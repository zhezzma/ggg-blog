[{"data":1,"prerenderedAt":957},["Reactive",2],{"content-query-RP5KATRe3c":3,"content-navigation-8C37fagqQL":375},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":369,"_id":370,"_source":371,"_file":372,"_extension":373,"date":374},"/game/2021-01-23-spelunky-map","game",false,"","Spelunky关卡生成","关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。",{"type":11,"children":12,"toc":366},"root",[13,22,27,32,40,56,63,68,93,98,103,108,113,118,123,128,133,140,149,155,162,167,174,184,189,255,260,265,270,275,280,285,312,317,322,327,336,345],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"part1-创建solution-path-关卡通路",[19],{"type":20,"value":21},"text","Part1. 创建Solution path - 关卡通路",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":9},{"type":14,"tag":23,"props":28,"children":29},{},[30],{"type":20,"value":31},"算法的第一部分是生成关卡的 Critical Path（通路），关卡由 16 个房间按照 4x4 的网格组成。方法是先在第一排随机找到一个起始房间，然后随机使相邻的房间成为通路的一部分，一直到最后一排，生成出口。找到通路之后，连接这些房间，然后再随机补充上非通路部分的房间，打通这些房间。如图顺序所示：",{"type":14,"tag":23,"props":33,"children":34},{},[35],{"type":14,"tag":36,"props":37,"children":39},"img",{"alt":36,"src":38},"/images/2021-01-23-Spelunky-map/spelunky-map-generation-steps.gif",[],{"type":14,"tag":23,"props":41,"children":42},{},[43,45,54],{"type":20,"value":44},"然后为这些房间随机选取对应的预定义好的关卡模块。根据 Spelunky 的教学文章[",{"type":14,"tag":46,"props":47,"children":51},"a",{"href":48,"rel":49},"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/#reference",[50],"nofollow",[52],{"type":20,"value":53},"3]",{"type":20,"value":55},"，这里有 4 种不同的房间类型：",{"type":14,"tag":23,"props":57,"children":58},{},[59],{"type":14,"tag":36,"props":60,"children":62},{"alt":36,"src":61},"/images/2021-01-23-Spelunky-map/8752-1519530045.png",[],{"type":14,"tag":23,"props":64,"children":65},{},[66],{"type":20,"value":67},"这个关卡由16个房间按照4x4的网格方式组成，这里有4种不同的房间类型：",{"type":14,"tag":69,"props":70,"children":71},"ul",{},[72,78,83,88],{"type":14,"tag":73,"props":74,"children":75},"li",{},[76],{"type":20,"value":77},"0：不在critical path上，不会产生任何出口（可被忽略的）次要房间 (感谢洋芋君指出之前的翻译问题)",{"type":14,"tag":73,"props":79,"children":80},{},[81],{"type":20,"value":82},"1：左右一定有出口",{"type":14,"tag":73,"props":84,"children":85},{},[86],{"type":20,"value":87},"2：左右下一定有出口，如果有2号room在上方，也一定有上方出口",{"type":14,"tag":73,"props":89,"children":90},{},[91],{"type":20,"value":92},"3：左右上一定有出口",{"type":14,"tag":23,"props":94,"children":95},{},[96],{"type":20,"value":97},"第一步在最顶部这行随机选取一格创建一个Start Room，房间类型对开始的房间来说没太大影响。一般来说，Start Room类型我们会选1或者2。",{"type":14,"tag":23,"props":99,"children":100},{},[101],{"type":20,"value":102},"每当一个Room被创建，首先总是类型1(左右)。",{"type":14,"tag":23,"props":104,"children":105},{},[106],{"type":20,"value":107},"然后要决定往哪边走。取一个均匀分布的随机数，从1到5。当1或2时，critical path向左；当3或4时，critical path向右；当5时，path向下。（当critical path碰到屏幕边缘，立即向下移动并同时切换左右方向。）",{"type":14,"tag":23,"props":109,"children":110},{},[111],{"type":20,"value":112},"这有个问题，如果我们向左或右移动，是OK的，因为我们创建的Room是一定有左右出口的。但我们要向下走，我们就得改变我们当前所在的房间了。所以生成器重写房间类型为2，覆盖当前的房间，现在我们可以向下移动了。",{"type":14,"tag":23,"props":114,"children":115},{},[116],{"type":20,"value":117},"当生成器移到下一个房间，会问我们最后创建的那个房间（也就是刚才我们头顶上那个）类型是不是2（底部有出口）。 如果是2，那么当前这个房间类型一定要是2或3（上方有出口）。因为2、3类型都有左右出口，启动算法从头再来一次。",{"type":14,"tag":23,"props":119,"children":120},{},[121],{"type":20,"value":122},"如果到了底部这一行，我们要尝试向下，那肯定不行了，我们放置一个Exit Room来取代向下的房间。",{"type":14,"tag":23,"props":124,"children":125},{},[126],{"type":20,"value":127},"现在我们已经生成了整个critical path（关卡通路，即图中那些暗红色的格子，游戏中是不显示的，这里只是为了举例）。接下来要做的最后一件事，我们要把4x4的网格中的空余部分放上类型为0的房间，这些房间并不在critical path上。这些房间在任何方向都不一定有出口，所以有时候会生成一些围墙。",{"type":14,"tag":23,"props":129,"children":130},{},[131],{"type":20,"value":132},"如果一列中有3或者4个Room 0，那这一列房间有几率成为一个蛇窝。如果我们要生成蛇窝的话，从上到下，放一列房间，类型为7 8 9，或者7 8 8 9，取决于我们希望这个蛇窝有多深。(这里的蛇和宝石并不像其他敌人那样随机生成，因为它们是这种地形的一部分，所以位置基本是固定出现。）",{"type":14,"tag":23,"props":134,"children":135},{},[136],{"type":14,"tag":36,"props":137,"children":139},{"alt":36,"src":138},"/images/2021-01-23-Spelunky-map/8752-1519530075.png_webp",[],{"type":14,"tag":23,"props":141,"children":142},{},[143],{"type":14,"tag":144,"props":145,"children":146},"em",{},[147],{"type":20,"value":148},"蛇窝",{"type":14,"tag":15,"props":150,"children":152},{"id":151},"part2-创建房间-关卡生成算法的第二部分生成room我们先不考虑那些障碍物陷阱敌人和宝箱什么的",[153],{"type":20,"value":154},"Part2. 创建房间 关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。",{"type":14,"tag":23,"props":156,"children":157},{},[158],{"type":14,"tag":36,"props":159,"children":161},{"alt":36,"src":160},"/images/2021-01-23-Spelunky-map/8752-1519530105.png_webp",[],{"type":14,"tag":23,"props":163,"children":164},{},[165],{"type":20,"value":166},"Spelunky并不像其他大部分游戏（平台游戏，platformer）在传统的2D tile-base的平台游戏中，你用关卡编辑器做出的地图可能看起来像这样：",{"type":14,"tag":23,"props":168,"children":169},{},[170],{"type":14,"tag":36,"props":171,"children":173},{"alt":36,"src":172},"/images/2021-01-23-Spelunky-map/8752-1519530119.png_webp",[],{"type":14,"tag":23,"props":175,"children":176},{},[177,179],{"type":20,"value":178},"在这种类型编辑器里，是这样的，比如，在（64,128）这个位置是草的tile。但Spelunky完全不是这样。\n上一部分我们了解了Spelunky有4种基本房间类型（types）。这每个房间类型有8-16个模板。这些模板具备一个房间的基本布局，包括一些静态和概率tile的组合。\nRoom Templates（房间模板）\n每个房间类型都有一堆不同的模板。\n",{"type":14,"tag":144,"props":180,"children":181},{},[182],{"type":20,"value":183},"译注：Derek Yu使用不同的布局，做了一系列的房间设计。比如你掉出去的房间（DROP）、掉入的房间（LANDING）、可以穿过的走廊（CORRIDOR）、不在关卡通路上的房间（NON-CRITICAL）。",{"type":14,"tag":23,"props":185,"children":186},{},[187],{"type":20,"value":188},"房间模板，嗯……看起来就像下面这样：",{"type":14,"tag":190,"props":191,"children":192},"blockquote",{},[193,201,209,217,225,233,240,247],{"type":14,"tag":190,"props":194,"children":195},{},[196],{"type":14,"tag":23,"props":197,"children":198},{},[199],{"type":20,"value":200},"1100000000",{"type":14,"tag":190,"props":202,"children":203},{},[204],{"type":14,"tag":23,"props":205,"children":206},{},[207],{"type":20,"value":208},"40L6000000",{"type":14,"tag":190,"props":210,"children":211},{},[212],{"type":14,"tag":23,"props":213,"children":214},{},[215],{"type":20,"value":216},"11P0000000",{"type":14,"tag":190,"props":218,"children":219},{},[220],{"type":14,"tag":23,"props":221,"children":222},{},[223],{"type":20,"value":224},"11L0000000",{"type":14,"tag":190,"props":226,"children":227},{},[228],{"type":14,"tag":23,"props":229,"children":230},{},[231],{"type":20,"value":232},"11L5000000",{"type":14,"tag":190,"props":234,"children":235},{},[236],{"type":14,"tag":23,"props":237,"children":238},{},[239],{"type":20,"value":200},{"type":14,"tag":190,"props":241,"children":242},{},[243],{"type":14,"tag":23,"props":244,"children":245},{},[246],{"type":20,"value":200},{"type":14,"tag":190,"props":248,"children":249},{},[250],{"type":14,"tag":23,"props":251,"children":252},{},[253],{"type":20,"value":254},"1111111111",{"type":14,"tag":23,"props":256,"children":257},{},[258],{"type":20,"value":259},"每个模板由10x8 的tile网格组成。\"0\"表示空，\"1\"表示100%是砖块，\"L\"是梯子，\"P\"是爬梯子上去的平台(platform)。现在你在看这个模板， 嗯，下面一排是地面，左边是2个tile宽的墙，上面有个小缺口，有个梯子可以爬到那。",{"type":14,"tag":23,"props":261,"children":262},{},[263],{"type":20,"value":264},"Static and Probabilistic Tiles( 静态和概率Tile )",{"type":14,"tag":23,"props":266,"children":267},{},[268],{"type":20,"value":269},"static tile就像传统关卡编辑器里一样，你让这里有个砖块，那这就永远是砖块了。",{"type":14,"tag":23,"props":271,"children":272},{},[273],{"type":20,"value":274},"上面模板里的\"4\" tile，就是probabilistic tile。\"4\"表示那有25%的几率会是一个能推动的障碍物，出现在梯子的顶部旁边。有经验的Spelunky玩家会一下认出这个：有时你爬到一个梯子顶部，旁边有个障碍物，你得推它，就可以进到下一个房间。有时候爬到梯子顶上旁边就没有这玩意。还有比如“这有33%的几率会出现个尖刺”，或者“这有一半的几率是空的，或者是砖块”。",{"type":14,"tag":23,"props":276,"children":277},{},[278],{"type":20,"value":279},"Obstacle Block( 障碍块）",{"type":14,"tag":23,"props":281,"children":282},{},[283],{"type":20,"value":284},"\"5\"和\"6\"就是所谓的Obstacle Block。Obstacle Block由 5x3 的tile网格组成，是个有趣的小结构，会让玩家针对这个障碍来思考自己的策略。Obstacle block本身也会由一些概率tile组成。下面是\"5\" 这个模板，表示放置在地上（\"6\"表示放置在空中）:",{"type":14,"tag":190,"props":286,"children":287},{},[288,296,304],{"type":14,"tag":190,"props":289,"children":290},{},[291],{"type":14,"tag":23,"props":292,"children":293},{},[294],{"type":20,"value":295},"00000",{"type":14,"tag":190,"props":297,"children":298},{},[299],{"type":14,"tag":23,"props":300,"children":301},{},[302],{"type":20,"value":303},"00102",{"type":14,"tag":190,"props":305,"children":306},{},[307],{"type":14,"tag":23,"props":308,"children":309},{},[310],{"type":20,"value":311},"71177",{"type":14,"tag":23,"props":313,"children":314},{},[315],{"type":20,"value":316},"规则和之前的一样，0是空，1是砖块。你能看出来，这是个小台阶。\"7\"有33%的几率是个尖刺，或者为空。如果运气不好，这里就得跳到那个台阶上面避开尖刺。\"2\"表示有一半的几率味空，或者是砖块。这就有意思了，有可能有个小砖块让你落脚不用踩到尖刺，也有可能除了小台阶，旁边都是空的，玩家得跳到上面去。你可以看出，这么个小障碍块，如果设计的好的话，游戏自己就会随机生成很多很多有意思的场景。",{"type":14,"tag":23,"props":318,"children":319},{},[320],{"type":20,"value":321},"译于2018-Jan-20",{"type":14,"tag":23,"props":323,"children":324},{},[325],{"type":20,"value":326},"原文链接最好用chrome打开，对，要科学，你懂了",{"type":14,"tag":23,"props":328,"children":329},{},[330],{"type":14,"tag":46,"props":331,"children":334},{"href":332,"rel":333},"http://tinysubversions.com/spelunkyGen/",[50],[335],{"type":20,"value":332},{"type":14,"tag":23,"props":337,"children":338},{},[339],{"type":14,"tag":46,"props":340,"children":343},{"href":341,"rel":342},"http://tinysubversions.com/spelunkyGen2/",[50],[344],{"type":20,"value":341},{"type":14,"tag":69,"props":346,"children":347},{},[348,357],{"type":14,"tag":73,"props":349,"children":350},{},[351],{"type":14,"tag":46,"props":352,"children":355},{"href":353,"rel":354},"https://indienova.com/u/root/blogread/5454",[50],[356],{"type":20,"value":353},{"type":14,"tag":73,"props":358,"children":359},{},[360],{"type":14,"tag":46,"props":361,"children":364},{"href":362,"rel":363},"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/",[50],[365],{"type":20,"value":362},{"title":7,"searchDepth":367,"depth":367,"links":368},2,[],"markdown","content:game:2021-01-23-Spelunky-map.md","content","game/2021-01-23-Spelunky-map.md","md","2021-01-23",[376,386,513,560,612,625,737],{"title":377,"_path":378,"children":379},"Art","/art",[380,383],{"title":381,"_path":382},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":384,"_path":385},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":387,"_path":388,"children":389},"Dotnet","/dotnet",[390,393,396,399,402,405,408,411,414,417,420,423,426,429,432,435,438,441,444,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492,495,498,501,504,507,510],{"title":391,"_path":392},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":394,"_path":395},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":397,"_path":398},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":400,"_path":401},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":403,"_path":404},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":406,"_path":407},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":409,"_path":410},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":412,"_path":413},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":415,"_path":416},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":418,"_path":419},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":421,"_path":422},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":424,"_path":425},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":427,"_path":428},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":430,"_path":431},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":433,"_path":434},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":436,"_path":437},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":439,"_path":440},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":442,"_path":443},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":445,"_path":446},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":448,"_path":449},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":451,"_path":452},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":454,"_path":455},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":457,"_path":458},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":460,"_path":461},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":463,"_path":464},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":466,"_path":467},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":469,"_path":470},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":472,"_path":473},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":475,"_path":476},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":478,"_path":479},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":481,"_path":482},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":484,"_path":485},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":487,"_path":488},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":490,"_path":491},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":493,"_path":494},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":496,"_path":497},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":499,"_path":500},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":502,"_path":503},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":505,"_path":506},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":508,"_path":509},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":511,"_path":512},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":514,"_path":515,"children":516},"Game","/game",[517,520,523,526,529,530,533,536,539,542,545,548,551,554,557],{"title":518,"_path":519},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":521,"_path":522},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":524,"_path":525},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":527,"_path":528},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":8,"_path":4},{"title":531,"_path":532},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":534,"_path":535},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":537,"_path":538},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":540,"_path":541},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":543,"_path":544},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":546,"_path":547},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":549,"_path":550},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":552,"_path":553},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":555,"_path":556},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":558,"_path":559},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":561,"_path":562,"children":563},"Gyj","/gyj",[564,567,570,573,576,579,582,585,588,591,594,597,600,603,606,609],{"title":565,"_path":566},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":568,"_path":569},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":571,"_path":572},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":574,"_path":575},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":577,"_path":578},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":580,"_path":581},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":583,"_path":584},"玩法","/gyj/2022-08-22-wanfa",{"title":586,"_path":587},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":589,"_path":590},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":592,"_path":593},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":595,"_path":596},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":598,"_path":599},"门派内容相关","/gyj/2022-11-17-sect",{"title":601,"_path":602},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":604,"_path":605},"种植","/gyj/2022-12-01-zhongzhi",{"title":607,"_path":608},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":610,"_path":611},"跑商","/gyj/2023-11-01-paoshang",{"title":613,"_path":614,"children":615},"Js","/js",[616,619,622],{"title":617,"_path":618},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":620,"_path":621},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":623,"_path":624},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":626,"_path":627,"children":628},"Tool","/tool",[629,632,635,638,641,644,647,650,653,656,659,662,665,668,671,674,677,680,683,686,689,692,695,698,701,704,707,710,713,716,719,722,725,728,731,734],{"title":630,"_path":631},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":633,"_path":634},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":636,"_path":637},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":639,"_path":640},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":642,"_path":643},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":645,"_path":646},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":648,"_path":649},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":651,"_path":652},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":654,"_path":655},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":657,"_path":658},"mac下brew 使用","/tool/2020-01-13-brew",{"title":660,"_path":661},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":663,"_path":664},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":666,"_path":667},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":669,"_path":670},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":672,"_path":673},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":675,"_path":676},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":678,"_path":679},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":681,"_path":682},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":684,"_path":685},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":687,"_path":688},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":690,"_path":691},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":693,"_path":694},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":696,"_path":697},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":699,"_path":700},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":702,"_path":703},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":705,"_path":706},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":708,"_path":709},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":711,"_path":712},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":714,"_path":715},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":717,"_path":718},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":720,"_path":721},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":723,"_path":724},"rider的使用","/tool/2022-08-02-rider-use",{"title":726,"_path":727},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":729,"_path":730},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":732,"_path":733},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":735,"_path":736},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":738,"_path":739,"children":740},"Unity","/unity",[741,744,747,750,753,756,759,762,765,768,771,774,777,780,783,786,789,792,795,798,801,804,807,810,813,816,819,822,825,828,831,834,837,840,843,846,849,852,855,858,861,864,867,870,873,876,879,882,885,888,891,894,897,900,903,906,909,912,915,918,921,924,927,930,933,936,939,942,945,948,951,954],{"title":742,"_path":743},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":745,"_path":746},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":748,"_path":749},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":751,"_path":752},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":754,"_path":755},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":757,"_path":758},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":760,"_path":761},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":763,"_path":764},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":766,"_path":767},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":769,"_path":770},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":772,"_path":773},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":775,"_path":776},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":778,"_path":779},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":781,"_path":782},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":784,"_path":785},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":787,"_path":788},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":790,"_path":791},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":793,"_path":794},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":796,"_path":797},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":799,"_path":800},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":802,"_path":803},"技能系统","/unity/2020-02-15-skill-system",{"title":805,"_path":806},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":808,"_path":809},"角色状态设计","/unity/2020-02-17-character-states",{"title":811,"_path":812},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":814,"_path":815},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":817,"_path":818},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":820,"_path":821},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":823,"_path":824},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":826,"_path":827},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":829,"_path":830},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":832,"_path":833},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":835,"_path":836},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":838,"_path":839},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":841,"_path":842},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":844,"_path":845},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":847,"_path":848},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":850,"_path":851},"unity的addressables","/unity/2020-09-12-addressables",{"title":853,"_path":854},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":856,"_path":857},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":859,"_path":860},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":862,"_path":863},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":865,"_path":866},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":868,"_path":869},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":871,"_path":872},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":874,"_path":875},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":877,"_path":878},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":880,"_path":881},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":883,"_path":884},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":886,"_path":887},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":889,"_path":890},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":892,"_path":893},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":895,"_path":896},"简单保存工具","/unity/2020-11-13-simple-save",{"title":898,"_path":899},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":901,"_path":902},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":904,"_path":905},"ability","/unity/2020-11-16-dotssample",{"title":907,"_path":908},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":910,"_path":911},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":913,"_path":914},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":916,"_path":917},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":919,"_path":920},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":922,"_path":923},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":925,"_path":926},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":928,"_path":929},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":931,"_path":932},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":934,"_path":935},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":937,"_path":938},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":940,"_path":941},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":943,"_path":944},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":946,"_path":947},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":949,"_path":950},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":952,"_path":953},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":955,"_path":956},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779036492]