[{"data":1,"prerenderedAt":1047},["Reactive",2],{"content-query-jpGMpKMjNF":3,"content-navigation-8C37fagqQL":465},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":459,"_id":460,"_source":461,"_file":462,"_extension":463,"date":464},"/game/2021-01-22-civ-map","game",false,"","文明6地图生成算法","作者：哈里叔叔\n链接：https://www.zhihu.com/question/52019284/answer/1476187895\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",{"type":11,"children":12,"toc":450},"root",[13,31,37,42,55,67,72,93,102,107,112,123,131,136,141,152,157,162,170,175,186,194,207,218,239,244,249,260,268,273,294,299,310,315,326,334,339,344,349,360,368,373,384,389,394,405,410,421,426,437,442,447],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18,21,29],{"type":19,"value":20},"text","作者：哈里叔叔\n链接：",{"type":14,"tag":22,"props":23,"children":27},"a",{"href":24,"rel":25},"https://www.zhihu.com/question/52019284/answer/1476187895",[26],"nofollow",[28],{"type":19,"value":24},{"type":19,"value":30},"\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",{"type":14,"tag":32,"props":33,"children":35},"h3",{"id":34},"对称性对抗游戏简介",[36],{"type":19,"value":34},{"type":14,"tag":15,"props":38,"children":39},{},[40],{"type":19,"value":41},"对称性对抗游戏是指参与游戏的玩家所拥有的资源、交互方式、受制规则、最终目标是相同或相近的，是一种公平、对称的零和游戏。如《英雄无敌》《文明》《卡坦岛》等游戏。",{"type":14,"tag":15,"props":43,"children":44},{},[45,47,53],{"type":19,"value":46},"我们参考文明的4X要素[",{"type":14,"tag":22,"props":48,"children":50},{"href":49},"#ref_1",[51],{"type":19,"value":52},"1]",{"type":19,"value":54},"搭建了一个多人回合制战略游戏，如下图所示：地图开始被“战争迷雾”所覆盖。玩家必须派遣探险者进入这片迷雾中，以揭露要扩张的土地，要开发的资源以及要消灭的对手。",{"type":14,"tag":15,"props":56,"children":57},{},[58,63],{"type":14,"tag":59,"props":60,"children":62},"img",{"alt":59,"src":61},"/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_hd.jpg",[],{"type":14,"tag":59,"props":64,"children":66},{"alt":59,"src":65},"/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_720w.jpg",[],{"type":14,"tag":32,"props":68,"children":70},{"id":69},"地图的平衡性指标",[71],{"type":19,"value":69},{"type":14,"tag":15,"props":73,"children":74},{},[75,77,83,85,91],{"type":19,"value":76},"我们参考[",{"type":14,"tag":22,"props":78,"children":80},{"href":79},"#ref_2",[81],{"type":19,"value":82},"2]",{"type":19,"value":84},"[",{"type":14,"tag":22,"props":86,"children":88},{"href":87},"#ref_3",[89],{"type":19,"value":90},"3]",{"type":19,"value":92},"两篇参考文献制定出评估对称性对抗游戏地图平衡性的两点指标。",{"type":14,"tag":15,"props":94,"children":95},{},[96],{"type":14,"tag":97,"props":98,"children":99},"strong",{},[100],{"type":19,"value":101},"1. 战略特征（Strategic Feature）",{"type":14,"tag":15,"props":103,"children":104},{},[105],{"type":19,"value":106},"战略特征是指玩家在游戏中可以利用的战略资源。 战略特征的平衡是指每一名玩家在一定时间内获得基本相同的资源（包括类型和数量）。",{"type":14,"tag":15,"props":108,"children":109},{},[110],{"type":19,"value":111},"下面两张图显示了两名玩家战略特征不平衡的情况，蓝色玩家初始时可以获得更多的矿产资源，而黄色玩家的出生点附近几乎没有矿产资源，这会导致游戏初期黄色玩家的发展受限。",{"type":14,"tag":15,"props":113,"children":114},{},[115,119],{"type":14,"tag":59,"props":116,"children":118},{"alt":59,"src":117},"/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_hd.jpg",[],{"type":14,"tag":59,"props":120,"children":122},{"alt":59,"src":121},"/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_720w.jpg",[],{"type":14,"tag":15,"props":124,"children":125},{},[126],{"type":14,"tag":97,"props":127,"children":128},{},[129],{"type":19,"value":130},"2. 玩家占位符（player placeholder）",{"type":14,"tag":15,"props":132,"children":133},{},[134],{"type":19,"value":135},"玩家初始的出生点占位的分布也会影响游戏的平衡性。",{"type":14,"tag":15,"props":137,"children":138},{},[139],{"type":19,"value":140},"下面两张图显示了玩家初始占位符分布密度不同导致游戏性不平衡的情况。左图的玩家初始分布密集，这会导致这个地区的玩家在游戏前期相互碾压、发展受限；而右图中的黄色玩家在游戏前期缺少竞争，能够更好地发展自身建设。",{"type":14,"tag":15,"props":142,"children":143},{},[144,148],{"type":14,"tag":59,"props":145,"children":147},{"alt":59,"src":146},"/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_hd.jpg",[],{"type":14,"tag":59,"props":149,"children":151},{"alt":59,"src":150},"/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_720w.jpg",[],{"type":14,"tag":15,"props":153,"children":154},{},[155],{"type":19,"value":156},"除了以上两点对游戏平衡性的影响之外，战略游戏地图的随机地图还要考虑到：地图的美观性、根据玩家的偏好定制参数、生成地图的效率等要求。",{"type":14,"tag":32,"props":158,"children":160},{"id":159},"地图的生成过程",[161],{"type":19,"value":159},{"type":14,"tag":15,"props":163,"children":164},{},[165],{"type":14,"tag":97,"props":166,"children":167},{},[168],{"type":19,"value":169},"1. 根据玩家的偏好定制地图参数",{"type":14,"tag":15,"props":171,"children":172},{},[173],{"type":19,"value":174},"在新建游戏之前，我们会让玩家根据自己的喜好定制地图参数，包括地图的尺寸、玩家的总数量、地图的类型（盘古大陆、大洲、海岛群）、水体比例、植被比例、岩石比例与资源的比例等。",{"type":14,"tag":15,"props":176,"children":177},{},[178,182],{"type":14,"tag":59,"props":179,"children":181},{"alt":59,"src":180},"/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_hd.jpg",[],{"type":14,"tag":59,"props":183,"children":185},{"alt":59,"src":184},"/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_720w.jpg",[],{"type":14,"tag":15,"props":187,"children":188},{},[189],{"type":14,"tag":97,"props":190,"children":191},{},[192],{"type":19,"value":193},"2. 生成地图的轮廓：柏林噪声",{"type":14,"tag":15,"props":195,"children":196},{},[197,199,205],{"type":19,"value":198},"柏林噪声（Perlin noise）指由Ken Perlin发明的自然噪声生成算法[",{"type":14,"tag":22,"props":200,"children":202},{"href":201},"#ref_4",[203],{"type":19,"value":204},"4]",{"type":19,"value":206},"。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。如下图所示：",{"type":14,"tag":15,"props":208,"children":209},{},[210,214],{"type":14,"tag":59,"props":211,"children":213},{"alt":59,"src":212},"/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_hd.jpg",[],{"type":14,"tag":59,"props":215,"children":217},{"alt":59,"src":216},"/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_720w.jpg",[],{"type":14,"tag":15,"props":219,"children":220},{},[221,223,230,231,237],{"type":19,"value":222},"与椒盐噪声相比，柏林噪声有较好的连续性分布，可以更好的模拟自然界中的地形分布与地表装饰物分布。利用柏林噪声生成自然地图可以参考B站视频：",{"type":14,"tag":22,"props":224,"children":227},{"href":225,"rel":226},"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1sJ411e7nt",[26],[228],{"type":19,"value":229},"柏林噪声程序化生成随机地图",{"type":19,"value":84},{"type":14,"tag":22,"props":232,"children":234},{"href":233},"#ref_5",[235],{"type":19,"value":236},"5]",{"type":19,"value":238},"。",{"type":14,"tag":15,"props":240,"children":241},{},[242],{"type":19,"value":243},"柏林噪声的生成采用伪随机数的生成方式，相同的“随机数种子”会生成相同的地貌。这也是很多随机地图生成器中会暴露“种子”让玩家根据种子生成地图的原因。如果想跟好朋友分享某个生成结果比较好的地图，只需要共享“种子”字符串，就能在随机地图生成器中还原出所生成的地形，而不需要把整个地图文件保存到本地再分享。",{"type":14,"tag":15,"props":245,"children":246},{},[247],{"type":19,"value":248},"Unity官方自带生成柏林函数的函数。我们引用了柏林噪声js库来进行地形的实现。我们利用柏林噪声的采样尺度来决定地图的类型是连续的大陆型地图还是离散的大洲型地图；将随机取到的连续噪声均衡化作为地图的高度图，根据用户设置的水体占比来制定海平面高度，最终生成的地形结果如下图所示：",{"type":14,"tag":15,"props":250,"children":251},{},[252,256],{"type":14,"tag":59,"props":253,"children":255},{"alt":59,"src":254},"/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_hd.jpg",[],{"type":14,"tag":59,"props":257,"children":259},{"alt":59,"src":258},"/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_720w.jpg",[],{"type":14,"tag":15,"props":261,"children":262},{},[263],{"type":14,"tag":97,"props":264,"children":265},{},[266],{"type":19,"value":267},"3. 玩家出生点的选择：米切尔最佳候选算法",{"type":14,"tag":15,"props":269,"children":270},{},[271],{"type":19,"value":272},"为了保证每位玩家两两之间的初始分布不会过近，我们在生成游戏地形后，在陆地上对玩家初始占位符进行均匀采样。为了兼顾效果与效率，我们最终选用米切尔最佳候选 算法（best candidate）。",{"type":14,"tag":15,"props":274,"children":275},{},[276,278,285,286,292],{"type":19,"value":277},"米切尔最佳候选算法是一种渐进、增量式的均匀采样方法。它每一轮采样都是从多个随机采样点中，保留与之前轮的所有采样点中最小距离最大的点作为本轮的采样结果。更加具体直观的算法解释可以参考:",{"type":14,"tag":22,"props":279,"children":282},{"href":280,"rel":281},"https://link.zhihu.com/?target=https%3A//bindog.github.io/blog/2014/08/09/visualizing-algorithms/",[26],[283],{"type":19,"value":284},"算法可视化",{"type":19,"value":84},{"type":14,"tag":22,"props":287,"children":289},{"href":288},"#ref_6",[290],{"type":19,"value":291},"6]",{"type":19,"value":293},"中有关米切尔候选算法的部分",{"type":14,"tag":15,"props":295,"children":296},{},[297],{"type":19,"value":298},"如下图所示：黑色点是之前轮已经确定的采样点，灰色点是本轮随机采样的候选点，每个候选点都选出与之前轮采样点中距离最近的距离，再从中选出最小距离最大的红色点作为本轮采样的结果。",{"type":14,"tag":15,"props":300,"children":301},{},[302,306],{"type":14,"tag":59,"props":303,"children":305},{"alt":59,"src":304},"/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_hd.jpg",[],{"type":14,"tag":59,"props":307,"children":309},{"alt":59,"src":308},"/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_720w.jpg",[],{"type":14,"tag":15,"props":311,"children":312},{},[313],{"type":19,"value":314},"利用这种采样方式采样出玩家的初始占位符，可以避免任意两个玩家之间的距离过近导致游戏平衡性被破坏，如下图所示：",{"type":14,"tag":15,"props":316,"children":317},{},[318,322],{"type":14,"tag":59,"props":319,"children":321},{"alt":59,"src":320},"/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_hd.jpg",[],{"type":14,"tag":59,"props":323,"children":325},{"alt":59,"src":324},"/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_720w.jpg",[],{"type":14,"tag":15,"props":327,"children":328},{},[329],{"type":14,"tag":97,"props":330,"children":331},{},[332],{"type":19,"value":333},"4. 战略资源的分布",{"type":14,"tag":15,"props":335,"children":336},{},[337],{"type":19,"value":338},"采样出玩家的分布之后，我们将地图单元格分为两种类型：每个玩家占位符附近距离N以内的单元格为玩家区域（Player Zones），不隶属于任何玩家区域的单元格被称为隔离区或自然区（Natural Zones）。",{"type":14,"tag":15,"props":340,"children":341},{},[342],{"type":19,"value":343},"为了让每名玩家在游戏初始时具有公平的战略特征，我们对每位玩家的玩家区域内定额分配植被、岩石与矿产资源。根据用户设定的植被、岩石与资源占比分别计算出每位玩家区应当分配到的植被、岩石与资源数量，然后在每个玩家区域内不重不漏地采样出相等数量的植被、岩石与资源单元格。",{"type":14,"tag":15,"props":345,"children":346},{},[347],{"type":19,"value":348},"对于自然区，我们按照玩家设置的参数，采用米切尔候选算法均匀采样每一种资源。这样可以保证每位玩家在游戏初始时能够得到数量一致的战略特征。如下图所示：",{"type":14,"tag":15,"props":350,"children":351},{},[352,356],{"type":14,"tag":59,"props":353,"children":355},{"alt":59,"src":354},"/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_hd.jpg",[],{"type":14,"tag":59,"props":357,"children":359},{"alt":59,"src":358},"/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_720w.jpg",[],{"type":14,"tag":15,"props":361,"children":362},{},[363],{"type":14,"tag":97,"props":364,"children":365},{},[366],{"type":19,"value":367},"5. 边界情况处理",{"type":14,"tag":15,"props":369,"children":370},{},[371],{"type":19,"value":372},"用以上方式生成的地图在某些情况下会产生不好的结果，例如当水体比例过低时生成海岛地形，会导致水体不够划分不出海岛地形；当水体比例过高时，会由于陆地单元格分布不均导致出生在不同规模大小的岛屿上的玩家能够得到的战略资源再度失衡。对于这些边界情况，我们利用种子生长与泛洪填充等启发式生成方法生成地图，优先保证地图类型能够满足用户的需求，并尽可能保证水体与各种战略特征的资源逼近用户的设定。以下是我们在水体占比过低与水体占比过高时生成的地图，可以看出在这两种情况下依然能够保证所生成地图的平衡性：",{"type":14,"tag":15,"props":374,"children":375},{},[376,380],{"type":14,"tag":59,"props":377,"children":379},{"alt":59,"src":378},"/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_hd.jpg",[],{"type":14,"tag":59,"props":381,"children":383},{"alt":59,"src":382},"/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_720w.jpg",[],{"type":14,"tag":32,"props":385,"children":387},{"id":386},"生成地图质量的定量评估",[388],{"type":19,"value":386},{"type":14,"tag":15,"props":390,"children":391},{},[392],{"type":19,"value":393},"为了判断我们的生成随机地图算法是否具有良好的平衡性指标，我们设计了一套地图自动扩张算法：每个玩家以出生点占位符为种子，轮流从目前领土所毗邻的无人单元格中抽取一个进行占领以扩张势力范围，直到地图中所有的单元格都被有且只有一个玩家占领；然后我们统计每个玩家占领到的资源数量、距离最近的敌人距离，以及每个玩家与多少数量的玩家领土相邻。如下图所示：",{"type":14,"tag":15,"props":395,"children":396},{},[397,401],{"type":14,"tag":59,"props":398,"children":400},{"alt":59,"src":399},"/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_hd.jpg",[],{"type":14,"tag":59,"props":402,"children":404},{"alt":59,"src":403},"/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_720w.jpg",[],{"type":14,"tag":15,"props":406,"children":407},{},[408],{"type":19,"value":409},"实验组是我们的算法生成的地图，对照组是根据水体与各种资源的比例随机采样地形、随机采样玩家分布得到的地图。如下方左侧是实验组生成的地图，右侧是对照组生成的地图：",{"type":14,"tag":15,"props":411,"children":412},{},[413,417],{"type":14,"tag":59,"props":414,"children":416},{"alt":59,"src":415},"/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_hd.jpg",[],{"type":14,"tag":59,"props":418,"children":420},{"alt":59,"src":419},"/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_720w.jpg",[],{"type":14,"tag":15,"props":422,"children":423},{},[424],{"type":19,"value":425},"实验组与对照组各生成100次地图，统计每个玩家与其他势力最小距离的均值与方差、扩张完成后各资源占有量的均值与方差以及每位玩家潜在冲突势力的均值与方差，统计的结果如下所示：",{"type":14,"tag":15,"props":427,"children":428},{},[429,433],{"type":14,"tag":59,"props":430,"children":432},{"alt":59,"src":431},"/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_hd.jpg",[],{"type":14,"tag":59,"props":434,"children":436},{"alt":59,"src":435},"/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_720w.jpg",[],{"type":14,"tag":15,"props":438,"children":439},{},[440],{"type":19,"value":441},"通过定量的统计结果可以看出，我们的方法生成的地图，玩家之间有更大的平均极小距离，这说明每位玩家的出生点占位符设置更加平衡；各种资源的分布方差均比对照组小，说明我们的战略特征分配与朴素的随机生成的地图相比更加均衡。",{"type":14,"tag":15,"props":443,"children":444},{},[445],{"type":19,"value":446},"综上所述，我们的地图生成结果能够保证对称性多人对抗战略游戏的平衡性。",{"type":14,"tag":32,"props":448,"children":449},{"id":7},[],{"title":7,"searchDepth":451,"depth":451,"links":452},2,[453,455,456,457,458],{"id":34,"depth":454,"text":34},3,{"id":69,"depth":454,"text":69},{"id":159,"depth":454,"text":159},{"id":386,"depth":454,"text":386},{"id":7,"depth":454,"text":7},"markdown","content:game:2021-01-22-civ-map.md","content","game/2021-01-22-civ-map.md","md","2021-01-22",[466,476,603,650,702,715,827],{"title":467,"_path":468,"children":469},"Art","/art",[470,473],{"title":471,"_path":472},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":474,"_path":475},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":477,"_path":478,"children":479},"Dotnet","/dotnet",[480,483,486,489,492,495,498,501,504,507,510,513,516,519,522,525,528,531,534,537,540,543,546,549,552,555,558,561,564,567,570,573,576,579,582,585,588,591,594,597,600],{"title":481,"_path":482},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":484,"_path":485},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":487,"_path":488},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":490,"_path":491},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":493,"_path":494},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":496,"_path":497},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":499,"_path":500},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":502,"_path":503},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":505,"_path":506},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":508,"_path":509},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":511,"_path":512},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":514,"_path":515},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":517,"_path":518},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":520,"_path":521},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":523,"_path":524},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":526,"_path":527},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":529,"_path":530},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":532,"_path":533},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":535,"_path":536},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":538,"_path":539},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":541,"_path":542},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":544,"_path":545},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":547,"_path":548},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":550,"_path":551},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":553,"_path":554},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":556,"_path":557},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":559,"_path":560},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":562,"_path":563},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":565,"_path":566},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":568,"_path":569},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":571,"_path":572},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":574,"_path":575},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":577,"_path":578},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":580,"_path":581},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":583,"_path":584},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":586,"_path":587},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":589,"_path":590},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":592,"_path":593},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":595,"_path":596},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":598,"_path":599},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":601,"_path":602},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":604,"_path":605,"children":606},"Game","/game",[607,610,613,614,617,620,623,626,629,632,635,638,641,644,647],{"title":608,"_path":609},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":611,"_path":612},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":8,"_path":4},{"title":615,"_path":616},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":618,"_path":619},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":621,"_path":622},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":624,"_path":625},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":627,"_path":628},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":630,"_path":631},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":633,"_path":634},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":636,"_path":637},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":639,"_path":640},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":642,"_path":643},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":645,"_path":646},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":648,"_path":649},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":651,"_path":652,"children":653},"Gyj","/gyj",[654,657,660,663,666,669,672,675,678,681,684,687,690,693,696,699],{"title":655,"_path":656},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":658,"_path":659},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":661,"_path":662},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":664,"_path":665},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":667,"_path":668},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":670,"_path":671},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":673,"_path":674},"玩法","/gyj/2022-08-22-wanfa",{"title":676,"_path":677},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":679,"_path":680},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":682,"_path":683},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":685,"_path":686},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":688,"_path":689},"门派内容相关","/gyj/2022-11-17-sect",{"title":691,"_path":692},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":694,"_path":695},"种植","/gyj/2022-12-01-zhongzhi",{"title":697,"_path":698},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":700,"_path":701},"跑商","/gyj/2023-11-01-paoshang",{"title":703,"_path":704,"children":705},"Js","/js",[706,709,712],{"title":707,"_path":708},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":710,"_path":711},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":713,"_path":714},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":716,"_path":717,"children":718},"Tool","/tool",[719,722,725,728,731,734,737,740,743,746,749,752,755,758,761,764,767,770,773,776,779,782,785,788,791,794,797,800,803,806,809,812,815,818,821,824],{"title":720,"_path":721},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":723,"_path":724},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":726,"_path":727},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":729,"_path":730},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":732,"_path":733},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":735,"_path":736},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":738,"_path":739},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":741,"_path":742},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":744,"_path":745},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":747,"_path":748},"mac下brew 使用","/tool/2020-01-13-brew",{"title":750,"_path":751},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":753,"_path":754},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":756,"_path":757},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":759,"_path":760},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":762,"_path":763},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":765,"_path":766},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":768,"_path":769},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":771,"_path":772},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":774,"_path":775},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":777,"_path":778},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":780,"_path":781},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":783,"_path":784},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":786,"_path":787},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":789,"_path":790},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":792,"_path":793},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":795,"_path":796},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":798,"_path":799},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":801,"_path":802},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":804,"_path":805},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":807,"_path":808},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":810,"_path":811},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":813,"_path":814},"rider的使用","/tool/2022-08-02-rider-use",{"title":816,"_path":817},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":819,"_path":820},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":822,"_path":823},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":825,"_path":826},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":828,"_path":829,"children":830},"Unity","/unity",[831,834,837,840,843,846,849,852,855,858,861,864,867,870,873,876,879,882,885,888,891,894,897,900,903,906,909,912,915,918,921,924,927,930,933,936,939,942,945,948,951,954,957,960,963,966,969,972,975,978,981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017,1020,1023,1026,1029,1032,1035,1038,1041,1044],{"title":832,"_path":833},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":835,"_path":836},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":838,"_path":839},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":841,"_path":842},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":844,"_path":845},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":847,"_path":848},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":850,"_path":851},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":853,"_path":854},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":856,"_path":857},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":859,"_path":860},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":862,"_path":863},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":865,"_path":866},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":868,"_path":869},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":871,"_path":872},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":874,"_path":875},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":877,"_path":878},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":880,"_path":881},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":883,"_path":884},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":886,"_path":887},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":889,"_path":890},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":892,"_path":893},"技能系统","/unity/2020-02-15-skill-system",{"title":895,"_path":896},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":898,"_path":899},"角色状态设计","/unity/2020-02-17-character-states",{"title":901,"_path":902},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":904,"_path":905},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":907,"_path":908},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":910,"_path":911},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":913,"_path":914},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":916,"_path":917},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":919,"_path":920},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":922,"_path":923},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":925,"_path":926},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":928,"_path":929},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":931,"_path":932},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":934,"_path":935},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":937,"_path":938},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":940,"_path":941},"unity的addressables","/unity/2020-09-12-addressables",{"title":943,"_path":944},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":946,"_path":947},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":949,"_path":950},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":952,"_path":953},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":955,"_path":956},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":958,"_path":959},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":961,"_path":962},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":964,"_path":965},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":967,"_path":968},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":970,"_path":971},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":973,"_path":974},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":976,"_path":977},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":979,"_path":980},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":982,"_path":983},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":985,"_path":986},"简单保存工具","/unity/2020-11-13-simple-save",{"title":988,"_path":989},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":991,"_path":992},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":994,"_path":995},"ability","/unity/2020-11-16-dotssample",{"title":997,"_path":998},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1000,"_path":1001},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1003,"_path":1004},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1006,"_path":1007},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1009,"_path":1010},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1012,"_path":1013},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1015,"_path":1016},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1018,"_path":1019},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1021,"_path":1022},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1024,"_path":1025},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1027,"_path":1028},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1030,"_path":1031},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1033,"_path":1034},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1036,"_path":1037},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1039,"_path":1040},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1042,"_path":1043},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1045,"_path":1046},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779036561]