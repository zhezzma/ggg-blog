[{"data":1,"prerenderedAt":952},["Reactive",2],{"content-query-3W9Fjz68Jt":3,"content-navigation-8C37fagqQL":370},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":364,"_id":365,"_source":366,"_file":367,"_extension":368,"date":369},"/game/2021-01-21-wave-collapse-function","game",false,"","波函数坍塌算法生成地图","什么是“波函数坍塌”？这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才",{"type":11,"children":12,"toc":355},"root",[13,22,28,33,38,43,48,77,82,87,92,97,113,120,147,152,157,162,167,192,197,202,207,212,229,234,247,252,257,264,269,274,279,307,312],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"什么是波函数坍塌",[19],{"type":20,"value":21},"text","什么是“波函数坍塌”？",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":27},"这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。",{"type":14,"tag":23,"props":29,"children":30},{},[31],{"type":20,"value":32},"这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才有了一个比较霸气的名字而已。",{"type":14,"tag":23,"props":34,"children":35},{},[36],{"type":20,"value":37},"开发这些模型或者贴图合成技术是为了能使用一块很小的由人工制作的贴图或者模型来生成大量相似的贴图或者模型。这样可以有效的减少人工作业，提升效率。当然可能有人会有这样的疑问，现在基于GAN的AI看起来能够生成又是动画又是图片的，还有这种技术存在的必要吗? 答案当然是有存在的必要，首先GAN需要海量的样本去训练，有生成这么多样本的劲，大概早就做完游戏了，其次是AI生成的不一定能满足业务需求，而且使用者并没有调教的可能性，而在做贴图或者模型合成时，实际上只需要一个样本就可以完成所有的工作了。接下来要简要介绍下基本的原理。",{"type":14,"tag":15,"props":39,"children":41},{"id":40},"基本原理",[42],{"type":20,"value":40},{"type":14,"tag":23,"props":44,"children":45},{},[46],{"type":20,"value":47},"“波函数坍塌“主要是依赖于样本相邻各点的布局结构，以这些结构作为特征，在一个更大的空间上生成满足样本结构约束的新数据。",{"type":14,"tag":23,"props":49,"children":50},{},[51,53,59,61,65,67,70,72,75],{"type":20,"value":52},"以贴图合成为例，假设在输入贴图中有且仅有一点坐标是 x,y，颜色为",{"type":14,"tag":54,"props":55,"children":58},"img",{"alt":56,"src":57},"[公式]","/images/2021-01-21-wave-collapse-function/6.svg",[],{"type":20,"value":60}," ，上下左右四个点的颜色分别是 ",{"type":14,"tag":54,"props":62,"children":64},{"alt":56,"src":63},"/images/2021-01-21-wave-collapse-function/5.svg",[],{"type":20,"value":66}," 。那么在输出贴图中，如果存在一点颜色为 ",{"type":14,"tag":54,"props":68,"children":69},{"alt":56,"src":57},[],{"type":20,"value":71}," ，那么它的上下左右四个点的颜色必须是 ",{"type":14,"tag":54,"props":73,"children":74},{"alt":56,"src":63},[],{"type":20,"value":76}," 。",{"type":14,"tag":23,"props":78,"children":79},{},[80],{"type":20,"value":81},"实际上我们可以建立更复杂的相邻布局约束，比如说以贴图中某个点周围的不仅上下左右，还有对角线上的4个点，总共八个点建立约束条件，甚至是上下左右四个点的上下左右总共12个点。不过本文只会探讨受上下左右四个点约束的情况。",{"type":14,"tag":23,"props":83,"children":84},{},[85],{"type":20,"value":86},"所以我们的算法就是根据输入贴图提供的这种约束关系来生成输出贴图。这是一个搜索的过程，实际上是一个np hard问题，也就是说，只有当我们搜索了所有的可能性时，才一定能获得一个结果，当然这个结果可能是成功合成贴图，也可能是失败了，当对最终生成图片存在外界约束时，会有更大的可能性失败。",{"type":14,"tag":23,"props":88,"children":89},{},[90],{"type":20,"value":91},"虽然以贴图为例来说明，但是本文的初衷是为了能够生2d游戏的地图，所以接下来将仅介绍2d下的离散模型合成技术。在2d游戏开发中，一般会用瓦片（tiles）贴图来构成地图，其中瓦片会有特定的几何形状，然后通过瓦片的放置来完成地图。本文以及提供的代码只会考虑正方形的瓦片，对于正方形瓦片来说就和上面的解释完全一致了。",{"type":14,"tag":23,"props":93,"children":94},{},[95],{"type":20,"value":96},"最后不得不列一下我觉得还蛮重要的公式，该公式描述了上文中提及的一致性约束。",{"type":14,"tag":23,"props":98,"children":99},{},[100,102,106,108,111],{"type":20,"value":101},"设输入模型为 E，输出模型为 M ，那么当 M与 E 一致时，则对于 M中任意一点 x ，存在 ",{"type":14,"tag":54,"props":103,"children":105},{"alt":56,"src":104},"/images/2021-01-21-wave-collapse-function/8.svg",[],{"type":20,"value":107}," ，且 ",{"type":14,"tag":54,"props":109,"children":110},{"alt":56,"src":104},[],{"type":20,"value":112}," 属于 E ，满足：",{"type":14,"tag":23,"props":114,"children":115},{},[116],{"type":14,"tag":54,"props":117,"children":119},{"alt":56,"src":118},"/images/2021-01-21-wave-collapse-function/7.svg",[],{"type":14,"tag":23,"props":121,"children":122},{},[123,125,128,130,134,136,140,142,146],{"type":20,"value":124},"其中， x 是 M中一点，而 ",{"type":14,"tag":54,"props":126,"children":127},{"alt":56,"src":104},[],{"type":20,"value":129}," 是 E中一点， ",{"type":14,"tag":54,"props":131,"children":133},{"alt":56,"src":132},"/images/2021-01-21-wave-collapse-function/9.svg",[],{"type":20,"value":135}," 则是几何纬度上正负向的单位向量，3维下是 ",{"type":14,"tag":54,"props":137,"children":139},{"alt":56,"src":138},"/images/2021-01-21-wave-collapse-function/4.svg",[],{"type":20,"value":141}," ，2维下则是 ",{"type":14,"tag":54,"props":143,"children":145},{"alt":56,"src":144},"/images/2021-01-21-wave-collapse-function/3.svg",[],{"type":20,"value":76},{"type":14,"tag":23,"props":148,"children":149},{},[150],{"type":20,"value":151},"接下来当然是要介绍具体的算法了。但是首先还是需要将问题重新描述一下。",{"type":14,"tag":15,"props":153,"children":155},{"id":154},"描述问题",[156],{"type":20,"value":154},{"type":14,"tag":23,"props":158,"children":159},{},[160],{"type":20,"value":161},"我们需要通过一个样例模型，然后给予一个种子来生成一个更大的模型。在2d情况下，模型会被描述为一个二维矩阵，矩阵中的每个点都是一个非负整数，不同的整数代表一个瓦片的种类，0表示空瓦片。我们需要设定输出模型的大小比如一个10*10的矩阵，然后通过一个特定的种子来生成随机数，根据这个随机数去遍历所有的可能性并找到一个合适的解。",{"type":14,"tag":23,"props":163,"children":164},{},[165],{"type":20,"value":166},"所以我们的程序至少需要做下面几件事：",{"type":14,"tag":168,"props":169,"children":170},"ol",{},[171,177,182,187],{"type":14,"tag":172,"props":173,"children":174},"li",{},[175],{"type":20,"value":176},"载入瓦片信息，种类编号和瓦片的图片。",{"type":14,"tag":172,"props":178,"children":179},{},[180],{"type":20,"value":181},"载入输入模型信息，即输入模型矩阵，矩阵的值为瓦片种类id，然后分析输入模型，得到约束条件矩阵。",{"type":14,"tag":172,"props":183,"children":184},{},[185],{"type":20,"value":186},"根据约束矩阵，以及随机数去搜索输出模型。",{"type":14,"tag":172,"props":188,"children":189},{},[190],{"type":20,"value":191},"输出（可视化）输出模型。",{"type":14,"tag":23,"props":193,"children":194},{},[195],{"type":20,"value":196},"显然，第三步是最为麻烦的，也是最困难的，其次是第二步，我们需要得到一个约束矩阵，然后第一和第四步都是常规操作。",{"type":14,"tag":15,"props":198,"children":200},{"id":199},"获得约束矩阵",[201],{"type":20,"value":199},{"type":14,"tag":23,"props":203,"children":204},{},[205],{"type":20,"value":206},"约束矩阵描述了在输入模型中，相邻点的布局关系。当我们为输出模型布局时，我们可以在某一点填入一个特定的瓦片id，然后当填充这个瓦片相邻的四个瓦片时，通过查询约束矩阵，我们可以知道在当前瓦片id下，它上方的位置只能是特定的几个id。同理就可以推导出其他三个瓦片能够选择的id。",{"type":14,"tag":23,"props":208,"children":209},{},[210],{"type":20,"value":211},"所以当生成一个2d模型时，需要4个约束矩阵，分别代表x轴正向，负向，和y轴正向，负向的约束。每个约束矩阵的长度为总的瓦片id数，宽度也是总的瓦片id数，其值为bool或者是0或1，用来表示当当前点上的瓦片id是某个值时，其相邻对应位置瓦片允许的值。",{"type":14,"tag":23,"props":213,"children":214},{},[215,217,221,223,227],{"type":20,"value":216},"写个简单的例子，对于输入模型矩阵 ",{"type":14,"tag":54,"props":218,"children":220},{"alt":56,"src":219},"/images/2021-01-21-wave-collapse-function/2.svg",[],{"type":20,"value":222}," 的正的右侧，也就是x轴正方向，可以得到如下的约束规则：0-1，1-2，2-3，2-1，1-0，0-0。整理成矩阵也就是 ",{"type":14,"tag":54,"props":224,"children":226},{"alt":56,"src":225},"/images/2021-01-21-wave-collapse-function/1.svg",[],{"type":20,"value":228}," ，这个矩阵等于它的转置矩阵，然后我们会有4个类似这样的约束矩阵对应不同方向的邻居，我们使用当前的瓦片id去查询就可以得到相邻瓦片允许填入的瓦片id了。",{"type":14,"tag":15,"props":230,"children":232},{"id":231},"搜索算法",[233],{"type":20,"value":231},{"type":14,"tag":23,"props":235,"children":236},{},[237,239,245],{"type":20,"value":238},"搜索算法部分是最为困难的部分了。我们需要保存一个记录矩阵（catalog），该矩阵与最终输出模型大小相同，比如输出模型是10",{"type":14,"tag":240,"props":241,"children":242},"em",{},[243],{"type":20,"value":244},"10的这个记录矩阵也是10",{"type":20,"value":246},"10的。在这个记录矩阵中，每个元素会是一个集合，表示当前该点可以填入的瓦片id的集合，当该点可填入瓦片id集合为空集时，说明走了一条错误的路径，需要回退。然后我们的搜索算法会按照之前走过来的路径回退到上一个操作点，同时这个记录矩阵也需要回退相应的步数。",{"type":14,"tag":23,"props":248,"children":249},{},[250],{"type":20,"value":251},"对于记录矩阵的回退，需要记录一个类似数据库的ahead log的东西，来记录所有对记录矩阵的操作，当产生回退时，只需要沿着这log向前恢复就可以。",{"type":14,"tag":23,"props":253,"children":254},{},[255],{"type":20,"value":256},"对于搜索算法的前进和回退，在我参考的论文里没有提及具体的方式，经过一段时间的尝试，我建立了一颗树来记录搜索的路径，当产生回退时，树的当前节点会被标记为不可通行，便不会向这片树枝搜索了。",{"type":14,"tag":23,"props":258,"children":259},{},[260],{"type":14,"tag":54,"props":261,"children":263},{"alt":54,"src":262},"/images/2021-01-21-wave-collapse-function/v2-37deccf09bca15112c03e8169fc3c525_720w.jpg",[],{"type":14,"tag":23,"props":265,"children":266},{},[267],{"type":20,"value":268},"如上图所示，灰色的节点表示还没探索到，实际上还不在树里，红色的节点表示需要回退的节点。蓝色的节点表示已探索或者待探索的节点，绿色的箭头表示已经探索的路径。",{"type":14,"tag":23,"props":270,"children":271},{},[272],{"type":20,"value":273},"五边形节点表示根节点，一旦在根节点发生回退说明，搜索失败，并没有找到合适的输出模型。正方形节点表示选择点操作，当游标在正方形节点上时，等于选取该节点记录的点为当前点。圆形节点则表示，为当前点选择了一个特定的瓦片，该瓦片的种类取决于记录矩阵在该点允许的选择，然后会根据约束矩阵，更新记录矩阵，当发现更新后记录矩阵存在空集便会回退。",{"type":14,"tag":23,"props":275,"children":276},{},[277],{"type":20,"value":278},"最终会有如下的搜索过程：",{"type":14,"tag":168,"props":280,"children":281},{},[282,287,292,297,302],{"type":14,"tag":172,"props":283,"children":284},{},[285],{"type":20,"value":286},"建立搜索树，找到所有的点，并将其放在根节点下边，随机选一个节点，将游标移动到该节点，设定该节点对应的点为当前节点，然后根据记录矩阵中的值，随机选择一个瓦片填入，并根据约束矩阵更新记录矩阵。",{"type":14,"tag":172,"props":288,"children":289},{},[290],{"type":20,"value":291},"找到剩余所有没有瓦片的点，将这些节点加入当前节点后面，然后将根据这些点与当前所选中的点的距离，计算一个权重，离得最近的会被最先搜索，如果没有新的节点可以选择，则生成成功。",{"type":14,"tag":172,"props":293,"children":294},{},[295],{"type":20,"value":296},"根据权重和生成的随机数以及选择一个节点，根据记录矩阵在该点的瓦片集合以及随机数为该节点选择一个瓦片，然后根据约束矩阵以及当前选择去更新记录矩阵中相邻点的记录：",{"type":14,"tag":172,"props":298,"children":299},{},[300],{"type":20,"value":301},"如果更新中发现某相邻点可选瓦片为空，则需要回退到上一个圆形节点，与此同时记录矩阵也要回退上一个圆形节点之后的操作，并将该节点标为禁止通行，并返回第2步，如果发现当前节点在根节点，则生成失败。",{"type":14,"tag":172,"props":303,"children":304},{},[305],{"type":20,"value":306},"如果不为空，则根据随机数选择一个瓦片填入，并根据约束矩阵更新记录矩阵，然后返回第2步。",{"type":14,"tag":15,"props":308,"children":310},{"id":309},"链接",[311],{"type":20,"value":309},{"type":14,"tag":313,"props":314,"children":315},"ul",{},[316,328,337,346],{"type":14,"tag":172,"props":317,"children":318},{},[319],{"type":14,"tag":320,"props":321,"children":325},"a",{"href":322,"rel":323},"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian%5C_docid=0M2y2bvM",[324],"nofollow",[326],{"type":20,"value":327},"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian\\_docid=0M2y2bvM",{"type":14,"tag":172,"props":329,"children":330},{},[331],{"type":14,"tag":320,"props":332,"children":335},{"href":333,"rel":334},"https://zhuanlan.zhihu.com/p/65495333",[324],[336],{"type":20,"value":333},{"type":14,"tag":172,"props":338,"children":339},{},[340],{"type":14,"tag":320,"props":341,"children":344},{"href":342,"rel":343},"https://github.com/mxgmn/WaveFunctionCollapse",[324],[345],{"type":20,"value":342},{"type":14,"tag":172,"props":347,"children":348},{},[349],{"type":14,"tag":320,"props":350,"children":353},{"href":351,"rel":352},"https://github.com/BorisTheBrave/DeBroglie",[324],[354],{"type":20,"value":351},{"title":7,"searchDepth":356,"depth":356,"links":357},2,[358,359,360,361,362,363],{"id":17,"depth":356,"text":21},{"id":40,"depth":356,"text":40},{"id":154,"depth":356,"text":154},{"id":199,"depth":356,"text":199},{"id":231,"depth":356,"text":231},{"id":309,"depth":356,"text":309},"markdown","content:game:2021-01-21-wave-collapse-function.md","content","game/2021-01-21-wave-collapse-function.md","md","2021-01-21",[371,381,508,555,607,620,732],{"title":372,"_path":373,"children":374},"Art","/art",[375,378],{"title":376,"_path":377},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":379,"_path":380},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":382,"_path":383,"children":384},"Dotnet","/dotnet",[385,388,391,394,397,400,403,406,409,412,415,418,421,424,427,430,433,436,439,442,445,448,451,454,457,460,463,466,469,472,475,478,481,484,487,490,493,496,499,502,505],{"title":386,"_path":387},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":389,"_path":390},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":392,"_path":393},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":395,"_path":396},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":398,"_path":399},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":401,"_path":402},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":404,"_path":405},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":407,"_path":408},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":410,"_path":411},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":413,"_path":414},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":416,"_path":417},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":419,"_path":420},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":422,"_path":423},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":425,"_path":426},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":428,"_path":429},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":431,"_path":432},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":434,"_path":435},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":437,"_path":438},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":440,"_path":441},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":443,"_path":444},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":446,"_path":447},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":449,"_path":450},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":452,"_path":453},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":455,"_path":456},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":458,"_path":459},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":461,"_path":462},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":464,"_path":465},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":467,"_path":468},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":470,"_path":471},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":473,"_path":474},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":476,"_path":477},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":479,"_path":480},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":482,"_path":483},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":485,"_path":486},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":488,"_path":489},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":491,"_path":492},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":494,"_path":495},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":497,"_path":498},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":500,"_path":501},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":503,"_path":504},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":506,"_path":507},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":509,"_path":510,"children":511},"Game","/game",[512,515,516,519,522,525,528,531,534,537,540,543,546,549,552],{"title":513,"_path":514},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":8,"_path":4},{"title":517,"_path":518},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":520,"_path":521},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":523,"_path":524},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":526,"_path":527},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":529,"_path":530},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":532,"_path":533},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":535,"_path":536},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":538,"_path":539},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":541,"_path":542},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":544,"_path":545},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":547,"_path":548},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":550,"_path":551},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":553,"_path":554},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":556,"_path":557,"children":558},"Gyj","/gyj",[559,562,565,568,571,574,577,580,583,586,589,592,595,598,601,604],{"title":560,"_path":561},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":563,"_path":564},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":566,"_path":567},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":569,"_path":570},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":572,"_path":573},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":575,"_path":576},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":578,"_path":579},"玩法","/gyj/2022-08-22-wanfa",{"title":581,"_path":582},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":584,"_path":585},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":587,"_path":588},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":590,"_path":591},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":593,"_path":594},"门派内容相关","/gyj/2022-11-17-sect",{"title":596,"_path":597},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":599,"_path":600},"种植","/gyj/2022-12-01-zhongzhi",{"title":602,"_path":603},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":605,"_path":606},"跑商","/gyj/2023-11-01-paoshang",{"title":608,"_path":609,"children":610},"Js","/js",[611,614,617],{"title":612,"_path":613},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":615,"_path":616},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":618,"_path":619},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":621,"_path":622,"children":623},"Tool","/tool",[624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675,678,681,684,687,690,693,696,699,702,705,708,711,714,717,720,723,726,729],{"title":625,"_path":626},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":628,"_path":629},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":631,"_path":632},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":634,"_path":635},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":637,"_path":638},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":640,"_path":641},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":643,"_path":644},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":646,"_path":647},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":649,"_path":650},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":652,"_path":653},"mac下brew 使用","/tool/2020-01-13-brew",{"title":655,"_path":656},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":658,"_path":659},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":661,"_path":662},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":664,"_path":665},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":667,"_path":668},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":670,"_path":671},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":673,"_path":674},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":676,"_path":677},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":679,"_path":680},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":682,"_path":683},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":685,"_path":686},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":688,"_path":689},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":691,"_path":692},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":694,"_path":695},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":697,"_path":698},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":700,"_path":701},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":703,"_path":704},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":706,"_path":707},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":709,"_path":710},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":712,"_path":713},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":715,"_path":716},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":718,"_path":719},"rider的使用","/tool/2022-08-02-rider-use",{"title":721,"_path":722},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":724,"_path":725},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":727,"_path":728},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":730,"_path":731},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":733,"_path":734,"children":735},"Unity","/unity",[736,739,742,745,748,751,754,757,760,763,766,769,772,775,778,781,784,787,790,793,796,799,802,805,808,811,814,817,820,823,826,829,832,835,838,841,844,847,850,853,856,859,862,865,868,871,874,877,880,883,886,889,892,895,898,901,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949],{"title":737,"_path":738},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":740,"_path":741},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":743,"_path":744},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":746,"_path":747},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":749,"_path":750},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":752,"_path":753},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":755,"_path":756},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":758,"_path":759},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":761,"_path":762},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":764,"_path":765},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":767,"_path":768},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":770,"_path":771},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":773,"_path":774},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":776,"_path":777},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":779,"_path":780},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":782,"_path":783},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":785,"_path":786},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":788,"_path":789},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":791,"_path":792},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":794,"_path":795},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":797,"_path":798},"技能系统","/unity/2020-02-15-skill-system",{"title":800,"_path":801},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":803,"_path":804},"角色状态设计","/unity/2020-02-17-character-states",{"title":806,"_path":807},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":809,"_path":810},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":812,"_path":813},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":815,"_path":816},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":818,"_path":819},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":821,"_path":822},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":824,"_path":825},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":827,"_path":828},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":830,"_path":831},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":833,"_path":834},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":836,"_path":837},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":839,"_path":840},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":842,"_path":843},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":845,"_path":846},"unity的addressables","/unity/2020-09-12-addressables",{"title":848,"_path":849},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":851,"_path":852},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":854,"_path":855},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":857,"_path":858},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":860,"_path":861},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":863,"_path":864},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":866,"_path":867},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":869,"_path":870},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":872,"_path":873},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":875,"_path":876},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":878,"_path":879},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":881,"_path":882},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":884,"_path":885},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":887,"_path":888},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":890,"_path":891},"简单保存工具","/unity/2020-11-13-simple-save",{"title":893,"_path":894},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":896,"_path":897},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":899,"_path":900},"ability","/unity/2020-11-16-dotssample",{"title":902,"_path":903},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":905,"_path":906},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":908,"_path":909},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":911,"_path":912},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":914,"_path":915},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":917,"_path":918},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":920,"_path":921},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":923,"_path":924},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":926,"_path":927},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":929,"_path":930},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":932,"_path":933},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":935,"_path":936},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":938,"_path":939},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":941,"_path":942},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":944,"_path":945},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":947,"_path":948},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":950,"_path":951},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779036568]