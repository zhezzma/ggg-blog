[{"data":1,"prerenderedAt":1021},["Reactive",2],{"content-query-LUknIqKOUZ":3,"content-navigation-8C37fagqQL":439},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":433,"_id":434,"_source":435,"_file":436,"_extension":437,"date":438},"/game/2021-12-14-untiy-gameplay-ablility-sourcecode","game",false,"","unity gameplay ability源代码解析","github仓库 : https://github.com/sjai013/unity-gameplay-ability-system",{"type":11,"children":12,"toc":418},"root",[13,29,34,59,65,70,83,88,110,116,128,133,142,155,187,196,204,213,218,223,241,246,255,260,265,283,292,297,310,319,324,330,335,365,374,380,409],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18,21],{"type":19,"value":20},"text","github仓库 : ",{"type":14,"tag":22,"props":23,"children":27},"a",{"href":24,"rel":25},"https://github.com/sjai013/unity-gameplay-ability-system",[26],"nofollow",[28],{"type":19,"value":24},{"type":14,"tag":15,"props":30,"children":31},{},[32],{"type":19,"value":33},"这是一个开源系统主要包含了以下内容",{"type":14,"tag":35,"props":36,"children":37},"ul",{},[38,44,49,54],{"type":14,"tag":39,"props":40,"children":41},"li",{},[42],{"type":19,"value":43},"Attribute System  属性系统.",{"type":14,"tag":39,"props":45,"children":46},{},[47],{"type":19,"value":48},"Gameplay Tags  tag用来判断技能是否能够释放,以及检查effect是否能够添加",{"type":14,"tag":39,"props":50,"children":51},{},[52],{"type":19,"value":53},"Gameplay Effects  技能特效",{"type":14,"tag":39,"props":55,"children":56},{},[57],{"type":19,"value":58},"Ability 技能",{"type":14,"tag":60,"props":61,"children":63},"h2",{"id":62},"特效",[64],{"type":19,"value":62},{"type":14,"tag":15,"props":66,"children":67},{},[68],{"type":19,"value":69},"GameplayEffectSpec 是特效的runtime",{"type":14,"tag":35,"props":71,"children":72},{},[73,78],{"type":14,"tag":39,"props":74,"children":75},{},[76],{"type":19,"value":77},"包含了特效的双方和target",{"type":14,"tag":39,"props":79,"children":80},{},[81],{"type":19,"value":82},"包含了其他数据等级,持续时间等",{"type":14,"tag":15,"props":84,"children":85},{},[86],{"type":19,"value":87},"创建方法",{"type":14,"tag":35,"props":89,"children":90},{},[91,101],{"type":14,"tag":39,"props":92,"children":93},{},[94],{"type":14,"tag":95,"props":96,"children":98},"code",{"className":97},[],[99],{"type":19,"value":100},"AbilitySystemCharacter.MakeOutgoingSpec",{"type":14,"tag":39,"props":102,"children":103},{},[104],{"type":14,"tag":95,"props":105,"children":107},{"className":106},[],[108],{"type":19,"value":109},"GameplayEffectSpec.CreateNew",{"type":14,"tag":111,"props":112,"children":114},"h3",{"id":113},"添加特效到角色",[115],{"type":19,"value":113},{"type":14,"tag":117,"props":118,"children":123},"pre",{"className":119,"code":121,"language":122,"meta":7},[120],"language-csharp","public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n","csharp",[124],{"type":14,"tag":95,"props":125,"children":126},{"__ignoreMap":7},[127],{"type":19,"value":121},{"type":14,"tag":15,"props":129,"children":130},{},[131],{"type":19,"value":132},"检查特效tag是否能够添加到角色身上",{"type":14,"tag":117,"props":134,"children":137},{"className":135,"code":136,"language":122,"meta":7},[120],"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List\u003CGameplayTagScriptableObject>();\nfor (var i = 0; i \u003C AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i \u003C geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i \u003C geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n",[138],{"type":14,"tag":95,"props":139,"children":140},{"__ignoreMap":7},[141],{"type":19,"value":136},{"type":14,"tag":111,"props":143,"children":145},{"id":144},"特效gameplayeffectscriptableobject本身",[146,147,153],{"type":19,"value":62},{"type":14,"tag":95,"props":148,"children":150},{"className":149},[],[151],{"type":19,"value":152},"GameplayEffectScriptableObject",{"type":19,"value":154},"本身",{"type":14,"tag":35,"props":156,"children":157},{},[158],{"type":14,"tag":39,"props":159,"children":160},{},[161,163],{"type":19,"value":162},"GameplayEffectDefinitionContainer  定义了特效的使用效果与条件",{"type":14,"tag":35,"props":164,"children":165},{},[166,177,182],{"type":14,"tag":39,"props":167,"children":168},{},[169,171],{"type":19,"value":170},"DurationPolicy和DurationModifier和DurationMultiplier构成了该特效的持续时间,以及是否立即使用",{"type":14,"tag":95,"props":172,"children":174},{"className":173},[],[175],{"type":19,"value":176},"DurationModifier.CalculateMagnitude(this).GetValueOrDefault() *.DurationMultiplier",{"type":14,"tag":39,"props":178,"children":179},{},[180],{"type":19,"value":181},"Modifiers 该特效对属性的修改",{"type":14,"tag":39,"props":183,"children":184},{},[185],{"type":19,"value":186},"ConditionalGameplayEffects  暂时没看到使用的地方??",{"type":14,"tag":117,"props":188,"children":191},{"className":189,"code":190,"language":122,"meta":7},[120],"   public struct GameplayEffectDefinitionContainer\n    {\n        /// \u003Csummary>\n        /// 持续方案,,是立即,还是持续\n        /// \u003C/summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// \u003Csummary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// \u003C/summary>\n        public float DurationMultiplier;\n\n\n        /// \u003Csummary>\n        /// 该特效对属性的修改\n        /// \u003C/summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// \u003Csummary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// \u003C/summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n",[192],{"type":14,"tag":95,"props":193,"children":194},{"__ignoreMap":7},[195],{"type":19,"value":190},{"type":14,"tag":35,"props":197,"children":198},{},[199],{"type":14,"tag":39,"props":200,"children":201},{},[202],{"type":19,"value":203},"GameplayEffectTags   定义处理特效之间的关系",{"type":14,"tag":117,"props":205,"children":208},{"className":206,"code":207,"language":122,"meta":7},[120],"   public struct GameplayEffectTags\n   {\n        /// \u003Csummary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// \u003C/summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// \u003Csummary>\n        /// effect添加到人身上前,需要检查的条件\n        /// \u003C/summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n",[209],{"type":14,"tag":95,"props":210,"children":211},{"__ignoreMap":7},[212],{"type":19,"value":207},{"type":14,"tag":60,"props":214,"children":216},{"id":215},"技能",[217],{"type":19,"value":215},{"type":14,"tag":15,"props":219,"children":220},{},[221],{"type":19,"value":222},"AbstractAbilitySpec是技能的runtime,包含了",{"type":14,"tag":35,"props":224,"children":225},{},[226,231,236],{"type":14,"tag":39,"props":227,"children":228},{},[229],{"type":19,"value":230},"ability的scriptobject",{"type":14,"tag":39,"props":232,"children":233},{},[234],{"type":19,"value":235},"ability的其他数据例如等级,词条等",{"type":14,"tag":39,"props":237,"children":238},{},[239],{"type":19,"value":240},"角色字段",{"type":14,"tag":111,"props":242,"children":244},{"id":243},"技能释放流程",[245],{"type":19,"value":243},{"type":14,"tag":117,"props":247,"children":250},{"className":248,"code":249,"language":122,"meta":7},[120],"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n",[251],{"type":14,"tag":95,"props":252,"children":253},{"__ignoreMap":7},[254],{"type":19,"value":249},{"type":14,"tag":15,"props":256,"children":257},{},[258],{"type":19,"value":259},"ability的cost和cooldown都使用了GameplayEffectScriptableObject,这也是这个系统比较蛋疼的地方,就是每个ability都需要建立cost和cooldown的object.",{"type":14,"tag":111,"props":261,"children":263},{"id":262},"检查cost",[264],{"type":19,"value":262},{"type":14,"tag":35,"props":266,"children":267},{},[268,273,278],{"type":14,"tag":39,"props":269,"children":270},{},[271],{"type":19,"value":272},"检查cost特效身上的Modifiers字段,并计算最终值",{"type":14,"tag":39,"props":274,"children":275},{},[276],{"type":19,"value":277},"然后和角色属性进行对比",{"type":14,"tag":39,"props":279,"children":280},{},[281],{"type":19,"value":282},"Modifiers可以有多条,且有计算公式",{"type":14,"tag":117,"props":284,"children":287},{"className":285,"code":286,"language":122,"meta":7},[120],"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i \u003C geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue \u003C 0) return false;\n\n        }\n        return true;\n}\n",[288],{"type":14,"tag":95,"props":289,"children":290},{"__ignoreMap":7},[291],{"type":19,"value":286},{"type":14,"tag":111,"props":293,"children":295},{"id":294},"检查cooldow",[296],{"type":19,"value":294},{"type":14,"tag":35,"props":298,"children":299},{},[300,305],{"type":14,"tag":39,"props":301,"children":302},{},[303],{"type":19,"value":304},"冷却时间特效最终会被添加到人物的身上",{"type":14,"tag":39,"props":306,"children":307},{},[308],{"type":19,"value":309},"该函数,主要是比对并找到人身上同tag的特效.然后检查该特效的TotalDuration",{"type":14,"tag":117,"props":311,"children":314},{"className":312,"code":313,"language":122,"meta":7},[120],"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i \u003C this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag \u003C grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag \u003C cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n",[315],{"type":14,"tag":95,"props":316,"children":317},{"__ignoreMap":7},[318],{"type":19,"value":313},{"type":14,"tag":111,"props":320,"children":322},{"id":321},"检查abilitytags",[323],{"type":19,"value":321},{"type":14,"tag":325,"props":326,"children":328},"h4",{"id":327},"abilitytags",[329],{"type":19,"value":327},{"type":14,"tag":15,"props":331,"children":332},{},[333],{"type":19,"value":334},"定义了一些tag用来释放前进行检查是否能释放该技能",{"type":14,"tag":35,"props":336,"children":337},{},[338,349,360],{"type":14,"tag":39,"props":339,"children":340},{},[341,343],{"type":19,"value":342},"例如检查自身是否能够匹配",{"type":14,"tag":95,"props":344,"children":346},{"className":345},[],[347],{"type":19,"value":348},"OwnerTags",{"type":14,"tag":39,"props":350,"children":351},{},[352,354],{"type":19,"value":353},"如果是指定目标则检查目标身上是否能够匹配",{"type":14,"tag":95,"props":355,"children":357},{"className":356},[],[358],{"type":19,"value":359},"TargetTags",{"type":14,"tag":39,"props":361,"children":362},{},[363],{"type":19,"value":364},"SourceTags?暂时没有好的理解",{"type":14,"tag":117,"props":366,"children":369},{"className":367,"code":368,"language":122,"meta":7},[120],"[Serializable]\npublic struct AbilityTags\n{\n    /// \u003Csummary>\n    /// This tag describes the Gameplay Ability\n    /// \u003C/summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// \u003Csummary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// \u003C/summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// \u003Csummary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// \u003C/summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// \u003Csummary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// \u003C/summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n",[370],{"type":14,"tag":95,"props":371,"children":372},{"__ignoreMap":7},[373],{"type":19,"value":368},{"type":14,"tag":325,"props":375,"children":377},{"id":376},"checkgameplaytags被定义在每个ability下然后对其重写",[378],{"type":19,"value":379},"CheckGameplayTags()被定义在每个ability下然后对其重写",{"type":14,"tag":35,"props":381,"children":382},{},[383,396],{"type":14,"tag":39,"props":384,"children":385},{},[386,388,394],{"type":19,"value":387},"AscHasAllTags  用来检查",{"type":14,"tag":95,"props":389,"children":391},{"className":390},[],[392],{"type":19,"value":393},"RequireTags",{"type":19,"value":395}," ,检查人身上特效的tags是否包含这些,如果没有包含则检查失败",{"type":14,"tag":39,"props":397,"children":398},{},[399,401,407],{"type":19,"value":400},"AscHasNoneTags 用来检查",{"type":14,"tag":95,"props":402,"children":404},{"className":403},[],[405],{"type":19,"value":406},"IgnoreTags",{"type":19,"value":408}," ,检查人身上特效的tags是否包含这些,如果包含则检查失败",{"type":14,"tag":117,"props":410,"children":413},{"className":411,"code":412,"language":122,"meta":7},[120],"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag \u003C tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc \u003C asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag \u003C ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag \u003C tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc \u003C asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag \u003C ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n",[414],{"type":14,"tag":95,"props":415,"children":416},{"__ignoreMap":7},[417],{"type":19,"value":412},{"title":7,"searchDepth":419,"depth":419,"links":420},2,[421,427],{"id":62,"depth":419,"text":62,"children":422},[423,425],{"id":113,"depth":424,"text":113},3,{"id":144,"depth":424,"text":426},"特效GameplayEffectScriptableObject本身",{"id":215,"depth":419,"text":215,"children":428},[429,430,431,432],{"id":243,"depth":424,"text":243},{"id":262,"depth":424,"text":262},{"id":294,"depth":424,"text":294},{"id":321,"depth":424,"text":321},"markdown","content:game:2021-12-14-untiy-gameplay-ablility-sourcecode.md","content","game/2021-12-14-untiy-gameplay-ablility-sourcecode.md","md","2021-12-14",[440,450,577,624,676,689,801],{"title":441,"_path":442,"children":443},"Art","/art",[444,447],{"title":445,"_path":446},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":448,"_path":449},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":451,"_path":452,"children":453},"Dotnet","/dotnet",[454,457,460,463,466,469,472,475,478,481,484,487,490,493,496,499,502,505,508,511,514,517,520,523,526,529,532,535,538,541,544,547,550,553,556,559,562,565,568,571,574],{"title":455,"_path":456},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":458,"_path":459},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":461,"_path":462},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":464,"_path":465},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":467,"_path":468},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":470,"_path":471},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":473,"_path":474},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":476,"_path":477},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":479,"_path":480},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":482,"_path":483},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":485,"_path":486},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":488,"_path":489},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":491,"_path":492},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":494,"_path":495},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":497,"_path":498},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":500,"_path":501},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":503,"_path":504},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":506,"_path":507},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":509,"_path":510},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":512,"_path":513},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":515,"_path":516},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":518,"_path":519},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":521,"_path":522},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":524,"_path":525},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":527,"_path":528},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":530,"_path":531},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":533,"_path":534},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":536,"_path":537},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":539,"_path":540},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":542,"_path":543},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":545,"_path":546},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":548,"_path":549},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":551,"_path":552},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":554,"_path":555},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":557,"_path":558},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":560,"_path":561},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":563,"_path":564},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":566,"_path":567},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":569,"_path":570},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":572,"_path":573},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":575,"_path":576},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":578,"_path":579,"children":580},"Game","/game",[581,584,587,590,593,596,599,602,605,606,609,612,615,618,621],{"title":582,"_path":583},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":585,"_path":586},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":588,"_path":589},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":591,"_path":592},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":594,"_path":595},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":597,"_path":598},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":600,"_path":601},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":603,"_path":604},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":8,"_path":4},{"title":607,"_path":608},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":610,"_path":611},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":613,"_path":614},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":616,"_path":617},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":619,"_path":620},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":622,"_path":623},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":625,"_path":626,"children":627},"Gyj","/gyj",[628,631,634,637,640,643,646,649,652,655,658,661,664,667,670,673],{"title":629,"_path":630},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":632,"_path":633},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":635,"_path":636},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":638,"_path":639},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":641,"_path":642},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":644,"_path":645},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":647,"_path":648},"玩法","/gyj/2022-08-22-wanfa",{"title":650,"_path":651},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":653,"_path":654},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":656,"_path":657},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":659,"_path":660},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":662,"_path":663},"门派内容相关","/gyj/2022-11-17-sect",{"title":665,"_path":666},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":668,"_path":669},"种植","/gyj/2022-12-01-zhongzhi",{"title":671,"_path":672},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":674,"_path":675},"跑商","/gyj/2023-11-01-paoshang",{"title":677,"_path":678,"children":679},"Js","/js",[680,683,686],{"title":681,"_path":682},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":684,"_path":685},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":687,"_path":688},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":690,"_path":691,"children":692},"Tool","/tool",[693,696,699,702,705,708,711,714,717,720,723,726,729,732,735,738,741,744,747,750,753,756,759,762,765,768,771,774,777,780,783,786,789,792,795,798],{"title":694,"_path":695},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":697,"_path":698},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":700,"_path":701},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":703,"_path":704},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":706,"_path":707},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":709,"_path":710},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":712,"_path":713},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":715,"_path":716},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":718,"_path":719},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":721,"_path":722},"mac下brew 使用","/tool/2020-01-13-brew",{"title":724,"_path":725},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":727,"_path":728},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":730,"_path":731},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":733,"_path":734},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":736,"_path":737},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":739,"_path":740},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":742,"_path":743},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":745,"_path":746},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":748,"_path":749},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":751,"_path":752},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":754,"_path":755},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":757,"_path":758},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":760,"_path":761},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":763,"_path":764},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":766,"_path":767},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":769,"_path":770},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":772,"_path":773},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":775,"_path":776},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":778,"_path":779},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":781,"_path":782},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":784,"_path":785},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":787,"_path":788},"rider的使用","/tool/2022-08-02-rider-use",{"title":790,"_path":791},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":793,"_path":794},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":796,"_path":797},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":799,"_path":800},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":802,"_path":803,"children":804},"Unity","/unity",[805,808,811,814,817,820,823,826,829,832,835,838,841,844,847,850,853,856,859,862,865,868,871,874,877,880,883,886,889,892,895,898,901,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000,1003,1006,1009,1012,1015,1018],{"title":806,"_path":807},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":809,"_path":810},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":812,"_path":813},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":815,"_path":816},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":818,"_path":819},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":821,"_path":822},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":824,"_path":825},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":827,"_path":828},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":830,"_path":831},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":833,"_path":834},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":836,"_path":837},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":839,"_path":840},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":842,"_path":843},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":845,"_path":846},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":848,"_path":849},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":851,"_path":852},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":854,"_path":855},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":857,"_path":858},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":860,"_path":861},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":863,"_path":864},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":866,"_path":867},"技能系统","/unity/2020-02-15-skill-system",{"title":869,"_path":870},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":872,"_path":873},"角色状态设计","/unity/2020-02-17-character-states",{"title":875,"_path":876},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":878,"_path":879},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":881,"_path":882},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":884,"_path":885},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":887,"_path":888},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":890,"_path":891},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":893,"_path":894},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":896,"_path":897},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":899,"_path":900},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":902,"_path":903},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":905,"_path":906},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":908,"_path":909},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":911,"_path":912},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":914,"_path":915},"unity的addressables","/unity/2020-09-12-addressables",{"title":917,"_path":918},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":920,"_path":921},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":923,"_path":924},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":926,"_path":927},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":929,"_path":930},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":932,"_path":933},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":935,"_path":936},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":938,"_path":939},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":941,"_path":942},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":944,"_path":945},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":947,"_path":948},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":950,"_path":951},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":953,"_path":954},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":956,"_path":957},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":959,"_path":960},"简单保存工具","/unity/2020-11-13-simple-save",{"title":962,"_path":963},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":965,"_path":966},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":968,"_path":969},"ability","/unity/2020-11-16-dotssample",{"title":971,"_path":972},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":974,"_path":975},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":977,"_path":978},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":980,"_path":981},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":983,"_path":984},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":986,"_path":987},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":989,"_path":990},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":992,"_path":993},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":995,"_path":996},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":998,"_path":999},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1001,"_path":1002},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1004,"_path":1005},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1007,"_path":1008},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1010,"_path":1011},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1013,"_path":1014},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1016,"_path":1017},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1019,"_path":1020},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779036223]