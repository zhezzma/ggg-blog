[{"data":1,"prerenderedAt":1500},["Reactive",2],{"content-query-vzLi6UfVpN":3,"content-navigation-8C37fagqQL":918},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":912,"_id":913,"_source":914,"_file":915,"_extension":916,"date":917},"/game/2021-01-20-perlin-map","game",false,"","使用柏林噪声算法生成地图","柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得奥斯卡科技成果奖（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的改进版柏林噪声算法。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。\n如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。",{"type":11,"children":12,"toc":904},"root",[13,41,54,59,63,70,88,100,120,138,143,151,168,179,193,201,206,223,243,248,253,262,267,271,279,284,288,296,301,305,313,318,335,340,344,352,372,389,394,406,411,414,420,433,440,453,457,465,482,487,491,499,534,539,551,556,560,568,581,587,592,600,612,616,624,651,657,677,681,689,694,698,706,725,737,743,748,752,760,763,769,774,791,796,813,825,846,858,870,883,887,895,898],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18,21,30,32,39],{"type":19,"value":20},"text","柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得",{"type":14,"tag":22,"props":23,"children":27},"a",{"href":24,"rel":25},"http://mrl.nyu.edu/~perlin/doc/oscar.html",[26],"nofollow",[28],{"type":19,"value":29},"奥斯卡科技成果奖",{"type":19,"value":31},"（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的",{"type":14,"tag":22,"props":33,"children":36},{"href":34,"rel":35},"http://mrl.nyu.edu/~perlin/noise/",[26],[37],{"type":19,"value":38},"改进版柏林噪声算法",{"type":19,"value":40},"。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。\n如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。",{"type":14,"tag":15,"props":42,"children":43},{},[44],{"type":14,"tag":22,"props":45,"children":48},{"href":46,"rel":47},"https://images2015.cnblogs.com/blog/608996/201707/608996-20170721155322355-1352334868.png",[26],[49],{"type":14,"tag":50,"props":51,"children":53},"img",{"alt":50,"src":52},"/images/2021-01-20-Perlin-map/608996-20170721155322355-1352334868.png",[],{"type":14,"tag":15,"props":55,"children":56},{},[57],{"type":19,"value":58},"正如图所示，柏林噪声算法可以用来模拟许多自然中的噪声现象。接下来让我们从数理上分析算法的实现原理。",{"type":14,"tag":60,"props":61,"children":62},"hr",{},[],{"type":14,"tag":64,"props":65,"children":67},"h1",{"id":66},"基本原理",[68],{"type":19,"value":69},"基本原理#",{"type":14,"tag":71,"props":72,"children":73},"blockquote",{},[74],{"type":14,"tag":15,"props":75,"children":76},{},[77,79,86],{"type":19,"value":78},"注意：事先声明，本节内容大多源于",{"type":14,"tag":22,"props":80,"children":83},{"href":81,"rel":82},"http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html",[26],[84],{"type":19,"value":85},"this wonderful article by Matt Zucker",{"type":19,"value":87},"，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。",{"type":14,"tag":15,"props":89,"children":90},{},[91,93],{"type":19,"value":92},"让我们从最基本的柏林噪声函数看起：\n",{"type":14,"tag":94,"props":95,"children":97},"code",{"className":96},[],[98],{"type":19,"value":99},"public double perlin(double x, double y, double z);",{"type":14,"tag":15,"props":101,"children":102},{},[103,105,111,113,118],{"type":19,"value":104},"函数接收",{"type":14,"tag":94,"props":106,"children":108},{"className":107},[],[109],{"type":19,"value":110},"x,y,z",{"type":19,"value":112},"三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值",{"type":14,"tag":94,"props":114,"children":116},{"className":115},[],[117],{"type":19,"value":110},{"type":19,"value":119},"的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示：",{"type":14,"tag":15,"props":121,"children":122},{},[123,132],{"type":14,"tag":22,"props":124,"children":127},{"href":125,"rel":126},"https://upload-images.jianshu.io/upload_images/1797904-bfbbc85ed4afee99.png?imageMogr2/auto-orient/strip",[26],[128],{"type":14,"tag":50,"props":129,"children":131},{"alt":50,"src":130},"/images/2021-01-20-Perlin-map/1797904-bfbbc85ed4afee99.png",[],{"type":14,"tag":133,"props":134,"children":135},"em",{},[136],{"type":19,"value":137},"图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点",{"type":14,"tag":15,"props":139,"children":140},{},[141],{"type":19,"value":142},"接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。",{"type":14,"tag":71,"props":144,"children":145},{},[146],{"type":14,"tag":15,"props":147,"children":148},{},[149],{"type":19,"value":150},"举个例子来理解伪随机，比如我们从圆周率π（3.14159...）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。",{"type":14,"tag":15,"props":152,"children":153},{},[154,163],{"type":14,"tag":22,"props":155,"children":158},{"href":156,"rel":157},"https://upload-images.jianshu.io/upload_images/1797904-ad4b0120e857b5d3.png?imageMogr2/auto-orient/strip",[26],[159],{"type":14,"tag":50,"props":160,"children":162},{"alt":50,"src":161},"/images/2021-01-20-Perlin-map/1797904-ad4b0120e857b5d3.png",[],{"type":14,"tag":133,"props":164,"children":165},{},[166],{"type":19,"value":167},"图2：各顶点上的梯度向量随机选取结果",{"type":14,"tag":15,"props":169,"children":170},{},[171,173],{"type":19,"value":172},"请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成：\n",{"type":14,"tag":94,"props":174,"children":176},{"className":175},[],[177],{"type":19,"value":178},"(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)",{"type":14,"tag":15,"props":180,"children":181},{},[182,184,191],{"type":19,"value":183},"采用这些特殊梯度向量的原因在",{"type":14,"tag":22,"props":185,"children":188},{"href":186,"rel":187},"http://mrl.nyu.edu/~perlin/paper445.pdf",[26],[189],{"type":19,"value":190},"Ken Perlin's SIGGRAPH 2002 paper: Improving Noise",{"type":19,"value":192},"这篇文章里有具体讲解。",{"type":14,"tag":71,"props":194,"children":195},{},[196],{"type":14,"tag":15,"props":197,"children":198},{},[199],{"type":19,"value":200},"注意：许多介绍柏林噪声算法的文章都是根据最初版柏林噪声算法来讲解的，预定义的梯度表不是本文所说的这12个向量。如图2所示的梯度向量就是最初版算法所随机出来的梯度向量，不过这两种算法的原理都是一样的。",{"type":14,"tag":15,"props":202,"children":203},{},[204],{"type":19,"value":205},"接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子：",{"type":14,"tag":15,"props":207,"children":208},{},[209,218],{"type":14,"tag":22,"props":210,"children":213},{"href":211,"rel":212},"https://upload-images.jianshu.io/upload_images/1797904-6dde06b2b941253d.png?imageMogr2/auto-orient/strip",[26],[214],{"type":14,"tag":50,"props":215,"children":217},{"alt":50,"src":216},"/images/2021-01-20-Perlin-map/1797904-6dde06b2b941253d.png",[],{"type":14,"tag":133,"props":219,"children":220},{},[221],{"type":19,"value":222},"图3:各个距离向量",{"type":14,"tag":15,"props":224,"children":225},{},[226,228,235,237],{"type":19,"value":227},"接着，对每个顶点的梯度向量和距离向量做",{"type":14,"tag":22,"props":229,"children":232},{"href":230,"rel":231},"https://en.wikipedia.org/wiki/Dot_product",[26],[233],{"type":19,"value":234},"点积",{"type":19,"value":236},"运算，我们就可以得出每个顶点的影响值：\n",{"type":14,"tag":94,"props":238,"children":240},{"className":239},[],[241],{"type":19,"value":242},"grad.x * dist.x + grad.y * dist.y + grad.z * dist.z",{"type":14,"tag":15,"props":244,"children":245},{},[246],{"type":19,"value":247},"这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦：",{"type":14,"tag":15,"props":249,"children":250},{},[251],{"type":19,"value":252},"复制代码",{"type":14,"tag":254,"props":255,"children":257},"pre",{"code":256},"dot(vec1,vec2) = cos(angle(vec1,vec2)) * vec1.length * vec2.length\n",[258],{"type":14,"tag":94,"props":259,"children":260},{"__ignoreMap":7},[261],{"type":19,"value":256},{"type":14,"tag":15,"props":263,"children":264},{},[265],{"type":19,"value":266},"换句话说，如果两向量指向同一方向，点积结果为：",{"type":14,"tag":15,"props":268,"children":269},{},[270],{"type":19,"value":252},{"type":14,"tag":254,"props":272,"children":274},{"code":273},"1 * vec1.length * vec2.length\n",[275],{"type":14,"tag":94,"props":276,"children":277},{"__ignoreMap":7},[278],{"type":19,"value":273},{"type":14,"tag":15,"props":280,"children":281},{},[282],{"type":19,"value":283},"如果两向量指向相反方向，则点积结果为：",{"type":14,"tag":15,"props":285,"children":286},{},[287],{"type":19,"value":252},{"type":14,"tag":254,"props":289,"children":291},{"code":290},"-1 * vec1.length * vec2.length\n",[292],{"type":14,"tag":94,"props":293,"children":294},{"__ignoreMap":7},[295],{"type":19,"value":290},{"type":14,"tag":15,"props":297,"children":298},{},[299],{"type":19,"value":300},"如果两向量互相垂直，则点积结果为0。",{"type":14,"tag":15,"props":302,"children":303},{},[304],{"type":19,"value":252},{"type":14,"tag":254,"props":306,"children":308},{"code":307},"0 * vec1.length * vec2.length\n",[309],{"type":14,"tag":94,"props":310,"children":311},{"__ignoreMap":7},[312],{"type":19,"value":307},{"type":14,"tag":15,"props":314,"children":315},{},[316],{"type":19,"value":317},"点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。下面通过一副彩色图，直观地看下各顶点的影响值：",{"type":14,"tag":15,"props":319,"children":320},{},[321,330],{"type":14,"tag":22,"props":322,"children":325},{"href":323,"rel":324},"https://upload-images.jianshu.io/upload_images/1797904-0c7ca0db2126715a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",[26],[326],{"type":14,"tag":50,"props":327,"children":329},{"alt":50,"src":328},"/images/2021-01-20-Perlin-map/1797904-0c7ca0db2126715a.png",[],{"type":14,"tag":133,"props":331,"children":332},{},[333],{"type":19,"value":334},"图4：2D柏林噪声的影响值",{"type":14,"tag":15,"props":336,"children":337},{},[338],{"type":19,"value":339},"下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）：",{"type":14,"tag":15,"props":341,"children":342},{},[343],{"type":19,"value":252},{"type":14,"tag":254,"props":345,"children":347},{"code":346},"// Below are 4 influence values in the arrangement:\n// [g1] | [g2]\n// -----------\n// [g3] | [g4]\nint g1, g2, g3, g4;\nint u, v;   // These coordinates are the location of the input coordinate in its unit square.  \n            // For example a value of (0.5,0.5) is in the exact center of its unit square.\n\nint x1 = lerp(g1,g2,u);\nint x2 = lerp(g3,h4,u);\n\nint average = lerp(x1,x2,v);\n",[348],{"type":14,"tag":94,"props":349,"children":350},{"__ignoreMap":7},[351],{"type":19,"value":346},{"type":14,"tag":15,"props":353,"children":354},{},[355,357,363,365,370],{"type":19,"value":356},"至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数：",{"type":14,"tag":358,"props":359,"children":360},"strong",{},[361],{"type":19,"value":362},"fade函数",{"type":19,"value":364},"，通常也被称为",{"type":14,"tag":358,"props":366,"children":367},{},[368],{"type":19,"value":369},"ease curve",{"type":19,"value":371},"(也作为缓动函数在游戏中广泛使用)：",{"type":14,"tag":15,"props":373,"children":374},{},[375,384],{"type":14,"tag":22,"props":376,"children":379},{"href":377,"rel":378},"https://upload-images.jianshu.io/upload_images/1797904-27f5e6997742a89a.png?imageMogr2/auto-orient/strip",[26],[380],{"type":14,"tag":50,"props":381,"children":383},{"alt":50,"src":382},"/images/2021-01-20-Perlin-map/1797904-27f5e6997742a89a.png",[],{"type":14,"tag":133,"props":385,"children":386},{},[387],{"type":19,"value":388},"图5：ease curve",{"type":14,"tag":15,"props":390,"children":391},{},[392],{"type":19,"value":393},"ease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式：",{"type":14,"tag":15,"props":395,"children":396},{},[397],{"type":14,"tag":22,"props":398,"children":401},{"href":399,"rel":400},"https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip",[26],[402],{"type":14,"tag":50,"props":403,"children":405},{"alt":50,"src":404},"/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif",[],{"type":14,"tag":15,"props":407,"children":408},{},[409],{"type":19,"value":410},"基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。",{"type":14,"tag":60,"props":412,"children":413},{},[],{"type":14,"tag":64,"props":415,"children":417},{"id":416},"代码实现",[418],{"type":19,"value":419},"代码实现#",{"type":14,"tag":15,"props":421,"children":422},{},[423,425,431],{"type":19,"value":424},"在本节开始前我需要重申一遍，代码实现是C#版本。相比",{"type":14,"tag":22,"props":426,"children":428},{"href":34,"rel":427},[26],[429],{"type":19,"value":430},"Ken Perlin的Java版本实现",{"type":19,"value":432},"做了小小的改动，主要是增加了代码的整洁性和可读性，支持噪声重复（瓦片重复）特性。代码完全开源，可免费使用（考虑到这毕竟不是我原创发明的算法 - Ken Perlin才是！）",{"type":14,"tag":434,"props":435,"children":437},"h2",{"id":436},"准备工作",[438],{"type":19,"value":439},"准备工作##",{"type":14,"tag":15,"props":441,"children":442},{},[443,445,451],{"type":19,"value":444},"第一步，我们需要先声明一个排列表（permutation table），或者直接缩写为",{"type":14,"tag":94,"props":446,"children":448},{"className":447},[],[449],{"type":19,"value":450},"p[]",{"type":19,"value":452},"数组就行了。数组长度为256，分别随机、无重复地存放了0-255这些数值。为了避免缓存溢出，我们再重复填充一次数组的值，所以数组最终长度为512：",{"type":14,"tag":15,"props":454,"children":455},{},[456],{"type":19,"value":252},{"type":14,"tag":254,"props":458,"children":460},{"code":459},"private static readonly int[] permutation = { 151,160,137,91,90,15,                 // Hash lookup table as defined by Ken Perlin.  This is a randomly\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    // arranged array of all numbers from 0-255 inclusive.\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\nprivate static readonly int[] p;                                                    // Doubled permutation to avoid overflow\n\nstatic Perlin() {\n    p = new int[512];\n    for(int x=0;x\u003C512;x++) {\n        p[x] = permutation[x%256];\n    }\n}\n",[461],{"type":14,"tag":94,"props":462,"children":463},{"__ignoreMap":7},[464],{"type":19,"value":459},{"type":14,"tag":15,"props":466,"children":467},{},[468,473,475,480],{"type":14,"tag":94,"props":469,"children":471},{"className":470},[],[472],{"type":19,"value":450},{"type":19,"value":474},"数组会在算法后续的哈希计算中使用到，用于确定一组输入最终挑选哪个梯度向量（从前面所列出的12个梯度向量中挑选）。后续代码会详细展示",{"type":14,"tag":94,"props":476,"children":478},{"className":477},[],[479],{"type":19,"value":450},{"type":19,"value":481},"数组的用法。",{"type":14,"tag":15,"props":483,"children":484},{},[485],{"type":19,"value":486},"接着，我们开始编写柏林噪声函数：",{"type":14,"tag":15,"props":488,"children":489},{},[490],{"type":19,"value":252},{"type":14,"tag":254,"props":492,"children":494},{"code":493},"public double perlin(double x, double y, double z) {\n    if(repeat > 0) {                                    // If we have any repeat on, change the coordinates to their \"local\" repetitions\n        x = x%repeat;\n        y = y%repeat;\n        z = z%repeat;\n    }\n    \n    int xi = (int)x & 255;                              // Calculate the \"unit cube\" that the point asked will be located in\n    int yi = (int)y & 255;                              // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\n    int zi = (int)z & 255;                              // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\n    double xf = x-(int)x;\n    double yf = y-(int)y;\n    double zf = z-(int)z;\n    // ...\n}\n",[495],{"type":14,"tag":94,"props":496,"children":497},{"__ignoreMap":7},[498],{"type":19,"value":493},{"type":14,"tag":15,"props":500,"children":501},{},[502,504,510,512,517,519,525,527,532],{"type":19,"value":503},"上面的代码很直观。首先，对输入坐标使用求余运算符%，求出[0,repeat)范围内的余数。紧接着声明",{"type":14,"tag":94,"props":505,"children":507},{"className":506},[],[508],{"type":19,"value":509},"xi, yi, zi",{"type":19,"value":511},"三个变量。它们代表了输入坐标落在了哪个单元正方形里。我们还要限制坐标在[0,255]这个范围内，避免访问数组",{"type":14,"tag":94,"props":513,"children":515},{"className":514},[],[516],{"type":19,"value":450},{"type":19,"value":518},"时，出现数组越界错误。这也产生了一个副作用：柏林噪声每隔256个整数就会再次重复。但这不是太大的问题，因为算法不仅能处理整数，还能处理小数。最后，我们通过",{"type":14,"tag":94,"props":520,"children":522},{"className":521},[],[523],{"type":19,"value":524},"xf, yf, zf",{"type":19,"value":526},"三个变量（也就是",{"type":14,"tag":94,"props":528,"children":530},{"className":529},[],[531],{"type":19,"value":110},{"type":19,"value":533},"的小数部分值），确定了输入坐标在单元正方形里的空间位置（就是前面所示的小蓝点）。",{"type":14,"tag":434,"props":535,"children":536},{"id":362},[537],{"type":19,"value":538},"Fade函数##",{"type":14,"tag":15,"props":540,"children":541},{},[542,544],{"type":19,"value":543},"现在我们需要用代码表示前面所提到的fade函数（图5）。正如上文所提，函数的数学表示：\n",{"type":14,"tag":22,"props":545,"children":547},{"href":399,"rel":546},[26],[548],{"type":14,"tag":50,"props":549,"children":550},{"alt":50,"src":404},[],{"type":14,"tag":15,"props":552,"children":553},{},[554],{"type":19,"value":555},"代码实现如下：",{"type":14,"tag":15,"props":557,"children":558},{},[559],{"type":19,"value":252},{"type":14,"tag":254,"props":561,"children":563},{"code":562},"public static double fade(double t) {\n                                                        // Fade function as defined by Ken Perlin.  This eases coordinate values\n                                                        // so that they will ease towards integral values.  This ends up smoothing\n                                                        // the final output.\n    return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3\n}\n\npublic double perlin(double x, double y, double z) {\n    // ...\n\n    double u = fade(xf);\n    double v = fade(yf);\n    double w = fade(zf);\n\n    // ...\n}\n",[564],{"type":14,"tag":94,"props":565,"children":566},{"__ignoreMap":7},[567],{"type":19,"value":562},{"type":14,"tag":15,"props":569,"children":570},{},[571,573,579],{"type":19,"value":572},"代码所计算得出的",{"type":14,"tag":94,"props":574,"children":576},{"className":575},[],[577],{"type":19,"value":578},"u / v / w",{"type":19,"value":580},"变量将在后面的插值计算中使用到。",{"type":14,"tag":434,"props":582,"children":584},{"id":583},"哈希函数",[585],{"type":19,"value":586},"哈希函数##",{"type":14,"tag":15,"props":588,"children":589},{},[590],{"type":19,"value":591},"柏林噪声哈希函数用于给每组输入计算返回一个唯一、确定值。哈希函数在维基百科的定义如下：",{"type":14,"tag":71,"props":593,"children":594},{},[595],{"type":14,"tag":15,"props":596,"children":597},{},[598],{"type":19,"value":599},"哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法，输入数据有任何细微的不同，都会令输出结果完全不一样",{"type":14,"tag":15,"props":601,"children":602},{},[603,605,610],{"type":19,"value":604},"下面代码就是柏林噪声算法所使用的哈希函数。它使用了早前我们声明的",{"type":14,"tag":94,"props":606,"children":608},{"className":607},[],[609],{"type":19,"value":450},{"type":19,"value":611},"数组：",{"type":14,"tag":15,"props":613,"children":614},{},[615],{"type":19,"value":252},{"type":14,"tag":254,"props":617,"children":619},{"code":618},"public double perlin(double x, double y, double z) {\n    // ...\n\n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n\n    // ...\n}\n\npublic int inc(int num) {\n    num++;\n    if (repeat > 0) num %= repeat;\n    \n    return num;\n}\n",[620],{"type":14,"tag":94,"props":621,"children":622},{"__ignoreMap":7},[623],{"type":19,"value":618},{"type":14,"tag":15,"props":625,"children":626},{},[627,629,635,637,642,644,649],{"type":19,"value":628},"代码的哈希函数，对包围着输入坐标（小蓝点）的周围8个单元正方形的索引坐标进行了哈希计算。",{"type":14,"tag":94,"props":630,"children":632},{"className":631},[],[633],{"type":19,"value":634},"inc()",{"type":19,"value":636},"函数用于将输入值增加1，同时保证范围在[0,repeat)内。如果不需要噪声重复，",{"type":14,"tag":94,"props":638,"children":640},{"className":639},[],[641],{"type":19,"value":634},{"type":19,"value":643},"函数可以简化成单纯将输入值增加1。由于哈希结果值是从",{"type":14,"tag":94,"props":645,"children":647},{"className":646},[],[648],{"type":19,"value":450},{"type":19,"value":650},"数组中得到的，所以哈希函数的返回值范围限定在[0,255]内。",{"type":14,"tag":434,"props":652,"children":654},{"id":653},"梯度函数",[655],{"type":19,"value":656},"梯度函数##",{"type":14,"tag":15,"props":658,"children":659},{},[660,662,668,670,675],{"type":19,"value":661},"我时常认为Ken Perlin的最初版算法里的",{"type":14,"tag":94,"props":663,"children":665},{"className":664},[],[666],{"type":19,"value":667},"grad()",{"type":19,"value":669},"函数写法过于复杂，令人费解。我们只要明白",{"type":14,"tag":94,"props":671,"children":673},{"className":672},[],[674],{"type":19,"value":667},{"type":19,"value":676},"函数的作用在于计算随机选取的梯度向量以及顶点位置向量的点积。Ken Perlin巧妙地使用了位翻转(bit-flipping)技巧来实现：",{"type":14,"tag":15,"props":678,"children":679},{},[680],{"type":19,"value":252},{"type":14,"tag":254,"props":682,"children":684},{"code":683},"public static double grad(int hash, double x, double y, double z) {\n    int h = hash & 15;                                    // Take the hashed value and take the first 4 bits of it (15 == 0b1111)\n    double u = h \u003C 8 /* 0b1000 */ ? x : y;                // If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.\n    \n    double v;                                             // In Ken Perlin's original implementation this was another conditional operator (?:).  I\n                                                          // expanded it for readability.\n    \n    if(h \u003C 4 /* 0b0100 */)                                // If the first and second significant bits are 0 set v = y\n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)  // If the first and second significant bits are 1 set v = x\n        v = x;\n    else                                                  // If the first and second significant bits are not equal (0/1, 1/0) set v = z\n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.\n}\n",[685],{"type":14,"tag":94,"props":686,"children":687},{"__ignoreMap":7},[688],{"type":19,"value":683},{"type":14,"tag":15,"props":690,"children":691},{},[692],{"type":19,"value":693},"下面代码则是以另一种令人容易理解的方式完成了这个任务（而且在很多语言版本的运行效率都优于前面一种）：",{"type":14,"tag":15,"props":695,"children":696},{},[697],{"type":19,"value":252},{"type":14,"tag":254,"props":699,"children":701},{"code":700},"// Source: http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html\npublic static double grad(int hash, double x, double y, double z)\n{\n    switch(hash & 0xF)\n    {\n        case 0x0: return  x + y;\n        case 0x1: return -x + y;\n        case 0x2: return  x - y;\n        case 0x3: return -x - y;\n        case 0x4: return  x + z;\n        case 0x5: return -x + z;\n        case 0x6: return  x - z;\n        case 0x7: return -x - z;\n        case 0x8: return  y + z;\n        case 0x9: return -y + z;\n        case 0xA: return  y - z;\n        case 0xB: return -y - z;\n        case 0xC: return  y + x;\n        case 0xD: return -y + z;\n        case 0xE: return  y - x;\n        case 0xF: return -y - z;\n        default: return 0; // never happens\n    }\n}\n",[702],{"type":14,"tag":94,"props":703,"children":704},{"__ignoreMap":7},[705],{"type":19,"value":700},{"type":14,"tag":15,"props":707,"children":708},{},[709,711,718,720],{"type":19,"value":710},"以上的源码可以",{"type":14,"tag":22,"props":712,"children":715},{"href":713,"rel":714},"http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html",[26],[716],{"type":19,"value":717},"点击这里",{"type":19,"value":719},"查看。无论如何，上面的两种实现并没有实质差别。他们都是从以下12个向量里随机挑选一个作为梯度向量：\n",{"type":14,"tag":94,"props":721,"children":723},{"className":722},[],[724],{"type":19,"value":178},{"type":14,"tag":15,"props":726,"children":727},{},[728,730,735],{"type":19,"value":729},"随机挑选结果其实取决于前一步所计算得出的哈希值（",{"type":14,"tag":94,"props":731,"children":733},{"className":732},[],[734],{"type":19,"value":667},{"type":19,"value":736},"函数的第一个参数）。后面3个参数则代表由输入点指向顶点的距离向量（最终拿来与梯度向量进行点积）。",{"type":14,"tag":434,"props":738,"children":740},{"id":739},"插值整合",[741],{"type":19,"value":742},"插值整合##",{"type":14,"tag":15,"props":744,"children":745},{},[746],{"type":19,"value":747},"经过前面的几步计算，我们得出了8个顶点的影响值，并将它们进行平滑插值，得出了最终结果：",{"type":14,"tag":15,"props":749,"children":750},{},[751],{"type":19,"value":252},{"type":14,"tag":254,"props":753,"children":755},{"code":754},"public double perlin(double x, double y, double z) {\n    // ...\n\n    double x1, x2, y1, y2;\n    x1 = lerp(    grad (aaa, xf  , yf  , zf),           // The gradient function calculates the dot product between a pseudorandom\n                grad (baa, xf-1, yf  , zf),             // gradient vector and the vector from the input coordinate to the 8\n                u);                                     // surrounding points in its unit cube.\n    x2 = lerp(    grad (aba, xf  , yf-1, zf),           // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\n                grad (bba, xf-1, yf-1, zf),             // values we made earlier.\n                  u);\n    y1 = lerp(x1, x2, v);\n\n    x1 = lerp(    grad (aab, xf  , yf  , zf-1),\n                grad (bab, xf-1, yf  , zf-1),\n                u);\n    x2 = lerp(    grad (abb, xf  , yf-1, zf-1),\n                  grad (bbb, xf-1, yf-1, zf-1),\n                  u);\n    y2 = lerp (x1, x2, v);\n    \n    return (lerp (y1, y2, w)+1)/2;                      // For convenience we bind the result to 0 - 1 (theoretical min/max before is [-1, 1])\n}\n\n// Linear Interpolate\npublic static double lerp(double a, double b, double x) {\n    return a + x * (b - a);\n}\n",[756],{"type":14,"tag":94,"props":757,"children":758},{"__ignoreMap":7},[759],{"type":19,"value":754},{"type":14,"tag":60,"props":761,"children":762},{},[],{"type":14,"tag":64,"props":764,"children":766},{"id":765},"利用倍频实现更自然的噪声",[767],{"type":19,"value":768},"利用倍频实现更自然的噪声#",{"type":14,"tag":15,"props":770,"children":771},{},[772],{"type":19,"value":773},"最后让我们再思考下，除了前面所讲的计算，还有其他办法可以令噪声结果更加自然吗？虽然柏林噪声算法一定程度上模拟了自然噪声，但仍没有完全表现出自然噪声的不规律性。举个现实例子，现实地形会有大段连绵、高耸的山地，也会有丘陵和蚀坑，更小点的有大块岩石，甚至更小的鹅卵石块，这都属于地形的一部分。那如何让柏林噪声算法模拟出这样的自然噪声特性，解决方法也很简单：我们可以使用不同的频率（frequencies）和振幅（amplitudes）参数进行多几次柏林噪声计算，然后将结果叠加在一起。频率是指采样数据的间隔，振幅是指返回值的幅度范围。",{"type":14,"tag":15,"props":775,"children":776},{},[777,786],{"type":14,"tag":22,"props":778,"children":781},{"href":779,"rel":780},"https://upload-images.jianshu.io/upload_images/1797904-6f96e55ed8d87b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",[26],[782],{"type":14,"tag":50,"props":783,"children":785},{"alt":50,"src":784},"/images/2021-01-20-Perlin-map/1797904-6f96e55ed8d87b04.png",[],{"type":14,"tag":133,"props":787,"children":788},{},[789],{"type":19,"value":790},"图6：不同频率和振幅参数下的柏林噪声结果",{"type":14,"tag":15,"props":792,"children":793},{},[794],{"type":19,"value":795},"将所有结果叠加在一起，我们就能得到以下结果：",{"type":14,"tag":15,"props":797,"children":798},{},[799,808],{"type":14,"tag":22,"props":800,"children":803},{"href":801,"rel":802},"https://upload-images.jianshu.io/upload_images/1797904-c69b2bf9e253defb.png?imageMogr2/auto-orient/strip",[26],[804],{"type":14,"tag":50,"props":805,"children":807},{"alt":50,"src":806},"/images/2021-01-20-Perlin-map/1797904-c69b2bf9e253defb.png",[],{"type":14,"tag":133,"props":809,"children":810},{},[811],{"type":19,"value":812},"图7：图6所有噪声的叠加结果",{"type":14,"tag":15,"props":814,"children":815},{},[816,818,823],{"type":19,"value":817},"很明显，这样的噪声结果更加令人信服。上面的6组噪声被称之为噪声的不同",{"type":14,"tag":358,"props":819,"children":820},{},[821],{"type":19,"value":822},"倍频(Octave)",{"type":19,"value":824},"。随着倍频增大，噪声对于最终叠加噪声的影响程度变小。当然，倍频组数的增加，会线性地增加代码执行时间，在游戏运行时使用噪声算法，再好不要使用超过几组倍频（比如，当你想在60fps下模拟火焰特效时，最好不要这么干）。然而，做数据预处理时，就很适合使用多组倍频叠加来模拟更自然的噪声（比如用于提前生成游戏地形等）。",{"type":14,"tag":15,"props":826,"children":827},{},[828,830,835,837,844],{"type":19,"value":829},"那我们应该分别挑选多大的频率和振幅来进行噪声计算呢？这个可以通过",{"type":14,"tag":358,"props":831,"children":832},{},[833],{"type":19,"value":834},"persistence",{"type":19,"value":836},"参数确定。",{"type":14,"tag":22,"props":838,"children":841},{"href":839,"rel":840},"http://freespace.virgin.net/hugo.elias/models/m_perlin.htm",[26],[842],{"type":19,"value":843},"Hugo Elias",{"type":19,"value":845},"对persistence的定义使用如下：",{"type":14,"tag":15,"props":847,"children":848},{},[849],{"type":14,"tag":22,"props":850,"children":853},{"href":851,"rel":852},"https://upload-images.jianshu.io/upload_images/1797904-b7093e0ea840d56c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",[26],[854],{"type":14,"tag":50,"props":855,"children":857},{"alt":50,"src":856},"/images/2021-01-20-Perlin-map/1797904-b7093e0ea840d56c.png",[],{"type":14,"tag":15,"props":859,"children":860},{},[861],{"type":14,"tag":22,"props":862,"children":865},{"href":863,"rel":864},"https://upload-images.jianshu.io/upload_images/1797904-006ffe9e12825253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",[26],[866],{"type":14,"tag":50,"props":867,"children":869},{"alt":50,"src":868},"/images/2021-01-20-Perlin-map/1797904-006ffe9e12825253.png",[],{"type":14,"tag":15,"props":871,"children":872},{},[873,875,881],{"type":19,"value":874},"以上公式",{"type":14,"tag":94,"props":876,"children":878},{"className":877},[],[879],{"type":19,"value":880},"i",{"type":19,"value":882},"的值取决于倍频数量，代码实现也很简单：",{"type":14,"tag":15,"props":884,"children":885},{},[886],{"type":19,"value":252},{"type":14,"tag":254,"props":888,"children":890},{"code":889},"public double OctavePerlin(double x, double y, double z, int octaves, double persistence) {\n    double total = 0;\n    double frequency = 1;\n    double amplitude = 1;\n    double maxValue = 0;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i\u003Coctaves;i++) {\n        total += perlin(x * frequency, y * frequency, z * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2;\n    }\n    \n    return total/maxValue;\n}\n",[891],{"type":14,"tag":94,"props":892,"children":893},{"__ignoreMap":7},[894],{"type":19,"value":889},{"type":14,"tag":60,"props":896,"children":897},{},[],{"type":14,"tag":64,"props":899,"children":901},{"id":900},"unity",[902],{"type":19,"value":903},"UNITY",{"title":7,"searchDepth":905,"depth":905,"links":906},2,[907,908,909,910,911],{"id":436,"depth":905,"text":439},{"id":362,"depth":905,"text":538},{"id":583,"depth":905,"text":586},{"id":653,"depth":905,"text":656},{"id":739,"depth":905,"text":742},"markdown","content:game:2021-01-20-Perlin-map.md","content","game/2021-01-20-Perlin-map.md","md","2021-01-20",[919,929,1056,1103,1155,1168,1280],{"title":920,"_path":921,"children":922},"Art","/art",[923,926],{"title":924,"_path":925},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":927,"_path":928},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":930,"_path":931,"children":932},"Dotnet","/dotnet",[933,936,939,942,945,948,951,954,957,960,963,966,969,972,975,978,981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017,1020,1023,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053],{"title":934,"_path":935},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":937,"_path":938},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":940,"_path":941},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":943,"_path":944},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":946,"_path":947},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":949,"_path":950},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":952,"_path":953},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":955,"_path":956},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":958,"_path":959},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":961,"_path":962},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":964,"_path":965},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":967,"_path":968},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":970,"_path":971},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":973,"_path":974},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":976,"_path":977},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":979,"_path":980},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":982,"_path":983},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":985,"_path":986},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":988,"_path":989},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":991,"_path":992},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":994,"_path":995},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":997,"_path":998},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1000,"_path":1001},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1003,"_path":1004},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1006,"_path":1007},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1009,"_path":1010},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1012,"_path":1013},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1015,"_path":1016},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1018,"_path":1019},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1021,"_path":1022},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1024,"_path":1025},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1027,"_path":1028},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1030,"_path":1031},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1033,"_path":1034},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1036,"_path":1037},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1039,"_path":1040},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1042,"_path":1043},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1045,"_path":1046},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1048,"_path":1049},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1051,"_path":1052},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1054,"_path":1055},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1057,"_path":1058,"children":1059},"Game","/game",[1060,1061,1064,1067,1070,1073,1076,1079,1082,1085,1088,1091,1094,1097,1100],{"title":8,"_path":4},{"title":1062,"_path":1063},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1065,"_path":1066},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1068,"_path":1069},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1071,"_path":1072},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1074,"_path":1075},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1077,"_path":1078},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1080,"_path":1081},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1083,"_path":1084},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1086,"_path":1087},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1089,"_path":1090},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1092,"_path":1093},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1095,"_path":1096},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1098,"_path":1099},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1101,"_path":1102},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1104,"_path":1105,"children":1106},"Gyj","/gyj",[1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140,1143,1146,1149,1152],{"title":1108,"_path":1109},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1111,"_path":1112},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1114,"_path":1115},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1117,"_path":1118},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1120,"_path":1121},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1123,"_path":1124},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1126,"_path":1127},"玩法","/gyj/2022-08-22-wanfa",{"title":1129,"_path":1130},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1132,"_path":1133},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1135,"_path":1136},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1138,"_path":1139},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1141,"_path":1142},"门派内容相关","/gyj/2022-11-17-sect",{"title":1144,"_path":1145},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1147,"_path":1148},"种植","/gyj/2022-12-01-zhongzhi",{"title":1150,"_path":1151},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1153,"_path":1154},"跑商","/gyj/2023-11-01-paoshang",{"title":1156,"_path":1157,"children":1158},"Js","/js",[1159,1162,1165],{"title":1160,"_path":1161},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1163,"_path":1164},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1166,"_path":1167},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1169,"_path":1170,"children":1171},"Tool","/tool",[1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202,1205,1208,1211,1214,1217,1220,1223,1226,1229,1232,1235,1238,1241,1244,1247,1250,1253,1256,1259,1262,1265,1268,1271,1274,1277],{"title":1173,"_path":1174},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1176,"_path":1177},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1179,"_path":1180},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1182,"_path":1183},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1185,"_path":1186},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1188,"_path":1189},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1191,"_path":1192},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1194,"_path":1195},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1197,"_path":1198},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1200,"_path":1201},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1203,"_path":1204},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1206,"_path":1207},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1209,"_path":1210},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1212,"_path":1213},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1215,"_path":1216},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1218,"_path":1219},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1221,"_path":1222},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1224,"_path":1225},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1227,"_path":1228},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1230,"_path":1231},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1233,"_path":1234},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1236,"_path":1237},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1239,"_path":1240},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1242,"_path":1243},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1245,"_path":1246},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1248,"_path":1249},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1251,"_path":1252},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1254,"_path":1255},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1257,"_path":1258},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1260,"_path":1261},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1263,"_path":1264},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1266,"_path":1267},"rider的使用","/tool/2022-08-02-rider-use",{"title":1269,"_path":1270},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1272,"_path":1273},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1275,"_path":1276},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1278,"_path":1279},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1281,"_path":1282,"children":1283},"Unity","/unity",[1284,1287,1290,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392,1395,1398,1401,1404,1407,1410,1413,1416,1419,1422,1425,1428,1431,1434,1437,1440,1443,1446,1449,1452,1455,1458,1461,1464,1467,1470,1473,1476,1479,1482,1485,1488,1491,1494,1497],{"title":1285,"_path":1286},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1288,"_path":1289},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1291,"_path":1292},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1294,"_path":1295},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1297,"_path":1298},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1300,"_path":1301},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1303,"_path":1304},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1306,"_path":1307},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1309,"_path":1310},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1312,"_path":1313},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1315,"_path":1316},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1318,"_path":1319},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1321,"_path":1322},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1324,"_path":1325},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1327,"_path":1328},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1330,"_path":1331},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1333,"_path":1334},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1336,"_path":1337},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1339,"_path":1340},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1342,"_path":1343},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1345,"_path":1346},"技能系统","/unity/2020-02-15-skill-system",{"title":1348,"_path":1349},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1351,"_path":1352},"角色状态设计","/unity/2020-02-17-character-states",{"title":1354,"_path":1355},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1357,"_path":1358},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1360,"_path":1361},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1363,"_path":1364},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1366,"_path":1367},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1369,"_path":1370},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1372,"_path":1373},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1375,"_path":1376},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1378,"_path":1379},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1381,"_path":1382},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1384,"_path":1385},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1387,"_path":1388},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1390,"_path":1391},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1393,"_path":1394},"unity的addressables","/unity/2020-09-12-addressables",{"title":1396,"_path":1397},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1399,"_path":1400},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1402,"_path":1403},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1405,"_path":1406},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1408,"_path":1409},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1411,"_path":1412},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1414,"_path":1415},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1417,"_path":1418},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1420,"_path":1421},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1423,"_path":1424},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1426,"_path":1427},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1429,"_path":1430},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1432,"_path":1433},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1435,"_path":1436},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1438,"_path":1439},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1441,"_path":1442},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1444,"_path":1445},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1447,"_path":1448},"ability","/unity/2020-11-16-dotssample",{"title":1450,"_path":1451},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1453,"_path":1454},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1456,"_path":1457},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1459,"_path":1460},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1462,"_path":1463},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1465,"_path":1466},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1468,"_path":1469},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1471,"_path":1472},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1474,"_path":1475},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1477,"_path":1478},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1480,"_path":1481},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1483,"_path":1484},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1486,"_path":1487},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1489,"_path":1490},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1492,"_path":1493},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1495,"_path":1496},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1498,"_path":1499},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779036576]