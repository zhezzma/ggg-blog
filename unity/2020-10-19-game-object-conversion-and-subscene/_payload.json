[{"data":1,"prerenderedAt":5876},["Reactive",2],{"content-query-BvHFm9sxv2":3,"content-navigation-8C37fagqQL":5294},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":5288,"_id":5289,"_source":5290,"_file":5291,"_extension":5292,"date":5293},"/unity/2020-10-19-game-object-conversion-and-subscene","unity",false,"","基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","*(译前言: Unity DOTS提出了一套全新的开发技术栈, 但目前少有精讲如何结合现有工作流进行开发的资料, 外网 *这篇文章 (Game Object Conversion and SubScene) 详细解构了基于 GameObject 和 Subscene 的工作流程和原理, 要求读者对 DOTS/ECS 有基本的了解, 虽然非常之长, 但值得一读)",{"type":11,"children":12,"toc":5253},"root",[13,36,40,45,51,59,64,69,99,111,116,121,127,140,169,224,245,251,308,341,382,387,392,418,430,437,442,451,456,463,475,487,494,513,519,524,529,536,587,592,601,614,619,654,663,670,675,682,687,692,718,746,751,757,769,774,782,802,814,947,953,984,1048,1060,1087,1094,1107,1155,1167,1173,1178,1187,1198,1266,1273,1320,1327,1333,1352,1363,1372,1436,1441,1450,1456,1475,1495,1508,1536,1542,1579,1626,1633,1645,1652,1659,1685,1690,1697,1702,1709,1716,1735,1760,1767,1774,1794,1801,1837,1850,1856,1880,1887,1907,1926,1988,2007,2014,2026,2033,2038,2073,2091,2125,2165,2170,2177,2183,2210,2217,2236,2242,2247,2267,2298,2305,2310,2317,2324,2370,2375,2393,2400,2407,2412,2418,2430,2478,2483,2510,2523,2536,2543,2563,2568,2575,2595,2604,2611,2653,2662,2667,2673,2701,2733,2745,2752,2759,2764,2771,2776,2782,2794,2837,2846,2900,2913,2932,2965,2971,2981,3070,3089,3122,3140,3146,3179,3184,3193,3198,3207,3214,3240,3247,3259,3265,3290,3302,3309,3352,3359,3364,3420,3425,3431,3436,3441,3450,3455,3462,3467,3474,3479,3485,3490,3495,3501,3506,3511,3518,3523,3529,3534,3539,3547,3552,3560,3565,3573,3583,3591,3596,3601,3610,3615,3620,3629,3634,3642,3654,3659,3667,3672,3684,3689,3694,3699,3704,3716,3721,3727,3732,3740,3745,3752,3759,3764,3773,3778,3785,3808,3816,3821,3826,3831,3839,3844,3852,3857,3864,3874,3881,3890,3895,3902,3911,3918,3926,3931,3938,3947,3952,3960,3987,3995,4000,4005,4011,4020,4027,4032,4037,4042,4047,4055,4067,4072,4077,4086,4094,4099,4105,4112,4117,4124,4131,4136,4141,4148,4153,4162,4167,4174,4181,4186,4193,4198,4207,4212,4221,4226,4235,4240,4245,4252,4259,4264,4276,4281,4290,4297,4307,4312,4321,4326,4332,4342,4347,4356,4363,4370,4375,4384,4391,4396,4401,4410,4417,4427,4436,4443,4448,4457,4462,4468,4473,4478,4485,4492,4497,4506,4513,4518,4525,4530,4535,4540,4547,4552,4559,4564,4571,4576,4583,4594,4600,4605,4617,4622,4631,4643,4648,4655,4660,4667,4672,4677,4684,4689,4694,4699,4707,4717,4722,4727,4732,4739,4744,4753,4760,4765,4774,4779,4786,4791,4797,4802,4811,4823,4828,4841,4846,4855,4860,4865,4873,4882,4887,4892,4901,4906,4911,4920,4925,4930,4972,4979,4987,4992,4997,5004,5009,5016,5023,5028,5035,5053,5058,5063,5070,5080,5090,5097,5122,5132,5140,5147,5152,5161,5170,5175,5180,5187,5195,5200,5205,5212,5217,5224,5229,5236,5241,5246],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18,21,34],{"type":19,"value":20},"text","*(译前言: Unity DOTS提出了一套全新的开发技术栈, 但目前少有精讲如何结合现有工作流进行开发的资料, 外网 *",{"type":14,"tag":22,"props":23,"children":27},"a",{"href":24,"rel":25},"https://link.zhihu.com/?target=https%3A//gametorrahod.com/game-object-conversion-and-subscene/",[26],"nofollow",[28],{"type":14,"tag":29,"props":30,"children":31},"em",{},[32],{"type":19,"value":33},"这篇文章 (Game Object Conversion and SubScene)",{"type":19,"value":35}," 详细解构了基于 GameObject 和 Subscene 的工作流程和原理, 要求读者对 DOTS/ECS 有基本的了解, 虽然非常之长, 但值得一读)",{"type":14,"tag":37,"props":38,"children":39},"hr",{},[],{"type":14,"tag":15,"props":41,"children":42},{},[43],{"type":19,"value":44},"游戏基本上就是关于玩家的输入如何改变(设计好的)数据, 并从渲染结果中得到乐趣的过程. 传统上, 这些数据是用 Unity 的所见即所得的编辑器来设计的. 但是基于 GameObject 的数据和 ECS 并不兼容. 如果在设计数据阶段能保留Unity的传统模式同时在 Runtime 阶段使用 ECS 高效处理数据, 那就能完美结合两者的优点.",{"type":14,"tag":46,"props":47,"children":49},"h2",{"id":48},"以前是如何制作游戏的",[50],{"type":19,"value":48},{"type":14,"tag":15,"props":52,"children":53},{},[54],{"type":14,"tag":55,"props":56,"children":58},"img",{"alt":55,"src":57},"/images/2020-10-19-game-object-conversion-and-subscene/v2-6189e6b1d575c1ad9bbec966f5e99ee4_720w.jpg",[],{"type":14,"tag":15,"props":60,"children":61},{},[62],{"type":19,"value":63},"如上图, 首先想想为什么方块能在每帧都被正确绘制到屏幕上? 在传统的 GameObject 里, 引擎会编译并排序整个 hierarchy 树, 同时按顺序调用绘制函数(draw call). 每次 Draw call 调用之间引擎需要初始化 material 和 mesh (也即 set pass call, 如果和前一次调用一样则无需初始化). 在内部 Unity 可能尝试合并 mesh 来减少 draw call (dynamic batching 和 static batching), 如果是 Dynamic 对象这步操作会增加一些 CPU 开销, 如果是 static 则会在build 时预先合并.",{"type":14,"tag":15,"props":65,"children":66},{},[67],{"type":19,"value":68},"换句话说, 我们使用 Unity 构建的游戏保存在 YAML格式的 Scene文件中. 尽管游戏并非在 YAML 基础上运行, 在加载 Scene 并解析了方块 .prefab 文件后, 引起会准备一些 C++ 的内存用来存储 Transform, 相应代码则基于此来绘制.",{"type":14,"tag":15,"props":70,"children":71},{},[72,74,80,82,89,91,97],{"type":19,"value":73},"在同一帧中这是同一块操作. 并取决于",{"type":14,"tag":75,"props":76,"children":77},"strong",{},[78],{"type":19,"value":79},"数据",{"type":19,"value":81},"本身, 每个方块的",{"type":14,"tag":83,"props":84,"children":86},"code",{"className":85},[],[87],{"type":19,"value":88},"Transform",{"type":19,"value":90},"和 ",{"type":14,"tag":83,"props":92,"children":94},{"className":93},[],[95],{"type":19,"value":96},"MeshFilter",{"type":19,"value":98}," 告知了我们绘制什么. 不幸的是, 绘制都关注于什么样draw call 顺序能得到的正确的结果, 而所有这些绘制都来自于对于数据某些形式的迭代. (在C++中如果数据排布不佳依然不一定能高效迭代). 大家知道 ECS 擅长数据迭代. 而 Burst 加 ECS 则能帮助数据容易多线程处理, 这是我们为什么要用 ECS 来开发游戏的原因.",{"type":14,"tag":15,"props":100,"children":101},{},[102,104,109],{"type":19,"value":103},"另一块操作则是逻辑. 在绘制之前, 比如方块可能有个 Bouncing 组件在持续地改变它的 ",{"type":14,"tag":83,"props":105,"children":107},{"className":106},[],[108],{"type":19,"value":88},{"type":19,"value":110}," (好让你的游戏变得更有趣). 在改变用于绘制的数据这方面, ECS 依然能帮到你.",{"type":14,"tag":15,"props":112,"children":113},{},[114],{"type":19,"value":115},"游戏基本上就这些了, 你有一些数据, 然后可能根据玩家的输入等因素来改变, 最后在每一帧中绘制出来.",{"type":14,"tag":15,"props":117,"children":118},{},[119],{"type":19,"value":120},"结合改变数据和对数据的绘制, 玩家应该开始能感受到乐趣了! 事实上这一过程也常常使人放松(比如看着一个球在屏幕上下移动). 从纯数据的角度来审视游戏非常重要, 否则你无法接受基于 DOTS 来开发游戏的方式.",{"type":14,"tag":46,"props":122,"children":124},{"id":123},"如何在-dots-的世界里做游戏",[125],{"type":19,"value":126},"如何在 DOTS 的世界里做游戏",{"type":14,"tag":15,"props":128,"children":129},{},[130,132,138],{"type":19,"value":131},"和",{"type":14,"tag":83,"props":133,"children":135},{"className":134},[],[136],{"type":19,"value":137},"GameOjbect",{"type":19,"value":139},"不同, 数据在ECS里类似数据库, 设想一下, 因为我们可以使用Jobs或者 SIMD指令来更快地迭代数据, 所以不仅改变数据的逻辑非常高效而且绘制本身也是高效的.",{"type":14,"tag":15,"props":141,"children":142},{},[143,145,151,153,159,161,167],{"type":19,"value":144},"接下来我们直接跳到最后. 我现在已经在使用ECS并且我有3个 transform 矩阵需要绘制(以",{"type":14,"tag":83,"props":146,"children":148},{"className":147},[],[149],{"type":19,"value":150},"IcomponentData",{"type":19,"value":152},"形式, 所以迭代是线性且快速的) , 外加对应的 ",{"type":14,"tag":83,"props":154,"children":156},{"className":155},[],[157],{"type":19,"value":158},"Mesh",{"type":19,"value":160}," 和 ",{"type":14,"tag":83,"props":162,"children":164},{"className":163},[],[165],{"type":19,"value":166},"Material",{"type":19,"value":168},".",{"type":14,"tag":15,"props":170,"children":171},{},[172,174,180,182,189,191,197,199,205,207,214,216,222],{"type":19,"value":173},"使用 Unity 的 Graphics Api 我们可以直接绘制这些数据而无需 ",{"type":14,"tag":83,"props":175,"children":177},{"className":176},[],[178],{"type":19,"value":179},"GameObject",{"type":19,"value":181}," 这个数据容器! 参考 ",{"type":14,"tag":22,"props":183,"children":186},{"href":184,"rel":185},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/Graphics.html",[26],[187],{"type":19,"value":188},"Unity - Scripting API: Graphics",{"type":19,"value":190}," 以及支持 ",{"type":14,"tag":83,"props":192,"children":194},{"className":193},[],[195],{"type":19,"value":196},"NativeArray",{"type":19,"value":198}," 的 ",{"type":14,"tag":83,"props":200,"children":202},{"className":201},[],[203],{"type":19,"value":204},"BatchRendererGroup",{"type":19,"value":206},"(",{"type":14,"tag":22,"props":208,"children":211},{"href":209,"rel":210},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html",[26],[212],{"type":19,"value":213},"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html",{"type":19,"value":215},"). 这时你已经可以直接从数据来绘制了. 只需要用 ECS 的",{"type":14,"tag":83,"props":217,"children":219},{"className":218},[],[220],{"type":19,"value":221},"EntityQuery",{"type":19,"value":223},"等方法来获取数据并绘制它们.",{"type":14,"tag":15,"props":225,"children":226},{},[227,229,236,238,243],{"type":19,"value":228},"参考这篇日文博客(",{"type":14,"tag":22,"props":230,"children":233},{"href":231,"rel":232},"https://link.zhihu.com/?target=https%3A//virtualcast.jp/blog/2019/10/batchrenderergroup/",[26],[234],{"type":19,"value":235},"https://virtualcast.jp/blog/2019/10/batchrenderergroup/",{"type":19,"value":237},"), 描述了 BatchRendererGroup 的优势. 尽管 \"batches\" 数量巨大, 性能依然优异. 要注意 batching 实际上是合并 mesh 的操作, 因此有一定的计算量. 绘制就是重复地调用没有改变的数据,只要你将 NativeArray 的内存留在 ",{"type":14,"tag":83,"props":239,"children":241},{"className":240},[],[242],{"type":19,"value":204},{"type":19,"value":244}," 里面, 1000+的 \"batches\" 一点也不可怕.(较低的\"set pass call\"展示了在帧间绘制时并没有太多了 material 切换)",{"type":14,"tag":46,"props":246,"children":248},{"id":247},"hybrid-renderer",[249],{"type":19,"value":250},"Hybrid Renderer",{"type":14,"tag":15,"props":252,"children":253},{},[254,256,263,265,271,273,279,280,286,288,293,294,299,301,306],{"type":19,"value":255},"Unity 开发了 Hybrid Renderer (",{"type":14,"tag":22,"props":257,"children":260},{"href":258,"rel":259},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.rendering.hybrid%40latest",[26],[261],{"type":19,"value":262},"https://docs.unity3d.com/Packages/com.unity.rendering.hybrid@latest",{"type":19,"value":264},") 来完成上文提到的绘制工作. 如果你有一个关联 ",{"type":14,"tag":83,"props":266,"children":268},{"className":267},[],[269],{"type":19,"value":270},"LocalToworld",{"type":19,"value":272}," 组件(也即Transform矩阵)的 Entity , 且Entity 所在 Chunk 关联了是 ",{"type":14,"tag":83,"props":274,"children":276},{"className":275},[],[277],{"type":19,"value":278},"ISharedComponentData",{"type":19,"value":198},{"type":14,"tag":83,"props":281,"children":283},{"className":282},[],[284],{"type":19,"value":285},"RenderMesh",{"type":19,"value":287}," 组件 (",{"type":14,"tag":83,"props":289,"children":291},{"className":290},[],[292],{"type":19,"value":158},{"type":19,"value":160},{"type":14,"tag":83,"props":295,"children":297},{"className":296},[],[298],{"type":19,"value":166},{"type":19,"value":300}," 不在 ECS 框架下), 那么它就会使用 ",{"type":14,"tag":83,"props":302,"children":304},{"className":303},[],[305],{"type":19,"value":204},{"type":19,"value":307}," 来绘制数据.",{"type":14,"tag":15,"props":309,"children":310},{},[311,313,319,321,326,327,332,334,339],{"type":19,"value":312},"整个 Chunk 基于 ",{"type":14,"tag":83,"props":314,"children":316},{"className":315},[],[317],{"type":19,"value":318},"LocalToWorld",{"type":19,"value":320}," 的数量来绘制的是同样数量的 mesh 和 material. 这已经类似于CPU版本的 GPU instancing 了, 只使用 draw call 是非常快的, 这种粗暴的绘制方式甚至可能比花费 CPU 来每帧合并 mesh 的方式还要快. 由于同一 chunk 使用同样的 ",{"type":14,"tag":83,"props":322,"children":324},{"className":323},[],[325],{"type":19,"value":158},{"type":19,"value":160},{"type":14,"tag":83,"props":328,"children":330},{"className":329},[],[331],{"type":19,"value":166},{"type":19,"value":333}," , 并非100%无需 set pass call. 如果你的 Material 开启了 GPU instancing, ",{"type":14,"tag":83,"props":335,"children":337},{"className":336},[],[338],{"type":19,"value":204},{"type":19,"value":340}," 可以批量绘制可不是快速的重绘.",{"type":14,"tag":15,"props":342,"children":343},{},[344,346,351,353,358,360,366,368,373,375,380],{"type":19,"value":345},"之所以这种方式称之为 Hybrid 是因为 ",{"type":14,"tag":83,"props":347,"children":349},{"className":348},[],[350],{"type":19,"value":204},{"type":19,"value":352}," 是普通的 Unity API 而不是 ECS API. 但是这并不意味着这不是 Data-Oriented. 事实上 ",{"type":14,"tag":83,"props":354,"children":356},{"className":355},[],[357],{"type":19,"value":204},{"type":19,"value":359}," 工作的方式非常地 Data-Oriented: 就是由 ",{"type":14,"tag":83,"props":361,"children":363},{"className":362},[],[364],{"type":19,"value":365},"MaterialPropertyBlock",{"type":19,"value":367}," 和 Transform 矩阵构成的 ",{"type":14,"tag":83,"props":369,"children":371},{"className":370},[],[372],{"type":19,"value":196},{"type":19,"value":374}," 数据. 所以别害怕使用它(Hybrid Renderer) 除非你知道如何使用 Graphics API 或者使用 ",{"type":14,"tag":83,"props":376,"children":378},{"className":377},[],[379],{"type":19,"value":204},{"type":19,"value":381},"构建你自己的渲染模式. (或许可以去掉非必须的步骤比如 culling).",{"type":14,"tag":46,"props":383,"children":385},{"id":384},"让我们用纯数据来做个游戏吧",[386],{"type":19,"value":384},{"type":14,"tag":15,"props":388,"children":389},{},[390],{"type":19,"value":391},"既然已经接受了游戏就是改变数据和展示数据, 使用 Hybrid Renderer 我们就可以来做游戏了. 我们假设这就是关于一个上下弹跳的方块的游戏, 按住空格的时候让它跳的更疯狂, 这可能对于小孩子来讲非常有趣.",{"type":14,"tag":15,"props":393,"children":394},{},[395,397,402,403,408,410,416],{"type":19,"value":396},"首先要解决的问题, 如何获取到我们需要的 ",{"type":14,"tag":83,"props":398,"children":400},{"className":399},[],[401],{"type":19,"value":158},{"type":19,"value":160},{"type":14,"tag":83,"props":404,"children":406},{"className":405},[],[407],{"type":19,"value":166},{"type":19,"value":409},". 我想我会使用 ",{"type":14,"tag":83,"props":411,"children":413},{"className":412},[],[414],{"type":19,"value":415},"Rensources.Load",{"type":19,"value":417},"来加载一个引用了相关 asset 的 prefab:",{"type":14,"tag":419,"props":420,"children":425},"pre",{"className":421,"code":423,"language":424,"meta":7},[422],"language-csharp","using UnityEngine;\n\npublic class AssetHolder : MonoBehaviour\n{\n    public Mesh myMesh;\n    public Material myMaterial;\n}\n","csharp",[426],{"type":14,"tag":83,"props":427,"children":428},{"__ignoreMap":7},[429],{"type":19,"value":423},{"type":14,"tag":15,"props":431,"children":432},{},[433],{"type":14,"tag":55,"props":434,"children":436},{"alt":55,"src":435},"/images/2020-10-19-game-object-conversion-and-subscene/v2-2fd0d4674c7f066e2e1059dd48558882_720w.jpg",[],{"type":14,"tag":15,"props":438,"children":439},{},[440],{"type":19,"value":441},"下面的 System 用来创建Hybrid Renderer 要使用的数据.",{"type":14,"tag":419,"props":443,"children":446},{"className":444,"code":445,"language":424,"meta":7},[422],"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Rendering;\nusing Unity.Transforms;\nusing UnityEngine;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class CubeGameSystem : JobComponentSystem\n{\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        var myCube = EntityManager.CreateEntity(\n            ComponentType.ReadOnly\u003CLocalToWorld>(),\n            ComponentType.ReadOnly\u003CRenderMesh>()\n        );\n        EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n        var ah = Resources.Load\u003CGameObject>(\"AssetHolder\").GetComponent\u003CAssetHolder>();\n        EntityManager.SetSharedComponentData(myCube, new RenderMesh\n        {\n            mesh = ah.myMesh,\n            material = ah.myMaterial\n        });\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        return default;\n    }\n}\n",[447],{"type":14,"tag":83,"props":448,"children":449},{"__ignoreMap":7},[450],{"type":19,"value":445},{"type":14,"tag":15,"props":452,"children":453},{},[454],{"type":19,"value":455},"瞧, 我的 data-oriented 方块坐标位于 (1, 2, 3)!",{"type":14,"tag":15,"props":457,"children":458},{},[459],{"type":14,"tag":55,"props":460,"children":462},{"alt":55,"src":461},"/images/2020-10-19-game-object-conversion-and-subscene/v2-e531723f584b5747646fc3340dc937ef_720w.jpg",[],{"type":14,"tag":15,"props":464,"children":465},{},[466,468,473],{"type":19,"value":467},"可以看到 Hierarchy 窗口里什么都没有, 但是方块却出现了. 编辑器窗口里也无法选中它, 它仅仅是被绘制了而已. 事实上编辑器里之所以可以选中是因为 ",{"type":14,"tag":83,"props":469,"children":471},{"className":470},[],[472],{"type":19,"value":179},{"type":19,"value":474}," 容器连接了绘制的内容和其他编辑的内容.",{"type":14,"tag":15,"props":476,"children":477},{},[478,480,485],{"type":19,"value":479},"如果现在检查 Entity Debugger, 你会注意到 Hybrid Renderer 又添加了一些别的东西. 它会在提交数据到 ",{"type":14,"tag":83,"props":481,"children":483},{"className":482},[],[484],{"type":19,"value":204},{"type":19,"value":486}," 之前剔除掉无法被看到的东西.",{"type":14,"tag":15,"props":488,"children":489},{},[490],{"type":14,"tag":55,"props":491,"children":493},{"alt":55,"src":492},"/images/2020-10-19-game-object-conversion-and-subscene/v2-218f24f57c5b783f8d52064804a8e977_720w.jpg",[],{"type":14,"tag":15,"props":495,"children":496},{},[497,499,504,506,511],{"type":19,"value":498},"以上意味着: \"你拥有 1 个chunk, 该 chunk 能容纳 128 个 Entity ( 1 个 Entity占用 125 字节, 1 个 chunk 16kb), 你已经使用了该 chunk 其中 1 个位置, 你还能添加 127 个方块. Hybrid Renderer 把方块 ",{"type":14,"tag":83,"props":500,"children":502},{"className":501},[],[503],{"type":19,"value":318},{"type":19,"value":505}," 数据喂给 ",{"type":14,"tag":83,"props":507,"children":509},{"className":508},[],[510],{"type":19,"value":204},{"type":19,"value":512}," 时, 这些数据在内存中都是连续排列的.",{"type":14,"tag":46,"props":514,"children":516},{"id":515},"transform-systems",[517],{"type":19,"value":518},"Transform systems",{"type":14,"tag":15,"props":520,"children":521},{},[522],{"type":19,"value":523},"现在你有一个数据并且绘制了, 接下来我们加点玩法.",{"type":14,"tag":15,"props":525,"children":526},{},[527],{"type":19,"value":528},"如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:",{"type":14,"tag":15,"props":530,"children":531},{},[532],{"type":14,"tag":55,"props":533,"children":535},{"alt":55,"src":534},"/images/2020-10-19-game-object-conversion-and-subscene/v2-1eb72ea2222c31c50554021afecb27d1_720w.jpg",[],{"type":14,"tag":15,"props":537,"children":538},{},[539,541,547,549,555,556,562,564,570,572,578,580,585],{"type":19,"value":540},"使用",{"type":14,"tag":83,"props":542,"children":544},{"className":543},[],[545],{"type":19,"value":546},"Translation",{"type":19,"value":548},",",{"type":14,"tag":83,"props":550,"children":552},{"className":551},[],[553],{"type":19,"value":554},"Rotation",{"type":19,"value":548},{"type":14,"tag":83,"props":557,"children":559},{"className":558},[],[560],{"type":19,"value":561},"Scale",{"type":19,"value":563},"/",{"type":14,"tag":83,"props":565,"children":567},{"className":566},[],[568],{"type":19,"value":569},"NonUniformScale",{"type":19,"value":571},"组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 ",{"type":14,"tag":83,"props":573,"children":575},{"className":574},[],[576],{"type":19,"value":577},"Parent",{"type":19,"value":579}," 组件指向了父 Entity, 那么最终该 Entity 的 ",{"type":14,"tag":83,"props":581,"children":583},{"className":582},[],[584],{"type":19,"value":318},{"type":19,"value":586}," 值将会和父 Entity的 LocalToWorld 一样.",{"type":14,"tag":15,"props":588,"children":589},{},[590],{"type":19,"value":591},"接下来我们添加 Translation 给方块. 玩法系统现在就可以通过修改 Translation 而不是 LocalToWorld了. 我同时添加了 Cube 组件作为 Tag, 这样子代码会更加清晰:",{"type":14,"tag":419,"props":593,"children":596},{"className":594,"code":595,"language":424,"meta":7},[422],"var myCube = EntityManager.CreateEntity(\n    ComponentType.ReadOnly\u003CTranslation>(),\n    ComponentType.ReadOnly\u003CCube>(), //Tag\n    ComponentType.ReadOnly\u003CLocalToWorld>(),\n    ComponentType.ReadOnly\u003CRenderMesh>()\n);\n",[597],{"type":14,"tag":83,"props":598,"children":599},{"__ignoreMap":7},[600],{"type":19,"value":595},{"type":14,"tag":15,"props":602,"children":603},{},[604,606,612],{"type":19,"value":605},"接下来实现弹跳. 我们使用 ",{"type":14,"tag":83,"props":607,"children":609},{"className":608},[],[610],{"type":19,"value":611},"Time .ElapsedTime",{"type":19,"value":613}," 作为余弦函数的输入, 会返回一个从 0 到 1来回的值.",{"type":14,"tag":15,"props":615,"children":616},{},[617],{"type":19,"value":618},"注意, ECS 妙的一点在于你可以不断地添加新系统来实现代码的\"横向地\"以构建更多玩法. 模式则是从 ECS 快速的数据库里查询数据, 然后修改, 再存回去. 你可能对这种每次都查询-修改都要增加新 System 的模式觉得有些不安, 但这种模式提升了代码的扩展性. 而 Unity ECS 则确保了重复的数据查询是高效的, 因此在代码中有大量逻辑简单的 System 是完全可行的.",{"type":14,"tag":15,"props":620,"children":621},{},[622,624,629,631,636,638,644,646,652],{"type":19,"value":623},"我们的弹跳系统先在主线程检查空格是否按下, 并声明相关变量, 最后在 Lambda jobs 中捕获这些变量, 并根据此并行修改查询到的 Cube 的 ",{"type":14,"tag":83,"props":625,"children":627},{"className":626},[],[628],{"type":19,"value":546},{"type":19,"value":630}," 值, 其中每一个线程会运行时会使用 1 个 chunk 的 Cube 和 ",{"type":14,"tag":83,"props":632,"children":634},{"className":633},[],[635],{"type":19,"value":546},{"type":19,"value":637}," 数据. ",{"type":14,"tag":83,"props":639,"children":641},{"className":640},[],[642],{"type":19,"value":643},"Time",{"type":19,"value":645}," 是由 ECS 库维护的一个属性, 它每帧都会从传统的 ",{"type":14,"tag":83,"props":647,"children":649},{"className":648},[],[650],{"type":19,"value":651},"UnityEngine.Time",{"type":19,"value":653}," 获取相应的数据",{"type":14,"tag":419,"props":655,"children":658},{"className":656,"code":657,"language":424,"meta":7},[422],"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\n[UpdateBefore(typeof(TransformSystemGroup))]\npublic class CubeBouncingSystem : JobComponentSystem\n{\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        int multiplier = Input.GetKey(KeyCode.Space) ? 100 : 20;\n        var elapsedTime = Time.ElapsedTime;\n        \n        JobHandle jh = Entities.WithAll\u003CCube>().ForEach((ref Translation t) =>\n        {\n            float3 value = t.Value;\n            value.y = math.cos((float) elapsedTime * multiplier);\n            t.Value = value;\n        }).Schedule(inputDeps);\n        return jh;\n    }\n}\n",[659],{"type":14,"tag":83,"props":660,"children":661},{"__ignoreMap":7},[662],{"type":19,"value":657},{"type":14,"tag":15,"props":664,"children":665},{},[666],{"type":14,"tag":55,"props":667,"children":669},{"alt":55,"src":668},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f23943863e0ab8ec8907f242579a0884_b.jpg",[],{"type":14,"tag":15,"props":671,"children":672},{},[673],{"type":19,"value":674},"Worker 线程现在已经在工作了. 当你用这种方式构建游戏, 最终几乎每个 Worker 线程都会来回使用以避免闲置:",{"type":14,"tag":15,"props":676,"children":677},{},[678],{"type":14,"tag":55,"props":679,"children":681},{"alt":55,"src":680},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f116b2bea7e7ca411112bc9e82265c54_720w.jpg",[],{"type":14,"tag":46,"props":683,"children":685},{"id":684},"可是这样构建游戏实在是太痛苦了",[686],{"type":19,"value":684},{"type":14,"tag":15,"props":688,"children":689},{},[690],{"type":19,"value":691},"你应该已经注意到, 正儿八经的游戏要改成 data-oriented 并不容易. (除了上文的弹跳球这样的简单场景). 甚至现在你都没法使用所见即所得的编辑器了. 整个游戏如果按照这种方式获取 LTW + Mesh + Material 将会是噩梦般的开发旅程. 虽然整个游戏按照这样的方式构建非常恐怖, 但性能确实是会非常好. 有点倒退回 Cocos2D 时代的感觉. 自然你是想要在编辑器中快速地迭代玩法/美术相关内容.",{"type":14,"tag":15,"props":693,"children":694},{},[695,697,702,704,709,711,716],{"type":19,"value":696},"但记住这个方块绘制效率极高, 如果你添加更多的方块, 它们都会打包喂给",{"type":14,"tag":83,"props":698,"children":700},{"className":699},[],[701],{"type":19,"value":204},{"type":19,"value":703}," 因为在同一个 chunk 内存里 ",{"type":14,"tag":83,"props":705,"children":707},{"className":706},[],[708],{"type":19,"value":318},{"type":19,"value":710}," 已经被连续排列好了. 而复制一个方块也不再是复制",{"type":14,"tag":83,"props":712,"children":714},{"className":713},[],[715],{"type":19,"value":179},{"type":19,"value":717},"这样昂贵的操作, 只需要添加更多 Entity 以及相应的组件.",{"type":14,"tag":15,"props":719,"children":720},{},[721,723,728,730,736,738,744],{"type":19,"value":722},"同样的, 一个 Entity 将数据转存回 ",{"type":14,"tag":83,"props":724,"children":726},{"className":725},[],[727],{"type":19,"value":179},{"type":19,"value":729}," 也不是什么好主意 (",{"type":14,"tag":83,"props":731,"children":733},{"className":732},[],[734],{"type":19,"value":735},"GameObjectEntity",{"type":19,"value":737}," 就做了这样的事儿), 我们想要运行时的 pure ECS , 而不是桥接回 ",{"type":14,"tag":83,"props":739,"children":741},{"className":740},[],[742],{"type":19,"value":743},"MonoBehaviour",{"type":19,"value":745}," 的 ECS.",{"type":14,"tag":15,"props":747,"children":748},{},[749],{"type":19,"value":750},"简言之, 你想要 ECS 的高性能, 但不想要按这样的方式来开发游戏.",{"type":14,"tag":46,"props":752,"children":754},{"id":753},"conversion-workflow",[755],{"type":19,"value":756},"Conversion workflow",{"type":14,"tag":15,"props":758,"children":759},{},[760,762,767],{"type":19,"value":761},"所以 Unity 团队采用了常规的 GameObject 来仅实现",{"type":14,"tag":75,"props":763,"children":764},{},[765],{"type":19,"value":766},"编辑操作(authoring),",{"type":19,"value":768}," 而在运行时, 则将这些 GameObject **转换(convert)**为纯粹的 ECS data.",{"type":14,"tag":15,"props":770,"children":771},{},[772],{"type":19,"value":773},"我之所以之前介绍 renderer 和 transform, 是因为转换过程实际上是将编辑时方便的 GameObject 对象转换为高性能 transform 和 renderring 系统支持的 entity.",{"type":14,"tag":15,"props":775,"children":776},{},[777],{"type":14,"tag":75,"props":778,"children":779},{},[780],{"type":19,"value":781},"Component object",{"type":14,"tag":15,"props":783,"children":784},{},[785,787,793,795,800],{"type":19,"value":786},"在进阶之前, 我假设你已经知道了 component objects. 这不仅是可以添加到 Entity 上的 ",{"type":14,"tag":83,"props":788,"children":790},{"className":789},[],[791],{"type":19,"value":792},"IComponentData",{"type":19,"value":794}," 组件, 你甚至可以使用 ",{"type":14,"tag":83,"props":796,"children":798},{"className":797},[],[799],{"type":19,"value":743},{"type":19,"value":801}," 类型.",{"type":14,"tag":15,"props":803,"children":804},{},[805,807,812],{"type":19,"value":806},"只不过你无法在 jobs 使用这些类型, 很多有 ",{"type":14,"tag":83,"props":808,"children":810},{"className":809},[],[811],{"type":19,"value":792},{"type":19,"value":813}," 约束的泛型 API 也无法被使用. 但是这种类型的组件确实是关联到 Entity 上的, 也有相关的 API 可以使用. 以下是一些支持 component objects API 例子:",{"type":14,"tag":815,"props":816,"children":817},"ul",{},[818,845,876,908],{"type":14,"tag":819,"props":820,"children":821},"li",{},[822,828,830,836,837,843],{"type":14,"tag":83,"props":823,"children":825},{"className":824},[],[826],{"type":19,"value":827},"EntityManager",{"type":19,"value":829},":",{"type":14,"tag":83,"props":831,"children":833},{"className":832},[],[834],{"type":19,"value":835},"AddComponentObject",{"type":19,"value":548},{"type":14,"tag":83,"props":838,"children":840},{"className":839},[],[841],{"type":19,"value":842},"GetComponentObject",{"type":19,"value":844},". 如果添加不存在的组件, 你在获取时会得到一个 null.",{"type":14,"tag":819,"props":846,"children":847},{},[848,854,856,862,864,869,871],{"type":14,"tag":83,"props":849,"children":851},{"className":850},[],[852],{"type":19,"value":853},"ComponentType",{"type":19,"value":855},": 你可以创建 ",{"type":14,"tag":83,"props":857,"children":859},{"className":858},[],[860],{"type":19,"value":861},"\u003CT>",{"type":19,"value":863}," (如",{"type":14,"tag":83,"props":865,"children":867},{"className":866},[],[868],{"type":19,"value":743},{"type":19,"value":870},")类型的 ",{"type":14,"tag":83,"props":872,"children":874},{"className":873},[],[875],{"type":19,"value":853},{"type":14,"tag":819,"props":877,"children":878},{},[879,885,886,892,894,899,901,906],{"type":14,"tag":83,"props":880,"children":882},{"className":881},[],[883],{"type":19,"value":884},"system.GetEntityQuery",{"type":19,"value":548},{"type":14,"tag":83,"props":887,"children":889},{"className":888},[],[890],{"type":19,"value":891},"em.CreateArchetype",{"type":19,"value":893},": 因此你可以使用",{"type":14,"tag":83,"props":895,"children":897},{"className":896},[],[898],{"type":19,"value":743},{"type":19,"value":900},"类型的 ",{"type":14,"tag":83,"props":902,"children":904},{"className":903},[],[905],{"type":19,"value":853},{"type":19,"value":907}," 来创建组件的查询.",{"type":14,"tag":819,"props":909,"children":910},{},[911,916,917,923,925,931,933,939,941],{"type":14,"tag":83,"props":912,"children":914},{"className":913},[],[915],{"type":19,"value":221},{"type":19,"value":829},{"type":14,"tag":83,"props":918,"children":920},{"className":919},[],[921],{"type":19,"value":922},"ToComponentArray",{"type":19,"value":924},"会返回 ",{"type":14,"tag":83,"props":926,"children":928},{"className":927},[],[929],{"type":19,"value":930},"T[]",{"type":19,"value":932},". 这会返回以托管数组方式存储托管组件的结果, 而不是",{"type":14,"tag":83,"props":934,"children":936},{"className":935},[],[937],{"type":19,"value":938},"ToComponentDataArray",{"type":19,"value":940},"那样返回 ",{"type":14,"tag":83,"props":942,"children":944},{"className":943},[],[945],{"type":19,"value":946},"NativeArray\u003CT>",{"type":14,"tag":46,"props":948,"children":950},{"id":949},"conversion-world-destination-world-primary-entity",[951],{"type":19,"value":952},"Conversion world, destination world, primary entity",{"type":14,"tag":15,"props":954,"children":955},{},[956,958,963,965,970,972,977,979],{"type":19,"value":957},"在内部, 转换过程是创建特定目的的 World, 并在其中运行特定的 ",{"type":14,"tag":75,"props":959,"children":960},{},[961],{"type":19,"value":962},"conversion systems",{"type":19,"value":964}," (这样你会得到一个新的 ",{"type":14,"tag":83,"props":966,"children":968},{"className":967},[],[969],{"type":19,"value":827},{"type":19,"value":971},", 以及存储entities 的数据库). 这被称为 ",{"type":14,"tag":75,"props":973,"children":974},{},[975],{"type":19,"value":976},"conversion world",{"type":19,"value":978},". conversion world 同时也知晓用于存储转换结果的 ",{"type":14,"tag":75,"props":980,"children":981},{},[982],{"type":19,"value":983},"destination world.",{"type":14,"tag":15,"props":985,"children":986},{},[987,989,994,996,1002,1004,1009,1011,1017,1019,1024,1026,1032,1033,1038,1040,1046],{"type":19,"value":988},"因为conversion world is一个 ECS World, 我们可以从 Entity 出发来而不是仅仅是 Hierarchy 中的 ",{"type":14,"tag":83,"props":990,"children":992},{"className":991},[],[993],{"type":19,"value":179},{"type":19,"value":995},". 由于前文所提到的 component object 的存在, 从",{"type":14,"tag":83,"props":997,"children":999},{"className":998},[],[1000],{"type":19,"value":1001},"Gamebject",{"type":19,"value":1003}," ",{"type":14,"tag":75,"props":1005,"children":1006},{},[1007],{"type":19,"value":1008},"importing",{"type":19,"value":1010}," 的过程也非常容易, 所以你也可以得到一堆完整复刻 ",{"type":14,"tag":83,"props":1012,"children":1014},{"className":1013},[],[1015],{"type":19,"value":1016},"Gameobject",{"type":19,"value":1018},"原有层级关系和组件的 Entity (使用 class 类型组件). 也就是说, 让每个 entity 也拥有 Unity 传统的 ",{"type":14,"tag":83,"props":1020,"children":1022},{"className":1021},[],[1023],{"type":19,"value":88},{"type":19,"value":1025},", ",{"type":14,"tag":83,"props":1027,"children":1029},{"className":1028},[],[1030],{"type":19,"value":1031},"RectTransform",{"type":19,"value":1025},{"type":14,"tag":83,"props":1034,"children":1036},{"className":1035},[],[1037],{"type":19,"value":96},{"type":19,"value":1039}," 或者 ",{"type":14,"tag":83,"props":1041,"children":1043},{"className":1042},[],[1044],{"type":19,"value":1045},"LineRenderer",{"type":19,"value":1047}," 组件.",{"type":14,"tag":15,"props":1049,"children":1050},{},[1051,1053,1058],{"type":19,"value":1052},"这些拥有component object 的 entity 并不优秀, 我们更希望得到更优的基于 ",{"type":14,"tag":83,"props":1054,"children":1056},{"className":1055},[],[1057],{"type":19,"value":792},{"type":19,"value":1059}," 的组件.",{"type":14,"tag":15,"props":1061,"children":1062},{},[1063,1065,1070,1072,1078,1080,1085],{"type":19,"value":1064},"通过",{"type":14,"tag":75,"props":1066,"children":1067},{},[1068],{"type":19,"value":1069},"单次调用",{"type":19,"value":1071}," conversion world 的 ",{"type":14,"tag":83,"props":1073,"children":1075},{"className":1074},[],[1076],{"type":19,"value":1077},"update",{"type":19,"value":1079}," 方法, 其中的特定 system 也会 update 单次, 这会导入 component object entity 并将结果存入 destination world. 至少, 这会为每一个conversion world 中找到的 ",{"type":14,"tag":83,"props":1081,"children":1083},{"className":1082},[],[1084],{"type":19,"value":88},{"type":19,"value":1086}," 组件创建一个空的 Entity.",{"type":14,"tag":15,"props":1088,"children":1089},{},[1090],{"type":14,"tag":55,"props":1091,"children":1093},{"alt":55,"src":1092},"/images/2020-10-19-game-object-conversion-and-subscene/v2-bff28dd360d229c6ba16b991033abf0d_720w.jpg",[],{"type":14,"tag":15,"props":1095,"children":1096},{},[1097,1099,1105],{"type":19,"value":1098},"上图中, destination world 的 Entity A 被成为 ",{"type":14,"tag":83,"props":1100,"children":1102},{"className":1101},[],[1103],{"type":19,"value":1104},"GameObject A ",{"type":19,"value":1106},"的 \"primary entity\". 之所以没有被称为 \"resulting entity\", 是因为这转换过程并非是一对一的过程. 比如 A 可能在 destination world 中构建出 A1 和 A2 两个 entity, 这种情况, 其中一个将成为 primary entity.",{"type":14,"tag":15,"props":1108,"children":1109},{},[1110,1112,1117,1119,1124,1126,1131,1133,1138,1140,1146,1148,1153],{"type":19,"value":1111},"另一个",{"type":14,"tag":75,"props":1113,"children":1114},{},[1115],{"type":19,"value":1116},"在 conversion world 工作时",{"type":19,"value":1118},"的特点是你可以通过原始的 ",{"type":14,"tag":83,"props":1120,"children":1122},{"className":1121},[],[1123],{"type":19,"value":179},{"type":19,"value":1125}," 获取 primary entity(当然也可以传入任一 ",{"type":14,"tag":83,"props":1127,"children":1129},{"className":1128},[],[1130],{"type":19,"value":743},{"type":19,"value":1132}," 来获取, 内部将会调用",{"type":14,"tag":83,"props":1134,"children":1136},{"className":1135},[],[1137],{"type":19,"value":743},{"type":19,"value":1139},"的 ",{"type":14,"tag":83,"props":1141,"children":1143},{"className":1142},[],[1144],{"type":19,"value":1145},".gameObject",{"type":19,"value":1147},"来替代). 比如上图 A 的",{"type":14,"tag":83,"props":1149,"children":1151},{"className":1150},[],[1152],{"type":19,"value":88},{"type":19,"value":1154}," 也可以用于获取 primary entity, 这在更复杂的转换过程中可能有用.",{"type":14,"tag":15,"props":1156,"children":1157},{},[1158,1160,1165],{"type":19,"value":1159},"最后, 包含那些并不高效的 Entity 的 conversion world 将会被 ",{"type":14,"tag":75,"props":1161,"children":1162},{},[1163],{"type":19,"value":1164},"destroy",{"type":19,"value":1166}," 掉.",{"type":14,"tag":46,"props":1168,"children":1170},{"id":1169},"gameobjectconversionsystem",[1171],{"type":19,"value":1172},"GameObjectConversionSystem",{"type":14,"tag":15,"props":1174,"children":1175},{},[1176],{"type":19,"value":1177},"被标记了如下 attribute 的 system 将在 conversion world 中被调用:",{"type":14,"tag":419,"props":1179,"children":1182},{"className":1180,"code":1181,"language":424,"meta":7},[422],"[WorldSystemFilter(WorldSystemFilterFlags.GameObjectConversion)]\n",[1183],{"type":14,"tag":83,"props":1184,"children":1185},{"__ignoreMap":7},[1186],{"type":19,"value":1181},{"type":14,"tag":15,"props":1188,"children":1189},{},[1190,1192,1197],{"type":19,"value":1191},"这个 attribute 是可继承的, 因此更推荐的方法是直接继承ECS库里已提供的",{"type":14,"tag":83,"props":1193,"children":1195},{"className":1194},[],[1196],{"type":19,"value":1172},{"type":19,"value":168},{"type":14,"tag":15,"props":1199,"children":1200},{},[1201,1203,1209,1211,1216,1218,1223,1224,1230,1231,1236,1237,1242,1244,1249,1251,1257,1259,1264],{"type":19,"value":1202},"拿 ",{"type":14,"tag":83,"props":1204,"children":1206},{"className":1205},[],[1207],{"type":19,"value":1208},"TransformConversion",{"type":19,"value":1210}," system 为例. 它会在 conversion world 里面寻找 ",{"type":14,"tag":83,"props":1212,"children":1214},{"className":1213},[],[1215],{"type":19,"value":88},{"type":19,"value":1217}," 组件, 依此来构建 destination world 中 entity 的",{"type":14,"tag":83,"props":1219,"children":1221},{"className":1220},[],[1222],{"type":19,"value":318},{"type":19,"value":131},{"type":14,"tag":83,"props":1225,"children":1227},{"className":1226},[],[1228],{"type":19,"value":1229},"Translate",{"type":19,"value":563},{"type":14,"tag":83,"props":1232,"children":1234},{"className":1233},[],[1235],{"type":19,"value":554},{"type":19,"value":563},{"type":14,"tag":83,"props":1238,"children":1240},{"className":1239},[],[1241],{"type":19,"value":569},{"type":19,"value":1243},"组件, 它甚至知道在",{"type":14,"tag":83,"props":1245,"children":1247},{"className":1246},[],[1248],{"type":19,"value":88},{"type":19,"value":1250},"的 scale 为",{"type":14,"tag":83,"props":1252,"children":1254},{"className":1253},[],[1255],{"type":19,"value":1256},"(1,1,1)",{"type":19,"value":1258},"时不添加",{"type":14,"tag":83,"props":1260,"children":1262},{"className":1261},[],[1263],{"type":19,"value":569},{"type":19,"value":1265},"!",{"type":14,"tag":15,"props":1267,"children":1268},{},[1269],{"type":14,"tag":55,"props":1270,"children":1272},{"alt":55,"src":1271},"/images/2020-10-19-game-object-conversion-and-subscene/v2-48b3c53e12f6c638b561e55ad6b095cb_720w.jpg",[],{"type":14,"tag":15,"props":1274,"children":1275},{},[1276,1278,1284,1286,1291,1292,1298,1300,1305,1307,1312,1313,1318],{"type":19,"value":1277},"另一个值得看的例子是 ",{"type":14,"tag":83,"props":1279,"children":1281},{"className":1280},[],[1282],{"type":19,"value":1283},"MeshRendererConversion",{"type":19,"value":1285},". 这是",{"type":14,"tag":83,"props":1287,"children":1289},{"className":1288},[],[1290],{"type":19,"value":96},{"type":19,"value":131},{"type":14,"tag":83,"props":1293,"children":1295},{"className":1294},[],[1296],{"type":19,"value":1297},"MeshRenderer",{"type":19,"value":1299},"转换为",{"type":14,"tag":83,"props":1301,"children":1303},{"className":1302},[],[1304],{"type":19,"value":285},{"type":19,"value":1306}," 加 ",{"type":14,"tag":83,"props":1308,"children":1310},{"className":1309},[],[1311],{"type":19,"value":158},{"type":19,"value":160},{"type":14,"tag":83,"props":1314,"children":1316},{"className":1315},[],[1317],{"type":19,"value":166},{"type":19,"value":1319}," 的地方",{"type":14,"tag":15,"props":1321,"children":1322},{},[1323],{"type":14,"tag":55,"props":1324,"children":1326},{"alt":55,"src":1325},"/images/2020-10-19-game-object-conversion-and-subscene/v2-acf0da5e1a80bd23ba69b1bf80870973_720w.jpg",[],{"type":14,"tag":46,"props":1328,"children":1330},{"id":1329},"conversion-的顺序",[1331],{"type":19,"value":1332},"Conversion 的顺序",{"type":14,"tag":15,"props":1334,"children":1335},{},[1336,1338,1343,1345,1350],{"type":19,"value":1337},"conversion systems 都是被扫描以及归集到一起的, 因此顺序并没有被清晰地定义. 假设你想要转换过程中 \"get primary entity\" 并获取到 ",{"type":14,"tag":83,"props":1339,"children":1341},{"className":1340},[],[1342],{"type":19,"value":318},{"type":19,"value":1344}," 组件, 执行顺序就变得很重要了, 因为你要确保你的 conversion system 在 Unity 的 ",{"type":14,"tag":83,"props":1346,"children":1348},{"className":1347},[],[1349],{"type":19,"value":1208},{"type":19,"value":1351},"之后执行.",{"type":14,"tag":15,"props":1353,"children":1354},{},[1355,1361],{"type":14,"tag":83,"props":1356,"children":1358},{"className":1357},[],[1359],{"type":19,"value":1360},"UpdateInGroup",{"type":19,"value":1362},"依然排得上用场. 在 conversion world, 有如下一些 groups:",{"type":14,"tag":419,"props":1364,"children":1367},{"className":1365,"code":1366,"language":424,"meta":7},[422],"public class GameObjectDeclareReferencedObjectsGroup : ComponentSystemGroup { }\n\npublic class GameObjectBeforeConversionGroup : ComponentSystemGroup { }\npublic class GameObjectConversionGroup : ComponentSystemGroup { }\npublic class GameObjectAfterConversionGroup : ComponentSystemGroup { }\n\npublic class GameObjectExportGroup : ComponentSystemGroup { }\n",[1368],{"type":14,"tag":83,"props":1369,"children":1370},{"__ignoreMap":7},[1371],{"type":19,"value":1366},{"type":14,"tag":15,"props":1373,"children":1374},{},[1375,1377,1383,1385,1391,1393,1398,1400,1406,1408,1413,1415,1420,1422,1427,1429,1434],{"type":19,"value":1376},"如非特别指定, 你的 system 将运行在 ",{"type":14,"tag":83,"props":1378,"children":1380},{"className":1379},[],[1381],{"type":19,"value":1382},"GameObjectConversionGroup",{"type":19,"value":1384},"中. 因此如果你想要在Unity内置的 conversion system 之后做事情, 你得确保你的 system 运行在其后. 要注意的是你不能使用",{"type":14,"tag":83,"props":1386,"children":1388},{"className":1387},[],[1389],{"type":19,"value":1390},"[UpdateAfter(typeof(TransformConversion))]",{"type":19,"value":1392},"因为",{"type":14,"tag":83,"props":1394,"children":1396},{"className":1395},[],[1397],{"type":19,"value":1208},{"type":19,"value":1399},"不是",{"type":14,"tag":83,"props":1401,"children":1403},{"className":1402},[],[1404],{"type":19,"value":1405},"public",{"type":19,"value":1407},"的. 从前文截图你可以看到它运行在 before group 中, 因此你的默认运行在",{"type":14,"tag":83,"props":1409,"children":1411},{"className":1410},[],[1412],{"type":19,"value":1382},{"type":19,"value":1414}," 中的 system 是可以获取到 ",{"type":14,"tag":83,"props":1416,"children":1418},{"className":1417},[],[1419],{"type":19,"value":318},{"type":19,"value":1421},"等组件的. ",{"type":14,"tag":83,"props":1423,"children":1425},{"className":1424},[],[1426],{"type":19,"value":1283},{"type":19,"value":1428}," 则运行在 ",{"type":14,"tag":83,"props":1430,"children":1432},{"className":1431},[],[1433],{"type":19,"value":1382},{"type":19,"value":1435}," 中, 因此如果你想要获取到 RenderMesh, 则需要将你的 system 放在其后.",{"type":14,"tag":15,"props":1437,"children":1438},{},[1439],{"type":19,"value":1440},"declare 和 export Group 很特殊, 因为它们运行在特定的过程的前后, 而中间三个 Group则是一紧挨着运行, 因此, 你如果要放在这两个 Group 内运行, 一定得明白它们前后都做了些什么事儿(后文会讲).",{"type":14,"tag":419,"props":1442,"children":1445},{"className":1443,"code":1444,"language":424,"meta":7},[422],"???\nGameObjectDeclareReferencedObjectsGroup.Update()\n???\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n???\nGameObjectExportGroup.Update()\n",[1446],{"type":14,"tag":83,"props":1447,"children":1448},{"__ignoreMap":7},[1449],{"type":19,"value":1444},{"type":14,"tag":46,"props":1451,"children":1453},{"id":1452},"gameobjectconversionmappingsystem",[1454],{"type":19,"value":1455},"GameObjectConversionMappingSystem",{"type":14,"tag":15,"props":1457,"children":1458},{},[1459,1461,1466,1468,1473],{"type":19,"value":1460},"conversion world 还有一个非常特别的系统附加在所有可用的 ",{"type":14,"tag":83,"props":1462,"children":1464},{"className":1463},[],[1465],{"type":19,"value":1172},{"type":19,"value":1467}," 里, 就是",{"type":14,"tag":83,"props":1469,"children":1471},{"className":1470},[],[1472],{"type":19,"value":1455},{"type":19,"value":1474},". (下文称之为 mapping system). 该系统是所有 conversion world 的 boss, 奇迹发生之地.",{"type":14,"tag":15,"props":1476,"children":1477},{},[1478,1480,1486,1488,1493],{"type":19,"value":1479},"首先这是一个纯粹的 \"tooling system\", 意思是它只有一个空的 ",{"type":14,"tag":83,"props":1481,"children":1483},{"className":1482},[],[1484],{"type":19,"value":1485},"OnUpdate",{"type":19,"value":1487}," 函数, 完全是用来被其他系统获取, 并在它们的",{"type":14,"tag":83,"props":1489,"children":1491},{"className":1490},[],[1492],{"type":19,"value":1485},{"type":19,"value":1494},"中使用的工具.(这种设计也适用于你自己的游戏.)",{"type":14,"tag":15,"props":1496,"children":1497},{},[1498,1500,1506],{"type":19,"value":1499},"这里你可以执行",{"type":14,"tag":83,"props":1501,"children":1503},{"className":1502},[],[1504],{"type":19,"value":1505},"GetPrimaryEntity",{"type":19,"value":1507}," 来与 destination world 沟通, 或者创建更多的 entity. 当你想执行 conversion, 你需要显式地指定 destination world. 这个 world 用来当作 mapping system 的 constructor.",{"type":14,"tag":15,"props":1509,"children":1510},{},[1511,1513,1519,1521,1526,1528,1534],{"type":19,"value":1512},"在你的 conversion system 里面, 你可以 ",{"type":14,"tag":83,"props":1514,"children":1516},{"className":1515},[],[1517],{"type":19,"value":1518},"GetOrCreateSystem",{"type":19,"value":1520}," 来获取 mapping system, 但如果你继承了",{"type":14,"tag":83,"props":1522,"children":1524},{"className":1523},[],[1525],{"type":19,"value":1172},{"type":19,"value":1527},", 则可以直接通过相应的",{"type":14,"tag":83,"props":1529,"children":1531},{"className":1530},[],[1532],{"type":19,"value":1533},"protected",{"type":19,"value":1535}," 方法获取到.",{"type":14,"tag":46,"props":1537,"children":1539},{"id":1538},"让我们使用-converttoentity-来convert吧",[1540],{"type":19,"value":1541},"让我们使用 ConvertToEntity 来convert吧",{"type":14,"tag":15,"props":1543,"children":1544},{},[1545,1547,1552,1553,1558,1560,1565,1566,1571,1572,1577],{"type":19,"value":1546},"现在已经有足够的知识来执行转换过程了. 目前我们仅仅使用 Unity 内置的 conversion system. 也即",{"type":14,"tag":83,"props":1548,"children":1550},{"className":1549},[],[1551],{"type":19,"value":1208},{"type":19,"value":131},{"type":14,"tag":83,"props":1554,"children":1556},{"className":1555},[],[1557],{"type":19,"value":1283},{"type":19,"value":1559}," , 因此确保你的输入拥有",{"type":14,"tag":83,"props":1561,"children":1563},{"className":1562},[],[1564],{"type":19,"value":88},{"type":19,"value":548},{"type":14,"tag":83,"props":1567,"children":1569},{"className":1568},[],[1570],{"type":19,"value":96},{"type":19,"value":131},{"type":14,"tag":83,"props":1573,"children":1575},{"className":1574},[],[1576],{"type":19,"value":1297},{"type":19,"value":1578}," 来得到结果.",{"type":14,"tag":15,"props":1580,"children":1581},{},[1582,1584,1590,1592,1598,1600,1605,1607,1612,1613,1618,1619,1625],{"type":19,"value":1583},"要在scene里面选择 game objects导入 conversion world, 我们可以使用",{"type":14,"tag":83,"props":1585,"children":1587},{"className":1586},[],[1588],{"type":19,"value":1589},"ConvertToEntity",{"type":19,"value":1591},"组件. 在 ",{"type":14,"tag":83,"props":1593,"children":1595},{"className":1594},[],[1596],{"type":19,"value":1597},"Awake",{"type":19,"value":1599}," 里面, 它会基于一些标准来选择导入什么. 所以若如下图附加到",{"type":14,"tag":83,"props":1601,"children":1603},{"className":1602},[],[1604],{"type":19,"value":179},{"type":19,"value":1606},"上, 那么在 conversion world里, 我会得到这些ECS的 ",{"type":14,"tag":75,"props":1608,"children":1609},{},[1610],{"type":19,"value":1611},"component objects:",{"type":19,"value":1003},{"type":14,"tag":83,"props":1614,"children":1616},{"className":1615},[],[1617],{"type":19,"value":88},{"type":19,"value":548},{"type":14,"tag":83,"props":1620,"children":1622},{"className":1621},[],[1623],{"type":19,"value":1624},"Hello",{"type":19,"value":168},{"type":14,"tag":15,"props":1627,"children":1628},{},[1629],{"type":14,"tag":55,"props":1630,"children":1632},{"alt":55,"src":1631},"/images/2020-10-19-game-object-conversion-and-subscene/v2-a96ebb838511e15934a42fd1b2000b1c_720w.jpg",[],{"type":14,"tag":15,"props":1634,"children":1635},{},[1636,1638,1643],{"type":19,"value":1637},"当进入 play mode 时, ",{"type":14,"tag":83,"props":1639,"children":1641},{"className":1640},[],[1642],{"type":19,"value":1597},{"type":19,"value":1644}," 被调用的瞬间后你得到:",{"type":14,"tag":15,"props":1646,"children":1647},{},[1648],{"type":14,"tag":55,"props":1649,"children":1651},{"alt":55,"src":1650},"/images/2020-10-19-game-object-conversion-and-subscene/v2-dcece28b71a8313f75f0e4fd6ca7667c_720w.jpg",[],{"type":14,"tag":15,"props":1653,"children":1654},{},[1655],{"type":14,"tag":55,"props":1656,"children":1658},{"alt":55,"src":1657},"/images/2020-10-19-game-object-conversion-and-subscene/v2-87122268425b7052676a0b7cce6c8cc8_720w.jpg",[],{"type":14,"tag":15,"props":1660,"children":1661},{},[1662,1664,1669,1671,1676,1678,1683],{"type":19,"value":1663},"当前状态当然还没准备好绘制, 因为还没有 ",{"type":14,"tag":83,"props":1665,"children":1667},{"className":1666},[],[1668],{"type":19,"value":285},{"type":19,"value":1670},", 但是你可以看到",{"type":14,"tag":83,"props":1672,"children":1674},{"className":1673},[],[1675],{"type":19,"value":1208},{"type":19,"value":1677},"发现了",{"type":14,"tag":83,"props":1679,"children":1681},{"className":1680},[],[1682],{"type":19,"value":88},{"type":19,"value":1684},"component object 然后就在conversion world 被销毁之前, 在 Primary entity 上构建了 LTW/TR .",{"type":14,"tag":15,"props":1686,"children":1687},{},[1688],{"type":19,"value":1689},"如果我修改一下 scale:",{"type":14,"tag":15,"props":1691,"children":1692},{},[1693],{"type":14,"tag":55,"props":1694,"children":1696},{"alt":55,"src":1695},"/images/2020-10-19-game-object-conversion-and-subscene/v2-84dbdfe15794ce27a4b4957f7480abcb_720w.jpg",[],{"type":14,"tag":15,"props":1698,"children":1699},{},[1700],{"type":19,"value":1701},"转换的结果:",{"type":14,"tag":15,"props":1703,"children":1704},{},[1705],{"type":14,"tag":55,"props":1706,"children":1708},{"alt":55,"src":1707},"/images/2020-10-19-game-object-conversion-and-subscene/v2-6d131a5073402ee6700baf5c1c9a7829_720w.jpg",[],{"type":14,"tag":15,"props":1710,"children":1711},{},[1712],{"type":14,"tag":55,"props":1713,"children":1715},{"alt":55,"src":1714},"/images/2020-10-19-game-object-conversion-and-subscene/v2-bf7ebc16e636d69937377796cc12a334_720w.jpg",[],{"type":14,"tag":15,"props":1717,"children":1718},{},[1719,1721,1726,1728,1733],{"type":19,"value":1720},"因为 ",{"type":14,"tag":83,"props":1722,"children":1724},{"className":1723},[],[1725],{"type":19,"value":1208},{"type":19,"value":1727}," conversion system 的代码发现了 ",{"type":14,"tag":83,"props":1729,"children":1731},{"className":1730},[],[1732],{"type":19,"value":88},{"type":19,"value":1734},"有非 1 的 scale, 于是决定加上额外的组件到 primary entity 上.",{"type":14,"tag":15,"props":1736,"children":1737},{},[1738,1740,1745,1747,1752,1753,1758],{"type":19,"value":1739},"接下来看看",{"type":14,"tag":83,"props":1741,"children":1743},{"className":1742},[],[1744],{"type":19,"value":1283},{"type":19,"value":1746},"在我们添加了 ",{"type":14,"tag":83,"props":1748,"children":1750},{"className":1749},[],[1751],{"type":19,"value":96},{"type":19,"value":131},{"type":14,"tag":83,"props":1754,"children":1756},{"className":1755},[],[1757],{"type":19,"value":1297},{"type":19,"value":1759}," 后做些什么:",{"type":14,"tag":15,"props":1761,"children":1762},{},[1763],{"type":14,"tag":55,"props":1764,"children":1766},{"alt":55,"src":1765},"/images/2020-10-19-game-object-conversion-and-subscene/v2-2cc3d708a668ecd3a34776ae9860b433_720w.jpg",[],{"type":14,"tag":15,"props":1768,"children":1769},{},[1770],{"type":14,"tag":55,"props":1771,"children":1773},{"alt":55,"src":1772},"/images/2020-10-19-game-object-conversion-and-subscene/v2-adeb3de47a701bf36a971fa9baeaae97_b.jpg",[],{"type":14,"tag":15,"props":1775,"children":1776},{},[1777,1779,1784,1786,1792],{"type":19,"value":1778},"我得到了一个正确转换且拥有纯粹ECS数据后的方块! 另外 conversion world 也可以分配 entity name, 因为 conversion world 知晓 ",{"type":14,"tag":83,"props":1780,"children":1782},{"className":1781},[],[1783],{"type":19,"value":88},{"type":19,"value":1785}," 的存在, 所以可以在 conversion world 被销毁前通过",{"type":14,"tag":83,"props":1787,"children":1789},{"className":1788},[],[1790],{"type":19,"value":1791},".gameObject.name",{"type":19,"value":1793}," 来追踪其名字.",{"type":14,"tag":15,"props":1795,"children":1796},{},[1797],{"type":14,"tag":55,"props":1798,"children":1800},{"alt":55,"src":1799},"/images/2020-10-19-game-object-conversion-and-subscene/v2-992e31a0522e8183fcbee75cf061ec4b_720w.jpg",[],{"type":14,"tag":15,"props":1802,"children":1803},{},[1804,1809,1811,1816,1817,1822,1824,1829,1830,1835],{"type":14,"tag":83,"props":1805,"children":1807},{"className":1806},[],[1808],{"type":19,"value":1589},{"type":19,"value":1810},"组件里\"and destroy\" 选项并非 conversion world 流程里的内容, 由该MonoBehaviour 组件自行完成. 因为它并不觉得你想要复制出同样的结果, 如果我不销毁掉原对象, 那么我就会得到两个方块, 一个来自",{"type":14,"tag":83,"props":1812,"children":1814},{"className":1813},[],[1815],{"type":19,"value":96},{"type":19,"value":131},{"type":14,"tag":83,"props":1818,"children":1820},{"className":1819},[],[1821],{"type":19,"value":1297},{"type":19,"value":1823}," , 另一个来自Hybrid Renderer 渲染的",{"type":14,"tag":83,"props":1825,"children":1827},{"className":1826},[],[1828],{"type":19,"value":285},{"type":19,"value":131},{"type":14,"tag":83,"props":1831,"children":1833},{"className":1832},[],[1834],{"type":19,"value":318},{"type":19,"value":1836}," .",{"type":14,"tag":15,"props":1838,"children":1839},{},[1840,1842,1848],{"type":19,"value":1841},"如果你不想要默认的行为, 你可以使用",{"type":14,"tag":83,"props":1843,"children":1845},{"className":1844},[],[1846],{"type":19,"value":1847},"GameObjectConversionUtility.ConvertGameObjectHierarchy",{"type":19,"value":1849},"手工转换. 后文会细讲.",{"type":14,"tag":46,"props":1851,"children":1853},{"id":1852},"hierarchy-conversion",[1854],{"type":19,"value":1855},"Hierarchy conversion",{"type":14,"tag":15,"props":1857,"children":1858},{},[1859,1864,1866,1871,1873,1879],{"type":14,"tag":83,"props":1860,"children":1862},{"className":1861},[],[1863],{"type":19,"value":1589},{"type":19,"value":1865}," 实际上提交了所有子 ",{"type":14,"tag":83,"props":1867,"children":1869},{"className":1868},[],[1870],{"type":19,"value":179},{"type":19,"value":1872}," 给 conversion world, 除非你在子对象中使用 ",{"type":14,"tag":83,"props":1874,"children":1876},{"className":1875},[],[1877],{"type":19,"value":1878},"ConvertToEntity (Stop)",{"type":19,"value":168},{"type":14,"tag":15,"props":1881,"children":1882},{},[1883],{"type":14,"tag":55,"props":1884,"children":1886},{"alt":55,"src":1885},"/images/2020-10-19-game-object-conversion-and-subscene/v2-3ecf0a5ef86786b295197e8b9af42d3e_720w.jpg",[],{"type":14,"tag":15,"props":1888,"children":1889},{},[1890,1892,1897,1899,1905],{"type":19,"value":1891},"上图的结构中, conversion world 最后会得到: A B E F G H. 每一个元素的 component objects 都会和最初的类似. ",{"type":14,"tag":83,"props":1893,"children":1895},{"className":1894},[],[1896],{"type":19,"value":88},{"type":19,"value":1898},"component object 是关键点, 因为它有",{"type":14,"tag":83,"props":1900,"children":1902},{"className":1901},[],[1903],{"type":19,"value":1904},".parent",{"type":19,"value":1906},"属性, 这样 conversion world 才能基于此构建出整个层级树.",{"type":14,"tag":15,"props":1908,"children":1909},{},[1910,1912,1917,1919,1924],{"type":19,"value":1911},"给 D 添加 ",{"type":14,"tag":83,"props":1913,"children":1915},{"className":1914},[],[1916],{"type":19,"value":1589},{"type":19,"value":1918},"是不会有效果的(在C处转换就停止了), 因此会抛出警告. 而添加",{"type":14,"tag":83,"props":1920,"children":1922},{"className":1921},[],[1923],{"type":19,"value":1589},{"type":19,"value":1925},"给 B 则没有警告, 但也不会有额外的作用, 因为 A 处隐含了 B也将被纳入层级的事实.",{"type":14,"tag":15,"props":1927,"children":1928},{},[1929,1931,1936,1938,1944,1946,1951,1953,1958,1960,1965,1967,1972,1974,1979,1981,1986],{"type":19,"value":1930},"ECS 里有一个",{"type":14,"tag":83,"props":1932,"children":1934},{"className":1933},[],[1935],{"type":19,"value":577},{"type":19,"value":1937},"组件, 该组件仅有一个",{"type":14,"tag":83,"props":1939,"children":1941},{"className":1940},[],[1942],{"type":19,"value":1943},"Entity",{"type":19,"value":1945},"字段用来表示 transform 的层级关系.",{"type":14,"tag":83,"props":1947,"children":1949},{"className":1948},[],[1950],{"type":19,"value":318},{"type":19,"value":1952},"的计算总是基于",{"type":14,"tag":83,"props":1954,"children":1956},{"className":1955},[],[1957],{"type":19,"value":577},{"type":19,"value":1959},"组件. 如果 ",{"type":14,"tag":83,"props":1961,"children":1963},{"className":1962},[],[1964],{"type":19,"value":546},{"type":19,"value":1966},"是 0, 那么 ",{"type":14,"tag":83,"props":1968,"children":1970},{"className":1969},[],[1971],{"type":19,"value":318},{"type":19,"value":1973}," 矩阵的结果并不是在行1 2 3 和 列4为0, 而是直接复制",{"type":14,"tag":83,"props":1975,"children":1977},{"className":1976},[],[1978],{"type":19,"value":577},{"type":19,"value":1980},"所指示Entity的",{"type":14,"tag":83,"props":1982,"children":1984},{"className":1983},[],[1985],{"type":19,"value":318},{"type":19,"value":1987}," 的值.",{"type":14,"tag":15,"props":1989,"children":1990},{},[1991,1993,1998,2000,2005],{"type":19,"value":1992},"而负责计算",{"type":14,"tag":83,"props":1994,"children":1996},{"className":1995},[],[1997],{"type":19,"value":577},{"type":19,"value":1999},"的正是 ",{"type":14,"tag":83,"props":2001,"children":2003},{"className":2002},[],[2004],{"type":19,"value":1208},{"type":19,"value":2006},", 让我们看看结果:",{"type":14,"tag":15,"props":2008,"children":2009},{},[2010],{"type":14,"tag":55,"props":2011,"children":2013},{"alt":55,"src":2012},"/images/2020-10-19-game-object-conversion-and-subscene/v2-cf1b98c0bfc171a75faaeb1708bb6807_720w.jpg",[],{"type":14,"tag":15,"props":2015,"children":2016},{},[2017,2019,2024],{"type":19,"value":2018},"我们先猜猜A B E F G H 会占用多少 chunk? (不管转换过程中有多少魔法, 我们永远得关注数据本身!) 先假设我们这些对象的 scale 都为1 (这样就不会产出",{"type":14,"tag":83,"props":2020,"children":2022},{"className":2021},[],[2023],{"type":19,"value":569},{"type":19,"value":2025},"组件).",{"type":14,"tag":15,"props":2027,"children":2028},{},[2029],{"type":14,"tag":55,"props":2030,"children":2032},{"alt":55,"src":2031},"/images/2020-10-19-game-object-conversion-and-subscene/v2-b03840ef2f4026f8171dd5a0981ab1f5_b.jpg",[],{"type":14,"tag":15,"props":2034,"children":2035},{},[2036],{"type":19,"value":2037},"为何有 3 个chunk?",{"type":14,"tag":15,"props":2039,"children":2040},{},[2041,2043,2048,2050,2055,2057,2063,2065,2071],{"type":19,"value":2042},"你可能会猜测所有 chunk 都会有 ",{"type":14,"tag":83,"props":2044,"children":2046},{"className":2045},[],[2047],{"type":19,"value":577},{"type":19,"value":2049}," 而对于根部的 A, 其",{"type":14,"tag":83,"props":2051,"children":2053},{"className":2052},[],[2054],{"type":19,"value":577},{"type":19,"value":2056},"则可以是一个 ",{"type":14,"tag":83,"props":2058,"children":2060},{"className":2059},[],[2061],{"type":19,"value":2062},"Entity.Null",{"type":19,"value":2064}," , 但是 Unity 并没有选择这样做, 因为在复杂一些的游戏里, 查询时使用",{"type":14,"tag":83,"props":2066,"children":2068},{"className":2067},[],[2069],{"type":19,"value":2070},"ComponentType.Exclude",{"type":19,"value":2072}," 会相对更加高效一点. (你可以想象成如果没有parent组件, transform systems 可以忽略掉一些矩阵运算.)",{"type":14,"tag":815,"props":2074,"children":2075},{},[2076,2081,2086],{"type":14,"tag":819,"props":2077,"children":2078},{},[2079],{"type":19,"value":2080},"没有 Parent, 但有 child : A",{"type":14,"tag":819,"props":2082,"children":2083},{},[2084],{"type":19,"value":2085},"Parent 和 Child 都有: F",{"type":14,"tag":819,"props":2087,"children":2088},{},[2089],{"type":19,"value":2090},"叶子节点, 仅有 Child: B E H G",{"type":14,"tag":15,"props":2092,"children":2093},{},[2094,2096,2102,2103,2109,2110,2116,2118,2123],{"type":19,"value":2095},"你可以看到还有一些 component 被添加了: ",{"type":14,"tag":83,"props":2097,"children":2099},{"className":2098},[],[2100],{"type":19,"value":2101},"LocalToParent",{"type":19,"value":548},{"type":14,"tag":83,"props":2104,"children":2106},{"className":2105},[],[2107],{"type":19,"value":2108},"Child",{"type":19,"value":548},{"type":14,"tag":83,"props":2111,"children":2113},{"className":2112},[],[2114],{"type":19,"value":2115},"PreviousParent",{"type":19,"value":2117},".目前还无需关心它们, 总之它们会最终参与",{"type":14,"tag":83,"props":2119,"children":2121},{"className":2120},[],[2122],{"type":19,"value":318},{"type":19,"value":2124},"的计算.",{"type":14,"tag":15,"props":2126,"children":2127},{},[2128,2130,2135,2137,2142,2144,2149,2151,2156,2158,2163],{"type":19,"value":2129},"注意到 conversion 过程中有多少个不同的 Archetype 产生有时候很有用. 比如当你有个巨大的 game objects 层级树, 且其中有些对象仅仅是用来组织结构的空对象, 有些则真正拥有",{"type":14,"tag":83,"props":2131,"children":2133},{"className":2132},[],[2134],{"type":19,"value":96},{"type":19,"value":2136},"and",{"type":14,"tag":83,"props":2138,"children":2140},{"className":2139},[],[2141],{"type":19,"value":1297},{"type":19,"value":2143},", 这样你最终可能会至少得到 6 个 chunk. (3个前述chunk, 以及3个包含",{"type":14,"tag":83,"props":2145,"children":2147},{"className":2146},[],[2148],{"type":19,"value":285},{"type":19,"value":2150}," 的chunk). 因为",{"type":14,"tag":83,"props":2152,"children":2154},{"className":2153},[],[2155],{"type":19,"value":285},{"type":19,"value":2157},"是",{"type":14,"tag":83,"props":2159,"children":2161},{"className":2160},[],[2162],{"type":19,"value":278},{"type":19,"value":2164},", 如果你有更多的 mesh 和 materials, 那么 chunk 的数量还会继续增加. 总之, 这类的思想也出现在dynamic/static batching, GPU instancing, 或 SRP batchers 之中, 而不是 ECS 独有. 使用Entity Debugger 可以清楚地看到 chunks 是如何被组织的.",{"type":14,"tag":15,"props":2166,"children":2167},{},[2168],{"type":19,"value":2169},"\"and destroy\" 的行为在 stop 时也会有一些变化, 被 stop 的对象之下的层级会被单独摘出来并保留(因为 Unity 猜测既然那里你没有相应的 entity, 那么就为你保留 gameobject)",{"type":14,"tag":15,"props":2171,"children":2172},{},[2173],{"type":14,"tag":55,"props":2174,"children":2176},{"alt":55,"src":2175},"/images/2020-10-19-game-object-conversion-and-subscene/v2-ad321f404c9cc350778236f78db75bab_720w.jpg",[],{"type":14,"tag":46,"props":2178,"children":2180},{"id":2179},"disabled-与-gameobject-conversion",[2181],{"type":19,"value":2182},"Disabled 与 GameObject conversion",{"type":14,"tag":15,"props":2184,"children":2185},{},[2186,2188,2193,2195,2201,2203,2208],{"type":19,"value":2187},"被 disabled 了的",{"type":14,"tag":83,"props":2189,"children":2191},{"className":2190},[],[2192],{"type":19,"value":179},{"type":19,"value":2194},"会被加上一个 ECS 中的",{"type":14,"tag":83,"props":2196,"children":2198},{"className":2197},[],[2199],{"type":19,"value":2200},"Disabled",{"type":19,"value":2202},"component, 如下所示, Convert and destroying 顶部的 Cube, 你会得到 5 个 Entity, 其中 3 个关联 ",{"type":14,"tag":83,"props":2204,"children":2206},{"className":2205},[],[2207],{"type":19,"value":2200},{"type":19,"value":2209},"component:",{"type":14,"tag":15,"props":2211,"children":2212},{},[2213],{"type":14,"tag":55,"props":2214,"children":2216},{"alt":55,"src":2215},"/images/2020-10-19-game-object-conversion-and-subscene/v2-aa8d98f0c436030e2833da7985bb4f51_720w.jpg",[],{"type":14,"tag":15,"props":2218,"children":2219},{},[2220,2222,2227,2229,2234],{"type":19,"value":2221},"当然你依然可以在层级任何位置添加 Convert To Entity (Stop), 其行为不会发生变化. 比如我在 Cube(1) 和 Cube(4) 上添加 stop, 那么我最终将得到 3 个 Entity: Cube(2) , 有",{"type":14,"tag":83,"props":2223,"children":2225},{"className":2224},[],[2226],{"type":19,"value":2200},{"type":19,"value":2228},"的Cube(3), 没有",{"type":14,"tag":83,"props":2230,"children":2232},{"className":2231},[],[2233],{"type":19,"value":2200},{"type":19,"value":2235},"Cube .",{"type":14,"tag":46,"props":2237,"children":2239},{"id":2238},"convert-and-inject-模式",[2240],{"type":19,"value":2241},"Convert and inject 模式",{"type":14,"tag":15,"props":2243,"children":2244},{},[2245],{"type":19,"value":2246},"假如:",{"type":14,"tag":815,"props":2248,"children":2249},{},[2250,2255],{"type":14,"tag":819,"props":2251,"children":2252},{},[2253],{"type":19,"value":2254},"你想保留原始的 game object",{"type":14,"tag":819,"props":2256,"children":2257},{},[2258,2260,2265],{"type":19,"value":2259},"同时想在 conversion world 销毁之前导出 ",{"type":14,"tag":75,"props":2261,"children":2262},{},[2263],{"type":19,"value":2264},"component objects",{"type":19,"value":2266}," 给 primary entity. (当然也包含转换过程中新增的 components)",{"type":14,"tag":15,"props":2268,"children":2269},{},[2270,2272,2277,2278,2283,2285,2290,2291,2296],{"type":19,"value":2271},"如前文中提到的, 我有",{"type":14,"tag":83,"props":2273,"children":2275},{"className":2274},[],[2276],{"type":19,"value":1624},{"type":19,"value":131},{"type":14,"tag":83,"props":2279,"children":2281},{"className":2280},[],[2282],{"type":19,"value":1045},{"type":19,"value":2284},"会被带进 conversion world , 但由于并没有conversion system会处理",{"type":14,"tag":83,"props":2286,"children":2288},{"className":2287},[],[2289],{"type":19,"value":1624},{"type":19,"value":131},{"type":14,"tag":83,"props":2292,"children":2294},{"className":2293},[],[2295],{"type":19,"value":1045},{"type":19,"value":2297},", 因此会在 conversion world 被销毁时也同时被销毁.",{"type":14,"tag":15,"props":2299,"children":2300},{},[2301],{"type":14,"tag":55,"props":2302,"children":2304},{"alt":55,"src":2303},"/images/2020-10-19-game-object-conversion-and-subscene/v2-310140196c94a5d298a09d2551b3382f_720w.jpg",[],{"type":14,"tag":15,"props":2306,"children":2307},{},[2308],{"type":19,"value":2309},"但在\"Convert and inject\"模式下, 这两者就可以被保留:",{"type":14,"tag":15,"props":2311,"children":2312},{},[2313],{"type":14,"tag":55,"props":2314,"children":2316},{"alt":55,"src":2315},"/images/2020-10-19-game-object-conversion-and-subscene/v2-3a5a13b66d3362a1fbf6e30aa20a6223_720w.jpg",[],{"type":14,"tag":15,"props":2318,"children":2319},{},[2320],{"type":14,"tag":55,"props":2321,"children":2323},{"alt":55,"src":2322},"/images/2020-10-19-game-object-conversion-and-subscene/v2-b635d5f273e58223e298b87a1edebc82_720w.jpg",[],{"type":14,"tag":15,"props":2325,"children":2326},{},[2327,2329,2334,2336,2341,2342,2347,2348,2353,2355,2361,2363,2369],{"type":19,"value":2328},"这样, 我像之前一样正常得到了",{"type":14,"tag":83,"props":2330,"children":2332},{"className":2331},[],[2333],{"type":19,"value":318},{"type":19,"value":2335}," , 但同时我也得到了",{"type":14,"tag":83,"props":2337,"children":2339},{"className":2338},[],[2340],{"type":19,"value":88},{"type":19,"value":1003},{"type":14,"tag":83,"props":2343,"children":2345},{"className":2344},[],[2346],{"type":19,"value":1624},{"type":19,"value":131},{"type":14,"tag":83,"props":2349,"children":2351},{"className":2350},[],[2352],{"type":19,"value":1045},{"type":19,"value":2354},", 这意味着你得到了一个可以追溯回原始 GameObject 的 Entity. 如果我们在别处 destroy 这个 GameObject, 那么 ECS 侧的",{"type":14,"tag":83,"props":2356,"children":2358},{"className":2357},[],[2359],{"type":19,"value":2360},"em.GetComponentObject\u003CTransform/LineRenderer>",{"type":19,"value":2362}," 也相应回返回 ",{"type":14,"tag":83,"props":2364,"children":2366},{"className":2365},[],[2367],{"type":19,"value":2368},"null",{"type":19,"value":168},{"type":14,"tag":15,"props":2371,"children":2372},{},[2373],{"type":19,"value":2374},"现在你应该明白了, 销毁或者不销毁原始 Gameobject 两种模式都有各自的意义 (前者是为了避免重复, 后者为了访问 component objects).",{"type":14,"tag":15,"props":2376,"children":2377},{},[2378,2380,2385,2386,2391],{"type":19,"value":2379},"这意味着如果我有一个关联",{"type":14,"tag":83,"props":2381,"children":2383},{"className":2382},[],[2384],{"type":19,"value":1297},{"type":19,"value":131},{"type":14,"tag":83,"props":2387,"children":2389},{"className":2388},[],[2390],{"type":19,"value":96},{"type":19,"value":2392},"的方块同时又选择了inject模式, 我会得到渲染在同一位置的两个方块. 如下图, 一个方块是 2 * 6 * 2 = 24个 tris(额外 2个 tris是蓝色的背景所占用的), 如果使用 convert and destroy, 我依然会得到 26 个 tris并被Hybrid Renderer所用, 在但 inject 模式下, 会变为 50 个 tris, 因为转换前后的对象都被保留了:",{"type":14,"tag":15,"props":2394,"children":2395},{},[2396],{"type":14,"tag":55,"props":2397,"children":2399},{"alt":55,"src":2398},"/images/2020-10-19-game-object-conversion-and-subscene/v2-689301524050755bbcf6ed29b45330f0_720w.jpg",[],{"type":14,"tag":15,"props":2401,"children":2402},{},[2403],{"type":14,"tag":55,"props":2404,"children":2406},{"alt":55,"src":2405},"/images/2020-10-19-game-object-conversion-and-subscene/v2-3b37442f567073f3500c401bdadc285a_720w.jpg",[],{"type":14,"tag":15,"props":2408,"children":2409},{},[2410],{"type":19,"value":2411},"上面这个例子并不是 inject 模式的预期用法, 该模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯.",{"type":14,"tag":46,"props":2413,"children":2415},{"id":2414},"使用-ecs-的system-来管理传统的-monobehaviour",[2416],{"type":19,"value":2417},"使用 ECS 的System 来管理传统的 MonoBehaviour",{"type":14,"tag":15,"props":2419,"children":2420},{},[2421,2423,2428],{"type":19,"value":2422},"inject 模式最酷的在于, 从现在开始, 你就可以制作 hybrid ECS 游戏了. 你可以把 inject 模式视作将对象转化为 ECS system 可访问的对象, 甚至在你没有 conversion system 的时候. 仅仅是保留 component objects 以及是非常有用了. 你完全可以用 ",{"type":14,"tag":83,"props":2424,"children":2426},{"className":2425},[],[2427],{"type":19,"value":743},{"type":19,"value":2429},"进行组件的开发, 然后用 system 来控制它们.",{"type":14,"tag":15,"props":2431,"children":2432},{},[2433,2435,2440,2442,2447,2449,2454,2456,2461,2463,2468,2470,2476],{"type":19,"value":2434},"你可以在 ",{"type":14,"tag":83,"props":2436,"children":2438},{"className":2437},[],[2439],{"type":19,"value":179},{"type":19,"value":2441}," 上就如同",{"type":14,"tag":83,"props":2443,"children":2445},{"className":2444},[],[2446],{"type":19,"value":792},{"type":19,"value":2448},"一般添加 ",{"type":14,"tag":83,"props":2450,"children":2452},{"className":2451},[],[2453],{"type":19,"value":743},{"type":19,"value":2455},", \"tag 用途的",{"type":14,"tag":83,"props":2457,"children":2459},{"className":2458},[],[2460],{"type":19,"value":743},{"type":19,"value":2462},"\" 也是完全可行的. 不过过去常见的",{"type":14,"tag":83,"props":2464,"children":2466},{"className":2465},[],[2467],{"type":19,"value":743},{"type":19,"value":2469},"继承模式在ECS的世界里, 你可能需要考虑用组合模式来替代了, 一如 ECS 里常用的",{"type":14,"tag":83,"props":2471,"children":2473},{"className":2472},[],[2474],{"type":19,"value":2475},"struct",{"type":19,"value":2477}," 并不能继承.",{"type":14,"tag":15,"props":2479,"children":2480},{},[2481],{"type":19,"value":2482},"虽然并没有性能上的提升, 但是依托 ECS 的查询能力可以获得 system 设计上极佳的灵活性.",{"type":14,"tag":15,"props":2484,"children":2485},{},[2486,2488,2494,2496,2502,2504,2509],{"type":19,"value":2487},"或许你过去常常使用一种\"manager优化\"手段, 就是你去掉移除对象的",{"type":14,"tag":83,"props":2489,"children":2491},{"className":2490},[],[2492],{"type":19,"value":2493},"Update",{"type":19,"value":2495}," 方法, 然后让一个 Manager 来追踪该对象的",{"type":14,"tag":83,"props":2497,"children":2499},{"className":2498},[],[2500],{"type":19,"value":2501},"List",{"type":19,"value":2503},"来统一地 ",{"type":14,"tag":83,"props":2505,"children":2507},{"className":2506},[],[2508],{"type":19,"value":1077},{"type":19,"value":168},{"type":14,"tag":15,"props":2511,"children":2512},{},[2513,2515,2521],{"type":19,"value":2514},"而用于操作 component object (monobehaviour) 的 system 正是和上述优化一模一样的玩意儿! 而且 ECS 在查询上更加灵活. 你可以不断添加查询不同种类 component object 的 system. 这样对于在团队中分割工作量更容易. 也可以通过 ",{"type":14,"tag":83,"props":2516,"children":2518},{"className":2517},[],[2519],{"type":19,"value":2520},"UpdateBefore/After",{"type":19,"value":2522}," 调整执行顺序, 而不是过去地狱般的 script execution order.",{"type":14,"tag":15,"props":2524,"children":2525},{},[2526,2528,2534],{"type":19,"value":2527},"举一个 UGUI 按钮的例子. 我想要用 system 来添加一段逻辑: 改变",{"type":14,"tag":83,"props":2529,"children":2531},{"className":2530},[],[2532],{"type":19,"value":2533},"interactable",{"type":19,"value":2535},"时按钮会在正常和禁用状态之间闪烁.",{"type":14,"tag":15,"props":2537,"children":2538},{},[2539],{"type":14,"tag":55,"props":2540,"children":2542},{"alt":55,"src":2541},"/images/2020-10-19-game-object-conversion-and-subscene/v2-691223f5e1d1debbb595f47a4b38c2ed_720w.jpg",[],{"type":14,"tag":15,"props":2544,"children":2545},{},[2546,2548,2554,2556,2561],{"type":19,"value":2547},"所有按钮都使用 convert and inject, 其中一个缺少",{"type":14,"tag":83,"props":2549,"children":2551},{"className":2550},[],[2552],{"type":19,"value":2553},"BlinkingButton",{"type":19,"value":2555},"\"tag\"",{"type":14,"tag":83,"props":2557,"children":2559},{"className":2558},[],[2560],{"type":19,"value":179},{"type":19,"value":2562},". 目前还没有任何实际代码, 不过我想要用这些类型来进行查询.",{"type":14,"tag":15,"props":2564,"children":2565},{},[2566],{"type":19,"value":2567},"来看看 conversion 后的结果, 我们得到 2个 chunk, 其中一个有3个 entity (橙色的竖条往右边移动了一点, 意味着其包含 3/160 个 entity), 另一个则有一个 entity.",{"type":14,"tag":15,"props":2569,"children":2570},{},[2571],{"type":14,"tag":55,"props":2572,"children":2574},{"alt":55,"src":2573},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f6a2d6ad3e349d49a3b6ef3d34b2aa44_720w.jpg",[],{"type":14,"tag":15,"props":2576,"children":2577},{},[2578,2580,2585,2587,2593],{"type":19,"value":2579},"下面的 system 则能自动到 ECS 的数据库里面查询 scene 里面所有带有 blinking 组件的按钮. 这种\"凭空\"查询",{"type":14,"tag":83,"props":2581,"children":2583},{"className":2582},[],[2584],{"type":19,"value":179},{"type":19,"value":2586},"的能力让声明",{"type":14,"tag":83,"props":2588,"children":2590},{"className":2589},[],[2591],{"type":19,"value":2592},"GameObject[]",{"type":19,"value":2594},"成为了过去时. 即便你对 ECS 毫无兴趣, 这种查询能力也让其成为非常便捷的 Unity 开发工具.",{"type":14,"tag":419,"props":2596,"children":2599},{"className":2597,"code":2598,"language":424,"meta":7},[422],"using Unity.Entities;\nusing Unity.Jobs;\nusing UnityEngine.UI;\n\n[UpdateInGroup(typeof(PresentationSystemGroup))]\npublic class BlinkingButtonSystem : JobComponentSystem\n{\n    EntityQuery blinkingButtonQuery;\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        blinkingButtonQuery = GetEntityQuery(\n            ComponentType.ReadOnly\u003CButton>(),\n            ComponentType.ReadOnly\u003CBlinkingButton>()\n        );\n    }\n\n    //It is not a good idea to have data in system!\n    float collectTime;\n    bool on;\n    \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        collectTime += Time.DeltaTime;\n        if (collectTime > 0.2f)\n        {\n            collectTime -= 0.2f;\n            on = !on;\n        }\n\n        Button[] buttons = blinkingButtonQuery.ToComponentArray\u003CButton>();\n        foreach (var b in buttons)\n        {\n            b.interactable = on;\n        }\n        return default;\n    }\n}\n",[2600],{"type":14,"tag":83,"props":2601,"children":2602},{"__ignoreMap":7},[2603],{"type":19,"value":2598},{"type":14,"tag":15,"props":2605,"children":2606},{},[2607],{"type":14,"tag":55,"props":2608,"children":2610},{"alt":55,"src":2609},"/images/2020-10-19-game-object-conversion-and-subscene/v2-5ed751beea434345f9972273619f2ed2_b.jpg",[],{"type":14,"tag":15,"props":2612,"children":2613},{},[2614,2620,2622,2628,2630,2636,2638,2644,2646,2652],{"type":14,"tag":83,"props":2615,"children":2617},{"className":2616},[],[2618],{"type":19,"value":2619},"Entities.ForEach",{"type":19,"value":2621},"也可以使用 component objects, 只不过这时候不能使用",{"type":14,"tag":83,"props":2623,"children":2625},{"className":2624},[],[2626],{"type":19,"value":2627},"ref",{"type":19,"value":2629},"或",{"type":14,"tag":83,"props":2631,"children":2633},{"className":2632},[],[2634],{"type":19,"value":2635},"in",{"type":19,"value":2637},"关键字, 同时为了防止使用 Burst, 你需要用",{"type":14,"tag":83,"props":2639,"children":2641},{"className":2640},[],[2642],{"type":19,"value":2643},"Run",{"type":19,"value":2645},"来替代",{"type":14,"tag":83,"props":2647,"children":2649},{"className":2648},[],[2650],{"type":19,"value":2651},"Schedule",{"type":19,"value":168},{"type":14,"tag":419,"props":2654,"children":2657},{"className":2655,"code":2656,"language":424,"meta":7},[422],"Entities.WithAll\u003CBlinkingButton>()\n  .ForEach((Button b) => { b.interactable = on; }).WithoutBurst().Run(); \n",[2658],{"type":14,"tag":83,"props":2659,"children":2660},{"__ignoreMap":7},[2661],{"type":19,"value":2656},{"type":14,"tag":15,"props":2663,"children":2664},{},[2665],{"type":19,"value":2666},"这样完全或者部分移植到 ECS 的游戏, 也可以自由使用 system 了, 只需要 inject 模式, 你便拥有了基于 Entity 的查询能力.",{"type":14,"tag":46,"props":2668,"children":2670},{"id":2669},"inject-模式的-conversion-规则",[2671],{"type":19,"value":2672},"Inject 模式的 conversion 规则",{"type":14,"tag":15,"props":2674,"children":2675},{},[2676,2678,2684,2686,2691,2693,2699],{"type":19,"value":2677},"上文例子中将所有的",{"type":14,"tag":83,"props":2679,"children":2681},{"className":2680},[],[2682],{"type":19,"value":2683},"Button",{"type":19,"value":2685},"转换到 ECS 了, 那",{"type":14,"tag":83,"props":2687,"children":2689},{"className":2688},[],[2690],{"type":19,"value":2683},{"type":19,"value":2692}," 里的",{"type":14,"tag":83,"props":2694,"children":2696},{"className":2695},[],[2697],{"type":19,"value":2698},"Text",{"type":19,"value":2700},"怎么办呢?",{"type":14,"tag":15,"props":2702,"children":2703},{},[2704,2706,2711,2713,2718,2720,2725,2727,2732],{"type":19,"value":2705},"和会将所有子层级提交到 conversion world 的 destroy 模式",{"type":14,"tag":75,"props":2707,"children":2708},{},[2709],{"type":19,"value":2710},"不同",{"type":19,"value":2712},", 这时所有的子层级将被忽略(即便你为它们添加了inject模式的",{"type":14,"tag":83,"props":2714,"children":2716},{"className":2715},[],[2717],{"type":19,"value":1589},{"type":19,"value":2719},"组件). 仅有顶层对象会正常convert and inject. 所以 ECS 不会为创建关联",{"type":14,"tag":83,"props":2721,"children":2723},{"className":2722},[],[2724],{"type":19,"value":2698},{"type":19,"value":2726},"component object的",{"type":14,"tag":83,"props":2728,"children":2730},{"className":2729},[],[2731],{"type":19,"value":1943},{"type":19,"value":168},{"type":14,"tag":15,"props":2734,"children":2735},{},[2736,2738,2744],{"type":19,"value":2737},"为了更清晰地说明这条规则, 我试着 convert 更上层的",{"type":14,"tag":83,"props":2739,"children":2741},{"className":2740},[],[2742],{"type":19,"value":2743},"Canvas",{"type":19,"value":829},{"type":14,"tag":15,"props":2746,"children":2747},{},[2748],{"type":14,"tag":55,"props":2749,"children":2751},{"alt":55,"src":2750},"/images/2020-10-19-game-object-conversion-and-subscene/v2-44014cd244f3d5aa39e4c0cf8d534e47_720w.jpg",[],{"type":14,"tag":15,"props":2753,"children":2754},{},[2755],{"type":14,"tag":55,"props":2756,"children":2758},{"alt":55,"src":2757},"/images/2020-10-19-game-object-conversion-and-subscene/v2-5b8285a1bdd4c30a3aa57bf7c8cd3f7f_720w.jpg",[],{"type":14,"tag":15,"props":2760,"children":2761},{},[2762],{"type":19,"value":2763},"这下我的 Button 并没出现在 ECS 的世界里, 而只得到了 Canvas, 如果我把模式切回 destroy, 则得到一堆 pure 的 entity 而不带任何 component objects:",{"type":14,"tag":15,"props":2765,"children":2766},{},[2767],{"type":14,"tag":55,"props":2768,"children":2770},{"alt":55,"src":2769},"/images/2020-10-19-game-object-conversion-and-subscene/v2-e573126980ccfb5cf19b281e234acbb4_720w.jpg",[],{"type":14,"tag":15,"props":2772,"children":2773},{},[2774],{"type":19,"value":2775},"可以看到, 所有在conversion world 中的 component objects 最终都被销毁了.",{"type":14,"tag":46,"props":2777,"children":2779},{"id":2778},"iconvertgameobjecttoentity",[2780],{"type":19,"value":2781},"IConvertGameObjectToEntity",{"type":14,"tag":15,"props":2783,"children":2784},{},[2785,2787,2792],{"type":19,"value":2786},"实现 conversion system(通过继承",{"type":14,"tag":83,"props":2788,"children":2790},{"className":2789},[],[2791],{"type":19,"value":1172},{"type":19,"value":2793},")可以让你自由控制conversion 的过程. 但如果你想按照具体类型来转换呢? 每当转换执行时, 应当相应地执行一些代码.",{"type":14,"tag":15,"props":2795,"children":2796},{},[2797,2799,2805,2807,2812,2814,2820,2822,2827,2829,2835],{"type":19,"value":2798},"Unity 内置了另一种名为",{"type":14,"tag":83,"props":2800,"children":2802},{"className":2801},[],[2803],{"type":19,"value":2804},"ConvertGameObjectToEntitySystem",{"type":19,"value":2806}," 的 conversion system. 该 system 会迭代 conversion world 中所有的",{"type":14,"tag":83,"props":2808,"children":2810},{"className":2809},[],[2811],{"type":19,"value":179},{"type":19,"value":2813},", 接着使用",{"type":14,"tag":83,"props":2815,"children":2817},{"className":2816},[],[2818],{"type":19,"value":2819},"GetComponents",{"type":19,"value":2821}," 并判断是否实现",{"type":14,"tag":83,"props":2823,"children":2825},{"className":2824},[],[2826],{"type":19,"value":2781},{"type":19,"value":2828}," 接口, 然后再调用该接口的",{"type":14,"tag":83,"props":2830,"children":2832},{"className":2831},[],[2833],{"type":19,"value":2834},".Convert",{"type":19,"value":2836}," 方法. 你可以把任何逻辑都放在这里:",{"type":14,"tag":419,"props":2838,"children":2841},{"className":2839,"code":2840,"language":424,"meta":7},[422],"using Unity.Entities;\nusing UnityEngine;\n\npublic class BlinkingButton : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n    }\n}\n",[2842],{"type":14,"tag":83,"props":2843,"children":2844},{"__ignoreMap":7},[2845],{"type":19,"value":2840},{"type":14,"tag":15,"props":2847,"children":2848},{},[2849,2855,2857,2862,2864,2869,2871,2876,2878,2884,2886,2891,2893,2898],{"type":14,"tag":83,"props":2850,"children":2852},{"className":2851},[],[2853],{"type":19,"value":2854},"entity",{"type":19,"value":2856},"参数是 ",{"type":14,"tag":83,"props":2858,"children":2860},{"className":2859},[],[2861],{"type":19,"value":179},{"type":19,"value":2863},"产生的 primary entity. 回忆一下前文提到\"primary entity\"与",{"type":14,"tag":83,"props":2865,"children":2867},{"className":2866},[],[2868],{"type":19,"value":179},{"type":19,"value":2870}," 以及相应",{"type":14,"tag":83,"props":2872,"children":2874},{"className":2873},[],[2875],{"type":19,"value":743},{"type":19,"value":2877}," 关联. ",{"type":14,"tag":83,"props":2879,"children":2881},{"className":2880},[],[2882],{"type":19,"value":2883},"dstManager",{"type":19,"value":2885},"参数则是 destination world 里的 ",{"type":14,"tag":83,"props":2887,"children":2889},{"className":2888},[],[2890],{"type":19,"value":827},{"type":19,"value":2892},". 在这里你可以做任何相关联的事儿, 比如为每个",{"type":14,"tag":83,"props":2894,"children":2896},{"className":2895},[],[2897],{"type":19,"value":2553},{"type":19,"value":2899},"添加 500 个屁用没有的 Entity?当然可以!",{"type":14,"tag":15,"props":2901,"children":2902},{},[2903,2905,2911],{"type":19,"value":2904},"你可以利用这里的机会来使用",{"type":14,"tag":83,"props":2906,"children":2908},{"className":2907},[],[2909],{"type":19,"value":2910},"dstManager.Add / SetComponentData",{"type":19,"value":2912},"来初始化更多数据. 要注意这里有一丝\"遥控\" destination world 的味道(因为实际上你工作在 conversion world 层面). 所以重视这个参数名字, 因为确实有另一个属于 conversion world 的 manager.",{"type":14,"tag":15,"props":2914,"children":2915},{},[2916,2918,2923,2925,2930],{"type":19,"value":2917},"单独创建 conversion system 并使用",{"type":14,"tag":83,"props":2919,"children":2921},{"className":2920},[],[2922],{"type":19,"value":2619},{"type":19,"value":2924},"来初始化数据也许会更高效一些(因为你在这里使用 Burst 和 jobs). 但是 Convert 方法运行你获取到",{"type":14,"tag":83,"props":2926,"children":2928},{"className":2927},[],[2929],{"type":19,"value":743},{"type":19,"value":2931},"中序列化的字段, 这样更加随心的修改每个 entity 关联的数据.",{"type":14,"tag":15,"props":2933,"children":2934},{},[2935,2941,2943,2949,2951,2956,2958,2963],{"type":14,"tag":83,"props":2936,"children":2938},{"className":2937},[],[2939],{"type":19,"value":2940},"conversionSystem",{"type":19,"value":2942},"参数则是调用",{"type":14,"tag":83,"props":2944,"children":2946},{"className":2945},[],[2947],{"type":19,"value":2948},"Convert",{"type":19,"value":2950},"方法的",{"type":14,"tag":83,"props":2952,"children":2954},{"className":2953},[],[2955],{"type":19,"value":2804},{"type":19,"value":2957},"本体, 但是强制被转换成了",{"type":14,"tag":83,"props":2959,"children":2961},{"className":2960},[],[2962],{"type":19,"value":1172},{"type":19,"value":2964}," 类型(小心名称有点易混). 其目的是让你可以使用 mapping system 中的方法.",{"type":14,"tag":46,"props":2966,"children":2968},{"id":2967},"linkedentitygroup",[2969],{"type":19,"value":2970},"LinkedEntityGroup",{"type":14,"tag":15,"props":2972,"children":2973},{},[2974,2979],{"type":14,"tag":83,"props":2975,"children":2977},{"className":2976},[],[2978],{"type":19,"value":2970},{"type":19,"value":2980},"是一个 dynamic buffer , 通常它会影响:",{"type":14,"tag":815,"props":2982,"children":2983},{},[2984,3012,3036],{"type":14,"tag":819,"props":2985,"children":2986},{},[2987,2989,2995,2997,3002,3004,3010],{"type":19,"value":2988},"调用",{"type":14,"tag":83,"props":2990,"children":2992},{"className":2991},[],[2993],{"type":19,"value":2994},"Instantiate",{"type":19,"value":2996},"方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的",{"type":14,"tag":83,"props":2998,"children":3000},{"className":2999},[],[3001],{"type":19,"value":2970},{"type":19,"value":3003},". 注意实例化并不一定和ECS中的",{"type":14,"tag":83,"props":3005,"children":3007},{"className":3006},[],[3008],{"type":19,"value":3009},"Prefab",{"type":19,"value":3011}," component 直接关联.",{"type":14,"tag":819,"props":3013,"children":3014},{},[3015,3016,3022,3024,3029,3031],{"type":19,"value":2988},{"type":14,"tag":83,"props":3017,"children":3019},{"className":3018},[],[3020],{"type":19,"value":3021},"DestroyEntity",{"type":19,"value":3023},"时也会同时销毁 ",{"type":14,"tag":83,"props":3025,"children":3027},{"className":3026},[],[3028],{"type":19,"value":2970},{"type":19,"value":3030},"中的所有 entity. 类似在编辑器中删除",{"type":14,"tag":83,"props":3032,"children":3034},{"className":3033},[],[3035],{"type":19,"value":179},{"type":14,"tag":819,"props":3037,"children":3038},{},[3039,3041,3047,3049,3054,3056,3061,3063,3068],{"type":19,"value":3040},"调用 ",{"type":14,"tag":83,"props":3042,"children":3044},{"className":3043},[],[3045],{"type":19,"value":3046},"entityManager.SetEnabled",{"type":19,"value":3048}," 加上的 ",{"type":14,"tag":83,"props":3050,"children":3052},{"className":3051},[],[3053],{"type":19,"value":2200},{"type":19,"value":3055},"component 会告知 ECS 的查询系统忽略它们, 而 ",{"type":14,"tag":83,"props":3057,"children":3059},{"className":3058},[],[3060],{"type":19,"value":2970},{"type":19,"value":3062}," 中的 entity 也会受到同样的影响. 有点类似禁用",{"type":14,"tag":83,"props":3064,"children":3066},{"className":3065},[],[3067],{"type":19,"value":179},{"type":19,"value":3069}," 时同时会禁用整个层级树.",{"type":14,"tag":15,"props":3071,"children":3072},{},[3073,3075,3080,3082,3087],{"type":19,"value":3074},"注意如果buffer 中的 entity 也有",{"type":14,"tag":83,"props":3076,"children":3078},{"className":3077},[],[3079],{"type":19,"value":2970},{"type":19,"value":3081},", 系统",{"type":14,"tag":75,"props":3083,"children":3084},{},[3085],{"type":19,"value":3086},"不会递归地",{"type":19,"value":3088},"执行instantiation/destroy/disabled 过程.",{"type":14,"tag":15,"props":3090,"children":3091},{},[3092,3094,3099,3100,3106,3108,3113,3115,3120],{"type":19,"value":3093},"这些过程在具体执行当中也有一些细微不同.",{"type":14,"tag":83,"props":3095,"children":3097},{"className":3096},[],[3098],{"type":19,"value":2994},{"type":19,"value":131},{"type":14,"tag":83,"props":3101,"children":3103},{"className":3102},[],[3104],{"type":19,"value":3105},"SetEnabled",{"type":19,"value":3107},"只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity ",{"type":14,"tag":75,"props":3109,"children":3110},{},[3111],{"type":19,"value":3112},"必须要把自己包括在内",{"type":19,"value":3114},"才能正常工作**.** 然而",{"type":14,"tag":83,"props":3116,"children":3118},{"className":3117},[],[3119],{"type":19,"value":3021},{"type":19,"value":3121},"则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.",{"type":14,"tag":15,"props":3123,"children":3124},{},[3125,3127,3132,3133,3138],{"type":19,"value":3126},"要注意",{"type":14,"tag":83,"props":3128,"children":3130},{"className":3129},[],[3131],{"type":19,"value":2970},{"type":19,"value":160},{"type":14,"tag":83,"props":3134,"children":3136},{"className":3135},[],[3137],{"type":19,"value":577},{"type":19,"value":3139},"并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.",{"type":14,"tag":46,"props":3141,"children":3143},{"id":3142},"从非-prefab-conversion-中获取linkedentitygroup",[3144],{"type":19,"value":3145},"从非 prefab conversion 中获取LinkedEntityGroup",{"type":14,"tag":15,"props":3147,"children":3148},{},[3149,3151,3156,3158,3163,3165,3170,3172,3177],{"type":19,"value":3150},"目前, 我们使用",{"type":14,"tag":83,"props":3152,"children":3154},{"className":3153},[],[3155],{"type":19,"value":1589},{"type":19,"value":3157},"并不能得到 ",{"type":14,"tag":83,"props":3159,"children":3161},{"className":3160},[],[3162],{"type":19,"value":2970},{"type":19,"value":3164},". 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. (",{"type":14,"tag":83,"props":3166,"children":3168},{"className":3167},[],[3169],{"type":19,"value":1589},{"type":19,"value":3171},"却可以正常得到基于",{"type":14,"tag":83,"props":3173,"children":3175},{"className":3174},[],[3176],{"type":19,"value":577},{"type":19,"value":3178}," 的层级结构).",{"type":14,"tag":15,"props":3180,"children":3181},{},[3182],{"type":19,"value":3183},"如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:",{"type":14,"tag":419,"props":3185,"children":3188},{"className":3186,"code":3187,"language":424,"meta":7},[422]," public void DeclareLinkedEntityGroup(GameObject gameObject)\n",[3189],{"type":14,"tag":83,"props":3190,"children":3191},{"__ignoreMap":7},[3192],{"type":19,"value":3187},{"type":14,"tag":15,"props":3194,"children":3195},{},[3196],{"type":19,"value":3197},"调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果).",{"type":14,"tag":419,"props":3199,"children":3202},{"className":3200,"code":3201,"language":424,"meta":7},[422],"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n",[3203],{"type":14,"tag":83,"props":3204,"children":3205},{"__ignoreMap":7},[3206],{"type":19,"value":3201},{"type":14,"tag":15,"props":3208,"children":3209},{},[3210],{"type":14,"tag":55,"props":3211,"children":3213},{"alt":55,"src":3212},"/images/2020-10-19-game-object-conversion-and-subscene/v2-fe2983f48e754c910758292e0a0dfc91_720w.jpg",[],{"type":14,"tag":15,"props":3215,"children":3216},{},[3217,3219,3224,3226,3231,3232,3238],{"type":19,"value":3218},"从 debbuger 现在可以看到已经正常添加了",{"type":14,"tag":83,"props":3220,"children":3222},{"className":3221},[],[3223],{"type":19,"value":2970},{"type":19,"value":3225},", 目前它已经支持",{"type":14,"tag":83,"props":3227,"children":3229},{"className":3228},[],[3230],{"type":19,"value":2994},{"type":19,"value":131},{"type":14,"tag":83,"props":3233,"children":3235},{"className":3234},[],[3236],{"type":19,"value":3237},"SetEnable",{"type":19,"value":3239}," 的正常工作了:",{"type":14,"tag":15,"props":3241,"children":3242},{},[3243],{"type":14,"tag":55,"props":3244,"children":3246},{"alt":55,"src":3245},"/images/2020-10-19-game-object-conversion-and-subscene/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_720w.jpg",[],{"type":14,"tag":15,"props":3248,"children":3249},{},[3250,3252,3257],{"type":19,"value":3251},"Unity 也在其他一些地方执行这一过程, 比如在转换 prefab ",{"type":14,"tag":75,"props":3253,"children":3254},{},[3255],{"type":19,"value":3256},"asset",{"type":19,"value":3258}," 的时候.(后文会讲)",{"type":14,"tag":46,"props":3260,"children":3262},{"id":3261},"尺寸警告",[3263],{"type":19,"value":3264},"尺寸警告!",{"type":14,"tag":15,"props":3266,"children":3267},{},[3268,3270,3275,3277,3282,3284,3289],{"type":19,"value":3269},"你可能觉得每个 chunk 16KB 非常多了, 你最多可以放进去 2000个 entity. 一旦你开始转换层级结构, ",{"type":14,"tag":83,"props":3271,"children":3273},{"className":3272},[],[3274],{"type":19,"value":2970},{"type":19,"value":3276},"和它那些朋友们(比如 ",{"type":14,"tag":83,"props":3278,"children":3280},{"className":3279},[],[3281],{"type":19,"value":2108},{"type":19,"value":3283}," )会很快耗光这些预算, 每一个 buffer 里的元素都是一个 8 bytes 的 ",{"type":14,"tag":83,"props":3285,"children":3287},{"className":3286},[],[3288],{"type":19,"value":1943},{"type":19,"value":168},{"type":14,"tag":15,"props":3291,"children":3292},{},[3293,3295,3300],{"type":19,"value":3294},"下图中 12 个 chunks 中, 每个只能容纳 45 个 ",{"type":14,"tag":83,"props":3296,"children":3298},{"className":3297},[],[3299],{"type":19,"value":1943},{"type":19,"value":3301}," , 哪怕只是非常简单的层级结构和非常少量的 component, 远达不到我们的千个级别.",{"type":14,"tag":15,"props":3303,"children":3304},{},[3305],{"type":14,"tag":55,"props":3306,"children":3308},{"alt":55,"src":3307},"/images/2020-10-19-game-object-conversion-and-subscene/v2-398058d78c2ab70ef17a48f705fe5195_720w.jpg",[],{"type":14,"tag":15,"props":3310,"children":3311},{},[3312,3314,3320,3322,3328,3330,3336,3338,3343,3345,3351],{"type":19,"value":3313},"在 entities-0.5.1版本里, ",{"type":14,"tag":83,"props":3315,"children":3317},{"className":3316},[],[3318],{"type":19,"value":3319},"TypeManager.cs",{"type":19,"value":3321}," 源码中可看到, 任何没有",{"type":14,"tag":83,"props":3323,"children":3325},{"className":3324},[],[3326],{"type":19,"value":3327},"[InternalBufferCapacity]",{"type":19,"value":3329}," 的buffer 类型都会默认 ",{"type":14,"tag":83,"props":3331,"children":3333},{"className":3332},[],[3334],{"type":19,"value":3335},"128/size",{"type":19,"value":3337}," 的容量. ",{"type":14,"tag":83,"props":3339,"children":3341},{"className":3340},[],[3342],{"type":19,"value":2970},{"type":19,"value":3344},"里面装的是 entity, 因此其容量是 ",{"type":14,"tag":83,"props":3346,"children":3348},{"className":3347},[],[3349],{"type":19,"value":3350},"128/8 = 16",{"type":19,"value":1836},{"type":14,"tag":15,"props":3353,"children":3354},{},[3355],{"type":14,"tag":55,"props":3356,"children":3358},{"alt":55,"src":3357},"/images/2020-10-19-game-object-conversion-and-subscene/v2-fe0be3a9fca17f9a89108d85d8ba961c_720w.jpg",[],{"type":14,"tag":15,"props":3360,"children":3361},{},[3362],{"type":19,"value":3363},"这意味着:",{"type":14,"tag":815,"props":3365,"children":3366},{},[3367,3384,3389,3408],{"type":14,"tag":819,"props":3368,"children":3369},{},[3370,3375,3377,3382],{"type":14,"tag":75,"props":3371,"children":3372},{},[3373],{"type":19,"value":3374},"每个 Entity",{"type":19,"value":3376}," 关联的",{"type":14,"tag":83,"props":3378,"children":3380},{"className":3379},[],[3381],{"type":19,"value":2970},{"type":19,"value":3383},"(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.",{"type":14,"tag":819,"props":3385,"children":3386},{},[3387],{"type":19,"value":3388},"层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.",{"type":14,"tag":819,"props":3390,"children":3391},{},[3392,3394,3399,3401,3406],{"type":19,"value":3393},"除非显式调用, ",{"type":14,"tag":83,"props":3395,"children":3397},{"className":3396},[],[3398],{"type":19,"value":2970},{"type":19,"value":3400},"仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 ",{"type":14,"tag":83,"props":3402,"children":3404},{"className":3403},[],[3405],{"type":19,"value":179},{"type":19,"value":3407}," 数量",{"type":14,"tag":819,"props":3409,"children":3410},{},[3411,3413,3418],{"type":19,"value":3412},"在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望",{"type":14,"tag":83,"props":3414,"children":3416},{"className":3415},[],[3417],{"type":19,"value":2970},{"type":19,"value":3419},"正常工作.",{"type":14,"tag":15,"props":3421,"children":3422},{},[3423],{"type":19,"value":3424},"最后, 16kb 一个 chunk 意味着 1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).",{"type":14,"tag":46,"props":3426,"children":3428},{"id":3427},"创建额外的-entity",[3429],{"type":19,"value":3430},"创建额外的 entity",{"type":14,"tag":15,"props":3432,"children":3433},{},[3434],{"type":19,"value":3435},"一个常见的情况是一个 GameObject 对应一个 Entity, 也即 \"primary entity\". 在 mapping system 里面, 调用 CreateAdditionalEntity(gameObject)来创建更多的Entity .这些 entity 现在属于这个 game object 的 \"secondary entity\".",{"type":14,"tag":15,"props":3437,"children":3438},{},[3439],{"type":19,"value":3440},"设想我们的新设计是每当CubeMultiple 转换时将会创建额外的两个 entity:",{"type":14,"tag":419,"props":3442,"children":3445},{"className":3443,"code":3444,"language":424,"meta":7},[422],"public class CubeMultiple : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $\"{this.name}_Add1\");\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $\"{this.name}_Add2\");\n    }\n}\n",[3446],{"type":14,"tag":83,"props":3447,"children":3448},{"__ignoreMap":7},[3449],{"type":19,"value":3444},{"type":14,"tag":15,"props":3451,"children":3452},{},[3453],{"type":19,"value":3454},"注意Convert调用是递归的, ConvertToEntity 附加在顶部的 CubeHead 上.",{"type":14,"tag":15,"props":3456,"children":3457},{},[3458],{"type":14,"tag":55,"props":3459,"children":3461},{"alt":55,"src":3460},"/images/2020-10-19-game-object-conversion-and-subscene/v2-9cbab2ea04976cef1e61cc2b365e71af_720w.jpg",[],{"type":14,"tag":15,"props":3463,"children":3464},{},[3465],{"type":19,"value":3466},"要注意额外的entity都是新增的, 且没有为它们添加 components, 这不像那些被默认转换的component objects (如 Transform), 注意下方拥有 2008 容量的 chunk:",{"type":14,"tag":15,"props":3468,"children":3469},{},[3470],{"type":14,"tag":55,"props":3471,"children":3473},{"alt":55,"src":3472},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f1a5fb905599fc0439e0a6764dd09072_720w.jpg",[],{"type":14,"tag":15,"props":3475,"children":3476},{},[3477],{"type":19,"value":3478},"你可能意识的到使用 destination entity manager 的 dstManager.CreateEntity() 来做同样的事情, 下文你会看到这不只是处理方式的问题.",{"type":14,"tag":46,"props":3480,"children":3482},{"id":3481},"从单一源得到-entity",[3483],{"type":19,"value":3484},"从单一源得到 entity",{"type":14,"tag":15,"props":3486,"children":3487},{},[3488],{"type":19,"value":3489},"要这样做, 需要在 mapping system 里, 调用GetEntities(gameObject/component). 因为我们增加了额外的 entity, 让 conversion world 知道这些 entity 来自特定的东西, 这样让我们可以查询到它们. 比如, 如果我有一个GameObject CubeMultiple 的引用, 那么使用GetEntities 我就能得到 primary entity 和另外两个新增的 entity.",{"type":14,"tag":15,"props":3491,"children":3492},{},[3493],{"type":19,"value":3494},"你无需担心它们是否已经被创建了或者担心Convert 顺序, 因为这类调用会例行调用Convert . (这一点同样适用于GetPrimaryEntity )",{"type":14,"tag":46,"props":3496,"children":3498},{"id":3497},"如何影响-linked-entity-group",[3499],{"type":19,"value":3500},"如何影响 linked entity group",{"type":14,"tag":15,"props":3502,"children":3503},{},[3504],{"type":19,"value":3505},"回忆一下DeclareLinkedEntityGroup. 通过正确增加额外的 entity, conversion system 知道它们如何关联至 GameObject. 这些结果也会添加进 linked entity group.",{"type":14,"tag":15,"props":3507,"children":3508},{},[3509],{"type":19,"value":3510},"前面 CubeHead 的例子在自己身上调用DeclareLinkedEntityGroup , 结果是已经把额外增加的 entity 包含进来了:",{"type":14,"tag":15,"props":3512,"children":3513},{},[3514],{"type":14,"tag":55,"props":3515,"children":3517},{"alt":55,"src":3516},"/images/2020-10-19-game-object-conversion-and-subscene/v2-549d3983b0e3532643b81a2a3cecf79a_720w.jpg",[],{"type":14,"tag":15,"props":3519,"children":3520},{},[3521],{"type":19,"value":3522},"而只是单纯地通过dstManager 来创建 entity 则不会有这样的效果. 这样看起来转换CubeMultiple 更像是带着一些添加更多 Entity 到 destination world 的\"副作用\", 而不是它变成了多个 entity. 而这种模式也能配合 live link 的工作. (后文会解释)",{"type":14,"tag":46,"props":3524,"children":3526},{"id":3525},"声明-asset",[3527],{"type":19,"value":3528},"声明 Asset",{"type":14,"tag":15,"props":3530,"children":3531},{},[3532],{"type":19,"value":3533},"或许你也想通过 asset 而不仅仅是 scene 来生成 entity, 好消息是 primary entity 可以关联到 asset 上, 不只是GameObject (或MonoBehaviour), 如果你调用GetPrimaryEntity 时传入 asset, 最后会在 mapping system 里面注册, 并得到正确的 entity.",{"type":14,"tag":15,"props":3535,"children":3536},{},[3537],{"type":19,"value":3538},"因为你无法将ConvertToEntity放置到 asset 文件上, 你需要在 conversion 后某种\"声明\"它们是 entity的方法.",{"type":14,"tag":15,"props":3540,"children":3541},{},[3542],{"type":14,"tag":75,"props":3543,"children":3544},{},[3545],{"type":19,"value":3546},"什么时候声明?",{"type":14,"tag":15,"props":3548,"children":3549},{},[3550],{"type":19,"value":3551},"答案是在 conversion 真实发生之前. 这被称之为 discovering 过程. 如果你在这个conversion过程之中试图添加, 声明的 API 就会报错. 在声明之后, 在 conversion 过程中, 你就可以使用 GetPrimaryEntity来传入 asset 的 primary entity了. 如果你不这样做, 那么查询它们将会有点困难.",{"type":14,"tag":15,"props":3553,"children":3554},{},[3555],{"type":14,"tag":75,"props":3556,"children":3557},{},[3558],{"type":19,"value":3559},"IDeclareReferencedPrefabs",{"type":14,"tag":15,"props":3561,"children":3562},{},[3563],{"type":19,"value":3564},"在 discovering 阶段, 首先, 实现了IDeclareReferencedPrefabs组件接口的GameObject会被扫描, 在这里你可以通过添加 prefab asset (目前只支持 prefab 文件) 到相应的 list 中来进行声明. 你可以在inspector里通过序列化的 GameObject 字段来引用它们.",{"type":14,"tag":15,"props":3566,"children":3567},{},[3568],{"type":14,"tag":75,"props":3569,"children":3570},{},[3571],{"type":19,"value":3572},"在conversion systems里面声明",{"type":14,"tag":15,"props":3574,"children":3575},{},[3576,3578],{"type":19,"value":3577},"在扫描了接口之后, 回忆一下我们前面提到的GameObjectExportGroup. 所有运行在第一个 GameObjectDeclareReferencedObjectsGroup 中的 conversion system 会被 update. 在这里, 你有另一个声明 asset 的机会, 这里支持 prefab 和",{"type":14,"tag":75,"props":3579,"children":3580},{},[3581],{"type":19,"value":3582},"其他任意类型的 assets.",{"type":14,"tag":419,"props":3584,"children":3586},{"className":3585,"code":1366,"language":424,"meta":7},[422],[3587],{"type":14,"tag":83,"props":3588,"children":3589},{"__ignoreMap":7},[3590],{"type":19,"value":1366},{"type":14,"tag":15,"props":3592,"children":3593},{},[3594],{"type":19,"value":3595},"使用 conversion system 意味着你手边可以使用 mapping system. 其中有几个方法可以用来声明 asset. 接下来你将如何在 system 代码中获取到这些 asset 引用呢? 你可以在conversion world 中查询任意可能链接了 asset 的 component object (比如通过在可以在 inspector 中添加的字段). 当然可能某个时间点你会意识到不如最开始就使用IDeclareReferencedPrefabs , 因为反正你都得实现某种\"占位\"机制. 所以, 如非必要, 尽可能使用 IDeclareReferencedPrefabs 吧.",{"type":14,"tag":15,"props":3597,"children":3598},{},[3599],{"type":19,"value":3600},"接下来到了正常 conversion 的时候, 这时候你可以结合 IConvertGameObjectToEntity 来获取已经被转换好的 asset/prefab 的 Entity, 传入之前一样的引用即可:",{"type":14,"tag":419,"props":3602,"children":3605},{"className":3603,"code":3604,"language":424,"meta":7},[422],"public class BlinkingButton : MonoBehaviour, IDeclareReferencedPrefabs, IConvertGameObjectToEntity\n{\n    public GameObject myPrefab;\n    \n    //This first\n    public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(myPrefab);\n    }\n    \n    // |\n    // V\n    \n    //Then GameObjectDeclareReferencedObjectsGroup \u003C- last chance to declare stuff\n    \n    //Then GameObjectBeforeConversionGroup\n    //Then GameObjectConversionGroup, which contains ConvertGameObjectToEntitySystem that run the following Convert\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        //Get primary entity of the prefab asset, to assign to primary entity converted from this component.\n        Entity prefabAssetEntity = conversionSystem.GetPrimaryEntity(myPrefab);\n        //Remember it, etc.\n    }\n    \n    // |\n    // V\n    \n    //Then GameObjectAfterConversionGroup\n}\n",[3606],{"type":14,"tag":83,"props":3607,"children":3608},{"__ignoreMap":7},[3609],{"type":19,"value":3604},{"type":14,"tag":15,"props":3611,"children":3612},{},[3613],{"type":19,"value":3614},"要注意 IConvertToGameObjectToEntity 的 Convert 被调用时你依然有机会使用 mapping system. (添加额外 entity, 遍历其他 primary entity 等等) 但如果你这时候使用 mapping system 来声明更多东西就太晚了会报错.",{"type":14,"tag":15,"props":3616,"children":3617},{},[3618],{"type":19,"value":3619},"以下就是完整的过程:",{"type":14,"tag":419,"props":3621,"children":3624},{"className":3622,"code":3623,"language":424,"meta":7},[422],"// ??? \u003C- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? \u003C- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n// ???\nGameObjectExportGroup.Update()\n",[3625],{"type":14,"tag":83,"props":3626,"children":3627},{"__ignoreMap":7},[3628],{"type":19,"value":3623},{"type":14,"tag":15,"props":3630,"children":3631},{},[3632],{"type":19,"value":3633},"顺便一提声明截至仅仅针对 asset/prefab, 你依然可以在conversion 过程中调用DeclareLinkedEntityGroup.",{"type":14,"tag":15,"props":3635,"children":3636},{},[3637],{"type":14,"tag":75,"props":3638,"children":3639},{},[3640],{"type":19,"value":3641},"声明任意 asset",{"type":14,"tag":15,"props":3643,"children":3644},{},[3645,3647,3652],{"type":19,"value":3646},"在 mapping system 里 使用DeclareReferencedAsset , ",{"type":14,"tag":75,"props":3648,"children":3649},{},[3650],{"type":19,"value":3651},"在 conversion world 里",{"type":19,"value":3653},", 你会得到一个关联 Asset conponent , 外加一个你声明的 asset 类型的 component object 的 Entity (注意并非 destination world).",{"type":14,"tag":15,"props":3655,"children":3656},{},[3657],{"type":19,"value":3658},"例如我可以通过DeclareReferencedAsset(mySpriteAtlas).来创建一个Entity+Asset+SpriteAtlas , 这时候 destination world 的 primary entity 依然是空的, 目前还不明白这个系统设计的目的, 也许是为了让你自己处理Asset的转换过程.",{"type":14,"tag":15,"props":3660,"children":3661},{},[3662],{"type":14,"tag":75,"props":3663,"children":3664},{},[3665],{"type":19,"value":3666},"声明 prefab asset",{"type":14,"tag":15,"props":3668,"children":3669},{},[3670],{"type":19,"value":3671},"添加进IDeclareReferencedPrefabs 里的 list 就行. 对于 GameObjectDeclareReferencedObjectsGroup 里的 system 来讲, 则是使用 mapping system 的DeclareReferencedPrefab 方法.",{"type":14,"tag":15,"props":3673,"children":3674},{},[3675,3677,3682],{"type":19,"value":3676},"不过这一次和AssetandGameObject component object 不一样, 你会在 destination world 中得到一个真正的 ",{"type":14,"tag":75,"props":3678,"children":3679},{},[3680],{"type":19,"value":3681},"prefab engity",{"type":19,"value":3683}," (而不是前面说到的空结果).",{"type":14,"tag":15,"props":3685,"children":3686},{},[3687],{"type":19,"value":3688},"接下来简单解释下什么是 Entityprefab. 如果你添加一个 Prefab 组件到任何 Entity, 除非你显式指定, 那么它将在默认 query 中隐身, 和Disabled组件的行为很相似. 使用 Instantiate方法则会将实例化出的 entity 将该prefab组件删掉. (毕竟你不太可能想要实例化另一个 prefab 出来...)",{"type":14,"tag":15,"props":3690,"children":3691},{},[3692],{"type":19,"value":3693},"不过该行为的目的又有所不同, 之所以在 query 中隐藏它们是并非主观上想要让它们处于 \"inactive\" 状态, 而是它们本就该是 \"inactive\". 它们只不过是用来快速创建新数据的蓝图. 因此, 在创建 query 时有两个不同的参数模式: \"include disabled\" 和 \"include prefabs\". 使用时注意语义上的区别 (如不要使用 Prefab 来隐藏 Entity).",{"type":14,"tag":15,"props":3695,"children":3696},{},[3697],{"type":19,"value":3698},"结合前面提到的LinkedEntityGroup , 现在ECS的实例化已经和传统 Unity 的实例化感觉一样了!",{"type":14,"tag":15,"props":3700,"children":3701},{},[3702],{"type":19,"value":3703},"通过声明 prefab asset, 你便同时添加了Prefab和LinkedEntityGroup 到目标primary entity上.",{"type":14,"tag":15,"props":3705,"children":3706},{},[3707,3709,3714],{"type":19,"value":3708},"要注意ConvertToEntity只是转换对象为普通的 Entity, 因为 scene 里的层级结构并不是 ",{"type":14,"tag":75,"props":3710,"children":3711},{},[3712],{"type":19,"value":3713},"asset.",{"type":19,"value":3715}," 无论它们是不是蓝色的(即在scene里被实例化的 prefab), 我们都无法得到Prefab或LinkedEntityGroup.",{"type":14,"tag":15,"props":3717,"children":3718},{},[3719],{"type":19,"value":3720},"Prefab 本身则属于 asset 文件, 你无法在 Project panel 中粘贴ConvertToEntity运行. ECS 库通过查看它是不是位于 scene 中来决定它是不是一个 prefab, 显然可以粘贴ConvertToEntity 则意味着对象在 scene 中.",{"type":14,"tag":46,"props":3722,"children":3724},{"id":3723},"prefab-asset-conversion-过程",[3725],{"type":19,"value":3726},"Prefab asset conversion 过程",{"type":14,"tag":15,"props":3728,"children":3729},{},[3730],{"type":19,"value":3731},"上面的声明过程实际上会调用 convert 过程. 接下来我说说和转换 scene 中GameObject在细节上有哪些不同. 只要在 scene 层级中, 是否从 prefab 实例化就无关紧要, 只有在从 Project panel 处声明的 asset 被实例化时才会有区别:",{"type":14,"tag":15,"props":3733,"children":3734},{},[3735],{"type":14,"tag":75,"props":3736,"children":3737},{},[3738],{"type":19,"value":3739},"为实例化准备的自动 LinkedEntityGroup",{"type":14,"tag":15,"props":3741,"children":3742},{},[3743],{"type":19,"value":3744},"如下所示的 prefab asset 设置:",{"type":14,"tag":15,"props":3746,"children":3747},{},[3748],{"type":14,"tag":55,"props":3749,"children":3751},{"alt":55,"src":3750},"/images/2020-10-19-game-object-conversion-and-subscene/v2-de0722a0a9b1b64f962e00c0655f6641_720w.jpg",[],{"type":14,"tag":15,"props":3753,"children":3754},{},[3755],{"type":14,"tag":55,"props":3756,"children":3758},{"alt":55,"src":3757},"/images/2020-10-19-game-object-conversion-and-subscene/v2-968dbba1c2b6b1579f9cd5d7b1083d42_720w.jpg",[],{"type":14,"tag":15,"props":3760,"children":3761},{},[3762],{"type":19,"value":3763},"要意识到 CubeHead 是一个 asset, 而不是 scene 对象.",{"type":14,"tag":419,"props":3765,"children":3768},{"className":3766,"code":3767,"language":424,"meta":7},[422],"[GenerateAuthoringComponent]\npublic struct PrefabConversion : IComponentData\n{\n    public Entity prefab;\n}\n",[3769],{"type":14,"tag":83,"props":3770,"children":3771},{"__ignoreMap":7},[3772],{"type":19,"value":3767},{"type":14,"tag":15,"props":3774,"children":3775},{},[3776],{"type":19,"value":3777},"我们会得到:",{"type":14,"tag":15,"props":3779,"children":3780},{},[3781],{"type":14,"tag":55,"props":3782,"children":3784},{"alt":55,"src":3783},"/images/2020-10-19-game-object-conversion-and-subscene/v2-eca8ecacce32b7cb618f690308873ba7_720w.jpg",[],{"type":14,"tag":815,"props":3786,"children":3787},{},[3788,3793,3798,3803],{"type":14,"tag":819,"props":3789,"children":3790},{},[3791],{"type":19,"value":3792},"如果我们 convert 位于 scene 中的 CubeHead, 我们无法获取到LinkedEntityGroup. 该行为仅仅针对 prefab asset, 其目的显然是为了实例化. (链锁销毁行为也一样)",{"type":14,"tag":819,"props":3794,"children":3795},{},[3796],{"type":19,"value":3797},"LinkedEntityGroup 包含层级树下的所有对象以及自己, 包括 cube 3 和 cube 4. Conversion过程让 prefab \"线性化\"了, 实例化过程就无需递归调用了, 是需要遍历 LinkedEntityGroup即可.",{"type":14,"tag":819,"props":3799,"children":3800},{},[3801],{"type":19,"value":3802},"前文提到过, 之所以LinkedEntityGroup包含它自己是因为 SetEnable 可以一次性完成工作, 而不是一个接一个的调用.",{"type":14,"tag":819,"props":3804,"children":3805},{},[3806],{"type":19,"value":3807},"所有转换后的 entity 都会添加 Prefab组件, 但是我们只需要使用最顶层的那个 Entity 用于实例化. 事实上, 实例化过程没有Prefab 什么事儿, 主要是用LinkedEntityGroup 来完成工作. 实际上你可以实例化任何 entity.",{"type":14,"tag":15,"props":3809,"children":3810},{},[3811],{"type":14,"tag":75,"props":3812,"children":3813},{},[3814],{"type":19,"value":3815},"为禁用功能准备的自动LinkedEntityGroup",{"type":14,"tag":15,"props":3817,"children":3818},{},[3819],{"type":19,"value":3820},"前文解释过 prefab 的顶层对象会得到LinkedEntityGroup 是因为需要实例化.",{"type":14,"tag":15,"props":3822,"children":3823},{},[3824],{"type":19,"value":3825},"额外地, 如果在 prefab 的任何位置发现了被禁用的GameObject,该位置的对象也会得到包含所有子级对象的LinkedEntityGroup .",{"type":14,"tag":15,"props":3827,"children":3828},{},[3829],{"type":19,"value":3830},"该行为的目的是为了你可以在已经被实例化的 Entity 上使用SetEnable 时能高效地添加 Disabled组件. 当然Disabled的 conversion 过程依然遵循相同的规则: 当 convert 一个非 asset 的GameObject , 会自动添加LinkedEntityGroup.",{"type":14,"tag":15,"props":3832,"children":3833},{},[3834],{"type":14,"tag":75,"props":3835,"children":3836},{},[3837],{"type":19,"value":3838},"Can't stop won't stop",{"type":14,"tag":15,"props":3840,"children":3841},{},[3842],{"type":19,"value":3843},"你不能在 prefab 中使用 Convert To Entity (Stop), 没用.",{"type":14,"tag":15,"props":3845,"children":3846},{},[3847],{"type":14,"tag":75,"props":3848,"children":3849},{},[3850],{"type":19,"value":3851},"来点小测验吧.",{"type":14,"tag":15,"props":3853,"children":3854},{},[3855],{"type":19,"value":3856},"依照目前这些 conversion 的规则, 来检查一下你是否能推算出上面例子正确的结果吧: Parent(还记得这是为 transform systems准备的么),Prefab,Disabled,LinkedEntityGroup(以及里面的 entity).Child和相关组件会根据Parent组件在一轮 transform systems 的update 之后被添加.",{"type":14,"tag":15,"props":3858,"children":3859},{},[3860],{"type":14,"tag":55,"props":3861,"children":3863},{"alt":55,"src":3862},"/images/2020-10-19-game-object-conversion-and-subscene/v2-081c8f1dcb6bece2eeb25a3e11620da6_720w.jpg",[],{"type":14,"tag":419,"props":3865,"children":3869},{"className":3866,"code":3868,"language":19,"meta":7},[3867],"language-text","Cube : Prefab, LinkedEntityGroup (Cube,1,2,3,4)\n1    : Prefab, Parent (Cube)\n2    : Prefab, Parent (Cube)\n3    : Prefab, Parent (2)\n4    : Prefab, Parent (2)\n",[3870],{"type":14,"tag":83,"props":3871,"children":3872},{"__ignoreMap":7},[3873],{"type":19,"value":3868},{"type":14,"tag":15,"props":3875,"children":3876},{},[3877],{"type":14,"tag":55,"props":3878,"children":3880},{"alt":55,"src":3879},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f0ecb3bdbdef8bdba3b8ec63f994015c_720w.jpg",[],{"type":14,"tag":419,"props":3882,"children":3885},{"className":3883,"code":3884,"language":19,"meta":7},[3867],"Cube : Prefab, Prefab, LinkedEntityGroup (Cube,1,2,3,4)\n1    : Prefab, Parent (Cube)\n2    : Prefab, Parent (Cube), Disabled, LinkedEntityGroup (2,3,4)\n3    : Prefab, Parent (2), Disabled\n4    : Prefab, Parent (2), Disabled\n",[3886],{"type":14,"tag":83,"props":3887,"children":3888},{"__ignoreMap":7},[3889],{"type":19,"value":3884},{"type":14,"tag":15,"props":3891,"children":3892},{},[3893],{"type":19,"value":3894},"要记住LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.(也许你觉得这无所谓, 但实际上这会让 chunks 的碎片变多).",{"type":14,"tag":15,"props":3896,"children":3897},{},[3898],{"type":14,"tag":55,"props":3899,"children":3901},{"alt":55,"src":3900},"/images/2020-10-19-game-object-conversion-and-subscene/v2-8abf5ccdb436f84aa87e0982f3eba30b_720w.jpg",[],{"type":14,"tag":419,"props":3903,"children":3906},{"className":3904,"code":3905,"language":19,"meta":7},[3867],"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube)\n3    : Parent (2)\n4    : Parent (2)\n",[3907],{"type":14,"tag":83,"props":3908,"children":3909},{"__ignoreMap":7},[3910],{"type":19,"value":3905},{"type":14,"tag":15,"props":3912,"children":3913},{},[3914],{"type":14,"tag":55,"props":3915,"children":3917},{"alt":55,"src":3916},"/images/2020-10-19-game-object-conversion-and-subscene/v2-43536999ecd92ac2b1f1788ba43257c8_720w.jpg",[],{"type":14,"tag":419,"props":3919,"children":3921},{"className":3920,"code":3905,"language":19,"meta":7},[3867],[3922],{"type":14,"tag":83,"props":3923,"children":3924},{"__ignoreMap":7},[3925],{"type":19,"value":3905},{"type":14,"tag":15,"props":3927,"children":3928},{},[3929],{"type":19,"value":3930},"是否蓝色名字(说明它连接这 prefab asset)无所谓, 它不是 asset, 不会遵循LinkedEntityGroup的conversion 规则.",{"type":14,"tag":15,"props":3932,"children":3933},{},[3934],{"type":14,"tag":55,"props":3935,"children":3937},{"alt":55,"src":3936},"/images/2020-10-19-game-object-conversion-and-subscene/v2-9b32027c1ea133d6cc35ff6861ff544a_720w.jpg",[],{"type":14,"tag":419,"props":3939,"children":3942},{"className":3940,"code":3941,"language":19,"meta":7},[3867],"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube), Disabled\n3    : Parent (2), Disabled\n4    : Parent (2), Disabled\n",[3943],{"type":14,"tag":83,"props":3944,"children":3945},{"__ignoreMap":7},[3946],{"type":19,"value":3941},{"type":14,"tag":15,"props":3948,"children":3949},{},[3950],{"type":19,"value":3951},"注意, 这时候你无法通过Cube (2) 连锁地禁用 Cube (3) 和 (4), 因为没有自动生成LinkedEntityGroup, 但你可以人工声明它.",{"type":14,"tag":15,"props":3953,"children":3954},{},[3955],{"type":14,"tag":75,"props":3956,"children":3957},{},[3958],{"type":19,"value":3959},"prefab 实例化时的 Remapping 过程",{"type":14,"tag":15,"props":3961,"children":3962},{},[3963,3965,3970,3972,3979,3981,3985],{"type":19,"value":3964},"当在拥有LinkedEntityGroup的entity上调用Instantiate时, 会发生 ",{"type":14,"tag":75,"props":3966,"children":3967},{},[3968],{"type":19,"value":3969},"entity remap",{"type":19,"value":3971}," 过程. (这里阅读更多内容: ",{"type":14,"tag":22,"props":3973,"children":3976},{"href":3974,"rel":3975},"https://link.zhihu.com/?target=https%3A//gametorrahod.com/entity-remapping/",[26],[3977],{"type":19,"value":3978},"https://gametorrahod.com/entity-remapping/",{"type":19,"value":3980},") 目前你只需要知道 convert 一个 prefab ",{"type":14,"tag":75,"props":3982,"children":3983},{},[3984],{"type":19,"value":3256},{"type":19,"value":3986}," 让LinkedEntityGroup 能工作, 就行了.",{"type":14,"tag":15,"props":3988,"children":3989},{},[3990],{"type":14,"tag":29,"props":3991,"children":3992},{},[3993],{"type":19,"value":3994},"(译注: entity id 在一个 world 当中是不可重复也不可被外部修改的, 当序列化存储 entity 时, 反序列化过程会因版本问题丢失掉 entity id 引用, 这一问题同样影响实例化过程, 而 entity remap 过程就为了解决这一问题而出现的)",{"type":14,"tag":15,"props":3996,"children":3997},{},[3998],{"type":19,"value":3999},"所以, \"烘焙\" Entity 值到 prefab entity 的 conversion 结果中是可行的, 当实例化时, 这些烘焙好的值又会\"活了过来\".",{"type":14,"tag":15,"props":4001,"children":4002},{},[4003],{"type":19,"value":4004},"在前例的情况中, 如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:",{"type":14,"tag":15,"props":4006,"children":4007},{},[4008],{"type":14,"tag":55,"props":4009,"children":4010},{"alt":55,"src":3750},[],{"type":14,"tag":419,"props":4012,"children":4015},{"className":4013,"code":4014,"language":424,"meta":7},[422],"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent\u003CLinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer\u003CLinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n",[4016],{"type":14,"tag":83,"props":4017,"children":4018},{"__ignoreMap":7},[4019],{"type":19,"value":4014},{"type":14,"tag":15,"props":4021,"children":4022},{},[4023],{"type":14,"tag":55,"props":4024,"children":4026},{"alt":55,"src":4025},"/images/2020-10-19-game-object-conversion-and-subscene/v2-50abef20adb51226bd0af6bddba9e8bb_720w.jpg",[],{"type":14,"tag":15,"props":4028,"children":4029},{},[4030],{"type":19,"value":4031},"这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用.",{"type":14,"tag":15,"props":4033,"children":4034},{},[4035],{"type":19,"value":4036},"![img](data/svg+xml;utf8,)",{"type":14,"tag":15,"props":4038,"children":4039},{},[4040],{"type":19,"value":4041},"当你调用Instantiate时, 一旦它发现可以被 Remap 的情况(如LinkedEntityGroup) Remapping 就会发生. 因此在 conversion 把它变成 Prefab 之前, \"连接\" Entity 引用是非常有用的, 这样一旦你Instantiate 它, 里面包含的 Entity 关系就已经可用了.",{"type":14,"tag":15,"props":4043,"children":4044},{},[4045],{"type":19,"value":4046},"没有LinkedEntityGroup则 Remapping不会发生, 因为在那种情况下就没有同级对象需要 remapping Entity 的值了.",{"type":14,"tag":15,"props":4048,"children":4049},{},[4050],{"type":14,"tag":75,"props":4051,"children":4052},{},[4053],{"type":19,"value":4054},"GameObjectExportGroup 是什么?",{"type":14,"tag":15,"props":4056,"children":4057},{},[4058,4060,4065],{"type":19,"value":4059},"前面 4 个我们都介绍了它们的作用, 来看看最后这一个. 前面介绍的过程你也许会发现不仅仅可以将 conversion 结果用作运行时, 也可以用来",{"type":14,"tag":75,"props":4061,"children":4062},{},[4063],{"type":19,"value":4064},"导出",{"type":19,"value":4066},". 通常 export group 是不包含在conversion 流程中的, 仅当我们显式要求时才导出.",{"type":14,"tag":15,"props":4068,"children":4069},{},[4070],{"type":19,"value":4071},"如果你的 conversion system 运行在这里, 那么所有的 conversion 都已经完成, LinkedEntityGroup Prefab都已经准备就绪, 当然你不能在这时候继续 convert 了.",{"type":14,"tag":15,"props":4073,"children":4074},{},[4075],{"type":19,"value":4076},"目前究竟什么是\"导出(export)\"依然是个谜, 或许得等 Unity 团队写点我能看懂的文档. 目前你可以认为这个 Group 在你日常的 conversion 中用不太上. 而且猜想它一定和 Assetentity有某些关系.",{"type":14,"tag":419,"props":4078,"children":4081},{"className":4079,"code":4080,"language":424,"meta":7},[422],"// ??? \u003C- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? \u003C- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n// ??? \u003C- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n",[4082],{"type":14,"tag":83,"props":4083,"children":4084},{"__ignoreMap":7},[4085],{"type":19,"value":4080},{"type":14,"tag":15,"props":4087,"children":4088},{},[4089],{"type":14,"tag":75,"props":4090,"children":4091},{},[4092],{"type":19,"value":4093},"mapping system 上的 DeclareDependency 是啥",{"type":14,"tag":15,"props":4095,"children":4096},{},[4097],{"type":19,"value":4098},"我们还漏掉了一个\"声明\". 但是我不清楚这是什么, 它看起来像是 live link 会用到的东西. (后文会解释 live link).",{"type":14,"tag":46,"props":4100,"children":4102},{"id":4101},"声明和使用-prefab-asset-的示例",[4103],{"type":19,"value":4104},"声明和使用 prefab asset 的示例",{"type":14,"tag":15,"props":4106,"children":4107},{},[4108],{"type":14,"tag":55,"props":4109,"children":4111},{"alt":55,"src":4110},"/images/2020-10-19-game-object-conversion-and-subscene/v2-88397d41a933c41fecc23cfdf0ca8e74_720w.jpg",[],{"type":14,"tag":15,"props":4113,"children":4114},{},[4115],{"type":19,"value":4116},"如果我 convert and destroy 上面这些 cubes 的 MeshFilter和MeshRenderer, 我会得到两个 chunk:",{"type":14,"tag":15,"props":4118,"children":4119},{},[4120],{"type":14,"tag":55,"props":4121,"children":4123},{"alt":55,"src":4122},"/images/2020-10-19-game-object-conversion-and-subscene/v2-7b1b82fa14a9c96763edcd0cc98fe34c_720w.jpg",[],{"type":14,"tag":15,"props":4125,"children":4126},{},[4127],{"type":14,"tag":55,"props":4128,"children":4130},{"alt":55,"src":4129},"/images/2020-10-19-game-object-conversion-and-subscene/v2-84ff4d8fe1120763c200837ec2c6e6fb_720w.jpg",[],{"type":14,"tag":15,"props":4132,"children":4133},{},[4134],{"type":19,"value":4135},"现在我将把它变成 prefab asset, 并从 scene 中删掉, 接着我会把该 prefab 转换为隐藏的 Prefab entity 以用于后面的 Instantiate.",{"type":14,"tag":15,"props":4137,"children":4138},{},[4139],{"type":19,"value":4140},"下面是我的计划: 做一个 SpawnHere 用于存储实例化位置 (\"tag\" 性质的MonoBehaviour).",{"type":14,"tag":15,"props":4142,"children":4143},{},[4144],{"type":14,"tag":55,"props":4145,"children":4147},{"alt":55,"src":4146},"/images/2020-10-19-game-object-conversion-and-subscene/v2-b92b5408db5a1d0c1b57c3bc876c1b63_720w.jpg",[],{"type":14,"tag":15,"props":4149,"children":4150},{},[4151],{"type":19,"value":4152},"不用担心上图中有3个GameObject声明了同一个 prefab, conversion system 知道如何处理重复情况, 下面是代码:",{"type":14,"tag":419,"props":4154,"children":4157},{"className":4155,"code":4156,"language":19,"meta":7},[3867],"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n    \n    public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n    }\n}\n",[4158],{"type":14,"tag":83,"props":4159,"children":4160},{"__ignoreMap":7},[4161],{"type":19,"value":4156},{"type":14,"tag":15,"props":4163,"children":4164},{},[4165],{"type":19,"value":4166},"在 discovery 阶段 asset 的 primary entity 已经被创建了且包含了Prefab和LinkedEntityGroup, 能够正常用于实例化. (由于 Prefab 的存在, 虽然拥有 RenderMesh和LocalToWorld组件, 但 Cube entity 是对于查询隐藏的, 因此也没有在画面中显示)",{"type":14,"tag":15,"props":4168,"children":4169},{},[4170],{"type":14,"tag":55,"props":4171,"children":4173},{"alt":55,"src":4172},"/images/2020-10-19-game-object-conversion-and-subscene/v2-61b91e13ae93422ebf600817a3d04dd2_720w.jpg",[],{"type":14,"tag":15,"props":4175,"children":4176},{},[4177],{"type":14,"tag":55,"props":4178,"children":4180},{"alt":55,"src":4179},"/images/2020-10-19-game-object-conversion-and-subscene/v2-32ab362213045eb4e7f2b0e5668928d0_720w.jpg",[],{"type":14,"tag":15,"props":4182,"children":4183},{},[4184],{"type":19,"value":4185},"conversion 之后, 我就可以获取Prefab在 SpawnHere 所在的位置进行实例化了, 因为LocalToWorld或Translation很多 entity 都包含, 被销毁的SpawnHere 是无法被区分的.",{"type":14,"tag":15,"props":4187,"children":4188},{},[4189],{"type":14,"tag":55,"props":4190,"children":4192},{"alt":55,"src":4191},"/images/2020-10-19-game-object-conversion-and-subscene/v2-fcc91ab4bc4773a9cea287ca4ef89419_720w.jpg",[],{"type":14,"tag":15,"props":4194,"children":4195},{},[4196],{"type":19,"value":4197},"因此我们添加 SpawnHereEcs 当作 Tag 来使用:",{"type":14,"tag":419,"props":4199,"children":4202},{"className":4200,"code":4201,"language":424,"meta":7},[422],"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\npublic struct SpawnHereEcs : IComponentData\n{\n}\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n    \n    public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent\u003CSpawnHereEcs>(entity);\n    }\n}\n",[4203],{"type":14,"tag":83,"props":4204,"children":4205},{"__ignoreMap":7},[4206],{"type":19,"value":4201},{"type":14,"tag":15,"props":4208,"children":4209},{},[4210],{"type":19,"value":4211},"另外, 我们可以直接在 SpawnHereEcs 里面加上 prefab entity 的引用, 而获取该 entity 的方式就是前文提到的声明过程:",{"type":14,"tag":419,"props":4213,"children":4216},{"className":4214,"code":4215,"language":424,"meta":7},[422],"using System.Collections.Generic;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Transforms;\nusing UnityEngine;\n\npublic struct SpawnHereEcs : IComponentData\n{\n    public Entity thatPrefabEntity;\n}\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n\n    public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);\n        dstManager.AddComponentData\u003CSpawnHereEcs>(entity, new SpawnHereEcs {thatPrefabEntity = prefabEntity});\n    }\n}\n",[4217],{"type":14,"tag":83,"props":4218,"children":4219},{"__ignoreMap":7},[4220],{"type":19,"value":4215},{"type":14,"tag":15,"props":4222,"children":4223},{},[4224],{"type":19,"value":4225},"然后我们的 system 将查询SpawnHereEcsentity 并在这些位置执行实例化, 之后再销毁SpawnHereEcs以避免重复实例化.",{"type":14,"tag":419,"props":4227,"children":4230},{"className":4228,"code":4229,"language":424,"meta":7},[422]," [UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class SpawnSystem : JobComponentSystem\n{\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities.ForEach(\n                (Entity e, in Translation t, in SpawnHereEcs she) =>\n                {\n                    Entity instantiated = EntityManager.Instantiate(she.thatPrefabEntity);\n                    //Set to the same translation.\n                    EntityManager.SetComponentData(instantiated, t);\n                    EntityManager.RemoveComponent\u003CSpawnHereEcs>(e);\n                })\n            .WithStructuralChanges().Run();\n        return default;\n    }\n}\n",[4231],{"type":14,"tag":83,"props":4232,"children":4233},{"__ignoreMap":7},[4234],{"type":19,"value":4229},{"type":14,"tag":15,"props":4236,"children":4237},{},[4238],{"type":19,"value":4239},"你可以按照 chunk 来批量RemoveComponent , 使用WithStoreEntityQueryInField 来导出 lambda 定义的 EntityQuery, 然后在 ForEach 之后使用 EntityManager.RemoveComponent 传入该EntityQuery.",{"type":14,"tag":15,"props":4241,"children":4242},{},[4243],{"type":19,"value":4244},"以下是我们的结果:",{"type":14,"tag":15,"props":4246,"children":4247},{},[4248],{"type":14,"tag":55,"props":4249,"children":4251},{"alt":55,"src":4250},"/images/2020-10-19-game-object-conversion-and-subscene/v2-a9888335c0aec5a24d809d2d49fd372c_720w.jpg",[],{"type":14,"tag":15,"props":4253,"children":4254},{},[4255],{"type":14,"tag":55,"props":4256,"children":4258},{"alt":55,"src":4257},"/images/2020-10-19-game-object-conversion-and-subscene/v2-d2fe910f9e5023e20a942675396ee977_720w.jpg",[],{"type":14,"tag":15,"props":4260,"children":4261},{},[4262],{"type":19,"value":4263},"和Prefab 一样我们实例化的结果也拥有LinkedEntityGroup, 你还可以注意到 debugger 现在支持 select 按钮来选中 entity.",{"type":14,"tag":15,"props":4265,"children":4266},{},[4267,4269,4274],{"type":19,"value":4268},"那么有没有可能在 conversion 阶段就能预先实例化呢? 这样我们就无需 SpawnHereEcstag 了, 因为我们知道TransformConversion完成的确切时间, 所以我们已经可以利用其 primary entity 来获取位置. 然后利用 dstManager来完成实例化. 看起来就像是SpawnHere MonoBehaviour",{"type":14,"tag":75,"props":4270,"children":4271},{},[4272],{"type":19,"value":4273},"直接转化",{"type":19,"value":4275},"成了 prefab 实例, 而不是在运行时分开来完成这一切.",{"type":14,"tag":15,"props":4277,"children":4278},{},[4279],{"type":19,"value":4280},"你可以思考一下为什么这种方法无法正确工作然后再继续往下看",{"type":14,"tag":419,"props":4282,"children":4285},{"className":4283,"code":4284,"language":424,"meta":7},[422],"using System.Collections.Generic;\nusing Unity.Entities;\nusing Unity.Transforms;\nusing UnityEngine;\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n\n    public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);\n        \n        var spawnPosition = dstManager.GetComponentData\u003CTranslation>(entity);\n\n        Entity instantiated = dstManager.Instantiate(prefabEntity);\n        dstManager.SetComponentData\u003CTranslation>(instantiated, spawnPosition);\n    }\n}\n",[4286],{"type":14,"tag":83,"props":4287,"children":4288},{"__ignoreMap":7},[4289],{"type":19,"value":4284},{"type":14,"tag":15,"props":4291,"children":4292},{},[4293],{"type":14,"tag":55,"props":4294,"children":4296},{"alt":55,"src":4295},"/images/2020-10-19-game-object-conversion-and-subscene/v2-aa979cae836c032b9353451a6c1b3f31_720w.jpg",[],{"type":14,"tag":15,"props":4298,"children":4299},{},[4300,4305],{"type":14,"tag":75,"props":4301,"children":4302},{},[4303],{"type":19,"value":4304},"几乎",{"type":19,"value":4306},"能够工作, 但是结果是只有三个cubes. 从图中可以知道, GetPrimaryEntity显然是能够正常工作的, 因为已经度过了 discovery 阶段. GetComponentData 也能正常工作, 因为Transform会在 GameObjectBeforeConversionGroup 阶段转换完成.",{"type":14,"tag":15,"props":4308,"children":4309},{},[4310],{"type":19,"value":4311},"但是回忆一下LinkedEntityGroup和Prefab 所涉及的声明过程:",{"type":14,"tag":419,"props":4313,"children":4316},{"className":4314,"code":4315,"language":424,"meta":7},[422],"// ??? \u003C- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? \u003C- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() \u003C-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? \u003C- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n",[4317],{"type":14,"tag":83,"props":4318,"children":4319},{"__ignoreMap":7},[4320],{"type":19,"value":4315},{"type":14,"tag":15,"props":4322,"children":4323},{},[4324],{"type":19,"value":4325},"LinkedEntityGroup和Prefab 并未就绪! 缺乏LinkedEntityGroup导致我们最终的结果里仅仅实例化了最顶层的那个 cube. 因此在conversion过程中你无法这样使用刚刚声明的 Prefab. 如果你不清楚 conversion 流程, 很难知道为什么会有这样的结果.",{"type":14,"tag":46,"props":4327,"children":4329},{"id":4328},"generateauthoringcomponent",[4330],{"type":19,"value":4331},"[GenerateAuthoringComponent]",{"type":14,"tag":15,"props":4333,"children":4334},{},[4335,4337],{"type":19,"value":4336},"SpawnHere->SpawnHereEcs 这种模式要求你有一个 MonoBehaviourcomponent 在 inspector 中暴露一些字段, 然后在 conversion 后转换为等价的数据. 我们把这个MonoBehaviour称为 ",{"type":14,"tag":75,"props":4338,"children":4339},{},[4340],{"type":19,"value":4341},"authoring component.",{"type":14,"tag":15,"props":4343,"children":4344},{},[4345],{"type":19,"value":4346},"我们当然可以创建GameObjectConversionSystem来完成相同的工作. 但是使用IConvertGameObjectToEntity无疑是更精简的方式.",{"type":14,"tag":419,"props":4348,"children":4351},{"className":4349,"code":4350,"language":424,"meta":7},[422],"using Unity.Entities;\nusing UnityEngine;\n\n//The real ECS\npublic struct MyData : IComponentData\n{\n    public float data1;\n    public int data2;\n    public bool data3;\n}\n\n//For authoring\npublic class MyDataOnScene : MonoBehaviour, IConvertGameObjectToEntity\n{\n    // Ugly duplicated code\n    public float data1;\n    public int data2;\n    public bool data3;\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentData\u003CMyData>(entity, new MyData\n        {\n            // Tedious work\n            data1 = data1,\n            data2 = data2,\n            data3 = data3,\n        });\n    }\n}\n",[4352],{"type":14,"tag":83,"props":4353,"children":4354},{"__ignoreMap":7},[4355],{"type":19,"value":4350},{"type":14,"tag":15,"props":4357,"children":4358},{},[4359],{"type":14,"tag":55,"props":4360,"children":4362},{"alt":55,"src":4361},"/images/2020-10-19-game-object-conversion-and-subscene/v2-35431ad3689e54c311b7c1256e5cbe7f_720w.jpg",[],{"type":14,"tag":15,"props":4364,"children":4365},{},[4366],{"type":14,"tag":55,"props":4367,"children":4369},{"alt":55,"src":4368},"/images/2020-10-19-game-object-conversion-and-subscene/v2-4a05be4b1b63bd7fc675c8a697d36565_720w.jpg",[],{"type":14,"tag":15,"props":4371,"children":4372},{},[4373],{"type":19,"value":4374},"更棒的是, ECS 还有 IL 黑魔法来帮助你完成这个过程:",{"type":14,"tag":419,"props":4376,"children":4379},{"className":4377,"code":4378,"language":424,"meta":7},[422],"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public float data1;\n    public int data2;\n    public bool data3;\n}\n",[4380],{"type":14,"tag":83,"props":4381,"children":4382},{"__ignoreMap":7},[4383],{"type":19,"value":4378},{"type":14,"tag":15,"props":4385,"children":4386},{},[4387],{"type":14,"tag":55,"props":4388,"children":4390},{"alt":55,"src":4389},"/images/2020-10-19-game-object-conversion-and-subscene/v2-29e1525831cf721dcee0618eff79b2ec_720w.jpg",[],{"type":14,"tag":15,"props":4392,"children":4393},{},[4394],{"type":19,"value":4395},"注意我们这里并没有定义 MonoBehaviour, 我们自动获取到了名为\"My Data Authoring\" 的组件, 甚至 \"My Data\" 也可以作为相同结果来添加. 这部分生成代码会和我们手写有类似 Convert 过程, 由于你无法查看生成的代码是什么, 这基本相当于魔法.",{"type":14,"tag":15,"props":4397,"children":4398},{},[4399],{"type":19,"value":4400},"目前要施放该魔法, ECS 字段必须定义为 public, 下面这样的代码并无法按你所设想的那样工作:",{"type":14,"tag":419,"props":4402,"children":4405},{"className":4403,"code":4404,"language":424,"meta":7},[422],"using Unity.Entities;\nusing UnityEngine;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    [SerializeField] internal float data1;\n    [SerializeField] public int data2;\n    [SerializeField] public bool data3;\n}\n",[4406],{"type":14,"tag":83,"props":4407,"children":4408},{"__ignoreMap":7},[4409],{"type":19,"value":4404},{"type":14,"tag":15,"props":4411,"children":4412},{},[4413],{"type":14,"tag":55,"props":4414,"children":4416},{"alt":55,"src":4415},"/images/2020-10-19-game-object-conversion-and-subscene/v2-babbcac3eb118386ffd7120ee87295d2_720w.jpg",[],{"type":14,"tag":15,"props":4418,"children":4419},{},[4420,4422],{"type":19,"value":4421},"还有一个小技巧是可以生成 \"声明 prefab asset\" 模式功能的代码 (前面SpawnHereEcs的例子), ",{"type":14,"tag":75,"props":4423,"children":4424},{},[4425],{"type":19,"value":4426},"仅需定义一个 Entity字段即可.",{"type":14,"tag":419,"props":4428,"children":4431},{"className":4429,"code":4430,"language":424,"meta":7},[422],"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public Entity magic;\n}\n",[4432],{"type":14,"tag":83,"props":4433,"children":4434},{"__ignoreMap":7},[4435],{"type":19,"value":4430},{"type":14,"tag":15,"props":4437,"children":4438},{},[4439],{"type":14,"tag":55,"props":4440,"children":4442},{"alt":55,"src":4441},"/images/2020-10-19-game-object-conversion-and-subscene/v2-e3e22ca2eab52093ca323900d9d4ddd7_720w.jpg",[],{"type":14,"tag":15,"props":4444,"children":4445},{},[4446],{"type":19,"value":4447},"以上和以下代码是完全等同的",{"type":14,"tag":419,"props":4449,"children":4452},{"className":4450,"code":4451,"language":424,"meta":7},[422],"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\n//[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public Entity magic;\n}\n\npublic class MyDataAuthoring : MonoBehaviour, IDeclareReferencedPrefabs, IConvertGameObjectToEntity\n{\n    public GameObject magic;\n    \n    public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(magic);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity primaryEntityOfDeclaredPrefab = conversionSystem.GetPrimaryEntity(magic);\n        dstManager.AddComponentData\u003CMyData>(entity, new MyData\n        {\n            magic = primaryEntityOfDeclaredPrefab\n        });\n    }\n}\n",[4453],{"type":14,"tag":83,"props":4454,"children":4455},{"__ignoreMap":7},[4456],{"type":19,"value":4451},{"type":14,"tag":15,"props":4458,"children":4459},{},[4460],{"type":19,"value":4461},"当然, 你可以正常混搭Entity或float字段在一起.",{"type":14,"tag":46,"props":4463,"children":4465},{"id":4464},"混用converttoentity的-destroy-和-inject-模式",[4466],{"type":19,"value":4467},"混用ConvertToEntity的 destroy 和 inject 模式",{"type":14,"tag":15,"props":4469,"children":4470},{},[4471],{"type":19,"value":4472},"inject 模式会产生太多的 component objectes, 而且也不能访问整个层级树. 同样的, destroy 模式也不能清晰完整地转换整个层级到 ECS 中去. 你可能会想要介于二者之间部分地\"inject\". \"stop\" 组件并没有满足需求 (因为你并不是要跳过转换).",{"type":14,"tag":15,"props":4474,"children":4475},{},[4476],{"type":19,"value":4477},"举个例子, 如果我用Transform,MeshFilter, 和MeshRenderer建造一个飞船, ConvertToEntity 在 destroy 模式下会被转换成LocalToWorld+RenderMesh",{"type":14,"tag":15,"props":4479,"children":4480},{},[4481],{"type":14,"tag":55,"props":4482,"children":4484},{"alt":55,"src":4483},"/images/2020-10-19-game-object-conversion-and-subscene/v2-64c6e9c8dcf9a4cbd9b6565c3308d9cf_720w.jpg",[],{"type":14,"tag":15,"props":4486,"children":4487},{},[4488],{"type":14,"tag":55,"props":4489,"children":4491},{"alt":55,"src":4490},"/images/2020-10-19-game-object-conversion-and-subscene/v2-c65c039ba549ed6676f01af4d00dd49c_720w.jpg",[],{"type":14,"tag":15,"props":4493,"children":4494},{},[4495],{"type":19,"value":4496},"之前我们的 bouncing system 对 Cube和 Translation有效, 如果添加Cube到飞船的根对象上, 应该也能工作. 当然我们可以继续使用魔法生成代码:",{"type":14,"tag":419,"props":4498,"children":4501},{"className":4499,"code":4500,"language":424,"meta":7},[422]," using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct Cube : IComponentData\n{\n}\n",[4502],{"type":14,"tag":83,"props":4503,"children":4504},{"__ignoreMap":7},[4505],{"type":19,"value":4500},{"type":14,"tag":15,"props":4507,"children":4508},{},[4509],{"type":14,"tag":55,"props":4510,"children":4512},{"alt":55,"src":4511},"/images/2020-10-19-game-object-conversion-and-subscene/v2-ead555ad6345028ebcfebc0546bbb150_b.jpg",[],{"type":14,"tag":15,"props":4514,"children":4515},{},[4516],{"type":19,"value":4517},"如果我们在排气孔位置增加一个粒子效果对象, 我想要的结果粒子随着飞船能上下弹跳:",{"type":14,"tag":15,"props":4519,"children":4520},{},[4521],{"type":14,"tag":55,"props":4522,"children":4524},{"alt":55,"src":4523},"/images/2020-10-19-game-object-conversion-and-subscene/v2-cc2adc78e27b72b13f67732d1cbab225_720w.jpg",[],{"type":14,"tag":15,"props":4526,"children":4527},{},[4528],{"type":19,"value":4529},"destroy 模式下, 当 ParticleSystem 这个 component object 进入 conversion world 后, 最终是会被销毁的.",{"type":14,"tag":15,"props":4531,"children":4532},{},[4533],{"type":19,"value":4534},"如果我添加 ConvertToEntity (Stop) 给它, 那么该对象会变成完全和 ECS 无关的东西.",{"type":14,"tag":15,"props":4536,"children":4537},{},[4538],{"type":19,"value":4539},"那么如果在 destroy 模式里面的子对象上添加 inject 模式呢? 这样做我确实会得到一个包含 ParticleSystem的 Entity . 但它是否和 destroy模式转换的飞船能关联起来呢?",{"type":14,"tag":15,"props":4541,"children":4542},{},[4543],{"type":14,"tag":55,"props":4544,"children":4546},{"alt":55,"src":4545},"/images/2020-10-19-game-object-conversion-and-subscene/v2-3c54d97e347fd5a0a340eba132b883bb_720w.jpg",[],{"type":14,"tag":15,"props":4548,"children":4549},{},[4550],{"type":19,"value":4551},"结果并不如我们所期望那样:",{"type":14,"tag":15,"props":4553,"children":4554},{},[4555],{"type":14,"tag":55,"props":4556,"children":4558},{"alt":55,"src":4557},"/images/2020-10-19-game-object-conversion-and-subscene/v2-291facdfb1aa6949c491128d172ea9ef_b.jpg",[],{"type":14,"tag":15,"props":4560,"children":4561},{},[4562],{"type":19,"value":4563},"但从 Entity Debugger 中我们可以看到, 这个对象确实是有destroy 模式下转换后的Parent和LocalToParent , 同时也有inject 模式下添加的ParticleSystem这个 component object. 你现在已经实现混用两种模式了!",{"type":14,"tag":15,"props":4565,"children":4566},{},[4567],{"type":14,"tag":55,"props":4568,"children":4570},{"alt":55,"src":4569},"/images/2020-10-19-game-object-conversion-and-subscene/v2-5e0a38c25b41d2feb69bbfcff52db36c_720w.jpg",[],{"type":14,"tag":15,"props":4572,"children":4573},{},[4574],{"type":19,"value":4575},"就我们目前所知, Parent会帮助我们计算最终的 LocalToWorld , 但是粒子没有上下弹跳是因为没有什么其他系统在使用它的LocalToWorld, 所以我们可以将它的值复制回原Transform 组件, 这可以通过copy transform to game object proxy 组件来实现, 这个组件同时也需要你添加 GameObjectEntity :",{"type":14,"tag":15,"props":4577,"children":4578},{},[4579],{"type":14,"tag":55,"props":4580,"children":4582},{"alt":55,"src":4581},"/images/2020-10-19-game-object-conversion-and-subscene/v2-a9447ea8f2906a1127dd652ceb9a313f_b.jpg",[],{"type":14,"tag":15,"props":4584,"children":4585},{},[4586,4588,4593],{"type":19,"value":4587},"注意如果飞船以 prefab asset 形式被实例化, 那么结果将会像仅使用了 destroy 模式, 也即这里的 ",{"type":14,"tag":75,"props":4589,"children":4590},{},[4591],{"type":19,"value":4592},"particle system 会缺失",{"type":19,"value":168},{"type":14,"tag":46,"props":4595,"children":4597},{"id":4596},"companion-game-object",[4598],{"type":19,"value":4599},"Companion Game Object",{"type":14,"tag":15,"props":4601,"children":4602},{},[4603],{"type":19,"value":4604},"前文所述的方案听起来像是 hack. Particle System 依然存在于 Hierachy 中, 像是它被\"胶粘\"在被转换后的 Entity 上进行移动.",{"type":14,"tag":15,"props":4606,"children":4607},{},[4608,4610,4615],{"type":19,"value":4609},"Companion game object 是一种更加\"干净\"的混合转换方式, 它会创建一个新的 game object 来**\"伴随\"(companion)",{"type":14,"tag":75,"props":4611,"children":4612},{},[4613],{"type":19,"value":4614},"被转换的数据, 并用它来选择你想保留的组件. 这让它",{"type":19,"value":4616},"看起来像**是被完美 conversion 了.",{"type":14,"tag":15,"props":4618,"children":4619},{},[4620],{"type":19,"value":4621},"我们使用 mapping system 来实现该模式. 如下代码所示, 我没有增加太多非 ECS 内容, 只不过修改了一下转换相关的代码:",{"type":14,"tag":419,"props":4623,"children":4626},{"className":4624,"code":4625,"language":424,"meta":7},[422],"using Unity.Entities;\nusing UnityEngine;\n\npublic class Ship : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public ParticleSystem particleCompanion;\n    public ParticleSystemRenderer rendererCompanion;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.AddHybridComponent(particleCompanion);\n        conversionSystem.AddHybridComponent(rendererCompanion);\n    }\n}\n",[4627],{"type":14,"tag":83,"props":4628,"children":4629},{"__ignoreMap":7},[4630],{"type":19,"value":4625},{"type":14,"tag":15,"props":4632,"children":4633},{},[4634,4636,4641],{"type":19,"value":4635},"虽然这模式的名称叫 companion game object, 但你需要配置的其实是",{"type":14,"tag":75,"props":4637,"children":4638},{},[4639],{"type":19,"value":4640},"components.",{"type":19,"value":4642}," AddHybridComponent 调用不仅指定了哪个GameObject应该\"伴随\", 同时也指定哪些组件会被保留.(primary entity 是按照组件来识别的). 因此我定义了组件的 public 字段而不是 GameObject字段.",{"type":14,"tag":15,"props":4644,"children":4645},{},[4646],{"type":19,"value":4647},"在下面这个 ParticleSystem 的例子里, 还隐含着一个 ParticleSystemRenderer, 如果缺失了 renderer, 那么最终的 companion game object 里就只有ParticleSystem 从而导致不会渲染结果. (但是 CPU 依然会运行粒子模拟)",{"type":14,"tag":15,"props":4649,"children":4650},{},[4651],{"type":14,"tag":55,"props":4652,"children":4654},{"alt":55,"src":4653},"/images/2020-10-19-game-object-conversion-and-subscene/v2-7fdcefe0ddf7884e12d264419ca52a92_720w.jpg",[],{"type":14,"tag":15,"props":4656,"children":4657},{},[4658],{"type":19,"value":4659},"可以看到, 之前那些 Hack 的内容现在全都不在了! (去掉了ConvertToEntity inject 模式, 去掉了 copy proxy, 去掉了 GameObjectEntity), 现在conversion 完全正常工作!",{"type":14,"tag":15,"props":4661,"children":4662},{},[4663],{"type":14,"tag":55,"props":4664,"children":4666},{"alt":55,"src":4665},"/images/2020-10-19-game-object-conversion-and-subscene/v2-9654b7da425abca92137e2cd44ff6e70_b.jpg",[],{"type":14,"tag":15,"props":4668,"children":4669},{},[4670],{"type":19,"value":4671},"可以看到现在 Hierarchy 窗口里没有 Particle System 了, 但在 Game view 窗口却正常显示着, 所以它是哪里来的?",{"type":14,"tag":15,"props":4673,"children":4674},{},[4675],{"type":19,"value":4676},"先来看看它对应的 primary entity 的 conversion 结果:",{"type":14,"tag":15,"props":4678,"children":4679},{},[4680],{"type":14,"tag":55,"props":4681,"children":4683},{"alt":55,"src":4682},"/images/2020-10-19-game-object-conversion-and-subscene/v2-2bc082bdb4447fc2ed9e59a18799f81f_720w.jpg",[],{"type":14,"tag":15,"props":4685,"children":4686},{},[4687],{"type":19,"value":4688},"调用AddHybridComponent方法让 companion 相关的组件自动添加到了GameObject的 primary entity (也即 Particle System entity) 上, 同时也加上了指定的ParticleSystem和ParticleSystemRenderer.",{"type":14,"tag":15,"props":4690,"children":4691},{},[4692],{"type":19,"value":4693},"其实这些 component object 仍然关联到 scene 中的对象, 只不过这些对象使用了HideFlags.HideInHierarchy 来隐藏自己. 而CompanionLink组件则指向了这个隐藏对象, 接下来 CompanionGameObjectUpdateTransformSystem 则负责将 transform 复制到 game object 当中.",{"type":14,"tag":15,"props":4695,"children":4696},{},[4697],{"type":19,"value":4698},"和我们上面的 hack 几乎是一致的过程, 但是更加简洁和官方, 和 conversion system 的衔接也更加无缝.",{"type":14,"tag":15,"props":4700,"children":4701},{},[4702],{"type":14,"tag":75,"props":4703,"children":4704},{},[4705],{"type":19,"value":4706},"同时也兼容 prefab !",{"type":14,"tag":15,"props":4708,"children":4709},{},[4710,4712],{"type":19,"value":4711},"Companion 的另一个好处是, 它完全支持 Prefab 转换流程, 并能",{"type":14,"tag":75,"props":4713,"children":4714},{},[4715],{"type":19,"value":4716},"正常地实例化.",{"type":14,"tag":15,"props":4718,"children":4719},{},[4720],{"type":19,"value":4721},"这意味着每次实例化时, 从 MeshFilter和MeshRenderer 中得到RenderMesh会被高效地处理, 而遇到 CompanionLink指定的 component object 则创建有HideFlag的 game object. 并关联好相应的 Entity",{"type":14,"tag":15,"props":4723,"children":4724},{},[4725],{"type":19,"value":4726},"基本上, 这感觉就和 EntityManager.Instantiate 一样, 完美地实现了 ECS 版本的ParticleSystem.",{"type":14,"tag":15,"props":4728,"children":4729},{},[4730],{"type":19,"value":4731},"具体来说, 我们将飞船先变成一个 prefab asset. 然后在 Ship 组件正常引用子对象里的组件即可.",{"type":14,"tag":15,"props":4733,"children":4734},{},[4735],{"type":14,"tag":55,"props":4736,"children":4738},{"alt":55,"src":4737},"/images/2020-10-19-game-object-conversion-and-subscene/v2-393b0c8128a558d1a8cf9825bb89a609_720w.jpg",[],{"type":14,"tag":15,"props":4740,"children":4741},{},[4742],{"type":19,"value":4743},"我继续使用前面说到的魔法:",{"type":14,"tag":419,"props":4745,"children":4748},{"className":4746,"code":4747,"language":424,"meta":7},[422],"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct ShipAndCo : IComponentData\n{\n    public Entity shipPrefab;\n}\n",[4749],{"type":14,"tag":83,"props":4750,"children":4751},{"__ignoreMap":7},[4752],{"type":19,"value":4747},{"type":14,"tag":15,"props":4754,"children":4755},{},[4756],{"type":14,"tag":55,"props":4757,"children":4759},{"alt":55,"src":4758},"/images/2020-10-19-game-object-conversion-and-subscene/v2-c25ff43a9da4a6adce9ec3ae6f5d6d89_720w.jpg",[],{"type":14,"tag":15,"props":4761,"children":4762},{},[4763],{"type":19,"value":4764},"进入 play mode 时, 我已经在 ShipAndCo上拥有一个 就绪的Prefabentity了, 由于我知道ShipAndCo是一个 singleton, 我们用如下系统来玩一玩: 每次我按下 A 键, 在0~10之间的随机位置上实例化该 Entity.",{"type":14,"tag":419,"props":4766,"children":4769},{"className":4767,"code":4768,"language":424,"meta":7},[422],"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Transforms;\nusing UnityEngine;\nusing Random = Unity.Mathematics.Random;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class ShipAndCoSpawnerSystem : JobComponentSystem\n{\n    Random randomizer;\n\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        RequireSingletonForUpdate\u003CShipAndCo>();\n        randomizer = new Random();\n        randomizer.InitState(seed: 12345);\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        if (Input.GetKeyDown(KeyCode.A))\n        {\n            var sac = GetSingleton\u003CShipAndCo>();\n            Entity prefabEntity = sac.shipPrefab;\n            Entity instantiated = EntityManager.Instantiate(prefabEntity);\n            EntityManager.SetComponentData\u003CTranslation>(instantiated, new Translation\n            {\n                Value = randomizer.NextFloat3() * 10\n            });\n        }\n\n        return default;\n    }\n}\n",[4770],{"type":14,"tag":83,"props":4771,"children":4772},{"__ignoreMap":7},[4773],{"type":19,"value":4768},{"type":14,"tag":15,"props":4775,"children":4776},{},[4777],{"type":19,"value":4778},"我得到了一个正常支持 Entity 实例化的 companion particle systems, 很酷吧:",{"type":14,"tag":15,"props":4780,"children":4781},{},[4782],{"type":14,"tag":55,"props":4783,"children":4785},{"alt":55,"src":4784},"/images/2020-10-19-game-object-conversion-and-subscene/v2-97834b5340ef86b4326a2390efef9da6_b.jpg",[],{"type":14,"tag":15,"props":4787,"children":4788},{},[4789],{"type":19,"value":4790},"截止到这里, companion game object 可以说是 conversion 过程的最后一块拼图了.",{"type":14,"tag":46,"props":4792,"children":4794},{"id":4793},"gameobjectconversionutility",[4795],{"type":19,"value":4796},"GameObjectConversionUtility",{"type":14,"tag":15,"props":4798,"children":4799},{},[4800],{"type":19,"value":4801},"如果前述的 convert and destroy 或者 convert and inject 规则你都不喜欢, 你完全可以使用下述static方法自行 convert.",{"type":14,"tag":419,"props":4803,"children":4806},{"className":4804,"code":4805,"language":424,"meta":7},[422],"public static Entity ConvertGameObjectHierarchy(GameObject root, GameObjectConversionSettings settings)\n",[4807],{"type":14,"tag":83,"props":4808,"children":4809},{"__ignoreMap":7},[4810],{"type":19,"value":4805},{"type":14,"tag":15,"props":4812,"children":4813},{},[4814,4816,4821],{"type":19,"value":4815},"但你得先拿到 GameObject才行. ConvertToEntity之所以方便是因为你添加时就选择了该对象, 另外还有它的子层级(根据模式的不同). 而现在你只能传入",{"type":14,"tag":75,"props":4817,"children":4818},{},[4819],{"type":19,"value":4820},"一个",{"type":19,"value":4822},"GameObject 参数到这个方法中.",{"type":14,"tag":15,"props":4824,"children":4825},{},[4826],{"type":19,"value":4827},"root 自然是你想要 convert 的对象, 方法名字有 \"hierarchy\", 它知道如何处理这些情况:",{"type":14,"tag":815,"props":4829,"children":4830},{},[4831,4836],{"type":14,"tag":819,"props":4832,"children":4833},{},[4834],{"type":19,"value":4835},"如果root 是 prefab asset, 那么你得到的结果和前述在 conversion 中声明 prefab 的结果一样. 如果你不喜欢声明和创建 prefab entity 绑定在一起, 那么你可以一个一个来.",{"type":14,"tag":819,"props":4837,"children":4838},{},[4839],{"type":19,"value":4840},"如果root 是 scene 中的对象, 它会和ConvertToEntity的工作模式类似, 要注意这个方法同时也会执行LinkedEntityGroup过程.",{"type":14,"tag":15,"props":4842,"children":4843},{},[4844],{"type":19,"value":4845},"settings可以通过 destination world 来获得:",{"type":14,"tag":419,"props":4847,"children":4850},{"className":4848,"code":4849,"language":424,"meta":7},[422]," public static GameObjectConversionSettings FromWorld(World destinationWorld, BlobAssetStore blobAssetStore)\n",[4851],{"type":14,"tag":83,"props":4852,"children":4853},{"__ignoreMap":7},[4854],{"type":19,"value":4849},{"type":14,"tag":15,"props":4856,"children":4857},{},[4858],{"type":19,"value":4859},"如非特殊, Destination world 通常是 World.DefaultGameObjectInjectionWorld. ConvertToEntity就会在内部默认使用该值.",{"type":14,"tag":15,"props":4861,"children":4862},{},[4863],{"type":19,"value":4864},"BlobAssetStore我猜测是当你需要产生某些有BlobAssetReference字段的component时需要用到的东西, 目前你可以传入 null 或者 new BlobAssetStore , 但是记得要Dispose.",{"type":14,"tag":15,"props":4866,"children":4867},{},[4868],{"type":14,"tag":75,"props":4869,"children":4870},{},[4871],{"type":19,"value":4872},"GameObjectConversionUtility 其他有趣的方法",{"type":14,"tag":419,"props":4874,"children":4877},{"className":4875,"code":4876,"language":424,"meta":7},[422],"public static void ConvertScene(Scene scene, GameObjectConversionSettings settings)\n",[4878],{"type":14,"tag":83,"props":4879,"children":4880},{"__ignoreMap":7},[4881],{"type":19,"value":4876},{"type":14,"tag":15,"props":4883,"children":4884},{},[4885],{"type":19,"value":4886},"和ConvertGameObjectHierarchy几乎一样, 只不过针对的是 scene 中所有的东西. 它不会添加LinkedEntityGroupbuffer, 除非scene中有被禁用的对象. (禁用行为参考前文).",{"type":14,"tag":15,"props":4888,"children":4889},{},[4890],{"type":19,"value":4891},"这个方法比给每个 scene 对象都加上ConvertToEntity 要高级一些, 后者你无法得到disabled entity 作为结果. 有 ConvertToEntity且被禁用的GameObject 的 Awake 方法不会被调用, 也就完全不会有 conversion 过程.",{"type":14,"tag":419,"props":4893,"children":4896},{"className":4894,"code":4895,"language":424,"meta":7},[422],"public static World ConvertIncrementalInitialize(Scene scene, GameObjectConversionSettings settings)\npublic static void ConvertIncremental(World conversionWorld, IEnumerable\u003CGameObject> gameObjects, ConversionFlags flags)\n",[4897],{"type":14,"tag":83,"props":4898,"children":4899},{"__ignoreMap":7},[4900],{"type":19,"value":4895},{"type":14,"tag":15,"props":4902,"children":4903},{},[4904],{"type":19,"value":4905},"这两个方法是什么? 第一个返回 World, 看起来像是 scene 中的内容可能会变化, 你可以用还未销毁的 conversion world 增量地 convert scene中新增的内容.",{"type":14,"tag":15,"props":4907,"children":4908},{},[4909],{"type":19,"value":4910},"这两个方法在 live link 系统中有被用到, 后文会解释.",{"type":14,"tag":46,"props":4912,"children":4914},{"id":4913},"subscene",[4915],{"type":14,"tag":75,"props":4916,"children":4917},{},[4918],{"type":19,"value":4919},"Subscene",{"type":14,"tag":15,"props":4921,"children":4922},{},[4923],{"type":19,"value":4924},"因为 subscene 还处于开发中, 用法随时可能改变, 所以我计划先写到这里, 不过我会大致解释一下, 然后等 entities package 正式发布.",{"type":14,"tag":15,"props":4926,"children":4927},{},[4928],{"type":19,"value":4929},"现在你已经可以使用 GameObject 来编辑游戏, 在 ECS 的环境里运行了, 那么还缺点啥?",{"type":14,"tag":815,"props":4931,"children":4932},{},[4933,4945,4950,4962,4967],{"type":14,"tag":819,"props":4934,"children":4935},{},[4936,4938,4943],{"type":19,"value":4937},"你可能想要在",{"type":14,"tag":75,"props":4939,"children":4940},{},[4941],{"type":19,"value":4942},"编辑模式",{"type":19,"value":4944},"时查看 conversion 的结果, 无论你多么小心地设计 conversion 过程都有可能出错.",{"type":14,"tag":819,"props":4946,"children":4947},{},[4948],{"type":19,"value":4949},"你太懒了, 不想复制粘贴ConvertToEntity, 或者使用 utility 里的 Scene 方法.",{"type":14,"tag":819,"props":4951,"children":4952},{},[4953,4955,4960],{"type":19,"value":4954},"你想在发布游戏时, 游戏能预先转换好(",{"type":14,"tag":75,"props":4956,"children":4957},{},[4958],{"type":19,"value":4959},"pre-converted",{"type":19,"value":4961},"). 当加载 scene 时你就可以不用再重新运行转换过程, 而是加载 chunk 内存直接使用.",{"type":14,"tag":819,"props":4963,"children":4964},{},[4965],{"type":19,"value":4966},"你懒得点\"序列化 ECS 内存\" 按钮来保存play mode下的内存供运行时使用, 更懒得添加内存加载的代码.",{"type":14,"tag":819,"props":4968,"children":4969},{},[4970],{"type":19,"value":4971},"在 play mode 时, 你不想让这些 pure Entity 从 Hierarchy 窗口消失. (当然你也不想使用 inject 模式来实现, 这会导致重复绘制对象的问题). 在 inspector 快速查看和修改运行时的对象非常有用.",{"type":14,"tag":15,"props":4973,"children":4974},{},[4975],{"type":14,"tag":55,"props":4976,"children":4978},{"alt":55,"src":4977},"/images/2020-10-19-game-object-conversion-and-subscene/v2-c924c16e23d2b941e4058ae2a720f115_b.jpg",[],{"type":14,"tag":815,"props":4980,"children":4981},{},[4982],{"type":14,"tag":819,"props":4983,"children":4984},{},[4985],{"type":19,"value":4986},"你可能想要一边修改内容, 一边实时 convert 这些数据. (比如调整Transform后里面更新到 LocalToWorld/Translation)",{"type":14,"tag":15,"props":4988,"children":4989},{},[4990],{"type":19,"value":4991},"好消息是, 以上内容在 Subscene 里都是可行的! subscene 并不是比scene \"少\" 些东西, 而是被设计为可以嵌套进普通 scene 中的工具. 它的能力甚至比普通的 scene 要更强.",{"type":14,"tag":15,"props":4993,"children":4994},{},[4995],{"type":19,"value":4996},"让我们开始吧, 先创建一个 GameObject并添加Subscenecomponent. 这时候你会被告知需要添加一个新的 Scene asset 用来存放 subscene 的内容.",{"type":14,"tag":15,"props":4998,"children":4999},{},[5000],{"type":14,"tag":55,"props":5001,"children":5003},{"alt":55,"src":5002},"/images/2020-10-19-game-object-conversion-and-subscene/v2-6d07337664d2fd541b8d1742f070e5e2_720w.jpg",[],{"type":14,"tag":15,"props":5005,"children":5006},{},[5007],{"type":19,"value":5008},"你可以点击 \"Edit\" 来添加内容, 或者双击 scene asset 来打开 scene 进行修改 (这和常规的 scene 操作是一样的). 这里我添加了 2 个cube GameObject , 不过我不再需要ConvertToEntity了, scene 中的所有内容偶会被自动 convert (甚至还会警告你把已经没用的 ConvertToEntity 删掉).",{"type":14,"tag":15,"props":5010,"children":5011},{},[5012],{"type":14,"tag":55,"props":5013,"children":5015},{"alt":55,"src":5014},"/images/2020-10-19-game-object-conversion-and-subscene/v2-cf47b079fde25956965c75cfafd062e8_720w.jpg",[],{"type":14,"tag":15,"props":5017,"children":5018},{},[5019],{"type":14,"tag":55,"props":5020,"children":5022},{"alt":55,"src":5021},"/images/2020-10-19-game-object-conversion-and-subscene/v2-6ca9f8540a1bf57028c0878103a3d4d6_720w.jpg",[],{"type":14,"tag":15,"props":5024,"children":5025},{},[5026],{"type":19,"value":5027},"现在当你进入 play mode, 两个\"世界\"的好处都能获得. Hybrid Renderer负责渲染, tris 数量正常, 没有重复的对象出现.",{"type":14,"tag":15,"props":5029,"children":5030},{},[5031],{"type":14,"tag":55,"props":5032,"children":5034},{"alt":55,"src":5033},"/images/2020-10-19-game-object-conversion-and-subscene/v2-b1487642fdc3ba9a7ab3fc3698c1d27b_720w.jpg",[],{"type":14,"tag":15,"props":5036,"children":5037},{},[5038,5040,5045,5047,5051],{"type":19,"value":5039},"而且, 它们是",{"type":14,"tag":75,"props":5041,"children":5042},{},[5043],{"type":19,"value":5044},"可被选中",{"type":19,"value":5046},"的. 这意味着尽管已经被convert 并 ",{"type":14,"tag":75,"props":5048,"children":5049},{},[5050],{"type":19,"value":1164},{"type":19,"value":5052}," 了, 但不知为何点击 Hierarchy 的对象依然可以选中转换前的状态.",{"type":14,"tag":15,"props":5054,"children":5055},{},[5056],{"type":19,"value":5057},"相应地, 如果你点击 scene view 你也可以选中 Hierarchy 中的对象!",{"type":14,"tag":15,"props":5059,"children":5060},{},[5061],{"type":19,"value":5062},"你可能注意到上图中橙色的轮廓线不见了, 这时因为我开启了下面的选项:",{"type":14,"tag":15,"props":5064,"children":5065},{},[5066],{"type":14,"tag":55,"props":5067,"children":5069},{"alt":55,"src":5068},"/images/2020-10-19-game-object-conversion-and-subscene/v2-720ebb51d4072e9b804c87a57b1bf758_720w.jpg",[],{"type":14,"tag":15,"props":5071,"children":5072},{},[5073,5078],{"type":14,"tag":75,"props":5074,"children":5075},{},[5076],{"type":19,"value":5077},"SceneView : Live Game State",{"type":19,"value":5079}," 意思是让 scene view 里面显示已经 convert 过的内容. 因此这时候 scene view 在使用 Hybrid Renderer 来渲染结果, 也无法显示那些橙色的轮廓线.",{"type":14,"tag":15,"props":5081,"children":5082},{},[5083,5088],{"type":14,"tag":75,"props":5084,"children":5085},{},[5086],{"type":19,"value":5087},"SceneView: Editing State",{"type":19,"value":5089}," 则是让 scene view 在 play mode 时依然保持在 edit mode 时的状态, 这时候橙色轮廓线就能够显示了. 当然 cube 依然和 MeshFilter+MeshRenderer=RenderMesh设计地那样一样绘制. 但是如果 conversion 过程中将cube 染成了绿色, scene view 中将无法感知这一修改, cube 依然呈灰色.",{"type":14,"tag":15,"props":5091,"children":5092},{},[5093],{"type":14,"tag":55,"props":5094,"children":5096},{"alt":55,"src":5095},"/images/2020-10-19-game-object-conversion-and-subscene/v2-a1038be6c110edc989089a85047257eb_720w.jpg",[],{"type":14,"tag":15,"props":5098,"children":5099},{},[5100,5102,5107,5109,5114,5116,5120],{"type":19,"value":5101},"最上面的 ",{"type":14,"tag":75,"props":5103,"children":5104},{},[5105],{"type":19,"value":5106},"Live Conversion in Edit Mode",{"type":19,"value":5108}," 指示在 edit mode 时的行为, 你可以选中它然后在 edit mode 看到 convert 的状态. ",{"type":14,"tag":75,"props":5110,"children":5111},{},[5112],{"type":19,"value":5113},"SceneView: Live Game State",{"type":19,"value":5115}," 开启而 ",{"type":14,"tag":75,"props":5117,"children":5118},{},[5119],{"type":19,"value":5106},{"type":19,"value":5121}," 保持禁用这种情况没什么用, 因为你本想要在scene view + edit mode 查看实时的游戏状态, 而同时你又禁止它这样做.",{"type":14,"tag":15,"props":5123,"children":5124},{},[5125,5127],{"type":19,"value":5126},"如果你在 play mode 时移动 scene 中的 Transform (很可能因为 subscene 用预先转换的状态保持了 Hierarchy 的完整), 则会通过增量地重新转换(reconverted, diff-ed)无缝地更新到新状态, 这套机制就是 ",{"type":14,"tag":75,"props":5128,"children":5129},{},[5130],{"type":19,"value":5131},"live link.",{"type":14,"tag":15,"props":5133,"children":5134},{},[5135],{"type":14,"tag":75,"props":5136,"children":5137},{},[5138],{"type":19,"value":5139},"比较 ConvertToEntity 和 Subscene",{"type":14,"tag":15,"props":5141,"children":5142},{},[5143],{"type":14,"tag":55,"props":5144,"children":5146},{"alt":55,"src":5145},"/images/2020-10-19-game-object-conversion-and-subscene/v2-00f0364648daf575b2595c3583779473_720w.jpg",[],{"type":14,"tag":15,"props":5148,"children":5149},{},[5150],{"type":19,"value":5151},"下面两图中, 前者是通过 Subscene 进行转换, 后者则通过ConvertToEntity. 两者都是 destroy 模式, 所以MeshFilter这样的 component object 会被销毁:",{"type":14,"tag":15,"props":5153,"children":5154},{},[5155,5159],{"type":14,"tag":55,"props":5156,"children":5158},{"alt":55,"src":5157},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f669be4df96944af4b995954d229e5b7_720w.jpg",[],{"type":19,"value":5160},"Subscene, 上方是 CubeInside, 下方是 Cube",{"type":14,"tag":15,"props":5162,"children":5163},{},[5164,5168],{"type":14,"tag":55,"props":5165,"children":5167},{"alt":55,"src":5166},"/images/2020-10-19-game-object-conversion-and-subscene/v2-a1d3fdd0f7bf0aa49578990dc5109b99_720w.jpg",[],{"type":19,"value":5169},"ConvertToEntity, 上下同理",{"type":14,"tag":15,"props":5171,"children":5172},{},[5173],{"type":19,"value":5174},"EditorRenderData,EntityGuid,SceneSection,SceneTag是这里最大的区别. 除了EntityGuid, 其他三者都是 ISharedComponentData. 所以基本不用操心 chunk 碎片的问题, 基本上所有 subscene 里的对象都会得到同样的结果.",{"type":14,"tag":15,"props":5176,"children":5177},{},[5178],{"type":19,"value":5179},"ConvertToEntity或 subscene 都不会为层级结构添加LinkedEntityGroupbuffer, 但是因为 subscene 与 ConvertScene 方法的规则相同, 因此如果有被 disabled 的对象时, 它会添加LinkedEntityGroup.",{"type":14,"tag":15,"props":5181,"children":5182},{},[5183],{"type":14,"tag":55,"props":5184,"children":5186},{"alt":55,"src":5185},"/images/2020-10-19-game-object-conversion-and-subscene/v2-fa31f3d1c34e5328ea654b88792039bd_720w.jpg",[],{"type":14,"tag":15,"props":5188,"children":5189},{},[5190],{"type":14,"tag":75,"props":5191,"children":5192},{},[5193],{"type":19,"value":5194},"不是一次 conversion, 而是一个 scene!",{"type":14,"tag":15,"props":5196,"children":5197},{},[5198],{"type":19,"value":5199},"Unity 并不希望传达出\"subscene 是一堆ConvertToEntity的结果\"这样的观念, 这是一个真正的 scene.",{"type":14,"tag":15,"props":5201,"children":5202},{},[5203],{"type":19,"value":5204},"包括在调用SceneManager.LoadScene 时. 下面的例子中, GO 有一个ConvertToEntity, InSubScene1什么都没有但是位于 subscene 中:",{"type":14,"tag":15,"props":5206,"children":5207},{},[5208],{"type":14,"tag":55,"props":5209,"children":5211},{"alt":55,"src":5210},"/images/2020-10-19-game-object-conversion-and-subscene/v2-d03443f3982058272989d61a6fda8259_720w.jpg",[],{"type":14,"tag":15,"props":5213,"children":5214},{},[5215],{"type":19,"value":5216},"当进入 play mode 时, 两者都按照期望被转换了, Subscene 和ConvertToEntity 这时是等价的.",{"type":14,"tag":15,"props":5218,"children":5219},{},[5220],{"type":14,"tag":55,"props":5221,"children":5223},{"alt":55,"src":5222},"/images/2020-10-19-game-object-conversion-and-subscene/v2-0dd4504f76658d822b0c78eee4606300_720w.jpg",[],{"type":14,"tag":15,"props":5225,"children":5226},{},[5227],{"type":19,"value":5228},"但如果我们 SceneManager.LoadScene 改变当前的 scene:",{"type":14,"tag":15,"props":5230,"children":5231},{},[5232],{"type":14,"tag":55,"props":5233,"children":5235},{"alt":55,"src":5234},"/images/2020-10-19-game-object-conversion-and-subscene/v2-f26e95d0237f8cfb9753c38397a681d8_720w.jpg",[],{"type":14,"tag":15,"props":5237,"children":5238},{},[5239],{"type":19,"value":5240},"可以看到 subscene 里的 entity 同样被删除了, 但是正如ConvertToEntity名字所隐含的意义, 转换后就和 scene 没什么关系了, GO 依然存在. 这对于 entity 的生命周期管理很有帮助. ( 在进入 scene 前, 相关 system 无需做无用功)",{"type":14,"tag":15,"props":5242,"children":5243},{},[5244],{"type":19,"value":5245},"我猜想 DeclareDependency 应该对这个功能有所帮助.",{"type":14,"tag":15,"props":5247,"children":5248},{},[5249],{"type":14,"tag":55,"props":5250,"children":5252},{"alt":55,"src":5251},"/images/2020-10-19-game-object-conversion-and-subscene/v2-36bbe1659c6b2da765b54421090f2319_720w.jpg",[],{"title":7,"searchDepth":5254,"depth":5254,"links":5255},2,[5256,5257,5258,5259,5260,5261,5262,5263,5264,5265,5266,5267,5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281,5282,5283,5284,5285,5286,5287],{"id":48,"depth":5254,"text":48},{"id":123,"depth":5254,"text":126},{"id":247,"depth":5254,"text":250},{"id":384,"depth":5254,"text":384},{"id":515,"depth":5254,"text":518},{"id":684,"depth":5254,"text":684},{"id":753,"depth":5254,"text":756},{"id":949,"depth":5254,"text":952},{"id":1169,"depth":5254,"text":1172},{"id":1329,"depth":5254,"text":1332},{"id":1452,"depth":5254,"text":1455},{"id":1538,"depth":5254,"text":1541},{"id":1852,"depth":5254,"text":1855},{"id":2179,"depth":5254,"text":2182},{"id":2238,"depth":5254,"text":2241},{"id":2414,"depth":5254,"text":2417},{"id":2669,"depth":5254,"text":2672},{"id":2778,"depth":5254,"text":2781},{"id":2967,"depth":5254,"text":2970},{"id":3142,"depth":5254,"text":3145},{"id":3261,"depth":5254,"text":3264},{"id":3427,"depth":5254,"text":3430},{"id":3481,"depth":5254,"text":3484},{"id":3497,"depth":5254,"text":3500},{"id":3525,"depth":5254,"text":3528},{"id":3723,"depth":5254,"text":3726},{"id":4101,"depth":5254,"text":4104},{"id":4328,"depth":5254,"text":4331},{"id":4464,"depth":5254,"text":4467},{"id":4596,"depth":5254,"text":4599},{"id":4793,"depth":5254,"text":4796},{"id":4913,"depth":5254,"text":4919},"markdown","content:unity:2020-10-19-game-object-conversion-and-subscene.md","content","unity/2020-10-19-game-object-conversion-and-subscene.md","md","2020-10-19",[5295,5305,5432,5481,5533,5546,5658],{"title":5296,"_path":5297,"children":5298},"Art","/art",[5299,5302],{"title":5300,"_path":5301},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":5303,"_path":5304},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":5306,"_path":5307,"children":5308},"Dotnet","/dotnet",[5309,5312,5315,5318,5321,5324,5327,5330,5333,5336,5339,5342,5345,5348,5351,5354,5357,5360,5363,5366,5369,5372,5375,5378,5381,5384,5387,5390,5393,5396,5399,5402,5405,5408,5411,5414,5417,5420,5423,5426,5429],{"title":5310,"_path":5311},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":5313,"_path":5314},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":5316,"_path":5317},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":5319,"_path":5320},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":5322,"_path":5323},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":5325,"_path":5326},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":5328,"_path":5329},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":5331,"_path":5332},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":5334,"_path":5335},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":5337,"_path":5338},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":5340,"_path":5341},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":5343,"_path":5344},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":5346,"_path":5347},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":5349,"_path":5350},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":5352,"_path":5353},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":5355,"_path":5356},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":5358,"_path":5359},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":5361,"_path":5362},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":5364,"_path":5365},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":5367,"_path":5368},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":5370,"_path":5371},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":5373,"_path":5374},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":5376,"_path":5377},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":5379,"_path":5380},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":5382,"_path":5383},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":5385,"_path":5386},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":5388,"_path":5389},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":5391,"_path":5392},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":5394,"_path":5395},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":5397,"_path":5398},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":5400,"_path":5401},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":5403,"_path":5404},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":5406,"_path":5407},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":5409,"_path":5410},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":5412,"_path":5413},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":5415,"_path":5416},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":5418,"_path":5419},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":5421,"_path":5422},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":5424,"_path":5425},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":5427,"_path":5428},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":5430,"_path":5431},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":5433,"_path":5434,"children":5435},"Game","/game",[5436,5439,5442,5445,5448,5451,5454,5457,5460,5463,5466,5469,5472,5475,5478],{"title":5437,"_path":5438},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":5440,"_path":5441},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":5443,"_path":5444},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":5446,"_path":5447},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":5449,"_path":5450},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":5452,"_path":5453},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":5455,"_path":5456},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":5458,"_path":5459},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":5461,"_path":5462},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":5464,"_path":5465},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":5467,"_path":5468},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":5470,"_path":5471},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":5473,"_path":5474},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":5476,"_path":5477},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":5479,"_path":5480},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":5482,"_path":5483,"children":5484},"Gyj","/gyj",[5485,5488,5491,5494,5497,5500,5503,5506,5509,5512,5515,5518,5521,5524,5527,5530],{"title":5486,"_path":5487},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":5489,"_path":5490},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":5492,"_path":5493},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":5495,"_path":5496},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":5498,"_path":5499},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":5501,"_path":5502},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":5504,"_path":5505},"玩法","/gyj/2022-08-22-wanfa",{"title":5507,"_path":5508},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":5510,"_path":5511},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":5513,"_path":5514},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":5516,"_path":5517},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":5519,"_path":5520},"门派内容相关","/gyj/2022-11-17-sect",{"title":5522,"_path":5523},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":5525,"_path":5526},"种植","/gyj/2022-12-01-zhongzhi",{"title":5528,"_path":5529},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":5531,"_path":5532},"跑商","/gyj/2023-11-01-paoshang",{"title":5534,"_path":5535,"children":5536},"Js","/js",[5537,5540,5543],{"title":5538,"_path":5539},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":5541,"_path":5542},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":5544,"_path":5545},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":5547,"_path":5548,"children":5549},"Tool","/tool",[5550,5553,5556,5559,5562,5565,5568,5571,5574,5577,5580,5583,5586,5589,5592,5595,5598,5601,5604,5607,5610,5613,5616,5619,5622,5625,5628,5631,5634,5637,5640,5643,5646,5649,5652,5655],{"title":5551,"_path":5552},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":5554,"_path":5555},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":5557,"_path":5558},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":5560,"_path":5561},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":5563,"_path":5564},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":5566,"_path":5567},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":5569,"_path":5570},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":5572,"_path":5573},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":5575,"_path":5576},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":5578,"_path":5579},"mac下brew 使用","/tool/2020-01-13-brew",{"title":5581,"_path":5582},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":5584,"_path":5585},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":5587,"_path":5588},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":5590,"_path":5591},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":5593,"_path":5594},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":5596,"_path":5597},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":5599,"_path":5600},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":5602,"_path":5603},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":5605,"_path":5606},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":5608,"_path":5609},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":5611,"_path":5612},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":5614,"_path":5615},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":5617,"_path":5618},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":5620,"_path":5621},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":5623,"_path":5624},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":5626,"_path":5627},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":5629,"_path":5630},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":5632,"_path":5633},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":5635,"_path":5636},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":5638,"_path":5639},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":5641,"_path":5642},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":5644,"_path":5645},"rider的使用","/tool/2022-08-02-rider-use",{"title":5647,"_path":5648},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":5650,"_path":5651},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":5653,"_path":5654},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":5656,"_path":5657},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":5659,"_path":5660,"children":5661},"Unity","/unity",[5662,5665,5668,5671,5674,5677,5680,5683,5686,5689,5692,5695,5698,5701,5704,5707,5710,5713,5716,5719,5722,5725,5728,5731,5734,5737,5740,5743,5746,5749,5752,5755,5758,5761,5764,5767,5770,5773,5776,5779,5782,5785,5788,5789,5792,5795,5798,5801,5804,5807,5810,5813,5816,5819,5822,5825,5828,5831,5834,5837,5840,5843,5846,5849,5852,5855,5858,5861,5864,5867,5870,5873],{"title":5663,"_path":5664},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":5666,"_path":5667},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":5669,"_path":5670},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":5672,"_path":5673},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":5675,"_path":5676},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":5678,"_path":5679},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":5681,"_path":5682},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":5684,"_path":5685},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":5687,"_path":5688},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":5690,"_path":5691},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":5693,"_path":5694},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":5696,"_path":5697},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":5699,"_path":5700},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":5702,"_path":5703},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":5705,"_path":5706},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":5708,"_path":5709},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":5711,"_path":5712},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":5714,"_path":5715},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":5717,"_path":5718},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":5720,"_path":5721},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":5723,"_path":5724},"技能系统","/unity/2020-02-15-skill-system",{"title":5726,"_path":5727},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":5729,"_path":5730},"角色状态设计","/unity/2020-02-17-character-states",{"title":5732,"_path":5733},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":5735,"_path":5736},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":5738,"_path":5739},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":5741,"_path":5742},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":5744,"_path":5745},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":5747,"_path":5748},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":5750,"_path":5751},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":5753,"_path":5754},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":5756,"_path":5757},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":5759,"_path":5760},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":5762,"_path":5763},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":5765,"_path":5766},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":5768,"_path":5769},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":5771,"_path":5772},"unity的addressables","/unity/2020-09-12-addressables",{"title":5774,"_path":5775},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":5777,"_path":5778},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":5780,"_path":5781},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":5783,"_path":5784},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":5786,"_path":5787},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":8,"_path":4},{"title":5790,"_path":5791},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":5793,"_path":5794},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":5796,"_path":5797},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":5799,"_path":5800},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":5802,"_path":5803},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":5805,"_path":5806},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":5808,"_path":5809},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":5811,"_path":5812},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":5814,"_path":5815},"简单保存工具","/unity/2020-11-13-simple-save",{"title":5817,"_path":5818},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":5820,"_path":5821},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":5823,"_path":5824},"ability","/unity/2020-11-16-dotssample",{"title":5826,"_path":5827},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":5829,"_path":5830},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":5832,"_path":5833},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":5835,"_path":5836},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":5838,"_path":5839},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":5841,"_path":5842},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":5844,"_path":5845},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":5847,"_path":5848},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":5850,"_path":5851},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":5853,"_path":5854},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":5856,"_path":5857},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":5859,"_path":5860},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":5862,"_path":5863},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":5865,"_path":5866},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":5868,"_path":5869},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":5871,"_path":5872},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":5874,"_path":5875},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779039465]