[{"data":1,"prerenderedAt":1501},["Reactive",2],{"content-query-YSz9LPdNFH":3,"content-navigation-8C37fagqQL":919},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":913,"_id":914,"_source":915,"_file":916,"_extension":917,"date":918},"/unity/2020-10-23-unity-optimizing-gpu","unity",false,"","关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","静态批处理[1]定义标明为 Static 的静态物件，如果在使用相同材质球的条件下，在**Build（项目打包）**的时候Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调",{"type":11,"children":12,"toc":901},"root",[13,31,45,58,66,71,78,92,97,111,122,131,142,155,166,173,177,190,200,225,230,235,245,267,278,315,324,334,341,344,350,360,416,431,442,473,482,492,509,519,526,529,542,552,605,614,624,658,667,677,699,709,716,719,731,758,763],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"静态批处理1",[19,22],{"type":20,"value":21},"text","静态批处理[",{"type":14,"tag":23,"props":24,"children":28},"a",{"href":25,"rel":26},"https://zhuanlan.zhihu.com/p/98642798#ref_1",[27],"nofollow",[29],{"type":20,"value":30},"1]",{"type":14,"tag":32,"props":33,"children":34},"ul",{},[35],{"type":14,"tag":36,"props":37,"children":38},"li",{},[39],{"type":14,"tag":40,"props":41,"children":42},"strong",{},[43],{"type":20,"value":44},"定义",{"type":14,"tag":46,"props":47,"children":48},"p",{},[49,51,56],{"type":20,"value":50},"标明为 Static 的静态物件，如果在使用",{"type":14,"tag":40,"props":52,"children":53},{},[54],{"type":20,"value":55},"相同材质球",{"type":20,"value":57},"的条件下，在**Build（项目打包）**的时候Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。",{"type":14,"tag":46,"props":59,"children":60},{},[61],{"type":14,"tag":62,"props":63,"children":65},"img",{"alt":62,"src":64},"/images/2020-10-23-unity-optimizing-gpu/v2-48b948e088a2310817c67c6530637a95_720w.jpg",[],{"type":14,"tag":46,"props":67,"children":68},{},[69],{"type":20,"value":70},"在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次Draw call分别绘制每一个子模型。",{"type":14,"tag":46,"props":72,"children":73},{},[74],{"type":14,"tag":62,"props":75,"children":77},{"alt":62,"src":76},"/images/2020-10-23-unity-optimizing-gpu/v2-9e2e1e5df3ad1b37ebe0dc1af4712005_720w.jpg",[],{"type":14,"tag":46,"props":79,"children":80},{},[81,83,90],{"type":20,"value":82},"Static batching并**不减少Draw call的数量（**但是在编辑器时由于计算方法区别Draw call数量是会显示减少了的[",{"type":14,"tag":23,"props":84,"children":87},{"href":85,"rel":86},"https://zhuanlan.zhihu.com/p/98642798#ref_2",[27],[88],{"type":20,"value":89},"2]",{"type":20,"value":91},"），但是由于我们预先把所有的子模型的顶点变换到了世界空间下，所以在运行时cpu不需要再次执行顶点变换操作，节约了少量的计算资源，并且这些子模型共享材质，所以在多次Draw call调用之间并没有渲染状态的切换，渲染API（Command Buffer）会缓存绘制命令，起到了渲染优化的目的 。",{"type":14,"tag":46,"props":93,"children":94},{},[95],{"type":20,"value":96},"但Static batching也会带来一些性能的负面影响。Static batching会导致应用打包之后体积增大，应用运行时所占用的内存体积也会增大。",{"type":14,"tag":46,"props":98,"children":99},{},[100,102,109],{"type":20,"value":101},"另外，在很多不同的GameObject引用同一模型的情况下，如果不开启Static batching，GameObject共享的模型会在应用程序包内或者内存中只存在一份，绘制的时候提交模型顶点信息，然后设置每一个GameObjec的材质信息，分别调用渲染API绘制。开启Static batching，在Unity执行Build的时候，场景中所有引用相同模型的GameObject都必须将模型顶点信息复制，并经过计算变化到最终在世界空间中，存储在最终生成的Vertex buffer中。这就导致了打包的体积及运行时内存的占用增大。例如，在茂密的森林级别将树标记为静态会严重影响内存[",{"type":14,"tag":23,"props":103,"children":106},{"href":104,"rel":105},"https://zhuanlan.zhihu.com/p/98642798#ref_3",[27],[107],{"type":20,"value":108},"3]",{"type":20,"value":110},"。",{"type":14,"tag":32,"props":112,"children":113},{},[114],{"type":14,"tag":36,"props":115,"children":116},{},[117],{"type":14,"tag":40,"props":118,"children":119},{},[120],{"type":20,"value":121},"无法参与批处理情况",{"type":14,"tag":123,"props":124,"children":125},"ol",{},[126],{"type":14,"tag":36,"props":127,"children":128},{},[129],{"type":20,"value":130},"改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。",{"type":14,"tag":32,"props":132,"children":133},{},[134],{"type":14,"tag":36,"props":135,"children":136},{},[137],{"type":14,"tag":40,"props":138,"children":139},{},[140],{"type":20,"value":141},"相同材质批处理断开情况",{"type":14,"tag":123,"props":143,"children":144},{},[145,150],{"type":14,"tag":36,"props":146,"children":147},{},[148],{"type":20,"value":149},"位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。",{"type":14,"tag":36,"props":151,"children":152},{},[153],{"type":20,"value":154},"拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行同批处理（除非他们指向lightmap的同一部分）。",{"type":14,"tag":32,"props":156,"children":157},{},[158],{"type":14,"tag":36,"props":159,"children":160},{},[161],{"type":14,"tag":40,"props":162,"children":163},{},[164],{"type":20,"value":165},"流程原理",{"type":14,"tag":46,"props":167,"children":168},{},[169],{"type":14,"tag":62,"props":170,"children":172},{"alt":62,"src":171},"/images/2020-10-23-unity-optimizing-gpu/v2-37b225e02afe6dca369647e4a3bf3bd4_720w.jpg",[],{"type":14,"tag":174,"props":175,"children":176},"hr",{},[],{"type":14,"tag":15,"props":178,"children":180},{"id":179},"动态批处理4",[181,183],{"type":20,"value":182},"动态批处理[",{"type":14,"tag":23,"props":184,"children":187},{"href":185,"rel":186},"https://zhuanlan.zhihu.com/p/98642798#ref_4",[27],[188],{"type":20,"value":189},"4]",{"type":14,"tag":32,"props":191,"children":192},{},[193],{"type":14,"tag":36,"props":194,"children":195},{},[196],{"type":14,"tag":40,"props":197,"children":198},{},[199],{"type":20,"value":44},{"type":14,"tag":46,"props":201,"children":202},{},[203,205,209,211,216,218,223],{"type":20,"value":204},"在使用",{"type":14,"tag":40,"props":206,"children":207},{},[208],{"type":20,"value":55},{"type":20,"value":210},"的情况下，Unity会在运行时对于",{"type":14,"tag":40,"props":212,"children":213},{},[214],{"type":20,"value":215},"正在视野中",{"type":20,"value":217},"的符合条件的动态对象在一个Draw call内绘制，所以",{"type":14,"tag":40,"props":219,"children":220},{},[221],{"type":20,"value":222},"会降低Draw Calls",{"type":20,"value":224},"的数量。",{"type":14,"tag":46,"props":226,"children":227},{},[228],{"type":20,"value":229},"Dynamic batching的原理也很简单，在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中，然后通过一次Draw call绘制多个模型，达到合批的目的。模型顶点变换的操作是由CPU完成的，所以这会带来一些CPU的性能消耗。并且计算的模型顶点数量不宜太多，否则CPU串行计算耗费的时间太长会造成场景渲染卡顿，所以Dynamic batching只能处理一些小模型。",{"type":14,"tag":46,"props":231,"children":232},{},[233],{"type":20,"value":234},"Dynamic batching在降低Draw call的同时会导致额外的CPU性能消耗，所以仅仅在合批操作的性能消耗小于不合批，Dynamic batching才会有意义。而新一代图形API（ Metal、Vulkan）在批次间的消耗降低了很多，所以在这种情况下使用Dynamic batching很可能不能获得性能提升。Dynamic batching相对于Static batching不需要预先复制模型顶点，所以在内存占用和发布的程序体积方面要优于Static batching。但是Dynamic batching会带来一些运行时CPU性能消耗，Static batching在这一点要比Dynamic batching更加高效。",{"type":14,"tag":32,"props":236,"children":237},{},[238],{"type":14,"tag":36,"props":239,"children":240},{},[241],{"type":14,"tag":40,"props":242,"children":243},{},[244],{"type":20,"value":121},{"type":14,"tag":123,"props":246,"children":247},{},[248,253,258,263],{"type":14,"tag":36,"props":249,"children":250},{},[251],{"type":20,"value":252},"物件Mesh大于等于900个面。",{"type":14,"tag":36,"props":254,"children":255},{},[256],{"type":20,"value":257},"代码动态改变材质变量后不算同一个材质，会不参与合批。",{"type":14,"tag":36,"props":259,"children":260},{},[261],{"type":20,"value":262},"如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体，否则都无法参与合批。",{"type":14,"tag":36,"props":264,"children":265},{},[266],{"type":20,"value":130},{"type":14,"tag":32,"props":268,"children":269},{},[270],{"type":14,"tag":36,"props":271,"children":272},{},[273],{"type":14,"tag":40,"props":274,"children":275},{},[276],{"type":20,"value":277},"批处理中断情况",{"type":14,"tag":123,"props":279,"children":280},{},[281,285,290,295,300,305,310],{"type":14,"tag":36,"props":282,"children":283},{},[284],{"type":20,"value":149},{"type":14,"tag":36,"props":286,"children":287},{},[288],{"type":20,"value":289},"物体如果都符合条件会优先参与静态批处理，再是GPU Instancing，然后才到动态批处理，假如物体符合前两者，此次批处理都会被打断。",{"type":14,"tag":36,"props":291,"children":292},{},[293],{"type":20,"value":294},"GameObject之间如果有镜像变换不能进行合批，例如，\"GameObject A with +1 scale and GameObject B with –1 scale cannot be batched together\"。",{"type":14,"tag":36,"props":296,"children":297},{},[298],{"type":20,"value":299},"拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。",{"type":14,"tag":36,"props":301,"children":302},{},[303],{"type":20,"value":304},"使用Multi-pass Shader的物体会禁用Dynamic batching，因为Multi-pass Shader通常会导致一个物体要连续绘制多次，并切换渲染状态。这会打破其跟其他物体进行Dynamic batching的机会。",{"type":14,"tag":36,"props":306,"children":307},{},[308],{"type":20,"value":309},"我们知道能够进行合批的前提是多个GameObject共享同一材质，但是对于Shadow casters的渲染是个例外。仅管Shadow casters使用不同的材质，但是只要它们的材质中给Shadow Caster Pass使用的参数是相同的，他们也能够进行Dynamic batching。",{"type":14,"tag":36,"props":311,"children":312},{},[313],{"type":20,"value":314},"Unity的Forward Rendering Path中如果一个GameObject接受多个光照会为每一个per-pixel light产生多余的模型提交和绘制，从而附加了多个Pass导致无法合批，如下图:",{"type":14,"tag":46,"props":316,"children":317},{},[318,322],{"type":14,"tag":62,"props":319,"children":321},{"alt":62,"src":320},"/images/2020-10-23-unity-optimizing-gpu/v2-177f53a633d2eac753abe07805367d4d_720w.jpg",[],{"type":20,"value":323},"可以接收多个光源的shader，在受到多个光源是无法合批",{"type":14,"tag":32,"props":325,"children":326},{},[327],{"type":14,"tag":36,"props":328,"children":329},{},[330],{"type":14,"tag":40,"props":331,"children":332},{},[333],{"type":20,"value":165},{"type":14,"tag":46,"props":335,"children":336},{},[337],{"type":14,"tag":62,"props":338,"children":340},{"alt":62,"src":339},"/images/2020-10-23-unity-optimizing-gpu/v2-8c69d718432ba4045155c700fda6f6b6_720w.jpg",[],{"type":14,"tag":174,"props":342,"children":343},{},[],{"type":14,"tag":15,"props":345,"children":347},{"id":346},"gpu-instancing",[348],{"type":20,"value":349},"GPU Instancing",{"type":14,"tag":32,"props":351,"children":352},{},[353],{"type":14,"tag":36,"props":354,"children":355},{},[356],{"type":14,"tag":40,"props":357,"children":358},{},[359],{"type":20,"value":44},{"type":14,"tag":46,"props":361,"children":362},{},[363,364,369,371,376,378,385,387,393,395,399,409,414],{"type":20,"value":204},{"type":14,"tag":40,"props":365,"children":366},{},[367],{"type":20,"value":368},"相同材质球、相同Mesh(预设体的实例会自动地使用相同的网格模型和材质)的情况下，Unity会在运行时对于",{"type":20,"value":370},"正在视野中的符合要求的所有对象使用",{"type":14,"tag":40,"props":372,"children":373},{},[374],{"type":20,"value":375},"Constant Buffer",{"type":20,"value":377},"[",{"type":14,"tag":23,"props":379,"children":382},{"href":380,"rel":381},"https://zhuanlan.zhihu.com/p/98642798#ref_5",[27],[383],{"type":20,"value":384},"5]",{"type":20,"value":386},"将其位置、缩放、uv偏移、",{"type":14,"tag":388,"props":389,"children":390},"em",{},[391],{"type":20,"value":392},"lightmapindex",{"type":20,"value":394},"等相关信息保存在显存中的**“统一/常量缓冲器”",{"type":14,"tag":40,"props":396,"children":397},{},[398],{"type":20,"value":377},{"type":14,"tag":23,"props":400,"children":403},{"href":401,"rel":402},"https://zhuanlan.zhihu.com/p/98642798#ref_6",[27],[404],{"type":14,"tag":40,"props":405,"children":406},{},[407],{"type":20,"value":408},"6]",{"type":14,"tag":40,"props":410,"children":411},{},[412],{"type":20,"value":413},"中，然后从中抽取一个对象作为实例送入渲染流程，当在执行DrawCall操作后，从显存中取出实例的部分共享信息与从GPU常量缓冲器中取出对应对象的相关信息一并传递到下一渲染阶段，与此同时，不同的着色器阶段可以从缓存区中直接获取到需要的常量，不用设置两次常量。比起以上两种批处理，GPU Instancing可以",{"type":20,"value":415},"规避合并Mesh导致的内存与性能上升**的问题，但是由于场景中所有符合该合批条件的渲染物体的信息每帧都要被重新创建，放入“统一/常量缓冲区”中，而碍于缓存区的大小限制，每一个Constant Buffer的大小要严格限制（不得大于64k）。详细请阅读：",{"type":14,"tag":46,"props":417,"children":418},{},[419],{"type":14,"tag":23,"props":420,"children":423},{"href":421,"rel":422},"https://zhuanlan.zhihu.com/p/34499251",[27],[424,426],{"type":20,"value":425},"Testplus：U3D优化批处理-GPU Instancing了解一下zhuanlan.zhihu.com",{"type":14,"tag":62,"props":427,"children":430},{"alt":428,"src":429},"图标","/images/2020-10-23-unity-optimizing-gpu/v2-b06a0dbdf07544a4d0687a8917611afd_180x120.jpg",[],{"type":14,"tag":32,"props":432,"children":433},{},[434],{"type":14,"tag":36,"props":435,"children":436},{},[437],{"type":14,"tag":40,"props":438,"children":439},{},[440],{"type":20,"value":441},"无法参与加速情况",{"type":14,"tag":123,"props":443,"children":444},{},[445,450,463,468],{"type":14,"tag":36,"props":446,"children":447},{},[448],{"type":20,"value":449},"缩放为负值的情况下，会不参与加速。",{"type":14,"tag":36,"props":451,"children":452},{},[453,455,462],{"type":20,"value":454},"代码动态改变材质变量后不算同一个材质，会不参与加速，但可以通过将颜色变化等变量加入常量缓冲器中实现[",{"type":14,"tag":23,"props":456,"children":459},{"href":457,"rel":458},"https://zhuanlan.zhihu.com/p/98642798#ref_7",[27],[460],{"type":20,"value":461},"7]",{"type":20,"value":110},{"type":14,"tag":36,"props":464,"children":465},{},[466],{"type":20,"value":467},"受限于常量缓冲区在不同设备上的大小的上限，移动端支持的个数可能较低。",{"type":14,"tag":36,"props":469,"children":470},{},[471],{"type":20,"value":472},"只支持一盏实时光，要在多个光源的情况下使用实例化，我们别无选择，只能切换到延迟渲染路径。为了能够让这套机制运作起来，请将所需的编译器指令添加到我们着色器的延迟渲染通道中。",{"type":14,"tag":46,"props":474,"children":475},{},[476,480],{"type":14,"tag":62,"props":477,"children":479},{"alt":62,"src":478},"/images/2020-10-23-unity-optimizing-gpu/v2-5c97567b099e9d98ca9d957282b1922e_720w.jpg",[],{"type":20,"value":481},"当在多个光源开启GPU Instancing",{"type":14,"tag":32,"props":483,"children":484},{},[485],{"type":14,"tag":36,"props":486,"children":487},{},[488],{"type":14,"tag":40,"props":489,"children":490},{},[491],{"type":20,"value":277},{"type":14,"tag":123,"props":493,"children":494},{},[495,499,504],{"type":14,"tag":36,"props":496,"children":497},{},[498],{"type":20,"value":149},{"type":14,"tag":36,"props":500,"children":501},{},[502],{"type":20,"value":503},"一个批次超过125个物体（受限于常量缓冲区在不同设备上的大小的上限，移动端数量有浮动）的时候会新建另一个加速流程。",{"type":14,"tag":36,"props":505,"children":506},{},[507],{"type":20,"value":508},"物体如果都符合条件会优先参与静态批处理，然后才到GPU Instancing，假如物体符合前者，此次加速都会被打断。",{"type":14,"tag":32,"props":510,"children":511},{},[512],{"type":14,"tag":36,"props":513,"children":514},{},[515],{"type":14,"tag":40,"props":516,"children":517},{},[518],{"type":20,"value":165},{"type":14,"tag":46,"props":520,"children":521},{},[522],{"type":14,"tag":62,"props":523,"children":525},{"alt":62,"src":524},"/images/2020-10-23-unity-optimizing-gpu/v2-0dde54b930bef9c768c10d3c79126e16_720w.jpg",[],{"type":14,"tag":174,"props":527,"children":528},{},[],{"type":14,"tag":15,"props":530,"children":532},{"id":531},"srp-batcher8",[533,535],{"type":20,"value":534},"SRP Batcher[",{"type":14,"tag":23,"props":536,"children":539},{"href":537,"rel":538},"https://zhuanlan.zhihu.com/p/98642798#ref_8",[27],[540],{"type":20,"value":541},"8]",{"type":14,"tag":32,"props":543,"children":544},{},[545],{"type":14,"tag":36,"props":546,"children":547},{},[548],{"type":14,"tag":40,"props":549,"children":550},{},[551],{"type":20,"value":44},{"type":14,"tag":46,"props":553,"children":554},{},[555,557,562,564,568,570,574,575,580,582,586,594,603],{"type":20,"value":556},"在使用LWRP或者HWRP时，开启SRP Batcher的情况下，只要物体的",{"type":14,"tag":40,"props":558,"children":559},{},[560],{"type":20,"value":561},"Shader中变体",{"type":20,"value":563},"一致，就可以启用SRP Batcher加速。它与上文GPU Instancing实现的原理相近，Unity会在运行时对于正在视野中的符合要求的所有对象使用**“Per Object” GPU BUFFER（一个独立的Buffer）** 将其位置、缩放、uv偏移、",{"type":14,"tag":388,"props":565,"children":566},{},[567],{"type":20,"value":392},{"type":20,"value":569},"等相关信息保存在GPU内存中，同时也会将正在视野中的符合要求的所有对象使用",{"type":14,"tag":40,"props":571,"children":572},{},[573],{"type":20,"value":375},{"type":20,"value":377},{"type":14,"tag":23,"props":576,"children":578},{"href":380,"rel":577},[27],[579],{"type":20,"value":384},{"type":20,"value":581},"将材质信息保存在保存在显存中的**“统一/常量缓冲器”",{"type":14,"tag":40,"props":583,"children":584},{},[585],{"type":20,"value":377},{"type":14,"tag":23,"props":587,"children":589},{"href":401,"rel":588},[27],[590],{"type":14,"tag":40,"props":591,"children":592},{},[593],{"type":20,"value":408},{"type":14,"tag":40,"props":595,"children":596},{},[597,599],{"type":20,"value":598},"中。与GPU Instancing相比，因为数据不再每帧被重新创建，而且需要保存进“统一/常量缓冲区”的数据排除了各自的位置、缩放、uv偏移、",{"type":14,"tag":388,"props":600,"children":601},{},[602],{"type":20,"value":392},{"type":20,"value":604},"等相关信息，所以缓冲区内有更多的空间可以动态地**存储场景中所有渲染物体的材质信息。由于数据不再每帧被重新创建，而是动态更新，所以SRP Batcher的本质并不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本。",{"type":14,"tag":46,"props":606,"children":607},{},[608,612],{"type":14,"tag":62,"props":609,"children":611},{"alt":62,"src":610},"/images/2020-10-23-unity-optimizing-gpu/v2-7b93309c00f2866639a2f7c529495608_720w.jpg",[],{"type":20,"value":613},"因为不用重新创建Constant Buffer，所以本质上SRP Batcher不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本",{"type":14,"tag":32,"props":615,"children":616},{},[617],{"type":14,"tag":36,"props":618,"children":619},{},[620],{"type":14,"tag":40,"props":621,"children":622},{},[623],{"type":20,"value":441},{"type":14,"tag":123,"props":625,"children":626},{},[627,632],{"type":14,"tag":36,"props":628,"children":629},{},[630],{"type":20,"value":631},"对象不可以是粒子或蒙皮网格。",{"type":14,"tag":36,"props":633,"children":634},{},[635,637,642,644,649,651,656],{"type":20,"value":636},"Shader中",{"type":14,"tag":40,"props":638,"children":639},{},[640],{"type":20,"value":641},"变体",{"type":20,"value":643},"不一致，如下图两个",{"type":14,"tag":40,"props":645,"children":646},{},[647],{"type":20,"value":648},"相同Shader",{"type":20,"value":650},"的材质，但是因为Surface Options不一致，导致",{"type":14,"tag":40,"props":652,"children":653},{},[654],{"type":20,"value":655},"变体不一样",{"type":20,"value":657},"而无法合并。",{"type":14,"tag":46,"props":659,"children":660},{},[661,665],{"type":14,"tag":62,"props":662,"children":664},{"alt":62,"src":663},"/images/2020-10-23-unity-optimizing-gpu/v2-b0599861b3304d19979816413cb13a43_720w.jpg",[],{"type":20,"value":666},"变体不同的不同材质",{"type":14,"tag":32,"props":668,"children":669},{},[670],{"type":14,"tag":36,"props":671,"children":672},{},[673],{"type":14,"tag":40,"props":674,"children":675},{},[676],{"type":20,"value":277},{"type":14,"tag":123,"props":678,"children":679},{},[680],{"type":14,"tag":36,"props":681,"children":682},{},[683,685,690,692,697],{"type":20,"value":684},"位置不相邻且中间夹杂着",{"type":14,"tag":40,"props":686,"children":687},{},[688],{"type":20,"value":689},"不同Shader",{"type":20,"value":691},"，或者",{"type":14,"tag":40,"props":693,"children":694},{},[695],{"type":20,"value":696},"不同变体",{"type":20,"value":698},"的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。",{"type":14,"tag":32,"props":700,"children":701},{},[702],{"type":14,"tag":36,"props":703,"children":704},{},[705],{"type":14,"tag":40,"props":706,"children":707},{},[708],{"type":20,"value":165},{"type":14,"tag":46,"props":710,"children":711},{},[712],{"type":14,"tag":62,"props":713,"children":715},{"alt":62,"src":714},"/images/2020-10-23-unity-optimizing-gpu/v2-6125b513800939912bb07853ae0a1f90_720w.jpg",[],{"type":14,"tag":174,"props":717,"children":718},{},[],{"type":14,"tag":15,"props":720,"children":722},{"id":721},"_2020年2月13日-更新-更改对统一常量缓冲器的描述对srp-batcher与gpu-instancing的实现原理进行了比较大的修改",[723],{"type":14,"tag":388,"props":724,"children":725},{},[726],{"type":14,"tag":40,"props":727,"children":728},{},[729],{"type":20,"value":730},"2020年2月13日-更新： 更改对”统一/常量缓冲器“的描述，对SRP Batcher与GPU Instancing的实现原理进行了比较大的修改。",{"type":14,"tag":732,"props":733,"children":734},"blockquote",{},[735],{"type":14,"tag":46,"props":736,"children":737},{},[738,743,748,753],{"type":14,"tag":388,"props":739,"children":740},{},[741],{"type":20,"value":742},"^ ^ 以上只是我工作中的一些小总结",{"type":14,"tag":388,"props":744,"children":745},{},[746],{"type":20,"value":747},"有什么不正确的地方可以在评论告诉我",{"type":14,"tag":388,"props":749,"children":750},{},[751],{"type":20,"value":752},"我的微信号是：sam2b2b",{"type":14,"tag":388,"props":754,"children":755},{},[756],{"type":20,"value":757},"有想一起进步的小伙伴可以加微信逛逛圈",{"type":14,"tag":15,"props":759,"children":761},{"id":760},"参考",[762],{"type":20,"value":760},{"type":14,"tag":123,"props":764,"children":765},{},[766,782,797,812,826,851,869,884],{"type":14,"tag":36,"props":767,"children":768},{},[769,776],{"type":14,"tag":23,"props":770,"children":773},{"href":771,"rel":772},"https://zhuanlan.zhihu.com/p/98642798#ref_1_0",[27],[774],{"type":20,"value":775},"^",{"type":14,"tag":23,"props":777,"children":780},{"href":778,"rel":779},"https://gameinstitute.qq.com/community/detail/114323",[27],[781],{"type":20,"value":778},{"type":14,"tag":36,"props":783,"children":784},{},[785,791],{"type":14,"tag":23,"props":786,"children":789},{"href":787,"rel":788},"https://zhuanlan.zhihu.com/p/98642798#ref_2_0",[27],[790],{"type":20,"value":775},{"type":14,"tag":23,"props":792,"children":795},{"href":793,"rel":794},"https://forum.unity.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/",[27],[796],{"type":20,"value":793},{"type":14,"tag":36,"props":798,"children":799},{},[800,806],{"type":14,"tag":23,"props":801,"children":804},{"href":802,"rel":803},"https://zhuanlan.zhihu.com/p/98642798#ref_3_0",[27],[805],{"type":20,"value":775},{"type":14,"tag":23,"props":807,"children":810},{"href":808,"rel":809},"https://docs.unity3d.com/Manual/DrawCallBatching.html",[27],[811],{"type":20,"value":808},{"type":14,"tag":36,"props":813,"children":814},{},[815,821],{"type":14,"tag":23,"props":816,"children":819},{"href":817,"rel":818},"https://zhuanlan.zhihu.com/p/98642798#ref_4_0",[27],[820],{"type":20,"value":775},{"type":14,"tag":23,"props":822,"children":824},{"href":778,"rel":823},[27],[825],{"type":20,"value":778},{"type":14,"tag":36,"props":827,"children":828},{},[829,830,836,843,845],{"type":20,"value":775},{"type":14,"tag":23,"props":831,"children":834},{"href":832,"rel":833},"https://zhuanlan.zhihu.com/p/98642798#ref_5_0",[27],[835],{"type":20,"value":23},{"type":14,"tag":23,"props":837,"children":840},{"href":838,"rel":839},"https://zhuanlan.zhihu.com/p/98642798#ref_5_1",[27],[841],{"type":20,"value":842},"b",{"type":20,"value":844},"Constant Buffer ",{"type":14,"tag":23,"props":846,"children":849},{"href":847,"rel":848},"https://zhuanlan.zhihu.com/p/35830868",[27],[850],{"type":20,"value":847},{"type":14,"tag":36,"props":852,"children":853},{},[854,855,861,867],{"type":20,"value":775},{"type":14,"tag":23,"props":856,"children":859},{"href":857,"rel":858},"https://zhuanlan.zhihu.com/p/98642798#ref_6_0",[27],[860],{"type":20,"value":23},{"type":14,"tag":23,"props":862,"children":865},{"href":863,"rel":864},"https://zhuanlan.zhihu.com/p/98642798#ref_6_1",[27],[866],{"type":20,"value":842},{"type":20,"value":868},"unity将常量存储在4M的缓冲池里，并每帧循环池（这个池子被绑定到GPU上，可以在截帧工具比如XCode或者Snapdragon上看到）",{"type":14,"tag":36,"props":870,"children":871},{},[872,878],{"type":14,"tag":23,"props":873,"children":876},{"href":874,"rel":875},"https://zhuanlan.zhihu.com/p/98642798#ref_7_0",[27],[877],{"type":20,"value":775},{"type":14,"tag":23,"props":879,"children":882},{"href":880,"rel":881},"https://blog.csdn.net/lzhq1982/article/details/88119283",[27],[883],{"type":20,"value":880},{"type":14,"tag":36,"props":885,"children":886},{},[887,893,895],{"type":14,"tag":23,"props":888,"children":891},{"href":889,"rel":890},"https://zhuanlan.zhihu.com/p/98642798#ref_8_0",[27],[892],{"type":20,"value":775},{"type":20,"value":894},"SRP Batcher 官方文档： ",{"type":14,"tag":23,"props":896,"children":899},{"href":897,"rel":898},"https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw",[27],[900],{"type":20,"value":897},{"title":7,"searchDepth":902,"depth":902,"links":903},2,[904,906,908,909,911,912],{"id":17,"depth":902,"text":905},"静态批处理[1]",{"id":179,"depth":902,"text":907},"动态批处理[4]",{"id":346,"depth":902,"text":349},{"id":531,"depth":902,"text":910},"SRP Batcher[8]",{"id":721,"depth":902,"text":730},{"id":760,"depth":902,"text":760},"markdown","content:unity:2020-10-23-unity-optimizing-gpu.md","content","unity/2020-10-23-unity-optimizing-gpu.md","md","2020-10-23",[920,930,1057,1106,1158,1171,1283],{"title":921,"_path":922,"children":923},"Art","/art",[924,927],{"title":925,"_path":926},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":928,"_path":929},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":931,"_path":932,"children":933},"Dotnet","/dotnet",[934,937,940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000,1003,1006,1009,1012,1015,1018,1021,1024,1027,1030,1033,1036,1039,1042,1045,1048,1051,1054],{"title":935,"_path":936},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":938,"_path":939},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":941,"_path":942},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":944,"_path":945},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":947,"_path":948},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":950,"_path":951},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":953,"_path":954},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":956,"_path":957},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":959,"_path":960},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":962,"_path":963},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":965,"_path":966},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":968,"_path":969},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":971,"_path":972},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":974,"_path":975},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":977,"_path":978},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":980,"_path":981},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":983,"_path":984},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":986,"_path":987},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":989,"_path":990},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":992,"_path":993},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":995,"_path":996},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":998,"_path":999},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1001,"_path":1002},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1004,"_path":1005},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1007,"_path":1008},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1010,"_path":1011},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1013,"_path":1014},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1016,"_path":1017},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1019,"_path":1020},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1022,"_path":1023},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1025,"_path":1026},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1028,"_path":1029},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1031,"_path":1032},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1034,"_path":1035},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1037,"_path":1038},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1040,"_path":1041},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1043,"_path":1044},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1046,"_path":1047},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1049,"_path":1050},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1052,"_path":1053},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1055,"_path":1056},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1058,"_path":1059,"children":1060},"Game","/game",[1061,1064,1067,1070,1073,1076,1079,1082,1085,1088,1091,1094,1097,1100,1103],{"title":1062,"_path":1063},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1065,"_path":1066},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1068,"_path":1069},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1071,"_path":1072},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1074,"_path":1075},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1077,"_path":1078},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1080,"_path":1081},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1083,"_path":1084},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1086,"_path":1087},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1089,"_path":1090},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1092,"_path":1093},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1095,"_path":1096},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1098,"_path":1099},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1101,"_path":1102},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1104,"_path":1105},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1107,"_path":1108,"children":1109},"Gyj","/gyj",[1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140,1143,1146,1149,1152,1155],{"title":1111,"_path":1112},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1114,"_path":1115},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1117,"_path":1118},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1120,"_path":1121},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1123,"_path":1124},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1126,"_path":1127},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1129,"_path":1130},"玩法","/gyj/2022-08-22-wanfa",{"title":1132,"_path":1133},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1135,"_path":1136},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1138,"_path":1139},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1141,"_path":1142},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1144,"_path":1145},"门派内容相关","/gyj/2022-11-17-sect",{"title":1147,"_path":1148},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1150,"_path":1151},"种植","/gyj/2022-12-01-zhongzhi",{"title":1153,"_path":1154},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1156,"_path":1157},"跑商","/gyj/2023-11-01-paoshang",{"title":1159,"_path":1160,"children":1161},"Js","/js",[1162,1165,1168],{"title":1163,"_path":1164},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1166,"_path":1167},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1169,"_path":1170},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1172,"_path":1173,"children":1174},"Tool","/tool",[1175,1178,1181,1184,1187,1190,1193,1196,1199,1202,1205,1208,1211,1214,1217,1220,1223,1226,1229,1232,1235,1238,1241,1244,1247,1250,1253,1256,1259,1262,1265,1268,1271,1274,1277,1280],{"title":1176,"_path":1177},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1179,"_path":1180},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1182,"_path":1183},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1185,"_path":1186},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1188,"_path":1189},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1191,"_path":1192},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1194,"_path":1195},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1197,"_path":1198},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1200,"_path":1201},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1203,"_path":1204},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1206,"_path":1207},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1209,"_path":1210},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1212,"_path":1213},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1215,"_path":1216},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1218,"_path":1219},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1221,"_path":1222},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1224,"_path":1225},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1227,"_path":1228},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1230,"_path":1231},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1233,"_path":1234},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1236,"_path":1237},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1239,"_path":1240},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1242,"_path":1243},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1245,"_path":1246},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1248,"_path":1249},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1251,"_path":1252},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1254,"_path":1255},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1257,"_path":1258},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1260,"_path":1261},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1263,"_path":1264},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1266,"_path":1267},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1269,"_path":1270},"rider的使用","/tool/2022-08-02-rider-use",{"title":1272,"_path":1273},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1275,"_path":1276},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1278,"_path":1279},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1281,"_path":1282},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1284,"_path":1285,"children":1286},"Unity","/unity",[1287,1290,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392,1395,1398,1401,1404,1407,1410,1413,1416,1419,1422,1425,1426,1429,1432,1435,1438,1441,1444,1447,1450,1453,1456,1459,1462,1465,1468,1471,1474,1477,1480,1483,1486,1489,1492,1495,1498],{"title":1288,"_path":1289},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1291,"_path":1292},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1294,"_path":1295},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1297,"_path":1298},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1300,"_path":1301},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1303,"_path":1304},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1306,"_path":1307},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1309,"_path":1310},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1312,"_path":1313},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1315,"_path":1316},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1318,"_path":1319},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1321,"_path":1322},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1324,"_path":1325},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1327,"_path":1328},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1330,"_path":1331},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1333,"_path":1334},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1336,"_path":1337},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1339,"_path":1340},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1342,"_path":1343},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1345,"_path":1346},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1348,"_path":1349},"技能系统","/unity/2020-02-15-skill-system",{"title":1351,"_path":1352},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1354,"_path":1355},"角色状态设计","/unity/2020-02-17-character-states",{"title":1357,"_path":1358},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1360,"_path":1361},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1363,"_path":1364},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1366,"_path":1367},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1369,"_path":1370},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1372,"_path":1373},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1375,"_path":1376},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1378,"_path":1379},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1381,"_path":1382},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1384,"_path":1385},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1387,"_path":1388},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1390,"_path":1391},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1393,"_path":1394},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1396,"_path":1397},"unity的addressables","/unity/2020-09-12-addressables",{"title":1399,"_path":1400},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1402,"_path":1403},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1405,"_path":1406},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1408,"_path":1409},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1411,"_path":1412},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1414,"_path":1415},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1417,"_path":1418},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1420,"_path":1421},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1423,"_path":1424},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":8,"_path":4},{"title":1427,"_path":1428},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1430,"_path":1431},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1433,"_path":1434},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1436,"_path":1437},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1439,"_path":1440},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1442,"_path":1443},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1445,"_path":1446},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1448,"_path":1449},"ability","/unity/2020-11-16-dotssample",{"title":1451,"_path":1452},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1454,"_path":1455},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1457,"_path":1458},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1460,"_path":1461},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1463,"_path":1464},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1466,"_path":1467},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1469,"_path":1470},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1472,"_path":1473},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1475,"_path":1476},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1478,"_path":1479},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1481,"_path":1482},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1484,"_path":1485},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1487,"_path":1488},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1490,"_path":1491},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1493,"_path":1494},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1496,"_path":1497},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1499,"_path":1500},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779039393]