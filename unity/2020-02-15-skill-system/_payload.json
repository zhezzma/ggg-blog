[{"data":1,"prerenderedAt":1516},["Reactive",2],{"content-query-un0GE5oKfx":3,"content-navigation-8C37fagqQL":934},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":928,"_id":929,"_source":930,"_file":931,"_extension":932,"date":933},"/unity/2020-02-15-skill-system","unity",false,"","技能系统","从架构上说,主动技能都可以拆分为释放条件检测->释放->目标选择->产生效果\n但是里面很多细节,比如子弹初始位置设置,做成什么样子组合出更多的设计形式,同时可以兼容更多的有效需求\n比如一个回合制卡牌游戏,要啥飞行子弹,区域只要相对和绝对位置2大类,然后直接填坐标就好了示例1:\n玩家释放技能1->释放子弹1对自身加免疫buff,释放子弹2在1秒后对身前范围最近1个友方击中->命中后对自身释放子弹->命令自身对目标释放技能2\n释放技能1后选择对身前最近一个友方追加释放技能2示例2:\n被动技能->获得buff->buff触发器每2秒在自身位置释放单体子弹1清除buff1,aoe子弹击中敌人->每命中",{"type":11,"children":12,"toc":903},"root",[13,23,29,40,50,60,70,80,85,90,97,102,107,142,149,154,167,173,178,183,188,194,199,204,222,227,232,238,243,257,264,269,274,279,284,289,294,301,306,311,316,320,328,333,338,343,348,353,356,362,367,385,391,396,401,406,412,417,423,428,433,438,443,449,454,459,464,469,474,479,484,489,495,500,505,510,515,520,525,531,536,547,552,558,563,568,573,586,591,598,602,607,616,624,630,635,641,656,661,666,671,689,694,702,708,713,720,725,730,758,763,768,776,781,786,799,805,810,815,820,830,835,840,846,851,859,864,869,879,884,889,894],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":14,"tag":19,"props":20,"children":22},"img",{"alt":19,"src":21},"/images/2020-02-15-skill-system/20180602102244475.png",[],{"type":14,"tag":15,"props":24,"children":25},{},[26],{"type":27,"value":28},"text","从架构上说,主动技能都可以拆分为释放条件检测->释放->目标选择->产生效果\n但是里面很多细节,比如子弹初始位置设置,做成什么样子组合出更多的设计形式,同时可以兼容更多的有效需求\n比如一个回合制卡牌游戏,要啥飞行子弹,区域只要相对和绝对位置2大类,然后直接填坐标就好了",{"type":14,"tag":15,"props":30,"children":31},{},[32,38],{"type":14,"tag":33,"props":34,"children":35},"strong",{},[36],{"type":27,"value":37},"示例1:",{"type":27,"value":39},"\n玩家释放技能1->释放子弹1对自身加免疫buff,释放子弹2在1秒后对身前范围最近1个友方击中->命中后对自身释放子弹->命令自身对目标释放技能2\n释放技能1后选择对身前最近一个友方追加释放技能2",{"type":14,"tag":15,"props":41,"children":42},{},[43,48],{"type":14,"tag":33,"props":44,"children":45},{},[46],{"type":27,"value":47},"示例2:",{"type":27,"value":49},"\n被动技能->获得buff->buff触发器每2秒在自身位置释放单体子弹1清除buff1,aoe子弹击中敌人->每命中一个敌人对自身叠加1层buff1\n实际效果:周围敌人越多自身获得越多层buff1",{"type":14,"tag":15,"props":51,"children":52},{},[53,58],{"type":14,"tag":33,"props":54,"children":55},{},[56],{"type":27,"value":57},"示例3:",{"type":27,"value":59},"\n玩家释放技能1->释放子弹1对自身周围友方和敌方击中->对命中的目标释放3个子弹:子弹1筛选敌人产生伤害,子弹2筛选友方30%血以上造成治疗,子弹3筛选敌人血量大于80%命中后产生子弹4对自身添加buff\n实际效果:对周围友方残血造成治疗,对敌人造成伤害,如果击中的敌人血量较高,自身获得增益",{"type":14,"tag":15,"props":61,"children":62},{},[63,68],{"type":14,"tag":33,"props":64,"children":65},{},[66],{"type":27,"value":67},"示例4",{"type":27,"value":69},"\n玩家有被动技能获得buff1->buff触发器效果为暴击击中时若双方距离>300则对目标发射子弹1和子弹2->子弹1对自身添加buff,子弹2筛选有buff2的敌人\n技能效果:暴击击中距离自身较远的敌人使自身获得增益,触发时若敌人有buff2,则造成额外效果",{"type":14,"tag":15,"props":71,"children":72},{},[73,78],{"type":14,"tag":33,"props":74,"children":75},{},[76],{"type":27,"value":77},"示例5",{"type":27,"value":79},"\n玩家释放主动技能->发射子弹使自身获得6层buff1\nbuff1附带3个触发器\n触发器1->释放技能清除所有层数buff1\n触发器2->受到攻击失去1层\n触发器3->buff1消失时自身获得buff2\nbuff2->触发器每1秒对自身附近发射子弹筛选1个敌人->令目标对自身发射子弹添加增益\n技能效果:主动隐身,受到攻击失去1层,释放技能后解除隐身,隐身结束后一段时间内受到伤害转移给附近一个敌人",{"type":14,"tag":15,"props":81,"children":82},{},[83],{"type":27,"value":84},"基础内容有这么几个部分：\n1、Actor，这个是角色本身，它不属于技能系统，但是它要给技能系统开放足够的接口，比如播放动画、播放声音、控制位移、造成伤害、添加buff等等\n2、Skill，这个就是技能本身，它在合适的时机调用脚本中的相应函数，脚本中可以在OnCreate  OnHit  OnDeath  OnHeroDeath  OnSoldierDeath等事件中写相应代码。由于是脚本，所以代码非常灵活，而由于限定了只处理技能相关功能，所以代码也不会很复杂，有经验的策划绝对搞的定。\n3、Buff，这个是技能效果的核心。它可以是有时限的，也可以是被动无时限的。在它对应的脚本中，定义了这个Buff会影响哪些角色属性（如血量、暴击、攻击力等等）或者角色状态（如眩晕、隐身、沉默等等），同样，buff脚本也支持事件机制，在脚本的相应事件处理其逻辑功能，可以实现非常丰富的效果。\n4、Modifier，这个是一个技能修改器。技能修改器可以修改技能的流程和效果（比如技能伤害增加、火球击中人会爆炸等等），具体可以参考风暴英雄中的技能天赋系统。技能修改器并没有脚本与之对应，一个技能如果支持某个修改器，需要在脚本中处理相应功能。",{"type":14,"tag":15,"props":86,"children":87},{},[88],{"type":27,"value":89},"技能的基类是RoleSkill，然后分近战和远程两个大类，记得不要根据职业来分，而是根据功能来抽象，近战的技能是通过武器来产生伤害，而远程技能是通过发射物来伤害。近战技能可以继续分为：近距离接触攻击单人，近距离范围内接触攻击多人等；远程技能可以分为：单发射物攻击单人，远距离范围内非接触攻击多人等。",{"type":14,"tag":15,"props":91,"children":92},{},[93],{"type":14,"tag":19,"props":94,"children":96},{"alt":19,"src":95},"https://github.com/dongweiPeng/SkillSystem/raw/master/Assets/%E6%8A%80%E8%83%BD%E6%B5%81%E7%A8%8B.png",[],{"type":14,"tag":15,"props":98,"children":99},{},[100],{"type":27,"value":101},"广义的的说，和战斗结算相关的内容都算技能系统，包括技能信息管理、技能调用接口、技能目标查找、技能表现、技能结算、技能创生体（buff/法术场/弹道）管理，此外还涉及的模块包括：AI模块（技能调用者）、动作模块、寻路/移动模块以及人物属性和伤害数值结算等。",{"type":14,"tag":15,"props":103,"children":104},{},[105],{"type":27,"value":106},"先说下技能模块每个部分的职责和原理：",{"type":14,"tag":108,"props":109,"children":110},"ul",{},[111,117,122,127,132,137],{"type":14,"tag":112,"props":113,"children":114},"li",{},[115],{"type":27,"value":116},"技能信息管理：管理unit所拥有的技能以及技能的等级、cd等。在我们游戏中，这里还需要负责管理符文，符文会对技能信息进行修改。",{"type":14,"tag":112,"props":118,"children":119},{},[120],{"type":27,"value":121},"技能调用接口：AI或者UI操作触发技能，触发技能时可能选择了一个目标（AI），也可能并没有目标。",{"type":14,"tag":112,"props":123,"children":124},{},[125],{"type":27,"value":126},"技能流程管理：一个技能可能由多个子技能以移动的执行模式组合而成，而每一个最终执行的技能执行过程也存在一个流程，一般包括：前摇过程-结算点-后摇过程。技能在前摇结束时进入技能真正的结算流程，结算流程可能创建子弹，也可能触发buf或者创建法术场。",{"type":14,"tag":112,"props":128,"children":129},{},[130],{"type":27,"value":131},"技能目标查找：若技能触发时已经设置了技能目标unit(如怪物AI释放技能)，则直接将其作为目标unit，否则需要根据一定的策略选择一个目标。此外，技能释放的时候还需要释放方向和释放位置等信息，也通过这个模块获取。",{"type":14,"tag":112,"props":133,"children":134},{},[135],{"type":27,"value":136},"技能表现：技能释放过程中，需要创建相应的特效以及执行相应的动作。",{"type":14,"tag":112,"props":138,"children":139},{},[140],{"type":27,"value":141},"技能创生体（buf/弹道/法术场）管理：buf挂在unit身上，可能影响unit的一些行为和状态；法术场一般由场景管理，影响场景中某范围内的unit；弹道就是技能创建的一个子弹，这个子弹可能以不同的路线移动（直线／抛物线／直接命中等）",{"type":14,"tag":143,"props":144,"children":146},"h2",{"id":145},"_0技能表",[147],{"type":27,"value":148},"0技能表",{"type":14,"tag":15,"props":150,"children":151},{},[152],{"type":27,"value":153},"首先说下实现技能的基本思路。实现技能的基本思路就是通过策划填写表格，来配制成某些技能，在执行某个技能的时候，分别去根据这些表格中的内容，确定技能如何表现。基本的逻辑是：",{"type":14,"tag":155,"props":156,"children":161},"pre",{"className":157,"code":159,"language":160,"meta":7},[158],"language-csharp","if skillTable.get(\"技能动作\"):\n     paly 动作\nif skillTable.get(\"特效\"):\n     播放特效\nif skillTable.get(\"法术场\"):\n    创建法术场\n....\n","csharp",[162],{"type":14,"tag":163,"props":164,"children":165},"code",{"__ignoreMap":7},[166],{"type":27,"value":159},{"type":14,"tag":143,"props":168,"children":170},{"id":169},"_1-技能信息管理",[171],{"type":27,"value":172},"1 技能信息管理",{"type":14,"tag":15,"props":174,"children":175},{},[176],{"type":27,"value":177},"unit创建时，此模块管理unit可使用哪些技能，比如游戏中玩家可以选择使用哪些技能。",{"type":14,"tag":15,"props":179,"children":180},{},[181],{"type":27,"value":182},"游戏中技能的升级、技能加点、技能池管理都在这个模块。",{"type":14,"tag":15,"props":184,"children":185},{},[186],{"type":27,"value":187},"此模块还需要管理技能等级／符文／装备等外部模块对技能参数的修改。",{"type":14,"tag":143,"props":189,"children":191},{"id":190},"_2-技能调用接口",[192],{"type":27,"value":193},"2 技能调用接口",{"type":14,"tag":15,"props":195,"children":196},{},[197],{"type":27,"value":198},"提供技能调用的接口供AI或玩家操作调用，调用时可以提供一个目标unit，也可以不提供让技能自己查找。",{"type":14,"tag":15,"props":200,"children":201},{},[202],{"type":27,"value":203},"提供三个接口：",{"type":14,"tag":108,"props":205,"children":206},{},[207,212,217],{"type":14,"tag":112,"props":208,"children":209},{},[210],{"type":27,"value":211},"技能开始skill_enter：开始执行技能，若技能不循环进行，则技能可以自动结束。",{"type":14,"tag":112,"props":213,"children":214},{},[215],{"type":27,"value":216},"技能结束skill_exit：有的技能不能自己结束，比如某些循环技能，对于循环技能玩家可以按住按钮一直释放。当玩家松开按钮，调用技能结束接口，告诉当前技能使其结束，此时技能到达后摇点时，技能不再继续执行。",{"type":14,"tag":112,"props":218,"children":219},{},[220],{"type":27,"value":221},"技能停止skill_stop：当技能被强制打断时，如被攻击、晕眩、蓝不足等，技能会被强制停止。",{"type":14,"tag":15,"props":223,"children":224},{},[225],{"type":27,"value":226},"此外，当前一个技能正在执行时新的技能调用启动，此时新的技能调用信息会被保存。一般来说，并不会把所有新的技能调用信息保存下来，那样就成了一个技能执行的序列。我们游戏仅保存一个新的技能调用信息。",{"type":14,"tag":15,"props":228,"children":229},{},[230],{"type":27,"value":231},"总的来说，技能模块提供尽量少的接口供AI/UI等上层逻辑使用，这样可以有效的与AI和UI进行解耦。",{"type":14,"tag":143,"props":233,"children":235},{"id":234},"_3-技能流程管理",[236],{"type":27,"value":237},"3 技能流程管理",{"type":14,"tag":15,"props":239,"children":240},{},[241],{"type":27,"value":242},"技能流程这里分两点讨论：",{"type":14,"tag":244,"props":245,"children":246},"ol",{},[247,252],{"type":14,"tag":112,"props":248,"children":249},{},[250],{"type":27,"value":251},"一个技能可能由多个子技能以一定的模式组合起来。\n一个技能常常由多个子技能以一定的模式组合而成，比如三段击、比如冲锋斩（先冲锋、后斩）等，甚至还存在根据不同的环境选择执行不同的子技能。分析策划需求发现，技能可以分成一个树形结构，这个树形结构非常类似行为树，同样可以将节点分为控制节点和执行节点，甚至可以包括condition节点。为此，我们项目引入一个技能树概念来描述这种数据结构。",{"type":14,"tag":112,"props":253,"children":254},{},[255],{"type":27,"value":256},"一个具体的技能（技能树执行节点）也有一个固定的执行流程。这个流程一般为：前摇过程、前摇过程结束=技能结算时间点、后摇时间点。",{"type":14,"tag":258,"props":259,"children":261},"h3",{"id":260},"_31-技能树",[262],{"type":27,"value":263},"3.1 技能树",{"type":14,"tag":15,"props":265,"children":266},{},[267],{"type":27,"value":268},"技能树参考传统行为树的设计，使用树形结构控制技能的执行流程。",{"type":14,"tag":15,"props":270,"children":271},{},[272],{"type":27,"value":273},"技能树和行为树在结构上比较类似，但是在运行逻辑上有很大的不同。",{"type":14,"tag":15,"props":275,"children":276},{},[277],{"type":27,"value":278},"首先，技能树的重点并不是根据上下文选择一个合适的节点执行，而是以一定的策略将技能树从头到尾遍历执行一遍。",{"type":14,"tag":15,"props":280,"children":281},{},[282],{"type":27,"value":283},"其次，技能树没有tick的概念，而是基于回调的，比如一个顺序节点，顺序节点中一个子节点执行完毕后，马上通知顺序节点，顺序节点执行下一个子节点，直至顺序节点的最后一个子节点执行完毕，顺序节点就会通知父节点（如果有）它已经执行完毕。",{"type":14,"tag":15,"props":285,"children":286},{},[287],{"type":27,"value":288},"此外，为了完成技能的一些需求，控制节点往往存储更多的控制信息来控制子节点的执行流程。具体的信息根据策划需求设置，比如顺序结点包括原子属性和循环属性。如果一个顺序节点具有原子属性，则这个顺树节点在执行的过程中并不会被end，只有全部子节点执行结束才可以end。",{"type":14,"tag":15,"props":290,"children":291},{},[292],{"type":27,"value":293},"以我们游戏中战士普攻三段击为例：",{"type":14,"tag":15,"props":295,"children":296},{},[297],{"type":14,"tag":19,"props":298,"children":300},{"alt":19,"src":299},"https:////upload-images.jianshu.io/upload_images/36361-5ec18bbce4b863ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/544/format/webp",[],{"type":14,"tag":15,"props":302,"children":303},{},[304],{"type":27,"value":305},"Paste_Image.png",{"type":14,"tag":15,"props":307,"children":308},{},[309],{"type":27,"value":310},"三段击本身是一个顺序节点，当技能开始时，此节点顺序执行三个子节点。对于第一个子节点，它依然是一个顺序节点，首先冲锋至目标单位身前，然后对目标单位进行挥砍。但是冲锋节点还包括了一个condition，若和目标的距离很近，则跳过冲锋节点，直接挥砍。",{"type":14,"tag":15,"props":312,"children":313},{},[314],{"type":27,"value":315},"普攻是一个循环技能，这个技能只要玩家点着按钮不放开，技能就会一直执行，因此根节点（普攻）是一个具有循环属性的顺序节点。而对于子技能1（控制节点），他是一个具有原子属性的顺序技能，即当单位正在冲锋时，玩家松开按钮，单位也会执行完挥砍后才会推出技能。",{"type":14,"tag":317,"props":318,"children":319},"hr",{},[],{"type":14,"tag":15,"props":321,"children":322},{},[323],{"type":14,"tag":33,"props":324,"children":325},{},[326],{"type":27,"value":327},"！关于技能树的使用和思考",{"type":14,"tag":15,"props":329,"children":330},{},[331],{"type":27,"value":332},"技能树开始的设计思路是，有些技能的执行流程和行为树类似，比如以一定的顺序执行一系列子技能，比如根据不同的上下文确定技能的执行流程。简单的说，技能树的引入有以下好处：1.使技能模块可以获得部分AI的能力，从而将和技能强相关的AI逻辑放在技能模块使技能模块和AI模块降低耦合，2.可以清晰的描述技能流程，3.使用树增加拓展性，策划可以设计出各种各样复杂的技能。",{"type":14,"tag":15,"props":334,"children":335},{},[336],{"type":27,"value":337},"关于好处1，举个例子：屠夫boss的勾子技能可以将玩家拉过来，若成功的拉过来，boss会执行一个攻击子技能，否则不执行。通过这样可以将勾人和攻击作为两个子技能构成技能树，攻击子技能有一个condition过程，即判断上一个子技能是否成功。",{"type":14,"tag":15,"props":339,"children":340},{},[341],{"type":27,"value":342},"技能树在使用后慢慢发现一些问题，首先，技能树的同步要求每个树节点都进行同步，增加同步负担，其次，技能本身并不会有太复杂的控制结构。",{"type":14,"tag":15,"props":344,"children":345},{},[346],{"type":27,"value":347},"为此，后来我们对技能树进行了优化：\n1.简化同步信息，不再同步所有节点的enter/exit信息（具体参考文章《技能模块的同步》）。\n2.取消并行节点，通过拓展表头实现一个技能同时执行多件事情。",{"type":14,"tag":15,"props":349,"children":350},{},[351],{"type":27,"value":352},"最终的技能树基本上是只有顺序／随机两种控制类型节点，节点拥有较轻度的condition功能。",{"type":14,"tag":317,"props":354,"children":355},{},[],{"type":14,"tag":258,"props":357,"children":359},{"id":358},"_32-执行节点的技能流程",[360],{"type":27,"value":361},"3.2 执行节点的技能流程",{"type":14,"tag":15,"props":363,"children":364},{},[365],{"type":27,"value":366},"一般来说，技能的执行流程包括：",{"type":14,"tag":108,"props":368,"children":369},{},[370,375,380],{"type":14,"tag":112,"props":371,"children":372},{},[373],{"type":27,"value":374},"前摇时间：技能开始，但是技能真正的结算流程还没开始。技能开始以后，机能相关的特效和动作就开始播放。",{"type":14,"tag":112,"props":376,"children":377},{},[378],{"type":27,"value":379},"前摇时间结束：技能前摇结束时技能开始真正的释放以及结算，等技能前摇结束以后，技能真正的释放并结算。释放包括创建相应的弹道／法术场和buff。",{"type":14,"tag":112,"props":381,"children":382},{},[383],{"type":27,"value":384},"技能后摇点：技能播放到后摇点时间时，技能真正的结束。这时，技能对应的特效以及人物动作可能还会继续播放，但是技能流程已经正式结束了。也就是说，下一个技能可以执行。",{"type":14,"tag":143,"props":386,"children":388},{"id":387},"_4-技能目标查找",[389],{"type":27,"value":390},"4 技能目标查找",{"type":14,"tag":15,"props":392,"children":393},{},[394],{"type":27,"value":395},"技能释放时，目标可能已经由AI传给了技能模块，也有可能没有一个目标，如玩家控制单位。",{"type":14,"tag":15,"props":397,"children":398},{},[399],{"type":27,"value":400},"技能在释放法术场、弹道的时候，重要的是技能的方向而不是技能目标一般来说，技能获得一个目标对象以后，技能的方向就是释法者到目标的方向。",{"type":14,"tag":15,"props":402,"children":403},{},[404],{"type":27,"value":405},"此外，技能方向可能需要一些配置，如前摇锁定（前摇过程中目标移动，技能方向不变），UI可控制（技能释放过程中，玩家可以通过控制UI控制技能的释放方向）。",{"type":14,"tag":143,"props":407,"children":409},{"id":408},"_5技能表现",[410],{"type":27,"value":411},"5技能表现",{"type":14,"tag":15,"props":413,"children":414},{},[415],{"type":27,"value":416},"技能的表现包括动作、特效、shader、音效等。其中，特效比较复杂，需要配置的内容也比较多。比如，有些特效挂在模型上，有的特效挂在场景里。对于法术场的特效，分别可以分为法术场开始、结算、结束特效，分别在法术场开始时、结算时、结束时显示。对于buff也类似。",{"type":14,"tag":143,"props":418,"children":420},{"id":419},"_6-弹道法术场和buff等技能创生体",[421],{"type":27,"value":422},"6 弹道、法术场和buff等技能创生体",{"type":14,"tag":15,"props":424,"children":425},{},[426],{"type":27,"value":427},"狭义的来说，技能只是负责技能的执行流程（技能树管理以及技能流程管理），而技能真正的结算主要是由其创生体结算的。当技能前摇结束开始生效时，技能创建相应的弹道和法术场，法术场弹道击中敌人时又有可能产生相应的buff。",{"type":14,"tag":15,"props":429,"children":430},{},[431],{"type":27,"value":432},"一般来说，法术场是一个场景的某块检测区域，每隔一段时间法术场检测此区域的敌人，并对其攻击结算。\n弹道是一类子弹移动路径的抽象，创建一个弹道就表示一个子弹特效沿这个弹道移动并检测路径上的敌人。\nbuff就是挂在单位身上的一个具有持续时间的状态，状态对单位产生一些正面或者负面的影响，并且在此段时间内，每隔一段时间进行一次伤害结算 。",{"type":14,"tag":15,"props":434,"children":435},{},[436],{"type":27,"value":437},"对于技能、法术场、buff之间的功能界定并不是很固定，比如技能能否直接对单位造成伤害，法术场能否对单位造成伤害，甚至技能只能创建法术场，法术场只能检测目标不能造成伤害，只能挂buff，而所有的伤害都是通过buff来结算。当然，这样并不一定好，一般来说，技能和法术场都可以对单位造成伤害。",{"type":14,"tag":15,"props":439,"children":440},{},[441],{"type":27,"value":442},"总之，创生体功能的界定需要根据策划需求、效率考虑等因素调整。",{"type":14,"tag":143,"props":444,"children":446},{"id":445},"_61-buff状态",[447],{"type":27,"value":448},"6.1 Buff状态",{"type":14,"tag":15,"props":450,"children":451},{},[452],{"type":27,"value":453},"Buff就是挂在单位身上持续一定时间的有益或者有害的状态，这里状态＝buff。",{"type":14,"tag":15,"props":455,"children":456},{},[457],{"type":27,"value":458},"Buff模块有个需要注意的是Buff之间的相互关系，如排斥（A状态在，B状态挂不上去），清除（A状态挂上去同时导致B状态消失）等。",{"type":14,"tag":15,"props":460,"children":461},{},[462],{"type":27,"value":463},"为了实现以上功能，最简单的方式是在状态A中直接填写状态关系状态字段，如状态A排斥状态B/C/D/E...，A状态清除状态X/Y/Z...。",{"type":14,"tag":15,"props":465,"children":466},{},[467],{"type":27,"value":468},"以上的实现方式有个问题，等游戏做到后期，我们有成千上万个buff状态，那么一个魔法免疫状态，策划需要填表的排斥状态可能成千上万。",{"type":14,"tag":15,"props":470,"children":471},{},[472],{"type":27,"value":473},"为了解决这个问题，可以使用分类的思想解决。定义某类状态和另一类状态之间的规则。\n基于以上思想，引入一个叫buff原子状态的概念，原子状态表示一类状态，如减速、禁魔、魔免、悬空、晕眩、变羊等等等。",{"type":14,"tag":15,"props":475,"children":476},{},[477],{"type":27,"value":478},"在给单位挂一个新的buff的之前，查询此buff持有的原子状态和单位身上已经有的原子状态之间的关系，根据单位身上已有的原子状态判定新的原子状态应该使用何种行为处理。",{"type":14,"tag":15,"props":480,"children":481},{},[482],{"type":27,"value":483},"此处的何种行为，代表的就是原子状态之间的规则，如排斥等。这些规则可以让策划填一个名字叫“原子状态关系”的表，此表是一个n*n的二维数组，n为游戏中所有的原子状态的数量。",{"type":14,"tag":15,"props":485,"children":486},{},[487],{"type":27,"value":488},"原子状态的数量远远小于buff的数量，所以可以很容易的定义这些规则。",{"type":14,"tag":258,"props":490,"children":492},{"id":491},"_62-法术场",[493],{"type":27,"value":494},"6.2 法术场",{"type":14,"tag":15,"props":496,"children":497},{},[498],{"type":27,"value":499},"法术场描述对一块区域的影响，这块区域可以每隔一段时间进行一次检测，检测这块区域内的单位并且对单位进行结算。",{"type":14,"tag":15,"props":501,"children":502},{},[503],{"type":27,"value":504},"法术场需要注意一个问题，就是一个法术场每次结算可能使用不同的参数进行结算，比如一个技能，第一次结算对每个单位进行晕眩，第二次结算对单位进行伤害。",{"type":14,"tag":15,"props":506,"children":507},{},[508],{"type":27,"value":509},"解决这种问题比较直接的方式是技能直接创建两个法术场，每个法术场结算一次，第二个法术场创建具有延迟时间。但是这种方式有个问题，有可能策划需求做一个结算十次而且每次结算的参数都不同的法术场。那么，一个技能以一定的时间间隔创建是个法术场，同时法术场的管理具有一定的成本，从而导致效率的降低。",{"type":14,"tag":15,"props":511,"children":512},{},[513],{"type":27,"value":514},"为解决这个问题，我们优化了法术场结算的实现机制，增加了一种新的法术场：序列法术场。这类法术场策划可以配置法术场每次结算之间的时间间隔以及每次结算所使用的法术场参数。",{"type":14,"tag":15,"props":516,"children":517},{},[518],{"type":27,"value":519},"这里所说的技能模块包括：技能流程、法术场、弹道和buff。",{"type":14,"tag":15,"props":521,"children":522},{},[523],{"type":27,"value":524},"首先介绍authority和proxy的概念，这两个概念是基于单位unit的基础上进行的区分。\nauthority表示单位的主控端，即此单位是由客户端和还是服务端控制。对于玩家avatar，玩家本地的客户端就是主控端。而对于怪物，他们的行为由服务端控制，主控端就是服务端。\nproxy表示代理端，表示被主控端控制。如对于怪物来说，所有的客户端都是proxy；对于玩家A来说，服务端和其他玩家的客户端都是proxy。",{"type":14,"tag":143,"props":526,"children":528},{"id":527},"_0-技能同步的原则",[529],{"type":27,"value":530},"0 技能同步的原则",{"type":14,"tag":15,"props":532,"children":533},{},[534],{"type":27,"value":535},"1.客户端先行\n对于玩家控制的单位来说，玩家点击按钮释放一个技能，客户端首先响应，单位播放动作以及相应的技能特效。",{"type":14,"tag":155,"props":537,"children":542},{"className":538,"code":540,"language":541,"meta":7},[539],"language-undefined","据我了解，有的已上线游戏并没有做客户端先行，而是所有的技能执行请求都发给服务端，然后由服务端发起。\n这种模式技能流程控制会比较简单，但是在网络环境差的情况下，体验可能差一些。但是，目测也是可以接受的。\n","undefined",[543],{"type":14,"tag":163,"props":544,"children":545},{"__ignoreMap":7},[546],{"type":27,"value":540},{"type":14,"tag":15,"props":548,"children":549},{},[550],{"type":27,"value":551},"2.技能流程以authority为发起端\n玩家单位技能发起是由她的客户端，怪物的技能发起是由AI也就是服务端。\n3.技能结算在服务端发起。\n技能真正的结算，比如法术场检测、buff结算、伤害结算等，统一在服务端处理。",{"type":14,"tag":143,"props":553,"children":555},{"id":554},"_1-技能执行流程的同步",[556],{"type":27,"value":557},"1 技能执行流程的同步",{"type":14,"tag":15,"props":559,"children":560},{},[561],{"type":27,"value":562},"这里所说的技能执行流程指的是技能树的一个执行节点的流程。",{"type":14,"tag":15,"props":564,"children":565},{},[566],{"type":27,"value":567},"技能流程负责动作、特效以及技能结算，其中技能结算包括：释放法术场、弹道或buff。",{"type":14,"tag":15,"props":569,"children":570},{},[571],{"type":27,"value":572},"一个技能执行节点的执行流程中，需要同步的有两个时间点：",{"type":14,"tag":108,"props":574,"children":575},{},[576,581],{"type":14,"tag":112,"props":577,"children":578},{},[579],{"type":27,"value":580},"技能开始：技能开始播放动作",{"type":14,"tag":112,"props":582,"children":583},{},[584],{"type":27,"value":585},"技能结算：前摇结束，即能进入结算逻辑。这类同步消息往往并不是由技能本身去同步，而是技能生成了法术场、弹道等，他们去做相应的同步。",{"type":14,"tag":15,"props":587,"children":588},{},[589],{"type":27,"value":590},"以玩家点击技能按钮开始释放技能为例介绍技能同步流程，如图所示：",{"type":14,"tag":15,"props":592,"children":593},{},[594],{"type":14,"tag":19,"props":595,"children":597},{"alt":19,"src":596},"https:////upload-images.jianshu.io/upload_images/36361-392299771fc34192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp",[],{"type":14,"tag":15,"props":599,"children":600},{},[601],{"type":27,"value":305},{"type":14,"tag":15,"props":603,"children":604},{},[605],{"type":27,"value":606},"1.主控端点击技能按钮，技能开始播放动作，主控端告诉服务端技能开始。\n2.服务端广播给所有的客户端(多玩家场景)，告知其他所有的客户端此玩家开始执行技能。其他客户端收到指令后可是播放技能表现。\n3.服务端延迟一段时间后，服务端开始进行技能结算，并且将结算结果通知客户端。",{"type":14,"tag":608,"props":609,"children":610},"blockquote",{},[611],{"type":14,"tag":15,"props":612,"children":613},{},[614],{"type":27,"value":615},"延迟时间=技能前摇时间-上行-下行，下行一半不能确定，所以默认为上行=下行",{"type":14,"tag":608,"props":617,"children":618},{},[619],{"type":14,"tag":15,"props":620,"children":621},{},[622],{"type":27,"value":623},"另一种中庸的计算方式是：延迟时间=技能前摇时间-上行，防止要求技能前摇时间过长",{"type":14,"tag":258,"props":625,"children":627},{"id":626},"使用此同步流程的表现为",[628],{"type":27,"value":629},"使用此同步流程的表现为：",{"type":14,"tag":15,"props":631,"children":632},{},[633],{"type":27,"value":634},"1.要求技能前摇时间>2*网络延迟，若前摇时间短，则延迟时间=0，效果可能差一些\n2.authority客户端表现完美。\n3.proxy client表现一般，即玩家A看玩家B的效果为：玩家B刚开始执行技能动作，没到前摇时间就进行了技能结算。但是因为玩家一般也不会过分关注其他玩家的动作，所以是可以接受的。",{"type":14,"tag":143,"props":636,"children":638},{"id":637},"_2-技能树的同步",[639],{"type":27,"value":640},"2 技能树的同步",{"type":14,"tag":15,"props":642,"children":643},{},[644,646,654],{"type":27,"value":645},"我上篇文章",{"type":14,"tag":647,"props":648,"children":652},"a",{"href":649,"rel":650},"https://www.jianshu.com/p/551f02f95727",[651],"nofollow",[653],{"type":27,"value":8},{"type":27,"value":655},"已经介绍，我们游戏使用的是技能树来管理技能流程。那么就面临一个问题，技能树如何同步。",{"type":14,"tag":15,"props":657,"children":658},{},[659],{"type":27,"value":660},"最简单最暴力的方式，是客户端和服务端同时管理技能树，并且将其状态同步。这样，客户端和服务端的技能树状态统一、完备。",{"type":14,"tag":15,"props":662,"children":663},{},[664],{"type":27,"value":665},"后来发现，对于proxy端，并不需要完备的技能树信息，最节省的方式是proxy根本不接受技能树同步信息，只是接受播放动作、技能结算等信息。但这样需要告诉其他proxy播放什么动作、特效等。",{"type":14,"tag":15,"props":667,"children":668},{},[669],{"type":27,"value":670},"在我们系统中，技能同步包括三类同步消息:",{"type":14,"tag":108,"props":672,"children":673},{},[674,679,684],{"type":14,"tag":112,"props":675,"children":676},{},[677],{"type":27,"value":678},"技能根节点enter (root_enter): 表示一个大技能的进入",{"type":14,"tag":112,"props":680,"children":681},{},[682],{"type":27,"value":683},"技能叶子节点enter(action_enter): 表示一个技能树的执行节点的进入。",{"type":14,"tag":112,"props":685,"children":686},{},[687],{"type":27,"value":688},"根节点exit(root_exit) ：表示大技能结束",{"type":14,"tag":15,"props":690,"children":691},{},[692],{"type":27,"value":693},"根节点保存一个完整技能的信息，需要和技能模块外部交互，因此需要知道技能的开始和结束。\n叶子节点的执行代表着技能真正的执行逻辑，也需要同步。\n而对于其他节点，作为流程控制节点，只需要在主端确保技能流程无误即可",{"type":14,"tag":608,"props":695,"children":696},{},[697],{"type":14,"tag":15,"props":698,"children":699},{},[700],{"type":27,"value":701},"后来这里进行了进一步的优化，对于纯根节点，主控端（玩家控制的客户端）将信息同步给服务端，服务端不再同步给其他客户端。有的技能树只有一个节点，那么按照叶子节点的策略，主控端同步给服务端，服务端广播给所有的其他客户端。",{"type":14,"tag":143,"props":703,"children":705},{"id":704},"_3-技能结算的同步",[706],{"type":27,"value":707},"3 技能结算的同步",{"type":14,"tag":15,"props":709,"children":710},{},[711],{"type":27,"value":712},"技能结算包括创建法术场、buff、弹道、技能直接伤害等。",{"type":14,"tag":714,"props":715,"children":717},"h4",{"id":716},"法术场弹道的同步",[718],{"type":27,"value":719},"法术场、弹道的同步",{"type":14,"tag":15,"props":721,"children":722},{},[723],{"type":27,"value":724},"法术场、弹道的同步比较类似，他们都作为一个entity（网络同步单元）在服务端创建，创建以后使用entity管理机制服务端通知客户端他们的创建和销毁。",{"type":14,"tag":15,"props":726,"children":727},{},[728],{"type":27,"value":729},"以法术场为例，法术场的执行和同步流程：",{"type":14,"tag":244,"props":731,"children":732},{},[733,738,743,748,753],{"type":14,"tag":112,"props":734,"children":735},{},[736],{"type":27,"value":737},"服务端发起创建一个法术场，并且通知客户端",{"type":14,"tag":112,"props":739,"children":740},{},[741],{"type":27,"value":742},"法术场每隔一段时间结算一次，注意，法术场结算并不需要同步，每隔一段时间服务端执行检测逻辑，客户端播放结算特效等。两个逻辑互不依赖，也不要求时间一致。",{"type":14,"tag":112,"props":744,"children":745},{},[746],{"type":27,"value":747},"当法术场结算时检测到攻击目标时，服务端计算攻击伤害等信息，并将攻击信息发给客户端。",{"type":14,"tag":112,"props":749,"children":750},{},[751],{"type":27,"value":752},"客户端收到伤害信息，客户端播放相应的表现，如法术场受击特效等。此处还包括属于通用模块的跳字等。",{"type":14,"tag":112,"props":754,"children":755},{},[756],{"type":27,"value":757},"当服务端的法术场时间到了进行destroy时，使用entity的管理机制通知所有客户端destroy法术场。",{"type":14,"tag":15,"props":759,"children":760},{},[761],{"type":27,"value":762},"弹道的同步类似，唯一的区别就是法术场在某一位置使用攻击盒检测目标，而弹道是一个移动的子弹，客户端表现是一个特效在飞，而服务端每隔一段时间根据飞行速度等使用胶囊攻击盒去检测目标碰撞。",{"type":14,"tag":15,"props":764,"children":765},{},[766],{"type":27,"value":767},"由以上可以发现，法术场作为一个entity他的管理成本是比较高的，所以若策划想出一些需求需要使用多个法术场实现，一般通过拓展法术场功能使用一个法术场来实现。",{"type":14,"tag":608,"props":769,"children":770},{},[771],{"type":14,"tag":15,"props":772,"children":773},{},[774],{"type":27,"value":775},"比如，策划要做一个冰火两重天法术场，即法术场在每次结算时使用不同的参数，第一次结算使用火焰，第二次结算是冰霜。若这种需求较少，可以使用两个法术场，但是如果要冰火雷毒水电风魔奥术神圣***N重天，则代价太大。一般可以让法术场支持每次使用不同的结算参数来结算即可。",{"type":14,"tag":714,"props":777,"children":779},{"id":778},"buff同步",[780],{"type":27,"value":778},{"type":14,"tag":15,"props":782,"children":783},{},[784],{"type":27,"value":785},"buff是附加在unit身上的东西（没有unit就没有buff，但是没有unit可能有法术场），所以不需要使用entity来同步。",{"type":14,"tag":244,"props":787,"children":788},{},[789,794],{"type":14,"tag":112,"props":790,"children":791},{},[792],{"type":27,"value":793},"服务端确定buff是否可以挂在unit上面。",{"type":14,"tag":112,"props":795,"children":796},{},[797],{"type":27,"value":798},"客户端和服务端都维护一个buff管理器，挂buff的消息通知所有客户端，客户端负责表现，服务端负责结算即可。",{"type":14,"tag":143,"props":800,"children":802},{"id":801},"_4-伤害属性的同步",[803],{"type":27,"value":804},"4 伤害、属性的同步",{"type":14,"tag":15,"props":806,"children":807},{},[808],{"type":27,"value":809},"主要介绍下伤害的同步，顺便附带介绍下属性同步。",{"type":14,"tag":15,"props":811,"children":812},{},[813],{"type":27,"value":814},"对于伤害结算来说，技能、buff、法术场和弹道都可能造成伤害，当服务端发现造成伤害时，服务端首先根据技能信息计算伤害值，计算以后将信息通过技能模块发送给所有客户端，所有客户端接到信息后首先播放技能伤害相关的表现，如受击特效等，然后播放跳字等通用伤害客户端表现。",{"type":14,"tag":15,"props":816,"children":817},{},[818],{"type":27,"value":819},"buff可能修改单位属性，如攻击力、攻击速度等。单位的属性由基础成长属性+装备属性+buff属性构成，前两个属性为面板属性，属于玩家信息。而buff属性只在战斗中有效，在面板中并没有表现。\n因此装备属性的同步需要通知逻辑服务器（真正的服务器），而buff并不需要通知逻辑服务器。",{"type":14,"tag":821,"props":822,"children":824},"h1",{"id":823},"技能说穿了只是一个流程而不该是一个实体",[825],{"type":14,"tag":33,"props":826,"children":827},{},[828],{"type":27,"value":829},"技能，说穿了只是一个流程，而不该是一个实体",{"type":14,"tag":15,"props":831,"children":832},{},[833],{"type":27,"value":834},"1、表的作用实际不是定义流程，而是提供流程中需要的数据。因此不管流程需要数据的是前端还是后端，他们都应该从一个表中调用。\n2、并不是因为把技能作为实体才导致它的混乱，真正导致混乱是的技能实体的范围扩大化了（从这个意义上说，把技能做为一个流程也没什么错，技能的承载内容应该仅仅是这个流程本身），把后续效果剥离出来会好很多。",{"type":14,"tag":15,"props":836,"children":837},{},[838],{"type":27,"value":839},"我个人的经验，不评价好坏，大概是这样的：技能的表象数据必须要有，技能效果相应的数据应该仅限于这个技能释放条件和它的直接效果（这个与表象共享技能id，所以最好也放在一起）；直接效果之外的触发效果，单独建立BUFF表，为此建立一套单独的流程，供技能调用（也就是技能效果应该是触发了某个buff）",{"type":14,"tag":143,"props":841,"children":843},{"id":842},"就skill和buff的边界问题",[844],{"type":27,"value":845},"就skill和buff的边界问题，",{"type":14,"tag":15,"props":847,"children":848},{},[849],{"type":27,"value":850},"恰好新的项目里里面我进行了一个比较新的尝试，就是抹除这个边界。 在这次的项目中，因为技能需求足够复杂，所以采用了以前一直只想没实践的想法，就是取消技能在逻辑中的的概念，或者说在基础逻辑中没有技能的设计，技能只在数据层和讨论的概念中出现。 具体的描述也很简单，所谓的技能我们都理解为 施法者一组行为和数据的组合，它包含了技能的icon，类型，动作等一系列和战斗逻辑有直接关系但没有本质关系的概念与数据的总和，用来在游戏概念中定义一个技能的所有特征。 但是在战斗中，真正发挥作用的是buff，在新的设计中，所有的参与战斗逻辑的实体都是buff。 比如 如果要实现一个火球，那么实现方式是技能数据告诉我会播放什么样的施法动画，同时丢出一个弹道，而这个弹道上附着一个buff，叫做燃烧，该buff附带特效火焰和200点的碰撞伤害（在弹道命中敌人时候）。 而这个一整个流程，在概念里，被定义为 施法者释放了一个技能，映射到现实逻辑，就是某人拿起一个石头，点燃，然后把石头丢出去砸到了某人。 至此，核心的技能结算逻辑里，彻底干掉了skill这个类，技能变成了只在概念讨论里才出现的词汇。战斗结算中，不再存在skill的概念。",{"type":14,"tag":15,"props":852,"children":853},{},[854],{"type":14,"tag":33,"props":855,"children":856},{},[857],{"type":27,"value":858},"表与脚本混合.",{"type":14,"tag":15,"props":860,"children":861},{},[862],{"type":27,"value":863},"又有两种分支,",{"type":14,"tag":15,"props":865,"children":866},{},[867],{"type":27,"value":868},"**分支一:主表副脚本,**脚本作为字段绑定于表里.表的某个字段就是技能的脚本路径.技能的主流程,框架逻辑有表的字段来决定.",{"type":14,"tag":15,"props":870,"children":871},{},[872,877],{"type":14,"tag":33,"props":873,"children":874},{},[875],{"type":27,"value":876},"分支二:主脚本副表",{"type":27,"value":878},",主逻辑,流程都是有脚本实现.技能的主流程由脚本实现.脚本读表获取数据,进行技能的操作.",{"type":14,"tag":15,"props":880,"children":881},{},[882],{"type":27,"value":883},"优点:增加奇怪技能,很方便,直接写脚本就可以了.",{"type":14,"tag":15,"props":885,"children":886},{},[887],{"type":27,"value":888},"缺点:批量处理工作量大,既要改表,又要改技能.每个技能对应独立的脚本,技能越多,脚本越多.批量处理的时候,工作量大.",{"type":14,"tag":821,"props":890,"children":892},{"id":891},"相关链接",[893],{"type":27,"value":891},{"type":14,"tag":15,"props":895,"children":896},{},[897],{"type":14,"tag":647,"props":898,"children":901},{"href":899,"rel":900},"https://zhuanlan.zhihu.com/p/147681650",[651],[902],{"type":27,"value":899},{"title":7,"searchDepth":904,"depth":904,"links":905},2,[906,907,908,909,914,915,916,917,920,921,924,925,926,927],{"id":145,"depth":904,"text":148},{"id":169,"depth":904,"text":172},{"id":190,"depth":904,"text":193},{"id":234,"depth":904,"text":237,"children":910},[911,913],{"id":260,"depth":912,"text":263},3,{"id":358,"depth":912,"text":361},{"id":387,"depth":904,"text":390},{"id":408,"depth":904,"text":411},{"id":419,"depth":904,"text":422},{"id":445,"depth":904,"text":448,"children":918},[919],{"id":491,"depth":912,"text":494},{"id":527,"depth":904,"text":530},{"id":554,"depth":904,"text":557,"children":922},[923],{"id":626,"depth":912,"text":629},{"id":637,"depth":904,"text":640},{"id":704,"depth":904,"text":707},{"id":801,"depth":904,"text":804},{"id":842,"depth":904,"text":845},"markdown","content:unity:2020-02-15-skill-system.md","content","unity/2020-02-15-skill-system.md","md","2020-02-15",[935,945,1072,1121,1173,1186,1298],{"title":936,"_path":937,"children":938},"Art","/art",[939,942],{"title":940,"_path":941},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":943,"_path":944},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":946,"_path":947,"children":948},"Dotnet","/dotnet",[949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000,1003,1006,1009,1012,1015,1018,1021,1024,1027,1030,1033,1036,1039,1042,1045,1048,1051,1054,1057,1060,1063,1066,1069],{"title":950,"_path":951},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":953,"_path":954},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":956,"_path":957},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":959,"_path":960},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":962,"_path":963},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":965,"_path":966},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":968,"_path":969},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":971,"_path":972},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":974,"_path":975},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":977,"_path":978},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":980,"_path":981},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":983,"_path":984},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":986,"_path":987},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":989,"_path":990},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":992,"_path":993},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":995,"_path":996},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":998,"_path":999},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1001,"_path":1002},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1004,"_path":1005},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1007,"_path":1008},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1010,"_path":1011},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1013,"_path":1014},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1016,"_path":1017},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1019,"_path":1020},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1022,"_path":1023},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1025,"_path":1026},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1028,"_path":1029},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1031,"_path":1032},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1034,"_path":1035},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1037,"_path":1038},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1040,"_path":1041},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1043,"_path":1044},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1046,"_path":1047},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1049,"_path":1050},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1052,"_path":1053},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1055,"_path":1056},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1058,"_path":1059},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1061,"_path":1062},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1064,"_path":1065},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1067,"_path":1068},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1070,"_path":1071},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1073,"_path":1074,"children":1075},"Game","/game",[1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118],{"title":1077,"_path":1078},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1080,"_path":1081},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1083,"_path":1084},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1086,"_path":1087},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1089,"_path":1090},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1092,"_path":1093},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1095,"_path":1096},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1098,"_path":1099},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1101,"_path":1102},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1104,"_path":1105},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1107,"_path":1108},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1110,"_path":1111},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1113,"_path":1114},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1116,"_path":1117},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1119,"_path":1120},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1122,"_path":1123,"children":1124},"Gyj","/gyj",[1125,1128,1131,1134,1137,1140,1143,1146,1149,1152,1155,1158,1161,1164,1167,1170],{"title":1126,"_path":1127},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1129,"_path":1130},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1132,"_path":1133},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1135,"_path":1136},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1138,"_path":1139},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1141,"_path":1142},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1144,"_path":1145},"玩法","/gyj/2022-08-22-wanfa",{"title":1147,"_path":1148},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1150,"_path":1151},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1153,"_path":1154},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1156,"_path":1157},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1159,"_path":1160},"门派内容相关","/gyj/2022-11-17-sect",{"title":1162,"_path":1163},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1165,"_path":1166},"种植","/gyj/2022-12-01-zhongzhi",{"title":1168,"_path":1169},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1171,"_path":1172},"跑商","/gyj/2023-11-01-paoshang",{"title":1174,"_path":1175,"children":1176},"Js","/js",[1177,1180,1183],{"title":1178,"_path":1179},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1181,"_path":1182},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1184,"_path":1185},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1187,"_path":1188,"children":1189},"Tool","/tool",[1190,1193,1196,1199,1202,1205,1208,1211,1214,1217,1220,1223,1226,1229,1232,1235,1238,1241,1244,1247,1250,1253,1256,1259,1262,1265,1268,1271,1274,1277,1280,1283,1286,1289,1292,1295],{"title":1191,"_path":1192},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1194,"_path":1195},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1197,"_path":1198},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1200,"_path":1201},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1203,"_path":1204},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1206,"_path":1207},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1209,"_path":1210},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1212,"_path":1213},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1215,"_path":1216},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1218,"_path":1219},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1221,"_path":1222},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1224,"_path":1225},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1227,"_path":1228},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1230,"_path":1231},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1233,"_path":1234},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1236,"_path":1237},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1239,"_path":1240},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1242,"_path":1243},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1245,"_path":1246},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1248,"_path":1249},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1251,"_path":1252},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1254,"_path":1255},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1257,"_path":1258},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1260,"_path":1261},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1263,"_path":1264},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1266,"_path":1267},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1269,"_path":1270},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1272,"_path":1273},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1275,"_path":1276},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1278,"_path":1279},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1281,"_path":1282},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1284,"_path":1285},"rider的使用","/tool/2022-08-02-rider-use",{"title":1287,"_path":1288},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1290,"_path":1291},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1293,"_path":1294},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1296,"_path":1297},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1299,"_path":1300,"children":1301},"Unity","/unity",[1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1363,1366,1369,1372,1375,1378,1381,1384,1387,1390,1393,1396,1399,1402,1405,1408,1411,1414,1417,1420,1423,1426,1429,1432,1435,1438,1441,1444,1447,1450,1453,1456,1459,1462,1465,1468,1471,1474,1477,1480,1483,1486,1489,1492,1495,1498,1501,1504,1507,1510,1513],{"title":1303,"_path":1304},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1306,"_path":1307},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1309,"_path":1310},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1312,"_path":1313},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1315,"_path":1316},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1318,"_path":1319},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1321,"_path":1322},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1324,"_path":1325},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1327,"_path":1328},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1330,"_path":1331},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1333,"_path":1334},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1336,"_path":1337},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1339,"_path":1340},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1342,"_path":1343},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1345,"_path":1346},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1348,"_path":1349},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1351,"_path":1352},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1354,"_path":1355},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1357,"_path":1358},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1360,"_path":1361},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":8,"_path":4},{"title":1364,"_path":1365},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1367,"_path":1368},"角色状态设计","/unity/2020-02-17-character-states",{"title":1370,"_path":1371},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1373,"_path":1374},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1376,"_path":1377},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1379,"_path":1380},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1382,"_path":1383},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1385,"_path":1386},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1388,"_path":1389},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1391,"_path":1392},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1394,"_path":1395},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1397,"_path":1398},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1400,"_path":1401},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1403,"_path":1404},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1406,"_path":1407},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1409,"_path":1410},"unity的addressables","/unity/2020-09-12-addressables",{"title":1412,"_path":1413},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1415,"_path":1416},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1418,"_path":1419},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1421,"_path":1422},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1424,"_path":1425},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1427,"_path":1428},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1430,"_path":1431},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1433,"_path":1434},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1436,"_path":1437},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1439,"_path":1440},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1442,"_path":1443},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1445,"_path":1446},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1448,"_path":1449},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1451,"_path":1452},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1454,"_path":1455},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1457,"_path":1458},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1460,"_path":1461},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1463,"_path":1464},"ability","/unity/2020-11-16-dotssample",{"title":1466,"_path":1467},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1469,"_path":1470},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1472,"_path":1473},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1475,"_path":1476},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1478,"_path":1479},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1481,"_path":1482},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1484,"_path":1485},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1487,"_path":1488},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1490,"_path":1491},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1493,"_path":1494},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1496,"_path":1497},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1499,"_path":1500},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1502,"_path":1503},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1505,"_path":1506},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1508,"_path":1509},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1511,"_path":1512},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1514,"_path":1515},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779040501]