[{"data":1,"prerenderedAt":1612},["Reactive",2],{"content-query-7yC0O413HK":3,"content-navigation-8C37fagqQL":1030},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1024,"_id":1025,"_source":1026,"_file":1027,"_extension":1028,"date":1029},"/unity/2019-08-10-ugui-recttransform","unity",false,"","一次精通 RectTransform","在編輯器中快速設定 RectTransform快速控制器的基本操作我們就不在這裡贅述，基本上都可以在 Unity 網站裡找到很好的教學文件與影片。RectTransform 的控制精髓：錨點們 Anchor Points在透過快速設定器修改 RectTransform 的過程中，你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖：Pos X 與 Left、Pos Y 與 Top、Width 與 Right、Height 與 Bottom 這四對屬性個別不會同時出現，有 Pos X 就沒有 Left，有 Width 就沒有 Right，那麼他們出現的規則是什麼呢？簡單來說其實就是：「當兩個",{"type":11,"children":12,"toc":1003},"root",[13,22,28,36,42,47,54,59,64,69,88,93,100,105,116,122,127,138,144,149,160,166,171,182,188,193,198,208,218,228,248,255,260,268,273,281,286,294,299,304,309,314,322,327,335,340,390,409,422,440,455,462,477,484,490,540,547,554,559,564,569,574,584,590,595,601,606,615,631,654,665,674,679,684,705,713,721,729,739,747,752,760,768,773,781,789,797,802,812,820,833,841,846,854,862,870,882,890,898,903,909,917,924,929,936,942,947,952,960,965,973,978],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"在編輯器中快速設定-recttransform",[19],{"type":20,"value":21},"text","在編輯器中快速設定 RectTransform",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":27},"快速控制器的基本操作我們就不在這裡贅述，基本上都可以在 Unity 網站裡找到很好的教學文件與影片。",{"type":14,"tag":23,"props":29,"children":30},{},[31],{"type":14,"tag":32,"props":33,"children":35},"img",{"alt":32,"src":34},"/images/2019-08-10-ugui-RectTransform/4B112FCB-1D5E-41FC-A19D-AA5322C52414.png",[],{"type":14,"tag":15,"props":37,"children":39},{"id":38},"recttransform-的控制精髓錨點們-anchor-points",[40],{"type":20,"value":41},"RectTransform 的控制精髓：錨點們 Anchor Points",{"type":14,"tag":23,"props":43,"children":44},{},[45],{"type":20,"value":46},"在透過快速設定器修改 RectTransform 的過程中，你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖：",{"type":14,"tag":23,"props":48,"children":49},{},[50],{"type":14,"tag":32,"props":51,"children":53},{"alt":32,"src":52},"/images/2019-08-10-ugui-RectTransform/B30BC54C-DA7C-4882-9B3C-FA194FE9ACA5.png",[],{"type":14,"tag":23,"props":55,"children":56},{},[57],{"type":20,"value":58},"Pos X 與 Left、Pos Y 與 Top、Width 與 Right、Height 與 Bottom 這四對屬性個別不會同時出現，有 Pos X 就沒有 Left，有 Width 就沒有 Right，那麼他們出現的規則是什麼呢？",{"type":14,"tag":23,"props":60,"children":61},{},[62],{"type":20,"value":63},"簡單來說其實就是：",{"type":14,"tag":23,"props":65,"children":66},{},[67],{"type":20,"value":68},"「當兩個錨點的某一維度值相等時，該維度的尺寸則是固定的（跟 Parent 尺寸無關），反之該維度的尺寸則是相對於 Parent 的尺寸而變化。」",{"type":14,"tag":23,"props":70,"children":71},{},[72,74,80,82,86],{"type":20,"value":73},"其實全部都取決於控制 ",{"type":14,"tag":75,"props":76,"children":77},"em",{},[78],{"type":20,"value":79},"RectTransform",{"type":20,"value":81}," 型態最重要的屬性「最大與最小錨點們（Min / Max Anchors）」，而快速設定器其實也只是在幫你快速的調整這兩個錨點的值，所以只要了解這兩個設定值關係與行為，其實你已經完全掌握了 ",{"type":14,"tag":75,"props":83,"children":84},{},[85],{"type":20,"value":79},{"type":20,"value":87}," ，而依照上述邏輯，透過兩個錨點所產生出的配置型態總共有四種：",{"type":14,"tag":23,"props":89,"children":90},{},[91],{"type":20,"value":92},"A. 當兩錨點 x, y 維度的值都相等時。\nB. 當兩錨點 x 維度的值不相等、y 維度值相等時。\nC. 當兩錨點 x 維度的值相等、y 維度值不相等時。\nD. 當兩錨點 x, y 維度的值都不相等時。",{"type":14,"tag":94,"props":95,"children":97},"h3",{"id":96},"a-當兩錨點-x-y-維度的值都相等時",[98],{"type":20,"value":99},"A. 當兩錨點 x, y 維度的值都相等時：",{"type":14,"tag":23,"props":101,"children":102},{},[103],{"type":20,"value":104},"當兩錨點 x, y 值都相等時，代表此物件的寬高尺寸都是固定值，所以我們會透過 PosX、PosY、Width 以及 Height 來定義此物件的顯示方式，PosX 與 PosY 則分別表示錨點到物件 Pivot 點的位移，而此物件的實際顯示區域則會受到 Pivot 的 x, y 值設定所影響。",{"type":14,"tag":23,"props":106,"children":107},{},[108,112],{"type":14,"tag":32,"props":109,"children":111},{"alt":32,"src":110},"/images/2019-08-10-ugui-RectTransform/static-anchors.png",[],{"type":14,"tag":32,"props":113,"children":115},{"alt":32,"src":114},"/images/2019-08-10-ugui-RectTransform/ezgif-1-eea893f81f2e.gif",[],{"type":14,"tag":94,"props":117,"children":119},{"id":118},"b-當兩錨點-x-維度的值不相等y-維度值相等時",[120],{"type":20,"value":121},"B. 當兩錨點 x 維度的值不相等、y 維度值相等時：",{"type":14,"tag":23,"props":123,"children":124},{},[125],{"type":20,"value":126},"當兩錨點 x 維度的值不相等、y 維度值相等時，代表 x 維度的尺寸會受到 Parent 的尺寸影響，在 x 維度上則是使用間距（Padding）的概念來排版，所以會用到 Left、PosY、Right 以及 Height，實際的 Width 是由 Left 與 Right 來控制。",{"type":14,"tag":23,"props":128,"children":129},{},[130,134],{"type":14,"tag":32,"props":131,"children":133},{"alt":32,"src":132},"/images/2019-08-10-ugui-RectTransform/anchor_x1.png",[],{"type":14,"tag":32,"props":135,"children":137},{"alt":32,"src":136},"/images/2019-08-10-ugui-RectTransform/anchor_x.gif",[],{"type":14,"tag":94,"props":139,"children":141},{"id":140},"c-當兩錨點-x-維度的值相等y-維度值不相等時",[142],{"type":20,"value":143},"C. 當兩錨點 x 維度的值相等、y 維度值不相等時：",{"type":14,"tag":23,"props":145,"children":146},{},[147],{"type":20,"value":148},"當兩錨點 x 維度的值相等、y 維度值不相等時，代表 y 維度的尺寸會受到 Parent 的尺寸影響，在 y 維度上則是使用間距（Padding）的概念來排版，所以會用到 PosX、Top、Width 以及 Bottom，實際的 Height 是由 Top 與 Bottom 來控制。",{"type":14,"tag":23,"props":150,"children":151},{},[152,156],{"type":14,"tag":32,"props":153,"children":155},{"alt":32,"src":154},"/images/2019-08-10-ugui-RectTransform/anchor_y1.png",[],{"type":14,"tag":32,"props":157,"children":159},{"alt":32,"src":158},"/images/2019-08-10-ugui-RectTransform/anchor_y.gif",[],{"type":14,"tag":94,"props":161,"children":163},{"id":162},"d-當兩錨點-x-y-維度的值都不相等時",[164],{"type":20,"value":165},"D. 當兩錨點 x, y 維度的值都不相等時：",{"type":14,"tag":23,"props":167,"children":168},{},[169],{"type":20,"value":170},"當兩錨點 x, y 維度的值都不相等時，代表物件的寬高尺寸都會受到 Parent 的影響，完全是使用四個方向的間距來定義此物件的顯示區域 Left、Top、Right 以及 Bottom。",{"type":14,"tag":23,"props":172,"children":173},{},[174,178],{"type":14,"tag":32,"props":175,"children":177},{"alt":32,"src":176},"/images/2019-08-10-ugui-RectTransform/anchor_xy.png",[],{"type":14,"tag":32,"props":179,"children":181},{"alt":32,"src":180},"/images/2019-08-10-ugui-RectTransform/anchor_xy.gif",[],{"type":14,"tag":183,"props":184,"children":186},"h1",{"id":185},"一些术语解释",[187],{"type":20,"value":185},{"type":14,"tag":94,"props":189,"children":191},{"id":190},"pivot",[192],{"type":20,"value":190},{"type":14,"tag":23,"props":194,"children":195},{},[196],{"type":20,"value":197},"物體自身的支點，影響物體的旋轉、縮放、位置，改變 UI Pivot 必須先開啟控制面板的 Pivot 按鈕，如下圖",{"type":14,"tag":23,"props":199,"children":200},{},[201,206],{"type":14,"tag":32,"props":202,"children":205},{"alt":203,"src":204},"Pivot_01","/images/2019-08-10-ugui-RectTransform/Pivot_01.png",[],{"type":20,"value":207},"，",{"type":14,"tag":23,"props":209,"children":210},{},[211,213],{"type":20,"value":212},"Pivot (0.5, 0.5)\n",{"type":14,"tag":32,"props":214,"children":217},{"alt":215,"src":216},"Pivot_02","/images/2019-08-10-ugui-RectTransform/Pivot_02.gif",[],{"type":14,"tag":23,"props":219,"children":220},{},[221,223],{"type":20,"value":222},"Pivot (0, 1)\n",{"type":14,"tag":32,"props":224,"children":227},{"alt":225,"src":226},"Pivot_03","/images/2019-08-10-ugui-RectTransform/Pivot_03.gif",[],{"type":14,"tag":23,"props":229,"children":230},{},[231,233,239,241,246],{"type":20,"value":232},"它是一个X,Y值范围是0到1的点，这个点的会在",{"type":14,"tag":234,"props":235,"children":236},"strong",{},[237],{"type":20,"value":238},"Anchor",{"type":20,"value":240},"（锚点）计算位置的时候会使用到，下面用一张图来解释",{"type":14,"tag":234,"props":242,"children":243},{},[244],{"type":20,"value":245},"Pivot",{"type":20,"value":247},"点的位置",{"type":14,"tag":23,"props":249,"children":250},{},[251],{"type":14,"tag":32,"props":252,"children":254},{"alt":32,"src":253},"/images/2019-08-10-ugui-RectTransform/84177-b27df7bbe9d3c829.webp",[],{"type":14,"tag":23,"props":256,"children":257},{},[258],{"type":20,"value":259},"pivot和text的填充",{"type":14,"tag":23,"props":261,"children":262},{},[263],{"type":14,"tag":32,"props":264,"children":267},{"alt":265,"src":266},"image-20200420000104602","/images/2019-08-10-ugui-RectTransform/image-20200420000104602.png",[],{"type":14,"tag":23,"props":269,"children":270},{},[271],{"type":20,"value":272},"当pivot为0.5和0.5时数字的填充时以中心点向上下方向扩展rect",{"type":14,"tag":23,"props":274,"children":275},{},[276],{"type":14,"tag":32,"props":277,"children":280},{"alt":278,"src":279},"image-20200420000313192","/images/2019-08-10-ugui-RectTransform/image-20200420000313192.png",[],{"type":14,"tag":23,"props":282,"children":283},{},[284],{"type":20,"value":285},"一般来讲,动态改变文本,为了使其按照从上到下,可以把pivot设置在左上角  0,1",{"type":14,"tag":23,"props":287,"children":288},{},[289],{"type":14,"tag":32,"props":290,"children":293},{"alt":291,"src":292},"image-20200420000549965","/images/2019-08-10-ugui-RectTransform/image-20200420000549965.png",[],{"type":14,"tag":23,"props":295,"children":296},{},[297],{"type":20,"value":298},"点击上方的pivot可以切换pivot的所在位置",{"type":14,"tag":23,"props":300,"children":301},{},[302],{"type":20,"value":303},"center 的中心点",{"type":14,"tag":23,"props":305,"children":306},{},[307],{"type":20,"value":308},"pivot的点所在位置",{"type":14,"tag":23,"props":310,"children":311},{},[312],{"type":20,"value":313},"这同样适用于layout,下图设置成0,1.在中间位置添加panel,他会向下扩充,加上verticallayoutgroup和contentsizefitter两个组件",{"type":14,"tag":23,"props":315,"children":316},{},[317],{"type":14,"tag":32,"props":318,"children":321},{"alt":319,"src":320},"image-20200420013535477","/images/2019-08-10-ugui-RectTransform/image-20200420013535477.png",[],{"type":14,"tag":23,"props":323,"children":324},{},[325],{"type":20,"value":326},"设置成0.5,0.5.他会向上下扩充",{"type":14,"tag":23,"props":328,"children":329},{},[330],{"type":14,"tag":32,"props":331,"children":334},{"alt":332,"src":333},"image-20200420013708207","/images/2019-08-10-ugui-RectTransform/image-20200420013708207.png",[],{"type":14,"tag":94,"props":336,"children":338},{"id":337},"位置",[339],{"type":20,"value":337},{"type":14,"tag":341,"props":342,"children":343},"ul",{},[344,357,368,379],{"type":14,"tag":345,"props":346,"children":347},"li",{},[348,355],{"type":14,"tag":349,"props":350,"children":352},"code",{"className":351},[],[353],{"type":20,"value":354},"position",{"type":20,"value":356},"世界坐标是三维的全局坐标,一般作为基准坐标",{"type":14,"tag":345,"props":358,"children":359},{},[360,366],{"type":14,"tag":349,"props":361,"children":363},{"className":362},[],[364],{"type":20,"value":365},"localPosition",{"type":20,"value":367}," 相对于父级物体的相对位置",{"type":14,"tag":345,"props":369,"children":370},{},[371,377],{"type":14,"tag":349,"props":372,"children":374},{"className":373},[],[375],{"type":20,"value":376},"anchoredPosition",{"type":20,"value":378}," 相对位置，但是相对的是自身的Anchor",{"type":14,"tag":345,"props":380,"children":381},{},[382,388],{"type":14,"tag":349,"props":383,"children":385},{"className":384},[],[386],{"type":20,"value":387},"anchoredPosition3D",{"type":20,"value":389},"  相对位置，但是相对的是自身的Anchor",{"type":14,"tag":23,"props":391,"children":392},{},[393,395,400,402,407],{"type":20,"value":394},"关于",{"type":14,"tag":349,"props":396,"children":398},{"className":397},[],[399],{"type":20,"value":354},{"type":20,"value":401},"和",{"type":14,"tag":349,"props":403,"children":405},{"className":404},[],[406],{"type":20,"value":365},{"type":20,"value":408},"，它们的值根其所属的Canvas的渲染模式有关。",{"type":14,"tag":341,"props":410,"children":411},{},[412,417],{"type":14,"tag":345,"props":413,"children":414},{},[415],{"type":20,"value":416},"在Screen Space——Overlay的模式下，由于Canvas的世界尺寸与其像素尺寸在数值上相等，因此其rectTransform的position与其在屏幕空间的坐标在数值上也相等。这种模式下，要获取某个RectTransform的屏幕坐标，直接使用position就可以。",{"type":14,"tag":345,"props":418,"children":419},{},[420],{"type":20,"value":421},"在Screen Space——Camera的模式和World Space下，RectTransform的渲染与摄像机有关，在获取其屏幕坐标时，需要利用canvas.worldCamera，或者transform.TransformPoint等坐标转换函数进行坐标转换。",{"type":14,"tag":23,"props":423,"children":424},{},[425,426,431,432,438],{"type":20,"value":394},{"type":14,"tag":349,"props":427,"children":429},{"className":428},[],[430],{"type":20,"value":376},{"type":20,"value":401},{"type":14,"tag":349,"props":433,"children":435},{"className":434},[],[436],{"type":20,"value":437},"anchoredPositoin3D",{"type":20,"value":439},"都可以认为是以像素为单位。",{"type":14,"tag":341,"props":441,"children":442},{},[443],{"type":14,"tag":345,"props":444,"children":445},{},[446,448,453],{"type":20,"value":447},"当锚点全部重合时，",{"type":14,"tag":349,"props":449,"children":451},{"className":450},[],[452],{"type":20,"value":376},{"type":20,"value":454},"代表的就是自身Pivot到Anchor的向量。",{"type":14,"tag":23,"props":456,"children":457},{},[458],{"type":14,"tag":32,"props":459,"children":461},{"alt":7,"src":460},"/images/2019-08-10-ugui-RectTransform/20171218185814418.png",[],{"type":14,"tag":341,"props":463,"children":464},{},[465],{"type":14,"tag":345,"props":466,"children":467},{},[468,470,475],{"type":20,"value":469},"当Anchor不重合时,Pivot相对于四个锚点",{"type":14,"tag":234,"props":471,"children":472},{},[473],{"type":20,"value":474},"中点",{"type":20,"value":476},"的坐标",{"type":14,"tag":23,"props":478,"children":479},{},[480],{"type":14,"tag":32,"props":481,"children":483},{"alt":7,"src":482},"/images/2019-08-10-ugui-RectTransform/20171218185822581.png",[],{"type":14,"tag":94,"props":485,"children":487},{"id":486},"offsetmin-和-offsetmax",[488],{"type":20,"value":489},"offsetMin 和 offsetMax",{"type":14,"tag":23,"props":491,"children":492},{},[493,499,501,506,508,513,515,521,522,527,528,533,535],{"type":14,"tag":349,"props":494,"children":496},{"className":495},[],[497],{"type":20,"value":498},"offsetMax",{"type":20,"value":500},"是",{"type":14,"tag":234,"props":502,"children":503},{},[504],{"type":20,"value":505},"RectTransform右上角",{"type":20,"value":507},"相对于",{"type":14,"tag":234,"props":509,"children":510},{},[511],{"type":20,"value":512},"右上Anchor",{"type":20,"value":514},"的距离；",{"type":14,"tag":349,"props":516,"children":518},{"className":517},[],[519],{"type":20,"value":520},"offsetMin",{"type":20,"value":500},{"type":14,"tag":234,"props":523,"children":524},{},[525],{"type":20,"value":526},"RectTransform左下角",{"type":20,"value":507},{"type":14,"tag":234,"props":529,"children":530},{},[531],{"type":20,"value":532},"左下Anchor",{"type":20,"value":534},"的距离。",{"type":14,"tag":75,"props":536,"children":537},{},[538],{"type":20,"value":539},"這就是為什麼 offsetMax 的值跟編輯器中 Top、Right 值剛好正負相反的原因。",{"type":14,"tag":23,"props":541,"children":542},{},[543],{"type":14,"tag":32,"props":544,"children":546},{"alt":32,"src":545},"/images/2019-08-10-ugui-RectTransform/84177-3bd3ac83352a431b.webp",[],{"type":14,"tag":23,"props":548,"children":549},{},[550],{"type":14,"tag":32,"props":551,"children":553},{"alt":32,"src":552},"/images/2019-08-10-ugui-RectTransform/84177-6feb68ae67ceaae8.webp",[],{"type":14,"tag":94,"props":555,"children":557},{"id":556},"rect",[558],{"type":20,"value":556},{"type":14,"tag":23,"props":560,"children":561},{},[562],{"type":20,"value":563},"如果想要获取一个RectTransform的矩形信息，应该使用rectTransform.rect属性。",{"type":14,"tag":23,"props":565,"children":566},{},[567],{"type":20,"value":568},"rect属性同样是一个计算出来的值，但是它表示的是该rectTransform对应的矩形的相关信息。",{"type":14,"tag":23,"props":570,"children":571},{},[572],{"type":20,"value":573},"rect 的 x 和 y 返回左下角相对于pivot的距离,w 和 h 返回本身的宽高.",{"type":14,"tag":23,"props":575,"children":576},{},[577,579],{"type":20,"value":578},"注意:",{"type":14,"tag":234,"props":580,"children":581},{},[582],{"type":20,"value":583},"Awake中Rectangle还没有初始化出来,所以不要在awake中获取rect",{"type":14,"tag":94,"props":585,"children":587},{"id":586},"anchormin-和-anchormax",[588],{"type":20,"value":589},"anchorMin 和 anchorMax",{"type":14,"tag":23,"props":591,"children":592},{},[593],{"type":20,"value":594},"这个是针对锚点的,锚点时相对于父容器定义的,所以这两个属性也是相对于父容器的.分别指锚点占父容器尺寸的百分比位置.",{"type":14,"tag":94,"props":596,"children":598},{"id":597},"sizedelta",[599],{"type":20,"value":600},"sizeDelta",{"type":14,"tag":23,"props":602,"children":603},{},[604],{"type":20,"value":605},"sizeDelta是个由引擎计算出来的值，这个值很容易被错误地使用。要正确地使用sizeDelta，就要先理解它是怎么算出来的。",{"type":14,"tag":607,"props":608,"children":609},"blockquote",{},[610],{"type":14,"tag":23,"props":611,"children":612},{},[613],{"type":20,"value":614},"The size of this RectTransform relative to the distances between the anchors.\nIf the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent.",{"type":14,"tag":23,"props":616,"children":617},{},[618,622,623,629],{"type":14,"tag":75,"props":619,"children":620},{},[621],{"type":20,"value":600},{"type":20,"value":500},{"type":14,"tag":349,"props":624,"children":626},{"className":625},[],[627],{"type":20,"value":628},"offsetMax-offsetMin",{"type":20,"value":630},"的结果。在锚点全部重合的情况下，它的值就是面板上的*（Width，Height）*。在锚点完全不重合的情况下，它是相对于父矩形的尺寸。",{"type":14,"tag":23,"props":632,"children":633},{},[634,636,640,642,646,648,652],{"type":20,"value":635},"一个常见的错误是，当",{"type":14,"tag":75,"props":637,"children":638},{},[639],{"type":20,"value":79},{"type":20,"value":641},"的锚点并非全部重合时，使用",{"type":14,"tag":75,"props":643,"children":644},{},[645],{"type":20,"value":600},{"type":20,"value":647},"作为这个",{"type":14,"tag":75,"props":649,"children":650},{},[651],{"type":20,"value":79},{"type":20,"value":653},"的尺寸。此时拿到的结果一般来说并非预期的结果。",{"type":14,"tag":23,"props":655,"children":656},{},[657,659,663],{"type":20,"value":658},"所以 ",{"type":14,"tag":75,"props":660,"children":661},{},[662],{"type":20,"value":79},{"type":20,"value":664}," 宽和高真正的計算方法是:",{"type":14,"tag":666,"props":667,"children":669},"pre",{"code":668},"GUI.Label(new Rect(20, 20, 600, 40), \"Rect : \" + rect.rect);\nvar width =  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;\nvar height = (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;\nGUI.Label(new Rect(20, 60, 600, 40), $\"width :{width} height:{height} \");\n",[670],{"type":14,"tag":349,"props":671,"children":672},{"__ignoreMap":7},[673],{"type":20,"value":668},{"type":14,"tag":23,"props":675,"children":676},{},[677],{"type":20,"value":678},"意思就是 sizeDelta 個別維度的值是跟兩錨點個別維度的差值相關，所以只有當兩錨點某的維度的值相等的時候，sizeDelta 在此維度的值才會剛好等於最後顯示的 size 大小。",{"type":14,"tag":183,"props":680,"children":682},{"id":681},"代码修改坐标及大小",[683],{"type":20,"value":681},{"type":14,"tag":23,"props":685,"children":686},{},[687,692,694,698,699,703],{"type":14,"tag":234,"props":688,"children":689},{},[690],{"type":20,"value":691},"1.改变RectTransform的top",{"type":20,"value":693}," 注意offsetMax`是",{"type":14,"tag":234,"props":695,"children":696},{},[697],{"type":20,"value":505},{"type":20,"value":507},{"type":14,"tag":234,"props":700,"children":701},{},[702],{"type":20,"value":512},{"type":20,"value":704},"的距离,所以top的值应该是一个负值",{"type":14,"tag":666,"props":706,"children":708},{"code":707},"GetComponent\u003CRectTransform>().offsetMax = new Vector2(GetComponent\u003CRectTransform>().offsetMax.x, top);\n",[709],{"type":14,"tag":349,"props":710,"children":711},{"__ignoreMap":7},[712],{"type":20,"value":707},{"type":14,"tag":23,"props":714,"children":715},{},[716],{"type":14,"tag":234,"props":717,"children":718},{},[719],{"type":20,"value":720},"2.改变RectTransform的bottom",{"type":14,"tag":666,"props":722,"children":724},{"code":723},"GetComponent\u003CRectTransform>().offsetMin = new Vector2(GetComponent\u003CRectTransform>().offsetMin.x, bottom);\n",[725],{"type":14,"tag":349,"props":726,"children":727},{"__ignoreMap":7},[728],{"type":20,"value":723},{"type":14,"tag":23,"props":730,"children":731},{},[732,737],{"type":14,"tag":234,"props":733,"children":734},{},[735],{"type":20,"value":736},"3.改变RectTransform的width，height",{"type":20,"value":738}," ,会根据上面的计算公式重新计算得出width和height,所以如果锚点不是在同一个点的情况下,你设置的值和实际的值是有很大区别的",{"type":14,"tag":666,"props":740,"children":742},{"code":741},"GetComponent\u003CRectTransform>().sizeDelta = new Vector2(width, height);\n",[743],{"type":14,"tag":349,"props":744,"children":745},{"__ignoreMap":7},[746],{"type":20,"value":741},{"type":14,"tag":23,"props":748,"children":749},{},[750],{"type":20,"value":751},"例如:",{"type":14,"tag":23,"props":753,"children":754},{},[755],{"type":14,"tag":32,"props":756,"children":759},{"alt":757,"src":758},"1566677675284","/images/2019-08-10-ugui-RectTransform/1566677675284.png",[],{"type":14,"tag":23,"props":761,"children":762},{},[763],{"type":14,"tag":32,"props":764,"children":767},{"alt":765,"src":766},"1566678423941","/images/2019-08-10-ugui-RectTransform/1566678423941.png",[],{"type":14,"tag":23,"props":769,"children":770},{},[771],{"type":20,"value":772},"当使用脚本直接改变大小后",{"type":14,"tag":666,"props":774,"children":776},{"code":775},"rect.sizeDelta = new Vector2(750, 200);\n",[777],{"type":14,"tag":349,"props":778,"children":779},{"__ignoreMap":7},[780],{"type":20,"value":775},{"type":14,"tag":23,"props":782,"children":783},{},[784],{"type":14,"tag":32,"props":785,"children":788},{"alt":786,"src":787},"1566677736663","/images/2019-08-10-ugui-RectTransform/1566677736663.png",[],{"type":14,"tag":666,"props":790,"children":792},{"code":791},"var width =  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;\nvar height = (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;\n",[793],{"type":14,"tag":349,"props":794,"children":795},{"__ignoreMap":7},[796],{"type":20,"value":791},{"type":14,"tag":23,"props":798,"children":799},{},[800],{"type":20,"value":801},"他的宽和高经过了运算使其分别为1500,1534",{"type":14,"tag":23,"props":803,"children":804},{},[805,810],{"type":14,"tag":234,"props":806,"children":807},{},[808],{"type":20,"value":809},"4.改变RectTransform的pos",{"type":20,"value":811}," 注意anchoredPosition是相对于锚点的位置",{"type":14,"tag":666,"props":813,"children":815},{"code":814},"GetComponent\u003CRectTransform>().anchoredPosition3D = new Vector3(posx,posy,posz);\nGetComponent\u003CRectTransform>().anchoredPosition = new Vector2(posx,posy);\n",[816],{"type":14,"tag":349,"props":817,"children":818},{"__ignoreMap":7},[819],{"type":20,"value":814},{"type":14,"tag":23,"props":821,"children":822},{},[823,825,831],{"type":20,"value":824},"**5.使用SetSizeWithCurrentAnchors函数来进行设定，其中Horizontal和Vertical分别对应宽和高。此函数受当前锚点和中心点的影响。**由于会受到",{"type":14,"tag":349,"props":826,"children":828},{"className":827},[],[829],{"type":20,"value":830},"povit",{"type":20,"value":832},"的影响设置的高度是根据povit进行上下缩小的",{"type":14,"tag":666,"props":834,"children":836},{"code":835},"var rt = gameObject.GetComponent\u003CRectTransform>();\nrt.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 100);\nrt.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 30);\n",[837],{"type":14,"tag":349,"props":838,"children":839},{"__ignoreMap":7},[840],{"type":20,"value":835},{"type":14,"tag":23,"props":842,"children":843},{},[844],{"type":20,"value":845},"上面同样的示例:",{"type":14,"tag":23,"props":847,"children":848},{},[849],{"type":14,"tag":32,"props":850,"children":853},{"alt":851,"src":852},"1566678433363","/images/2019-08-10-ugui-RectTransform/1566678433363.png",[],{"type":14,"tag":666,"props":855,"children":857},{"code":856},"rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 200);\n",[858],{"type":14,"tag":349,"props":859,"children":860},{"__ignoreMap":7},[861],{"type":20,"value":856},{"type":14,"tag":23,"props":863,"children":864},{},[865],{"type":14,"tag":32,"props":866,"children":869},{"alt":867,"src":868},"1566678329701","/images/2019-08-10-ugui-RectTransform/1566678329701.png",[],{"type":14,"tag":23,"props":871,"children":872},{},[873,875,880],{"type":20,"value":874},"可以看到它围绕着",{"type":14,"tag":349,"props":876,"children":878},{"className":877},[],[879],{"type":20,"value":190},{"type":20,"value":881},"上下都缩减了180",{"type":14,"tag":23,"props":883,"children":884},{},[885],{"type":14,"tag":234,"props":886,"children":887},{},[888],{"type":20,"value":889},"6.使用SetInsetAndSizeFromParentEdge函数来进行设定。此函数不受锚点和中心的影响，其中第一个参数代表对齐方式，第二个参数为距离边界的距离，第三个参数为宽度。",{"type":14,"tag":666,"props":891,"children":893},{"code":892},"var rt = gameObject.GetComponent\u003CRectTransform>();\nrt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Right, 0, 100);\nrt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Bottom, 0, 30);\n",[894],{"type":14,"tag":349,"props":895,"children":896},{"__ignoreMap":7},[897],{"type":20,"value":892},{"type":14,"tag":183,"props":899,"children":901},{"id":900},"recttransform的一些其他操做",[902],{"type":20,"value":900},{"type":14,"tag":94,"props":904,"children":906},{"id":905},"blue-print-mode藍圖模式-raw-edit-mode原始编辑模式",[907],{"type":20,"value":908},"Blue Print Mode(藍圖模式) 、 Raw Edit Mode(原始编辑模式)",{"type":14,"tag":15,"props":910,"children":911},{"id":7},[912],{"type":14,"tag":32,"props":913,"children":916},{"alt":914,"src":915},"BluePrint_RawEdit_01","/images/2019-08-10-ugui-RectTransform/BluePrint_RawEdit_01.png",[],{"type":14,"tag":918,"props":919,"children":921},"h4",{"id":920},"blue-print-mode-藍圖模式",[922],{"type":20,"value":923},"Blue Print Mode (藍圖模式)",{"type":14,"tag":23,"props":925,"children":926},{},[927],{"type":20,"value":928},"忽略了物體的 Local Rotation 和 Local Scale，方便以原來的旋轉與大小調整物體",{"type":14,"tag":23,"props":930,"children":931},{},[932],{"type":14,"tag":32,"props":933,"children":935},{"alt":32,"src":934},"/images/2019-08-10-ugui-RectTransform/BluePrintMode_m2-1024x711.png",[],{"type":14,"tag":918,"props":937,"children":939},{"id":938},"raw-edit-mode-原始编辑模式",[940],{"type":20,"value":941},"Raw Edit Mode (原始编辑模式)",{"type":14,"tag":23,"props":943,"children":944},{},[945],{"type":20,"value":946},"在 Inspector 中調整 Pivot 和 Anchor 時，物體會維持目前的位置與大小(Inspector 中數值部分)，調整情形如下，請注意數值部分",{"type":14,"tag":23,"props":948,"children":949},{},[950],{"type":20,"value":951},"Inspector 中調整  Pivot",{"type":14,"tag":23,"props":953,"children":954},{},[955],{"type":14,"tag":32,"props":956,"children":959},{"alt":957,"src":958},"RawEditMode_02","/images/2019-08-10-ugui-RectTransform/RawEditMode_02.gif",[],{"type":14,"tag":23,"props":961,"children":962},{},[963],{"type":20,"value":964},"Inspector 中調整  Anchor",{"type":14,"tag":23,"props":966,"children":967},{},[968],{"type":14,"tag":32,"props":969,"children":972},{"alt":970,"src":971},"RawEditMode_01","/images/2019-08-10-ugui-RectTransform/RawEditMode_01.gif",[],{"type":14,"tag":94,"props":974,"children":976},{"id":975},"參考資料",[977],{"type":20,"value":975},{"type":14,"tag":341,"props":979,"children":980},{},[981,993],{"type":14,"tag":345,"props":982,"children":983},{},[984],{"type":14,"tag":985,"props":986,"children":990},"a",{"href":987,"rel":988},"http://docs.unity3d.com/Manual/UIBasicLayout.html",[989],"nofollow",[991],{"type":20,"value":992},"Unity – Manual: Basic Layout",{"type":14,"tag":345,"props":994,"children":995},{},[996],{"type":14,"tag":985,"props":997,"children":1000},{"href":998,"rel":999},"http://tsubakit1.hateblo.jp/entry/2014/12/19/033946",[989],[1001],{"type":20,"value":1002},"UnityのuGUIのレイアウト調整機能について解説してみる（RectTransform入門）",{"title":7,"searchDepth":1004,"depth":1004,"links":1005},2,[1006,1007,1021],{"id":17,"depth":1004,"text":21},{"id":38,"depth":1004,"text":41,"children":1008},[1009,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020],{"id":96,"depth":1010,"text":99},3,{"id":118,"depth":1010,"text":121},{"id":140,"depth":1010,"text":143},{"id":162,"depth":1010,"text":165},{"id":190,"depth":1010,"text":190},{"id":337,"depth":1010,"text":337},{"id":486,"depth":1010,"text":489},{"id":556,"depth":1010,"text":556},{"id":586,"depth":1010,"text":589},{"id":597,"depth":1010,"text":600},{"id":905,"depth":1010,"text":908},{"id":7,"depth":1004,"text":7,"children":1022},[1023],{"id":975,"depth":1010,"text":975},"markdown","content:unity:2019-08-10-ugui-RectTransform.md","content","unity/2019-08-10-ugui-RectTransform.md","md","2019-08-10",[1031,1041,1168,1217,1269,1282,1394],{"title":1032,"_path":1033,"children":1034},"Art","/art",[1035,1038],{"title":1036,"_path":1037},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1039,"_path":1040},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1042,"_path":1043,"children":1044},"Dotnet","/dotnet",[1045,1048,1051,1054,1057,1060,1063,1066,1069,1072,1075,1078,1081,1084,1087,1090,1093,1096,1099,1102,1105,1108,1111,1114,1117,1120,1123,1126,1129,1132,1135,1138,1141,1144,1147,1150,1153,1156,1159,1162,1165],{"title":1046,"_path":1047},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1049,"_path":1050},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1052,"_path":1053},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1055,"_path":1056},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1058,"_path":1059},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":1061,"_path":1062},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1064,"_path":1065},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1067,"_path":1068},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1070,"_path":1071},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1073,"_path":1074},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1076,"_path":1077},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1079,"_path":1080},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1082,"_path":1083},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1085,"_path":1086},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1088,"_path":1089},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1091,"_path":1092},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1094,"_path":1095},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1097,"_path":1098},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1100,"_path":1101},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1103,"_path":1104},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1106,"_path":1107},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1109,"_path":1110},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1112,"_path":1113},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1115,"_path":1116},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1118,"_path":1119},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1121,"_path":1122},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1124,"_path":1125},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1127,"_path":1128},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1130,"_path":1131},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1133,"_path":1134},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1136,"_path":1137},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1139,"_path":1140},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1142,"_path":1143},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1145,"_path":1146},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1148,"_path":1149},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1151,"_path":1152},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1154,"_path":1155},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1157,"_path":1158},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1160,"_path":1161},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1163,"_path":1164},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1166,"_path":1167},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1169,"_path":1170,"children":1171},"Game","/game",[1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202,1205,1208,1211,1214],{"title":1173,"_path":1174},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1176,"_path":1177},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1179,"_path":1180},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1182,"_path":1183},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1185,"_path":1186},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1188,"_path":1189},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1191,"_path":1192},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1194,"_path":1195},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1197,"_path":1198},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1200,"_path":1201},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1203,"_path":1204},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1206,"_path":1207},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1209,"_path":1210},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1212,"_path":1213},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1215,"_path":1216},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1218,"_path":1219,"children":1220},"Gyj","/gyj",[1221,1224,1227,1230,1233,1236,1239,1242,1245,1248,1251,1254,1257,1260,1263,1266],{"title":1222,"_path":1223},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1225,"_path":1226},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1228,"_path":1229},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1231,"_path":1232},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1234,"_path":1235},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1237,"_path":1238},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1240,"_path":1241},"玩法","/gyj/2022-08-22-wanfa",{"title":1243,"_path":1244},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1246,"_path":1247},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1249,"_path":1250},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1252,"_path":1253},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1255,"_path":1256},"门派内容相关","/gyj/2022-11-17-sect",{"title":1258,"_path":1259},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1261,"_path":1262},"种植","/gyj/2022-12-01-zhongzhi",{"title":1264,"_path":1265},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1267,"_path":1268},"跑商","/gyj/2023-11-01-paoshang",{"title":1270,"_path":1271,"children":1272},"Js","/js",[1273,1276,1279],{"title":1274,"_path":1275},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1277,"_path":1278},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1280,"_path":1281},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1283,"_path":1284,"children":1285},"Tool","/tool",[1286,1289,1292,1295,1298,1301,1304,1307,1310,1313,1316,1319,1322,1325,1328,1331,1334,1337,1340,1343,1346,1349,1352,1355,1358,1361,1364,1367,1370,1373,1376,1379,1382,1385,1388,1391],{"title":1287,"_path":1288},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1290,"_path":1291},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1293,"_path":1294},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1296,"_path":1297},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1299,"_path":1300},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1302,"_path":1303},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1305,"_path":1306},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1308,"_path":1309},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1311,"_path":1312},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1314,"_path":1315},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1317,"_path":1318},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1320,"_path":1321},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1323,"_path":1324},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1326,"_path":1327},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1329,"_path":1330},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1332,"_path":1333},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1335,"_path":1336},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1338,"_path":1339},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1341,"_path":1342},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1344,"_path":1345},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1347,"_path":1348},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1350,"_path":1351},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1353,"_path":1354},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1356,"_path":1357},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1359,"_path":1360},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1362,"_path":1363},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1365,"_path":1366},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1368,"_path":1369},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1371,"_path":1372},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1374,"_path":1375},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1377,"_path":1378},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1380,"_path":1381},"rider的使用","/tool/2022-08-02-rider-use",{"title":1383,"_path":1384},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1386,"_path":1387},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1389,"_path":1390},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1392,"_path":1393},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1395,"_path":1396,"children":1397},"Unity","/unity",[1398,1401,1404,1407,1410,1411,1414,1417,1420,1423,1426,1429,1432,1435,1438,1441,1444,1447,1450,1453,1456,1459,1462,1465,1468,1471,1474,1477,1480,1483,1486,1489,1492,1495,1498,1501,1504,1507,1510,1513,1516,1519,1522,1525,1528,1531,1534,1537,1540,1543,1546,1549,1552,1555,1558,1561,1564,1567,1570,1573,1576,1579,1582,1585,1588,1591,1594,1597,1600,1603,1606,1609],{"title":1399,"_path":1400},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1402,"_path":1403},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1405,"_path":1406},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1408,"_path":1409},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":8,"_path":4},{"title":1412,"_path":1413},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1415,"_path":1416},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1418,"_path":1419},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1421,"_path":1422},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1424,"_path":1425},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1427,"_path":1428},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1430,"_path":1431},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1433,"_path":1434},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1436,"_path":1437},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1439,"_path":1440},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1442,"_path":1443},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1445,"_path":1446},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1448,"_path":1449},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1451,"_path":1452},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1454,"_path":1455},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1457,"_path":1458},"技能系统","/unity/2020-02-15-skill-system",{"title":1460,"_path":1461},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1463,"_path":1464},"角色状态设计","/unity/2020-02-17-character-states",{"title":1466,"_path":1467},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1469,"_path":1470},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1472,"_path":1473},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1475,"_path":1476},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1478,"_path":1479},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1481,"_path":1482},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1484,"_path":1485},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1487,"_path":1488},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1490,"_path":1491},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1493,"_path":1494},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1496,"_path":1497},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1499,"_path":1500},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1502,"_path":1503},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1505,"_path":1506},"unity的addressables","/unity/2020-09-12-addressables",{"title":1508,"_path":1509},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1511,"_path":1512},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1514,"_path":1515},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1517,"_path":1518},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1520,"_path":1521},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1523,"_path":1524},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1526,"_path":1527},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1529,"_path":1530},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1532,"_path":1533},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1535,"_path":1536},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1538,"_path":1539},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1541,"_path":1542},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1544,"_path":1545},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1547,"_path":1548},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1550,"_path":1551},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1553,"_path":1554},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1556,"_path":1557},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1559,"_path":1560},"ability","/unity/2020-11-16-dotssample",{"title":1562,"_path":1563},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1565,"_path":1566},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1568,"_path":1569},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1571,"_path":1572},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1574,"_path":1575},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1577,"_path":1578},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1580,"_path":1581},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1583,"_path":1584},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1586,"_path":1587},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1589,"_path":1590},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1592,"_path":1593},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1595,"_path":1596},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1598,"_path":1599},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1601,"_path":1602},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1604,"_path":1605},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1607,"_path":1608},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1610,"_path":1611},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779042011]