[{"data":1,"prerenderedAt":1266},["Reactive",2],{"content-query-qNK18b9wp1":3,"content-navigation-8C37fagqQL":684},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":678,"_id":679,"_source":680,"_file":681,"_extension":682,"date":683},"/unity/2020-11-15-ecs-parent","unity",false,"","ecs中的parent","ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject",{"type":11,"children":12,"toc":671},"root",[13,21,26,31,41,46,61,66,71,79,84,92,144,149,157,162,170,216,221,228,238,329,349,383,402,408,442,447,458,463,472,479,505,512,517,528,533,540,549,556,561,568,579,613,618,623,637,645,653,663],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"关于转换系统",[19],{"type":20,"value":17},"text",{"type":14,"tag":22,"props":23,"children":24},"p",{},[25],{"type":20,"value":9},{"type":14,"tag":22,"props":27,"children":28},{},[29],{"type":20,"value":30},"最终调用的时候是使用.",{"type":14,"tag":32,"props":33,"children":35},"pre",{"code":34},"GameObjectConversionUtility.Convert(gameObjectWorld);\n",[36],{"type":14,"tag":37,"props":38,"children":39},"code",{"__ignoreMap":7},[40],{"type":20,"value":34},{"type":14,"tag":22,"props":42,"children":43},{},[44],{"type":20,"value":45},"然后具体的转换过程会新疆一个转换world主要执行GameObjectConversionMappingSystem,然后转换完成后销毁这个world",{"type":14,"tag":47,"props":48,"children":49},"ul",{},[50,56],{"type":14,"tag":51,"props":52,"children":53},"li",{},[54],{"type":20,"value":55},"GameObjectConversionUtility.ConvertGameObjectHierarchy(unitView.gameObject, settings)会转换所有child.",{"type":14,"tag":51,"props":57,"children":58},{},[59],{"type":20,"value":60},"GameObjectConversionMappingSystem.conversion.MappingSystem.AddGameObjectOrPrefab(root);会递归所有child",{"type":14,"tag":15,"props":62,"children":64},{"id":63},"parent",[65],{"type":20,"value":63},{"type":14,"tag":22,"props":67,"children":68},{},[69],{"type":20,"value":70},"localtoworld是一个矩阵",{"type":14,"tag":32,"props":72,"children":74},{"code":73},"      EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n",[75],{"type":14,"tag":37,"props":76,"children":77},{"__ignoreMap":7},[78],{"type":20,"value":73},{"type":14,"tag":22,"props":80,"children":81},{},[82],{"type":20,"value":83},"如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:",{"type":14,"tag":22,"props":85,"children":86},{},[87],{"type":14,"tag":88,"props":89,"children":91},"img",{"alt":88,"src":90},"/images/2020-11-15-ecs-parent/v2-1eb72ea2222c31c50554021afecb27d1_1440w.jpg",[],{"type":14,"tag":22,"props":93,"children":94},{},[95,97,103,105,111,112,118,120,126,128,134,136,142],{"type":20,"value":96},"使用",{"type":14,"tag":37,"props":98,"children":100},{"className":99},[],[101],{"type":20,"value":102},"Translation",{"type":20,"value":104},",",{"type":14,"tag":37,"props":106,"children":108},{"className":107},[],[109],{"type":20,"value":110},"Rotation",{"type":20,"value":104},{"type":14,"tag":37,"props":113,"children":115},{"className":114},[],[116],{"type":20,"value":117},"Scale",{"type":20,"value":119},"/",{"type":14,"tag":37,"props":121,"children":123},{"className":122},[],[124],{"type":20,"value":125},"NonUniformScale",{"type":20,"value":127},"组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 ",{"type":14,"tag":37,"props":129,"children":131},{"className":130},[],[132],{"type":20,"value":133},"Parent",{"type":20,"value":135}," 组件指向了父 Entity, 那么最终该 Entity 的 ",{"type":14,"tag":37,"props":137,"children":139},{"className":138},[],[140],{"type":20,"value":141},"LocalToWorld",{"type":20,"value":143}," 值将会和父 Entity的 LocalToWorld 一样.",{"type":14,"tag":22,"props":145,"children":146},{},[147],{"type":20,"value":148},"我们新建一个场景",{"type":14,"tag":22,"props":150,"children":151},{},[152],{"type":14,"tag":88,"props":153,"children":156},{"alt":154,"src":155},"image-20201116024147417","/images/2020-11-15-ecs-parent/image-20201116024147417.png",[],{"type":14,"tag":22,"props":158,"children":159},{},[160],{"type":20,"value":161},"查看分析器.就能看到如下关系图",{"type":14,"tag":22,"props":163,"children":164},{},[165],{"type":14,"tag":88,"props":166,"children":169},{"alt":167,"src":168},"image-20201116024105067","/images/2020-11-15-ecs-parent/image-20201116024105067.png",[],{"type":14,"tag":47,"props":171,"children":172},{},[173,191],{"type":14,"tag":51,"props":174,"children":175},{},[176,178,184,185],{"type":20,"value":177},"CUBE   ",{"type":14,"tag":37,"props":179,"children":181},{"className":180},[],[182],{"type":20,"value":183},"child",{"type":20,"value":104},{"type":14,"tag":37,"props":186,"children":188},{"className":187},[],[189],{"type":20,"value":190},"physicsCollider",{"type":14,"tag":51,"props":192,"children":193},{},[194,196,201,203,209,210],{"type":20,"value":195},"SPHER ",{"type":14,"tag":37,"props":197,"children":199},{"className":198},[],[200],{"type":20,"value":63},{"type":20,"value":202}," ,",{"type":14,"tag":37,"props":204,"children":206},{"className":205},[],[207],{"type":20,"value":208},"localtoparent",{"type":20,"value":202},{"type":14,"tag":37,"props":211,"children":213},{"className":212},[],[214],{"type":20,"value":215},"previousparent",{"type":14,"tag":22,"props":217,"children":218},{},[219],{"type":20,"value":220},"由于物理的转化规则,子物体没有physicscollider.",{"type":14,"tag":222,"props":223,"children":225},"h2",{"id":224},"linkedentitygroup",[226],{"type":20,"value":227},"LinkedEntityGroup",{"type":14,"tag":22,"props":229,"children":230},{},[231,236],{"type":14,"tag":37,"props":232,"children":234},{"className":233},[],[235],{"type":20,"value":227},{"type":20,"value":237},"是一个 dynamic buffer , 通常它会影响:",{"type":14,"tag":47,"props":239,"children":240},{},[241,269,294],{"type":14,"tag":51,"props":242,"children":243},{},[244,246,252,254,259,261,267],{"type":20,"value":245},"调用",{"type":14,"tag":37,"props":247,"children":249},{"className":248},[],[250],{"type":20,"value":251},"Instantiate",{"type":20,"value":253},"方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的",{"type":14,"tag":37,"props":255,"children":257},{"className":256},[],[258],{"type":20,"value":227},{"type":20,"value":260},". 注意实例化并不一定和ECS中的",{"type":14,"tag":37,"props":262,"children":264},{"className":263},[],[265],{"type":20,"value":266},"Prefab",{"type":20,"value":268}," component 直接关联.",{"type":14,"tag":51,"props":270,"children":271},{},[272,273,279,281,286,288],{"type":20,"value":245},{"type":14,"tag":37,"props":274,"children":276},{"className":275},[],[277],{"type":20,"value":278},"DestroyEntity",{"type":20,"value":280},"时也会同时销毁 ",{"type":14,"tag":37,"props":282,"children":284},{"className":283},[],[285],{"type":20,"value":227},{"type":20,"value":287},"中的所有 entity. 类似在编辑器中删除",{"type":14,"tag":37,"props":289,"children":291},{"className":290},[],[292],{"type":20,"value":293},"GameObject",{"type":14,"tag":51,"props":295,"children":296},{},[297,299,305,307,313,315,320,322,327],{"type":20,"value":298},"调用 ",{"type":14,"tag":37,"props":300,"children":302},{"className":301},[],[303],{"type":20,"value":304},"entityManager.SetEnabled",{"type":20,"value":306}," 加上的 ",{"type":14,"tag":37,"props":308,"children":310},{"className":309},[],[311],{"type":20,"value":312},"Disabled",{"type":20,"value":314},"component 会告知 ECS 的查询系统忽略它们, 而 ",{"type":14,"tag":37,"props":316,"children":318},{"className":317},[],[319],{"type":20,"value":227},{"type":20,"value":321}," 中的 entity 也会受到同样的影响. 有点类似禁用",{"type":14,"tag":37,"props":323,"children":325},{"className":324},[],[326],{"type":20,"value":293},{"type":20,"value":328}," 时同时会禁用整个层级树.",{"type":14,"tag":22,"props":330,"children":331},{},[332,334,339,341,347],{"type":20,"value":333},"注意如果buffer 中的 entity 也有",{"type":14,"tag":37,"props":335,"children":337},{"className":336},[],[338],{"type":20,"value":227},{"type":20,"value":340},", 系统",{"type":14,"tag":342,"props":343,"children":344},"strong",{},[345],{"type":20,"value":346},"不会递归地",{"type":20,"value":348},"执行instantiation/destroy/disabled 过程.",{"type":14,"tag":22,"props":350,"children":351},{},[352,354,359,361,367,369,374,376,381],{"type":20,"value":353},"这些过程在具体执行当中也有一些细微不同.",{"type":14,"tag":37,"props":355,"children":357},{"className":356},[],[358],{"type":20,"value":251},{"type":20,"value":360},"和",{"type":14,"tag":37,"props":362,"children":364},{"className":363},[],[365],{"type":20,"value":366},"SetEnabled",{"type":20,"value":368},"只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity ",{"type":14,"tag":342,"props":370,"children":371},{},[372],{"type":20,"value":373},"必须要把自己包括在内",{"type":20,"value":375},"才能正常工作**.** 然而",{"type":14,"tag":37,"props":377,"children":379},{"className":378},[],[380],{"type":20,"value":278},{"type":20,"value":382},"则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.",{"type":14,"tag":22,"props":384,"children":385},{},[386,388,393,395,400],{"type":20,"value":387},"要注意",{"type":14,"tag":37,"props":389,"children":391},{"className":390},[],[392],{"type":20,"value":227},{"type":20,"value":394}," 和 ",{"type":14,"tag":37,"props":396,"children":398},{"className":397},[],[399],{"type":20,"value":133},{"type":20,"value":401},"并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.",{"type":14,"tag":222,"props":403,"children":405},{"id":404},"从非-prefab-conversion-中获取linkedentitygroup",[406],{"type":20,"value":407},"从非 prefab conversion 中获取LinkedEntityGroup",{"type":14,"tag":22,"props":409,"children":410},{},[411,413,419,421,426,428,433,435,440],{"type":20,"value":412},"目前, 我们使用",{"type":14,"tag":37,"props":414,"children":416},{"className":415},[],[417],{"type":20,"value":418},"ConvertToEntity",{"type":20,"value":420},"并不能得到 ",{"type":14,"tag":37,"props":422,"children":424},{"className":423},[],[425],{"type":20,"value":227},{"type":20,"value":427},". 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. (",{"type":14,"tag":37,"props":429,"children":431},{"className":430},[],[432],{"type":20,"value":418},{"type":20,"value":434},"却可以正常得到基于",{"type":14,"tag":37,"props":436,"children":438},{"className":437},[],[439],{"type":20,"value":133},{"type":20,"value":441}," 的层级结构).",{"type":14,"tag":22,"props":443,"children":444},{},[445],{"type":20,"value":446},"如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:",{"type":14,"tag":32,"props":448,"children":453},{"code":449,"language":450,"meta":7,"className":451}," public void DeclareLinkedEntityGroup(GameObject gameObject)\n","csharp",[452],"language-csharp",[454],{"type":14,"tag":37,"props":455,"children":456},{"__ignoreMap":7},[457],{"type":20,"value":449},{"type":14,"tag":22,"props":459,"children":460},{},[461],{"type":20,"value":462},"调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果).",{"type":14,"tag":32,"props":464,"children":467},{"code":465,"language":450,"meta":7,"className":466},"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n",[452],[468],{"type":14,"tag":37,"props":469,"children":470},{"__ignoreMap":7},[471],{"type":20,"value":465},{"type":14,"tag":22,"props":473,"children":474},{},[475],{"type":14,"tag":88,"props":476,"children":478},{"alt":88,"src":477},"/images/2020-11-15-ecs-parent/v2-fe2983f48e754c910758292e0a0dfc91_1440w.jpg",[],{"type":14,"tag":22,"props":480,"children":481},{},[482,484,489,491,496,497,503],{"type":20,"value":483},"从 debbuger 现在可以看到已经正常添加了",{"type":14,"tag":37,"props":485,"children":487},{"className":486},[],[488],{"type":20,"value":227},{"type":20,"value":490},", 目前它已经支持",{"type":14,"tag":37,"props":492,"children":494},{"className":493},[],[495],{"type":20,"value":251},{"type":20,"value":360},{"type":14,"tag":37,"props":498,"children":500},{"className":499},[],[501],{"type":20,"value":502},"SetEnable",{"type":20,"value":504}," 的正常工作了:",{"type":14,"tag":22,"props":506,"children":507},{},[508],{"type":14,"tag":88,"props":509,"children":511},{"alt":88,"src":510},"/images/2020-11-15-ecs-parent/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_1440w.jpg",[],{"type":14,"tag":22,"props":513,"children":514},{},[515],{"type":20,"value":516},"LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.",{"type":14,"tag":222,"props":518,"children":520},{"id":519},"关于手动添加linkedentitygroup",[521,523],{"type":20,"value":522},"关于手动添加",{"type":14,"tag":37,"props":524,"children":526},{"className":525},[],[527],{"type":20,"value":227},{"type":14,"tag":22,"props":529,"children":530},{},[531],{"type":20,"value":532},"如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:",{"type":14,"tag":22,"props":534,"children":535},{},[536],{"type":14,"tag":88,"props":537,"children":539},{"alt":88,"src":538},"/images/2020-11-15-ecs-parent/v2-de0722a0a9b1b64f962e00c0655f6641_1440w.jpg",[],{"type":14,"tag":32,"props":541,"children":544},{"code":542,"language":450,"meta":7,"className":543},"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent\u003CLinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer\u003CLinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n",[452],[545],{"type":14,"tag":37,"props":546,"children":547},{"__ignoreMap":7},[548],{"type":20,"value":542},{"type":14,"tag":22,"props":550,"children":551},{},[552],{"type":14,"tag":88,"props":553,"children":555},{"alt":88,"src":554},"/images/2020-11-15-ecs-parent/v2-50abef20adb51226bd0af6bddba9e8bb_1440w.jpg",[],{"type":14,"tag":22,"props":557,"children":558},{},[559],{"type":20,"value":560},"这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用.",{"type":14,"tag":22,"props":562,"children":563},{},[564],{"type":14,"tag":88,"props":565,"children":567},{"alt":88,"src":566},"/images/2020-11-15-ecs-parent/v2-287469fff9e08d15954ccf00d6b63df5_1440w.jpg",[],{"type":14,"tag":15,"props":569,"children":571},{"id":570},"关于parent和linkedentitygroup",[572,574],{"type":20,"value":573},"关于parent和",{"type":14,"tag":37,"props":575,"children":577},{"className":576},[],[578],{"type":20,"value":227},{"type":14,"tag":47,"props":580,"children":581},{},[582,587],{"type":14,"tag":51,"props":583,"children":584},{},[585],{"type":20,"value":586},"parent 涉及到localtoworld, 以及一些物理和其他的转换规则",{"type":14,"tag":51,"props":588,"children":589},{},[590,592,597,599,604,606,611],{"type":20,"value":591},"linkedEntityGroup 和 ",{"type":14,"tag":37,"props":593,"children":595},{"className":594},[],[596],{"type":20,"value":251},{"type":20,"value":598}," ",{"type":14,"tag":37,"props":600,"children":602},{"className":601},[],[603],{"type":20,"value":366},{"type":20,"value":605},"  ",{"type":14,"tag":37,"props":607,"children":609},{"className":608},[],[610],{"type":20,"value":278},{"type":20,"value":612}," 有关",{"type":14,"tag":22,"props":614,"children":615},{},[616],{"type":20,"value":617},"被disable的组件不会被foreach到,除非主动申请选取disable",{"type":14,"tag":15,"props":619,"children":621},{"id":620},"最佳的方式去关联entity和prefab",[622],{"type":20,"value":620},{"type":14,"tag":22,"props":624,"children":625},{},[626,628],{"type":20,"value":627},"[",{"type":14,"tag":629,"props":630,"children":634},"a",{"href":631,"rel":632},"https://forum.unity.com/threads/hybrid-ecs-best-way-to-handle-convert-and-inject-game-object-prefab.736646/",[633],"nofollow",[635],{"type":20,"value":636},"Hybrid ECS] Best way to handle Convert and Inject Game Object Prefab? - Unity Forum",{"type":14,"tag":32,"props":638,"children":640},{"code":639},"using UnityEngine;\n \npublic class Prefabs : MonoBehaviour\n{\n    private static Prefabs m_Instance;\n \n    public static GameObject PlayerModel => m_Instance.playerModel;\n \n    public GameObject playerModel;\n \n    private void Awake()\n    {\n        if (m_Instance == null)\n        {\n            m_Instance = this;\n        }\n        else\n        {\n            Debug.LogError(\"Prefab Singleton loaded twice\");\n        }\n    }\n}\n",[641],{"type":14,"tag":37,"props":642,"children":643},{"__ignoreMap":7},[644],{"type":20,"value":639},{"type":14,"tag":32,"props":646,"children":648},{"code":647},"using Unity.Entities;\nusing Unity.NetCode;\nusing Unity.Transforms;\nusing UnityEngine;\n \n[UpdateInGroup(typeof(ClientSimulationSystemGroup))]\n \npublic class PlayerModelSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.WithNone\u003CTransform>().ForEach((Entity playerEntity, ref PlayerComponent playerComponent) => {\n            if (Prefabs.PlayerModel != null)\n            {\n                var playerModel = Object.Instantiate(Prefabs.PlayerModel);\n                EntityManager.AddComponentObject(playerEntity, playerModel.GetComponent\u003CTransform>());\n                EntityManager.AddComponentData(playerEntity, new CopyTransformToGameObject());\n            }\n        });\n    }\n}\n",[649],{"type":14,"tag":37,"props":650,"children":651},{"__ignoreMap":7},[652],{"type":20,"value":647},{"type":14,"tag":22,"props":654,"children":655},{},[656],{"type":14,"tag":629,"props":657,"children":660},{"href":658,"rel":659},"https://forum.unity.com/threads/unity-tech-where-is-the-simple-bridge-between-monobehaviours-and-ecs.823485/",[633],[661],{"type":20,"value":662},"Unity Tech - Where is the SIMPLE Bridge Between MonoBehaviours and ECS?? - Unity Forum",{"type":14,"tag":32,"props":664,"children":666},{"code":665},"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n \n// Attach to your Game Object to be converted, the GameObjectPrefab is a pure Game Object with no conversion that may contain MonoBehaviour components such as the particle system.\npublic class GameObjectPrefabAuthoring : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject GameObjectPrefab;\n \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentObject(entity, new GameObjectPrefab\n        {\n            Value = GameObjectPrefab\n        });\n    }\n}\n \npublic class GameObjectPrefab : IComponentData\n{\n    public GameObject Value;\n}\n \n// Instantiate and destroy the referenced prefab when the entity is created or destroyed. You can even pool the Game Object.\npublic class GameObjectPrefabSystem : JobComponentSystem\n{\n    public class GameObjectPrefabInstance : ISystemStateComponentData\n    {\n        public GameObject Value;\n    }\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities\n            .WithNone\u003CGameObjectPrefabInstance>()\n            .ForEach((Entity entity, GameObjectPrefab gameObjectPrefab) =>\n            {\n                var gameObjectPrefabInstance = Object.Instantiate(gameObjectPrefab.Value);\n \n                EntityManager.AddComponentData(entity, new GameObjectPrefabInstance\n                {\n                    Value = gameObjectPrefabInstance\n                });\n \n                // Just an example to make the GameObject Prefab instance follow the entity.\n                EntityManager.AddComponentObject(entity, gameObjectPrefabInstance.transform);\n                EntityManager.AddComponent\u003CCopyTransformToGameObject>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        Entities\n            .WithNone\u003CGameObjectPrefab>()\n            .ForEach((Entity entity, GameObjectPrefabInstance gameObjectPrefabInstance) =>\n            {\n                Object.Destroy(gameObjectPrefabInstance.Value);\n \n                EntityManager.RemoveComponent\u003CGameObjectPrefabInstance>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        return default;\n    }\n}\n \n// A dummy system for testing purposes.\npublic class DummyEntityWithGameObjectControllerSystem : JobComponentSystem\n{\n    EntityQuery m_Query;\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var deltaTime = Time.DeltaTime;\n        var speed = 3;\n        var direction = new float2(Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\"));\n        var destroy = Input.GetKeyDown(KeyCode.Delete);\n \n        if (destroy)\n        {\n            EntityManager.DestroyEntity(m_Query);\n        }\n \n        return Entities\n            .WithStoreEntityQueryInField(ref m_Query)\n            .WithAll\u003CGameObjectPrefab>()\n            .ForEach((ref Translation translation) =>\n            {\n                translation.Value += math.normalizesafe(new float3(direction, 0).xzy) * speed * deltaTime;\n            })\n            .Schedule(inputDeps);\n    }\n}\n",[667],{"type":14,"tag":37,"props":668,"children":669},{"__ignoreMap":7},[670],{"type":20,"value":665},{"title":7,"searchDepth":672,"depth":672,"links":673},2,[674,675,676],{"id":224,"depth":672,"text":227},{"id":404,"depth":672,"text":407},{"id":519,"depth":672,"text":677},"关于手动添加LinkedEntityGroup","markdown","content:unity:2020-11-15-ecs-parent.md","content","unity/2020-11-15-ecs-parent.md","md","2020-11-15",[685,695,822,871,923,936,1048],{"title":686,"_path":687,"children":688},"Art","/art",[689,692],{"title":690,"_path":691},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":693,"_path":694},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":696,"_path":697,"children":698},"Dotnet","/dotnet",[699,702,705,708,711,714,717,720,723,726,729,732,735,738,741,744,747,750,753,756,759,762,765,768,771,774,777,780,783,786,789,792,795,798,801,804,807,810,813,816,819],{"title":700,"_path":701},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":703,"_path":704},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":706,"_path":707},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":709,"_path":710},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":712,"_path":713},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":715,"_path":716},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":718,"_path":719},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":721,"_path":722},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":724,"_path":725},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":727,"_path":728},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":730,"_path":731},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":733,"_path":734},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":736,"_path":737},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":739,"_path":740},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":742,"_path":743},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":745,"_path":746},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":748,"_path":749},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":751,"_path":752},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":754,"_path":755},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":757,"_path":758},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":760,"_path":761},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":763,"_path":764},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":766,"_path":767},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":769,"_path":770},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":772,"_path":773},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":775,"_path":776},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":778,"_path":779},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":781,"_path":782},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":784,"_path":785},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":787,"_path":788},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":790,"_path":791},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":793,"_path":794},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":796,"_path":797},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":799,"_path":800},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":802,"_path":803},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":805,"_path":806},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":808,"_path":809},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":811,"_path":812},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":814,"_path":815},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":817,"_path":818},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":820,"_path":821},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":823,"_path":824,"children":825},"Game","/game",[826,829,832,835,838,841,844,847,850,853,856,859,862,865,868],{"title":827,"_path":828},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":830,"_path":831},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":833,"_path":834},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":836,"_path":837},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":839,"_path":840},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":842,"_path":843},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":845,"_path":846},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":848,"_path":849},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":851,"_path":852},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":854,"_path":855},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":857,"_path":858},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":860,"_path":861},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":863,"_path":864},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":866,"_path":867},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":869,"_path":870},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":872,"_path":873,"children":874},"Gyj","/gyj",[875,878,881,884,887,890,893,896,899,902,905,908,911,914,917,920],{"title":876,"_path":877},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":879,"_path":880},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":882,"_path":883},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":885,"_path":886},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":888,"_path":889},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":891,"_path":892},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":894,"_path":895},"玩法","/gyj/2022-08-22-wanfa",{"title":897,"_path":898},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":900,"_path":901},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":903,"_path":904},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":906,"_path":907},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":909,"_path":910},"门派内容相关","/gyj/2022-11-17-sect",{"title":912,"_path":913},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":915,"_path":916},"种植","/gyj/2022-12-01-zhongzhi",{"title":918,"_path":919},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":921,"_path":922},"跑商","/gyj/2023-11-01-paoshang",{"title":924,"_path":925,"children":926},"Js","/js",[927,930,933],{"title":928,"_path":929},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":931,"_path":932},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":934,"_path":935},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":937,"_path":938,"children":939},"Tool","/tool",[940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000,1003,1006,1009,1012,1015,1018,1021,1024,1027,1030,1033,1036,1039,1042,1045],{"title":941,"_path":942},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":944,"_path":945},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":947,"_path":948},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":950,"_path":951},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":953,"_path":954},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":956,"_path":957},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":959,"_path":960},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":962,"_path":963},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":965,"_path":966},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":968,"_path":969},"mac下brew 使用","/tool/2020-01-13-brew",{"title":971,"_path":972},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":974,"_path":975},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":977,"_path":978},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":980,"_path":981},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":983,"_path":984},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":986,"_path":987},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":989,"_path":990},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":992,"_path":993},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":995,"_path":996},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":998,"_path":999},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1001,"_path":1002},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1004,"_path":1005},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1007,"_path":1008},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1010,"_path":1011},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1013,"_path":1014},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1016,"_path":1017},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1019,"_path":1020},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1022,"_path":1023},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1025,"_path":1026},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1028,"_path":1029},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1031,"_path":1032},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1034,"_path":1035},"rider的使用","/tool/2022-08-02-rider-use",{"title":1037,"_path":1038},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1040,"_path":1041},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1043,"_path":1044},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1046,"_path":1047},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1049,"_path":1050,"children":1051},"Unity","/unity",[1052,1055,1058,1061,1064,1067,1070,1073,1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118,1121,1124,1127,1130,1133,1136,1139,1142,1145,1148,1151,1154,1157,1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202,1205,1208,1211,1212,1215,1218,1221,1224,1227,1230,1233,1236,1239,1242,1245,1248,1251,1254,1257,1260,1263],{"title":1053,"_path":1054},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1056,"_path":1057},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1059,"_path":1060},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1062,"_path":1063},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1065,"_path":1066},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1068,"_path":1069},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1071,"_path":1072},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1074,"_path":1075},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1077,"_path":1078},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1080,"_path":1081},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1083,"_path":1084},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1086,"_path":1087},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1089,"_path":1090},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1092,"_path":1093},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1095,"_path":1096},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1098,"_path":1099},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1101,"_path":1102},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1104,"_path":1105},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1107,"_path":1108},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1110,"_path":1111},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1113,"_path":1114},"技能系统","/unity/2020-02-15-skill-system",{"title":1116,"_path":1117},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1119,"_path":1120},"角色状态设计","/unity/2020-02-17-character-states",{"title":1122,"_path":1123},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1125,"_path":1126},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1128,"_path":1129},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1131,"_path":1132},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1134,"_path":1135},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1137,"_path":1138},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1140,"_path":1141},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1143,"_path":1144},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1146,"_path":1147},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1149,"_path":1150},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1152,"_path":1153},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1155,"_path":1156},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1158,"_path":1159},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1161,"_path":1162},"unity的addressables","/unity/2020-09-12-addressables",{"title":1164,"_path":1165},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1167,"_path":1168},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1170,"_path":1171},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1173,"_path":1174},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1176,"_path":1177},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1179,"_path":1180},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1182,"_path":1183},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1185,"_path":1186},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1188,"_path":1189},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1191,"_path":1192},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1194,"_path":1195},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1197,"_path":1198},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1200,"_path":1201},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1203,"_path":1204},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1206,"_path":1207},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1209,"_path":1210},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":8,"_path":4},{"title":1213,"_path":1214},"ability","/unity/2020-11-16-dotssample",{"title":1216,"_path":1217},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1219,"_path":1220},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1222,"_path":1223},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1225,"_path":1226},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1228,"_path":1229},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1231,"_path":1232},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1234,"_path":1235},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1237,"_path":1238},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1240,"_path":1241},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1243,"_path":1244},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1246,"_path":1247},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1249,"_path":1250},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1252,"_path":1253},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1255,"_path":1256},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1258,"_path":1259},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1261,"_path":1262},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1264,"_path":1265},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779039117]