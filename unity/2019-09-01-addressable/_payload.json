[{"data":1,"prerenderedAt":1172},["Reactive",2],{"content-query-F4loXCh4UQ":3,"content-navigation-8C37fagqQL":590},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":584,"_id":585,"_source":586,"_file":587,"_extension":588,"date":589},"/unity/2019-09-01-addressable","unity",false,"","关于addressable那些事","在本文中将详细的描述Addressable对于内存的管理，如果正确的卸载资源",{"type":11,"children":12,"toc":572},"root",[13,20,26,72,77,82,134,146,151,187,206,227,233,261,331,344,363,390,424,435,441,461,469,474,494,502,507,512,534,546,558,564],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":21,"props":22,"children":24},"h2",{"id":23},"镜像资源的加载与卸载",[25],{"type":19,"value":23},{"type":14,"tag":15,"props":27,"children":28},{},[29,31,38,40,46,48,54,56,62,64,70],{"type":19,"value":30},"Addressables是否能够正确的清理内存主要的取决于是否正确的进行镜像资源的加载与卸载，而如何做到这点又取决于加载的资源的类型与使用加载的方法。",{"type":14,"tag":32,"props":33,"children":35},"code",{"className":34},[],[36],{"type":19,"value":37},"Addressables.Release",{"type":19,"value":39},"方法可以接受加载到的对象，也可以接受加载时返回的操作句柄(",{"type":14,"tag":32,"props":41,"children":43},{"className":42},[],[44],{"type":19,"value":45},"AsyncOperationHandle",{"type":19,"value":47},").比如，进行场景创建时，加载后返回一个",{"type":14,"tag":32,"props":49,"children":51},{"className":50},[],[52],{"type":19,"value":53},"AsyncOperationHandle\u003CSceneInstance>",{"type":19,"value":55},"，你可以通过返回的句柄或者",{"type":14,"tag":32,"props":57,"children":59},{"className":58},[],[60],{"type":19,"value":61},"handle.Result",{"type":19,"value":63},"(在这种情况下返回的Result为",{"type":14,"tag":32,"props":65,"children":67},{"className":66},[],[68],{"type":19,"value":69},"SceneInstance",{"type":19,"value":71},"对象)进行场景的的释放。",{"type":14,"tag":15,"props":73,"children":74},{},[75],{"type":19,"value":76},"接下来将详细的描述一下不同资源的释放方式及规则。",{"type":14,"tag":21,"props":78,"children":80},{"id":79},"资源加载",[81],{"type":19,"value":79},{"type":14,"tag":15,"props":83,"children":84},{},[85,87,93,95,101,103,109,111,116,118,124,126,132],{"type":19,"value":86},"此处的资源指的是使用",{"type":14,"tag":32,"props":88,"children":90},{"className":89},[],[91],{"type":19,"value":92},"Addressables.LoadAssetAsync",{"type":19,"value":94}," 或者 ",{"type":14,"tag":32,"props":96,"children":98},{"className":97},[],[99],{"type":19,"value":100},"Addressables.LoadAssetsAsync",{"type":19,"value":102},"加载的资源。\n使用上述的两个方法会将资源加载到内存中，但是并不实例化它，每次调用后对应的资源的引用记数都会增加1。如果您使用",{"type":14,"tag":32,"props":104,"children":106},{"className":105},[],[107],{"type":19,"value":108},"LoadAssetAsync",{"type":19,"value":110},"对同一个“地址”的资源调用了3次，您将会得到三个不同的",{"type":14,"tag":32,"props":112,"children":114},{"className":113},[],[115],{"type":19,"value":45},{"type":19,"value":117},"的实例，同时这些实例均引用相同的底层操作，对就应的底层操作的引用记数会变成3。如果资源加载成功，加载到的资源将会被存储到",{"type":14,"tag":32,"props":119,"children":121},{"className":120},[],[122],{"type":19,"value":123},"AsyncOperationHandle.Result",{"type":19,"value":125},"中，您可以使用Unity的方法进行实例化",{"type":14,"tag":32,"props":127,"children":129},{"className":128},[],[130],{"type":19,"value":131},"Object.instantite",{"type":19,"value":133},"，但是这种操作方式不会造成Adressables的引用记数发生变化。",{"type":14,"tag":15,"props":135,"children":136},{},[137,139,144],{"type":19,"value":138},"使用",{"type":14,"tag":32,"props":140,"children":142},{"className":141},[],[143],{"type":19,"value":37},{"type":19,"value":145},"方法可以进行卸载，调用后引用记数会减1，一旦资源的引用记数为0，那么它会被彻底的卸载掉。",{"type":14,"tag":21,"props":147,"children":149},{"id":148},"场景加载",[150],{"type":19,"value":148},{"type":14,"tag":15,"props":152,"children":153},{},[154,156,162,164,170,172,178,180,185],{"type":19,"value":155},"可以使用",{"type":14,"tag":32,"props":157,"children":159},{"className":158},[],[160],{"type":19,"value":161},"Addressables.LoadSceneAsync",{"type":19,"value":163},"进行场景的加载，同时可以在参数中指定使用",{"type":14,"tag":32,"props":165,"children":167},{"className":166},[],[168],{"type":19,"value":169},"Single",{"type":19,"value":171},"或者",{"type":14,"tag":32,"props":173,"children":175},{"className":174},[],[176],{"type":19,"value":177},"Additive",{"type":19,"value":179},"模式，如果指定使用",{"type":14,"tag":32,"props":181,"children":183},{"className":182},[],[184],{"type":19,"value":169},{"type":19,"value":186},"模式，那么当前所在打开的场景都会被关闭。",{"type":14,"tag":15,"props":188,"children":189},{},[190,191,197,199,204],{"type":19,"value":155},{"type":14,"tag":32,"props":192,"children":194},{"className":193},[],[195],{"type":19,"value":196},"Addressables.UnloadSceneAsync",{"type":19,"value":198},"进行场景的卸载，或者打开新场景时使用",{"type":14,"tag":32,"props":200,"children":202},{"className":201},[],[203],{"type":19,"value":169},{"type":19,"value":205},"模式。",{"type":14,"tag":15,"props":207,"children":208},{},[209,211,217,219,225],{"type":19,"value":210},"当想要打开一个新场景时可以使用上述Addressables提供的方法或者使用 ",{"type":14,"tag":32,"props":212,"children":214},{"className":213},[],[215],{"type":19,"value":216},"SceneManager.LoadScene",{"type":19,"value":218},"/",{"type":14,"tag":32,"props":220,"children":222},{"className":221},[],[223],{"type":19,"value":224},"SceneManager.LoadSceneAsync",{"type":19,"value":226},"，一个新场景的打开会关闭当前的场景，那么对应的引用记数也会正确的减少。",{"type":14,"tag":21,"props":228,"children":230},{"id":229},"gameobject的实例化",[231],{"type":19,"value":232},"GameObject的实例化",{"type":14,"tag":15,"props":234,"children":235},{},[236,238,244,246,251,253,259],{"type":19,"value":237},"GameObject的实例化相对其它的资源有些特殊，在Unity中使用",{"type":14,"tag":32,"props":239,"children":241},{"className":240},[],[242],{"type":19,"value":243},"Resources.Load",{"type":19,"value":245},"其实只是将Prefab的数据加载到了内存中，并未真正的实例化，所以需要再次调用",{"type":14,"tag":32,"props":247,"children":249},{"className":248},[],[250],{"type":19,"value":131},{"type":19,"value":252},"才能正确的得到需要的GameObject，在Addressables中也是这样的，不过Addressable提供了一些便利的方法",{"type":14,"tag":32,"props":254,"children":256},{"className":255},[],[257],{"type":19,"value":258},"Addressables.InstantiateAsync",{"type":19,"value":260},"可以直接得到对应的GameObject。",{"type":14,"tag":15,"props":262,"children":263},{},[264,266,271,273,279,281,286,288,293,295,300,302,307,309,314,316,322,324,329],{"type":19,"value":265},"当使用",{"type":14,"tag":32,"props":267,"children":269},{"className":268},[],[270],{"type":19,"value":258},{"type":19,"value":272},"加载一个Prefab时，Addressable会自动实例化，同时在加载的过程中Addressable在加载Prefab的同时也会加载其依赖，将所有的引用记数全部增加。对同一“地址”的资源调用",{"type":14,"tag":32,"props":274,"children":276},{"className":275},[],[277],{"type":19,"value":278},"InstantiateAsync",{"type":19,"value":280},"三次，将会使其依赖的所有资源的引用记数均增加为3.但是与三次调用",{"type":14,"tag":32,"props":282,"children":284},{"className":283},[],[285],{"type":19,"value":108},{"type":19,"value":287},"不同的是每次调用",{"type":14,"tag":32,"props":289,"children":291},{"className":290},[],[292],{"type":19,"value":278},{"type":19,"value":294},"将会得到一个指向同一个操作的",{"type":14,"tag":32,"props":296,"children":298},{"className":297},[],[299],{"type":19,"value":45},{"type":19,"value":301},",这是因为每一个",{"type":14,"tag":32,"props":303,"children":305},{"className":304},[],[306],{"type":19,"value":278},{"type":19,"value":308},"都将得到一个唯一的实例。与其它调用方法的另外一个区别在于",{"type":14,"tag":32,"props":310,"children":312},{"className":311},[],[313],{"type":19,"value":278},{"type":19,"value":315},"有一个可选参数",{"type":14,"tag":32,"props":317,"children":319},{"className":318},[],[320],{"type":19,"value":321},"trackHandle",{"type":19,"value":323},"，如果将其设置为false，在",{"type":14,"tag":32,"props":325,"children":327},{"className":326},[],[328],{"type":19,"value":45},{"type":19,"value":330},"释放前，您必须自己保管着此对象，在此期间您可以执行一些操作。这种方法可以提高效率但是需要更多格外的代码来实现。",{"type":14,"tag":15,"props":332,"children":333},{},[334,336,342],{"type":19,"value":335},"关闭实例所在场景或者使用",{"type":14,"tag":32,"props":337,"children":339},{"className":338},[],[340],{"type":19,"value":341},"Addressables.ReleaseInstance",{"type":19,"value":343},"可以卸载掉实例化的对象。",{"type":14,"tag":15,"props":345,"children":346},{},[347,349,354,356,361],{"type":19,"value":348},"如果您在加载时将",{"type":14,"tag":32,"props":350,"children":352},{"className":351},[],[353],{"type":19,"value":321},{"type":19,"value":355},"设置为false,那么您只能通过调用",{"type":14,"tag":32,"props":357,"children":359},{"className":358},[],[360],{"type":19,"value":341},{"type":19,"value":362},"并将返回的句柄做为参数，而不能再使用真实的GameObject做为参数进行释放了。",{"type":14,"tag":15,"props":364,"children":365},{},[366,368,373,375,380,382,388],{"type":19,"value":367},"关于",{"type":14,"tag":32,"props":369,"children":371},{"className":370},[],[372],{"type":19,"value":341},{"type":19,"value":374},"格外的说明：如果调用",{"type":14,"tag":32,"props":376,"children":378},{"className":377},[],[379],{"type":19,"value":341},{"type":19,"value":381},"方法来释放一个实例,但是此实例不是由Addressable创建或者说在使用Addressable创建时设置了",{"type":14,"tag":32,"props":383,"children":385},{"className":384},[],[386],{"type":19,"value":387},"trackHandle=false",{"type":19,"value":389},"，此方法调用后将会返回false，以表示Addressable无法释放此实例",{"type":14,"tag":15,"props":391,"children":392},{},[393,394,399,401,406,408,414,416,422],{"type":19,"value":138},{"type":14,"tag":32,"props":395,"children":397},{"className":396},[],[398],{"type":19,"value":258},{"type":19,"value":400},"方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，使用此方法就不再合适，可以考虑使用",{"type":14,"tag":32,"props":402,"children":404},{"className":403},[],[405],{"type":19,"value":92},{"type":19,"value":407},"进行资源的加载，同时自己保存返回的结果，然后再使用",{"type":14,"tag":32,"props":409,"children":411},{"className":410},[],[412],{"type":19,"value":413},"GameObject.Instantiate()",{"type":19,"value":415},"进行实例化，同时当所有的GameObject不再使用后，再通过",{"type":14,"tag":32,"props":417,"children":419},{"className":418},[],[420],{"type":19,"value":421},"Addessables.Release",{"type":19,"value":423},"方法将保存的结果进行释放。使用此种方法虽然可以提高部分性能，但是需要对其增加格外的管理。",{"type":14,"tag":15,"props":425,"children":426},{},[427,428,433],{"type":19,"value":138},{"type":14,"tag":32,"props":429,"children":431},{"className":430},[],[432],{"type":19,"value":258},{"type":19,"value":434},"方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，可以考虑使用Addressable进行资源的加载",{"type":14,"tag":21,"props":436,"children":438},{"id":437},"addressable分析工具",[439],{"type":19,"value":440},"Addressable分析工具",{"type":14,"tag":15,"props":442,"children":443},{},[444,446,452,454,459],{"type":19,"value":445},"通过",{"type":14,"tag":447,"props":448,"children":449},"em",{},[450],{"type":19,"value":451},"Window->Asset Management->Addressable Profiler",{"type":19,"value":453},"可以打开Addressable的分析工具，在使用此工具前需要将配置中的",{"type":14,"tag":447,"props":455,"children":456},{},[457],{"type":19,"value":458},"Send Profiler Events",{"type":19,"value":460},"打开（默认情况下配置文件为Assets/AddressableAssetsData/AddressableAssetSettings)",{"type":14,"tag":15,"props":462,"children":463},{},[464],{"type":14,"tag":465,"props":466,"children":468},"img",{"alt":458,"src":467},"/images/2019-09-01-addressable/sendprofilerevent.png",[],{"type":14,"tag":15,"props":470,"children":471},{},[472],{"type":19,"value":473},"窗口中显示了Addressable操作的引用记数，包括加载的AssetBundle及加载的资源等等。",{"type":14,"tag":475,"props":476,"children":477},"ul",{},[478,484,489],{"type":14,"tag":479,"props":480,"children":481},"li",{},[482],{"type":19,"value":483},"白色的竖线表示选择的当前的帧",{"type":14,"tag":479,"props":485,"children":486},{},[487],{"type":19,"value":488},"蓝色的背景当前加载的资源",{"type":14,"tag":479,"props":490,"children":491},{},[492],{"type":19,"value":493},"绿色的部分表示引用记数",{"type":14,"tag":15,"props":495,"children":496},{},[497],{"type":14,"tag":465,"props":498,"children":501},{"alt":499,"src":500},"Profiler","/images/2019-09-01-addressable/profiler.png",[],{"type":14,"tag":21,"props":503,"children":505},{"id":504},"内存清理时机",[506],{"type":19,"value":504},{"type":14,"tag":15,"props":508,"children":509},{},[510],{"type":19,"value":511},"即使一个资源的不再被引用也不代表此资源被卸载了，因为一个AssetBundle中可能包含有多个资源，比如：一个名称\"stuff\"的AssetBundle中包含有三个资源\"tree\",“tank”,“cow”，当资源\"tree”被加载后，能够看到\"tree\"的引用记录会是1，同时\"stuff\"的引用记数也是1，接着如果加载了\"tank\"资源，此时\"tree\"与\"tank\"的引用记数均为1，同时\"stuff\"的记数会是2。接下来卸载资源\"tree\"，则\"tree\"的引用记数将会减少为0，在\"Addressable Profiler\"中对应于\"tree\"的记录将会被删除，但是此时由于AssetBundle对应的\"stuff\"并未被卸载，因为还有其它的在使用此AssetBundle。使用AssetBundle时可以从AssetBundle中加载部分内容，但是不能部分卸载AssetBundle，只有AssetBundle中的任何资源都不再被使用时，此AssetBundle才会被卸载",{"type":14,"tag":15,"props":513,"children":514},{},[515,517,523,525],{"type":19,"value":516},"当使用Unity的",{"type":14,"tag":32,"props":518,"children":520},{"className":519},[],[521],{"type":19,"value":522},"Resources.UnloadUnusedAssets",{"type":19,"value":524}," (查看",{"type":14,"tag":526,"props":527,"children":531},"a",{"href":528,"rel":529},"https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)%E6%97%B6%EF%BC%8C%E4%B8%8A%E8%BF%B0%E6%8F%8F%E8%BF%B0%E4%B8%AD%E7%9A%84%22tree%22%E5%B0%86%E4%BC%9A%E8%A2%AB%E5%8D%B8%E8%BD%BD%E6%8E%89%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E5%88%B0%E6%AD%A4%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%8F%AA%E8%83%BD%E5%8F%8D%E6%98%A0%E5%BC%95%E7%94%A8%E8%AE%B0%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E5%86%85%E5%AD%98%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E5%8F%98%E5%8C%96%E3%80%82",[530],"nofollow",[532],{"type":19,"value":533},"https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)时，上述描述中的\"tree\"将会被卸载掉，但是由于我们无法检测到此操作，所以我们只能反映引用记数的变化，而不是真正内存中内容的变化。",{"type":14,"tag":15,"props":535,"children":536},{},[537,539,544],{"type":19,"value":538},"需要注意的是：使用",{"type":14,"tag":32,"props":540,"children":542},{"className":541},[],[543],{"type":19,"value":522},{"type":19,"value":545},"是一个很费时的操作，一般情况下不建议频繁使用，只有在场景切换时进行调用",{"type":14,"tag":15,"props":547,"children":548},{},[549,551,556],{"type":19,"value":550},"此段文字有些绕口，简单来说就是由于一个AssetBundle中包含有多个资源，其中的多个资源被加载出来后，只有所有的资源均不再使用时才会正确的卸载掉AssetBundle，同时对于加载出来的资源一般情况下，即使不再使用后也不是立即卸载的，依赖于引擎底层的实现。在Unity中通过使用",{"type":14,"tag":32,"props":552,"children":554},{"className":553},[],[555],{"type":19,"value":522},{"type":19,"value":557},"可以将不再使用的资源给卸载掉，但是由于此接口过于耗时，并不推荐频繁使用。可以使用的情况一般有：1 进行场景切换时，2 在某些大资源被销毁时，比如说：某此UI界面占用资源特别多，当此UI界面关闭时可以调用。",{"type":14,"tag":559,"props":560,"children":562},"h3",{"id":561},"一些注意点",[563],{"type":19,"value":561},{"type":14,"tag":475,"props":565,"children":566},{},[567],{"type":14,"tag":479,"props":568,"children":569},{},[570],{"type":19,"value":571},"不要想着用异步加载ui..那会很卡..会出现莫名其妙的事情",{"title":7,"searchDepth":573,"depth":573,"links":574},2,[575,576,577,578,579,580],{"id":23,"depth":573,"text":23},{"id":79,"depth":573,"text":79},{"id":148,"depth":573,"text":148},{"id":229,"depth":573,"text":232},{"id":437,"depth":573,"text":440},{"id":504,"depth":573,"text":504,"children":581},[582],{"id":561,"depth":583,"text":561},3,"markdown","content:unity:2019-09-01-addressable.md","content","unity/2019-09-01-addressable.md","md","2019-09-01",[591,601,728,777,829,842,954],{"title":592,"_path":593,"children":594},"Art","/art",[595,598],{"title":596,"_path":597},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":599,"_path":600},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":602,"_path":603,"children":604},"Dotnet","/dotnet",[605,608,611,614,617,620,623,626,629,632,635,638,641,644,647,650,653,656,659,662,665,668,671,674,677,680,683,686,689,692,695,698,701,704,707,710,713,716,719,722,725],{"title":606,"_path":607},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":609,"_path":610},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":612,"_path":613},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":615,"_path":616},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":618,"_path":619},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":621,"_path":622},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":624,"_path":625},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":627,"_path":628},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":630,"_path":631},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":633,"_path":634},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":636,"_path":637},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":639,"_path":640},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":642,"_path":643},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":645,"_path":646},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":648,"_path":649},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":651,"_path":652},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":654,"_path":655},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":657,"_path":658},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":660,"_path":661},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":663,"_path":664},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":666,"_path":667},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":669,"_path":670},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":672,"_path":673},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":675,"_path":676},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":678,"_path":679},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":681,"_path":682},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":684,"_path":685},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":687,"_path":688},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":690,"_path":691},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":693,"_path":694},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":696,"_path":697},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":699,"_path":700},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":702,"_path":703},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":705,"_path":706},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":708,"_path":709},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":711,"_path":712},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":714,"_path":715},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":717,"_path":718},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":720,"_path":721},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":723,"_path":724},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":726,"_path":727},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":729,"_path":730,"children":731},"Game","/game",[732,735,738,741,744,747,750,753,756,759,762,765,768,771,774],{"title":733,"_path":734},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":736,"_path":737},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":739,"_path":740},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":742,"_path":743},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":745,"_path":746},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":748,"_path":749},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":751,"_path":752},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":754,"_path":755},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":757,"_path":758},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":760,"_path":761},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":763,"_path":764},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":766,"_path":767},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":769,"_path":770},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":772,"_path":773},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":775,"_path":776},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":778,"_path":779,"children":780},"Gyj","/gyj",[781,784,787,790,793,796,799,802,805,808,811,814,817,820,823,826],{"title":782,"_path":783},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":785,"_path":786},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":788,"_path":789},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":791,"_path":792},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":794,"_path":795},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":797,"_path":798},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":800,"_path":801},"玩法","/gyj/2022-08-22-wanfa",{"title":803,"_path":804},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":806,"_path":807},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":809,"_path":810},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":812,"_path":813},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":815,"_path":816},"门派内容相关","/gyj/2022-11-17-sect",{"title":818,"_path":819},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":821,"_path":822},"种植","/gyj/2022-12-01-zhongzhi",{"title":824,"_path":825},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":827,"_path":828},"跑商","/gyj/2023-11-01-paoshang",{"title":830,"_path":831,"children":832},"Js","/js",[833,836,839],{"title":834,"_path":835},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":837,"_path":838},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":840,"_path":841},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":843,"_path":844,"children":845},"Tool","/tool",[846,849,852,855,858,861,864,867,870,873,876,879,882,885,888,891,894,897,900,903,906,909,912,915,918,921,924,927,930,933,936,939,942,945,948,951],{"title":847,"_path":848},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":850,"_path":851},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":853,"_path":854},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":856,"_path":857},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":859,"_path":860},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":862,"_path":863},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":865,"_path":866},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":868,"_path":869},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":871,"_path":872},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":874,"_path":875},"mac下brew 使用","/tool/2020-01-13-brew",{"title":877,"_path":878},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":880,"_path":881},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":883,"_path":884},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":886,"_path":887},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":889,"_path":890},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":892,"_path":893},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":895,"_path":896},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":898,"_path":899},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":901,"_path":902},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":904,"_path":905},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":907,"_path":908},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":910,"_path":911},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":913,"_path":914},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":916,"_path":917},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":919,"_path":920},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":922,"_path":923},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":925,"_path":926},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":928,"_path":929},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":931,"_path":932},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":934,"_path":935},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":937,"_path":938},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":940,"_path":941},"rider的使用","/tool/2022-08-02-rider-use",{"title":943,"_path":944},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":946,"_path":947},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":949,"_path":950},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":952,"_path":953},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":955,"_path":956,"children":957},"Unity","/unity",[958,961,964,967,970,973,976,979,982,983,986,989,992,995,998,1001,1004,1007,1010,1013,1016,1019,1022,1025,1028,1031,1034,1037,1040,1043,1046,1049,1052,1055,1058,1061,1064,1067,1070,1073,1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118,1121,1124,1127,1130,1133,1136,1139,1142,1145,1148,1151,1154,1157,1160,1163,1166,1169],{"title":959,"_path":960},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":962,"_path":963},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":965,"_path":966},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":968,"_path":969},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":971,"_path":972},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":974,"_path":975},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":977,"_path":978},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":980,"_path":981},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":8,"_path":4},{"title":984,"_path":985},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":987,"_path":988},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":990,"_path":991},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":993,"_path":994},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":996,"_path":997},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":999,"_path":1000},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1002,"_path":1003},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1005,"_path":1006},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1008,"_path":1009},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1011,"_path":1012},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1014,"_path":1015},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1017,"_path":1018},"技能系统","/unity/2020-02-15-skill-system",{"title":1020,"_path":1021},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1023,"_path":1024},"角色状态设计","/unity/2020-02-17-character-states",{"title":1026,"_path":1027},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1029,"_path":1030},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1032,"_path":1033},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1035,"_path":1036},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1038,"_path":1039},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1041,"_path":1042},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1044,"_path":1045},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1047,"_path":1048},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1050,"_path":1051},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1053,"_path":1054},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1056,"_path":1057},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1059,"_path":1060},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1062,"_path":1063},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1065,"_path":1066},"unity的addressables","/unity/2020-09-12-addressables",{"title":1068,"_path":1069},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1071,"_path":1072},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1074,"_path":1075},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1077,"_path":1078},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1080,"_path":1081},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1083,"_path":1084},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1086,"_path":1087},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1089,"_path":1090},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1092,"_path":1093},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1095,"_path":1096},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1098,"_path":1099},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1101,"_path":1102},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1104,"_path":1105},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1107,"_path":1108},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1110,"_path":1111},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1113,"_path":1114},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1116,"_path":1117},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1119,"_path":1120},"ability","/unity/2020-11-16-dotssample",{"title":1122,"_path":1123},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1125,"_path":1126},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1128,"_path":1129},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1131,"_path":1132},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1134,"_path":1135},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1137,"_path":1138},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1140,"_path":1141},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1143,"_path":1144},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1146,"_path":1147},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1149,"_path":1150},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1152,"_path":1153},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1155,"_path":1156},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1158,"_path":1159},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1161,"_path":1162},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1164,"_path":1165},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1167,"_path":1168},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1170,"_path":1171},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041893]