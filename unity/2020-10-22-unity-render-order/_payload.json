[{"data":1,"prerenderedAt":1447},["Reactive",2],{"content-query-wkqrgBr9EW":3,"content-navigation-8C37fagqQL":865},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":859,"_id":860,"_source":861,"_file":862,"_extension":863,"date":864},"/unity/2020-10-22-unity-render-order","unity",false,"","Unity rendering order渲染顺序","關於深度緩衝 (Depth buffering, or z-buffering)勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 Rasterization 怎麼透過 z-buffering ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小",{"type":11,"children":12,"toc":852},"root",[13,22,48,62,75,94,108,112,125,129,139,145,173,186,197,526,533,538,549,554,559,564,571,576,581,589,600,613,618,626,632,637,642,706,711,750,755],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"關於深度緩衝-depth-buffering-or-z-buffering",[19],{"type":20,"value":21},"text","關於深度緩衝 (Depth buffering, or z-buffering)",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26,28,37,39,46],{"type":20,"value":27},"勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 ",{"type":14,"tag":29,"props":30,"children":34},"a",{"href":31,"rel":32},"https://en.wikipedia.org/wiki/Rasterisation",[33],"nofollow",[35],{"type":20,"value":36},"Rasterization",{"type":20,"value":38}," 怎麼透過 ",{"type":14,"tag":29,"props":40,"children":43},{"href":41,"rel":42},"https://en.wikipedia.org/wiki/Z-buffering",[33],[44],{"type":20,"value":45},"z-buffering",{"type":20,"value":47}," ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。",{"type":14,"tag":23,"props":49,"children":50},{},[51,53,60],{"type":20,"value":52},"當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小與最後成像尺寸相同。在 Unity shader 中可利用 ",{"type":14,"tag":54,"props":55,"children":57},"code",{"className":56},[],[58],{"type":20,"value":59},"ZWrite On | Off",{"type":20,"value":61}," 來切換是否將深度資訊要寫入到 z-buffer。",{"type":14,"tag":23,"props":63,"children":64},{},[65,67,73],{"type":20,"value":66},"如果場景中其他物件 rendering 時，也在同一個 pixel 位置渲染結果時，會檢查 z-buffer 所儲存的深度資訊，是否將渲染結果覆蓋原本的 pixel，並且將新的深度資訊寫入到 z-buffer。通常條件會設定為深度資訊比原本更接近攝影機時，就能夠覆蓋原本結果。在 Unity shader 中可利用 ",{"type":14,"tag":54,"props":68,"children":70},{"className":69},[],[71],{"type":20,"value":72},"ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always",{"type":20,"value":74}," 來調整判斷方式。",{"type":14,"tag":23,"props":76,"children":77},{},[78,84,86,92],{"type":14,"tag":79,"props":80,"children":81},"strong",{},[82],{"type":20,"value":83},"有 z-buffering 機制，可不管物件算繪順序 (rendering order)，使得離攝影機越近的物件，永遠都描繪在其他離攝影機越遠的物件之前",{"type":20,"value":85}," (",{"type":14,"tag":54,"props":87,"children":89},{"className":88},[],[90],{"type":20,"value":91},"ZTest LEqual",{"type":20,"value":93},")。",{"type":14,"tag":23,"props":95,"children":96},{},[97],{"type":14,"tag":29,"props":98,"children":101},{"href":99,"rel":100},"https://3.bp.blogspot.com/-xEsBEXX2jiQ/Wv_KFd2e3hI/AAAAAAAAwHY/aMJAzz3UIPkMUZOUqd9sgz_dsKZYN0PmQCHMYCw/s1600/bed-room.png",[33],[102],{"type":14,"tag":103,"props":104,"children":107},"img",{"alt":105,"src":106},"房間示意圖","/images/2020-10-22-unity-render-order/bed-room.png",[],{"type":14,"tag":23,"props":109,"children":110},{},[111],{"type":20,"value":105},{"type":14,"tag":23,"props":113,"children":114},{},[115],{"type":14,"tag":29,"props":116,"children":119},{"href":117,"rel":118},"https://3.bp.blogspot.com/-x6KnmDnIk6o/Wv_KF_uymYI/AAAAAAAAwHc/XyV7-wddP-0QgqxstR_8MGzLGOxMlbUuACHMYCw/s1600/depth-info-bed-room.png",[33],[120],{"type":14,"tag":103,"props":121,"children":124},{"alt":122,"src":123},"房間的深度資訊，越深色表示離攝影機越近","/images/2020-10-22-unity-render-order/depth-info-bed-room.png",[],{"type":14,"tag":23,"props":126,"children":127},{},[128],{"type":20,"value":122},{"type":14,"tag":23,"props":130,"children":131},{},[132],{"type":14,"tag":29,"props":133,"children":136},{"href":134,"rel":135},"https://assetstore.unity.com/packages/3d/props/furniture/pack-gesta-furniture-1-28237",[33],[137],{"type":20,"value":138},"場景來源",{"type":14,"tag":15,"props":140,"children":142},{"id":141},"renderers-rendering-order",[143],{"type":20,"value":144},"Renderer’s rendering order",{"type":14,"tag":23,"props":146,"children":147},{},[148,150,156,158,164,166,171],{"type":20,"value":149},"假設 shader 中關閉深度機制的判斷 (",{"type":14,"tag":54,"props":151,"children":153},{"className":152},[],[154],{"type":20,"value":155},"ZTest Always",{"type":20,"value":157},")，或者在 render 場景物件的過程中都不寫入深度 (",{"type":14,"tag":54,"props":159,"children":161},{"className":160},[],[162],{"type":20,"value":163},"ZWrite Off",{"type":20,"value":165},")，即",{"type":14,"tag":79,"props":167,"children":168},{},[169],{"type":20,"value":170},"沒有 z-buffering 機制，rendering order 會決定成像的結果，越晚畫的物件永遠都在其他較早畫的物件之上",{"type":20,"value":172},"。",{"type":14,"tag":23,"props":174,"children":175},{},[176,178,184],{"type":20,"value":177},"而在 SpriteRenderer 直接修改 sorting layer 以及 order in layer 來改變 rendering order，就能調整該物件在算繪結果的物件前後，便是基於此緣故，更多細節可查看 ",{"type":14,"tag":54,"props":179,"children":181},{"className":180},[],[182],{"type":20,"value":183},"Sprites/Default",{"type":20,"value":185}," shader 程式碼。",{"type":14,"tag":23,"props":187,"children":188},{},[189,191,196],{"type":20,"value":190},"故整理在 Unity 中，rendering order 是根據以下參數進行排序：",{"type":14,"tag":79,"props":192,"children":193},{},[194],{"type":20,"value":195},"Camera depth > Material type > Sorting layer > Order in layer > Material render queue > Camera order algorithm",{"type":20,"value":172},{"type":14,"tag":198,"props":199,"children":200},"ul",{},[201,254,272,335,380,438],{"type":14,"tag":202,"props":203,"children":204},"li",{},[205,207],{"type":20,"value":206},"Camera depth",{"type":14,"tag":198,"props":208,"children":209},{},[210,215,220,231],{"type":14,"tag":202,"props":211,"children":212},{},[213],{"type":20,"value":214},"數字越大越晚畫",{"type":14,"tag":202,"props":216,"children":217},{},[218],{"type":20,"value":219},"通常無法搭配 Clear Flags: Don’t Clear，因為不會清除 depth buffer (z-buffer)",{"type":14,"tag":202,"props":221,"children":222},{},[223,225],{"type":20,"value":224},"程式設定 ",{"type":14,"tag":54,"props":226,"children":228},{"className":227},[],[229],{"type":20,"value":230},"camera.depth",{"type":14,"tag":202,"props":232,"children":233},{},[234,236,240,250,253],{"type":20,"value":235},"選擇場景中的 camera 編輯",{"type":14,"tag":237,"props":238,"children":239},"br",{},[],{"type":14,"tag":29,"props":241,"children":244},{"href":242,"rel":243},"https://3.bp.blogspot.com/-VdjJ2P8mRSw/Wv_KGL2e9kI/AAAAAAAAwHg/bf871Tz0ZCgcM_pTnENDlLA2EVCVEOXgQCHMYCw/s1600/edit-camera-depth-unity.png",[33],[245],{"type":14,"tag":103,"props":246,"children":249},{"alt":247,"src":248},"編輯 depth 參數","/images/2020-10-22-unity-render-order/edit-camera-depth-unity.png",[],{"type":14,"tag":237,"props":251,"children":252},{},[],{"type":20,"value":247},{"type":14,"tag":202,"props":255,"children":256},{},[257,259],{"type":20,"value":258},"Material type",{"type":14,"tag":198,"props":260,"children":261},{},[262,267],{"type":14,"tag":202,"props":263,"children":264},{},[265],{"type":20,"value":266},"先畫不透明物件 (opaque)，再畫透明物件 (transparent)",{"type":14,"tag":202,"props":268,"children":269},{},[270],{"type":20,"value":271},"根據 material render queue 來決定，數值小於等於 2500 為不透明物件，數值大於 2500 為透明物件",{"type":14,"tag":202,"props":273,"children":274},{},[275,277],{"type":20,"value":276},"Sorting layer",{"type":14,"tag":198,"props":278,"children":279},{},[280,284,289,299,317],{"type":14,"tag":202,"props":281,"children":282},{},[283],{"type":20,"value":214},{"type":14,"tag":202,"props":285,"children":286},{},[287],{"type":20,"value":288},"大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯（不過自定義編輯器來達成）",{"type":14,"tag":202,"props":290,"children":291},{},[292,293],{"type":20,"value":224},{"type":14,"tag":54,"props":294,"children":296},{"className":295},[],[297],{"type":20,"value":298},"renderer.sortingLayerID",{"type":14,"tag":202,"props":300,"children":301},{},[302,304,307],{"type":20,"value":303},"在 Tag Manager 編輯 Sorting layer",{"type":14,"tag":237,"props":305,"children":306},{},[],{"type":14,"tag":29,"props":308,"children":311},{"href":309,"rel":310},"https://3.bp.blogspot.com/-HQnwI_JP7dQ/Wv_KG_RuisI/AAAAAAAAwHo/8ecZFCMsknsP2XOd227LgYyr_JsP-k5fwCHMYCw/s1600/edit-sorting-layers-unity.png",[33],[312],{"type":14,"tag":103,"props":313,"children":316},{"alt":314,"src":315},"編輯 Sorting layers","/images/2020-10-22-unity-render-order/edit-sorting-layers-unity.png",[],{"type":14,"tag":202,"props":318,"children":319},{},[320,322,325],{"type":20,"value":321},"選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Sorting layer",{"type":14,"tag":237,"props":323,"children":324},{},[],{"type":14,"tag":29,"props":326,"children":329},{"href":327,"rel":328},"https://3.bp.blogspot.com/-74IY8tFv9b4/WwAf4mJ-bqI/AAAAAAAAwJQ/xHzyeHjHwP89PPKkCo3Ahp_OrsCdEJNKwCLcBGAs/s1600/edit-sorting-layer-unity.png",[33],[330],{"type":14,"tag":103,"props":331,"children":334},{"alt":332,"src":333},"編輯 Sorting layer","/images/2020-10-22-unity-render-order/edit-sorting-layer-unity.png",[],{"type":14,"tag":202,"props":336,"children":337},{},[338,340],{"type":20,"value":339},"Order in layer",{"type":14,"tag":198,"props":341,"children":342},{},[343,347,352,362],{"type":14,"tag":202,"props":344,"children":345},{},[346],{"type":20,"value":214},{"type":14,"tag":202,"props":348,"children":349},{},[350],{"type":20,"value":351},"大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯",{"type":14,"tag":202,"props":353,"children":354},{},[355,356],{"type":20,"value":224},{"type":14,"tag":54,"props":357,"children":359},{"className":358},[],[360],{"type":20,"value":361},"renderer.sortingOrder",{"type":14,"tag":202,"props":363,"children":364},{},[365,367,370],{"type":20,"value":366},"選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Order in layer",{"type":14,"tag":237,"props":368,"children":369},{},[],{"type":14,"tag":29,"props":371,"children":374},{"href":372,"rel":373},"https://3.bp.blogspot.com/-8VZ0pu3-ZdI/WwAfrRVqL9I/AAAAAAAAwJM/89ZAUPkUfUsy9eXQn1bZUW9y_Q8HxBCxwCLcBGAs/s1600/edit-order-in-layer-unity.png",[33],[375],{"type":14,"tag":103,"props":376,"children":379},{"alt":377,"src":378},"編輯 Order in layer","/images/2020-10-22-unity-render-order/edit-order-in-layer-unity.png",[],{"type":14,"tag":202,"props":381,"children":382},{},[383,385],{"type":20,"value":384},"Material render queue",{"type":14,"tag":198,"props":386,"children":387},{},[388,392,397,410,420],{"type":14,"tag":202,"props":389,"children":390},{},[391],{"type":20,"value":214},{"type":14,"tag":202,"props":393,"children":394},{},[395],{"type":20,"value":396},"預設值會從 Shader 取得，但可自行定義",{"type":14,"tag":202,"props":398,"children":399},{},[400,402],{"type":20,"value":401},"不透明物件 (Opaque)、半透明物件 (AlphaTest)、透明物件 (Transparent) 預設值分別 2000、2450、以及 3000",{"type":14,"tag":198,"props":403,"children":404},{},[405],{"type":14,"tag":202,"props":406,"children":407},{},[408],{"type":20,"value":409},"通常只有透明物件會關閉 ZWrite",{"type":14,"tag":202,"props":411,"children":412},{},[413,414],{"type":20,"value":224},{"type":14,"tag":54,"props":415,"children":417},{"className":416},[],[418],{"type":20,"value":419},"material.renderQueue",{"type":14,"tag":202,"props":421,"children":422},{},[423,425,428],{"type":20,"value":424},"選擇專案中的 material 編輯",{"type":14,"tag":237,"props":426,"children":427},{},[],{"type":14,"tag":29,"props":429,"children":432},{"href":430,"rel":431},"https://3.bp.blogspot.com/--4-IFurF7lk/Wv_KGSiPZ2I/AAAAAAAAwHk/95Bv8w902lke-HN_CCP1wigeekWuMQknQCHMYCw/s1600/edit-render-queue-unity.png",[33],[433],{"type":14,"tag":103,"props":434,"children":437},{"alt":435,"src":436},"編輯 render queue","/images/2020-10-22-unity-render-order/edit-render-queue-unity.png",[],{"type":14,"tag":202,"props":439,"children":440},{},[441,443],{"type":20,"value":442},"Camera render algorithm",{"type":14,"tag":198,"props":444,"children":445},{},[446,451,483],{"type":14,"tag":202,"props":447,"children":448},{},[449],{"type":20,"value":450},"無法在預設編輯器修改，使用程式調整",{"type":14,"tag":202,"props":452,"children":453},{},[454,456,465],{"type":20,"value":455},"非透明物件排序演算法",{"type":14,"tag":457,"props":458,"children":460},"pre",{"code":459},"camera.opaqueSortMode\n",[461],{"type":14,"tag":54,"props":462,"children":463},{"__ignoreMap":7},[464],{"type":20,"value":459},{"type":14,"tag":198,"props":466,"children":467},{},[468,473,478],{"type":14,"tag":202,"props":469,"children":470},{},[471],{"type":20,"value":472},"Default：在 Unity 2018.1 預設值 FrontToBack",{"type":14,"tag":202,"props":474,"children":475},{},[476],{"type":20,"value":477},"FrontToBack：粗略低由近到遠排序繪製，能使得 GPU rendering 時有更好的效能",{"type":14,"tag":202,"props":479,"children":480},{},[481],{"type":20,"value":482},"NoDistanceSort：關閉排序繪製，能降低 CPU 的使用量",{"type":14,"tag":202,"props":484,"children":485},{},[486,488,496],{"type":20,"value":487},"透明物件排序演算法",{"type":14,"tag":457,"props":489,"children":491},{"code":490},"camera.transparencySortMode\n",[492],{"type":14,"tag":54,"props":493,"children":494},{"__ignoreMap":7},[495],{"type":20,"value":490},{"type":14,"tag":198,"props":497,"children":498},{},[499,504,509,514],{"type":14,"tag":202,"props":500,"children":501},{},[502],{"type":20,"value":503},"Default：根據 camera projection mode 調整",{"type":14,"tag":202,"props":505,"children":506},{},[507],{"type":20,"value":508},"Perspective：根據 camera 位置到物件中心 (object center) 的距離排序",{"type":14,"tag":202,"props":510,"children":511},{},[512],{"type":20,"value":513},"Orthographic：根據 view plane 到物件中心 (object center) 的距離排序",{"type":14,"tag":202,"props":515,"children":516},{},[517,519],{"type":20,"value":518},"CustomAxis：制定 axis 排序，專門用於 2D 遊戲製作，可參考",{"type":14,"tag":29,"props":520,"children":523},{"href":521,"rel":522},"https://qiita.com/RyotaMurohoshi/items/3f0de2689af72f9b46f9",[33],[524],{"type":20,"value":525},"這篇文章",{"type":14,"tag":527,"props":528,"children":530},"h4",{"id":529},"补充renderqueue",[531],{"type":20,"value":532},"补充RenderQueue",{"type":14,"tag":23,"props":534,"children":535},{},[536],{"type":20,"value":537},"nderQueue ，RenderQueue 其实就是shader中tags中的Queue",{"type":14,"tag":457,"props":539,"children":544},{"code":540,"language":541,"meta":7,"className":542},"Tags { \"Queue\"=\"Geometry\" }\n","bash",[543],"language-bash",[545],{"type":14,"tag":54,"props":546,"children":547},{"__ignoreMap":7},[548],{"type":20,"value":540},{"type":14,"tag":23,"props":550,"children":551},{},[552],{"type":20,"value":553},"默认情况下，Unity会基于对象距离摄像机的远近来排序你的对象。因此，当一个对象离摄像机越近，它就会优先绘制在其他更远的对象上面。对于大多数情况这是有效并合适的，但是在一些特殊情况下，你可能想要自己控制对象的绘制顺序。而使用Tags{}块我们就可以得到这样的控制。",{"type":14,"tag":23,"props":555,"children":556},{},[557],{"type":20,"value":558},"Unity提供给我们一些默认的渲染队列，每一个对应一个唯一的值，来指导Unity绘制对象到屏幕上。这些内置的渲染队列被称为Background, Geometry, AlphaTest, GeometryLast,Transparent, Overlay。这些队列不是随便创建的，它们是为了让我们更容易地编写Shader并处理实时渲染的。",{"type":14,"tag":23,"props":560,"children":561},{},[562],{"type":20,"value":563},"同时需在SubShader中显示声明ZWrite Off，通知Unity我们会重写物体的渲染深度排序。",{"type":14,"tag":23,"props":565,"children":566},{},[567],{"type":14,"tag":103,"props":568,"children":570},{"alt":103,"src":569},"https:////upload-images.jianshu.io/upload_images/15536448-9a2deda21e4f661e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/744/format/webp",[],{"type":14,"tag":23,"props":572,"children":573},{},[574],{"type":20,"value":575},"好了，最后给出一个最终的总结：\n依次按条件先后顺序进行排序渲染处理。先按大项条件排序，后按小项条件排序",{"type":14,"tag":23,"props":577,"children":578},{},[579],{"type":20,"value":580},"1.Camera Depth: 越小越优先\n2.RenderQueue 2500以下",{"type":14,"tag":457,"props":582,"children":584},{"code":583},"1. Sorting Layer/Order in Layer\n    1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n    2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n    2.RenderQueue 越小越优先\n    3.RenderQueue 相等，`由近到远排序优先`\n",[585],{"type":14,"tag":54,"props":586,"children":587},{"__ignoreMap":7},[588],{"type":20,"value":583},{"type":14,"tag":23,"props":590,"children":591},{},[592,594],{"type":20,"value":593},"3.RenderQueue 2500以上\n1. Sorting Layer/Order in Layer\n1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n2.RenderQueue 越小越优先\n3.RenderQueue 相等，",{"type":14,"tag":54,"props":595,"children":597},{"className":596},[],[598],{"type":20,"value":599},"由远到近排序优先",{"type":14,"tag":23,"props":601,"children":602},{},[603,605,611],{"type":20,"value":604},"说明一下：2500是关键值，它是透明跟不透明的分界点，因此我们考虑层级的时候要注意着点：renderqueue > 2500的物体绝对会在renderqueue \u003C= 2500的物体前面，即渲染时renderqueue大的会挡住renderqueue小的，不论它的sortingLayer和sortingOrder怎么设置都是不起作用的。知道了这点，其他的就很好理解了。当两个的RenderQueue都在同一侧时，在SortingLayer高的绝对会在sortingLayer前面，无视renderqueue跟soringOrder，只有在sortingLayer相同的前提下，soringOrder高的会在sortingOrder低的前面，无视renderqueue。当sortingLayer跟sortingOrder相同时，才看renderqueue的高低，高的在前面。特别要注意一下半透明物体的渲染顺序是",{"type":14,"tag":54,"props":606,"children":608},{"className":607},[],[609],{"type":20,"value":610},"越远越先渲染",{"type":20,"value":612},"，这与不透明物体是相反的。",{"type":14,"tag":23,"props":614,"children":615},{},[616],{"type":20,"value":617},"UGUI中的ui默认使用的是UI/Default 材质，对应的shader中的渲染队列是Transparent",{"type":14,"tag":457,"props":619,"children":621},{"code":620},"Shader \"UI/Default\"\n{\n    Properties\n    {\n       ...\n    }\n\n    SubShader\n    {\n        Tags\n        {\n            \"Queue\"=\"Transparent\"\n            \"IgnoreProjector\"=\"True\"\n            \"RenderType\"=\"Transparent\"\n            \"PreviewType\"=\"Plane\"\n            \"CanUseSpriteAtlas\"=\"True\"\n        }\n        ...\n    }\n}\n",[622],{"type":14,"tag":54,"props":623,"children":624},{"__ignoreMap":7},[625],{"type":20,"value":620},{"type":14,"tag":15,"props":627,"children":629},{"id":628},"uguis-rendering-order",[630],{"type":20,"value":631},"UGUI’s rendering order",{"type":14,"tag":23,"props":633,"children":634},{},[635],{"type":20,"value":636},"在 Unity 5.x 推出的 UGUI 系統中，其 rendering order 卻是另外規則，這分成兩個部分探討 Canvas & CanvasRenderer，其概念可想像是 CanvasRenderer 可視為畫在畫布 Canvas 的元件，之後該畫布再畫在最終的畫面上（e.g. render target）。",{"type":14,"tag":23,"props":638,"children":639},{},[640],{"type":20,"value":641},"關於 Canvas 的 rendering order：",{"type":14,"tag":198,"props":643,"children":644},{},[645,676],{"type":14,"tag":202,"props":646,"children":647},{},[648,650],{"type":20,"value":649},"Screen Space - Overlay",{"type":14,"tag":198,"props":651,"children":652},{},[653,658],{"type":14,"tag":202,"props":654,"children":655},{},[656],{"type":20,"value":657},"想像該 canvas 由隱藏的 camera 處理，其 depth = 101 (最後才處理)",{"type":14,"tag":202,"props":659,"children":660},{},[661,663,666],{"type":20,"value":662},"多個相同的 canvas 使用 Sort Order 來決定描繪順序，數字越大越晚畫",{"type":14,"tag":237,"props":664,"children":665},{},[],{"type":14,"tag":29,"props":667,"children":670},{"href":668,"rel":669},"https://3.bp.blogspot.com/-Jwq-GkVy5Pg/Wv_MaxvDuEI/AAAAAAAAwII/8xeKRt-08sw9AtYHAxXbPztqk3rlwMH6QCLcBGAs/s1600/edit-canvas-unity.png",[33],[671],{"type":14,"tag":103,"props":672,"children":675},{"alt":673,"src":674},"編輯 Canvas's Sort Order","/images/2020-10-22-unity-render-order/edit-canvas-unity.png",[],{"type":14,"tag":202,"props":677,"children":678},{},[679,681],{"type":20,"value":680},"Screen Space - Camera & World Space",{"type":14,"tag":198,"props":682,"children":683},{},[684,689],{"type":14,"tag":202,"props":685,"children":686},{},[687],{"type":20,"value":688},"想像為存在在世界場景的平面",{"type":14,"tag":202,"props":690,"children":691},{},[692,694,697],{"type":20,"value":693},"多個相同 canvas 使用 Sorting layer 以及 Order in layer 來決定 rendering order",{"type":14,"tag":237,"props":695,"children":696},{},[],{"type":14,"tag":29,"props":698,"children":701},{"href":699,"rel":700},"https://4.bp.blogspot.com/-u-mDDKcRfAY/Wv_NHS9SsZI/AAAAAAAAwIU/Mt_mBRPL8DYo7Xj9Cbh-hOPTFbg6X3UMgCLcBGAs/s1600/edit-canvas-unity.png",[33],[702],{"type":14,"tag":103,"props":703,"children":705},{"alt":704,"src":674},"編輯 Canvas's Sorting layer & Order in layer",[],{"type":14,"tag":23,"props":707,"children":708},{},[709],{"type":20,"value":710},"關於同一個 canvas 下，其 CanvasRenderer 之間的 rendering order：",{"type":14,"tag":198,"props":712,"children":713},{},[714],{"type":14,"tag":202,"props":715,"children":716},{},[717,719],{"type":20,"value":718},"Material render queue > Transform order",{"type":14,"tag":198,"props":720,"children":721},{},[722,727,745],{"type":14,"tag":202,"props":723,"children":724},{},[725],{"type":20,"value":726},"Material render queue 同前面說明，看材質球 (material) 的 render queue 參數",{"type":14,"tag":202,"props":728,"children":729},{},[730,732,735],{"type":20,"value":731},"Transform order：依照 Transform 階層關係，採 Pre-order 方式排序",{"type":14,"tag":237,"props":733,"children":734},{},[],{"type":14,"tag":29,"props":736,"children":739},{"href":737,"rel":738},"https://4.bp.blogspot.com/-fCMusmLKj4k/Wv_NnqL6SXI/AAAAAAAAwIo/suCM_XaddIAEwirQkIibP2wB8Mas3EjagCLcBGAs/s1600/canvas-renderer-rendering-order-unity.png",[33],[740],{"type":14,"tag":103,"props":741,"children":744},{"alt":742,"src":743},"Canvas renderer's rendering order example","/images/2020-10-22-unity-render-order/canvas-renderer-rendering-order-unity.png",[],{"type":14,"tag":202,"props":746,"children":747},{},[748],{"type":20,"value":749},"注意：當所屬的 Canvas 之 render mode 為 Screen Space - Overlay，則無視 Material render queue",{"type":14,"tag":15,"props":751,"children":753},{"id":752},"使用實踐情境",[754],{"type":20,"value":752},{"type":14,"tag":198,"props":756,"children":757},{},[758,821,834],{"type":14,"tag":202,"props":759,"children":760},{},[761,763],{"type":20,"value":762},"3D",{"type":14,"tag":198,"props":764,"children":765},{},[766,784],{"type":14,"tag":202,"props":767,"children":768},{},[769,771],{"type":20,"value":770},"不透明物件 & 半透明物件 (e.g. 草、鐵絲網等等) 依照場景擺放",{"type":14,"tag":198,"props":772,"children":773},{},[774,779],{"type":14,"tag":202,"props":775,"children":776},{},[777],{"type":20,"value":778},"不需要特別設定 rendering order",{"type":14,"tag":202,"props":780,"children":781},{},[782],{"type":20,"value":783},"一切交給 z-buffering 機制",{"type":14,"tag":202,"props":785,"children":786},{},[787,789],{"type":20,"value":788},"透明物件或是粒子特效 (particle system) 可透過 sort layer & order in layer 機制調整 rendering order",{"type":14,"tag":198,"props":790,"children":791},{},[792,804],{"type":14,"tag":202,"props":793,"children":794},{},[795,797,802],{"type":20,"value":796},"透明物件 shader 通常不會寫 z-buffer (e.g. ",{"type":14,"tag":54,"props":798,"children":800},{"className":799},[],[801],{"type":20,"value":163},{"type":20,"value":803},")",{"type":14,"tag":202,"props":805,"children":806},{},[807,809,814,816],{"type":20,"value":808},"可 hack inspector 來設定 ",{"type":14,"tag":54,"props":810,"children":812},{"className":811},[],[813],{"type":20,"value":298},{"type":20,"value":815}," 以及 ",{"type":14,"tag":54,"props":817,"children":819},{"className":818},[],[820],{"type":20,"value":361},{"type":14,"tag":202,"props":822,"children":823},{},[824,826],{"type":20,"value":825},"2D",{"type":14,"tag":198,"props":827,"children":828},{},[829],{"type":14,"tag":202,"props":830,"children":831},{},[832],{"type":20,"value":833},"Sprite renderer 使用 sort layer & order in layer 機制來調整 rendering order，以控制 depth",{"type":14,"tag":202,"props":835,"children":836},{},[837,839],{"type":20,"value":838},"UGUI",{"type":14,"tag":198,"props":840,"children":841},{},[842,847],{"type":14,"tag":202,"props":843,"children":844},{},[845],{"type":20,"value":846},"利用 transform hierarchy 來建立 rendering order，因應效能優化可能還得拆成多個 canvas",{"type":14,"tag":202,"props":848,"children":849},{},[850],{"type":20,"value":851},"若採用 Canvas render mode: World space，想讓 UI 與 3D 場景物件的結合，可將 canvas 視為 3D 物件去設計場景架構 (這自己就沒有經驗…)",{"title":7,"searchDepth":853,"depth":853,"links":854},2,[855,856,857,858],{"id":17,"depth":853,"text":21},{"id":141,"depth":853,"text":144},{"id":628,"depth":853,"text":631},{"id":752,"depth":853,"text":752},"markdown","content:unity:2020-10-22-unity-render-order.md","content","unity/2020-10-22-unity-render-order.md","md","2020-10-22",[866,876,1003,1052,1104,1117,1229],{"title":867,"_path":868,"children":869},"Art","/art",[870,873],{"title":871,"_path":872},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":874,"_path":875},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":877,"_path":878,"children":879},"Dotnet","/dotnet",[880,883,886,889,892,895,898,901,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000],{"title":881,"_path":882},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":884,"_path":885},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":887,"_path":888},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":890,"_path":891},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":893,"_path":894},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":896,"_path":897},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":899,"_path":900},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":902,"_path":903},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":905,"_path":906},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":908,"_path":909},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":911,"_path":912},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":914,"_path":915},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":917,"_path":918},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":920,"_path":921},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":923,"_path":924},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":926,"_path":927},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":929,"_path":930},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":932,"_path":933},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":935,"_path":936},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":938,"_path":939},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":941,"_path":942},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":944,"_path":945},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":947,"_path":948},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":950,"_path":951},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":953,"_path":954},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":956,"_path":957},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":959,"_path":960},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":962,"_path":963},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":965,"_path":966},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":968,"_path":969},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":971,"_path":972},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":974,"_path":975},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":977,"_path":978},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":980,"_path":981},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":983,"_path":984},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":986,"_path":987},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":989,"_path":990},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":992,"_path":993},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":995,"_path":996},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":998,"_path":999},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1001,"_path":1002},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1004,"_path":1005,"children":1006},"Game","/game",[1007,1010,1013,1016,1019,1022,1025,1028,1031,1034,1037,1040,1043,1046,1049],{"title":1008,"_path":1009},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1011,"_path":1012},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1014,"_path":1015},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1017,"_path":1018},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1020,"_path":1021},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1023,"_path":1024},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1026,"_path":1027},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1029,"_path":1030},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1032,"_path":1033},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1035,"_path":1036},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1038,"_path":1039},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1041,"_path":1042},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1044,"_path":1045},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1047,"_path":1048},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1050,"_path":1051},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1053,"_path":1054,"children":1055},"Gyj","/gyj",[1056,1059,1062,1065,1068,1071,1074,1077,1080,1083,1086,1089,1092,1095,1098,1101],{"title":1057,"_path":1058},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1060,"_path":1061},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1063,"_path":1064},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1066,"_path":1067},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1069,"_path":1070},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1072,"_path":1073},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1075,"_path":1076},"玩法","/gyj/2022-08-22-wanfa",{"title":1078,"_path":1079},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1081,"_path":1082},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1084,"_path":1085},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1087,"_path":1088},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1090,"_path":1091},"门派内容相关","/gyj/2022-11-17-sect",{"title":1093,"_path":1094},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1096,"_path":1097},"种植","/gyj/2022-12-01-zhongzhi",{"title":1099,"_path":1100},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1102,"_path":1103},"跑商","/gyj/2023-11-01-paoshang",{"title":1105,"_path":1106,"children":1107},"Js","/js",[1108,1111,1114],{"title":1109,"_path":1110},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1112,"_path":1113},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1115,"_path":1116},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1118,"_path":1119,"children":1120},"Tool","/tool",[1121,1124,1127,1130,1133,1136,1139,1142,1145,1148,1151,1154,1157,1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202,1205,1208,1211,1214,1217,1220,1223,1226],{"title":1122,"_path":1123},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1125,"_path":1126},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1128,"_path":1129},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1131,"_path":1132},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1134,"_path":1135},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1137,"_path":1138},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1140,"_path":1141},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1143,"_path":1144},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1146,"_path":1147},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1149,"_path":1150},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1152,"_path":1153},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1155,"_path":1156},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1158,"_path":1159},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1161,"_path":1162},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1164,"_path":1165},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1167,"_path":1168},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1170,"_path":1171},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1173,"_path":1174},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1176,"_path":1177},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1179,"_path":1180},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1182,"_path":1183},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1185,"_path":1186},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1188,"_path":1189},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1191,"_path":1192},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1194,"_path":1195},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1197,"_path":1198},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1200,"_path":1201},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1203,"_path":1204},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1206,"_path":1207},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1209,"_path":1210},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1212,"_path":1213},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1215,"_path":1216},"rider的使用","/tool/2022-08-02-rider-use",{"title":1218,"_path":1219},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1221,"_path":1222},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1224,"_path":1225},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1227,"_path":1228},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1230,"_path":1231,"children":1232},"Unity","/unity",[1233,1236,1239,1242,1245,1248,1251,1254,1257,1260,1263,1266,1269,1272,1275,1278,1281,1284,1287,1290,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1369,1372,1375,1378,1381,1384,1387,1390,1393,1396,1399,1402,1405,1408,1411,1414,1417,1420,1423,1426,1429,1432,1435,1438,1441,1444],{"title":1234,"_path":1235},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1237,"_path":1238},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1240,"_path":1241},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1243,"_path":1244},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1246,"_path":1247},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1249,"_path":1250},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1252,"_path":1253},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1255,"_path":1256},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1258,"_path":1259},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1261,"_path":1262},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1264,"_path":1265},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1267,"_path":1268},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1270,"_path":1271},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1273,"_path":1274},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1276,"_path":1277},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1279,"_path":1280},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1282,"_path":1283},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1285,"_path":1286},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1288,"_path":1289},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1291,"_path":1292},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1294,"_path":1295},"技能系统","/unity/2020-02-15-skill-system",{"title":1297,"_path":1298},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1300,"_path":1301},"角色状态设计","/unity/2020-02-17-character-states",{"title":1303,"_path":1304},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1306,"_path":1307},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1309,"_path":1310},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1312,"_path":1313},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1315,"_path":1316},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1318,"_path":1319},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1321,"_path":1322},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1324,"_path":1325},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1327,"_path":1328},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1330,"_path":1331},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1333,"_path":1334},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1336,"_path":1337},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1339,"_path":1340},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1342,"_path":1343},"unity的addressables","/unity/2020-09-12-addressables",{"title":1345,"_path":1346},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1348,"_path":1349},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1351,"_path":1352},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1354,"_path":1355},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1357,"_path":1358},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1360,"_path":1361},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1363,"_path":1364},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1366,"_path":1367},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":8,"_path":4},{"title":1370,"_path":1371},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1373,"_path":1374},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1376,"_path":1377},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1379,"_path":1380},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1382,"_path":1383},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1385,"_path":1386},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1388,"_path":1389},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1391,"_path":1392},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1394,"_path":1395},"ability","/unity/2020-11-16-dotssample",{"title":1397,"_path":1398},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1400,"_path":1401},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1403,"_path":1404},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1406,"_path":1407},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1409,"_path":1410},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1412,"_path":1413},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1415,"_path":1416},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1418,"_path":1419},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1421,"_path":1422},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1424,"_path":1425},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1427,"_path":1428},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1430,"_path":1431},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1433,"_path":1434},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1436,"_path":1437},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1439,"_path":1440},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1442,"_path":1443},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1445,"_path":1446},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779039398]