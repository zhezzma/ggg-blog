[{"data":1,"prerenderedAt":1374},["Reactive",2],{"content-query-p8da9ASmZW":3,"content-navigation-8C37fagqQL":792},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":786,"_id":787,"_source":788,"_file":789,"_extension":790,"date":791},"/unity/2020-01-13-unity-attack-detection","unity",false,"","unity攻击范围检测","扇形攻击其实这个分为两部分，是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离是扇形角度范围内计算怪物是否在你的视野范围内其实可以这么看\nAvatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。这样就能判断是否在视线范围内。所以现在的问题就是这么计算这个夹角计算的方式是，获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量调用Vector3.Angle(a, b)计算夹角    public ",{"type":11,"children":12,"toc":776},"root",[13,21,27,42,53,58,63,68,73,92,102,107,115,121,129,134,142,148,156,161,169,174,182,187,192,197,202,207,214,222,227,235,240,248,253,258,264,272,276,284,289,294,299,304,317,322,327,345,351,362,370,375,380,385,390,395,405,410,415,420,425,430,438,443,448,453,461,466,471,476,484,489,497,502,510,515,523,528,533,538,545,550,555,563,568,573,578,583,588,593,606,611,624,629,634,639,644,697,732,740,748,756,761],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"扇形攻击",[19],{"type":20,"value":17},"text",{"type":14,"tag":22,"props":23,"children":24},"p",{},[25],{"type":20,"value":26},"其实这个分为两部分，",{"type":14,"tag":28,"props":29,"children":30},"ul",{},[31,37],{"type":14,"tag":32,"props":33,"children":34},"li",{},[35],{"type":20,"value":36},"是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离",{"type":14,"tag":32,"props":38,"children":39},{},[40],{"type":20,"value":41},"是扇形角度范围内",{"type":14,"tag":22,"props":43,"children":44},{},[45,47],{"type":20,"value":46},"计算怪物是否在你的视野范围内其实可以这么看\n",{"type":14,"tag":48,"props":49,"children":52},"img",{"alt":50,"src":51},"【小松教你手游开发】【unity实用技能】计算目标物体是否在自己的扇形视野范围","/images/2020-01-13-unity-attack-detection/80f6c4220d181e73991a8dfdfda32a81.png",[],{"type":14,"tag":22,"props":54,"children":55},{},[56],{"type":20,"value":57},"Avatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。",{"type":14,"tag":22,"props":59,"children":60},{},[61],{"type":20,"value":62},"这样就能判断是否在视线范围内。",{"type":14,"tag":22,"props":64,"children":65},{},[66],{"type":20,"value":67},"所以现在的问题就是这么计算这个夹角",{"type":14,"tag":22,"props":69,"children":70},{},[71],{"type":20,"value":72},"计算的方式是，",{"type":14,"tag":74,"props":75,"children":76},"ol",{},[77,82,87],{"type":14,"tag":32,"props":78,"children":79},{},[80],{"type":20,"value":81},"获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量",{"type":14,"tag":32,"props":83,"children":84},{},[85],{"type":20,"value":86},"Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量",{"type":14,"tag":32,"props":88,"children":89},{},[90],{"type":20,"value":91},"调用Vector3.Angle(a, b)计算夹角",{"type":14,"tag":93,"props":94,"children":96},"pre",{"code":95},"    public GameObject avatar;\n    public GameObject enemy;\n    \n    //扇形距离 攻击距离  扇形的半径 \n    float minDistance = 10f;\n    //扇形的角度 也就是攻击的角度\n    float minAngle = 120f;\n\n    // Update is called once per frame\n    void Update ()\n    {\n        Vector3 avatarPos = avatar.transform.position;\n        Vector3 enemyPos = enemy.transform.position;\n        \n        //与敌人的距离\n        float distance = Vector3.Distance(avatarPos, enemyPos);\n\n        //主角相对于目标的向量\n        Vector3 srcLocalVect = enemyPos - avatarPos;\n        srcLocalVect.y = 0;\n\n        //获取主角正前方的一个点\n        Vector3 forwardLocalPos = avatar.transform.forward * 1 + avatarPos;\n\n        //获取正方向向量\n        Vector3 forwardLocalVect = forwardLocalPos - avatarPos;\n        forwardLocalVect.y = 0;\n\n        //计算角度\n        float angle = Vector3.Angle(srcLocalVect, forwardLocalVect);\n\n        if(distance \u003C minDistance && angle \u003C minAngle/2)\n        {\n            Debug.Log(\"In EyeSight\");\n        }\n    }\n",[97],{"type":14,"tag":98,"props":99,"children":100},"code",{"__ignoreMap":7},[101],{"type":20,"value":95},{"type":14,"tag":15,"props":103,"children":105},{"id":104},"长方形范围攻击检测",[106],{"type":20,"value":104},{"type":14,"tag":93,"props":108,"children":110},{"code":109},"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance \u003C= 10)\n        {\n            float rightDistance = Vector3.Dot(temVec, transform.right.normalized);\n\n            if (Mathf.Abs(rightDistance) \u003C= 3)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n\n    }\n}\n",[111],{"type":14,"tag":98,"props":112,"children":113},{"__ignoreMap":7},[114],{"type":20,"value":109},{"type":14,"tag":15,"props":116,"children":118},{"id":117},"判断目标点是否在指定的矩形内两个随机点确定的矩形",[119],{"type":20,"value":120},"判断目标点是否在指定的矩形内（两个随机点确定的矩形）",{"type":14,"tag":93,"props":122,"children":124},{"code":123},"\npublic class Rectangle01\n{\n    /// Min为当前坐标系中矩形的最小点\n    /// Max为当前坐标系中矩形的最大点\n    public Vector2 Min;\n    public Vector2 Max;\n \n    public bool Contains( Vector2 point)\n    {\n        if (point.x \u003C this.Min.x)\n        {\n            return false;\n        }\n        if (point.x > this.Max.x)\n        {\n            return false;\n        }\n        if (point.y \u003C this.Min.y)\n        {\n            return false;\n        }\n        if (point.y > this.Max.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        vertex0 = this.Min;\n        vertex1 = new Vector2(this.Max.x, this.Min.y);\n        vertex2 = this.Max;\n        vertex3 = new Vector2(this.Min.x, this.Max.y);\n    }\n}\n",[125],{"type":14,"tag":98,"props":126,"children":127},{"__ignoreMap":7},[128],{"type":20,"value":123},{"type":14,"tag":22,"props":130,"children":131},{},[132],{"type":20,"value":133},"测试   脚本",{"type":14,"tag":93,"props":135,"children":137},{"code":136},"public class TestRt01 : MonoBehaviour {\n \n    public Transform Point;\n    public Transform RtPoint0, RtPoint1;\n    public Rectangle01 rtBox;\n \n    private const float _pointRadius = 0.1f;\n  \n    private void OnDrawGizmos()\n    {\n        if (rtBox != null)\n        {\n            DrawRt(rtBox);\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            rtBox = CreateFromTwoPoints(RtPoint0.position, RtPoint1.position);\n            bool cont = rtBox.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    public Rectangle01 CreateFromTwoPoints(Vector2 point0, Vector2 point1)\n    {\n        Rectangle01 rt = new Rectangle01();\n        if (point0.x \u003C point1.x)\n        {\n            rt.Min.x = point0.x;\n            rt.Max.x = point1.x;\n        }\n        else\n        {\n            rt.Min.x = point1.x;\n            rt.Max.x = point0.x;\n        }\n        if (point0.y \u003C point1.y)\n        {\n            rt.Min.y = point0.y;\n            rt.Max.y = point1.y;\n        }\n        else\n        {\n            rt.Min.y = point1.y;\n            rt.Max.y = point0.y;\n        }\n        return rt;\n    }\n \n    protected void DrawRt( Rectangle01 box)\n    {\n        Vector2 v0, v1, v2, v3;\n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n",[138],{"type":14,"tag":98,"props":139,"children":140},{"__ignoreMap":7},[141],{"type":20,"value":136},{"type":14,"tag":15,"props":143,"children":145},{"id":144},"判断目标点是否在某一矩形区域以任一点为中心的矩形区域",[146],{"type":20,"value":147},"判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）",{"type":14,"tag":93,"props":149,"children":151},{"code":150},"public class Box {\n \n    public Vector2 Center;\n    public Vector2 Axis0;\n    public Vector2 Axis1;\n    public Vector2 Extents;\n \n    public Box(Vector2 center, Vector2 axis0, Vector2 axis1, Vector2 extents)\n    {\n        this.Center = center;\n        this.Axis0 = axis0;\n        this.Axis1 = axis1;\n        this.Extents = extents;\n    }\n    public bool Contains(Vector2 point)\n    {\n        Vector2 vector;\n        vector.x = point.x - this.Center.x;\n        vector.y = point.y - this.Center.y;\n        float num = vector.Dot(ref this.Axis0);\n        if (num \u003C -this.Extents.x)\n        {\n            return false;\n        }\n        if (num > this.Extents.x)\n        {\n            return false;\n        }\n        num = vector.Dot(ref this.Axis1);\n        if (num \u003C -this.Extents.y)\n        {\n            return false;\n        }\n        if (num > this.Extents.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        Vector2 vector = (Vector2)(this.Axis0 * this.Extents.x);\n        Vector2 vector2 = (Vector2)(this.Axis1 * this.Extents.y);\n        vertex0 = (this.Center - vector) - vector2;\n        vertex1 = (this.Center + vector) - vector2;\n        vertex2 = (this.Center + vector) + vector2;\n        vertex3 = (this.Center - vector) + vector2;\n    }\n \n}\n \npublic static class Vector2ex\n{\n    public static float Dot(this Vector2 vector, ref Vector2 value)\n    {\n        return ((vector.x * value.x) + (vector.y * value.y));\n    }\n}\n",[152],{"type":14,"tag":98,"props":153,"children":154},{"__ignoreMap":7},[155],{"type":20,"value":150},{"type":14,"tag":22,"props":157,"children":158},{},[159],{"type":20,"value":160},"测试脚本",{"type":14,"tag":93,"props":162,"children":164},{"code":163},"\npublic class TestBox : MonoBehaviour {\n \n    public Transform Point;\n    public Transform rtBox;\n    Box box;\n    private const float _pointRadius = .11f;\n    private void OnDrawGizmos()\n    {\n        if (box!=null)\n        {\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n            DrawBox(ref box);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            box = new Box(rtBox.position, rtBox.right, rtBox.up, rtBox.localScale); ;\n            bool cont = box.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n \n    protected void DrawBox(ref Box box)\n    {\n        Vector2 v0, v1, v2, v3;\n \n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n",[165],{"type":14,"tag":98,"props":166,"children":167},{"__ignoreMap":7},[168],{"type":20,"value":163},{"type":14,"tag":15,"props":170,"children":172},{"id":171},"半圆形攻击范围检测",[173],{"type":20,"value":171},{"type":14,"tag":93,"props":175,"children":177},{"code":176},"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance \u003C= 10)\n        {\n            if (distance \u003C= 5)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n    }\n}\n",[178],{"type":14,"tag":98,"props":179,"children":180},{"__ignoreMap":7},[181],{"type":20,"value":176},{"type":14,"tag":15,"props":183,"children":185},{"id":184},"圆形攻击范围",[186],{"type":20,"value":184},{"type":14,"tag":22,"props":188,"children":189},{},[190],{"type":20,"value":191},"圆形攻击范围有两种，以玩着荣耀的王昭君大招为例子，",{"type":14,"tag":22,"props":193,"children":194},{},[195],{"type":20,"value":196},"第一种是制定位置施法：新版本的王昭君的大招是指定位置施法的，也就是说在玩家固定施法半径以内可随意放一个圆形的技能。在半径之内的敌人受伤。",{"type":14,"tag":22,"props":198,"children":199},{},[200],{"type":20,"value":201},"第二种是固定位置施法：老版本的王昭君大招是在自身一定半径以内，敌人在这个范围内受伤。",{"type":14,"tag":22,"props":203,"children":204},{},[205],{"type":20,"value":206},"其实两种判断都很简单，只需要判断敌人和SkillPosition之间的距离是否小于半径即可。",{"type":14,"tag":22,"props":208,"children":209},{},[210],{"type":14,"tag":48,"props":211,"children":213},{"alt":48,"src":212},"/images/2020-01-13-unity-attack-detection/20180425195609483.png",[],{"type":14,"tag":93,"props":215,"children":217},{"code":216},"/// \u003Csummary>\n    /// 不定点式圆形攻击\n    /// \u003C/summary>\n    /// \u003Cparam name=\"attacked\">被攻击方\u003C/param>\n    /// \u003Cparam name=\"skillPosition\">技能释放位置\u003C/param>\n    /// \u003Cparam name=\"radius\">半径\u003C/param>\n    /// \u003Creturns>\u003C/returns>\n    public bool CircleAttack(Transform attacked,Transform skillPosition, float radius)\n    {\n        float distance = Vector3.Distance(attacked.position, skillPosition.position);\n        if (distance \u003C radius)\n        {\n            return true;\n        }\n        return false;\n    }\n",[218],{"type":14,"tag":98,"props":219,"children":220},{"__ignoreMap":7},[221],{"type":20,"value":216},{"type":14,"tag":22,"props":223,"children":224},{},[225],{"type":20,"value":226},"方法2",{"type":14,"tag":93,"props":228,"children":230},{"code":229},"public class Circle {\n \n    public Vector2 Center;\n    public float Radius;\n \n    public Circle(Vector2 center, float radius)\n    {\n        this.Center = center;\n        this.Radius = radius;\n    }\n \n    public bool Contains( Vector2 point)\n    {\n        Vector2 vector = point - this.Center;\n        return (vector.SqrMagnitude() \u003C= (this.Radius * this.Radius));\n    }\n \n    public Vector2 Eval(float t)\n    {\n        return new Vector2(this.Center.x + (this.Radius * Mathf.Cos(t)), this.Center.y + (this.Radius * Mathf.Sin(t)));\n    }\n }\n",[231],{"type":14,"tag":98,"props":232,"children":233},{"__ignoreMap":7},[234],{"type":20,"value":229},{"type":14,"tag":15,"props":236,"children":238},{"id":237},"判断一个点是否在三角形里面",[239],{"type":20,"value":237},{"type":14,"tag":93,"props":241,"children":243},{"code":242},"public static  bool InTrigon(Vector3 _target,Vector3 _center,Vector3 _left,Vector3 _right){  \n        Vector3 Ctl=_left-_center;  \n        Vector3 Ctr=_right -_center;  \n        Vector3 Ctt=_target-_center;  \n        Vector3 Ltr=_right-_left;  \n        Vector3 Ltc=_right-_center;  \n        Vector3 Ltt=_left-_target;  \n        Vector3 Rtl=_left-_right;  \n        Vector3 Rtc=_center-_right;  \n        Vector3 Rtt=_target-_right;  \n        if(   \n           Vector3.Dot(Vector3.Cross(Ctl,Ctr).normalized,Vector3.Cross(Ctl,Ctt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Ltr,Ltc).normalized,Vector3.Cross(Ltr,Ltt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Rtc,Rtl).normalized,Vector3.Cross(Rtc,Rtt).normalized)==1  \n           )  \n            return true;  \n        else  \n            return false;  \n    }\n",[244],{"type":14,"tag":98,"props":245,"children":246},{"__ignoreMap":7},[247],{"type":20,"value":242},{"type":14,"tag":22,"props":249,"children":250},{},[251],{"type":20,"value":252},"原理：通过向量之间的对比，利用点乘和差乘实现判断一个点是否在三角形里面。",{"type":14,"tag":22,"props":254,"children":255},{},[256],{"type":20,"value":257},"叉乘： 叉乘结果用右手判断法则。",{"type":14,"tag":259,"props":260,"children":262},"h3",{"id":261},"方法二",[263],{"type":20,"value":261},{"type":14,"tag":93,"props":265,"children":267},{"code":266},"public class Triangle \n{\n    public enum Orientations\n    {\n        CW,//三个点顺时针\n        CCW,//三个点逆时针\n        None//不清楚点的顺序\n    }\n \n    public Vector2 V0;\n    public Vector2 V1;\n    public Vector2 V2;\n    public Triangle(Vector2 v0, Vector2 v1, Vector2 v2)\n    {\n        this.V0 = v0;\n        this.V1 = v1;\n        this.V2 = v2;\n    }\n    public static Triangle CreateTriangle2(Transform v0, Transform v1, Transform v2)\n    {\n        return new Triangle(v0.position, v1.position, v2.position);\n    }\n \n    public Orientations CalcOrientation(float threshold = 1E-05f)\n    {\n        float num = this.CalcDeterminant();\n        if (num > threshold)\n        {\n            return Orientations.CCW;\n        }\n        if (num \u003C -threshold)\n        {\n            return Orientations.CW;\n        }\n        return Orientations.None;\n    }\n \n    public float CalcDeterminant()\n    {\n        return ((((((this.V1.x * this.V2.y) + (this.V0.x * this.V1.y)) + (this.V2.x * this.V0.y)) - (this.V1.x * this.V0.y)) - (this.V2.x * this.V1.y)) - (this.V0.x * this.V2.y));\n    }\n \n    public bool Contains(Vector2 point)\n    {\n        bool flag = (((point.x - this.V1.x) * (this.V0.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V0.x - this.V1.x))) \u003C 0f;\n        bool flag2 = (((point.x - this.V2.x) * (this.V1.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V1.x - this.V2.x))) \u003C 0f;\n        if (flag != flag2)\n        {\n            return false;\n        }\n        bool flag3 = (((point.x - this.V0.x) * (this.V2.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V2.x - this.V0.x))) \u003C 0f;\n        return (flag2 == flag3);\n    }\n \n    /// \u003Csummary>\n    /// 当已经知道 三个顶点的顺序是逆时针方向的时候使用\n    /// \u003C/summary>\n    /// \u003Cparam name=\"point\">\u003C/param>\n    /// \u003Creturns>\u003C/returns>\n    public bool ContainsCCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) > 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    /// \u003Csummary>\n    /// 当已经知道 三个顶点的顺序是顺时针方向的时候使用\n    /// \u003C/summary>\n    /// \u003Cparam name=\"point\">\u003C/param>\n    /// \u003Creturns>\u003C/returns>\n    public bool ContainsCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) \u003C 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) \u003C 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) \u003C 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n\n}\n",[268],{"type":14,"tag":98,"props":269,"children":270},{"__ignoreMap":7},[271],{"type":20,"value":266},{"type":14,"tag":22,"props":273,"children":274},{},[275],{"type":20,"value":160},{"type":14,"tag":93,"props":277,"children":279},{"code":278},"\npublic class TriangleTest : MonoBehaviour {\n    public Transform Point;\n    public Transform V0, V1, V2;\n    Triangle triangle;\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            triangle = Triangle.CreateTriangle2(V0, V1, V2);\n            Triangle.Orientations orientation = triangle.CalcOrientation();\n \n            bool cont = false;\n            if (orientation == Triangle.Orientations.CCW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else if (orientation == Triangle.Orientations.CW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else // Degenerate\n            {\n                Debug.LogError(\"Triangle is degenerate\");\n            }\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    private void OnDrawGizmos()\n    {\n        if (triangle!=null)\n        {\n            DrawTriangle( triangle);\n        }\n    }\n \n \n    void DrawTriangle( Triangle triangle)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(triangle.V0, triangle.V1);\n        Gizmos.DrawLine(triangle.V1, triangle.V2);\n        Gizmos.DrawLine(triangle.V2, triangle.V0);\n    }\n\n}\n",[280],{"type":14,"tag":98,"props":281,"children":282},{"__ignoreMap":7},[283],{"type":20,"value":278},{"type":14,"tag":15,"props":285,"children":287},{"id":286},"向量",[288],{"type":20,"value":286},{"type":14,"tag":22,"props":290,"children":291},{},[292],{"type":20,"value":293},"其实这些小算法基本上用的全是向量的计算,向量的计算有两种",{"type":14,"tag":259,"props":295,"children":297},{"id":296},"向量的点乘",[298],{"type":20,"value":296},{"type":14,"tag":22,"props":300,"children":301},{},[302],{"type":20,"value":303},"–>A . B = |A| * |B| * cos θ\n–>点乘应用",{"type":14,"tag":74,"props":305,"children":306},{},[307,312],{"type":14,"tag":32,"props":308,"children":309},{},[310],{"type":20,"value":311},"如果 让 A 等于单位向量 |A| ==1 c点积 等于 B 在 A 上的投影",{"type":14,"tag":32,"props":313,"children":314},{},[315],{"type":20,"value":316},"如果 让 A B等于单位向量 arccos(a.b) == 夹角",{"type":14,"tag":259,"props":318,"children":320},{"id":319},"向量的叉乘",[321],{"type":20,"value":319},{"type":14,"tag":22,"props":323,"children":324},{},[325],{"type":20,"value":326},"–>A* B = C C就是A和B的法向量\n–>叉乘应用",{"type":14,"tag":74,"props":328,"children":329},{},[330,335,340],{"type":14,"tag":32,"props":331,"children":332},{},[333],{"type":20,"value":334},"c 是有方向 。 通过 左手 定则 可以知道 C 的方向",{"type":14,"tag":32,"props":336,"children":337},{},[338],{"type":20,"value":339},"所以叉乘一般是用来计算方向的",{"type":14,"tag":32,"props":341,"children":342},{},[343],{"type":20,"value":344},"A 和 B 都是单位向量 arcsin(|A*B|) 等于 夹角",{"type":14,"tag":15,"props":346,"children":348},{"id":347},"凸多边形碰撞分离轴定理算法",[349],{"type":20,"value":350},"凸多边形碰撞(分离轴定理算法)",{"type":14,"tag":22,"props":352,"children":353},{},[354,356],{"type":20,"value":355},"*",{"type":14,"tag":357,"props":358,"children":359},"strong",{},[360],{"type":20,"value":361},"正文如下：*",{"type":14,"tag":22,"props":363,"children":364},{},[365],{"type":14,"tag":48,"props":366,"children":369},{"alt":367,"src":368},"多边形碰撞","/images/2020-01-13-unity-attack-detection/20170204235932265.jpg",[],{"type":14,"tag":22,"props":371,"children":372},{},[373],{"type":20,"value":374},"分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。",{"type":14,"tag":22,"props":376,"children":377},{},[378],{"type":20,"value":379},"我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。",{"type":14,"tag":22,"props":381,"children":382},{},[383],{"type":20,"value":384},"我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：）",{"type":14,"tag":22,"props":386,"children":387},{},[388],{"type":20,"value":389},"当我发现我需要在flash中检测多边形碰撞时，我碰巧地遇到了一个叫“分离轴定理”的方法。但唯一的问题是，为了真正地掌握它，我可费了不少功夫。",{"type":14,"tag":22,"props":391,"children":392},{},[393],{"type":20,"value":394},"在阅读了大量有关碰撞检测的资料，并参看了一些代码示例后，这个方法总算被我领悟了。",{"type":14,"tag":22,"props":396,"children":397},{},[398,400],{"type":20,"value":399},"为了帮助其他那些不精通数学的开发者，我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍。我还在下文引入了一个使用分离轴定理实现的demo，以及供大家下载并使用的ActionScript 3源代码。",{"type":14,"tag":357,"props":401,"children":402},{},[403],{"type":20,"value":404},"（译者：demo和源代码请到原文中查看和下载）",{"type":14,"tag":22,"props":406,"children":407},{},[408],{"type":20,"value":409},"注意：分离轴定理需要一点数学向量的知识，所以在深究这个算法前，你最好复习一下这方面的内容。",{"type":14,"tag":15,"props":411,"children":413},{"id":412},"算法简述",[414],{"type":20,"value":412},{"type":14,"tag":22,"props":416,"children":417},{},[418],{"type":20,"value":419},"从根本上来讲，分离轴定理（以及其他碰撞算法）的用途就是去检测并判断两个图形之间是否有间隙。分离轴定理中用到的方法使算法本身显得十分独特。",{"type":14,"tag":22,"props":421,"children":422},{},[423],{"type":20,"value":424},"我所听到过分离轴定理的最好类比方式是这样的：",{"type":14,"tag":22,"props":426,"children":427},{},[428],{"type":20,"value":429},"假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？",{"type":14,"tag":22,"props":431,"children":432},{},[433],{"type":14,"tag":48,"props":434,"children":437},{"alt":435,"src":436},"投影问题","/images/2020-01-13-unity-attack-detection/20170205000242395.jpg",[],{"type":14,"tag":22,"props":439,"children":440},{},[441],{"type":20,"value":442},"如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。",{"type":14,"tag":22,"props":444,"children":445},{},[446],{"type":20,"value":447},"从编程的角度来讲，从每个可能的角度上去检测会使处理变得十分密集。不过幸运的是，由于多边形的性质，你只需要检测其中几个关键的角度。",{"type":14,"tag":22,"props":449,"children":450},{},[451],{"type":20,"value":452},"你需要检测的角度数量就正是这个多边形的边数。也就是说，你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和。举个例子，两个五边形就需要检测10个角度。",{"type":14,"tag":22,"props":454,"children":455},{},[456],{"type":14,"tag":48,"props":457,"children":460},{"alt":458,"src":459},"角度选取","/images/2020-01-13-unity-attack-detection/20170205000357272.jpg",[],{"type":14,"tag":15,"props":462,"children":464},{"id":463},"如何在代码中实现",[465],{"type":20,"value":463},{"type":14,"tag":22,"props":467,"children":468},{},[469],{"type":20,"value":470},"这是一个简易但比较啰嗦的方法，以下是基本的步骤：",{"type":14,"tag":22,"props":472,"children":473},{},[474],{"type":20,"value":475},"**步骤一：**从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。",{"type":14,"tag":22,"props":477,"children":478},{},[479],{"type":14,"tag":48,"props":480,"children":483},{"alt":481,"src":482},"步骤一图解","/images/2020-01-13-unity-attack-detection/20170205000919294.jpg",[],{"type":14,"tag":22,"props":485,"children":486},{},[487],{"type":20,"value":488},"**步骤二：**循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点）",{"type":14,"tag":22,"props":490,"children":491},{},[492],{"type":14,"tag":48,"props":493,"children":496},{"alt":494,"src":495},"步骤二图解","/images/2020-01-13-unity-attack-detection/20170205001546835.jpg",[],{"type":14,"tag":22,"props":498,"children":499},{},[500],{"type":20,"value":501},"**步骤三：**对第二个多边形做同样的处理。",{"type":14,"tag":22,"props":503,"children":504},{},[505],{"type":14,"tag":48,"props":506,"children":509},{"alt":507,"src":508},"步骤三图解","/images/2020-01-13-unity-attack-detection/20170205001940563.jpg",[],{"type":14,"tag":22,"props":511,"children":512},{},[513],{"type":20,"value":514},"**步骤四：**分别得到这两个多边形的投影，并检测这两段投影是否重叠。",{"type":14,"tag":22,"props":516,"children":517},{},[518],{"type":14,"tag":48,"props":519,"children":522},{"alt":520,"src":521},"步骤四图解","/images/2020-01-13-unity-attack-detection/20170205002051627.jpg",[],{"type":14,"tag":22,"props":524,"children":525},{},[526],{"type":20,"value":527},"如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。",{"type":14,"tag":22,"props":529,"children":530},{},[531],{"type":20,"value":532},"这个算法基本就是如此的。",{"type":14,"tag":22,"props":534,"children":535},{},[536],{"type":20,"value":537},"顺带提一下，如果你记录了哪个轴上的投影重叠值最小（以及重叠了多少），那么你就能用这个值来分开这两个图形。",{"type":14,"tag":539,"props":540,"children":542},"h2",{"id":541},"那么如何处理圆呢",[543],{"type":20,"value":544},"那么如何处理圆呢？",{"type":14,"tag":22,"props":546,"children":547},{},[548],{"type":20,"value":549},"在分离轴定理中，检测圆与检测多边形相比，会有点点奇异，但仍然是可以实现的。",{"type":14,"tag":22,"props":551,"children":552},{},[553],{"type":20,"value":554},"最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。",{"type":14,"tag":22,"props":556,"children":557},{},[558],{"type":14,"tag":48,"props":559,"children":562},{"alt":560,"src":561},"圆的投影轴","/images/2020-01-13-unity-attack-detection/20170205002152799.jpg",[],{"type":14,"tag":22,"props":564,"children":565},{},[566],{"type":20,"value":567},"在这以后就是按套路遍历另一个多边形的每条投影轴，并检测是否有投影重叠。",{"type":14,"tag":22,"props":569,"children":570},{},[571],{"type":20,"value":572},"噢，对了，万一你想知道如何把圆投影到轴上，那你只用简单地把圆心投影上去，然后加上和减去半径就能得到投影长度了。",{"type":14,"tag":15,"props":574,"children":576},{"id":575},"优点与不足",[577],{"type":20,"value":575},{"type":14,"tag":22,"props":579,"children":580},{},[581],{"type":20,"value":582},"和其他的碰撞检测技术一样，分离轴定理算法有它自己的优点和不足。以下是其一些优点和不足的简要概述：",{"type":14,"tag":539,"props":584,"children":586},{"id":585},"优点",[587],{"type":20,"value":585},{"type":14,"tag":22,"props":589,"children":590},{},[591],{"type":20,"value":592},"（译者：原来老外也喜欢先谈优点啊～>～）",{"type":14,"tag":28,"props":594,"children":595},{},[596,601],{"type":14,"tag":32,"props":597,"children":598},{},[599],{"type":20,"value":600},"分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。",{"type":14,"tag":32,"props":602,"children":603},{},[604],{"type":20,"value":605},"分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……）",{"type":14,"tag":539,"props":607,"children":609},{"id":608},"不足",[610],{"type":20,"value":608},{"type":14,"tag":28,"props":612,"children":613},{},[614,619],{"type":14,"tag":32,"props":615,"children":616},{},[617],{"type":20,"value":618},"分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。",{"type":14,"tag":32,"props":620,"children":621},{},[622],{"type":20,"value":623},"分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。",{"type":14,"tag":22,"props":625,"children":626},{},[627],{"type":20,"value":628},"可能这个算法会有更多优点和不足之处，但是我想这应该是最主要的几个了。",{"type":14,"tag":15,"props":630,"children":632},{"id":631},"总结",[633],{"type":20,"value":631},{"type":14,"tag":22,"props":635,"children":636},{},[637],{"type":20,"value":638},"我希望这篇文章能帮助你了解到分离轴定理算法。我已经尽可能地不提供过多的信息并讲解得十分简明了。（我绝不是数学方面的专家，所以如果我遗漏了什么，我深表歉意）",{"type":14,"tag":22,"props":640,"children":641},{},[642],{"type":20,"value":643},"以下是一些帮助我理解分离轴定理算法的页面：",{"type":14,"tag":28,"props":645,"children":646},{},[647,661,673,685],{"type":14,"tag":32,"props":648,"children":649},{},[650,659],{"type":14,"tag":651,"props":652,"children":656},"a",{"href":653,"rel":654},"http://www.harveycartel.org/metanet/tutorials/tutorialA.html",[655],"nofollow",[657],{"type":20,"value":658},"harverycartel.org",{"type":20,"value":660},"——有更多详细的表述以及很多很酷的示例。我在这个页面上学到了很多。",{"type":14,"tag":32,"props":662,"children":663},{},[664,671],{"type":14,"tag":651,"props":665,"children":668},{"href":666,"rel":667},"http://gpwiki.org/index.php/VB:Tutorials:Building_A_Physics_Engine:Basic_Intersection_Detection",[655],[669],{"type":20,"value":670},"GPWiki.org",{"type":20,"value":672},"——有不错的讲解和代码示例，我用这些代码作为编写自己代码的基础。",{"type":14,"tag":32,"props":674,"children":675},{},[676,683],{"type":14,"tag":651,"props":677,"children":680},{"href":678,"rel":679},"http://www.tonypa.pri.ee/vectors/index.html",[655],[681],{"type":20,"value":682},"Tony Pa",{"type":20,"value":684},"——向量教程，学习向量的不错资源。",{"type":14,"tag":32,"props":686,"children":687},{},[688,695],{"type":14,"tag":651,"props":689,"children":692},{"href":690,"rel":691},"http://www.gamedev.net/community/forums/topic.asp?topic_id=251638",[655],[693],{"type":20,"value":694},"GameDev.net forum",{"type":20,"value":696},"——一个论坛成员写的分离轴定理碰撞检测系统，带给了我一些计算方面的想法。",{"type":14,"tag":22,"props":698,"children":699},{},[700,705,715,720,730],{"type":14,"tag":357,"props":701,"children":702},{},[703],{"type":20,"value":704},"本文翻译自",{"type":14,"tag":651,"props":706,"children":709},{"href":707,"rel":708},"http://www.sevenson.com.au/",[655],[710],{"type":14,"tag":357,"props":711,"children":712},{},[713],{"type":20,"value":714},"@sevenson",{"type":14,"tag":357,"props":716,"children":717},{},[718],{"type":20,"value":719},"的文章",{"type":14,"tag":651,"props":721,"children":724},{"href":722,"rel":723},"http://www.sevenson.com.au/actionscript/sat/",[655],[725],{"type":14,"tag":357,"props":726,"children":727},{},[728],{"type":20,"value":729},"Separating Axis Theorem (SAT) Explanation",{"type":20,"value":731},"** 。**",{"type":14,"tag":93,"props":733,"children":735},{"code":734},"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XRect{\n    private Vector2 _point0 = new Vector2();\n    private Vector2 _point1 = new Vector2();\n    private Vector2 _point2 = new Vector2();\n    private Vector2 _point3 = new Vector2();\n\n    public List\u003CVector2> _pointList = new List\u003CVector2>();\n\n    private float _min = 0;\n    private float _max = 0;\n\n\n    public void UpdatePoint(RectTransform RT)\n    {\n        float x = RT.localPosition.x;\n        float y = RT.localPosition.y;\n        float width = RT.sizeDelta.x;\n        float height = RT.sizeDelta.y;\n        float angle = RT.localRotation.eulerAngles.z;\n\n        Vector2 centerV = new Vector2(RT.localPosition.x, RT.localPosition.y);\n\n        _point0 = new Vector2(x - width / 2, y + height / 2);\n        _point0 = _Transform(_point0,angle,centerV);\n\n        _point1 = new Vector2(x + width / 2, y + height / 2);\n        _point1 = _Transform(_point1, angle, centerV);\n\n        _point2 = new Vector2(x + width / 2, y - height / 2);\n        _point2 = _Transform(_point2, angle, centerV);\n\n        _point3 = new Vector2(x - width / 2, y - height / 2);\n        _point3 = _Transform(_point3, angle, centerV);\n\n        _pointList.Clear();\n        _pointList.Add(_point0);\n        _pointList.Add(_point1);\n        _pointList.Add(_point2);\n        _pointList.Add(_point3);\n\n        Vector3[] temp = new Vector3[4];\n        RT.GetLocalCorners(temp);\n       \n    }\n\n    //获取投影轴\n    public Vector2 GetAxis(int index)\n    {\n        Vector2 v = _GetEdge(index);\n\n        Vector2 result = new Vector2();\n\n        result.x = v.y;\n        result.y = 0 - v.x;\n\n        return result;\n    }\n\n    public void ResetProjection(Vector2 axis)\n    {\n        if (axis.x == 0 && axis.y == 0)\n        {\n            Debug.LogError(\"投影轴数据错误！\");\n            return;\n        }\n        float projectionX;\n        Vector2 v;\n        for (int i = 0; i \u003C _pointList.Count; ++i)\n        {\n            v = _pointList[i];\n            if (axis.x == 0)\n            {\n                projectionX = v.y;\n            }\n            else if (axis.y == 0)\n            {\n                projectionX = v.x;\n            }\n            else\n            {\n                projectionX = (v.x - axis.x / axis.y * v.y) / (1 + Mathf.Pow(axis.x / axis.y, 2));\n            }\n\n\n            if (i == 0)\n            {\n                _min = projectionX;\n                _max = projectionX;\n            }\n            else\n            {\n                if (projectionX > _max)\n                {\n                    _max = projectionX;\n                }\n                if (projectionX \u003C _min)\n                {\n                    _min = projectionX;\n                }\n            }\n\n        } \n    }\n\n    public float GetMin()\n    {\n        return _min;\n    }\n\n    public float GetMax()\n    {\n        return _max;\n    }\n\n\n    //获取边向量\n    private Vector2 _GetEdge(int index)\n    {\n        Vector2 result = new Vector2();\n        switch (index)\n        {\n            case 0:\n                result = _point1 - _point0;\n                break;\n            case 1:\n                result = _point2 - _point1;\n                break;\n            case 2:\n                result = _point3 - _point2;\n                break;\n            case 3:\n                result = _point0 - _point3;\n                break;\n        }\n\n        return result;\n    }\n\n    private Vector2 _Transform(Vector2 v,float angle,Vector2 centerV)\n    {\n        Vector2 result = new Vector2();\n\n        float initX = v.x;\n        float initY = v.y;\n\n        //将顶点移动到原点四周\n        float centerPointX = initX - centerV.x;\n        float centerPointY = initY - centerV.y;\n\n        float r = angle * Mathf.Deg2Rad;\n\n        float a = Mathf.Cos(r);\n        float b = Mathf.Sin(r);\n\n        result.x = centerPointX * a + centerPointY * (-b) + centerV.x;\n        result.y = centerPointX * b + centerPointY * a + centerV.y;\n\n        return result;\n    }\n",[736],{"type":14,"tag":98,"props":737,"children":738},{"__ignoreMap":7},[739],{"type":20,"value":734},{"type":14,"tag":93,"props":741,"children":743},{"code":742},"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XCollisionHelper {\n\n    private static XCollisionHelper _instance;\n\n    public static XCollisionHelper GetInstance()\n    {\n        if (_instance  == null)\n        {\n            _instance = new XCollisionHelper();\n        }\n\n        return _instance;\n    }\n\n    public bool Check(XRect xRect1,XRect xRect2)\n    {\n        for (int i = 0; i \u003C4;++i)\n        {\n            Vector2 axis = xRect1.GetAxis(i);\n\n            //获取两个矩形在投影轴上的范围\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() \u003C xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        for (int i = 0; i \u003C 4; ++i)\n        {\n            Vector2 axis = xRect2.GetAxis(i);\n\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() \u003C xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    \n\n}\n",[744],{"type":14,"tag":98,"props":745,"children":746},{"__ignoreMap":7},[747],{"type":20,"value":742},{"type":14,"tag":93,"props":749,"children":751},{"code":750},"﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class XRectItemCtrl : MonoBehaviour, IDragHandler\n{\n\n    public Image imgRect;\n    private XRect _xRect = new XRect();\n\n    public XRect GetXRect()\n    {\n        RectTransform RT = transform.GetComponent\u003CRectTransform>();\n        _xRect.UpdatePoint(RT);\n\n        if (transform.gameObject.name == \"Image0\")\n        {\n        }\n\n        return _xRect;\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        RectTransform RT = transform.GetComponent\u003CRectTransform>();\n        RT.localPosition = new Vector2(RT.localPosition.x + eventData.delta.x, RT.localPosition.y + eventData.delta.y);\n    }\n}\n",[752],{"type":14,"tag":98,"props":753,"children":754},{"__ignoreMap":7},[755],{"type":20,"value":750},{"type":14,"tag":15,"props":757,"children":759},{"id":758},"其他的一些参考",[760],{"type":20,"value":758},{"type":14,"tag":28,"props":762,"children":763},{},[764,767,770,773],{"type":14,"tag":32,"props":765,"children":766},{},[],{"type":14,"tag":32,"props":768,"children":769},{},[],{"type":14,"tag":32,"props":771,"children":772},{},[],{"type":14,"tag":32,"props":774,"children":775},{},[],{"title":7,"searchDepth":777,"depth":777,"links":778},2,[779,781,782,783,784,785],{"id":261,"depth":780,"text":261},3,{"id":296,"depth":780,"text":296},{"id":319,"depth":780,"text":319},{"id":541,"depth":777,"text":544},{"id":585,"depth":777,"text":585},{"id":608,"depth":777,"text":608},"markdown","content:unity:2020-01-13-unity-attack-detection.md","content","unity/2020-01-13-unity-attack-detection.md","md","2020-01-13",[793,803,930,979,1031,1044,1156],{"title":794,"_path":795,"children":796},"Art","/art",[797,800],{"title":798,"_path":799},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":801,"_path":802},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":804,"_path":805,"children":806},"Dotnet","/dotnet",[807,810,813,816,819,822,825,828,831,834,837,840,843,846,849,852,855,858,861,864,867,870,873,876,879,882,885,888,891,894,897,900,903,906,909,912,915,918,921,924,927],{"title":808,"_path":809},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":811,"_path":812},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":814,"_path":815},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":817,"_path":818},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":820,"_path":821},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":823,"_path":824},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":826,"_path":827},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":829,"_path":830},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":832,"_path":833},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":835,"_path":836},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":838,"_path":839},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":841,"_path":842},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":844,"_path":845},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":847,"_path":848},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":850,"_path":851},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":853,"_path":854},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":856,"_path":857},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":859,"_path":860},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":862,"_path":863},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":865,"_path":866},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":868,"_path":869},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":871,"_path":872},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":874,"_path":875},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":877,"_path":878},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":880,"_path":881},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":883,"_path":884},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":886,"_path":887},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":889,"_path":890},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":892,"_path":893},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":895,"_path":896},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":898,"_path":899},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":901,"_path":902},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":904,"_path":905},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":907,"_path":908},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":910,"_path":911},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":913,"_path":914},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":916,"_path":917},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":919,"_path":920},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":922,"_path":923},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":925,"_path":926},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":928,"_path":929},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":931,"_path":932,"children":933},"Game","/game",[934,937,940,943,946,949,952,955,958,961,964,967,970,973,976],{"title":935,"_path":936},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":938,"_path":939},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":941,"_path":942},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":944,"_path":945},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":947,"_path":948},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":950,"_path":951},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":953,"_path":954},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":956,"_path":957},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":959,"_path":960},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":962,"_path":963},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":965,"_path":966},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":968,"_path":969},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":971,"_path":972},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":974,"_path":975},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":977,"_path":978},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":980,"_path":981,"children":982},"Gyj","/gyj",[983,986,989,992,995,998,1001,1004,1007,1010,1013,1016,1019,1022,1025,1028],{"title":984,"_path":985},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":987,"_path":988},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":990,"_path":991},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":993,"_path":994},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":996,"_path":997},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":999,"_path":1000},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1002,"_path":1003},"玩法","/gyj/2022-08-22-wanfa",{"title":1005,"_path":1006},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1008,"_path":1009},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1011,"_path":1012},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1014,"_path":1015},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1017,"_path":1018},"门派内容相关","/gyj/2022-11-17-sect",{"title":1020,"_path":1021},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1023,"_path":1024},"种植","/gyj/2022-12-01-zhongzhi",{"title":1026,"_path":1027},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1029,"_path":1030},"跑商","/gyj/2023-11-01-paoshang",{"title":1032,"_path":1033,"children":1034},"Js","/js",[1035,1038,1041],{"title":1036,"_path":1037},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1039,"_path":1040},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1042,"_path":1043},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1045,"_path":1046,"children":1047},"Tool","/tool",[1048,1051,1054,1057,1060,1063,1066,1069,1072,1075,1078,1081,1084,1087,1090,1093,1096,1099,1102,1105,1108,1111,1114,1117,1120,1123,1126,1129,1132,1135,1138,1141,1144,1147,1150,1153],{"title":1049,"_path":1050},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1052,"_path":1053},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1055,"_path":1056},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1058,"_path":1059},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1061,"_path":1062},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1064,"_path":1065},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1067,"_path":1068},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1070,"_path":1071},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1073,"_path":1074},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1076,"_path":1077},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1079,"_path":1080},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1082,"_path":1083},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1085,"_path":1086},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1088,"_path":1089},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1091,"_path":1092},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1094,"_path":1095},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1097,"_path":1098},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1100,"_path":1101},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1103,"_path":1104},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1106,"_path":1107},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1109,"_path":1110},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1112,"_path":1113},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1115,"_path":1116},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1118,"_path":1119},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1121,"_path":1122},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1124,"_path":1125},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1127,"_path":1128},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1130,"_path":1131},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1133,"_path":1134},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1136,"_path":1137},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1139,"_path":1140},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1142,"_path":1143},"rider的使用","/tool/2022-08-02-rider-use",{"title":1145,"_path":1146},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1148,"_path":1149},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1151,"_path":1152},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1154,"_path":1155},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1157,"_path":1158,"children":1159},"Unity","/unity",[1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202,1205,1208,1211,1214,1217,1218,1221,1224,1227,1230,1233,1236,1239,1242,1245,1248,1251,1254,1257,1260,1263,1266,1269,1272,1275,1278,1281,1284,1287,1290,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371],{"title":1161,"_path":1162},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1164,"_path":1165},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1167,"_path":1168},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1170,"_path":1171},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1173,"_path":1174},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1176,"_path":1177},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1179,"_path":1180},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1182,"_path":1183},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1185,"_path":1186},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1188,"_path":1189},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1191,"_path":1192},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1194,"_path":1195},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1197,"_path":1198},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1200,"_path":1201},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1203,"_path":1204},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1206,"_path":1207},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1209,"_path":1210},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1212,"_path":1213},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1215,"_path":1216},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":8,"_path":4},{"title":1219,"_path":1220},"技能系统","/unity/2020-02-15-skill-system",{"title":1222,"_path":1223},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1225,"_path":1226},"角色状态设计","/unity/2020-02-17-character-states",{"title":1228,"_path":1229},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1231,"_path":1232},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1234,"_path":1235},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1237,"_path":1238},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1240,"_path":1241},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1243,"_path":1244},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1246,"_path":1247},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1249,"_path":1250},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1252,"_path":1253},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1255,"_path":1256},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1258,"_path":1259},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1261,"_path":1262},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1264,"_path":1265},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1267,"_path":1268},"unity的addressables","/unity/2020-09-12-addressables",{"title":1270,"_path":1271},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1273,"_path":1274},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1276,"_path":1277},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1279,"_path":1280},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1282,"_path":1283},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1285,"_path":1286},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1288,"_path":1289},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1291,"_path":1292},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1294,"_path":1295},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1297,"_path":1298},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1300,"_path":1301},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1303,"_path":1304},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1306,"_path":1307},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1309,"_path":1310},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1312,"_path":1313},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1315,"_path":1316},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1318,"_path":1319},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1321,"_path":1322},"ability","/unity/2020-11-16-dotssample",{"title":1324,"_path":1325},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1327,"_path":1328},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1330,"_path":1331},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1333,"_path":1334},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1336,"_path":1337},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1339,"_path":1340},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1342,"_path":1343},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1345,"_path":1346},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1348,"_path":1349},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1351,"_path":1352},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1354,"_path":1355},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1357,"_path":1358},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1360,"_path":1361},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1363,"_path":1364},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1366,"_path":1367},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1369,"_path":1370},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1372,"_path":1373},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041113]