[{"data":1,"prerenderedAt":1206},["Reactive",2],{"content-query-cGccEVY4za":3,"content-navigation-8C37fagqQL":624},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":618,"_id":619,"_source":620,"_file":621,"_extension":622,"date":623},"/unity/2020-07-01-unity-coordinate","unity",false,"","unity的坐标体系","一、前言刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了：区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y ",{"type":11,"children":12,"toc":612},"root",[13,22,28,33,42,47,52,58,63,88,96,101,110,124,136,189,197,205,210,231,239,274,287,295,303,308,387,415,423,428,436,441,449,510,518,531,540,567,579,587,592,601,607],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"一前言",[19],{"type":20,"value":21},"text","一、前言",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":27},"刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。",{"type":14,"tag":23,"props":29,"children":30},{},[31],{"type":20,"value":32},"其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了：",{"type":14,"tag":23,"props":34,"children":35},{},[36],{"type":14,"tag":37,"props":38,"children":41},"img",{"alt":39,"src":40},"zggtdzunj4","/images/2020-07-01-unity-coordinate/zggtdzunj4.jpeg",[],{"type":14,"tag":23,"props":43,"children":44},{},[45],{"type":20,"value":46},"区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y 轴就是左手坐标系，如果是右手 90 度握紧后到了 y 轴就是右手坐标系。",{"type":14,"tag":23,"props":48,"children":49},{},[50],{"type":20,"value":51},"除了 3D 世界中的坐标系，还有其他的几个坐标系也非常常用，比如我们经常要把世界三维坐标系转换成我们最终屏幕中的二维坐标系，或者把手机屏幕的二维坐标系转化成游戏世界中的三维坐标系等，各个坐标系各有特别，不能混用，为了更好的学习 Unity 游戏开发，自己在此总结一下 Unity 当中的坐标系和相关用法，以作备忘和学习。",{"type":14,"tag":15,"props":53,"children":55},{"id":54},"二坐标体系",[56],{"type":20,"value":57},"二、坐标体系",{"type":14,"tag":23,"props":59,"children":60},{},[61],{"type":20,"value":62},"Unity3D 当中基本的坐标体系主要有下面这四种：",{"type":14,"tag":64,"props":65,"children":66},"ol",{},[67,73,78,83],{"type":14,"tag":68,"props":69,"children":70},"li",{},[71],{"type":20,"value":72},"世界坐标系 (World Space)",{"type":14,"tag":68,"props":74,"children":75},{},[76],{"type":20,"value":77},"屏幕坐标系 (Screen Space)",{"type":14,"tag":68,"props":79,"children":80},{},[81],{"type":20,"value":82},"视口坐标系 (Viewport Space)",{"type":14,"tag":68,"props":84,"children":85},{},[86],{"type":20,"value":87},"GUI界面坐标系 (GUI System)",{"type":14,"tag":23,"props":89,"children":90},{},[91],{"type":14,"tag":37,"props":92,"children":95},{"alt":93,"src":94},"7ku2m8quf5","/images/2020-07-01-unity-coordinate/7ku2m8quf5.jpeg",[],{"type":14,"tag":23,"props":97,"children":98},{},[99],{"type":20,"value":100},"这四种坐标系可以说没有一个是完全相同的，各个坐标系所代表的意思也可以从字面含义中理解出来，它们之间都是可以相互转换的，不过 GUI 坐标体系除外，它比较特殊，也相对来说是最简单的，那么我们就从最简单的说起吧。",{"type":14,"tag":23,"props":102,"children":103},{},[104],{"type":14,"tag":105,"props":106,"children":107},"strong",{},[108],{"type":20,"value":109},"1. 绘制 GUI 界面的坐标体系",{"type":14,"tag":23,"props":111,"children":112},{},[113,115,122],{"type":20,"value":114},"我们在做 Unity 游戏开发的时候，经常会使用内置的 GUI 来做一些测试，比如显示一个按钮控制游戏，画一个文本显示相关信息等。它的代码全部控制在 ",{"type":14,"tag":116,"props":117,"children":119},"code",{"className":118},[],[120],{"type":20,"value":121},"OnGUI()",{"type":20,"value":123}," 函数中：",{"type":14,"tag":125,"props":126,"children":131},"pre",{"className":127,"code":129,"language":130,"meta":7},[128],"language-javascript","private void OnGUI()\n{\n    if (GUI.Button(new Rect(0f, 0f, 160f, 40f), \"Click Me\"))\n    {\n        //button clicked and do something here...\n    }\n}\n","javascript",[132],{"type":14,"tag":116,"props":133,"children":134},{"__ignoreMap":7},[135],{"type":20,"value":129},{"type":14,"tag":23,"props":137,"children":138},{},[139,141,147,149,155,157,163,165,171,173,179,181,187],{"type":20,"value":140},"这个按钮 ",{"type":14,"tag":116,"props":142,"children":144},{"className":143},[],[145],{"type":20,"value":146},"Button",{"type":20,"value":148}," 所在的坐标系就是 GUI 绘制坐标系。大家稍微测试一下就知道了，它的原点 ",{"type":14,"tag":116,"props":150,"children":152},{"className":151},[],[153],{"type":20,"value":154},"(0, 0)",{"type":20,"value":156}," 在最左上角，因为屏幕宽度是 ",{"type":14,"tag":116,"props":158,"children":160},{"className":159},[],[161],{"type":20,"value":162},"Screen.width",{"type":20,"value":164}," ，高度是 ",{"type":14,"tag":116,"props":166,"children":168},{"className":167},[],[169],{"type":20,"value":170},"Screen.height",{"type":20,"value":172}," ，所以 GUI 体系右下角的坐标为： ",{"type":14,"tag":116,"props":174,"children":176},{"className":175},[],[177],{"type":20,"value":178},"(Screen.width, Screen.height)",{"type":20,"value":180}," , 这是一个二维的坐标体系，坐标 ",{"type":14,"tag":116,"props":182,"children":184},{"className":183},[],[185],{"type":20,"value":186},"z",{"type":20,"value":188}," 的值都为 0 。大家可以看下图加深理解：",{"type":14,"tag":23,"props":190,"children":191},{},[192],{"type":14,"tag":37,"props":193,"children":196},{"alt":194,"src":195},"ojb5jzsb2r","/images/2020-07-01-unity-coordinate/ojb5jzsb2r.jpeg",[],{"type":14,"tag":23,"props":198,"children":199},{},[200],{"type":14,"tag":105,"props":201,"children":202},{},[203],{"type":20,"value":204},"2. 视口 Viewport 坐标体系",{"type":14,"tag":23,"props":206,"children":207},{},[208],{"type":20,"value":209},"当我们使用多个相机，在同一个场景中显示多个视口的时候，我们就需要用上视口坐标系了。",{"type":14,"tag":23,"props":211,"children":212},{},[213,215,221,223,229],{"type":20,"value":214},"视口坐标系对于场景的显示非常重要，对于新手来说我们经常使用一个相机就够了，但是当需要使用到多个视口的时候，我们就必须关注视口坐标体系了，大家可以在相机 ",{"type":14,"tag":116,"props":216,"children":218},{"className":217},[],[219],{"type":20,"value":220},"Camera",{"type":20,"value":222}," 的属性中看到 ",{"type":14,"tag":116,"props":224,"children":226},{"className":225},[],[227],{"type":20,"value":228},"Viewport Rect",{"type":20,"value":230}," 就是视口坐标系的设置：",{"type":14,"tag":23,"props":232,"children":233},{},[234],{"type":14,"tag":37,"props":235,"children":238},{"alt":236,"src":237},"x9myhu3k73","/images/2020-07-01-unity-coordinate/x9myhu3k73.jpeg",[],{"type":14,"tag":23,"props":240,"children":241},{},[242,244,250,252,257,259,265,267,272],{"type":20,"value":243},"一个相机对应一个视口，视口预览（ Camera Preview ）展示了相机所看到的所有物体，很显然，它默认大小是 ",{"type":14,"tag":116,"props":245,"children":247},{"className":246},[],[248],{"type":20,"value":249},"(width = 1, height = 1)",{"type":20,"value":251}," ，位置也是从 0 到 1 ，这个位置就是我们所讨论的坐标系：左下角为 ",{"type":14,"tag":116,"props":253,"children":255},{"className":254},[],[256],{"type":20,"value":154},{"type":20,"value":258}," ，右上角是 ",{"type":14,"tag":116,"props":260,"children":262},{"className":261},[],[263],{"type":20,"value":264},"(1, 1)",{"type":20,"value":266}," ，一般视口坐标系主要用在相机显示中，我们简单的进行 ",{"type":14,"tag":116,"props":268,"children":270},{"className":269},[],[271],{"type":20,"value":228},{"type":20,"value":273}," 的设置就可以了。",{"type":14,"tag":23,"props":275,"children":276},{},[277,279,285],{"type":20,"value":278},"另外，新手朋友们可以记住这么一个快捷键： ",{"type":14,"tag":116,"props":280,"children":282},{"className":281},[],[283],{"type":20,"value":284},"Ctrl + Shift + F",{"type":20,"value":286}," ，可以快速设置相机视口到当前场景窗口的视口位置。下图是视口坐标系和鼠标在屏幕上的坐标系的转换结果：",{"type":14,"tag":23,"props":288,"children":289},{},[290],{"type":14,"tag":37,"props":291,"children":294},{"alt":292,"src":293},"6hkl5q24ft","/images/2020-07-01-unity-coordinate/6hkl5q24ft.jpeg",[],{"type":14,"tag":23,"props":296,"children":297},{},[298],{"type":14,"tag":105,"props":299,"children":300},{},[301],{"type":20,"value":302},"3. 屏幕 Screen 坐标体系",{"type":14,"tag":23,"props":304,"children":305},{},[306],{"type":20,"value":307},"嗯，非常重要！不管怎样，最终我们所有的成果都会发布到各个平台（屏幕）上，所以，任何坐标系的坐标和屏幕坐标系的转换都是非常重要的。比如我们经常需要处理鼠标的相关事件（鼠标位置、单击、双击事件等），或者手机上的触摸反馈，这些原始数据都是屏幕坐标系相关的。",{"type":14,"tag":23,"props":309,"children":310},{},[311,313,319,321,326,328,333,335,340,342,347,349,354,356,361,363,369,371,377,379,385],{"type":20,"value":312},"虽然重要，其实屏幕坐标系处理起来很简单直接， ",{"type":14,"tag":116,"props":314,"children":316},{"className":315},[],[317],{"type":20,"value":318},"Input.mousePosition",{"type":20,"value":320}," 获取的就是鼠标在屏幕中的位置坐标。大家可以测试一下，屏幕坐标系中原点 ",{"type":14,"tag":116,"props":322,"children":324},{"className":323},[],[325],{"type":20,"value":154},{"type":20,"value":327}," 位于左下角，那么右上角必然就是 ",{"type":14,"tag":116,"props":329,"children":331},{"className":330},[],[332],{"type":20,"value":178},{"type":20,"value":334}," ，对了，还有一个 ",{"type":14,"tag":116,"props":336,"children":338},{"className":337},[],[339],{"type":20,"value":186},{"type":20,"value":341}," 呢？都为 0 吗？答案是肯定的，既然是二维坐标系那么 ",{"type":14,"tag":116,"props":343,"children":345},{"className":344},[],[346],{"type":20,"value":186},{"type":20,"value":348}," 肯定是 0 了，和 GUI 坐标系一样，但是话又说回来，屏幕坐标系转换成世界坐标系 ",{"type":14,"tag":116,"props":350,"children":352},{"className":351},[],[353],{"type":20,"value":186},{"type":20,"value":355}," 还是 0 吗？其实不然，屏幕坐标转换成世界坐标后物体的 ",{"type":14,"tag":116,"props":357,"children":359},{"className":358},[],[360],{"type":20,"value":186},{"type":20,"value":362}," 值是取决于相机的，因此： ",{"type":14,"tag":116,"props":364,"children":366},{"className":365},[],[367],{"type":20,"value":368},"gameObject.z = camera.z",{"type":20,"value":370}," ，其实在上面视口坐标系介绍中的图中我已经把 ",{"type":14,"tag":116,"props":372,"children":374},{"className":373},[],[375],{"type":20,"value":376},"Mouse Point",{"type":20,"value":378}," 鼠标位置转换成世界坐标（ ",{"type":14,"tag":116,"props":380,"children":382},{"className":381},[],[383],{"type":20,"value":384},"World Point",{"type":20,"value":386}," ）了，大家应该注意到了吧。",{"type":14,"tag":23,"props":388,"children":389},{},[390,392,397,399,405,407,413],{"type":20,"value":391},"那么，除了坐标系的转换，还有什么值得注意的呢？这里我要告诉大家的是，我们在控制相机的时候，因为屏幕显示的就是相机所看到的内容，而",{"type":14,"tag":105,"props":393,"children":394},{},[395],{"type":20,"value":396},"屏幕的宽高比直接影响了相机的显示",{"type":20,"value":398},"，也就是 ",{"type":14,"tag":116,"props":400,"children":402},{"className":401},[],[403],{"type":20,"value":404},"Aspect Ratio",{"type":20,"value":406}," 的值，大家可以在 Game 面板中轻松地设置 ",{"type":14,"tag":116,"props":408,"children":410},{"className":409},[],[411],{"type":20,"value":412},"Aspect",{"type":20,"value":414}," 宽高比，查看对游戏画面的影响：",{"type":14,"tag":23,"props":416,"children":417},{},[418],{"type":14,"tag":37,"props":419,"children":422},{"alt":420,"src":421},"cmpbepr0jw","/images/2020-07-01-unity-coordinate/cmpbepr0jw.jpeg",[],{"type":14,"tag":23,"props":424,"children":425},{},[426],{"type":20,"value":427},"如下图，相机的宽高比和屏幕宽高比一致，显示结果也一致：",{"type":14,"tag":23,"props":429,"children":430},{},[431],{"type":14,"tag":37,"props":432,"children":435},{"alt":433,"src":434},"a0qyr11woq","/images/2020-07-01-unity-coordinate/a0qyr11woq.jpeg",[],{"type":14,"tag":23,"props":437,"children":438},{},[439],{"type":20,"value":440},"如果相机的宽高比设置的和屏幕宽高比不一样的话，显示结果就有点不同了：",{"type":14,"tag":23,"props":442,"children":443},{},[444],{"type":14,"tag":37,"props":445,"children":448},{"alt":446,"src":447},"iadfp03ffu","/images/2020-07-01-unity-coordinate/iadfp03ffu.jpeg",[],{"type":14,"tag":23,"props":450,"children":451},{},[452,454,460,462,468,470,476,478,484,486,492,494,500,502,508],{"type":20,"value":453},"所以，在游戏开发中，**我们要重视相机的宽高比 **",{"type":14,"tag":116,"props":455,"children":457},{"className":456},[],[458],{"type":20,"value":459},"Camera.aspect",{"type":20,"value":461}," 的值，一般我们会保持相机宽高比不变，然后通过改变相机的视口尺寸 ",{"type":14,"tag":116,"props":463,"children":465},{"className":464},[],[466],{"type":20,"value":467},"Camera.orthographicSize",{"type":20,"value":469}," 来显示场景中需要显示的物体，关于这个主题我会在我的下一篇文章中提到，大家可以关注我的博客。如何通过宽高比获取摄像机视口尺寸呢？首先可以从上图中知道宽高比的计算方法： ",{"type":14,"tag":116,"props":471,"children":473},{"className":472},[],[474],{"type":20,"value":475},"aspect = width / height",{"type":20,"value":477}," ，当你同时获取到 ",{"type":14,"tag":116,"props":479,"children":481},{"className":480},[],[482],{"type":20,"value":483},"width",{"type":20,"value":485}," 和 ",{"type":14,"tag":116,"props":487,"children":489},{"className":488},[],[490],{"type":20,"value":491},"height",{"type":20,"value":493}," 的时候，你通过 ",{"type":14,"tag":116,"props":495,"children":497},{"className":496},[],[498],{"type":20,"value":499},"Mathf.Max(height, width / aspect)",{"type":20,"value":501}," 来得出最终的尺寸大小（",{"type":14,"tag":503,"props":504,"children":505},"em",{},[506],{"type":20,"value":507},"注意这个结果是 2 倍视口尺寸哦",{"type":20,"value":509},"）。这个在游戏场景中应用的还是比较多的，比如你有这么个需求：两个玩家移动对战，你的相机要把两个移动的玩家随时放置在屏幕显示中。",{"type":14,"tag":23,"props":511,"children":512},{},[513],{"type":14,"tag":105,"props":514,"children":515},{},[516],{"type":20,"value":517},"4. 世界 World 三维坐标系",{"type":14,"tag":23,"props":519,"children":520},{},[521,523,529],{"type":20,"value":522},"最后，世界坐标系！世界坐标系不是最简单的，但却是我们最常用的坐标系。记住一点，任何情况下： ",{"type":14,"tag":116,"props":524,"children":526},{"className":525},[],[527],{"type":20,"value":528},"transform.position",{"type":20,"value":530}," 都是返回物体的世界坐标值，及时你所使用的是子物体！另外，从上面所讲的屏幕坐标系转换成世界坐标系也是非常简单的，它以当前相机为参考：",{"type":14,"tag":125,"props":532,"children":535},{"className":533,"code":534,"language":130,"meta":7},[128],"var position = Input.mousePosition;\nvar worldPoint = Camera.main.ScreenToWorldPoint(position);\n",[536],{"type":14,"tag":116,"props":537,"children":538},{"__ignoreMap":7},[539],{"type":20,"value":534},{"type":14,"tag":23,"props":541,"children":542},{},[543,545,550,552,558,560,565],{"type":20,"value":544},"另一方面，我们在游戏开发过程中，经常要处理",{"type":14,"tag":105,"props":546,"children":547},{},[548],{"type":20,"value":549},"子物体",{"type":20,"value":551},"的相对 ",{"type":14,"tag":116,"props":553,"children":555},{"className":554},[],[556],{"type":20,"value":557},"transform",{"type":20,"value":559}," 值，这个时候我们就需要稍微动点脑子了，当然如何转变 Unity 已经帮我们预制好相应的函数方法了，你只要",{"type":14,"tag":105,"props":561,"children":562},{},[563],{"type":20,"value":564},"把父物体当做世界，子物体当做世界中的物体",{"type":20,"value":566},"，使用这些函数，换一下坐标就和处理绝对坐标一样了，不知道大家理解没有。我举个例子，我们在游戏开发中会遇到这种情况，你的相机如果直接放到世界中那么必然会需要调整它的旋转角度才能达到满意的视口位置，如何不让相机产生任何旋转就能把世界中的游戏物体放到合适的视口位置呢？",{"type":14,"tag":23,"props":568,"children":569},{},[570,572,577],{"type":20,"value":571},"办法就是：我们",{"type":14,"tag":105,"props":573,"children":574},{},[575],{"type":20,"value":576},"把相机放到一个产生了合适旋转角度的父物体当中！这样做的效果就是：相机就相当于子物体，父物体旋转了，子物体就不需要额外旋转了，这时候相机的",{"type":20,"value":578},"局部旋转就为 0 。这在有些场景中使用起来很方便，相机已经是父物体世界中的子物体了。",{"type":14,"tag":23,"props":580,"children":581},{},[582],{"type":14,"tag":37,"props":583,"children":586},{"alt":584,"src":585},"cjali0ffbs","/images/2020-07-01-unity-coordinate/cjali0ffbs.jpeg",[],{"type":14,"tag":23,"props":588,"children":589},{},[590],{"type":20,"value":591},"怎么计算相对坐标呢？在 Unity 中都有相应的函数，使用比较简单：",{"type":14,"tag":125,"props":593,"children":596},{"className":594,"code":595,"language":130,"meta":7},[128],"//获取的是世界坐标\nvar childPosition = childObject.transform.position;\n//转化为父物体下的相对坐标，相当于位于父物体世界中\nvar relativePosition = parentObject.transform.InverseTransformPoint(childPosition);\n//转化为世界坐标，注意：这里不能传入 childPosition ，因为 childPosition 就是世界坐标\nvar worldPosition = parentObject.transform.TransformPoint(relativePosition);\n\n//所以，下面结果是相等的！\nprint(childPosition == worldPosition);\n",[597],{"type":14,"tag":116,"props":598,"children":599},{"__ignoreMap":7},[600],{"type":20,"value":595},{"type":14,"tag":15,"props":602,"children":604},{"id":603},"三总结",[605],{"type":20,"value":606},"三、总结",{"type":14,"tag":23,"props":608,"children":609},{},[610],{"type":20,"value":611},"当然，在使用坐标系过程中我们还要关注其他方方面面，比如欧拉角的旋转，万向锁，平滑过渡视野等等，这些我想我会在后面的文章总结中写道吧。这次就总结介绍了这几个坐标系，看上去有点复杂，总体来说还是挺很好理解的，有什么不对的或者可以加强的请给我留言，谢谢！",{"title":7,"searchDepth":613,"depth":613,"links":614},2,[615,616,617],{"id":17,"depth":613,"text":21},{"id":54,"depth":613,"text":57},{"id":603,"depth":613,"text":606},"markdown","content:unity:2020-07-01-unity-coordinate.md","content","unity/2020-07-01-unity-coordinate.md","md","2020-07-01",[625,635,762,811,863,876,988],{"title":626,"_path":627,"children":628},"Art","/art",[629,632],{"title":630,"_path":631},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":633,"_path":634},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":636,"_path":637,"children":638},"Dotnet","/dotnet",[639,642,645,648,651,654,657,660,663,666,669,672,675,678,681,684,687,690,693,696,699,702,705,708,711,714,717,720,723,726,729,732,735,738,741,744,747,750,753,756,759],{"title":640,"_path":641},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":643,"_path":644},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":646,"_path":647},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":649,"_path":650},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":652,"_path":653},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":655,"_path":656},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":658,"_path":659},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":661,"_path":662},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":664,"_path":665},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":667,"_path":668},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":670,"_path":671},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":673,"_path":674},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":676,"_path":677},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":679,"_path":680},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":682,"_path":683},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":685,"_path":686},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":688,"_path":689},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":691,"_path":692},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":694,"_path":695},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":697,"_path":698},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":700,"_path":701},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":703,"_path":704},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":706,"_path":707},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":709,"_path":710},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":712,"_path":713},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":715,"_path":716},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":718,"_path":719},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":721,"_path":722},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":724,"_path":725},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":727,"_path":728},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":730,"_path":731},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":733,"_path":734},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":736,"_path":737},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":739,"_path":740},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":742,"_path":743},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":745,"_path":746},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":748,"_path":749},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":751,"_path":752},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":754,"_path":755},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":757,"_path":758},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":760,"_path":761},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":763,"_path":764,"children":765},"Game","/game",[766,769,772,775,778,781,784,787,790,793,796,799,802,805,808],{"title":767,"_path":768},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":770,"_path":771},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":773,"_path":774},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":776,"_path":777},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":779,"_path":780},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":782,"_path":783},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":785,"_path":786},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":788,"_path":789},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":791,"_path":792},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":794,"_path":795},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":797,"_path":798},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":800,"_path":801},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":803,"_path":804},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":806,"_path":807},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":809,"_path":810},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":812,"_path":813,"children":814},"Gyj","/gyj",[815,818,821,824,827,830,833,836,839,842,845,848,851,854,857,860],{"title":816,"_path":817},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":819,"_path":820},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":822,"_path":823},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":825,"_path":826},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":828,"_path":829},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":831,"_path":832},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":834,"_path":835},"玩法","/gyj/2022-08-22-wanfa",{"title":837,"_path":838},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":840,"_path":841},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":843,"_path":844},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":846,"_path":847},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":849,"_path":850},"门派内容相关","/gyj/2022-11-17-sect",{"title":852,"_path":853},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":855,"_path":856},"种植","/gyj/2022-12-01-zhongzhi",{"title":858,"_path":859},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":861,"_path":862},"跑商","/gyj/2023-11-01-paoshang",{"title":864,"_path":865,"children":866},"Js","/js",[867,870,873],{"title":868,"_path":869},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":871,"_path":872},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":874,"_path":875},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":877,"_path":878,"children":879},"Tool","/tool",[880,883,886,889,892,895,898,901,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985],{"title":881,"_path":882},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":884,"_path":885},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":887,"_path":888},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":890,"_path":891},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":893,"_path":894},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":896,"_path":897},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":899,"_path":900},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":902,"_path":903},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":905,"_path":906},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":908,"_path":909},"mac下brew 使用","/tool/2020-01-13-brew",{"title":911,"_path":912},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":914,"_path":915},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":917,"_path":918},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":920,"_path":921},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":923,"_path":924},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":926,"_path":927},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":929,"_path":930},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":932,"_path":933},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":935,"_path":936},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":938,"_path":939},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":941,"_path":942},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":944,"_path":945},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":947,"_path":948},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":950,"_path":951},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":953,"_path":954},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":956,"_path":957},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":959,"_path":960},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":962,"_path":963},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":965,"_path":966},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":968,"_path":969},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":971,"_path":972},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":974,"_path":975},"rider的使用","/tool/2022-08-02-rider-use",{"title":977,"_path":978},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":980,"_path":981},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":983,"_path":984},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":986,"_path":987},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":989,"_path":990,"children":991},"Unity","/unity",[992,995,998,1001,1004,1007,1010,1013,1016,1019,1022,1025,1028,1031,1034,1037,1040,1043,1046,1049,1052,1055,1058,1061,1064,1067,1070,1073,1076,1077,1080,1083,1086,1089,1092,1095,1098,1101,1104,1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140,1143,1146,1149,1152,1155,1158,1161,1164,1167,1170,1173,1176,1179,1182,1185,1188,1191,1194,1197,1200,1203],{"title":993,"_path":994},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":996,"_path":997},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":999,"_path":1000},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1002,"_path":1003},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1005,"_path":1006},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1008,"_path":1009},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1011,"_path":1012},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1014,"_path":1015},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1017,"_path":1018},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1020,"_path":1021},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1023,"_path":1024},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1026,"_path":1027},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1029,"_path":1030},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1032,"_path":1033},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1035,"_path":1036},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1038,"_path":1039},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1041,"_path":1042},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1044,"_path":1045},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1047,"_path":1048},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1050,"_path":1051},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1053,"_path":1054},"技能系统","/unity/2020-02-15-skill-system",{"title":1056,"_path":1057},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1059,"_path":1060},"角色状态设计","/unity/2020-02-17-character-states",{"title":1062,"_path":1063},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1065,"_path":1066},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1068,"_path":1069},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1071,"_path":1072},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1074,"_path":1075},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":8,"_path":4},{"title":1078,"_path":1079},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1081,"_path":1082},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1084,"_path":1085},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1087,"_path":1088},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1090,"_path":1091},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1093,"_path":1094},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1096,"_path":1097},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1099,"_path":1100},"unity的addressables","/unity/2020-09-12-addressables",{"title":1102,"_path":1103},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1105,"_path":1106},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1108,"_path":1109},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1111,"_path":1112},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1114,"_path":1115},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1117,"_path":1118},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1120,"_path":1121},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1123,"_path":1124},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1126,"_path":1127},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1129,"_path":1130},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1132,"_path":1133},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1135,"_path":1136},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1138,"_path":1139},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1141,"_path":1142},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1144,"_path":1145},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1147,"_path":1148},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1150,"_path":1151},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1153,"_path":1154},"ability","/unity/2020-11-16-dotssample",{"title":1156,"_path":1157},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1159,"_path":1160},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1162,"_path":1163},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1165,"_path":1166},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1168,"_path":1169},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1171,"_path":1172},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1174,"_path":1175},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1177,"_path":1178},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1180,"_path":1181},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1183,"_path":1184},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1186,"_path":1187},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1189,"_path":1190},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1192,"_path":1193},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1195,"_path":1196},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1198,"_path":1199},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1201,"_path":1202},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1204,"_path":1205},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779040098]