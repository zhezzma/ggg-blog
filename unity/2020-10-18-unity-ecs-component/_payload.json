[{"data":1,"prerenderedAt":1600},["Reactive",2],{"content-query-hI4mOfcoQk":3,"content-navigation-8C37fagqQL":1018},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1012,"_id":1013,"_source":1014,"_file":1015,"_extension":1016,"date":1017},"/unity/2020-10-18-unity-ecs-component","unity",false,"","unity ecs component","General Purpose ComponentShared component data    不存储在chunk中,而是存储在sharedComponentManager,而chunk中存的是索引.. 若ForEach中包含了Share Component，那么必须调用WithoutBurst方法和使用Run来执行Chunk component data    相当于单例...更改后,会更改所有相关实体System State Components  类似一个标记..但是实体销毁时,并不会回收entity,只有当所有satecomponent移除后Dynamic buffer compo",{"type":11,"children":12,"toc":995},"root",[13,45,52,67,84,97,106,134,139,144,150,163,171,184,190,198,203,270,275,282,311,316,449,460,466,477,495,527,533,538,563,569,579,598,617,623,628,633,638,643,656,674,693,726,732,743,769,811,830,835,843,856,922,927,949,960,973,982],{"type":14,"tag":15,"props":16,"children":17},"element","ul",{},[18,25,30,35,40],{"type":14,"tag":19,"props":20,"children":21},"li",{},[22],{"type":23,"value":24},"text","General Purpose Component",{"type":14,"tag":19,"props":26,"children":27},{},[28],{"type":23,"value":29},"Shared component data    不存储在chunk中,而是存储在sharedComponentManager,而chunk中存的是索引.. 若ForEach中包含了Share Component，那么必须调用WithoutBurst方法和使用Run来执行",{"type":14,"tag":19,"props":31,"children":32},{},[33],{"type":23,"value":34},"Chunk component data    相当于单例...更改后,会更改所有相关实体",{"type":14,"tag":19,"props":36,"children":37},{},[38],{"type":23,"value":39},"System State Components  类似一个标记..但是实体销毁时,并不会回收entity,只有当所有satecomponent移除后",{"type":14,"tag":19,"props":41,"children":42},{},[43],{"type":23,"value":44},"Dynamic buffer components    可以理解为一个数组component",{"type":14,"tag":46,"props":47,"children":49},"h2",{"id":48},"general-purpose-component普通用途组件",[50],{"type":23,"value":51},"General Purpose Component（普通用途组件）",{"type":14,"tag":53,"props":54,"children":55},"p",{},[56,58,65],{"type":23,"value":57},"这里指的是最普通的组件，可以通过实现 ",{"type":14,"tag":59,"props":60,"children":62},"code",{"className":61},[],[63],{"type":23,"value":64},"IComponentData",{"type":23,"value":66}," 接口来创建。",{"type":14,"tag":53,"props":68,"children":69},{},[70,75,77,82],{"type":14,"tag":59,"props":71,"children":73},{"className":72},[],[74],{"type":23,"value":64},{"type":23,"value":76}," 不存储行为，只储存数据。",{"type":14,"tag":59,"props":78,"children":80},{"className":79},[],[81],{"type":23,"value":64},{"type":23,"value":83}," 还是一个结构体（Struct）而不是一个类（Class），这意味着被复制时默认是通过值而不是通过引用。",{"type":14,"tag":53,"props":85,"children":86},{},[87,89,95],{"type":23,"value":88},"通常我们会用下面的",{"type":14,"tag":90,"props":91,"children":92},"strong",{},[93],{"type":23,"value":94},"模式",{"type":23,"value":96},"来修改组件数据：",{"type":14,"tag":98,"props":99,"children":101},"pre",{"code":100},"var transform = group.transform[index]; // Read\n    \ntransform.heading = playerInput.move; // Modify\ntransform.position += deltaTime * playerInput.move * settings.playerMoveSpeed;\n\ngroup.transform[index] = transform; // Write\n",[102],{"type":14,"tag":59,"props":103,"children":104},{"__ignoreMap":7},[105],{"type":23,"value":100},{"type":14,"tag":53,"props":107,"children":108},{},[109,114,116,121,123,132],{"type":14,"tag":59,"props":110,"children":112},{"className":111},[],[113],{"type":23,"value":64},{"type":23,"value":115}," 结构不包含托管对象（managed objects）的引用，所有",{"type":14,"tag":59,"props":117,"children":119},{"className":118},[],[120],{"type":23,"value":64},{"type":23,"value":122}," 被存在无垃圾回收的",{"type":14,"tag":124,"props":125,"children":129},"a",{"href":126,"rel":127},"https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html",[128],"nofollow",[130],{"type":23,"value":131},"块内存（chunk memory）",{"type":23,"value":133},"中。",{"type":14,"tag":53,"props":135,"children":136},{},[137],{"type":23,"value":138},"你可能还听过一种组件是不包含数据、只用来标记的“Tag”组件（Tag component），其用途也很广，例如我们可以轻易地给实体加标记来区分玩家和敌人，这样系统中能更容易通过组件的类型来筛选我们想要的实体。如果我们给一个内存块（Chunk）中的所有实体都添加\"Tag“组件的话，只有内存块中对应的原型会修改，不添加数据，因此官方也推荐利用好”Tag“组件。",{"type":14,"tag":53,"props":140,"children":141},{},[142],{"type":23,"value":143},"See file: /Packages/com.unity.entities/Unity.Entities/IComponentData.cs.",{"type":14,"tag":46,"props":145,"children":147},{"id":146},"shared-components共享组件",[148],{"type":23,"value":149},"Shared components（共享组件）",{"type":14,"tag":53,"props":151,"children":152},{},[153,155,161],{"type":23,"value":154},"Shared components 是一种特殊的组件，你可以把某些特殊的需要共享的值放到 shared component 中，从而在实体中与其他组件划分开。例如有时候我们的实体需要共享一套材质，我们可以为需要共享的材质创建 ",{"type":14,"tag":59,"props":156,"children":158},{"className":157},[],[159],{"type":23,"value":160},"Rendering.RenderMesh",{"type":23,"value":162},"，再放到 shared components 中。原型中也可以定义 shared components，这一点和其他组件是一样的。",{"type":14,"tag":98,"props":164,"children":166},{"code":165},"[System.Serializable]\npublic struct RenderMesh : ISharedComponentData\n{\n    public Mesh                 mesh;\n    public Material             material;\n\n    public ShadowCastingMode    castShadows;\n    public bool                 receiveShadows;\n}\n",[167],{"type":14,"tag":59,"props":168,"children":169},{"__ignoreMap":7},[170],{"type":23,"value":165},{"type":14,"tag":53,"props":172,"children":173},{},[174,176,182],{"type":23,"value":175},"当你为一个实体添加一个 shared components 时， ",{"type":14,"tag":59,"props":177,"children":179},{"className":178},[],[180],{"type":23,"value":181},"EntityManager",{"type":23,"value":183}," 会把所有带有同样 shared components 的实体放到一个同样的内存块中（Chunks）。shared components 允许我们的系统去一并处理相似的（有同样 shared components 的）实体。",{"type":14,"tag":185,"props":186,"children":188},"h3",{"id":187},"内存结构",[189],{"type":23,"value":187},{"type":14,"tag":53,"props":191,"children":192},{},[193],{"type":14,"tag":194,"props":195,"children":197},"img",{"alt":194,"src":196},"/images/2020-10-18-unity-ecs-component/5d295d398f62598876.png",[],{"type":14,"tag":53,"props":199,"children":200},{},[201],{"type":23,"value":202},"每个内存块（Chunk）会有一个存放 shared components 索引的数组。这句话包含了几个要点：",{"type":14,"tag":204,"props":205,"children":206},"ol",{},[207,220,246,258],{"type":14,"tag":19,"props":208,"children":209},{},[210,212,218],{"type":23,"value":211},"对于实体来说，有同样 ",{"type":14,"tag":59,"props":213,"children":215},{"className":214},[],[216],{"type":23,"value":217},"SharedComponentData",{"type":23,"value":219}," 的实体会被一起放到同样的内存块（Chunk）中。",{"type":14,"tag":19,"props":221,"children":222},{},[223,225,230,232,237,239,244],{"type":23,"value":224},"如果我们有两个存储在同样的内存块中的两个实体，它们有同样的 ",{"type":14,"tag":59,"props":226,"children":228},{"className":227},[],[229],{"type":23,"value":217},{"type":23,"value":231}," 类型和值。我们修改其中一个实体的 ",{"type":14,"tag":59,"props":233,"children":235},{"className":234},[],[236],{"type":23,"value":217},{"type":23,"value":238}," 的值，这样会导致这个实体会被移动到一个新的内存块中，因为一个内存块共享同一个数组的 ",{"type":14,"tag":59,"props":240,"children":242},{"className":241},[],[243],{"type":23,"value":217},{"type":23,"value":245}," 索引。事实上，从一个实体中增加或者移除一个组件，或者改变 shared components 的值都会导致这种操作的发生。",{"type":14,"tag":19,"props":247,"children":248},{},[249,251,256],{"type":23,"value":250},"其索引存储在内存块而非实体中，因此 ",{"type":14,"tag":59,"props":252,"children":254},{"className":253},[],[255],{"type":23,"value":217},{"type":23,"value":257}," 对实体来说是低开销的。",{"type":14,"tag":19,"props":259,"children":260},{},[261,263,268],{"type":23,"value":262},"因为内存块只需要存其索引，",{"type":14,"tag":59,"props":264,"children":266},{"className":265},[],[267],{"type":23,"value":217},{"type":23,"value":269}," 的内存消耗几乎可以忽略不计。",{"type":14,"tag":53,"props":271,"children":272},{},[273],{"type":23,"value":274},"因为上面的第二个要点，我们不能滥用 shared components。滥用 shared components 将让 Unity 不能利用好内存块（Chunk），因此我们要避免添加不必要的数据或修改数据到 shared components 中。我们可以通过 Entity Debugger 来监测内存块的利用。",{"type":14,"tag":53,"props":276,"children":277},{},[278],{"type":14,"tag":194,"props":279,"children":281},{"alt":194,"src":280},"/images/2020-10-18-unity-ecs-component/5d295b6d78b7f51832.png",[],{"type":14,"tag":53,"props":283,"children":284},{},[285,287,293,295,300,302,309],{"type":23,"value":286},"拿上一段 RenderMesh 的例子来说，共享材质会更有效率，因为 shared components 有其自己的 ",{"type":14,"tag":59,"props":288,"children":290},{"className":289},[],[291],{"type":23,"value":292},"manager",{"type":23,"value":294}," 和哈希表。其中 ",{"type":14,"tag":59,"props":296,"children":298},{"className":297},[],[299],{"type":23,"value":292},{"type":23,"value":301}," 带有一个存储 shared components 数据的自由列表（",{"type":14,"tag":124,"props":303,"children":306},{"href":304,"rel":305},"https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%A1%A8",[128],[307],{"type":23,"value":308},"freelist",{"type":23,"value":310},"），哈希表可以快速地找到相应的值。内存块里面存的是索引数组，需要找数据的时候就会从 Shared Component Manager 中找。",{"type":14,"tag":185,"props":312,"children":314},{"id":313},"其他要点",[315],{"type":23,"value":313},{"type":14,"tag":15,"props":317,"children":318},{},[319,337,372,399,432],{"type":14,"tag":19,"props":320,"children":321},{},[322,328,330,335],{"type":14,"tag":59,"props":323,"children":325},{"className":324},[],[326],{"type":23,"value":327},"EntityQuery",{"type":23,"value":329}," 可以迭代所有拥有相同 ",{"type":14,"tag":59,"props":331,"children":333},{"className":332},[],[334],{"type":23,"value":217},{"type":23,"value":336}," 的实体",{"type":14,"tag":19,"props":338,"children":339},{},[340,342,348,350,355,357,363,365,370],{"type":23,"value":341},"我们可以用 ",{"type":14,"tag":59,"props":343,"children":345},{"className":344},[],[346],{"type":23,"value":347},"EntityQuery.SetFilter()",{"type":23,"value":349}," 来迭代所有拥有某个特定 ",{"type":14,"tag":59,"props":351,"children":353},{"className":352},[],[354],{"type":23,"value":217},{"type":23,"value":356}," 的实体。这种操作开销十分低，因为 ",{"type":14,"tag":59,"props":358,"children":360},{"className":359},[],[361],{"type":23,"value":362},"SetFilter",{"type":23,"value":364}," 内部筛选的只是 int 的索引。前面说了每个内存块都有一个",{"type":14,"tag":59,"props":366,"children":368},{"className":367},[],[369],{"type":23,"value":217},{"type":23,"value":371}," 索引数组，因此对于每个内存块来说，筛选（filtering）的消耗都是可以忽略不计的。",{"type":14,"tag":19,"props":373,"children":374},{},[375,377,382,384,390,392,397],{"type":23,"value":376},"怎么样获取 ",{"type":14,"tag":59,"props":378,"children":380},{"className":379},[],[381],{"type":23,"value":217},{"type":23,"value":383}," 的值呢？",{"type":14,"tag":59,"props":385,"children":387},{"className":386},[],[388],{"type":23,"value":389},"EntityManager.GetAllUniqueSharedComponentData\u003CT>",{"type":23,"value":391}," 可以得到在存活的实体中（alive entities）的所有的泛型 T 类型的",{"type":14,"tag":59,"props":393,"children":395},{"className":394},[],[396],{"type":23,"value":217},{"type":23,"value":398}," 值，结果以参数中的列表返回，你也可以通过其重载的方法获得所有值的索引。其他获取值的方法可以参考 /Packages/com.unity.entities/Unity.Entities/EntityManagerAccessComponentData.cs。",{"type":14,"tag":19,"props":400,"children":401},{},[402,407,409,414,416,421,423,430],{"type":14,"tag":59,"props":403,"children":405},{"className":404},[],[406],{"type":23,"value":217},{"type":23,"value":408}," 是自动引用计数的，例如在没有任何内存块拥有某个",{"type":14,"tag":59,"props":410,"children":412},{"className":411},[],[413],{"type":23,"value":217},{"type":23,"value":415}," 索引的时候，引用计数会置零，从而知道要删除",{"type":14,"tag":59,"props":417,"children":419},{"className":418},[],[420],{"type":23,"value":217},{"type":23,"value":422}," 的数据 。这一点就能看出其在 ECS 的世界中是非常独特的存在，想要深入了解可以看这篇文章",{"type":14,"tag":124,"props":424,"children":427},{"href":425,"rel":426},"https://gametorrahod.com/everything-about-isharedcomponentdata/",[128],[428],{"type":23,"value":429},"《Everything about ISharedComponentData》",{"type":23,"value":431},"。",{"type":14,"tag":19,"props":433,"children":434},{},[435,440,442,447],{"type":14,"tag":59,"props":436,"children":438},{"className":437},[],[439],{"type":23,"value":217},{"type":23,"value":441}," 应该尽量不去更改，因为更改 ",{"type":14,"tag":59,"props":443,"children":445},{"className":444},[],[446],{"type":23,"value":217},{"type":23,"value":448}," 会导致实体的组件数据需要复制到其他的内存块中。",{"type":14,"tag":53,"props":450,"children":451},{},[452,454,459],{"type":23,"value":453},"你也可以读读这篇更深入的文章",{"type":14,"tag":124,"props":455,"children":457},{"href":425,"rel":456},[128],[458],{"type":23,"value":429},{"type":23,"value":431},{"type":14,"tag":46,"props":461,"children":463},{"id":462},"system-state-components系统状态组件",[464],{"type":23,"value":465},"System state components（系统状态组件）",{"type":14,"tag":53,"props":467,"children":468},{},[469,475],{"type":14,"tag":59,"props":470,"children":472},{"className":471},[],[473],{"type":23,"value":474},"SystemStateComponentData",{"type":23,"value":476}," 允许你跟踪系统（System）的资源，并允许你合适地创建和删除某些资源，这些过程中不依赖独立的回调（individual callback）。",{"type":14,"tag":478,"props":479,"children":480},"blockquote",{},[481],{"type":14,"tag":53,"props":482,"children":483},{},[484,486,493],{"type":23,"value":485},"假设有一个网络同步 System State，其监控一个 Component A 的同步，则我只需要定义一个 SystemStateComponent SA。当 Entity [有 A，无 SA] 时，表示 A 刚添加，此时添加 SA。等到 Entity [无 A，有 SA] 时,表示 A 被删除（尝试销毁Entity 时也会删除 A）。\n",{"type":14,"tag":124,"props":487,"children":490},{"href":488,"rel":489},"https://zhuanlan.zhihu.com/p/51289405",[128],[491],{"type":23,"value":492},"《浅入浅出Unity ECS》",{"type":23,"value":494}," BenzzZX",{"type":14,"tag":53,"props":496,"children":497},{},[498,503,505,511,513,519,520,525],{"type":14,"tag":59,"props":499,"children":501},{"className":500},[],[502],{"type":23,"value":474},{"type":23,"value":504}," 和 ",{"type":14,"tag":59,"props":506,"children":508},{"className":507},[],[509],{"type":23,"value":510},"SystemStateSharedComponentData",{"type":23,"value":512}," 这两个类型与 ",{"type":14,"tag":59,"props":514,"children":516},{"className":515},[],[517],{"type":23,"value":518},"ComponentData",{"type":23,"value":504},{"type":14,"tag":59,"props":521,"children":523},{"className":522},[],[524],{"type":23,"value":217},{"type":23,"value":526}," 十分相似，不同的是前者两个类型都是系统级别的，不会在实体删除的时候被删除。",{"type":14,"tag":185,"props":528,"children":530},{"id":529},"motivation诱因",[531],{"type":23,"value":532},"Motivation（诱因）",{"type":14,"tag":53,"props":534,"children":535},{},[536],{"type":23,"value":537},"System state components 有这样特殊的行为，是因为：",{"type":14,"tag":15,"props":539,"children":540},{},[541,553,558],{"type":14,"tag":19,"props":542,"children":543},{},[544,546,551],{"type":23,"value":545},"系统可能需要保持一个基于 ",{"type":14,"tag":59,"props":547,"children":549},{"className":548},[],[550],{"type":23,"value":518},{"type":23,"value":552}," 的内部状态。例如已经被分配的资源。",{"type":14,"tag":19,"props":554,"children":555},{},[556],{"type":23,"value":557},"系统需要通过值来管理这些状态，也需要管理其他系统所造成的的状态改变。例如在组件中的值改变的时候，或者在相关组件被添加或者被删除的时候。",{"type":14,"tag":19,"props":559,"children":560},{},[561],{"type":23,"value":562},"“没有回调”是 ECS 设计规则的重要元素。",{"type":14,"tag":185,"props":564,"children":566},{"id":565},"concept概念",[567],{"type":23,"value":568},"Concept（概念）",{"type":14,"tag":53,"props":570,"children":571},{},[572,577],{"type":14,"tag":59,"props":573,"children":575},{"className":574},[],[576],{"type":23,"value":474},{"type":23,"value":578}," 普遍用法是镜像一个用户组件，并提供内部状态。",{"type":14,"tag":53,"props":580,"children":581},{},[582,584,589,591,597],{"type":23,"value":583},"上面引用的网络同步的例子中，A 就是用户分配的 ",{"type":14,"tag":59,"props":585,"children":587},{"className":586},[],[588],{"type":23,"value":518},{"type":23,"value":590},"，SA 就是系统分配的 ",{"type":14,"tag":59,"props":592,"children":594},{"className":593},[],[595],{"type":23,"value":596},"SystemComponentData",{"type":23,"value":431},{"type":14,"tag":53,"props":599,"children":600},{},[601,603,608,610,615],{"type":23,"value":602},"下面以 FooComponent （",{"type":14,"tag":59,"props":604,"children":606},{"className":605},[],[607],{"type":23,"value":518},{"type":23,"value":609},"）和 FooStateComponent（",{"type":14,"tag":59,"props":611,"children":613},{"className":612},[],[614],{"type":23,"value":596},{"type":23,"value":616},"）做主要用途的示例。前两个用途已经在前面的网络同步例子中呈现过。",{"type":14,"tag":618,"props":619,"children":621},"h4",{"id":620},"检测组件的添加",[622],{"type":23,"value":620},{"type":14,"tag":53,"props":624,"children":625},{},[626],{"type":23,"value":627},"如果用户添加 FooComponent 时，FooStateComponent 还不存在。FooSystem 会在 update 中查询，如果实体只有 FooComponent 而没有 FooStateComponent,，则可以判断这个实体是新添加的。这时候 FooSystem 会加上 FooStateComponent 组件和其他需要的内部状态。",{"type":14,"tag":618,"props":629,"children":631},{"id":630},"检测组件的删除",[632],{"type":23,"value":630},{"type":14,"tag":53,"props":634,"children":635},{},[636],{"type":23,"value":637},"如果用户删除 FooComponent 后，FooStateComponent 仍然存在。FooSystem 会在 update 中查询，如果实体没有 FooComponent 而有 FooStateComponent,，则可以判断 FooComponent 已经被删除了。这时候 FooSystem 会给删除 FooStateComponent 组件和修改其他需要的内部状态。",{"type":14,"tag":618,"props":639,"children":641},{"id":640},"监测实体的删除",[642],{"type":23,"value":640},{"type":14,"tag":53,"props":644,"children":645},{},[646,648,654],{"type":23,"value":647},"通常 ",{"type":14,"tag":59,"props":649,"children":651},{"className":650},[],[652],{"type":23,"value":653},"DestroyEntity",{"type":23,"value":655}," 这个方法可以用来：",{"type":14,"tag":204,"props":657,"children":658},{},[659,664,669],{"type":14,"tag":19,"props":660,"children":661},{},[662],{"type":23,"value":663},"找到所有由某个实体 ID 标记的所有组件",{"type":14,"tag":19,"props":665,"children":666},{},[667],{"type":23,"value":668},"删除那些组件",{"type":14,"tag":19,"props":670,"children":671},{},[672],{"type":23,"value":673},"回收实体 ID 以作重用",{"type":14,"tag":53,"props":675,"children":676},{},[677,679,684,686,691],{"type":23,"value":678},"然而，",{"type":14,"tag":59,"props":680,"children":682},{"className":681},[],[683],{"type":23,"value":653},{"type":23,"value":685}," 无法删除 ",{"type":14,"tag":59,"props":687,"children":689},{"className":688},[],[690],{"type":23,"value":474},{"type":23,"value":692}," 。",{"type":14,"tag":53,"props":694,"children":695},{},[696,698,703,705,710,712,717,719,724],{"type":23,"value":697},"在你删除实体时，",{"type":14,"tag":59,"props":699,"children":701},{"className":700},[],[702],{"type":23,"value":181},{"type":23,"value":704}," ",{"type":14,"tag":90,"props":706,"children":707},{},[708],{"type":23,"value":709},"不会",{"type":23,"value":711},"移除任何 system state components，在它们没被删除的时候，",{"type":14,"tag":59,"props":713,"children":715},{"className":714},[],[716],{"type":23,"value":181},{"type":23,"value":718}," 也不会回收其实体的 ID 。这样允许系统（System）在一个实体被删除的时候，去整理内部的状态（internal state），也能清理关联着实体 ID 的相关的资源和状态。实体 ID 只会在所有 ",{"type":14,"tag":59,"props":720,"children":722},{"className":721},[],[723],{"type":23,"value":474},{"type":23,"value":725}," 被删除的时候才被重用。",{"type":14,"tag":46,"props":727,"children":729},{"id":728},"dynamic-buffers动态缓冲",[730],{"type":23,"value":731},"Dynamic Buffers（动态缓冲）",{"type":14,"tag":53,"props":733,"children":734},{},[735,741],{"type":14,"tag":59,"props":736,"children":738},{"className":737},[],[739],{"type":23,"value":740},"DynamicBuffer",{"type":23,"value":742}," 也是组件的一种类型，它能把一个变量内存空间大小的弹性的缓冲（variable-sized, “stretchy” buffer）和一个实体关联起来。它内部存储着一定数量的元素，但如果内部所占内存空间太大，会额外划分一个堆内存（heap memory）来存储。",{"type":14,"tag":53,"props":744,"children":745},{},[746,748,753,755,760,762,767],{"type":23,"value":747},"动态缓冲的内存管理是全自动的。与 ",{"type":14,"tag":59,"props":749,"children":751},{"className":750},[],[752],{"type":23,"value":740},{"type":23,"value":754}," 关联的内存由 ",{"type":14,"tag":59,"props":756,"children":758},{"className":757},[],[759],{"type":23,"value":181},{"type":23,"value":761}," 来管理，这样当",{"type":14,"tag":59,"props":763,"children":765},{"className":764},[],[766],{"type":23,"value":740},{"type":23,"value":768}," 组件被删除的时候，所关联的堆内存空间也会自动释放掉。",{"type":14,"tag":53,"props":770,"children":771},{},[772,774,779,781,787,789,794,796,802,804,809],{"type":23,"value":773},"上面的解释可能略显苍白，实际上 ",{"type":14,"tag":59,"props":775,"children":777},{"className":776},[],[778],{"type":23,"value":740},{"type":23,"value":780}," 可以看成一个有默认大小的数组，其行为和性能都和 ",{"type":14,"tag":59,"props":782,"children":784},{"className":783},[],[785],{"type":23,"value":786},"NativeArray",{"type":23,"value":788},"（在 ECS 中常用的无 GC 容器类型）差不多，但是存储数据超过默认大小也没关系，上文提到了会创建一个堆内存来存储多的数据。",{"type":14,"tag":59,"props":790,"children":792},{"className":791},[],[793],{"type":23,"value":740},{"type":23,"value":795}," 可以通过 ",{"type":14,"tag":59,"props":797,"children":799},{"className":798},[],[800],{"type":23,"value":801},"ToNativeArray",{"type":23,"value":803}," 转成 ",{"type":14,"tag":59,"props":805,"children":807},{"className":806},[],[808],{"type":23,"value":786},{"type":23,"value":810}," 类型，其中只是把指针重新指向缓冲，不会复制数据。",{"type":14,"tag":53,"props":812,"children":813},{},[814,821,823,828],{"type":14,"tag":124,"props":815,"children":818},{"href":816,"rel":817},"http://tsubakit1.hateblo.jp/entry/2018/11/07/234502",[128],[819],{"type":23,"value":820},"【Unity】ECSで配列を格納する Dynamic Buffers",{"type":23,"value":822}," 这篇文章中，作者用",{"type":14,"tag":59,"props":824,"children":826},{"className":825},[],[827],{"type":23,"value":740},{"type":23,"value":829}," 来储存临近的圆柱体实体，从而更方便地与这些实体交互。",{"type":14,"tag":185,"props":831,"children":833},{"id":832},"定义缓冲",[834],{"type":23,"value":832},{"type":14,"tag":98,"props":836,"children":838},{"code":837},"// 8 指的是缓冲中默认元素的数量，例如这例子中存的是 Integer 类型\n// 那么 8 integers （32 bytes）就是缓冲的默认大小\n// 64 位机器中则占 16 bytes\n[InternalBufferCapacity(8)]\npublic struct MyBufferElement : IBufferElementData\n{\n    // 下面的隐式转换是可选的，这样可以少写些代码\n    public static implicit operator int(MyBufferElement e) { return e.Value; }\n    public static implicit operator MyBufferElement(int e) { return new MyBufferElement { Value = e }; }\n\n    // 每个缓冲元素要存储的值\n    public int Value;\n}\n",[839],{"type":14,"tag":59,"props":840,"children":841},{"__ignoreMap":7},[842],{"type":23,"value":837},{"type":14,"tag":53,"props":844,"children":845},{},[846,848,854],{"type":23,"value":847},"可能有点奇怪，我们要定义缓冲中元素的结构而不是 ",{"type":14,"tag":59,"props":849,"children":851},{"className":850},[],[852],{"type":23,"value":853},"Buffer",{"type":23,"value":855}," 缓冲本身，其实这样在 ECS 中有两个好处：",{"type":14,"tag":204,"props":857,"children":858},{},[859,886],{"type":14,"tag":19,"props":860,"children":861},{},[862,864,870,872,877,879,885],{"type":23,"value":863},"对于 ",{"type":14,"tag":59,"props":865,"children":867},{"className":866},[],[868],{"type":23,"value":869},"float3",{"type":23,"value":871}," 或者其他常见的值类型来说，这样能支持多种 ",{"type":14,"tag":59,"props":873,"children":875},{"className":874},[],[876],{"type":23,"value":740},{"type":23,"value":878}," 。我们可以重用已有的缓冲元素的结构，来定义其他的 ",{"type":14,"tag":59,"props":880,"children":882},{"className":881},[],[883],{"type":23,"value":884},"Buffers",{"type":23,"value":431},{"type":14,"tag":19,"props":887,"children":888},{},[889,891,896,898,904,906,912,914,920],{"type":23,"value":890},"我们可以将 ",{"type":14,"tag":59,"props":892,"children":894},{"className":893},[],[895],{"type":23,"value":853},{"type":23,"value":897}," 的元素类型包含在 ",{"type":14,"tag":59,"props":899,"children":901},{"className":900},[],[902],{"type":23,"value":903},"EntityArchetypes",{"type":23,"value":905}," 中，这样它会表现得像拥有一个组件一样。例如用 ",{"type":14,"tag":59,"props":907,"children":909},{"className":908},[],[910],{"type":23,"value":911},"AddBuffer()",{"type":23,"value":913}," 方法，可以通过 ",{"type":14,"tag":59,"props":915,"children":917},{"className":916},[],[918],{"type":23,"value":919},"entityManager.AddBuffer\u003CMyBufferElement>(entity);",{"type":23,"value":921}," 来添加缓冲。",{"type":14,"tag":46,"props":923,"children":925},{"id":924},"关于prefab到entity",[926],{"type":23,"value":924},{"type":14,"tag":15,"props":928,"children":929},{},[930],{"type":14,"tag":19,"props":931,"children":932},{},[933,939,941,947],{"type":14,"tag":59,"props":934,"children":936},{"className":935},[],[937],{"type":23,"value":938},"IDeclareReferencedPrefabs",{"type":23,"value":940}," ： 将prefab引用添加到Conversion World。在",{"type":14,"tag":59,"props":942,"children":944},{"className":943},[],[945],{"type":23,"value":946},"IConvertGameObjectToEntity",{"type":23,"value":948},"中可以通过GameObjectConversionSystem根据prefab获取entity",{"type":14,"tag":98,"props":950,"children":955},{"code":951,"language":952,"meta":7,"className":953},"public void DeclareReferencedPrefabs(List\u003CGameObject> referencedPrefabs) => referencedPrefabs.Add(Prefab);\n","cpp",[954],"language-cpp",[956],{"type":14,"tag":59,"props":957,"children":958},{"__ignoreMap":7},[959],{"type":23,"value":951},{"type":14,"tag":15,"props":961,"children":962},{},[963],{"type":14,"tag":19,"props":964,"children":965},{},[966,971],{"type":14,"tag":59,"props":967,"children":969},{"className":968},[],[970],{"type":23,"value":946},{"type":23,"value":972},"：自动生成一个新的entity，然后自定义对entity的操作。",{"type":14,"tag":98,"props":974,"children":977},{"code":975,"language":952,"meta":7,"className":976},"public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentData(entity, new PeriodicSpawner\n        {\n            Prefab = conversionSystem.GetPrimaryEntity(Prefab),\n            SecondsBetweenSpawns = 1 / SpawnsPerSecond\n        });\n    }\n",[954],[978],{"type":14,"tag":59,"props":979,"children":980},{"__ignoreMap":7},[981],{"type":23,"value":975},{"type":14,"tag":15,"props":983,"children":984},{},[985],{"type":14,"tag":19,"props":986,"children":987},{},[988],{"type":14,"tag":124,"props":989,"children":992},{"href":990,"rel":991},"https://github.com/Knightmore/MultiWorldBootstrap",[128],[993],{"type":23,"value":994},"Knightmore/MultiWorldBootstrap: Unity ICustomBootstrap extension for multiple custom world creation in ECS (github.com)",{"title":7,"searchDepth":996,"depth":996,"links":997},2,[998,999,1004,1008,1011],{"id":48,"depth":996,"text":51},{"id":146,"depth":996,"text":149,"children":1000},[1001,1003],{"id":187,"depth":1002,"text":187},3,{"id":313,"depth":1002,"text":313},{"id":462,"depth":996,"text":465,"children":1005},[1006,1007],{"id":529,"depth":1002,"text":532},{"id":565,"depth":1002,"text":568},{"id":728,"depth":996,"text":731,"children":1009},[1010],{"id":832,"depth":1002,"text":832},{"id":924,"depth":996,"text":924},"markdown","content:unity:2020-10-18-unity-ecs-component.md","content","unity/2020-10-18-unity-ecs-component.md","md","2020-10-18",[1019,1029,1156,1205,1257,1270,1382],{"title":1020,"_path":1021,"children":1022},"Art","/art",[1023,1026],{"title":1024,"_path":1025},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1027,"_path":1028},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1030,"_path":1031,"children":1032},"Dotnet","/dotnet",[1033,1036,1039,1042,1045,1048,1051,1054,1057,1060,1063,1066,1069,1072,1075,1078,1081,1084,1087,1090,1093,1096,1099,1102,1105,1108,1111,1114,1117,1120,1123,1126,1129,1132,1135,1138,1141,1144,1147,1150,1153],{"title":1034,"_path":1035},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1037,"_path":1038},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1040,"_path":1041},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1043,"_path":1044},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1046,"_path":1047},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":1049,"_path":1050},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1052,"_path":1053},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1055,"_path":1056},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1058,"_path":1059},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1061,"_path":1062},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1064,"_path":1065},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1067,"_path":1068},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1070,"_path":1071},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1073,"_path":1074},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1076,"_path":1077},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1079,"_path":1080},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1082,"_path":1083},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1085,"_path":1086},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1088,"_path":1089},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1091,"_path":1092},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1094,"_path":1095},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1097,"_path":1098},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1100,"_path":1101},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1103,"_path":1104},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1106,"_path":1107},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1109,"_path":1110},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1112,"_path":1113},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1115,"_path":1116},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1118,"_path":1119},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1121,"_path":1122},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1124,"_path":1125},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1127,"_path":1128},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1130,"_path":1131},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1133,"_path":1134},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1136,"_path":1137},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1139,"_path":1140},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1142,"_path":1143},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1145,"_path":1146},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1148,"_path":1149},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1151,"_path":1152},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1154,"_path":1155},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1157,"_path":1158,"children":1159},"Game","/game",[1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202],{"title":1161,"_path":1162},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1164,"_path":1165},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1167,"_path":1168},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1170,"_path":1171},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1173,"_path":1174},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1176,"_path":1177},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1179,"_path":1180},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1182,"_path":1183},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1185,"_path":1186},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1188,"_path":1189},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1191,"_path":1192},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1194,"_path":1195},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1197,"_path":1198},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1200,"_path":1201},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1203,"_path":1204},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1206,"_path":1207,"children":1208},"Gyj","/gyj",[1209,1212,1215,1218,1221,1224,1227,1230,1233,1236,1239,1242,1245,1248,1251,1254],{"title":1210,"_path":1211},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1213,"_path":1214},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1216,"_path":1217},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1219,"_path":1220},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1222,"_path":1223},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1225,"_path":1226},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1228,"_path":1229},"玩法","/gyj/2022-08-22-wanfa",{"title":1231,"_path":1232},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1234,"_path":1235},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1237,"_path":1238},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1240,"_path":1241},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1243,"_path":1244},"门派内容相关","/gyj/2022-11-17-sect",{"title":1246,"_path":1247},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1249,"_path":1250},"种植","/gyj/2022-12-01-zhongzhi",{"title":1252,"_path":1253},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1255,"_path":1256},"跑商","/gyj/2023-11-01-paoshang",{"title":1258,"_path":1259,"children":1260},"Js","/js",[1261,1264,1267],{"title":1262,"_path":1263},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1265,"_path":1266},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1268,"_path":1269},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1271,"_path":1272,"children":1273},"Tool","/tool",[1274,1277,1280,1283,1286,1289,1292,1295,1298,1301,1304,1307,1310,1313,1316,1319,1322,1325,1328,1331,1334,1337,1340,1343,1346,1349,1352,1355,1358,1361,1364,1367,1370,1373,1376,1379],{"title":1275,"_path":1276},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1278,"_path":1279},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1281,"_path":1282},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1284,"_path":1285},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1287,"_path":1288},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1290,"_path":1291},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1293,"_path":1294},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1296,"_path":1297},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1299,"_path":1300},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1302,"_path":1303},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1305,"_path":1306},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1308,"_path":1309},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1311,"_path":1312},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1314,"_path":1315},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1317,"_path":1318},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1320,"_path":1321},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1323,"_path":1324},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1326,"_path":1327},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1329,"_path":1330},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1332,"_path":1333},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1335,"_path":1336},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1338,"_path":1339},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1341,"_path":1342},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1344,"_path":1345},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1347,"_path":1348},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1350,"_path":1351},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1353,"_path":1354},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1356,"_path":1357},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1359,"_path":1360},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1362,"_path":1363},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1365,"_path":1366},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1368,"_path":1369},"rider的使用","/tool/2022-08-02-rider-use",{"title":1371,"_path":1372},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1374,"_path":1375},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1377,"_path":1378},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1380,"_path":1381},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1383,"_path":1384,"children":1385},"Unity","/unity",[1386,1389,1392,1395,1398,1401,1404,1407,1410,1413,1416,1419,1422,1425,1428,1431,1434,1437,1440,1443,1446,1449,1452,1455,1458,1461,1464,1467,1470,1473,1476,1479,1482,1485,1488,1491,1494,1497,1500,1503,1506,1509,1510,1513,1516,1519,1522,1525,1528,1531,1534,1537,1540,1543,1546,1549,1552,1555,1558,1561,1564,1567,1570,1573,1576,1579,1582,1585,1588,1591,1594,1597],{"title":1387,"_path":1388},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1390,"_path":1391},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1393,"_path":1394},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1396,"_path":1397},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1399,"_path":1400},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1402,"_path":1403},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1405,"_path":1406},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1408,"_path":1409},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1411,"_path":1412},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1414,"_path":1415},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1417,"_path":1418},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1420,"_path":1421},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1423,"_path":1424},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1426,"_path":1427},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1429,"_path":1430},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1432,"_path":1433},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1435,"_path":1436},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1438,"_path":1439},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1441,"_path":1442},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1444,"_path":1445},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1447,"_path":1448},"技能系统","/unity/2020-02-15-skill-system",{"title":1450,"_path":1451},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1453,"_path":1454},"角色状态设计","/unity/2020-02-17-character-states",{"title":1456,"_path":1457},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1459,"_path":1460},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1462,"_path":1463},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1465,"_path":1466},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1468,"_path":1469},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1471,"_path":1472},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1474,"_path":1475},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1477,"_path":1478},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1480,"_path":1481},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1483,"_path":1484},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1486,"_path":1487},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1489,"_path":1490},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1492,"_path":1493},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1495,"_path":1496},"unity的addressables","/unity/2020-09-12-addressables",{"title":1498,"_path":1499},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1501,"_path":1502},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1504,"_path":1505},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1507,"_path":1508},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":8,"_path":4},{"title":1511,"_path":1512},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1514,"_path":1515},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1517,"_path":1518},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1520,"_path":1521},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1523,"_path":1524},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1526,"_path":1527},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1529,"_path":1530},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1532,"_path":1533},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1535,"_path":1536},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1538,"_path":1539},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1541,"_path":1542},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1544,"_path":1545},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1547,"_path":1548},"ability","/unity/2020-11-16-dotssample",{"title":1550,"_path":1551},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1553,"_path":1554},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1556,"_path":1557},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1559,"_path":1560},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1562,"_path":1563},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1565,"_path":1566},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1568,"_path":1569},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1571,"_path":1572},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1574,"_path":1575},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1577,"_path":1578},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1580,"_path":1581},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1583,"_path":1584},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1586,"_path":1587},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1589,"_path":1590},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1592,"_path":1593},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1595,"_path":1596},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1598,"_path":1599},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779039565]