[{"data":1,"prerenderedAt":770},["Reactive",2],{"content-query-uM95B7PDCh":3,"content-navigation-8C37fagqQL":188},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":182,"_id":183,"_source":184,"_file":185,"_extension":186,"date":187},"/unity/2019-09-03-xlua-inject","unity",false,"","xlua注入源码解读","让C#代码支持热更的流程Generate Code\n这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。Hotfix Inject\n这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码Generate Code 实现和生成结果\n在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Im",{"type":11,"children":12,"toc":179},"root",[13,29,43,56,69,75,88,97,110,120,128,137,142,155,166],{"type":14,"tag":15,"props":16,"children":17},"element","ul",{},[18],{"type":14,"tag":19,"props":20,"children":21},"li",{},[22],{"type":14,"tag":23,"props":24,"children":25},"strong",{},[26],{"type":27,"value":28},"text","让C#代码支持热更的流程",{"type":14,"tag":30,"props":31,"children":32},"ol",{},[33,38],{"type":14,"tag":19,"props":34,"children":35},{},[36],{"type":27,"value":37},"Generate Code\n这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。",{"type":14,"tag":19,"props":39,"children":40},{},[41],{"type":27,"value":42},"Hotfix Inject\n这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码",{"type":14,"tag":15,"props":44,"children":45},{},[46],{"type":14,"tag":19,"props":47,"children":48},{},[49,54],{"type":14,"tag":23,"props":50,"children":51},{},[52],{"type":27,"value":53},"Generate Code 实现和生成结果",{"type":27,"value":55},"\n在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Imp这个就是到时候要重复使用到的映射到Lua中function的委托。",{"type":14,"tag":57,"props":58,"children":63},"pre",{"className":59,"code":61,"language":62,"meta":7},[60],"language-csharp","public void __Gen_Delegate_Imp0()\n{\n    RealStatePtr L = luaEnv.rawL;\n    int errFunc = LuaAPI.pcall_prepare(L, errorFuncRef, luaReference);\n    PCall(L, 0, 0, errFunc);\n    LuaAPI.lua_settop(L, errFunc - 1);\n}\n","csharp",[64],{"type":14,"tag":65,"props":66,"children":67},"code",{"__ignoreMap":7},[68],{"type":27,"value":61},{"type":14,"tag":70,"props":71,"children":72},"p",{},[73],{"type":27,"value":74},"生成的代码就是先设置errorFuncRef（异常回调），luaReference（Lua方法）。如果在XLua中设置了热更修复代码，那么就会在C#中生成一个DelegateBridge，而其luaReference的指向就是Lua中的方法，所以这个只能调用指定的__Gen_Delegate_Imp，调用其他会报错。",{"type":14,"tag":15,"props":76,"children":77},{},[78],{"type":14,"tag":19,"props":79,"children":80},{},[81,86],{"type":14,"tag":23,"props":82,"children":83},{},[84],{"type":27,"value":85},"Hotfix Inject",{"type":27,"value":87},"\n这一步是在Unity为C#代码生成完对应dll之后，由XLua再来对dll注入一些判断条件式来完成是否进行Lua调用的行为。\n判断方法很简单，检查对应类静态字段是否有DelegateBridge对象。\n实现如下：",{"type":14,"tag":57,"props":89,"children":92},{"className":90,"code":91,"language":62,"meta":7},[60],"bool injectMethod(MethodDefinition method, HotfixFlagInTool hotfixType)\n{\n            var type = method.DeclaringType;\n            bool isFinalize = (method.Name == \"Finalize\" && method.IsSpecialName);\n            //__Gen_Delegate_Imp 方法引用\n            MethodReference invoke = null;\n            int param_count = method.Parameters.Count + (method.IsStatic ? 0 : 1);\n            //根据返回值和参数个数类型，查找对应的委托方法\n            if (!findHotfixDelegate(method, out invoke, hotfixType))\n            {\n                Error(\"can not find delegate for \" + method.DeclaringType + \".\" + method.Name + \"! try re-genertate code.\");\n                return false;\n            }\n\n            if (invoke == null)\n            {\n                throw new Exception(\"unknow exception!\");\n            }\n            \n            invoke = injectAssembly.MainModule.Import(invoke);\n            //插入的类静态字段，用来标记对应的方法是否有对应的Lua注入\n            FieldReference fieldReference = null;\n            //方法中的变量定义\n            VariableDefinition injection = null;\n            bool isIntKey = hotfixType.HasFlag(HotfixFlagInTool.IntKey) && !type.HasGenericParameters && isTheSameAssembly;\n            //isIntKey = !type.HasGenericParameters;\n\n            if (!isIntKey)\n            {\n                //新建变量，加入方法体的变量组中\n                injection = new VariableDefinition(invoke.DeclaringType);\n                method.Body.Variables.Add(injection);\n                //获取这个方法对应的委托名，因为有重载方法存在，所以之前已经注入的过的方法会在这边获取时候计数加1，\n                //比如第一个重载获取的是__Hotfix0，那么下一个重载会是__Hotfix1，判断是否注入就是是否设置对应FieldReference。\n                var luaDelegateName = getDelegateName(method);\n                if (luaDelegateName == null)\n                {\n                    Error(\"too many overload!\");\n                    return false;\n                }\n                //创建对应的静态Field名字就是上面取到的luaDelegateName \n                FieldDefinition fieldDefinition = new FieldDefinition(luaDelegateName, Mono.Cecil.FieldAttributes.Static | Mono.Cecil.FieldAttributes.Private,\n                    invoke.DeclaringType);\n                type.Fields.Add(fieldDefinition);\n                fieldReference = fieldDefinition.GetGeneric();\n            }\n\n            bool ignoreValueType = hotfixType.HasFlag(HotfixFlagInTool.ValueTypeBoxing);\n            //IL插入位置，现在定位的是方法体的第一行\n            var insertPoint = method.Body.Instructions[0];\n            //获取IL处理器\n            var processor = method.Body.GetILProcessor();\n            //构造函数的处理逻辑先跳过这边不做分析\n            if (method.IsConstructor)\n            {\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            Dictionary\u003CInstruction, Instruction> originToNewTarget = new Dictionary\u003CInstruction, Instruction>();\n            HashSet\u003CInstruction> noCheck = new HashSet\u003CInstruction>();\n            \n            while (insertPoint != null)\n            {\n                //isIntKey这边用到的是Xlua中的AutoIdMap，这边只对最基础的功能做分析，这边就分析基础的注入了。\n                Instruction firstInstruction;\n                if (isIntKey)\n                {\n                    firstInstruction = processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count);\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, hotfixFlagGetter));\n                }\n                else\n                {\n                    //创建第一条IL语句，获取类的静态Field压入方法栈中，其实就是之前luaDelegateName获取的字段\n                    firstInstruction = processor.Create(OpCodes.Ldsfld, fieldReference);\n                    //插入insertPoint之前\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    //创建并插入IL，获取栈顶的值并压入到对应的变量中，injection就是我们之前创建的新建变量\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Stloc, injection));\n                    //创建并插入IL，压入变量体中的值到栈\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n                //创建跳转语句，为false时候直接跳转insertPoint,\n                //这边OpCodes.Brfalse看起来是布尔值判断，其实也会判断是否为null\n                var jmpInstruction = processor.Create(OpCodes.Brfalse, insertPoint);\n                processor.InsertBefore(insertPoint, jmpInstruction);\n\n                if (isIntKey)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count));\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, delegateBridgeGetter));\n                }\n                else\n                {\n                    //创建并插入IL,再次压入变量的值，因为上面做完判断后，栈顶的值就会被弹出，所以这边要再次压入\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n\n                for (int i = 0; i \u003C param_count; i++)\n                {\n                    if (i \u003C ldargs.Length)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(ldargs[i]));\n                    }\n                    else if (i \u003C 256)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg_S, (byte)i));\n                    }\n                    else\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg, (short)i));\n                    }\n                    if (i == 0 && !method.IsStatic && type.IsValueType)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldobj, type));\n                        \n                    }\n                    //对值类型进行Box\n                    if (ignoreValueType)\n                    {\n                        TypeReference paramType;\n                        if (method.IsStatic)\n                        {\n                            paramType = method.Parameters[i].ParameterType;\n                        }\n                        else\n                        {\n                            paramType = (i == 0) ? type : method.Parameters[i - 1].ParameterType;\n                        }\n                        if (paramType.IsValueType)\n                        {\n                            processor.InsertBefore(insertPoint, processor.Create(OpCodes.Box, paramType));\n                        }\n                    }\n                }\n                //创建并插入IL，调用invoke方法，因为之前已经压入injection的值，DelegateBridge的对象\n                processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, invoke));\n                //普通方法，加入返回操作\n                if (!method.IsConstructor && !isFinalize)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ret));\n                }\n\n                if (!method.IsConstructor)\n                {\n                    break;\n                }\n                else\n                {\n                    originToNewTarget[insertPoint] = firstInstruction;\n                    noCheck.Add(jmpInstruction);\n                }\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            if (method.IsConstructor)\n            {\n                fixBranch(processor, method.Body.Instructions, originToNewTarget, noCheck);\n            }\n\n            if (isFinalize)\n            {\n                if (method.Body.ExceptionHandlers.Count == 0)\n                {\n                    throw new InvalidProgramException(\"Finalize has not try-catch? Type :\" + method.DeclaringType);\n                }\n                method.Body.ExceptionHandlers[0].TryStart = method.Body.Instructions[0];\n            }\n            if (isIntKey)\n            {\n                bridgeIndexByKey.Add(method);\n            }\n            return true;\n}\nstatic string getDelegateName(MethodDefinition method)\n{\n            string fieldName = method.Name;\n            if (fieldName.StartsWith(\".\"))\n            {\n                fieldName = fieldName.Substring(1);\n            }\n            string ccFlag = method.IsConstructor ? \"_c\" : \"\";\n            string luaDelegateName = null;\n            var type = method.DeclaringType;\n            for (int i = 0; i \u003C MAX_OVERLOAD; i++)\n            {\n                string tmp = ccFlag + \"__Hotfix\" + i + \"_\" + fieldName;\n                if (!type.Fields.Any(f => f.Name == tmp)) // injected\n                {\n                    luaDelegateName = tmp;\n                    break;\n                }\n            }\n            return luaDelegateName;\n}\n",[93],{"type":14,"tag":65,"props":94,"children":95},{"__ignoreMap":7},[96],{"type":27,"value":91},{"type":14,"tag":15,"props":98,"children":99},{},[100],{"type":14,"tag":19,"props":101,"children":102},{},[103,108],{"type":14,"tag":23,"props":104,"children":105},{},[106],{"type":27,"value":107},"xlua.hotfix",{"type":27,"value":109},"在完成生成代码和注入后，只要在Lua中调用xlua.hotfix或util.hotfix*ex方法就可以实现C#代码热更了。*hotfix和hotfixex的区别在与是否可以调用原C#代码，其实ex的实现也是调用了hotfix，在下面将分析hotfix和hotfix_ex的实现原理。\n先分析下hotfix的Lua代码，代码在第一篇文章中的实例化lua中：",{"type":14,"tag":57,"props":111,"children":115},{"className":112,"code":114,"language":27,"meta":7},[113],"language-text","     init_xlua.lua\n     xlua.hotfix = function(cs, field, func)\n                //判空\n                if func == nil then func = false end\n                //检查并且统一转化为table\n                //因为在Xlua中可以一次传一个方法，或者一次传一组方法\n                local tbl = (type(field) == 'table') and field or {[field] = func}\n                //遍历需要hotfix的代码，key是方法名，v是对应的func\n                for k, v in pairs(tbl) do\n                    //构造函数的hotfix，这边不做分析了，原理一样\n                    local cflag = ''\n                    if k == '.ctor' then\n                        cflag = '_c'\n                        k = 'ctor'\n                    end\n                    //检查v的类型\n                    local f = type(v) == 'function' and v or nil\n                    //调用access函数，其在初始化注册，最终实现在C#中下文解析实现\n                    xlua.access(cs, cflag .. '__Hotfix0_'..k, f) -- at least one\n                    //尝试给重载方法也添加上function如果有重载的话\n                    pcall(function()\n                        for i = 1, 99 do\n                            xlua.access(cs, cflag .. '__Hotfix'..i..'_'..k, f)\n                        end\n                    end)\n                end\n                //设置私有访问\n                xlua.private_accessible(cs)\n              end\n",[116],{"type":14,"tag":65,"props":117,"children":118},{"__ignoreMap":7},[119],{"type":27,"value":114},{"type":14,"tag":70,"props":121,"children":122},{},[123],{"type":14,"tag":23,"props":124,"children":125},{},[126],{"type":27,"value":127},"XLuaAccess在C#中的实现：",{"type":14,"tag":57,"props":129,"children":132},{"className":130,"code":131,"language":27,"meta":7},[113],"        //xlua.access(cs, cflag .. '__Hotfix0_'..k, f)\n\n        public static int XLuaAccess(RealStatePtr L)\n        {\n            try\n            {\n                \n                ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n                //获取对应的CS类Type\n                Type type = getType(L, translator, 1);\n                object obj = null;\n                if (type == null && LuaAPI.lua_type(L, 1) == LuaTypes.LUA_TUSERDATA)\n                {\n                    obj = translator.SafeGetCSObj(L, 1);\n                    if (obj == null)\n                    {\n                        return LuaAPI.luaL_error(L, \"xlua.access, #1 parameter must a type/c# object/string\");\n                    }\n                    type = obj.GetType();\n                }\n\n                if (type == null)\n                {\n                    return LuaAPI.luaL_error(L, \"xlua.access, can not find c# type\");\n                }\n                //将cflag .. '__Hotfix0_'..k 转为fieldName，这个字段就是之前Inject时候创建的类静态字段名\n                string fieldName = LuaAPI.lua_tostring(L, 2);\n\n                BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;\n                //这边访问一定是Set所以后面就不分析了，这边就是反射获取对应的FieldInfo，重点在于translator.GetObject方法。\n                if (LuaAPI.lua_gettop(L) > 2) // set\n                {\n                    var field = type.GetField(fieldName, bindingFlags);\n                    if (field != null)\n                    {\n                        field.SetValue(obj, translator.GetObject(L, 3, field.FieldType));\n                        return 0;\n                    }\n                    var prop = type.GetProperty(fieldName, bindingFlags);\n                    if (prop != null)\n                    {\n                        prop.SetValue(obj, translator.GetObject(L, 3, prop.PropertyType), null);\n                        return 0;\n                    }\n                }\n                else\n                {\n                    ...\n                }\n                return LuaAPI.luaL_error(L, \"xlua.access, no field \" + fieldName);\n            }\n            catch (Exception e)\n            {\n                return LuaAPI.luaL_error(L, \"c# exception in xlua.access: \" + e);\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object GetObject(RealStatePtr L, int index, Type type)\n        {\n            int udata = LuaAPI.xlua_tocsobj_safe(L, index);\n\n            if (udata != -1)\n            {\n                ...\n            }\n            else\n            {\n                //一些特殊值类型的返回\n                ...\n                return (objectCasters.GetCaster(type)(L, index, null));\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public ObjectCast GetCaster(Type type)\n       {\n            ...\n            ObjectCast oc;\n            //缓存行为，继续分析第一次获取的caster委托\n            if (!castersMap.TryGetValue(type, out oc))\n            {\n                oc = genCaster(type);\n                castersMap.Add(type, oc);\n            }\n            return oc;\n        }\n        //为了减少篇幅，只展示必要代码\n        private ObjectCast genCaster(Type type)\n        {\n            \n            ObjectCast fixTypeGetter = (RealStatePtr L, int idx, object target) =>\n            {\n                if (LuaAPI.lua_type(L, idx) == LuaTypes.LUA_TUSERDATA)\n                {\n                    object obj = translator.SafeGetCSObj(L, idx);\n                    return (obj != null && type.IsAssignableFrom(obj.GetType())) ? obj : null;\n                }\n                return null;\n            }; \n            if ...\n            //在Inject代码时候我们已经知道其字段类型就是DelegateBridge，所以会返回的就是这个表达式\n            else if (typeof(DelegateBridgeBase).IsAssignableFrom(type))\n            {\n                return (RealStatePtr L, int idx, object target) =>\n                {\n                    //缓存行为，分析CreateDelegateBridge\n                    object obj = fixTypeGetter(L, idx, target);\n                    if (obj != null) return obj;\n\n                    if (!LuaAPI.lua_isfunction(L, idx))\n                    {\n                        return null;\n                    }\n\n                    return translator.CreateDelegateBridge(L, null, idx);\n                };\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx)\n        {\n            //这边只是查找是否这个方法已经有缓存了，有的话直接返回，没有就要Create，我们继续分析Create的事。\n            LuaAPI.lua_pushvalue(L, idx);\n            LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);\n            //不为null就是已经生成过，就直接从缓存获取\n            if (!LuaAPI.lua_isnil(L, -1))\n            {\n                retrun ...\n            }\n            else\n            {\n                //弹出刚刚查询过的nil值\n                LuaAPI.lua_pop(L, 1);\n            }\n            //开始生成对应的DelegateBridge\n            //压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //获取function对应的引用id\n            int reference = LuaAPI.luaL_ref(L);\n            //再次压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //压入function对应的引用id\n            LuaAPI.lua_pushnumber(L, reference);\n            //将栈顶的两个值以字典形式存在全局变量表中，这个的作用就是上面的代码查询是否已经在lua中缓存。\n            LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n            DelegateBridgeBase bridge;\n            try\n            {\n                //创建DelegateBridge，注意这边的reference，这个就是对应了lua中修复的lua函数，\n                //我们在Inject时候call的方法会使用到这个参数。\n                bridge = new DelegateBridge(reference, luaEnv);\n            }\n            catch(Exception e)\n            {\n                //异常情况下的，清场操作\n                LuaAPI.lua_pushvalue(L, idx);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.xlua_rawseti(L, LuaIndexes.LUA_REGISTRYINDEX, reference);\n                throw e;\n            }\n            //因为hotfix时候，delegateType传进来是个null，后续代码不会被调用到，就不做分析了。\n            if (delegateType == null)\n            {\n                //缓存到字典中，注意这里是弱引用所以会被回收，被回收后，需要从lua中查询到对应引用值，然后再生产。\n                delegate_bridges[reference] = new WeakReference(bridge);\n                return bridge;\n            }\n            ...\n        }\n",[133],{"type":14,"tag":65,"props":134,"children":135},{"__ignoreMap":7},[136],{"type":27,"value":131},{"type":14,"tag":70,"props":138,"children":139},{},[140],{"type":27,"value":141},"这样在进行调用hotfix后，对应的要修复的类的静态字段就会被设置上对应的DelegateBridge对象，然后在C#代码执行到对应的需要热更修复的方法时候，会先执行我们注入的IL代码，检查是否有对应的DelegateBridge。那么就是调用DelegateBridge中对应的方法，方法中包含的reference就是Lua对应的function，这样就执行到了lua中去，实现了热更。",{"type":14,"tag":15,"props":143,"children":144},{},[145],{"type":14,"tag":19,"props":146,"children":147},{},[148,153],{"type":14,"tag":23,"props":149,"children":150},{},[151],{"type":27,"value":152},"util.hotfix_ex的实现",{"type":27,"value":154},"\n其实现直白的来讲就是在调用util.hotfix_ex(functionB)时候，真正设置的是一个中间函数A，它被设置为对应方法的热更修复函数。\n在调用A进行热更时候，它先设置这个方法的热更方法为空，然后调用原先设置的functionB，当functionB调用完后，然后再设置回热更方法为A，那么就能实现在热更修复方法functionB中调用原先的方法。\n因为设置这些参数都是带反射的，所以在高频场景是有性能消耗的。\n代码实现如下：",{"type":14,"tag":57,"props":156,"children":161},{"className":157,"code":159,"language":160,"meta":7},[158],"language-lua","local function hotfix_ex(cs, field, func)\n    --断言，检查参数\n    assert(type(field) == 'string' and type(func) == 'function', 'invalid argument: #2 string needed, #3 function needed!')\n    --创建中间函数，就是上文提到的A\n    local function func_after(...)\n        --先将需要热更修复的方法设置为nil，那么再调用方法时候会执行的就是之前方法\n        xlua.hotfix(cs, field, nil)\n        --执行func，就是上文提到的functionB\n        local ret = {func(...)}\n        ---重新将需要热更修复的方法设置为中间函数A\n        xlua.hotfix(cs, field, func_after)\n        return unpack(ret)\n    end\n    --设置需要热更修复为中间函数A\n    xlua.hotfix(cs, field, func_after)\nend\n","lua",[162],{"type":14,"tag":65,"props":163,"children":164},{"__ignoreMap":7},[165],{"type":27,"value":159},{"type":14,"tag":15,"props":167,"children":168},{},[169],{"type":14,"tag":19,"props":170,"children":171},{},[172,177],{"type":14,"tag":23,"props":173,"children":174},{},[175],{"type":27,"value":176},"结束语",{"type":27,"value":178},"整个Hotfix的实现也分析完了，后续的文章将继续分析，XLua中的各种优化技巧实现，比如无GC传值，模板生成技术。",{"title":7,"searchDepth":180,"depth":180,"links":181},2,[],"markdown","content:unity:2019-09-03-xlua-inject.md","content","unity/2019-09-03-xlua-inject.md","md","2019-09-03",[189,199,326,375,427,440,552],{"title":190,"_path":191,"children":192},"Art","/art",[193,196],{"title":194,"_path":195},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":197,"_path":198},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":200,"_path":201,"children":202},"Dotnet","/dotnet",[203,206,209,212,215,218,221,224,227,230,233,236,239,242,245,248,251,254,257,260,263,266,269,272,275,278,281,284,287,290,293,296,299,302,305,308,311,314,317,320,323],{"title":204,"_path":205},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":207,"_path":208},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":210,"_path":211},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":213,"_path":214},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":216,"_path":217},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":219,"_path":220},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":222,"_path":223},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":225,"_path":226},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":228,"_path":229},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":231,"_path":232},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":234,"_path":235},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":237,"_path":238},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":240,"_path":241},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":243,"_path":244},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":246,"_path":247},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":249,"_path":250},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":252,"_path":253},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":255,"_path":256},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":258,"_path":259},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":261,"_path":262},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":264,"_path":265},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":267,"_path":268},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":270,"_path":271},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":273,"_path":274},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":276,"_path":277},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":279,"_path":280},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":282,"_path":283},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":285,"_path":286},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":288,"_path":289},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":291,"_path":292},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":294,"_path":295},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":297,"_path":298},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":300,"_path":301},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":303,"_path":304},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":306,"_path":307},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":309,"_path":310},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":312,"_path":313},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":315,"_path":316},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":318,"_path":319},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":321,"_path":322},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":324,"_path":325},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":327,"_path":328,"children":329},"Game","/game",[330,333,336,339,342,345,348,351,354,357,360,363,366,369,372],{"title":331,"_path":332},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":334,"_path":335},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":337,"_path":338},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":340,"_path":341},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":343,"_path":344},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":346,"_path":347},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":349,"_path":350},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":352,"_path":353},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":355,"_path":356},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":358,"_path":359},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":361,"_path":362},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":364,"_path":365},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":367,"_path":368},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":370,"_path":371},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":373,"_path":374},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":376,"_path":377,"children":378},"Gyj","/gyj",[379,382,385,388,391,394,397,400,403,406,409,412,415,418,421,424],{"title":380,"_path":381},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":383,"_path":384},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":386,"_path":387},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":389,"_path":390},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":392,"_path":393},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":395,"_path":396},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":398,"_path":399},"玩法","/gyj/2022-08-22-wanfa",{"title":401,"_path":402},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":404,"_path":405},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":407,"_path":408},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":410,"_path":411},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":413,"_path":414},"门派内容相关","/gyj/2022-11-17-sect",{"title":416,"_path":417},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":419,"_path":420},"种植","/gyj/2022-12-01-zhongzhi",{"title":422,"_path":423},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":425,"_path":426},"跑商","/gyj/2023-11-01-paoshang",{"title":428,"_path":429,"children":430},"Js","/js",[431,434,437],{"title":432,"_path":433},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":435,"_path":436},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":438,"_path":439},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":441,"_path":442,"children":443},"Tool","/tool",[444,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492,495,498,501,504,507,510,513,516,519,522,525,528,531,534,537,540,543,546,549],{"title":445,"_path":446},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":448,"_path":449},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":451,"_path":452},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":454,"_path":455},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":457,"_path":458},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":460,"_path":461},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":463,"_path":464},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":466,"_path":467},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":469,"_path":470},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":472,"_path":473},"mac下brew 使用","/tool/2020-01-13-brew",{"title":475,"_path":476},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":478,"_path":479},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":481,"_path":482},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":484,"_path":485},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":487,"_path":488},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":490,"_path":491},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":493,"_path":494},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":496,"_path":497},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":499,"_path":500},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":502,"_path":503},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":505,"_path":506},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":508,"_path":509},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":511,"_path":512},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":514,"_path":515},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":517,"_path":518},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":520,"_path":521},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":523,"_path":524},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":526,"_path":527},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":529,"_path":530},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":532,"_path":533},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":535,"_path":536},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":538,"_path":539},"rider的使用","/tool/2022-08-02-rider-use",{"title":541,"_path":542},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":544,"_path":545},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":547,"_path":548},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":550,"_path":551},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":553,"_path":554,"children":555},"Unity","/unity",[556,559,562,565,568,571,574,577,580,583,586,589,592,593,596,599,602,605,608,611,614,617,620,623,626,629,632,635,638,641,644,647,650,653,656,659,662,665,668,671,674,677,680,683,686,689,692,695,698,701,704,707,710,713,716,719,722,725,728,731,734,737,740,743,746,749,752,755,758,761,764,767],{"title":557,"_path":558},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":560,"_path":561},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":563,"_path":564},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":566,"_path":567},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":569,"_path":570},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":572,"_path":573},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":575,"_path":576},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":578,"_path":579},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":581,"_path":582},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":584,"_path":585},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":587,"_path":588},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":590,"_path":591},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":8,"_path":4},{"title":594,"_path":595},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":597,"_path":598},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":600,"_path":601},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":603,"_path":604},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":606,"_path":607},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":609,"_path":610},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":612,"_path":613},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":615,"_path":616},"技能系统","/unity/2020-02-15-skill-system",{"title":618,"_path":619},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":621,"_path":622},"角色状态设计","/unity/2020-02-17-character-states",{"title":624,"_path":625},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":627,"_path":628},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":630,"_path":631},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":633,"_path":634},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":636,"_path":637},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":639,"_path":640},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":642,"_path":643},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":645,"_path":646},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":648,"_path":649},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":651,"_path":652},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":654,"_path":655},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":657,"_path":658},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":660,"_path":661},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":663,"_path":664},"unity的addressables","/unity/2020-09-12-addressables",{"title":666,"_path":667},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":669,"_path":670},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":672,"_path":673},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":675,"_path":676},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":678,"_path":679},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":681,"_path":682},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":684,"_path":685},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":687,"_path":688},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":690,"_path":691},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":693,"_path":694},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":696,"_path":697},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":699,"_path":700},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":702,"_path":703},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":705,"_path":706},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":708,"_path":709},"简单保存工具","/unity/2020-11-13-simple-save",{"title":711,"_path":712},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":714,"_path":715},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":717,"_path":718},"ability","/unity/2020-11-16-dotssample",{"title":720,"_path":721},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":723,"_path":724},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":726,"_path":727},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":729,"_path":730},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":732,"_path":733},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":735,"_path":736},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":738,"_path":739},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":741,"_path":742},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":744,"_path":745},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":747,"_path":748},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":750,"_path":751},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":753,"_path":754},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":756,"_path":757},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":759,"_path":760},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":762,"_path":763},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":765,"_path":766},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":768,"_path":769},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041693]