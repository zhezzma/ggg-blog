[{"data":1,"prerenderedAt":1230},["Reactive",2],{"content-query-q5N8Wi8F9U":3,"content-navigation-8C37fagqQL":648},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":642,"_id":643,"_source":644,"_file":645,"_extension":646,"date":647},"/unity/2020-07-03-unity-mesh","unity",false,"","2020 07 03 Unity Mesh","title : \"Mesh renderer 和 Mesh 和 Mesh Filter\"基本概念Meshes 是Unity的主要图形基元。 它们定义对象的形状。Materials 通过包含对所用纹理的引用、平铺信息、颜色色调等来定义表面应使用的渲染方式。材质的可用选项取决于材质使用的着色器。Shaders 是一些包含数学计算和算法的小脚本，根据光照输入和材质配置来计算每个像素渲染的颜色。Textures 是位图图像。材质可包含对纹理的引用，因此材质的着色器可在计算游戏对象的表面颜色时使用纹理。除了游戏对象表面的基本颜色（反照率）之外，纹理还可表示材质表面的许多其他方面，例如其反射率或粗糙度。T",{"type":11,"children":12,"toc":636},"root",[13,18,26,32,78,84,94,187,193,244,249,256,261,274,279,284,293,298,306,311,316,324,336,342,347,355,360,368,373,381,386,393,398,405,412,417,424,429,436,445,451,456,461,466,471,476,481,489,494,502,507,557,562],{"type":14,"tag":15,"props":16,"children":17},"element","hr",{},[],{"type":14,"tag":19,"props":20,"children":22},"h2",{"id":21},"title-mesh-renderer-和-mesh-和-mesh-filter",[23],{"type":24,"value":25},"text","title : \"Mesh renderer 和 Mesh 和 Mesh Filter\"",{"type":14,"tag":27,"props":28,"children":30},"h1",{"id":29},"基本概念",[31],{"type":24,"value":29},{"type":14,"tag":33,"props":34,"children":35},"ul",{},[36,48,58,68],{"type":14,"tag":37,"props":38,"children":39},"li",{},[40,46],{"type":14,"tag":41,"props":42,"children":43},"strong",{},[44],{"type":24,"value":45},"Meshes",{"type":24,"value":47}," 是Unity的主要图形基元。 它们定义对象的形状。",{"type":14,"tag":37,"props":49,"children":50},{},[51,56],{"type":14,"tag":41,"props":52,"children":53},{},[54],{"type":24,"value":55},"Materials",{"type":24,"value":57}," 通过包含对所用纹理的引用、平铺信息、颜色色调等来定义表面应使用的渲染方式。材质的可用选项取决于材质使用的着色器。",{"type":14,"tag":37,"props":59,"children":60},{},[61,66],{"type":14,"tag":41,"props":62,"children":63},{},[64],{"type":24,"value":65},"Shaders",{"type":24,"value":67}," 是一些包含数学计算和算法的小脚本，根据光照输入和材质配置来计算每个像素渲染的颜色。",{"type":14,"tag":37,"props":69,"children":70},{},[71,76],{"type":14,"tag":41,"props":72,"children":73},{},[74],{"type":24,"value":75},"Textures",{"type":24,"value":77}," 是位图图像。材质可包含对纹理的引用，因此材质的着色器可在计算游戏对象的表面颜色时使用纹理。除了游戏对象表面的基本颜色（反照率）之外，纹理还可表示材质表面的许多其他方面，例如其反射率或粗糙度。",{"type":14,"tag":19,"props":79,"children":81},{"id":80},"texture",[82],{"type":24,"value":83},"Texture",{"type":14,"tag":85,"props":86,"children":87},"p",{},[88],{"type":14,"tag":89,"props":90,"children":93},"img",{"alt":91,"src":92},"这里写图片描述","/images/2020-07-03-unity-mesh/201808082025438",[],{"type":14,"tag":33,"props":95,"children":96},{},[97,109,121,131,141,153,165,177],{"type":14,"tag":37,"props":98,"children":99},{},[100],{"type":14,"tag":101,"props":102,"children":106},"a",{"href":103,"rel":104},"https://docs.unity3d.com/Manual/TextureTypes.html#Default",[105],"nofollow",[107],{"type":24,"value":108},"Default",{"type":14,"tag":37,"props":110,"children":111},{},[112,119],{"type":14,"tag":101,"props":113,"children":116},{"href":114,"rel":115},"https://docs.unity3d.com/Manual/TextureTypes.html#NormalMap",[105],[117],{"type":24,"value":118},"Normal Map",{"type":24,"value":120}," 法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向，你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面",{"type":14,"tag":37,"props":122,"children":123},{},[124],{"type":14,"tag":101,"props":125,"children":128},{"href":126,"rel":127},"https://docs.unity3d.com/Manual/TextureTypes.html#Editor",[105],[129],{"type":24,"value":130},"Editor GUI and Legacy",{"type":14,"tag":37,"props":132,"children":133},{},[134],{"type":14,"tag":101,"props":135,"children":138},{"href":136,"rel":137},"https://docs.unity3d.com/Manual/TextureTypes.html#Sprite",[105],[139],{"type":24,"value":140},"Sprite (2D and UI)",{"type":14,"tag":37,"props":142,"children":143},{},[144,151],{"type":14,"tag":101,"props":145,"children":148},{"href":146,"rel":147},"https://docs.unity3d.com/Manual/TextureTypes.html#Cursor",[105],[149],{"type":24,"value":150},"Cursor",{"type":24,"value":152},"  光标文件",{"type":14,"tag":37,"props":154,"children":155},{},[156,163],{"type":14,"tag":101,"props":157,"children":160},{"href":158,"rel":159},"https://docs.unity3d.com/Manual/TextureTypes.html#Cookie",[105],[161],{"type":24,"value":162},"Cookie",{"type":24,"value":164}," 聚光灯贴图",{"type":14,"tag":37,"props":166,"children":167},{},[168,175],{"type":14,"tag":101,"props":169,"children":172},{"href":170,"rel":171},"https://docs.unity3d.com/Manual/TextureTypes.html#Lightmap",[105],[173],{"type":24,"value":174},"Lightmap",{"type":24,"value":176},"  光照贴图",{"type":14,"tag":37,"props":178,"children":179},{},[180],{"type":14,"tag":101,"props":181,"children":184},{"href":182,"rel":183},"https://docs.unity3d.com/Manual/TextureTypes.html#SingleChannel",[105],[185],{"type":24,"value":186},"Single Channel",{"type":14,"tag":27,"props":188,"children":190},{"id":189},"mesh",[191],{"type":24,"value":192},"Mesh",{"type":14,"tag":33,"props":194,"children":195},{},[196,201,206,220,225,239],{"type":14,"tag":37,"props":197,"children":198},{},[199],{"type":24,"value":200},"顶点坐标（vertex） 顶点坐标数组存放Mesh的每个顶点的空间坐标，假设某mesh有n个顶点，则vertex的size为n",{"type":14,"tag":37,"props":202,"children":203},{},[204],{"type":24,"value":205},"三角形序列（triangle） 每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，三角形的数组的size = 三角形个数 * 3.",{"type":14,"tag":37,"props":207,"children":208},{},[209,211,218],{"type":24,"value":210},"法线（normal） 法线数组存放mesh每个顶点的法线，大小与顶点坐标对应，normal[i]对应顶点vertex[i]的法线.它不仅说明了",{"type":14,"tag":212,"props":213,"children":215},"code",{"className":214},[],[216],{"type":24,"value":217},"面片的朝向，还可用于计算光照模型",{"type":24,"value":219},"。",{"type":14,"tag":37,"props":221,"children":222},{},[223],{"type":24,"value":224},"次法线 (subnormal)",{"type":14,"tag":37,"props":226,"children":227},{},[228,230,237],{"type":24,"value":229},"纹理坐标（uv） 它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的, 以决定表面纹理贴图的位置. UV就是将",{"type":14,"tag":101,"props":231,"children":234},{"href":232,"rel":233},"http://baike.baidu.com/view/42116.htm",[105],[235],{"type":24,"value":236},"图像",{"type":24,"value":238},"上每一个点精确对应到模型物体的表面. uv[i]对应vertex[i]",{"type":14,"tag":37,"props":240,"children":241},{},[242],{"type":24,"value":243},"切线 (tangent) 切线是垂直于法线的一条向量，由于垂直于法线的向量有无数条，所以切线最终规定为由UV坐标来决定朝向。",{"type":14,"tag":85,"props":245,"children":246},{},[247],{"type":24,"value":248},"例如：左图利用三个点绘制了一个三角形，而右图则通过两个三角形得到了一个四边形：",{"type":14,"tag":85,"props":250,"children":251},{},[252],{"type":14,"tag":89,"props":253,"children":255},{"alt":89,"src":254},"/images/2020-07-03-unity-mesh/20190805190859508.png",[],{"type":14,"tag":85,"props":257,"children":258},{},[259],{"type":24,"value":260},"注：这里需要注意的是，很明显从左图中给定的三个点，有两种方式可以得到三角图元，即",{"type":14,"tag":33,"props":262,"children":263},{},[264,269],{"type":14,"tag":37,"props":265,"children":266},{},[267],{"type":24,"value":268},"顺时针旋转（也称左手螺旋）：p0->p1->p2",{"type":14,"tag":37,"props":270,"children":271},{},[272],{"type":24,"value":273},"逆时针旋转（右手螺旋）：p0->p2->p1",{"type":14,"tag":85,"props":275,"children":276},{},[277],{"type":24,"value":278},"它们的区别在哪里呢？类似于物理中左右手判断法则，拇指指示了三角图元的法线方向。法线其中一个作用是指明了三角图元的方向，如果从反方向看的话，这个图元是不可见的。而unity3d是左手坐标系在渲染时默认只渲染正面，背面是看不见的。",{"type":14,"tag":85,"props":280,"children":281},{},[282],{"type":24,"value":283},"那么要绘制上图中的三角形，即问题在于表达三个点的坐标，也就可以表示为下面的代码：",{"type":14,"tag":285,"props":286,"children":288},"pre",{"code":287},"Vector2[] vertices = new Vector2[]{ \n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n };\n",[289],{"type":14,"tag":212,"props":290,"children":291},{"__ignoreMap":7},[292],{"type":24,"value":287},{"type":14,"tag":85,"props":294,"children":295},{},[296],{"type":24,"value":297},"而如果要绘制四边形，也就需要六个点的坐标，如下面所示：",{"type":14,"tag":285,"props":299,"children":301},{"code":300},"Vector2[] vertices = new Vector2[]{ \n    // 三角图元 0\n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n    // 三角图元 1\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 1 ),                            // p3\n    new Vector2( 1, 0 ),                            // p2\n };\n",[302],{"type":14,"tag":212,"props":303,"children":304},{"__ignoreMap":7},[305],{"type":24,"value":300},{"type":14,"tag":85,"props":307,"children":308},{},[309],{"type":24,"value":310},"如果单纯使用顶点来表示（绘制）图形，是非常直观的——因为我们知道每一个顶点的位置信息，并且知道每三个点构成一个三角图元。然而从上面绘制四边形的数据中可以发现，三角图元1中有两个顶点的位置信息（p1和p3）和三角图元0是一样的。这也就增加了一些开销。",{"type":14,"tag":85,"props":312,"children":313},{},[314],{"type":24,"value":315},"总而言之，这个额外的存储开销是完全可以去除的，方法就是使用索引（Indices）。",{"type":14,"tag":285,"props":317,"children":319},{"code":318},"Vector2[] vertices = new Vector2[]{ \n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n };\n int[] indices = new indices[]{\n    0, 1, 2                                         // 表示 0->1->2 构成一个三角图元\n };\n",[320],{"type":14,"tag":212,"props":321,"children":322},{"__ignoreMap":7},[323],{"type":24,"value":318},{"type":14,"tag":85,"props":325,"children":326},{},[327,329,335],{"type":24,"value":328},"没错，indices就是这么一回事，原来是vertices数组中，每三个顶点表示一个三角图元，现在是indices数组中，每三个整型表示一个图元。这些整形不存储真正的数据，",{"type":14,"tag":212,"props":330,"children":332},{"className":331},[],[333],{"type":24,"value":334},"只有用到时才从vertices中取出，也就是所谓的索引了",{"type":24,"value":219},{"type":14,"tag":27,"props":337,"children":339},{"id":338},"submesh",[340],{"type":24,"value":341},"SubMesh",{"type":14,"tag":85,"props":343,"children":344},{},[345],{"type":24,"value":346},"面提到过，MeshRenderer负责对MeshFilter中的Mesh进行绘制，而绘制依赖于着色器，或者说着色器生成的材质（Material）。简单来说，材质具体描述了Mesh中的数据如何进行绘制。\nMaterial只负责一个Mesh的一次绘制，但是现在有一个要求是，Mesh的不同部分，要求使用不同的材质。例如上面所绘制的四边形，两个三角面片要求绘制出不同的颜色。这个时候就需要使用SubMesh了。\n从名字也能看出，SubMesh类似于Mesh，并且Mesh包含SubMesh。但是和Mesh不一样的是，SubMesh只有triangles信息，也就是说SubMesh使用自身的 triangles信息，索引找到 Mesh上的顶点信息（如vertices、 uv、normal等）后进行三角面片的绘制。它们的关系如下图所示：",{"type":14,"tag":85,"props":348,"children":349},{},[350],{"type":14,"tag":89,"props":351,"children":354},{"alt":352,"src":353},"在这里插入图片描述","/images/2020-07-03-unity-mesh/20190806210636364.png",[],{"type":14,"tag":85,"props":356,"children":357},{},[358],{"type":24,"value":359},"这个设置的过程依赖于Mesh中的API是 SetTriangles，其函数原型为：",{"type":14,"tag":285,"props":361,"children":363},{"code":362},"/*\n @parm triangles:           SubMesh的triangles\n @parm submesh:             属于Mesh中的第几个submesh\n @parm calculateBounds： 是否计算包围盒，默认为true。设置为false会使用当前存在的包围盒以减少CPU开销\n @parm baseVertex：          triangles中每一个元素的偏移值，默认为0；\n*/\npublic void SetTriangles(int[] triangles, int submesh, bool calculateBounds = true, int baseVertex = 0);\n",[364],{"type":14,"tag":212,"props":365,"children":366},{"__ignoreMap":7},[367],{"type":24,"value":362},{"type":14,"tag":85,"props":369,"children":370},{},[371],{"type":24,"value":372},"用法如下：",{"type":14,"tag":285,"props":374,"children":376},{"code":375},"Vector3[] vertices = new Vector3[]{\n         new Vector3( 0, 0, 0 ),\n         new Vector3( 0, 1, 0 ),\n         new Vector3( 1, 0, 0 ),\n         new Vector3( 1, 1, 0 ),\n    };\n    int[] subTriangles_0 = new int[]{\n        0, 1, 2\n    };\n    int[] subTriangles_1 = new int[]{\n        1, 3, 2\n    };\n    Mesh mesh = new Mesh();\n    mesh.vertices = vertices;\n    // 告诉 Mesh它将会有两个SubMesh\n    mesh.subMeshCount = 2;\n    mesh.SetTriangles( subTriangles_0 , 0 );\n    mesh.SetTriangles( subTriangles_1 , 1 );\n    // 重新计算normal信息，不然后面的 material会不起作用\n    mesh.RecaculateNormals();\n    // MeshFilter\n    MeshFilter meshFilter = GetComponent\u003CMeshFilter>();\n    if( meshFilter == null ) meshFilter = gameObject.AddComponent\u003CMeshFilter>();\n    meshFilter.mesh = mesh;\n    // MeshRenderer\n    MeshRenderer meshRenderer = GetComponent\u003CMeshRenderer>();\n    if( meshRenderer == null ) gameObject.AddComponent\u003CMeshRenderer>();\n",[377],{"type":14,"tag":212,"props":378,"children":379},{"__ignoreMap":7},[380],{"type":24,"value":375},{"type":14,"tag":85,"props":382,"children":383},{},[384],{"type":24,"value":385},"将上述代码挂载到一个空节点上运行，可以得到以下结果：",{"type":14,"tag":85,"props":387,"children":388},{},[389],{"type":14,"tag":89,"props":390,"children":392},{"alt":89,"src":391},"/images/2020-07-03-unity-mesh/20190806223230787.png",[],{"type":14,"tag":85,"props":394,"children":395},{},[396],{"type":24,"value":397},"嗯？！难不成笔者在骗人，这里明明只有一个三角面片。莫慌，之前不是说过，要求两个三角面片使用不同的材质吗？如果运行时，将MeshRenderer的Material的Size设为2的话，你会发现另外一个三角图元也出现了：",{"type":14,"tag":85,"props":399,"children":400},{},[401],{"type":14,"tag":89,"props":402,"children":404},{"alt":89,"src":403},"/images/2020-07-03-unity-mesh/20190806223831570.png",[],{"type":14,"tag":85,"props":406,"children":407},{},[408],{"type":14,"tag":89,"props":409,"children":411},{"alt":89,"src":410},"/images/2020-07-03-unity-mesh/20190806223841210.png",[],{"type":14,"tag":85,"props":413,"children":414},{},[415],{"type":24,"value":416},"也就是说，有多少个SubMesh，就需要有多少个Material，并且它们的绘制关系是一一对应的。即第一个SubMesh使用第一个\nMaterial绘制，第二个SubMesh使用第二个Material绘制，以此类推。为了验证这个，接下来创建两个默认的Material，将它们的Albedo分别设置为红色和绿色，接着运行时将这两个 Material赋给MeshRenderer，将会得到如下图所示的运行结果：",{"type":14,"tag":85,"props":418,"children":419},{},[420],{"type":14,"tag":89,"props":421,"children":423},{"alt":352,"src":422},"/images/2020-07-03-unity-mesh/2019080622511158.png",[],{"type":14,"tag":85,"props":425,"children":426},{},[427],{"type":24,"value":428},"另外，如果双击 MeshFilter的 Mesh属性，从下面的预览窗口，也能看到这个Mesh有两个SubMesh：",{"type":14,"tag":85,"props":430,"children":431},{},[432],{"type":14,"tag":89,"props":433,"children":435},{"alt":352,"src":434},"/images/2020-07-03-unity-mesh/20190806225353486.png",[],{"type":14,"tag":437,"props":438,"children":439},"blockquote",{},[440],{"type":14,"tag":85,"props":441,"children":442},{},[443],{"type":24,"value":444},"如何在unity显示线框图\n选择场景视图在其工具栏左侧的显示模式。前三个选项是阴影线框和阴影线框。",{"type":14,"tag":27,"props":446,"children":448},{"id":447},"meshcombine",[449],{"type":24,"value":450},"MeshCombine",{"type":14,"tag":85,"props":452,"children":453},{},[454],{"type":24,"value":455},"MeshCombine，就是合并网格。",{"type":14,"tag":85,"props":457,"children":458},{},[459],{"type":24,"value":460},"为什么好好的模型要进行网格的合并呢？",{"type":14,"tag":85,"props":462,"children":463},{},[464],{"type":24,"value":465},"如果从应用的角度来看的话，通过网格合并可以实现游戏中的换装，你可能会说，更换的服装例如帽子好好的，为什么要合并到人物模型上？",{"type":14,"tag":85,"props":467,"children":468},{},[469],{"type":24,"value":470},"问题在于，如果游戏中不是所有人物模型都是标准的人型呢？例如魔兽世界中，不同种族的头部模型大小是不一致的，很容易出现穿模。当然可以同一顶帽子制作适配于不同种族的模型，反正这个工作是美术做的（溜）。但是从整体出发的话，这样做无疑增加了游戏容量的大小，也会减慢游戏开发的进度，同时一定程度上影响代码的简洁性。",{"type":14,"tag":85,"props":472,"children":473},{},[474],{"type":24,"value":475},"但是通过网格合并，将帽子的网格合并到人物模型上，并且蒙皮至人物头部的骨骼上。这样以后，由于骨骼的大小、旋转、位移信息会影响顶点，因此一旦这个帽子戴到别的人物模型身上时，由于它们头部骨骼的大小不一样，那么帽子也会自动变大。也就达到了同一个模型，适用于多个人物模型的目的。\n（关于骨骼、蒙皮、骨骼蒙皮动画，可以参考下面的扩展资料）",{"type":14,"tag":85,"props":477,"children":478},{},[479],{"type":24,"value":480},"关于网格合并，同样Unity在 Mesh提供了相关的API：",{"type":14,"tag":285,"props":482,"children":484},{"code":483},"/*\n @parm combine:             要进行合并的CombineInstance实例\n @parm mergeSubMeshes:      是否将SubMesh进行合并，true为将SubMesh进行合并，false表示以SubMesh的形式存在\n @parm useMatrices:         是否应用定义在CombineInstance中的transform信息\n @hashLightmapData:         如果为true，则应用CombineInstance中的lightmapScaleOffset对mesh中的lightmapUV进行偏移\n*/\npublic void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes = true, bool useMatrices = true, bool hasLightmapData = false);\n",[485],{"type":14,"tag":212,"props":486,"children":487},{"__ignoreMap":7},[488],{"type":24,"value":483},{"type":14,"tag":85,"props":490,"children":491},{},[492],{"type":24,"value":493},"要使用它也很简单，如下面的代码所示：",{"type":14,"tag":285,"props":495,"children":497},{"code":496}," // 收集要合并的物体的所有Mesh信息\n        MeshFilter[] childMeshFilters = GetComponentsInChildren\u003CMeshFilter>();\n\n        CombineInstance[] destCombineInstances = new CombineInstance[childMeshFilters.Length];\n        for ( int i = 0; i \u003C childMeshFilters.Length; i++)\n        {\n            destCombineInstances[i] = new CombineInstance();\n            destCombineInstances[i].mesh = childMeshFilters[i].mesh;\n            destCombineInstances[i].transform = childMeshFilters[i].transform.localToWorldMatrix;\n\n            // 隐藏子物体，或者Destory\n            childMeshFilters[i].gameObject.SetActive(false);\n        }\n        Mesh destMesh = new Mesh();\n        // 进行合并\n        destMesh.CombineMeshes(destCombineInstances, true);\n        destMesh.RecalculateNormals();\n\n        // 将合并后的mesh赋给当前的MeshFilter\n        MeshFilter meshFilter = GetComponent\u003CMeshFilter>();\n        if (meshFilter == null) meshFilter = gameObject.AddComponent\u003CMeshFilter>();\n        meshFilter.mesh = destMesh;\n\n        MeshRenderer meshRenderer = GetComponent\u003CMeshRenderer>();\n        if( meshRenderer == null)\n        {\n            meshRenderer = gameObject.AddComponent\u003CMeshRenderer>();\n            // 设置MeshRenderer的material\n            Material material = new Material(Shader.Find(\"Standard\"));\n            meshRenderer.material = material;\n        }\n",[498],{"type":14,"tag":212,"props":499,"children":500},{"__ignoreMap":7},[501],{"type":24,"value":496},{"type":14,"tag":19,"props":503,"children":505},{"id":504},"mesh合并的优缺点",[506],{"type":24,"value":504},{"type":14,"tag":33,"props":508,"children":509},{},[510,515,520,525],{"type":14,"tag":37,"props":511,"children":512},{},[513],{"type":24,"value":514},"静态批处理后，对内存的增加是非常大的，动则就是几十兆的内存",{"type":14,"tag":37,"props":516,"children":517},{},[518],{"type":24,"value":519},"动态批处理，对于合批要求挺多的，同时可能存在，动态合批消耗过大，得不偿失",{"type":14,"tag":37,"props":521,"children":522},{},[523],{"type":24,"value":524},"自己在逻辑代码里面进行动态合批，对于mesh的readwrite属性是要求开启的，这无疑也增大了内存的占用，复杂的合批处理可能会消耗更多的cpu时间",{"type":14,"tag":37,"props":526,"children":527},{},[528,530,537,539,545,547,555],{"type":24,"value":529},"GPU Instancing可以一次渲染(render)相同网格的多个副本，仅使用少量",{"type":14,"tag":101,"props":531,"children":534},{"href":532,"rel":533},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/DrawCallBatching.html",[105],[535],{"type":24,"value":536},"DrawCalls",{"type":24,"value":538},"。在渲染诸如建筑、树木、草等在场景中重复出现的事物时，GPU Instancing很有用。将这些静态的物件如植被等全部从场景中剔除，而保存其位置、缩放、uv偏移、",{"type":14,"tag":540,"props":541,"children":542},"em",{},[543],{"type":24,"value":544},"lightmapindex",{"type":24,"value":546},"等相关信息，在需要渲染的时候，根据其保存的信息，通过",{"type":14,"tag":540,"props":548,"children":549},{},[550],{"type":14,"tag":41,"props":551,"children":552},{},[553],{"type":24,"value":554},"Instance",{"type":24,"value":556},"来渲染，这能够减少那些因为内存原因而不能合批的大批量相同物件的渲染时间",{"type":14,"tag":27,"props":558,"children":560},{"id":559},"相关链接",[561],{"type":24,"value":559},{"type":14,"tag":33,"props":563,"children":564},{},[565,574,583,592,601,610,619,627],{"type":14,"tag":37,"props":566,"children":567},{},[568],{"type":14,"tag":101,"props":569,"children":572},{"href":570,"rel":571},"https://zhuanlan.zhihu.com/p/96084686",[105],[573],{"type":24,"value":570},{"type":14,"tag":37,"props":575,"children":576},{},[577],{"type":14,"tag":101,"props":578,"children":581},{"href":579,"rel":580},"https://docs.unity.cn/cn/2018.4/Manual/class-Mesh.html",[105],[582],{"type":24,"value":579},{"type":14,"tag":37,"props":584,"children":585},{},[586],{"type":14,"tag":101,"props":587,"children":590},{"href":588,"rel":589},"https://docs.unity.cn/cn/2020.1/Manual/Shaders.html",[105],[591],{"type":24,"value":588},{"type":14,"tag":37,"props":593,"children":594},{},[595],{"type":14,"tag":101,"props":596,"children":599},{"href":597,"rel":598},"https://learnopengl-cn.github.io/",[105],[600],{"type":24,"value":597},{"type":14,"tag":37,"props":602,"children":603},{},[604],{"type":14,"tag":101,"props":605,"children":608},{"href":606,"rel":607},"https://blog.csdn.net/Arkish/article/details/98482430",[105],[609],{"type":24,"value":606},{"type":14,"tag":37,"props":611,"children":612},{},[613],{"type":14,"tag":101,"props":614,"children":617},{"href":615,"rel":616},"https://blog.csdn.net/tw_345/article/details/79771454",[105],[618],{"type":24,"value":615},{"type":14,"tag":37,"props":620,"children":621},{},[622],{"type":14,"tag":101,"props":623,"children":625},{"href":570,"rel":624},[105],[626],{"type":24,"value":570},{"type":14,"tag":37,"props":628,"children":629},{},[630],{"type":14,"tag":101,"props":631,"children":634},{"href":632,"rel":633},"https://blog.csdn.net/ecidevilin/category_9266800.html",[105],[635],{"type":24,"value":632},{"title":7,"searchDepth":637,"depth":637,"links":638},2,[639,640,641],{"id":21,"depth":637,"text":25},{"id":80,"depth":637,"text":83},{"id":504,"depth":637,"text":504},"markdown","content:unity:2020-07-03-unity-mesh.md","content","unity/2020-07-03-unity-mesh.md","md","2020-07-03",[649,659,786,835,887,900,1012],{"title":650,"_path":651,"children":652},"Art","/art",[653,656],{"title":654,"_path":655},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":657,"_path":658},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":660,"_path":661,"children":662},"Dotnet","/dotnet",[663,666,669,672,675,678,681,684,687,690,693,696,699,702,705,708,711,714,717,720,723,726,729,732,735,738,741,744,747,750,753,756,759,762,765,768,771,774,777,780,783],{"title":664,"_path":665},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":667,"_path":668},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":670,"_path":671},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":673,"_path":674},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":676,"_path":677},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":679,"_path":680},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":682,"_path":683},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":685,"_path":686},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":688,"_path":689},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":691,"_path":692},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":694,"_path":695},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":697,"_path":698},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":700,"_path":701},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":703,"_path":704},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":706,"_path":707},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":709,"_path":710},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":712,"_path":713},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":715,"_path":716},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":718,"_path":719},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":721,"_path":722},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":724,"_path":725},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":727,"_path":728},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":730,"_path":731},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":733,"_path":734},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":736,"_path":737},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":739,"_path":740},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":742,"_path":743},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":745,"_path":746},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":748,"_path":749},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":751,"_path":752},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":754,"_path":755},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":757,"_path":758},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":760,"_path":761},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":763,"_path":764},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":766,"_path":767},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":769,"_path":770},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":772,"_path":773},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":775,"_path":776},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":778,"_path":779},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":781,"_path":782},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":784,"_path":785},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":787,"_path":788,"children":789},"Game","/game",[790,793,796,799,802,805,808,811,814,817,820,823,826,829,832],{"title":791,"_path":792},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":794,"_path":795},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":797,"_path":798},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":800,"_path":801},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":803,"_path":804},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":806,"_path":807},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":809,"_path":810},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":812,"_path":813},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":815,"_path":816},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":818,"_path":819},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":821,"_path":822},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":824,"_path":825},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":827,"_path":828},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":830,"_path":831},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":833,"_path":834},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":836,"_path":837,"children":838},"Gyj","/gyj",[839,842,845,848,851,854,857,860,863,866,869,872,875,878,881,884],{"title":840,"_path":841},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":843,"_path":844},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":846,"_path":847},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":849,"_path":850},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":852,"_path":853},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":855,"_path":856},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":858,"_path":859},"玩法","/gyj/2022-08-22-wanfa",{"title":861,"_path":862},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":864,"_path":865},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":867,"_path":868},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":870,"_path":871},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":873,"_path":874},"门派内容相关","/gyj/2022-11-17-sect",{"title":876,"_path":877},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":879,"_path":880},"种植","/gyj/2022-12-01-zhongzhi",{"title":882,"_path":883},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":885,"_path":886},"跑商","/gyj/2023-11-01-paoshang",{"title":888,"_path":889,"children":890},"Js","/js",[891,894,897],{"title":892,"_path":893},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":895,"_path":896},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":898,"_path":899},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":901,"_path":902,"children":903},"Tool","/tool",[904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000,1003,1006,1009],{"title":905,"_path":906},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":908,"_path":909},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":911,"_path":912},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":914,"_path":915},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":917,"_path":918},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":920,"_path":921},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":923,"_path":924},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":926,"_path":927},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":929,"_path":930},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":932,"_path":933},"mac下brew 使用","/tool/2020-01-13-brew",{"title":935,"_path":936},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":938,"_path":939},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":941,"_path":942},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":944,"_path":945},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":947,"_path":948},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":950,"_path":951},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":953,"_path":954},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":956,"_path":957},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":959,"_path":960},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":962,"_path":963},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":965,"_path":966},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":968,"_path":969},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":971,"_path":972},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":974,"_path":975},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":977,"_path":978},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":980,"_path":981},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":983,"_path":984},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":986,"_path":987},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":989,"_path":990},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":992,"_path":993},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":995,"_path":996},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":998,"_path":999},"rider的使用","/tool/2022-08-02-rider-use",{"title":1001,"_path":1002},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1004,"_path":1005},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1007,"_path":1008},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1010,"_path":1011},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1013,"_path":1014,"children":1015},"Unity","/unity",[1016,1019,1022,1025,1028,1031,1034,1037,1040,1043,1046,1049,1052,1055,1058,1061,1064,1067,1070,1073,1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1104,1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140,1143,1146,1149,1152,1155,1158,1161,1164,1167,1170,1173,1176,1179,1182,1185,1188,1191,1194,1197,1200,1203,1206,1209,1212,1215,1218,1221,1224,1227],{"title":1017,"_path":1018},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1020,"_path":1021},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1023,"_path":1024},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1026,"_path":1027},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1029,"_path":1030},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1032,"_path":1033},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1035,"_path":1036},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1038,"_path":1039},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1041,"_path":1042},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1044,"_path":1045},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1047,"_path":1048},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1050,"_path":1051},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1053,"_path":1054},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1056,"_path":1057},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1059,"_path":1060},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1062,"_path":1063},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1065,"_path":1066},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1068,"_path":1069},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1071,"_path":1072},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1074,"_path":1075},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1077,"_path":1078},"技能系统","/unity/2020-02-15-skill-system",{"title":1080,"_path":1081},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1083,"_path":1084},"角色状态设计","/unity/2020-02-17-character-states",{"title":1086,"_path":1087},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1089,"_path":1090},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1092,"_path":1093},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1095,"_path":1096},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1098,"_path":1099},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1101,"_path":1102},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":8,"_path":4},{"title":1105,"_path":1106},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1108,"_path":1109},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1111,"_path":1112},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1114,"_path":1115},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1117,"_path":1118},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1120,"_path":1121},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1123,"_path":1124},"unity的addressables","/unity/2020-09-12-addressables",{"title":1126,"_path":1127},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1129,"_path":1130},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1132,"_path":1133},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1135,"_path":1136},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1138,"_path":1139},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1141,"_path":1142},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1144,"_path":1145},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1147,"_path":1148},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1150,"_path":1151},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1153,"_path":1154},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1156,"_path":1157},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1159,"_path":1160},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1162,"_path":1163},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1165,"_path":1166},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1168,"_path":1169},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1171,"_path":1172},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1174,"_path":1175},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1177,"_path":1178},"ability","/unity/2020-11-16-dotssample",{"title":1180,"_path":1181},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1183,"_path":1184},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1186,"_path":1187},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1189,"_path":1190},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1192,"_path":1193},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1195,"_path":1196},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1198,"_path":1199},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1201,"_path":1202},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1204,"_path":1205},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1207,"_path":1208},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1210,"_path":1211},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1213,"_path":1214},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1216,"_path":1217},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1219,"_path":1220},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1222,"_path":1223},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1225,"_path":1226},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1228,"_path":1229},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779040089]