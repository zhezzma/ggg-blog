[{"data":1,"prerenderedAt":2124},["Reactive",2],{"content-query-lijQ8csZRQ":3,"content-navigation-8C37fagqQL":1542},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1536,"_id":1537,"_source":1538,"_file":1539,"_extension":1540,"date":1541},"/unity/2020-01-12-collision-detection","unity",false,"","常见的2D碰撞检测","“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。",{"type":11,"children":12,"toc":1516},"root",[13,20,25,30,91,96,101,115,124,137,142,147,154,159,164,172,183,188,193,211,216,224,230,235,245,250,258,268,273,277,285,289,297,302,307,312,320,325,351,375,399,404,424,443,461,466,474,478,482,490,496,501,506,514,519,527,532,537,545,613,618,623,628,633,638,643,651,655,659,664,680,685,693,697,701,709,713,721,725,730,735,756,761,787,814,826,834,839,843,851,855,863,869,874,895,904,909,914,934,938,942,950,954,962,966,974,980,993,1001,1019,1027,1032,1040,1045,1063,1068,1087,1096,1103,1111,1116,1124,1134,1139,1144,1149,1160,1185,1190,1198,1223,1231,1239,1244,1249,1257,1262,1267,1272,1276,1284,1288,1296,1300,1308,1313,1366,1372,1377,1385,1390,1395,1401,1406,1411,1417,1422,1427,1432,1437,1442,1495],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":15,"props":21,"children":22},{},[23],{"type":19,"value":24},"好了，不废话。直入主题——碰撞检测。",{"type":14,"tag":15,"props":26,"children":27},{},[28],{"type":19,"value":29},"在 2D 环境下，常见的碰撞检测方法如下：",{"type":14,"tag":31,"props":32,"children":33},"ul",{},[34,63,68,73],{"type":14,"tag":35,"props":36,"children":37},"li",{},[38,40],{"type":19,"value":39},"外接图形判别法",{"type":14,"tag":31,"props":41,"children":42},{},[43,48,53,58],{"type":14,"tag":35,"props":44,"children":45},{},[46],{"type":19,"value":47},"轴对称包围盒（Axis-Aligned Bounding Box），即无旋转矩形。",{"type":14,"tag":35,"props":49,"children":50},{},[51],{"type":19,"value":52},"圆形碰撞",{"type":14,"tag":35,"props":54,"children":55},{},[56],{"type":19,"value":57},"圆形与矩形（无旋转）",{"type":14,"tag":35,"props":59,"children":60},{},[61],{"type":19,"value":62},"圆形与旋转矩形（以矩形中心点为旋转轴）",{"type":14,"tag":35,"props":64,"children":65},{},[66],{"type":19,"value":67},"光线投射法",{"type":14,"tag":35,"props":69,"children":70},{},[71],{"type":19,"value":72},"分离轴定理",{"type":14,"tag":35,"props":74,"children":75},{},[76,78],{"type":19,"value":77},"其他",{"type":14,"tag":31,"props":79,"children":80},{},[81,86],{"type":14,"tag":35,"props":82,"children":83},{},[84],{"type":19,"value":85},"地图格子划分",{"type":14,"tag":35,"props":87,"children":88},{},[89],{"type":19,"value":90},"像素检测",{"type":14,"tag":15,"props":92,"children":93},{},[94],{"type":19,"value":95},"下文将由易到难的顺序介绍上述各种碰撞检测方法：外接图形判别法 > 其他 > 光线投射法 > 分离轴定理。",{"type":14,"tag":15,"props":97,"children":98},{},[99],{"type":19,"value":100},"另外，有一些场景只要我们约定好限定条件，也能实现我们想要的碰撞，如下面的碰壁反弹：",{"type":14,"tag":15,"props":102,"children":103},{},[104,106,113],{"type":19,"value":105},"当球碰到边框就反弹(如",{"type":14,"tag":107,"props":108,"children":110},"code",{"className":109},[],[111],{"type":19,"value":112},"x/y轴方向速度取反",{"type":19,"value":114},")。",{"type":14,"tag":116,"props":117,"children":119},"pre",{"code":118},"if(ball.left \u003C 0 || ball.right  > rect.width)  ball.velocityX = -ball.velocityX\nif(ball.top  \u003C 0 || ball.bottom > rect.height) ball.velocityY = -ball.velocityY\n",[120],{"type":14,"tag":107,"props":121,"children":122},{"__ignoreMap":7},[123],{"type":19,"value":118},{"type":14,"tag":15,"props":125,"children":126},{},[127,129,135],{"type":19,"value":128},"再例如当一个人走到 ",{"type":14,"tag":107,"props":130,"children":132},{"className":131},[],[133],{"type":19,"value":134},"100px",{"type":19,"value":136}," 位置时不进行跳跃，就会碰到石头等等。",{"type":14,"tag":15,"props":138,"children":139},{},[140],{"type":19,"value":141},"因此，某些场景只需通过设定到适当的参数即可实现碰撞检测。",{"type":14,"tag":143,"props":144,"children":145},"h2",{"id":39},[146],{"type":19,"value":39},{"type":14,"tag":148,"props":149,"children":151},"h3",{"id":150},"轴对称包围盒axis-aligned-bounding-box",[152],{"type":19,"value":153},"轴对称包围盒（Axis-Aligned Bounding Box）",{"type":14,"tag":15,"props":155,"children":156},{},[157],{"type":19,"value":158},"概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。",{"type":14,"tag":15,"props":160,"children":161},{},[162],{"type":19,"value":163},"算法：",{"type":14,"tag":116,"props":165,"children":167},{"code":166},"rect1.x \u003C rect2.x + rect2.width &&\nrect1.x + rect1.width > rect2.x &&\nrect1.y \u003C rect2.y + rect2.height &&\nrect1.height + rect1.y > rect2.y\n",[168],{"type":14,"tag":107,"props":169,"children":170},{"__ignoreMap":7},[171],{"type":19,"value":166},{"type":14,"tag":15,"props":173,"children":174},{},[175,177],{"type":19,"value":176},"两矩形间碰撞的各种情况：\n",{"type":14,"tag":178,"props":179,"children":182},"img",{"alt":180,"src":181},"轴对称包围盒","/images/2020-01-12-Collision-detection/rectangle_collision.png",[],{"type":14,"tag":15,"props":184,"children":185},{},[186],{"type":19,"value":187},"在线运行示例（先点击运行示例以获取焦点，下同）：",{"type":14,"tag":15,"props":189,"children":190},{},[191],{"type":19,"value":192},"缺点：",{"type":14,"tag":31,"props":194,"children":195},{},[196,201,206],{"type":14,"tag":35,"props":197,"children":198},{},[199],{"type":19,"value":200},"相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。",{"type":14,"tag":35,"props":202,"children":203},{},[204],{"type":19,"value":205},"对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。",{"type":14,"tag":35,"props":207,"children":208},{},[209],{"type":19,"value":210},"物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。",{"type":14,"tag":15,"props":212,"children":213},{},[214],{"type":19,"value":215},"适用案例：",{"type":14,"tag":31,"props":217,"children":218},{},[219],{"type":14,"tag":35,"props":220,"children":221},{},[222],{"type":19,"value":223},"（类）矩形物体间的碰撞。",{"type":14,"tag":148,"props":225,"children":227},{"id":226},"圆形碰撞circle-collision",[228],{"type":19,"value":229},"圆形碰撞（Circle Collision）",{"type":14,"tag":15,"props":231,"children":232},{},[233],{"type":19,"value":234},"概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。",{"type":14,"tag":15,"props":236,"children":237},{},[238,240],{"type":19,"value":239},"两点之间的距离由以下公式可得：\n",{"type":14,"tag":178,"props":241,"children":244},{"alt":242,"src":243},"两点之间距离","/images/2020-01-12-Collision-detection/two_point_distance.png",[],{"type":14,"tag":15,"props":246,"children":247},{},[248],{"type":19,"value":249},"判断两圆心距离是否小于两半径之和：",{"type":14,"tag":116,"props":251,"children":253},{"code":252},"Math.sqrt(Math.pow(circleA.x - circleB.x, 2) +\n          Math.pow(circleA.y - circleB.y, 2)) \n    \u003C circleA.radius + circleB.radius\n",[254],{"type":14,"tag":107,"props":255,"children":256},{"__ignoreMap":7},[257],{"type":19,"value":252},{"type":14,"tag":15,"props":259,"children":260},{},[261,263],{"type":19,"value":262},"图例：\n",{"type":14,"tag":178,"props":264,"children":267},{"alt":265,"src":266},"圆形间的碰撞检测","/images/2020-01-12-Collision-detection/circle_collision.png",[],{"type":14,"tag":15,"props":269,"children":270},{},[271],{"type":19,"value":272},"在线运行示例：",{"type":14,"tag":15,"props":274,"children":275},{},[276],{"type":19,"value":192},{"type":14,"tag":31,"props":278,"children":279},{},[280],{"type":14,"tag":35,"props":281,"children":282},{},[283],{"type":19,"value":284},"与『轴对称包围盒』类似",{"type":14,"tag":15,"props":286,"children":287},{},[288],{"type":19,"value":215},{"type":14,"tag":31,"props":290,"children":291},{},[292],{"type":14,"tag":35,"props":293,"children":294},{},[295],{"type":19,"value":296},"（类）圆形的物体，如各种球类碰撞。",{"type":14,"tag":148,"props":298,"children":300},{"id":299},"圆形与矩形无旋转",[301],{"type":19,"value":57},{"type":14,"tag":15,"props":303,"children":304},{},[305],{"type":19,"value":306},"概念：通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。",{"type":14,"tag":15,"props":308,"children":309},{},[310],{"type":19,"value":311},"那如何找出矩形上离圆心最近的点呢？下面我们从 x 轴、y 轴两个方向分别进行寻找。为了方便描述，我们先约定以下变量：",{"type":14,"tag":116,"props":313,"children":315},{"code":314},"矩形上离圆心最近的点为变量：closestPoint = {x, y};\n矩形 rect = {x, y, w, h}; // 左上角与宽高\n圆形 circle = {x, y, r}; // 圆心与半径\n",[316],{"type":14,"tag":107,"props":317,"children":318},{"__ignoreMap":7},[319],{"type":19,"value":314},{"type":14,"tag":15,"props":321,"children":322},{},[323],{"type":19,"value":324},"首先是 x 轴：",{"type":14,"tag":15,"props":326,"children":327},{},[328,330,336,338,344,346],{"type":19,"value":329},"如果圆心在矩形的左侧（",{"type":14,"tag":107,"props":331,"children":333},{"className":332},[],[334],{"type":19,"value":335},"if(circle.x \u003C rect.x)",{"type":19,"value":337},"），那么 ",{"type":14,"tag":107,"props":339,"children":341},{"className":340},[],[342],{"type":19,"value":343},"closestPoint.x = rect.x",{"type":19,"value":345},"。\n",{"type":14,"tag":178,"props":347,"children":350},{"alt":348,"src":349},"圆心在矩形的左侧","/images/2020-01-12-Collision-detection/cicle_rectangle_left.png",[],{"type":14,"tag":15,"props":352,"children":353},{},[354,356,362,363,369,370],{"type":19,"value":355},"如果圆心在矩形的右侧（",{"type":14,"tag":107,"props":357,"children":359},{"className":358},[],[360],{"type":19,"value":361},"else if(circle.x > rect.x + rect.w)",{"type":19,"value":337},{"type":14,"tag":107,"props":364,"children":366},{"className":365},[],[367],{"type":19,"value":368},"closestPoint.x = rect.x + rect.w",{"type":19,"value":345},{"type":14,"tag":178,"props":371,"children":374},{"alt":372,"src":373},"圆心在矩形的右侧","/images/2020-01-12-Collision-detection/circle_rectangle_right.png",[],{"type":14,"tag":15,"props":376,"children":377},{},[378,380,386,387,393,394],{"type":19,"value":379},"如果圆心在矩形的正上下方（",{"type":14,"tag":107,"props":381,"children":383},{"className":382},[],[384],{"type":19,"value":385},"else",{"type":19,"value":337},{"type":14,"tag":107,"props":388,"children":390},{"className":389},[],[391],{"type":19,"value":392},"closestPoint.x = circle.x",{"type":19,"value":345},{"type":14,"tag":178,"props":395,"children":398},{"alt":396,"src":397},"圆心在矩形的正上下方","/images/2020-01-12-Collision-detection/circle_rectangle_center.png",[],{"type":14,"tag":15,"props":400,"children":401},{},[402],{"type":19,"value":403},"同理，对于 y 轴（此处不列举图例）：",{"type":14,"tag":15,"props":405,"children":406},{},[407,409,415,416,422],{"type":19,"value":408},"如果圆心在矩形的上方（",{"type":14,"tag":107,"props":410,"children":412},{"className":411},[],[413],{"type":19,"value":414},"if(circle.y \u003C rect.y)",{"type":19,"value":337},{"type":14,"tag":107,"props":417,"children":419},{"className":418},[],[420],{"type":19,"value":421},"closestPoint.y = rect.y",{"type":19,"value":423},"。",{"type":14,"tag":15,"props":425,"children":426},{},[427,429,435,436,442],{"type":19,"value":428},"如果圆心在矩形的下方（",{"type":14,"tag":107,"props":430,"children":432},{"className":431},[],[433],{"type":19,"value":434},"else if(circle.y > rect.y + rect.h)",{"type":19,"value":337},{"type":14,"tag":107,"props":437,"children":439},{"className":438},[],[440],{"type":19,"value":441},"closestPoint.y = rect.y + rect.h",{"type":19,"value":423},{"type":14,"tag":15,"props":444,"children":445},{},[446,448,453,454,460],{"type":19,"value":447},"如果圆心在矩形的正左右两侧（",{"type":14,"tag":107,"props":449,"children":451},{"className":450},[],[452],{"type":19,"value":385},{"type":19,"value":337},{"type":14,"tag":107,"props":455,"children":457},{"className":456},[],[458],{"type":19,"value":459},"closestPoint.y = circle.y",{"type":19,"value":423},{"type":14,"tag":15,"props":462,"children":463},{},[464],{"type":19,"value":465},"因此，通过上述方法即可找出矩形上离圆心最近的点了，然后通过『两点之间的距离公式』得出『最近点』与『圆心』的距离，最后将其与圆的半径相比，即可判断是否发生碰撞。",{"type":14,"tag":116,"props":467,"children":469},{"code":468},"var distance = Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))\n\nif(distance \u003C circle.r) return true // 发生碰撞\nelse return false // 未发生碰撞\n",[470],{"type":14,"tag":107,"props":471,"children":472},{"__ignoreMap":7},[473],{"type":19,"value":468},{"type":14,"tag":15,"props":475,"children":476},{},[477],{"type":19,"value":272},{"type":14,"tag":15,"props":479,"children":480},{},[481],{"type":19,"value":192},{"type":14,"tag":31,"props":483,"children":484},{},[485],{"type":14,"tag":35,"props":486,"children":487},{},[488],{"type":19,"value":489},"矩形需是轴对称的，即不能旋转。",{"type":14,"tag":148,"props":491,"children":493},{"id":492},"圆形与旋转矩形以矩形中心为旋转轴",[494],{"type":19,"value":495},"圆形与旋转矩形（以矩形中心为旋转轴）",{"type":14,"tag":15,"props":497,"children":498},{},[499],{"type":19,"value":500},"概念：即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。",{"type":14,"tag":15,"props":502,"children":503},{},[504],{"type":19,"value":505},"对于旋转后的矩形，要找出其离圆心最近的点，视乎有些困难。其实，我们可以将我们思想的范围进行扩大：将矩形的旋转看作是整个画布的旋转。那么我们将画布（即 Canvas）反向旋转『矩形旋转的角度』后，所看到的结果就是上一个方法“圆形与矩形（无旋转）”的情形。因此，我们只需求出画布旋转后的圆心位置，即可使用『圆形与矩形（无旋转）』的判断方法了。",{"type":14,"tag":15,"props":507,"children":508},{},[509],{"type":14,"tag":178,"props":510,"children":513},{"alt":511,"src":512},"绕矩形中心旋转后的画布","/images/2020-01-12-Collision-detection/circle_and_rotated_rect.png",[],{"type":14,"tag":15,"props":515,"children":516},{},[517],{"type":19,"value":518},"先给出可直接套用的公式，从而得出旋转后的圆心坐标：",{"type":14,"tag":116,"props":520,"children":522},{"code":521},"x’ = cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerX\ny’ = sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY\n",[523],{"type":14,"tag":107,"props":524,"children":525},{"__ignoreMap":7},[526],{"type":19,"value":521},{"type":14,"tag":15,"props":528,"children":529},{},[530],{"type":19,"value":531},"下面给出该公式的推导过程：",{"type":14,"tag":15,"props":533,"children":534},{},[535],{"type":19,"value":536},"根据下图，计算某个点绕另外一个点旋转一定角度后的坐标。我们设 A(x,y) 绕 B(a,b) 旋转 β 度后的位置为 C(c,d)。",{"type":14,"tag":15,"props":538,"children":539},{},[540],{"type":14,"tag":178,"props":541,"children":544},{"alt":542,"src":543},"某个点绕另外一个点旋转一定角度后的坐标的公式推导","/images/2020-01-12-Collision-detection/circle_and_rotated_rect_formula.png",[],{"type":14,"tag":546,"props":547,"children":548},"ol",{},[549,554,572,577,595],{"type":14,"tag":35,"props":550,"children":551},{},[552],{"type":19,"value":553},"设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)",{"type":14,"tag":35,"props":555,"children":556},{},[557,559],{"type":19,"value":558},"由于 |AB| 与 |CB| 相等（即长度），且",{"type":14,"tag":546,"props":560,"children":561},{},[562,567],{"type":14,"tag":35,"props":563,"children":564},{},[565],{"type":19,"value":566},"|AB| = y/sin(δ) = x / cos(δ)",{"type":14,"tag":35,"props":568,"children":569},{},[570],{"type":19,"value":571},"|CB| = d/sin(δ + β) = c / cos(δ + β)",{"type":14,"tag":35,"props":573,"children":574},{},[575],{"type":19,"value":576},"半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)",{"type":14,"tag":35,"props":578,"children":579},{},[580,582],{"type":19,"value":581},"由以下三角函数两角和差公式：",{"type":14,"tag":31,"props":583,"children":584},{},[585,590],{"type":14,"tag":35,"props":586,"children":587},{},[588],{"type":19,"value":589},"sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)",{"type":14,"tag":35,"props":591,"children":592},{},[593],{"type":19,"value":594},"cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)",{"type":14,"tag":35,"props":596,"children":597},{},[598,600],{"type":19,"value":599},"可得出旋转后的坐标：",{"type":14,"tag":31,"props":601,"children":602},{},[603,608],{"type":14,"tag":35,"props":604,"children":605},{},[606],{"type":19,"value":607},"c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)",{"type":14,"tag":35,"props":609,"children":610},{},[611],{"type":19,"value":612},"d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)",{"type":14,"tag":15,"props":614,"children":615},{},[616],{"type":19,"value":617},"由上述公式推导后可得：旋转后的坐标 (c,d) 只与旋转前的坐标 (x,y) 及旋转的角度 β 有关。",{"type":14,"tag":15,"props":619,"children":620},{},[621],{"type":19,"value":622},"当然，(c,d) 是旋转一定角度后『相对于旋转点（轴）的坐标』。因此，前面提到的『可直接套用的公式』中加上了矩形的中心点的坐标值。",{"type":14,"tag":15,"props":624,"children":625},{},[626],{"type":19,"value":627},"从图中也可以得出以下结论：A 点旋转后的 C 点总是在圆周（半径为 |AB|）上运动，利用这点可让物体绕旋转点（轴）做圆周运动。",{"type":14,"tag":15,"props":629,"children":630},{},[631],{"type":19,"value":632},"得到旋转后的圆心坐标值后，即可使用『圆形与矩形（无旋转）』方法进行碰撞检测了。",{"type":14,"tag":15,"props":634,"children":635},{},[636],{"type":19,"value":637},"在线运行案例：",{"type":14,"tag":15,"props":639,"children":640},{},[641],{"type":19,"value":642},"优点：",{"type":14,"tag":31,"props":644,"children":645},{},[646],{"type":14,"tag":35,"props":647,"children":648},{},[649],{"type":19,"value":650},"相对于圆形与矩形（未旋转）的方法，适用范围更广。",{"type":14,"tag":143,"props":652,"children":653},{"id":77},[654],{"type":19,"value":77},{"type":14,"tag":148,"props":656,"children":657},{"id":85},[658],{"type":19,"value":85},{"type":14,"tag":15,"props":660,"children":661},{},[662],{"type":19,"value":663},"概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。",{"type":14,"tag":15,"props":665,"children":666},{},[667,673,675],{"type":14,"tag":107,"props":668,"children":670},{"className":669},[],[671],{"type":19,"value":672},"蓝色X",{"type":19,"value":674}," 为障碍物：\n",{"type":14,"tag":178,"props":676,"children":679},{"alt":677,"src":678},"地图格子碰撞检测","/images/2020-01-12-Collision-detection/map_cell_collision.png",[],{"type":14,"tag":15,"props":681,"children":682},{},[683],{"type":19,"value":684},"实现方法：",{"type":14,"tag":116,"props":686,"children":688},{"code":687},"// 通过特定标识指定（非）可行区域\nmap = [\n  [0, 0, 1, 1, 1, 0, 0, 0, 0],\n  [0, 1, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 1, 1, 1, 1, 1, 1, 0, 0]\n],\n// 设定角色的初始位置\nplayer = {left: 2, top: 2}\n\n// 移动前（后）判断角色的下一步的动作（如不能前行）\n...\n",[689],{"type":14,"tag":107,"props":690,"children":691},{"__ignoreMap":7},[692],{"type":19,"value":687},{"type":14,"tag":15,"props":694,"children":695},{},[696],{"type":19,"value":272},{"type":14,"tag":15,"props":698,"children":699},{},[700],{"type":19,"value":192},{"type":14,"tag":31,"props":702,"children":703},{},[704],{"type":14,"tag":35,"props":705,"children":706},{},[707],{"type":19,"value":708},"适用场景局限。",{"type":14,"tag":15,"props":710,"children":711},{},[712],{"type":19,"value":215},{"type":14,"tag":31,"props":714,"children":715},{},[716],{"type":14,"tag":35,"props":717,"children":718},{},[719],{"type":19,"value":720},"推箱子、踩地雷等",{"type":14,"tag":148,"props":722,"children":723},{"id":90},[724],{"type":19,"value":90},{"type":14,"tag":15,"props":726,"children":727},{},[728],{"type":19,"value":729},"概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。",{"type":14,"tag":15,"props":731,"children":732},{},[733],{"type":19,"value":734},"实现方法有多种，下面列举在 Canvas 中的两种实现方式：",{"type":14,"tag":546,"props":736,"children":737},{},[738,743],{"type":14,"tag":35,"props":739,"children":740},{},[741],{"type":19,"value":742},"如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。",{"type":14,"tag":35,"props":744,"children":745},{},[746,748,754],{"type":19,"value":747},"利用 canvas 的 ",{"type":14,"tag":107,"props":749,"children":751},{"className":750},[],[752],{"type":19,"value":753},"globalCompositeOperation = 'destination-in'",{"type":19,"value":755}," 属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。",{"type":14,"tag":15,"props":757,"children":758},{},[759],{"type":19,"value":760},"注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。",{"type":14,"tag":762,"props":763,"children":764},"blockquote",{},[765],{"type":14,"tag":15,"props":766,"children":767},{},[768,770,776,778],{"type":19,"value":769},"offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是",{"type":14,"tag":771,"props":772,"children":773},"strong",{},[774],{"type":19,"value":775},"内存",{"type":19,"value":777},"。渲染到内存比渲染到屏幕更快。—— ",{"type":14,"tag":779,"props":780,"children":784},"a",{"href":781,"rel":782},"http://devbutze.blogspot.com/2014/02/html5-canvas-offscreen-rendering.html",[783],"nofollow",[785],{"type":19,"value":786},"Offscreen Rendering",{"type":14,"tag":15,"props":788,"children":789},{},[790,792,798,800,806,808,813],{"type":19,"value":791},"当然，我们这里并不是利用 ",{"type":14,"tag":107,"props":793,"children":795},{"className":794},[],[796],{"type":19,"value":797},"offscreen render",{"type":19,"value":799}," 的性能优势，而是利用 ",{"type":14,"tag":107,"props":801,"children":803},{"className":802},[],[804],{"type":19,"value":805},"offscreen canvas",{"type":19,"value":807}," 保存独立物体的像素。换句话说：",{"type":14,"tag":771,"props":809,"children":810},{},[811],{"type":19,"value":812},"onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行",{"type":19,"value":423},{"type":14,"tag":15,"props":815,"children":816},{},[817,819,824],{"type":19,"value":818},"另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者",{"type":14,"tag":771,"props":820,"children":821},{},[822],{"type":19,"value":823},"相交区域",{"type":19,"value":825},"，然后只对该区域内的像素进行检测即可。",{"type":14,"tag":15,"props":827,"children":828},{},[829,830],{"type":19,"value":262},{"type":14,"tag":178,"props":831,"children":833},{"alt":90,"src":832},"/images/2020-01-12-Collision-detection/pixel_collision.png",[],{"type":14,"tag":15,"props":835,"children":836},{},[837],{"type":19,"value":838},"下面示例展示了第一种实现方式：",{"type":14,"tag":15,"props":840,"children":841},{},[842],{"type":19,"value":192},{"type":14,"tag":31,"props":844,"children":845},{},[846],{"type":14,"tag":35,"props":847,"children":848},{},[849],{"type":19,"value":850},"因为需要检查每一像素来判定是否碰撞，性能要求比较高。",{"type":14,"tag":15,"props":852,"children":853},{},[854],{"type":19,"value":215},{"type":14,"tag":31,"props":856,"children":857},{},[858],{"type":14,"tag":35,"props":859,"children":860},{},[861],{"type":19,"value":862},"需要以像素级别检测物体是否碰撞。",{"type":14,"tag":143,"props":864,"children":866},{"id":865},"光线投射法ray-casting",[867],{"type":19,"value":868},"光线投射法（Ray Casting）",{"type":14,"tag":15,"props":870,"children":871},{},[872],{"type":19,"value":873},"概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。",{"type":14,"tag":15,"props":875,"children":876},{},[877,879,885,887,893],{"type":19,"value":878},"对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线(",{"type":14,"tag":107,"props":880,"children":882},{"className":881},[],[883],{"type":19,"value":884},"#1",{"type":19,"value":886},")，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线(",{"type":14,"tag":107,"props":888,"children":890},{"className":889},[],[891],{"type":19,"value":892},"#2",{"type":19,"value":894},")，根据两条线的交点位置来判定是否发生碰撞。",{"type":14,"tag":15,"props":896,"children":897},{},[898,900],{"type":19,"value":899},"抛球进桶图例：\n",{"type":14,"tag":178,"props":901,"children":903},{"alt":67,"src":902},"/images/2020-01-12-Collision-detection/ray_casting_collision.png",[],{"type":14,"tag":15,"props":905,"children":906},{},[907],{"type":19,"value":908},"在小球飞行的过程中，需要不断计算两直线的交点。",{"type":14,"tag":15,"props":910,"children":911},{},[912],{"type":19,"value":913},"当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中：",{"type":14,"tag":31,"props":915,"children":916},{},[917,922],{"type":14,"tag":35,"props":918,"children":919},{},[920],{"type":19,"value":921},"两直线交点在桶口的左右边沿间",{"type":14,"tag":35,"props":923,"children":924},{},[925,927,932],{"type":19,"value":926},"小球位于第二条线（",{"type":14,"tag":107,"props":928,"children":930},{"className":929},[],[931],{"type":19,"value":892},{"type":19,"value":933},"）下方",{"type":14,"tag":15,"props":935,"children":936},{},[937],{"type":19,"value":272},{"type":14,"tag":15,"props":939,"children":940},{},[941],{"type":19,"value":642},{"type":14,"tag":31,"props":943,"children":944},{},[945],{"type":14,"tag":35,"props":946,"children":947},{},[948],{"type":19,"value":949},"适合运动速度快的物体",{"type":14,"tag":15,"props":951,"children":952},{},[953],{"type":19,"value":192},{"type":14,"tag":31,"props":955,"children":956},{},[957],{"type":14,"tag":35,"props":958,"children":959},{},[960],{"type":19,"value":961},"适用范围相对局限。",{"type":14,"tag":15,"props":963,"children":964},{},[965],{"type":19,"value":215},{"type":14,"tag":31,"props":967,"children":968},{},[969],{"type":14,"tag":35,"props":970,"children":971},{},[972],{"type":19,"value":973},"抛球运动进桶。",{"type":14,"tag":143,"props":975,"children":977},{"id":976},"分离轴定理separating-axis-theorem",[978],{"type":19,"value":979},"分离轴定理（Separating Axis Theorem）",{"type":14,"tag":15,"props":981,"children":982},{},[983,985,991],{"type":19,"value":984},"概念：通过判断任意两个 ",{"type":14,"tag":107,"props":986,"children":988},{"className":987},[],[989],{"type":19,"value":990},"凸多边形",{"type":19,"value":992}," 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。",{"type":14,"tag":15,"props":994,"children":995},{},[996,997],{"type":19,"value":262},{"type":14,"tag":178,"props":998,"children":1000},{"alt":72,"src":999},"/images/2020-01-12-Collision-detection/sat_base.png",[],{"type":14,"tag":15,"props":1002,"children":1003},{},[1004,1006,1012,1014],{"type":19,"value":1005},"在程序中，遍历所有角度是不现实的。那如何确定 ",{"type":14,"tag":107,"props":1007,"children":1009},{"className":1008},[],[1010],{"type":19,"value":1011},"投影轴",{"type":19,"value":1013}," 呢？其实",{"type":14,"tag":771,"props":1015,"children":1016},{},[1017],{"type":19,"value":1018},"投影轴的数量与多边形的边数相等即可。",{"type":14,"tag":15,"props":1020,"children":1021},{},[1022],{"type":14,"tag":178,"props":1023,"children":1026},{"alt":1024,"src":1025},"https://misc.aotu.io/JChehe/2017-02-13-2d-collision-detection/sat_projection_two.png","/images/2020-01-12-Collision-detection/sat_projection_two.png",[],{"type":14,"tag":15,"props":1028,"children":1029},{},[1030],{"type":19,"value":1031},"以较高抽象层次判断两个凸多边形是否碰撞：",{"type":14,"tag":116,"props":1033,"children":1035},{"code":1034},"function polygonsCollide(polygon1, polygon2) {\n    var axes, projection1, projection2\n    \n    // 根据多边形获取所有投影轴\n    axes = polygon1.getAxes()\n    axes.push(polygon2.getAxes())\n    \n    // 遍历所有投影轴，获取多边形在每条投影轴上的投影\n    for(each axis in axes) {\n        projection1 = polygon1.project(axis)\n        projection2 = polygon2.project(axis)\n        \n        // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n        if(!projection1.overlaps(projection2))\n            return false\n    }\n    return true\n}\n",[1036],{"type":14,"tag":107,"props":1037,"children":1038},{"__ignoreMap":7},[1039],{"type":19,"value":1034},{"type":14,"tag":15,"props":1041,"children":1042},{},[1043],{"type":19,"value":1044},"上述代码有几个需要解决的地方：",{"type":14,"tag":31,"props":1046,"children":1047},{},[1048,1053,1058],{"type":14,"tag":35,"props":1049,"children":1050},{},[1051],{"type":19,"value":1052},"如何确定多边形的各个投影轴",{"type":14,"tag":35,"props":1054,"children":1055},{},[1056],{"type":19,"value":1057},"如何将多边形投射到某条投影轴上",{"type":14,"tag":35,"props":1059,"children":1060},{},[1061],{"type":19,"value":1062},"如何检测两段投影是否发生重叠",{"type":14,"tag":1064,"props":1065,"children":1066},"h4",{"id":1011},[1067],{"type":19,"value":1011},{"type":14,"tag":15,"props":1069,"children":1070},{},[1071,1073,1078,1080,1085],{"type":19,"value":1072},"如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为",{"type":14,"tag":771,"props":1074,"children":1075},{},[1076],{"type":19,"value":1077},"边缘向量",{"type":19,"value":1079},"。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“",{"type":14,"tag":771,"props":1081,"children":1082},{},[1083],{"type":19,"value":1084},"边缘法向量",{"type":19,"value":1086},"”。",{"type":14,"tag":15,"props":1088,"children":1089},{},[1090,1094],{"type":14,"tag":771,"props":1091,"children":1092},{},[1093],{"type":19,"value":1011},{"type":19,"value":1095},"平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。",{"type":14,"tag":15,"props":1097,"children":1098},{},[1099],{"type":14,"tag":178,"props":1100,"children":1102},{"alt":1011,"src":1101},"/images/2020-01-12-Collision-detection/sat_projection_one.png",[],{"type":14,"tag":116,"props":1104,"children":1106},{"code":1105},"// 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。\nvar v1 = new Vector(p1.x, p1.y)\n    v2 = new Vector(p2.x, p2.y)\n\n// 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。\n// 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。\n// 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 = 0 可得：(-B,A) 或 (B,-A)。\n    axis = v1.edge(v2).normal()\n",[1107],{"type":14,"tag":107,"props":1108,"children":1109},{"__ignoreMap":7},[1110],{"type":19,"value":1105},{"type":14,"tag":15,"props":1112,"children":1113},{},[1114],{"type":19,"value":1115},"以下是向量对象的部分实现，具体可看源码。",{"type":14,"tag":116,"props":1117,"children":1119},{"code":1118},"var Vector = function(x, y) {\n    this.x = x\n    this.y = y\n}\n\nVector.prototype = {\n    // 获取向量大小（即向量的模），即两点间距离\n    getMagnitude: function() {\n        return Math.sqrt(Math.pow(this.x, 2),\n                         Math.pow(this.y, 2))\n    },\n    // 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n    // 后续将会用其计算出投影的长度\n    dotProduct: function(vector) {\n        return this.x * vector.x + this.y + vector.y\n    },\n    // 向量相减 得到边\n    subtarct: function(vector) {\n        var v = new Vector()\n        v.x = this.x - vector.x\n        v.y = this.y - vector.y\n        return v\n    },\n    edge: function(vector) {\n        return this.substract(vector)\n    },\n    // 获取当前向量的法向量（垂直）\n    perpendicular: function() {\n        var v = new Vector()\n        v.x = this.y\n        v.y = 0 - this.x\n        return v\n    },\n    // 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量\n    normalize: function() {\n        var v = new Vector(0, 0)\n            m = this.getMagnitude()\n        if(m !== 0) {\n            v.x = this.x / m\n            v.y = this.y /m\n        }\n        return v\n    },\n    // 获取边缘法向量的单位向量，即投影轴\n    normal: function() {\n        var p = this.perpendicular()\n        return p .normalize()\n    }\n}\n",[1120],{"type":14,"tag":107,"props":1121,"children":1122},{"__ignoreMap":7},[1123],{"type":19,"value":1118},{"type":14,"tag":15,"props":1125,"children":1126},{},[1127,1132],{"type":14,"tag":178,"props":1128,"children":1131},{"alt":1129,"src":1130},"此处输入图片的描述","/images/2020-01-12-Collision-detection/vector_subtract.png",[],{"type":19,"value":1133},"\n向量相减",{"type":14,"tag":15,"props":1135,"children":1136},{},[1137],{"type":19,"value":1138},"更多关于向量的知识可通过其它渠道学习。",{"type":14,"tag":1064,"props":1140,"children":1142},{"id":1141},"投影",[1143],{"type":19,"value":1141},{"type":14,"tag":15,"props":1145,"children":1146},{},[1147],{"type":19,"value":1148},"投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。",{"type":14,"tag":15,"props":1150,"children":1151},{},[1152,1154],{"type":19,"value":1153},"判断两多边形的投影是否重合：",{"type":14,"tag":107,"props":1155,"children":1157},{"className":1156},[],[1158],{"type":19,"value":1159},"projection1.max > projection2.min && project2.max > projection.min",{"type":14,"tag":15,"props":1161,"children":1162},{},[1163,1167,1169,1175,1177,1183],{"type":14,"tag":178,"props":1164,"children":1166},{"alt":1129,"src":1165},"/images/2020-01-12-Collision-detection/sat_project_length.png",[],{"type":19,"value":1168},"\n为了易于理解，示例图将坐标轴",{"type":14,"tag":107,"props":1170,"children":1172},{"className":1171},[],[1173],{"type":19,"value":1174},"原点(0,0)",{"type":19,"value":1176},"放置于三角形",{"type":14,"tag":107,"props":1178,"children":1180},{"className":1179},[],[1181],{"type":19,"value":1182},"边1",{"type":19,"value":1184},"投影轴的适当位置。",{"type":14,"tag":15,"props":1186,"children":1187},{},[1188],{"type":19,"value":1189},"由上述可得投影对象：",{"type":14,"tag":116,"props":1191,"children":1193},{"code":1192},"// 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置\nvar Projection = function (min, max) {\n    this.min\n    this.max\n}\n\nprojection.prototype = {\n    // 判断两投影是否重叠\n    overlaps: function(projection) {\n        return this.max > projection.min && projection.max > this.min\n    }\n}\n",[1194],{"type":14,"tag":107,"props":1195,"children":1196},{"__ignoreMap":7},[1197],{"type":19,"value":1192},{"type":14,"tag":15,"props":1199,"children":1200},{},[1201,1203,1207,1209,1215,1217],{"type":19,"value":1202},"如何得到向量在投影轴上的长度？\n向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n由于",{"type":14,"tag":771,"props":1204,"children":1205},{},[1206],{"type":19,"value":1011},{"type":19,"value":1208},"是单位向量（长度为",{"type":14,"tag":107,"props":1210,"children":1212},{"className":1211},[],[1213],{"type":19,"value":1214},"1",{"type":19,"value":1216},"），投影的长度为 ",{"type":14,"tag":107,"props":1218,"children":1220},{"className":1219},[],[1221],{"type":19,"value":1222},"x1 * x2 + y1 * y2",{"type":14,"tag":15,"props":1224,"children":1225},{},[1226],{"type":14,"tag":178,"props":1227,"children":1230},{"alt":1228,"src":1229},"点积","/images/2020-01-12-Collision-detection/dot_product.png",[],{"type":14,"tag":116,"props":1232,"children":1234},{"code":1233},"// 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。\nfunction project = function (axis) {\n    var scalars = [], v = new Vector()\n    \n    this.points.forEach(function (point) {\n        v.x = point.x\n        v.y = point.y\n        scalars.push(v.dotProduct(axis))\n    })\n    return new Projection(Math.min.apply(Math, scalars),\n                          Math.max,apply(Math, scalars))\n}\n",[1235],{"type":14,"tag":107,"props":1236,"children":1237},{"__ignoreMap":7},[1238],{"type":19,"value":1233},{"type":14,"tag":1064,"props":1240,"children":1242},{"id":1241},"圆形与多边形之间的碰撞检测",[1243],{"type":19,"value":1241},{"type":14,"tag":15,"props":1245,"children":1246},{},[1247],{"type":19,"value":1248},"由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示：",{"type":14,"tag":15,"props":1250,"children":1251},{},[1252],{"type":14,"tag":178,"props":1253,"children":1256},{"alt":1254,"src":1255},"圆形与多边形的投影轴","/images/2020-01-12-Collision-detection/sat_projection_circle.png",[],{"type":14,"tag":15,"props":1258,"children":1259},{},[1260],{"type":19,"value":1261},"因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。",{"type":14,"tag":15,"props":1263,"children":1264},{},[1265],{"type":19,"value":1266},"而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。",{"type":14,"tag":15,"props":1268,"children":1269},{},[1270],{"type":19,"value":1271},"分离轴定理的整体代码实现，可查看以下案例：",{"type":14,"tag":15,"props":1273,"children":1274},{},[1275],{"type":19,"value":642},{"type":14,"tag":31,"props":1277,"children":1278},{},[1279],{"type":14,"tag":35,"props":1280,"children":1281},{},[1282],{"type":19,"value":1283},"精确",{"type":14,"tag":15,"props":1285,"children":1286},{},[1287],{"type":19,"value":192},{"type":14,"tag":31,"props":1289,"children":1290},{},[1291],{"type":14,"tag":35,"props":1292,"children":1293},{},[1294],{"type":19,"value":1295},"不适用于凹多边形",{"type":14,"tag":15,"props":1297,"children":1298},{},[1299],{"type":19,"value":215},{"type":14,"tag":31,"props":1301,"children":1302},{},[1303],{"type":14,"tag":35,"props":1304,"children":1305},{},[1306],{"type":19,"value":1307},"任意凸多边形和圆形。",{"type":14,"tag":15,"props":1309,"children":1310},{},[1311],{"type":19,"value":1312},"更多关于分离轴定理的资料：",{"type":14,"tag":31,"props":1314,"children":1315},{},[1316,1326,1336,1346,1356],{"type":14,"tag":35,"props":1317,"children":1318},{},[1319],{"type":14,"tag":779,"props":1320,"children":1323},{"href":1321,"rel":1322},"http://www.sevenson.com.au/actionscript/sat/",[783],[1324],{"type":19,"value":1325},"Separating Axis Theorem (SAT) explanation",{"type":14,"tag":35,"props":1327,"children":1328},{},[1329],{"type":14,"tag":779,"props":1330,"children":1333},{"href":1331,"rel":1332},"http://www.metanetsoftware.com/technique/tutorialA.html",[783],[1334],{"type":19,"value":1335},"Collision detection and response",{"type":14,"tag":35,"props":1337,"children":1338},{},[1339],{"type":14,"tag":779,"props":1340,"children":1343},{"href":1341,"rel":1342},"http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169",[783],[1344],{"type":19,"value":1345},"Collision detection Using the Separating Axis Theorem",{"type":14,"tag":35,"props":1347,"children":1348},{},[1349],{"type":14,"tag":779,"props":1350,"children":1353},{"href":1351,"rel":1352},"http://www.codezealot.org/archives/55",[783],[1354],{"type":19,"value":1355},"SAT (Separating Axis Theorem)",{"type":14,"tag":35,"props":1357,"children":1358},{},[1359],{"type":14,"tag":779,"props":1360,"children":1363},{"href":1361,"rel":1362},"http://rocketmandevelopment.com/blog/separation-of-axis-theorem-for-collision-detection/",[783],[1364],{"type":19,"value":1365},"Separation of Axis Theorem (SAT) for Collision Detection",{"type":14,"tag":1064,"props":1367,"children":1369},{"id":1368},"延伸最小平移向量mit",[1370],{"type":19,"value":1371},"延伸：最小平移向量（MIT）",{"type":14,"tag":15,"props":1373,"children":1374},{},[1375],{"type":19,"value":1376},"通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。",{"type":14,"tag":15,"props":1378,"children":1379},{},[1380],{"type":14,"tag":178,"props":1381,"children":1384},{"alt":1382,"src":1383},"最小平移向量","/images/2020-01-12-Collision-detection/mit.png",[],{"type":14,"tag":148,"props":1386,"children":1388},{"id":1387},"碰撞性能优化",[1389],{"type":19,"value":1387},{"type":14,"tag":15,"props":1391,"children":1392},{},[1393],{"type":19,"value":1394},"若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。",{"type":14,"tag":1064,"props":1396,"children":1398},{"id":1397},"粗略阶段broad-phase",[1399],{"type":19,"value":1400},"粗略阶段（Broad Phase）",{"type":14,"tag":15,"props":1402,"children":1403},{},[1404],{"type":19,"value":1405},"Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供这些信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。",{"type":14,"tag":15,"props":1407,"children":1408},{},[1409],{"type":19,"value":1410},"读者若感兴趣，可以自行查阅相关信息。",{"type":14,"tag":1064,"props":1412,"children":1414},{"id":1413},"精细阶段narrow-phase",[1415],{"type":19,"value":1416},"精细阶段（Narrow Phase）",{"type":14,"tag":15,"props":1418,"children":1419},{},[1420],{"type":19,"value":1421},"当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。",{"type":14,"tag":148,"props":1423,"children":1425},{"id":1424},"最后",[1426],{"type":19,"value":1424},{"type":14,"tag":15,"props":1428,"children":1429},{},[1430],{"type":19,"value":1431},"碰撞检测有多种，选择合适最重要。",{"type":14,"tag":15,"props":1433,"children":1434},{},[1435],{"type":19,"value":1436},"完！",{"type":14,"tag":148,"props":1438,"children":1440},{"id":1439},"参考资料",[1441],{"type":19,"value":1439},{"type":14,"tag":31,"props":1443,"children":1444},{},[1445,1455,1465,1475,1485],{"type":14,"tag":35,"props":1446,"children":1447},{},[1448],{"type":14,"tag":779,"props":1449,"children":1452},{"href":1450,"rel":1451},"https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection",[783],[1453],{"type":19,"value":1454},"MDN：2D collision detection",{"type":14,"tag":35,"props":1456,"children":1457},{},[1458],{"type":14,"tag":779,"props":1459,"children":1462},{"href":1460,"rel":1461},"https://item.jd.com/11231175.html?dist=jd",[783],[1463],{"type":19,"value":1464},"《HTML5 Canvas 核心技术：图形、动画与游戏开发》",{"type":14,"tag":35,"props":1466,"children":1467},{},[1468],{"type":14,"tag":779,"props":1469,"children":1472},{"href":1470,"rel":1471},"http://lazyfoo.net/SDL_tutorials/lesson19/index.php",[783],[1473],{"type":19,"value":1474},"Circular Collision Detection",{"type":14,"tag":35,"props":1476,"children":1477},{},[1478],{"type":14,"tag":779,"props":1479,"children":1482},{"href":1480,"rel":1481},"http://www.migapro.com/circle-and-rotated-rectangle-collision-detection/",[783],[1483],{"type":19,"value":1484},"Circle and Rotated Rectangle Collision Detection",{"type":14,"tag":35,"props":1486,"children":1487},{},[1488],{"type":14,"tag":779,"props":1489,"children":1492},{"href":1490,"rel":1491},"http://www.cnblogs.com/ywxgod/archive/2010/08/06/1793609.html",[783],[1493],{"type":19,"value":1494},"推导坐标旋转公式",{"type":14,"tag":15,"props":1496,"children":1497},{},[1498,1500,1507,1509],{"type":19,"value":1499},"感谢您的阅读，本文由 ",{"type":14,"tag":779,"props":1501,"children":1504},{"href":1502,"rel":1503},"https://aotu.io/",[783],[1505],{"type":19,"value":1506},"凹凸实验室",{"type":19,"value":1508}," 版权所有。如若转载，请注明出处：凹凸实验室（",{"type":14,"tag":779,"props":1510,"children":1513},{"href":1511,"rel":1512},"https://aotu.io/notes/2017/02/16/2d-collision-detection/%EF%BC%89",[783],[1514],{"type":19,"value":1515},"https://aotu.io/notes/2017/02/16/2d-collision-detection/）",{"title":7,"searchDepth":1517,"depth":1517,"links":1518},2,[1519,1526,1530,1531],{"id":39,"depth":1517,"text":39,"children":1520},[1521,1523,1524,1525],{"id":150,"depth":1522,"text":153},3,{"id":226,"depth":1522,"text":229},{"id":299,"depth":1522,"text":57},{"id":492,"depth":1522,"text":495},{"id":77,"depth":1517,"text":77,"children":1527},[1528,1529],{"id":85,"depth":1522,"text":85},{"id":90,"depth":1522,"text":90},{"id":865,"depth":1517,"text":868},{"id":976,"depth":1517,"text":979,"children":1532},[1533,1534,1535],{"id":1387,"depth":1522,"text":1387},{"id":1424,"depth":1522,"text":1424},{"id":1439,"depth":1522,"text":1439},"markdown","content:unity:2020-01-12-Collision-detection.md","content","unity/2020-01-12-Collision-detection.md","md","2020-01-12",[1543,1553,1680,1729,1781,1794,1906],{"title":1544,"_path":1545,"children":1546},"Art","/art",[1547,1550],{"title":1548,"_path":1549},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1551,"_path":1552},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1554,"_path":1555,"children":1556},"Dotnet","/dotnet",[1557,1560,1563,1566,1569,1572,1575,1578,1581,1584,1587,1590,1593,1596,1599,1602,1605,1608,1611,1614,1617,1620,1623,1626,1629,1632,1635,1638,1641,1644,1647,1650,1653,1656,1659,1662,1665,1668,1671,1674,1677],{"title":1558,"_path":1559},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1561,"_path":1562},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1564,"_path":1565},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1567,"_path":1568},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1570,"_path":1571},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":1573,"_path":1574},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1576,"_path":1577},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1579,"_path":1580},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1582,"_path":1583},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1585,"_path":1586},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1588,"_path":1589},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1591,"_path":1592},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1594,"_path":1595},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1597,"_path":1598},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1600,"_path":1601},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1603,"_path":1604},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1606,"_path":1607},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1609,"_path":1610},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1612,"_path":1613},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1615,"_path":1616},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1618,"_path":1619},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1621,"_path":1622},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1624,"_path":1625},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1627,"_path":1628},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1630,"_path":1631},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1633,"_path":1634},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1636,"_path":1637},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1639,"_path":1640},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1642,"_path":1643},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1645,"_path":1646},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1648,"_path":1649},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1651,"_path":1652},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1654,"_path":1655},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1657,"_path":1658},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1660,"_path":1661},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1663,"_path":1664},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1666,"_path":1667},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1669,"_path":1670},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1672,"_path":1673},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1675,"_path":1676},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1678,"_path":1679},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1681,"_path":1682,"children":1683},"Game","/game",[1684,1687,1690,1693,1696,1699,1702,1705,1708,1711,1714,1717,1720,1723,1726],{"title":1685,"_path":1686},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1688,"_path":1689},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1691,"_path":1692},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1694,"_path":1695},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1697,"_path":1698},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1700,"_path":1701},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1703,"_path":1704},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1706,"_path":1707},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1709,"_path":1710},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1712,"_path":1713},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1715,"_path":1716},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1718,"_path":1719},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1721,"_path":1722},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1724,"_path":1725},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1727,"_path":1728},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1730,"_path":1731,"children":1732},"Gyj","/gyj",[1733,1736,1739,1742,1745,1748,1751,1754,1757,1760,1763,1766,1769,1772,1775,1778],{"title":1734,"_path":1735},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1737,"_path":1738},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1740,"_path":1741},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1743,"_path":1744},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1746,"_path":1747},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1749,"_path":1750},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1752,"_path":1753},"玩法","/gyj/2022-08-22-wanfa",{"title":1755,"_path":1756},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1758,"_path":1759},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1761,"_path":1762},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1764,"_path":1765},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1767,"_path":1768},"门派内容相关","/gyj/2022-11-17-sect",{"title":1770,"_path":1771},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1773,"_path":1774},"种植","/gyj/2022-12-01-zhongzhi",{"title":1776,"_path":1777},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1779,"_path":1780},"跑商","/gyj/2023-11-01-paoshang",{"title":1782,"_path":1783,"children":1784},"Js","/js",[1785,1788,1791],{"title":1786,"_path":1787},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1789,"_path":1790},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1792,"_path":1793},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1795,"_path":1796,"children":1797},"Tool","/tool",[1798,1801,1804,1807,1810,1813,1816,1819,1822,1825,1828,1831,1834,1837,1840,1843,1846,1849,1852,1855,1858,1861,1864,1867,1870,1873,1876,1879,1882,1885,1888,1891,1894,1897,1900,1903],{"title":1799,"_path":1800},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1802,"_path":1803},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1805,"_path":1806},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1808,"_path":1809},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1811,"_path":1812},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1814,"_path":1815},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1817,"_path":1818},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1820,"_path":1821},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1823,"_path":1824},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1826,"_path":1827},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1829,"_path":1830},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1832,"_path":1833},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1835,"_path":1836},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1838,"_path":1839},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1841,"_path":1842},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1844,"_path":1845},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1847,"_path":1848},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1850,"_path":1851},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1853,"_path":1854},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1856,"_path":1857},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1859,"_path":1860},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1862,"_path":1863},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1865,"_path":1866},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1868,"_path":1869},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1871,"_path":1872},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1874,"_path":1875},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1877,"_path":1878},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1880,"_path":1881},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1883,"_path":1884},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1886,"_path":1887},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1889,"_path":1890},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1892,"_path":1893},"rider的使用","/tool/2022-08-02-rider-use",{"title":1895,"_path":1896},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1898,"_path":1899},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1901,"_path":1902},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1904,"_path":1905},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1907,"_path":1908,"children":1909},"Unity","/unity",[1910,1913,1916,1919,1922,1925,1928,1931,1934,1937,1940,1943,1946,1949,1952,1955,1958,1961,1964,1965,1968,1971,1974,1977,1980,1983,1986,1989,1992,1995,1998,2001,2004,2007,2010,2013,2016,2019,2022,2025,2028,2031,2034,2037,2040,2043,2046,2049,2052,2055,2058,2061,2064,2067,2070,2073,2076,2079,2082,2085,2088,2091,2094,2097,2100,2103,2106,2109,2112,2115,2118,2121],{"title":1911,"_path":1912},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1914,"_path":1915},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1917,"_path":1918},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1920,"_path":1921},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1923,"_path":1924},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1926,"_path":1927},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1929,"_path":1930},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1932,"_path":1933},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1935,"_path":1936},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1938,"_path":1939},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1941,"_path":1942},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1944,"_path":1945},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1947,"_path":1948},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1950,"_path":1951},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1953,"_path":1954},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1956,"_path":1957},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1959,"_path":1960},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1962,"_path":1963},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":8,"_path":4},{"title":1966,"_path":1967},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1969,"_path":1970},"技能系统","/unity/2020-02-15-skill-system",{"title":1972,"_path":1973},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1975,"_path":1976},"角色状态设计","/unity/2020-02-17-character-states",{"title":1978,"_path":1979},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1981,"_path":1982},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1984,"_path":1985},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1987,"_path":1988},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1990,"_path":1991},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1993,"_path":1994},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1996,"_path":1997},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1999,"_path":2000},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":2002,"_path":2003},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":2005,"_path":2006},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":2008,"_path":2009},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":2011,"_path":2012},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":2014,"_path":2015},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":2017,"_path":2018},"unity的addressables","/unity/2020-09-12-addressables",{"title":2020,"_path":2021},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":2023,"_path":2024},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":2026,"_path":2027},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":2029,"_path":2030},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":2032,"_path":2033},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":2035,"_path":2036},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":2038,"_path":2039},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":2041,"_path":2042},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":2044,"_path":2045},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":2047,"_path":2048},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":2050,"_path":2051},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":2053,"_path":2054},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":2056,"_path":2057},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":2059,"_path":2060},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":2062,"_path":2063},"简单保存工具","/unity/2020-11-13-simple-save",{"title":2065,"_path":2066},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":2068,"_path":2069},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":2071,"_path":2072},"ability","/unity/2020-11-16-dotssample",{"title":2074,"_path":2075},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":2077,"_path":2078},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":2080,"_path":2081},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":2083,"_path":2084},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":2086,"_path":2087},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":2089,"_path":2090},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":2092,"_path":2093},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":2095,"_path":2096},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":2098,"_path":2099},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":2101,"_path":2102},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":2104,"_path":2105},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":2107,"_path":2108},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":2110,"_path":2111},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":2113,"_path":2114},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":2116,"_path":2117},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":2119,"_path":2120},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":2122,"_path":2123},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041232]