[{"data":1,"prerenderedAt":1143},["Reactive",2],{"content-query-mKwaONu4iX":3,"content-navigation-8C37fagqQL":561},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":555,"_id":556,"_source":557,"_file":558,"_extension":559,"date":560},"/unity/2020-01-01-unity-entitas","unity",false,"","一篇文章搞定Entitas","Entitas執行流程​      也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。\n​      在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。\n  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），",{"type":11,"children":12,"toc":548},"root",[13,22,31,36,42,47,52,57,62,72,77,95,101,106,116,121,130,135,141,146,155,160,169,174,179,185,228,236,241,300,305,310,318,326,331,337,366,371,379,389,395,408,413,418,424,429,437,442,447,455,460,467,488,499,510,516],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"entitas執行流程",[19],{"type":20,"value":21},"text","Entitas執行流程",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":14,"tag":27,"props":28,"children":30},"img",{"alt":7,"src":29},"/images/2020-01-01-unity-entitas/1362861-20190531225036556-1995562595%5B1%5D.png",[],{"type":14,"tag":23,"props":32,"children":33},{},[34],{"type":20,"value":35},"​      也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。\n​      在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。\n  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），只有第一次会遍历所有的Entity生成这个Group，之后再获取该类型Entity的复杂度就只有O(1)。\n  但是也有一定的隐患，当Group和Collector比较少时，这不是一个高消耗操作，但是Group、Collector很多，且在每一帧对Entity进行频繁修改的时候。这可能会成为一个高消耗操作。",{"type":14,"tag":15,"props":37,"children":39},{"id":38},"tips",[40],{"type":20,"value":41},"Tips",{"type":14,"tag":23,"props":43,"children":44},{},[45],{"type":20,"value":46},"1. 在销毁一个Entity时，会移除Entity身上所有的Component，然后再进行回收。在移除Component时可能会通过Group把这个移除事件发送到监听Remove行为的Collector中，Collector会持有这个被销毁的Entity。所以在filter、或execute时不能直接依赖Collector的收集条件，还需要对Entity的Component做独立的判断。\n  其实任何时候filter都需要对Entity的Component做判断，因为Collector收集的Entity很可能在其他地方被改变。",{"type":14,"tag":23,"props":48,"children":49},{},[50],{"type":20,"value":51},"2. Entity不应该被ECS系统外的模块持有，因为系统外对Entity的持有不会被自动引用计数（可以自己添加）。可能会导致一个Entity被销毁然后又从池子中重新取出来， 外部模块对这个Entity的引用没有改变，但已经可能不是自己持有的那个Entity了。\n  需要避免在外界持有Entity或通过持有uuid间接从context中持有这个Entity。",{"type":14,"tag":23,"props":53,"children":54},{},[55],{"type":20,"value":56},"3. 在replaceComponent时，发送了Remove、Add、Update三个事件，而不是只发送了Update事件。",{"type":14,"tag":23,"props":58,"children":59},{},[60],{"type":20,"value":61},"4. 在代码生成时，对单Componet的Matcher进行了缓存，如游戏中常用的Postion和Name等Component，但是对组合Component的Matcher没有进行缓存。所在在两个不同的ReactiveSystem中使用Matcher相同的Collector时，如：",{"type":14,"tag":63,"props":64,"children":66},"pre",{"code":65},"//1,2代表Postion和Name的Index\n//在使用代码生成时会生成类似Matcher.Position、Matcher.Name的静态函数，方便开发者使用\ncontext.CreateCollector(Matcher.AllOf(1,2));\n",[67],{"type":14,"tag":68,"props":69,"children":70},"code",{"__ignoreMap":7},[71],{"type":20,"value":65},{"type":14,"tag":23,"props":73,"children":74},{},[75],{"type":20,"value":76},"这样会生成两个Matcher相同的Group实例。\n如果在意这一点的话可以自己对Matcher进行缓存。",{"type":14,"tag":78,"props":79,"children":80},"ol",{},[81],{"type":14,"tag":82,"props":83,"children":84},"li",{},[85,87,93],{"type":20,"value":86},"在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用",{"type":14,"tag":68,"props":88,"children":90},{"className":89},[],[91],{"type":20,"value":92},"不可修改",{"type":20,"value":94},"（immutable）component的感觉。",{"type":14,"tag":15,"props":96,"children":98},{"id":97},"group",[99],{"type":20,"value":100},"Group",{"type":14,"tag":23,"props":102,"children":103},{},[104],{"type":20,"value":105},"在Context中可以对Entity进行快速过滤，它能不断的更新以保持当前的组中的Entity是最新的。假设Context有上千个Entities，但只有两个Entities拥有PositionComponent，那只要向Context询问特定的组就能立刻获取到所有符合的Entity。",{"type":14,"tag":63,"props":107,"children":111},{"code":108,"language":20,"meta":7,"className":109},"gameContext.GetGroup(GameMatcher.Position).GetEntities();\n",[110],"language-text",[112],{"type":14,"tag":68,"props":113,"children":114},{"__ignoreMap":7},[115],{"type":20,"value":108},{"type":14,"tag":23,"props":117,"children":118},{},[119],{"type":20,"value":120},"Group和Group所过滤到的entities会被缓存下来，所以即使多次调用GetGroup方法，也是非常高效的。",{"type":14,"tag":63,"props":122,"children":125},{"code":123,"language":20,"meta":7,"className":124},"gameContext.GetEntities(GameMatcher.Movable)\n",[110],[126],{"type":14,"tag":68,"props":127,"children":128},{"__ignoreMap":7},[129],{"type":20,"value":123},{"type":14,"tag":23,"props":131,"children":132},{},[133],{"type":20,"value":134},"内部也是通过Groups的方式来实现。Groups 拥有以下事件OnEntityAdded, OnEntityRemoved 和 OnEntityUpdated来直接响应Entity的变化。",{"type":14,"tag":15,"props":136,"children":138},{"id":137},"collector",[139],{"type":20,"value":140},"Collector",{"type":14,"tag":23,"props":142,"children":143},{},[144],{"type":20,"value":145},"Collector是Group的一个观察者类,Collector提供了一种简单的方法来处理Group中Entity变化的反应。假设你需要收集和处理所有entities，他们的PositionComponent被添加或替换：",{"type":14,"tag":63,"props":147,"children":150},{"code":148,"language":20,"meta":7,"className":149},"var group = gameContext.GetGroup(GameMatcher.Position);\nvar collector = group.CreateCollector(GroupEvent.Added);\n",[110],[151],{"type":14,"tag":68,"props":152,"children":153},{"__ignoreMap":7},[154],{"type":20,"value":148},{"type":14,"tag":23,"props":156,"children":157},{},[158],{"type":20,"value":159},"之后：",{"type":14,"tag":63,"props":161,"children":164},{"code":162,"language":20,"meta":7,"className":163},"foreach (var e in collector.collectedEntities) {\n    // do something with all the entities\n    // that have been collected to this point of time\n}\ncollector.ClearCollectedEntities();\n",[110],[165],{"type":14,"tag":68,"props":166,"children":167},{"__ignoreMap":7},[168],{"type":20,"value":162},{"type":14,"tag":23,"props":170,"children":171},{},[172],{"type":20,"value":173},"我们还可以注销这个Collector",{"type":14,"tag":23,"props":175,"children":176},{},[177],{"type":20,"value":178},"collector.Deactivate();",{"type":14,"tag":15,"props":180,"children":182},{"id":181},"reactivesystem",[183],{"type":20,"value":184},"ReactiveSystem",{"type":14,"tag":186,"props":187,"children":188},"ul",{},[189,202,223],{"type":14,"tag":82,"props":190,"children":191},{},[192,194,200],{"type":20,"value":193},"响应式的系统就像执行式系统一样，会每隔一段时间或是在每一个",{"type":14,"tag":68,"props":195,"children":197},{"className":196},[],[198],{"type":20,"value":199},"Update",{"type":20,"value":201},"中被触发",{"type":14,"tag":82,"props":203,"children":204},{},[205,207,213,215,221],{"type":20,"value":206},"响应式系统的",{"type":14,"tag":68,"props":208,"children":210},{"className":209},[],[211],{"type":20,"value":212},"Execute(List entities)",{"type":20,"value":214}," 方法只会在收集器距离上一次",{"type":14,"tag":68,"props":216,"children":218},{"className":217},[],[219],{"type":20,"value":220},"Execute",{"type":20,"value":222},"收集到新的Entity才会被执行。",{"type":14,"tag":82,"props":224,"children":225},{},[226],{"type":20,"value":227},"gettrigger使用Collector根据event建立一个group的entity列表",{"type":14,"tag":63,"props":229,"children":231},{"code":230},"        protected override ICollector\u003CGameEntity> GetTrigger(IContext\u003CGameEntity> context) {\n            return context.CreateCollector(GameMatcher.Destroyed);\n        }\n\n        protected override bool Filter(GameEntity entity) {\n            return entity.isDestroyed;\n        }\n       \n        public void Execute() {\n            if (_collector.count != 0) {\n                foreach (var e in _collector.collectedEntities) {\n                    if (Filter(e)) {\n                        e.Retain(this);\n                        _buffer.Add(e);\n                    }\n                }\n\n                _collector.ClearCollectedEntities();\n\n                if (_buffer.Count != 0) {\n                    try {\n                        Execute(_buffer);\n                    } finally {\n                        for (int i = 0; i \u003C _buffer.Count; i++) {\n                            _buffer[i].Release(this);\n                        }\n                        _buffer.Clear();\n                    }\n                }\n            }\n        }\n",[232],{"type":14,"tag":68,"props":233,"children":234},{"__ignoreMap":7},[235],{"type":20,"value":230},{"type":14,"tag":23,"props":237,"children":238},{},[239],{"type":20,"value":240},"如上代码:",{"type":14,"tag":23,"props":242,"children":243},{},[244,246,252,254,260,262,268,270,276,278,283,285,291,293,298],{"type":20,"value":245},"我们在",{"type":14,"tag":68,"props":247,"children":249},{"className":248},[],[250],{"type":20,"value":251},"GetTrigger",{"type":20,"value":253},"方法中返回了一个监测了",{"type":14,"tag":68,"props":255,"children":257},{"className":256},[],[258],{"type":20,"value":259},"Destroyed",{"type":20,"value":261},"Entity的Collector。在",{"type":14,"tag":68,"props":263,"children":265},{"className":264},[],[266],{"type":20,"value":267},"context.CreateCollector(GameMatcher.Destroyed)",{"type":20,"value":269}," 中，我们不需要指定当一个Entity何时应当被收集的事件，因为默认就是会收集在",{"type":14,"tag":68,"props":271,"children":273},{"className":272},[],[274],{"type":20,"value":275},"Added",{"type":20,"value":277},"情况下被通知到的Entity。所以当我们增加一个",{"type":14,"tag":68,"props":279,"children":281},{"className":280},[],[282],{"type":20,"value":259},{"type":20,"value":284},"组件到一个Entity上时，这个Entity会",{"type":14,"tag":68,"props":286,"children":288},{"className":287},[],[289],{"type":20,"value":290},"添加",{"type":20,"value":292},"到",{"type":14,"tag":68,"props":294,"children":296},{"className":295},[],[297],{"type":20,"value":259},{"type":20,"value":299},"的group里面，并因此被对应的collector收集到对应的reactive system里面。",{"type":14,"tag":23,"props":301,"children":302},{},[303],{"type":20,"value":304},"如下面的代码,AddDebugMessage就会被DebugMessageSystem收集了...",{"type":14,"tag":23,"props":306,"children":307},{},[308],{"type":20,"value":309},"执行RemoveDebugMessage()但是DebugMessageSystem仍然收集着呢,但是该实体已经没有了组件DebugMessage.所以需要过滤下Filter(GameEntity entity)否则收集的数据会报错",{"type":14,"tag":63,"props":311,"children":313},{"code":312},"using Entitas;\n\npublic class HelloWorldSystem : IInitializeSystem\n{\n    // always handy to keep a reference to the context \n    // we're going to be interacting with it\n    readonly GameContext _context;\n\n    public HelloWorldSystem(Contexts contexts)\n    {\n        // get the context from the constructor\n        _context = contexts.game;\n    }\n\n    public void Initialize()\n    {\n        // create an entity and give it a DebugMessageComponent with\n        // the text \"Hello World!\" as its data\n\n        var e = _context.CreateEntity();\n        e.AddDebugMessage(\"Hello World!\");\n        e.RemoveDebugMessage(); \n    }\n}\n\n",[314],{"type":14,"tag":68,"props":315,"children":316},{"__ignoreMap":7},[317],{"type":20,"value":312},{"type":14,"tag":63,"props":319,"children":321},{"code":320},"using System.Collections.Generic;\nusing Entitas;\nusing UnityEngine;\n\npublic class DebugMessageSystem : ReactiveSystem\u003CGameEntity>\n{\n    public DebugMessageSystem(Contexts contexts) : base(contexts.game)\n    {\n    }\n\n    protected override ICollector\u003CGameEntity> GetTrigger(IContext\u003CGameEntity> context)\n    {\n        // we only care about entities with DebugMessageComponent \n        return context.CreateCollector(GameMatcher.DebugMessage);\n    }\n\n    protected override bool Filter(GameEntity entity)\n    {\n        // good practice to perform a final check in case \n        // the entity has been altered in a different system.\n        return entity.hasDebugMessage;\n    }\n\n    protected override void Execute(List\u003CGameEntity> entities)\n    {\n        // this is the list of entities that meet our conditions\n        foreach (var e in entities)\n        {\n            // we can safely access their DebugMessage component\n            // then grab the string data and print it\n            Debug.Log(e.debugMessage.message);\n        }\n    }\n}\n",[322],{"type":14,"tag":68,"props":323,"children":324},{"__ignoreMap":7},[325],{"type":20,"value":320},{"type":14,"tag":15,"props":327,"children":329},{"id":328},"事件",[330],{"type":20,"value":328},{"type":14,"tag":332,"props":333,"children":335},"h3",{"id":334},"关于replace都干了什么",[336],{"type":20,"value":334},{"type":14,"tag":23,"props":338,"children":339},{},[340,342,348,350,356,358,364],{"type":20,"value":341},"Group具有事件 ",{"type":14,"tag":68,"props":343,"children":345},{"className":344},[],[346],{"type":20,"value":347},"OnEntityAdded",{"type":20,"value":349},", ",{"type":14,"tag":68,"props":351,"children":353},{"className":352},[],[354],{"type":20,"value":355},"OnEntityRemoved",{"type":20,"value":357}," and ",{"type":14,"tag":68,"props":359,"children":361},{"className":360},[],[362],{"type":20,"value":363},"OnEntityUpdated",{"type":20,"value":365}," 可以直接对组的更改做出反应。",{"type":14,"tag":23,"props":367,"children":368},{},[369],{"type":20,"value":370},"看源码",{"type":14,"tag":63,"props":372,"children":374},{"code":373}," public void UpdateEntity(TEntity entity, int index, IComponent previousComponent, IComponent newComponent) {\n            if (_entities.Contains(entity)) {\n                if (OnEntityRemoved != null) {\n                    OnEntityRemoved(this, entity, index, previousComponent);\n                }\n                if (OnEntityAdded != null) {\n                    OnEntityAdded(this, entity, index, newComponent);\n                }\n                if (OnEntityUpdated != null) {\n                    OnEntityUpdated(\n                        this, entity, index, previousComponent, newComponent\n                    );\n                }\n            }\n        }\n",[375],{"type":14,"tag":68,"props":376,"children":377},{"__ignoreMap":7},[378],{"type":20,"value":373},{"type":14,"tag":23,"props":380,"children":381},{},[382,383,388],{"type":20,"value":86},{"type":14,"tag":68,"props":384,"children":386},{"className":385},[],[387],{"type":20,"value":92},{"type":20,"value":94},{"type":14,"tag":332,"props":390,"children":392},{"id":391},"group和collect还有event应该在什么地方添加",[393],{"type":20,"value":394},"group和collect,还有event应该在什么地方添加.",{"type":14,"tag":186,"props":396,"children":397},{},[398,403],{"type":14,"tag":82,"props":399,"children":400},{},[401],{"type":20,"value":402},"在系统中的构造函数中",{"type":14,"tag":82,"props":404,"children":405},{},[406],{"type":20,"value":407},"在entitan的system初始化Initialize前",{"type":14,"tag":23,"props":409,"children":410},{},[411],{"type":20,"value":412},"因为初始化系统大多会有add,remove等动作.为了保持你的group,还有collect,还有event能够监听到.",{"type":14,"tag":23,"props":414,"children":415},{},[416],{"type":20,"value":417},"所以最好在Initialize前",{"type":14,"tag":15,"props":419,"children":421},{"id":420},"jenny",[422],{"type":20,"value":423},"Jenny",{"type":14,"tag":23,"props":425,"children":426},{},[427],{"type":20,"value":428},"jenny使用了roslyn, DataProviders需要更改下,否则会报错..",{"type":14,"tag":63,"props":430,"children":432},{"code":431},"Jenny.SearchPaths = Assets\\Plugins\\DesperateDevs\\Editor\\Plugins, \\\n                    Assets\\Plugins\\Entitas\\Editor\\Plugins, \\\n                    Jenny\\Plugins\\Entitas.Roslyn\n\nJenny.Plugins = DesperateDevs.CodeGeneration.Plugins, \\\n                DesperateDevs.CodeGeneration.Unity.Plugins, \\\n                Entitas.CodeGeneration.Plugins, \\\n                Entitas.Roslyn.CodeGeneration.Plugins, \\\n                Entitas.VisualDebugging.CodeGeneration.Plugins\n\nJenny.PreProcessors = DesperateDevs.CodeGeneration.Plugins.ValidateProjectPathPreProcessor, \\\n                      DesperateDevs.CodeGeneration.Plugins.TargetFrameworkProfilePreProcessor\n\nJenny.DataProviders = Entitas.CodeGeneration.Plugins.ContextDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.CleanupDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.ComponentDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.EntityIndexDataProvider\n\nJenny.CodeGenerators = Entitas.CodeGeneration.Plugins.ComponentContextApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentEntityApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentEntityApiInterfaceGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentLookupGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentMatcherApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextAttributeGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextMatcherGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextsGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EntityGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EntityIndexGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventEntityApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventListenerComponentGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventListenertInterfaceGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventSystemGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventSystemsGenerator, \\\n                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemGenerator, \\\n                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemsGenerator, \\\n                       Entitas.VisualDebugging.CodeGeneration.Plugins.ContextObserverGenerator, \\\n                       Entitas.VisualDebugging.CodeGeneration.Plugins.FeatureClassGenerator\n\nJenny.PostProcessors = DesperateDevs.CodeGeneration.Plugins.AddFileHeaderPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.CleanTargetDirectoryPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.MergeFilesPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.NewLinePostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.UpdateCSProjPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.WriteToDiskPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.ConsoleWriteLinePostProcessor\n\nJenny.Server.Port = 3333\nJenny.Client.Host = localhost\nDesperateDevs.CodeGeneration.Plugins.ProjectPath = Assembly-CSharp.csproj\nEntitas.CodeGeneration.Plugins.Assemblies = Library/ScriptAssemblies/Assembly-CSharp.dll\nEntitas.CodeGeneration.Plugins.Contexts = Game, \\\n                                          Unit, \\\n                                          Combat, \\\n                                          Config, \\\n                                          Input\n\nEntitas.CodeGeneration.Plugins.IgnoreNamespaces = true\nDesperateDevs.CodeGeneration.Plugins.TargetDirectory = Assets/Scripts/World\n\n",[433],{"type":14,"tag":68,"props":434,"children":435},{"__ignoreMap":7},[436],{"type":20,"value":431},{"type":14,"tag":23,"props":438,"children":439},{},[440],{"type":20,"value":441},"一般来说.先运行Jenny-Auto-Import.bat.再运行Jenny-Server.bat就可以了",{"type":14,"tag":23,"props":443,"children":444},{},[445],{"type":20,"value":446},"查看所有命令:",{"type":14,"tag":63,"props":448,"children":450},{"code":449},".\\Jenny\\Jenny.exe help \n",[451],{"type":14,"tag":68,"props":452,"children":453},{"__ignoreMap":7},[454],{"type":20,"value":449},{"type":14,"tag":23,"props":456,"children":457},{},[458],{"type":20,"value":459},"以VStudio为例，创建一个外部工具：",{"type":14,"tag":23,"props":461,"children":462},{},[463],{"type":14,"tag":27,"props":464,"children":466},{"alt":27,"src":465},"/images/2020-01-01-unity-entitas/v2-d49876b0ae0100844a372dfb16508b27_hd.jpg",[],{"type":14,"tag":23,"props":468,"children":469},{},[470,472,478,480,486],{"type":20,"value":471},"再之后，想要生成代码只需要保持运行",{"type":14,"tag":68,"props":473,"children":475},{"className":474},[],[476],{"type":20,"value":477},"Jenny Server",{"type":20,"value":479}," 然后在VS中运行",{"type":14,"tag":68,"props":481,"children":483},{"className":482},[],[484],{"type":20,"value":485},"工具/Jenny",{"type":20,"value":487}," 就可以了，这个方法可以让你专注于VS而无需切换回Unity。",{"type":14,"tag":23,"props":489,"children":490},{},[491,497],{"type":14,"tag":68,"props":492,"children":494},{"className":493},[],[495],{"type":20,"value":496},"jenny.exe client gen",{"type":20,"value":498},"需要服务器才能使用",{"type":14,"tag":23,"props":500,"children":501},{},[502,508],{"type":14,"tag":68,"props":503,"children":505},{"className":504},[],[506],{"type":20,"value":507},"jenny gen",{"type":20,"value":509}," 不开服务器直接可以使用",{"type":14,"tag":511,"props":512,"children":514},"h2",{"id":513},"相关链接",[515],{"type":20,"value":513},{"type":14,"tag":186,"props":517,"children":518},{},[519,530,539],{"type":14,"tag":82,"props":520,"children":521},{},[522],{"type":14,"tag":523,"props":524,"children":528},"a",{"href":525,"rel":526},"https://www.jianshu.com/c/e8e4c3f4280c",[527],"nofollow",[529],{"type":20,"value":525},{"type":14,"tag":82,"props":531,"children":532},{},[533],{"type":14,"tag":523,"props":534,"children":537},{"href":535,"rel":536},"https://github.com/OneYoungMean/Entitas-CSharp-OYM/wiki",[527],[538],{"type":20,"value":535},{"type":14,"tag":82,"props":540,"children":541},{},[542],{"type":14,"tag":523,"props":543,"children":546},{"href":544,"rel":545},"https://github.com/sschmid/Entitas-CSharp",[527],[547],{"type":20,"value":544},{"title":7,"searchDepth":549,"depth":549,"links":550},2,[551,553,554],{"id":334,"depth":552,"text":334},3,{"id":391,"depth":552,"text":394},{"id":513,"depth":549,"text":513},"markdown","content:unity:2020-01-01-unity-entitas.md","content","unity/2020-01-01-unity-entitas.md","md","2020-01-01",[562,572,699,748,800,813,925],{"title":563,"_path":564,"children":565},"Art","/art",[566,569],{"title":567,"_path":568},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":570,"_path":571},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":573,"_path":574,"children":575},"Dotnet","/dotnet",[576,579,582,585,588,591,594,597,600,603,606,609,612,615,618,621,624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675,678,681,684,687,690,693,696],{"title":577,"_path":578},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":580,"_path":581},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":583,"_path":584},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":586,"_path":587},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":589,"_path":590},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":592,"_path":593},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":595,"_path":596},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":598,"_path":599},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":601,"_path":602},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":604,"_path":605},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":607,"_path":608},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":610,"_path":611},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":613,"_path":614},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":616,"_path":617},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":619,"_path":620},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":622,"_path":623},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":625,"_path":626},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":628,"_path":629},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":631,"_path":632},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":634,"_path":635},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":637,"_path":638},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":640,"_path":641},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":643,"_path":644},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":646,"_path":647},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":649,"_path":650},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":652,"_path":653},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":655,"_path":656},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":658,"_path":659},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":661,"_path":662},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":664,"_path":665},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":667,"_path":668},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":670,"_path":671},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":673,"_path":674},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":676,"_path":677},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":679,"_path":680},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":682,"_path":683},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":685,"_path":686},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":688,"_path":689},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":691,"_path":692},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":694,"_path":695},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":697,"_path":698},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":700,"_path":701,"children":702},"Game","/game",[703,706,709,712,715,718,721,724,727,730,733,736,739,742,745],{"title":704,"_path":705},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":707,"_path":708},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":710,"_path":711},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":713,"_path":714},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":716,"_path":717},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":719,"_path":720},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":722,"_path":723},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":725,"_path":726},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":728,"_path":729},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":731,"_path":732},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":734,"_path":735},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":737,"_path":738},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":740,"_path":741},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":743,"_path":744},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":746,"_path":747},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":749,"_path":750,"children":751},"Gyj","/gyj",[752,755,758,761,764,767,770,773,776,779,782,785,788,791,794,797],{"title":753,"_path":754},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":756,"_path":757},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":759,"_path":760},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":762,"_path":763},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":765,"_path":766},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":768,"_path":769},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":771,"_path":772},"玩法","/gyj/2022-08-22-wanfa",{"title":774,"_path":775},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":777,"_path":778},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":780,"_path":781},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":783,"_path":784},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":786,"_path":787},"门派内容相关","/gyj/2022-11-17-sect",{"title":789,"_path":790},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":792,"_path":793},"种植","/gyj/2022-12-01-zhongzhi",{"title":795,"_path":796},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":798,"_path":799},"跑商","/gyj/2023-11-01-paoshang",{"title":801,"_path":802,"children":803},"Js","/js",[804,807,810],{"title":805,"_path":806},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":808,"_path":809},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":811,"_path":812},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":814,"_path":815,"children":816},"Tool","/tool",[817,820,823,826,829,832,835,838,841,844,847,850,853,856,859,862,865,868,871,874,877,880,883,886,889,892,895,898,901,904,907,910,913,916,919,922],{"title":818,"_path":819},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":821,"_path":822},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":824,"_path":825},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":827,"_path":828},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":830,"_path":831},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":833,"_path":834},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":836,"_path":837},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":839,"_path":840},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":842,"_path":843},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":845,"_path":846},"mac下brew 使用","/tool/2020-01-13-brew",{"title":848,"_path":849},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":851,"_path":852},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":854,"_path":855},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":857,"_path":858},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":860,"_path":861},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":863,"_path":864},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":866,"_path":867},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":869,"_path":870},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":872,"_path":873},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":875,"_path":876},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":878,"_path":879},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":881,"_path":882},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":884,"_path":885},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":887,"_path":888},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":890,"_path":891},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":893,"_path":894},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":896,"_path":897},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":899,"_path":900},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":902,"_path":903},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":905,"_path":906},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":908,"_path":909},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":911,"_path":912},"rider的使用","/tool/2022-08-02-rider-use",{"title":914,"_path":915},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":917,"_path":918},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":920,"_path":921},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":923,"_path":924},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":926,"_path":927,"children":928},"Unity","/unity",[929,932,935,938,941,944,947,950,953,956,959,962,965,968,971,974,977,978,981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017,1020,1023,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053,1056,1059,1062,1065,1068,1071,1074,1077,1080,1083,1086,1089,1092,1095,1098,1101,1104,1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140],{"title":930,"_path":931},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":933,"_path":934},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":936,"_path":937},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":939,"_path":940},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":942,"_path":943},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":945,"_path":946},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":948,"_path":949},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":951,"_path":952},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":954,"_path":955},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":957,"_path":958},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":960,"_path":961},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":963,"_path":964},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":966,"_path":967},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":969,"_path":970},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":972,"_path":973},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":975,"_path":976},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":8,"_path":4},{"title":979,"_path":980},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":982,"_path":983},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":985,"_path":986},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":988,"_path":989},"技能系统","/unity/2020-02-15-skill-system",{"title":991,"_path":992},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":994,"_path":995},"角色状态设计","/unity/2020-02-17-character-states",{"title":997,"_path":998},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1000,"_path":1001},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1003,"_path":1004},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1006,"_path":1007},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1009,"_path":1010},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1012,"_path":1013},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1015,"_path":1016},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1018,"_path":1019},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1021,"_path":1022},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1024,"_path":1025},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1027,"_path":1028},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1030,"_path":1031},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1033,"_path":1034},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1036,"_path":1037},"unity的addressables","/unity/2020-09-12-addressables",{"title":1039,"_path":1040},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1042,"_path":1043},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1045,"_path":1046},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1048,"_path":1049},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1051,"_path":1052},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1054,"_path":1055},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1057,"_path":1058},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1060,"_path":1061},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1063,"_path":1064},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1066,"_path":1067},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1069,"_path":1070},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1072,"_path":1073},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1075,"_path":1076},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1078,"_path":1079},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1081,"_path":1082},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1084,"_path":1085},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1087,"_path":1088},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1090,"_path":1091},"ability","/unity/2020-11-16-dotssample",{"title":1093,"_path":1094},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1096,"_path":1097},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1099,"_path":1100},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1102,"_path":1103},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1105,"_path":1106},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1108,"_path":1109},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1111,"_path":1112},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1114,"_path":1115},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1117,"_path":1118},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1120,"_path":1121},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1123,"_path":1124},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1126,"_path":1127},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1129,"_path":1130},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1132,"_path":1133},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1135,"_path":1136},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1138,"_path":1139},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1141,"_path":1142},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041429]