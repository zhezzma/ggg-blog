[{"data":1,"prerenderedAt":1969},["Reactive",2],{"content-query-ULI8hKyReg":3,"content-navigation-8C37fagqQL":1387},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1381,"_id":1382,"_source":1383,"_file":1384,"_extension":1385,"date":1386},"/unity/2019-08-12-ugui-raycasters","unity",false,"","Unity Raycasters 剖析","Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。",{"type":11,"children":12,"toc":1369},"root",[13,20,25,45,50,55,64,71,76,90,99,134,139,145,150,162,190,215,223,228,236,265,273,294,299,305,317,330,335,376,382,387,393,398,400,486,515,535,541,552,565,570,578,583,596,603,608,616,628,673,708,714,719,727,739,745,750,762,774,874,923,929,934,940,952,1001,1007,1017,1025,1037,1042,1047,1059,1067,1088,1096,1101,1109,1129,1137,1185,1190,1198,1218,1226,1231,1236,1241,1249,1262,1270,1275,1283,1291,1296,1304,1309,1314,1330,1338,1343,1351,1356,1364],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":15,"props":21,"children":22},{},[23],{"type":19,"value":24},"在 Unity Raycasters 中有三种类型的 Raycasters:",{"type":14,"tag":26,"props":27,"children":28},"ul",{},[29,35,40],{"type":14,"tag":30,"props":31,"children":32},"li",{},[33],{"type":19,"value":34},"Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体",{"type":14,"tag":30,"props":36,"children":37},{},[38],{"type":19,"value":39},"Physics 2D Raycaster - 用于检测 2D 物体",{"type":14,"tag":30,"props":41,"children":42},{},[43],{"type":19,"value":44},"Physics Raycaster - 用于检测 3D 物体",{"type":14,"tag":15,"props":46,"children":47},{},[48],{"type":19,"value":49},"接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。",{"type":14,"tag":15,"props":51,"children":52},{},[53],{"type":19,"value":54},"Raycast 在 Event System 流程中所处的位置大致如下图:",{"type":14,"tag":15,"props":56,"children":57},{},[58],{"type":14,"tag":59,"props":60,"children":63},"img",{"alt":61,"src":62},"unity_event_system_raycaster.png","/images/2019-08-12-ugui-Raycasters/unity_event_system_raycaster.png",[],{"type":14,"tag":65,"props":66,"children":68},"h2",{"id":67},"baseraycaster-类",[69],{"type":19,"value":70},"BaseRaycaster 类",{"type":14,"tag":15,"props":72,"children":73},{},[74],{"type":19,"value":75},"Unity Raycasters 中的三个 Raycaster 类都继承自 BaseRaycaster。首先就来看看 BaseRaycaster 类。",{"type":14,"tag":15,"props":77,"children":78},{},[79,81,88],{"type":19,"value":80},"BaseRaycaster 类很简单，它包含一个抽象方法 ",{"type":14,"tag":82,"props":83,"children":85},"code",{"className":84},[],[86],{"type":19,"value":87},"Raycast",{"type":19,"value":89},"，定义如下:",{"type":14,"tag":91,"props":92,"children":94},"pre",{"code":93},"abstract void Raycast(PointerEventData eventData, List\u003CRaycastResult> resultAppendList);\n",[95],{"type":14,"tag":82,"props":96,"children":97},{"__ignoreMap":7},[98],{"type":19,"value":93},{"type":14,"tag":15,"props":100,"children":101},{},[102,104,110,112,118,120,125,127,132],{"type":19,"value":103},"这个方法供子类覆写以实现对不同类别的物体进行射线检测。BaseRaycaster 类还继承自 UIBehaviour 类，因此它还覆写了 ",{"type":14,"tag":82,"props":105,"children":107},{"className":106},[],[108],{"type":19,"value":109},"OnEnable",{"type":19,"value":111}," 和 ",{"type":14,"tag":82,"props":113,"children":115},{"className":114},[],[116],{"type":19,"value":117},"OnDisable",{"type":19,"value":119}," 方法，在 ",{"type":14,"tag":82,"props":121,"children":123},{"className":122},[],[124],{"type":19,"value":109},{"type":19,"value":126}," 方法中向 RaycasterManager 类注册了自己，在 ",{"type":14,"tag":82,"props":128,"children":130},{"className":129},[],[131],{"type":19,"value":117},{"type":19,"value":133}," 方法中从 RaycasterManager 类移除了自己的注册。",{"type":14,"tag":15,"props":135,"children":136},{},[137],{"type":19,"value":138},"另外该类中还包含了 eventCamera、sortOrderPriority、renderOrderPriority 等属性，在射线检测物体时会用到。",{"type":14,"tag":65,"props":140,"children":142},{"id":141},"physics-raycaster",[143],{"type":19,"value":144},"Physics Raycaster",{"type":14,"tag":15,"props":146,"children":147},{},[148],{"type":19,"value":149},"Physics Raycaster 用于检测场景中的 3D 物体对象。",{"type":14,"tag":15,"props":151,"children":152},{},[153,155,160],{"type":19,"value":154},"PhysicsRaycaster 类继承自 BaseRaycaster，既然是射线检测那么最重要的方法莫过于 ",{"type":14,"tag":82,"props":156,"children":158},{"className":157},[],[159],{"type":19,"value":87},{"type":19,"value":161},"，接下来就一起看看这个方法。",{"type":14,"tag":15,"props":163,"children":164},{},[165,167,172,174,180,182,188],{"type":19,"value":166},"在 ",{"type":14,"tag":82,"props":168,"children":170},{"className":169},[],[171],{"type":19,"value":87},{"type":19,"value":173}," 方法中，首先使用传入的 PointerEventData 参数调用 ",{"type":14,"tag":82,"props":175,"children":177},{"className":176},[],[178],{"type":19,"value":179},"ComputeRayAndDistance",{"type":19,"value":181}," 方法，计算得到从当前射线检测使用的 Camera 的近裁剪面处出发，穿过屏幕事件发生处位置的一条射线；这个方法还会计算一个射线检测使用的最大距离 ",{"type":14,"tag":82,"props":183,"children":185},{"className":184},[],[186],{"type":19,"value":187},"distanceToClipPlane",{"type":19,"value":189},"。",{"type":14,"tag":15,"props":191,"children":192},{},[193,198,200,206,208,213],{"type":14,"tag":82,"props":194,"children":196},{"className":195},[],[197],{"type":19,"value":179},{"type":19,"value":199}," 内部使用了 Camera 类的 ",{"type":14,"tag":82,"props":201,"children":203},{"className":202},[],[204],{"type":19,"value":205},"ScreenPointToRay",{"type":19,"value":207}," 方法将某点转换成一条射线，根据得到的射线的方向以及 Camera 的 farClipPlane 和 nearClipPlane 求得检测最大距离 ",{"type":14,"tag":82,"props":209,"children":211},{"className":210},[],[212],{"type":19,"value":187},{"type":19,"value":214},"。具体代码如下:",{"type":14,"tag":91,"props":216,"children":218},{"code":217},"void ComputeRayAndDistance(PointerEventData eventData, out Ray ray, out float distanceToClipPlane)\n{\n    ray = eventCamera.ScreenPointToRay(eventData.position);\n    float projectionDirection = ray.direction.z;\n    // 这里加了个保护，因为 projectionDirection 近似为 0 的时候不能被除，因此 distanceToClipPlane 取 Mathf.Infinity 无限大\n    distanceToClipPlane = Mathf.Approximately(0.0f, projectionDirection) ? Mathf.Infinity : Mathf.Abs((eventCamera.farClipPlane - eventCamera.nearClipPlane) / projectionDirection);\n}\n",[219],{"type":14,"tag":82,"props":220,"children":221},{"__ignoreMap":7},[222],{"type":19,"value":217},{"type":14,"tag":15,"props":224,"children":225},{},[226],{"type":19,"value":227},"接下来就是进行射线检测了，代码如下:",{"type":14,"tag":91,"props":229,"children":231},{"code":230},"var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);\n",[232],{"type":14,"tag":82,"props":233,"children":234},{"__ignoreMap":7},[235],{"type":19,"value":230},{"type":14,"tag":15,"props":237,"children":238},{},[239,241,247,249,255,257,263],{"type":19,"value":240},"这里的 ",{"type":14,"tag":82,"props":242,"children":244},{"className":243},[],[245],{"type":19,"value":246},"ReflectionMethodsCache",{"type":19,"value":248}," 类里面缓存了一些通过反射得到的射线检测相关的类方法。在上面的代码中使用了 ",{"type":14,"tag":82,"props":250,"children":252},{"className":251},[],[253],{"type":19,"value":254},"raycast3DAll",{"type":19,"value":256}," 这个代理，最终执行的是 Physics 类的 ",{"type":14,"tag":82,"props":258,"children":260},{"className":259},[],[261],{"type":19,"value":262},"RaycastAll",{"type":19,"value":264}," 方法。传入的三个参数就是射线 ray，最大检测距离 distanceToClipPlane 以及需要检测的层 finalEventMask，返回结果就是检测成功得到的 RaycastHit 数组。第三个参数 finalEventMask 定义如下:",{"type":14,"tag":91,"props":266,"children":268},{"code":267},"public int finalEventMask\n{\n    get { return (eventCamera != null) ? eventCamera.cullingMask & m_EventMask : kNoEventMaskSet; }\n}\n",[269],{"type":14,"tag":82,"props":270,"children":271},{"__ignoreMap":7},[272],{"type":19,"value":267},{"type":14,"tag":15,"props":274,"children":275},{},[276,278,284,286,292],{"type":19,"value":277},"我们知道，射线检测的时候可以设置哪些 layer 可以接收检测碰撞。上面定义的 finalEventMask 就是需要检测的 layer，如果当前 raycaster 所在的对象有 Camera 组件，那么 finalEventMask 就是摄像机设置的渲染的所有层(",{"type":14,"tag":82,"props":279,"children":281},{"className":280},[],[282],{"type":19,"value":283},"eventCamera.cullingMask & m_EventMask",{"type":19,"value":285},")，否则就是默认所有的层(",{"type":14,"tag":82,"props":287,"children":289},{"className":288},[],[290],{"type":19,"value":291},"int kNoEventMaskSet = -1",{"type":19,"value":293},")都可以接收射线碰撞检测。",{"type":14,"tag":15,"props":295,"children":296},{},[297],{"type":19,"value":298},"然后对检测得到的 RaycastHit 数组按照 distance 由小到大排序。最后将这些射线检测结果依次拼装成 RaycastResult 并返回给 Event System，这里的 RaycastResult 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。",{"type":14,"tag":65,"props":300,"children":302},{"id":301},"physics2d-raycaster",[303],{"type":19,"value":304},"Physics2D Raycaster",{"type":14,"tag":15,"props":306,"children":307},{},[308,310,315],{"type":19,"value":309},"Physics2DRaycaster 类继承自 PhysicsRaycaster，主要就是 ",{"type":14,"tag":82,"props":311,"children":313},{"className":312},[],[314],{"type":19,"value":87},{"type":19,"value":316}," 方法中的一点点细小的区别。",{"type":14,"tag":15,"props":318,"children":319},{},[320,322,328],{"type":19,"value":321},"第一，在进行射线检测的时候，Physics2DRaycaster 中最后调用的是 Physics2D 的 ",{"type":14,"tag":82,"props":323,"children":325},{"className":324},[],[326],{"type":19,"value":327},"GetRayIntersectionAll",{"type":19,"value":329}," 方法。",{"type":14,"tag":15,"props":331,"children":332},{},[333],{"type":19,"value":334},"第二处同 PhysicsRaycaster 的不同之处是在返回构造 RaycastResult 时，填充的部分值不一样，包括以下几个:",{"type":14,"tag":26,"props":336,"children":337},{},[338,351,364],{"type":14,"tag":30,"props":339,"children":340},{},[341,343,349],{"type":19,"value":342},"distance，这个值是摄像机到射线检测碰撞点的距离，而在 PhysicsRaycaster 中是 RaycastHit 的 ",{"type":14,"tag":82,"props":344,"children":346},{"className":345},[],[347],{"type":19,"value":348},"distance",{"type":19,"value":350}," 值(射线起点在近裁剪面发出到碰撞点的距离)。",{"type":14,"tag":30,"props":352,"children":353},{},[354,356,362],{"type":19,"value":355},"sortingLayer，这个值是当前对象 SpriteRenderer 组件中的 ",{"type":14,"tag":82,"props":357,"children":359},{"className":358},[],[360],{"type":19,"value":361},"sortingLayerID",{"type":19,"value":363}," 值，在 PhysicsRaycaster 为 0。",{"type":14,"tag":30,"props":365,"children":366},{},[367,369,375],{"type":19,"value":368},"sortingOrder，这个同样为当前对象 SpriteRenderer 组件中的 ",{"type":14,"tag":82,"props":370,"children":372},{"className":371},[],[373],{"type":19,"value":374},"sortingOrder",{"type":19,"value":363},{"type":14,"tag":65,"props":377,"children":379},{"id":378},"graphic-raycaster",[380],{"type":19,"value":381},"Graphic Raycaster",{"type":14,"tag":15,"props":383,"children":384},{},[385],{"type":19,"value":386},"Graphic Raycaster 用于射线检测 Canvas 中的 Graphic 对象物体，通常绑定在 Canvas 所在的对象身上。",{"type":14,"tag":388,"props":389,"children":391},"h3",{"id":390},"属性或方法",[392],{"type":19,"value":390},{"type":14,"tag":15,"props":394,"children":395},{},[396],{"type":19,"value":397},"GraphicRaycaster 类的成员属性很少，除了继承 BaseRaycaster 类的一些属性和方法外，它还拥有以下一些常用的属性或方法:",{"type":19,"value":399},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":14,"tag":401,"props":402,"children":403},"table",{},[404,423],{"type":14,"tag":405,"props":406,"children":407},"thead",{},[408],{"type":14,"tag":409,"props":410,"children":411},"tr",{},[412,418],{"type":14,"tag":413,"props":414,"children":415},"th",{},[416],{"type":19,"value":417},"属性",{"type":14,"tag":413,"props":419,"children":420},{},[421],{"type":19,"value":422},"描述",{"type":14,"tag":424,"props":425,"children":426},"tbody",{},[427,445,462],{"type":14,"tag":409,"props":428,"children":429},{},[430,440],{"type":14,"tag":431,"props":432,"children":433},"td",{},[434],{"type":14,"tag":82,"props":435,"children":437},{"className":436},[],[438],{"type":19,"value":439},"Ignore Reversed Graphics",{"type":14,"tag":431,"props":441,"children":442},{},[443],{"type":19,"value":444},"射线检测时是否忽略背向的 Graphics",{"type":14,"tag":409,"props":446,"children":447},{},[448,457],{"type":14,"tag":431,"props":449,"children":450},{},[451],{"type":14,"tag":82,"props":452,"children":454},{"className":453},[],[455],{"type":19,"value":456},"Blocked Objects",{"type":14,"tag":431,"props":458,"children":459},{},[460],{"type":19,"value":461},"哪些类型的对象会阻挡 Graphic raycasts",{"type":14,"tag":409,"props":463,"children":464},{},[465,474],{"type":14,"tag":431,"props":466,"children":467},{},[468],{"type":14,"tag":82,"props":469,"children":471},{"className":470},[],[472],{"type":19,"value":473},"Blocking Mask",{"type":14,"tag":431,"props":475,"children":476},{},[477,479,484],{"type":19,"value":478},"哪些 Layer 会阻挡 Graphic raycasts(对 ",{"type":14,"tag":82,"props":480,"children":482},{"className":481},[],[483],{"type":19,"value":456},{"type":19,"value":485}," 指定的对象生效)",{"type":14,"tag":15,"props":487,"children":488},{},[489,491,497,499,505,507,513],{"type":19,"value":490},"不同于 PhysicsRaycaster 和 Physics2DRaycaster 类中直接使用父类的 ",{"type":14,"tag":82,"props":492,"children":494},{"className":493},[],[495],{"type":19,"value":496},"sortOrderPriority",{"type":19,"value":498}," 方法和 ",{"type":14,"tag":82,"props":500,"children":502},{"className":501},[],[503],{"type":19,"value":504},"renderOrderPriority",{"type":19,"value":506},"，GraphicRaycaster 覆写了这两个方法，并且当 Canvas 的 render mode 设置为 ",{"type":14,"tag":82,"props":508,"children":510},{"className":509},[],[511],{"type":19,"value":512},"RenderMode.ScreenSpaceOverlay",{"type":19,"value":514}," 时，上面两个方法分别返回 canvas 的 sortingOrder 以及 rootCanvas 的 renderOrder。",{"type":14,"tag":15,"props":516,"children":517},{},[518,520,525,527,533],{"type":19,"value":519},"对于 eventCamera 的 get 方法，如果 Canvas 的 render mode 设置为 ",{"type":14,"tag":82,"props":521,"children":523},{"className":522},[],[524],{"type":19,"value":512},{"type":19,"value":526}," 或者 ",{"type":14,"tag":82,"props":528,"children":530},{"className":529},[],[531],{"type":19,"value":532},"enderMode.ScreenSpaceCamera",{"type":19,"value":534}," 并且 Canvas 的 worldCamera 未设置时，返回 null，否则返回 Canvas 的 worldCamera 或者 Main Camera。",{"type":14,"tag":388,"props":536,"children":538},{"id":537},"graphicraycasterraycast",[539],{"type":19,"value":540},"GraphicRaycaster.Raycast",{"type":14,"tag":15,"props":542,"children":543},{},[544,546,551],{"type":19,"value":545},"接下来就来到最重要的覆写的 ",{"type":14,"tag":82,"props":547,"children":549},{"className":548},[],[550],{"type":19,"value":87},{"type":19,"value":329},{"type":14,"tag":15,"props":553,"children":554},{},[555,557,563],{"type":19,"value":556},"首先调用 ",{"type":14,"tag":82,"props":558,"children":560},{"className":559},[],[561],{"type":19,"value":562},"GraphicRegistry.GetGraphicsForCanvas",{"type":19,"value":564}," 方法获取当前 Canvas 下所有的 Graphic(canvasGraphics，这些 Graphics 在进行射线检测的时候会用到)。",{"type":14,"tag":15,"props":566,"children":567},{},[568],{"type":19,"value":569},"紧接着就是 MultiDisplay 的一些检测，代码如下:",{"type":14,"tag":91,"props":571,"children":573},{"code":572},"int displayIndex;\nvar currentEventCamera = eventCamera;\nif (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == null)\n    displayIndex = canvas.targetDisplay;\nelse\n    displayIndex = currentEventCamera.targetDisplay;\nvar eventPosition = Display.RelativeMouseAt(eventData.position);\nif (eventPosition != Vector3.zero)\n{\n    // 当前平台支持 MultiDisplay\n    int eventDisplayIndex = (int)eventPosition.z;\n    if (eventDisplayIndex != displayIndex)\n        return;\n}\nelse\n{\n    // 当前平台不支持 MultiDiplay\n    eventPosition = eventData.position;\n}\n",[574],{"type":14,"tag":82,"props":575,"children":576},{"__ignoreMap":7},[577],{"type":19,"value":572},{"type":14,"tag":15,"props":579,"children":580},{},[581],{"type":19,"value":582},"可以看出，当平台支持 MultiDisplay 时，如果用户操作的不是当前的 Display，那么所有的其他 Display 上产生的事件都会被舍弃。",{"type":14,"tag":15,"props":584,"children":585},{},[586,588,594],{"type":19,"value":587},"然后将屏幕坐标转换到 Camera 视窗坐标下。如果 eventCamera 不为空，则使用 ",{"type":14,"tag":82,"props":589,"children":591},{"className":590},[],[592],{"type":19,"value":593},"Camera.ScreenToViewportPoint",{"type":19,"value":595}," 方法转换坐标，否则直接使用当前 Display 的宽高除以 eventPosition 转换为视窗坐标([0,1]之间)。转换后的坐标若超出 Cmera 的范围(0 - 1)，则舍弃该事件。",{"type":14,"tag":597,"props":598,"children":600},"h4",{"id":599},"blocked-objects-和-blocked-mask-出场",[601],{"type":19,"value":602},"Blocked Objects 和 Blocked Mask 出场",{"type":14,"tag":15,"props":604,"children":605},{},[606],{"type":19,"value":607},"前面讲到 GraphicRaycaster 可以设置 Blocked Objects 和 Blocked Mask 来指定射线检测阻挡，下面一步就到了使用这两个属性来阻断射线检测部分。",{"type":14,"tag":91,"props":609,"children":611},{"code":610},"if (canvas.renderMode != RenderMode.ScreenSpaceOverlay && blockingObjects != BlockingObjects.None)\n{\n    float distanceToClipPlane\n    // 计算 distanceToClipPlane...\n    if (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)\n    {\n        if (ReflectionMethodsCache.Singleton.raycast3D != null)\n        {\n            var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n            if (hits.Length > 0)\n                hitDistance = hits[0].distance;\n        }    \n    }\n    //如果 blockingObjects 包含 BlockingObjects.TwoD，使用 ReflectionMethodsCache.Singleton.getRayIntersectionAll 方法再次计算 hitDistance\n}\n",[612],{"type":14,"tag":82,"props":613,"children":614},{"__ignoreMap":7},[615],{"type":19,"value":610},{"type":14,"tag":15,"props":617,"children":618},{},[619,621,626],{"type":19,"value":620},"当 Canvas renderMode 不为 ",{"type":14,"tag":82,"props":622,"children":624},{"className":623},[],[625],{"type":19,"value":512},{"type":19,"value":627}," 并且设置了 blockingObjects，此时就会 Blocked Objects 和 Blocked Mask 就会生效。",{"type":14,"tag":26,"props":629,"children":630},{},[631,652],{"type":14,"tag":30,"props":632,"children":633},{},[634,636,642,644,650],{"type":19,"value":635},"如果 blockingObjects 包含了 ",{"type":14,"tag":82,"props":637,"children":639},{"className":638},[],[640],{"type":19,"value":641},"BlockingObjects.ThreeD",{"type":19,"value":643}," 那么则会使用 ",{"type":14,"tag":82,"props":645,"children":647},{"className":646},[],[648],{"type":19,"value":649},"ReflectionMethodsCache.Singleton.raycast3DAll",{"type":19,"value":651}," 方法计算 hitDistance(PhysicsRaycaster 中也使用的该方法进行射线检测)。",{"type":14,"tag":30,"props":653,"children":654},{},[655,657,663,665,671],{"type":19,"value":656},"如果 blockingObjects 也包含了 ",{"type":14,"tag":82,"props":658,"children":660},{"className":659},[],[661],{"type":19,"value":662},"BlockingObjects.TwoD",{"type":19,"value":664},"，那么会使用 ",{"type":14,"tag":82,"props":666,"children":668},{"className":667},[],[669],{"type":19,"value":670},"ReflectionMethodsCache.Singleton.getRayIntersectionAll",{"type":19,"value":672}," 方法(Physics2DRaycaster 射线检测使用)再计算 hitDistance。",{"type":14,"tag":15,"props":674,"children":675},{},[676,678,684,686,691,693,699,701,706],{"type":19,"value":677},"具体的计算过程大致是: 这上面的代码中 raycast3DAll 时指定了射线检测层 ",{"type":14,"tag":82,"props":679,"children":681},{"className":680},[],[682],{"type":19,"value":683},"m_BlockingMask",{"type":19,"value":685},"，这个参数就是自定义设定的 ",{"type":14,"tag":82,"props":687,"children":689},{"className":688},[],[690],{"type":19,"value":473},{"type":19,"value":692},"，属于 block mask 的对象在这里就会就行射线检测，并得到最小的一个 hitDistance；",{"type":14,"tag":694,"props":695,"children":696},"strong",{},[697],{"type":19,"value":698},"后面对所有的 Graphics 进行射线检测时，如果检测结果 distance 大于 hitDistance，那么那个结果会被舍弃",{"type":19,"value":700},"。如此一来，",{"type":14,"tag":82,"props":702,"children":704},{"className":703},[],[705],{"type":19,"value":473},{"type":19,"value":707}," 就起到了阻挡的作用，属于这个 layer 的所有对象的一旦被射线检测成功并得到 hitDistance，PhysicsRaycaster 最后的射线检测结果都只会包含这个 hitDistance 距离以内的对象。",{"type":14,"tag":597,"props":709,"children":711},{"id":710},"graphicraycaster-类重载了-真-raycast-方法",[712],{"type":19,"value":713},"GraphicRaycaster 类重载了 “真” Raycast 方法",{"type":14,"tag":15,"props":715,"children":716},{},[717],{"type":19,"value":718},"终于可以进行真真切切的 Graphic Raycast 了。",{"type":14,"tag":91,"props":720,"children":722},{"code":721},"private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList\u003CGraphic> foundGraphics, List\u003CGraphic> results)\n{\n    int totalCount = foundGraphics.Count;\n    for (int i = 0; i \u003C totalCount; ++i)\n    {\n        Graphic graphic = foundGraphics[i];\n        // depth 为 -1 说明没有被 canvas 处理(未被绘制)\n        // raycastTarget 为 false 说明当前 graphic 不需要被射线检测\n        // graphic.canvasRenderer.cull 为 true，忽略当前 graphic 的 CanvasRender 渲染的物体\n        if (graphic.depth == -1 || !graphic.raycastTarget || graphic.canvasRenderer.cull)\n            continue;\n        // 从指定的 eventCamera 计算 pointerPosition 是否在 graphic 的 Rectangle 区域内 \n        if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera))\n            continue;\n        if (graphic.Raycast(pointerPosition, eventCamera))\n        {\n            s_SortedGraphics.Add(graphic);\n        }\n    }\n    s_SortedGraphics.Sort((g1, g2) => g2.depth.CompareTo(g1.depth));\n    // return result\n}\n",[723],{"type":14,"tag":82,"props":724,"children":725},{"__ignoreMap":7},[726],{"type":19,"value":721},{"type":14,"tag":15,"props":728,"children":729},{},[730,732,737],{"type":19,"value":731},"在循环中对每一个 Graphic 首先进行了初步的筛选，满足条件的 Graphic 才会调用其 ",{"type":14,"tag":82,"props":733,"children":735},{"className":734},[],[736],{"type":19,"value":87},{"type":19,"value":738}," 方法，这里的条件筛选包括 deth、raycastTarget 设置、位置信息是否满足等。",{"type":14,"tag":597,"props":740,"children":742},{"id":741},"graphicraycast",[743],{"type":19,"value":744},"Graphic.Raycast",{"type":14,"tag":15,"props":746,"children":747},{},[748],{"type":19,"value":749},"对 Canvas 下所有的 graphic 遍历，满足条件则进行射线检测。Graphic 射线检测过程如下:",{"type":14,"tag":15,"props":751,"children":752},{},[753,755,760],{"type":19,"value":754},"整个检测过程是在一个循环中实现的，从当前 Graphic 节点开始不断向上",{"type":14,"tag":694,"props":756,"children":757},{},[758],{"type":19,"value":759},"递归",{"type":19,"value":761},"，直至向上再没有节点或者节点绑定的组件中有被射线检测出来结果而返回。",{"type":14,"tag":15,"props":763,"children":764},{},[765,767,772],{"type":19,"value":766},"对于节点对象，首先获取其绑定的所有组件，依次",{"type":14,"tag":694,"props":768,"children":769},{},[770],{"type":19,"value":771},"遍历",{"type":19,"value":773},"判断组件:",{"type":14,"tag":26,"props":775,"children":776},{},[777,816],{"type":14,"tag":30,"props":778,"children":779},{},[780,782,788,790,796,798,802,804,808,810,815],{"type":19,"value":781},"当组件是 ",{"type":14,"tag":82,"props":783,"children":785},{"className":784},[],[786],{"type":19,"value":787},"Canvas",{"type":19,"value":789}," 并且其 overrideSorting 为 ",{"type":14,"tag":82,"props":791,"children":793},{"className":792},[],[794],{"type":19,"value":795},"true",{"type":19,"value":797}," 则指定: 若在当前节点绑定的一系列的组件中都未能成功唤起检测，则当前节点组件",{"type":14,"tag":694,"props":799,"children":800},{},[801],{"type":19,"value":771},{"type":19,"value":803},"结束后将跳出节点",{"type":14,"tag":694,"props":805,"children":806},{},[807],{"type":19,"value":759},{"type":19,"value":809},"并默认返回 ",{"type":14,"tag":82,"props":811,"children":813},{"className":812},[],[814],{"type":19,"value":795},{"type":19,"value":189},{"type":14,"tag":30,"props":817,"children":818},{},[819,821,827,829,835,837,842,844,849,851,857,859,865,867,872],{"type":19,"value":820},"如果组件是实现了 ",{"type":14,"tag":82,"props":822,"children":824},{"className":823},[],[825],{"type":19,"value":826},"ICanvasRaycastFilter",{"type":19,"value":828}," 接口，则判断组件是否是 ",{"type":14,"tag":82,"props":830,"children":832},{"className":831},[],[833],{"type":19,"value":834},"CanvasGroup",{"type":19,"value":836},"。若是 ",{"type":14,"tag":82,"props":838,"children":840},{"className":839},[],[841],{"type":19,"value":834},{"type":19,"value":843}," 且设置了 ignoreParentGroups 为 ",{"type":14,"tag":82,"props":845,"children":847},{"className":846},[],[848],{"type":19,"value":795},{"type":19,"value":850},"，那么对于接下来的所有 CanvasGroup 组件将不会调用 ",{"type":14,"tag":82,"props":852,"children":854},{"className":853},[],[855],{"type":19,"value":856},"IsRaycastLocationValid",{"type":19,"value":858}," 方法检测；若 CanvasGroup 都未设置 ",{"type":14,"tag":82,"props":860,"children":862},{"className":861},[],[863],{"type":19,"value":864},"ignoreParentGroups",{"type":19,"value":866},"或者不包含 CanvasGroup 组件，则直接调用组件实现的 ",{"type":14,"tag":82,"props":868,"children":870},{"className":869},[],[871],{"type":19,"value":856},{"type":19,"value":873}," 方法计算是否射线检测成功。",{"type":14,"tag":15,"props":875,"children":876},{},[877,879,884,886,891,893,899,901,907,909,914,916,921],{"type":19,"value":878},"从整个 Graphic.Raycast 检测过程可以看出，检测是自当前 graphic 节点开始，一旦检测到某个节点添加实现了 ",{"type":14,"tag":82,"props":880,"children":882},{"className":881},[],[883],{"type":19,"value":826},{"type":19,"value":885}," 接口且 ",{"type":14,"tag":82,"props":887,"children":889},{"className":888},[],[890],{"type":19,"value":856},{"type":19,"value":892}," 方法返回 ",{"type":14,"tag":82,"props":894,"children":896},{"className":895},[],[897],{"type":19,"value":898},"false",{"type":19,"value":900}," 则此 graphic 检测失败并结束检测；否则还会继续向上递归检测父节点，当所有节点(绑定了 Canvas 组件并设置了 ",{"type":14,"tag":82,"props":902,"children":904},{"className":903},[],[905],{"type":19,"value":906},"Canvas.overrideSorting",{"type":19,"value":908}," 为 ",{"type":14,"tag":82,"props":910,"children":912},{"className":911},[],[913],{"type":19,"value":795},{"type":19,"value":915},"的节点会截止此次检测)都射线检测成功或是不需要使用 ",{"type":14,"tag":82,"props":917,"children":919},{"className":918},[],[920],{"type":19,"value":856},{"type":19,"value":922}," 方法进行检测，则此次 Graphic.Raycast 成功。",{"type":14,"tag":597,"props":924,"children":926},{"id":925},"graphicraycast-成功的对象深度排序",[927],{"type":19,"value":928},"Graphic.Raycast 成功的对象深度排序",{"type":14,"tag":15,"props":930,"children":931},{},[932],{"type":19,"value":933},"对所有射线检测成功的 graphics 按照深度 depth 从小到大排序。",{"type":14,"tag":597,"props":935,"children":937},{"id":936},"reversed-graphics-过滤",[938],{"type":19,"value":939},"Reversed Graphics 过滤",{"type":14,"tag":15,"props":941,"children":942},{},[943,945,950],{"type":19,"value":944},"最后对检测结果再过滤。如果设置了 ",{"type":14,"tag":82,"props":946,"children":948},{"className":947},[],[949],{"type":19,"value":439},{"type":19,"value":951}," 为 true，则将背向 Camera 的对象过滤掉，这里面又分为两种情况:",{"type":14,"tag":26,"props":953,"children":954},{},[955,996],{"type":14,"tag":30,"props":956,"children":957},{},[958,960,966,968,976,980,982,987,989,994],{"type":19,"value":959},"Camera 为空，直接判断当前 Graphic 方向与正方向 ",{"type":14,"tag":82,"props":961,"children":963},{"className":962},[],[964],{"type":19,"value":965},"Vector3.forward",{"type":19,"value":967}," 是否相交，如下:",{"type":14,"tag":91,"props":969,"children":971},{"code":970},"var dir = go.transform.rotation * Vector3.forward;\nappendGraphic = Vector3.Dot(Vector3.forward, dir) > 0;\n",[972],{"type":14,"tag":82,"props":973,"children":974},{"__ignoreMap":7},[975],{"type":19,"value":970},{"type":14,"tag":977,"props":978,"children":979},"br",{},[],{"type":19,"value":981},"首先将 ",{"type":14,"tag":82,"props":983,"children":985},{"className":984},[],[986],{"type":19,"value":965},{"type":19,"value":988}," 绕着当前 Graphic 的 rotation 旋转得到 Graphic 的正方向，然后通过点积判断 Graphic 正方向是否与默认正方向(没有 Camera 所以默认正方向为 ",{"type":14,"tag":82,"props":990,"children":992},{"className":991},[],[993],{"type":19,"value":965},{"type":19,"value":995},")相交。点积大于 0 则相交，说明当前 Graphic 可以加入射线加测结果中。",{"type":14,"tag":30,"props":997,"children":998},{},[999],{"type":19,"value":1000},"当 Camera 不为空，就使用 Camera 的正方向与 Graphic 的正方向比较是否相交。",{"type":14,"tag":597,"props":1002,"children":1004},{"id":1003},"distance-检测是最终一道坎",[1005],{"type":19,"value":1006},"distance 检测是最终一道坎",{"type":14,"tag":15,"props":1008,"children":1009},{},[1010,1015],{"type":14,"tag":82,"props":1011,"children":1013},{"className":1012},[],[1014],{"type":19,"value":439},{"type":19,"value":1016}," 检测完，对结果进行 distance 计算:",{"type":14,"tag":91,"props":1018,"children":1020},{"code":1019},"float distance = 0;\nif (currentEventCamera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)\n    distance = 0;\nelse\n{\n    Transform trans = go.transform;\n    Vector3 transForward = trans.forward;\n    distance = (Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) / Vector3.Dot(transForward, ray.direction));\n    if (distance \u003C 0)\n        continue;\n}\n",[1021],{"type":14,"tag":82,"props":1022,"children":1023},{"__ignoreMap":7},[1024],{"type":19,"value":1019},{"type":14,"tag":15,"props":1026,"children":1027},{},[1028,1030,1035],{"type":19,"value":1029},"Render Mode 为 ",{"type":14,"tag":82,"props":1031,"children":1033},{"className":1032},[],[1034],{"type":19,"value":512},{"type":19,"value":1036}," 或者 Camera 为 null，distance 为 0；否则就计算 Graphic 和 Camera 之间的向量在 Graphic 正方向上的投影以及计算射线方向在 Graphic 正方向上的投影，两者相除就得到最终的 distance。",{"type":14,"tag":15,"props":1038,"children":1039},{},[1040],{"type":19,"value":1041},"如果 distance 小于 hitDistance(设置的 Blocked Objects 和 Blocked Mask 产生)，则结果通过最终的测试可被用作事件的接收者之一。",{"type":14,"tag":388,"props":1043,"children":1045},{"id":1044},"射线检测前后的一些操作",[1046],{"type":19,"value":1044},{"type":14,"tag":15,"props":1048,"children":1049},{},[1050,1052,1057],{"type":19,"value":1051},"首先来看看这些 Raycaster 被唤起的部分，也就是最开始的流程图中的第三步。Input Module 中使用 Raycaster 处理射线检测，真正的 Raycaster 实施代码又回到了 EventSystem 类中的 ",{"type":14,"tag":82,"props":1053,"children":1055},{"className":1054},[],[1056],{"type":19,"value":262},{"type":19,"value":1058}," 方法，具体代码如下:",{"type":14,"tag":91,"props":1060,"children":1062},{"code":1061},"public void RaycastAll(PointerEventData eventData, List\u003CRaycastResult> raycastResults)\n{\n    raycastResults.Clear();\n    var modules = RaycasterManager.GetRaycasters();\n    for (int i = 0; i \u003C modules.Count; ++i)\n    {\n        var module = modules[i];\n        if (module == null || !module.IsActive())\n            continue;\n        module.Raycast(eventData, raycastResults);\n    }\n    raycastResults.Sort(s_RaycastComparer);\n}\n",[1063],{"type":14,"tag":82,"props":1064,"children":1065},{"__ignoreMap":7},[1066],{"type":19,"value":1061},{"type":14,"tag":15,"props":1068,"children":1069},{},[1070,1072,1078,1080,1086],{"type":19,"value":1071},"场景中可以存在一个或多个 Raycaster。当存在多个时，如果需要发起射线检测，那么每个处于 Active 状态的 Raycaster 都会工作，所有 Raycaster 检测得到的结果都会存放在 ",{"type":14,"tag":82,"props":1073,"children":1075},{"className":1074},[],[1076],{"type":19,"value":1077},"raycastResults",{"type":19,"value":1079}," 中(这些 RaycastResult 都是在各自射线检测器中根据 distance 从小到大排过序的)。方法最后使用自定义 Comparer 对所有的 RaycastResult 排序。",{"type":14,"tag":82,"props":1081,"children":1083},{"className":1082},[],[1084],{"type":19,"value":1085},"s_RaycastComparer",{"type":19,"value":1087}," 有以下几种比较流程:",{"type":14,"tag":26,"props":1089,"children":1090},{},[1091],{"type":14,"tag":30,"props":1092,"children":1093},{},[1094],{"type":19,"value":1095},"两个 RaycastResult 检测所在的 Raycaster 不同",{"type":14,"tag":15,"props":1097,"children":1098},{},[1099],{"type":19,"value":1100},"首先比较两个对象的 Camera 的 depth。在渲染中，Camera depth 越小会越先渲染，越大越往后渲染，因此对于射线检测来说，Camera 的 depth 越大，它对应的物体应该先于 Camera depth 小的物体进行射线检测，检测得到的结果也应排在前面。代码如下:",{"type":14,"tag":91,"props":1102,"children":1104},{"code":1103},"if (lhsEventCamera.depth \u003C rhsEventCamera.depth)\n    return 1;\nif (lhsEventCamera.depth == rhsEventCamera.depth)\n    return 0;\nreturn -1;\n",[1105],{"type":14,"tag":82,"props":1106,"children":1107},{"__ignoreMap":7},[1108],{"type":19,"value":1103},{"type":14,"tag":15,"props":1110,"children":1111},{},[1112,1114,1119,1121,1127],{"type":19,"value":1113},"当 Camera depth 相等的时候，使用 ",{"type":14,"tag":82,"props":1115,"children":1117},{"className":1116},[],[1118],{"type":19,"value":496},{"type":19,"value":1120}," 进行比较。优先级数值越大，越先被射线检测选中，所以这里的 ",{"type":14,"tag":82,"props":1122,"children":1124},{"className":1123},[],[1125],{"type":19,"value":1126},"CompareTo",{"type":19,"value":1128}," 方法使用的是右边的参数去比较左边的参数，最终的结果就是按照从大到小(降序)的顺序排列。",{"type":14,"tag":91,"props":1130,"children":1132},{"code":1131},"return rhs.module.sortOrderPriority.CompareTo(lhs.module.sortOrderPriority);\n",[1133],{"type":14,"tag":82,"props":1134,"children":1135},{"__ignoreMap":7},[1136],{"type":19,"value":1131},{"type":14,"tag":15,"props":1138,"children":1139},{},[1140,1142,1147,1149,1155,1157,1162,1164,1169,1171,1176,1178,1183],{"type":19,"value":1141},"在 PhysicsRaycaster 和 Physics2DRaycaster 类中没有覆写 ",{"type":14,"tag":82,"props":1143,"children":1145},{"className":1144},[],[1146],{"type":19,"value":496},{"type":19,"value":1148}," 方法，因此都返回基类的 ",{"type":14,"tag":82,"props":1150,"children":1152},{"className":1151},[],[1153],{"type":19,"value":1154},"int.MinValue",{"type":19,"value":1156},"；但在 GraphicRaycaster 类中覆写了此方法，当对应的 Canvas 的 renderMode 设置为 ",{"type":14,"tag":82,"props":1158,"children":1160},{"className":1159},[],[1161],{"type":19,"value":512},{"type":19,"value":1163}," 时，此时的 ",{"type":14,"tag":82,"props":1165,"children":1167},{"className":1166},[],[1168],{"type":19,"value":496},{"type":19,"value":1170}," 返回 Canvas 的 sortingOrder(Sort Order越大越在上层)，否则同样也是返回基类设置的 ",{"type":14,"tag":82,"props":1172,"children":1174},{"className":1173},[],[1175],{"type":19,"value":1154},{"type":19,"value":1177},"，这是因为在 ",{"type":14,"tag":82,"props":1179,"children":1181},{"className":1180},[],[1182],{"type":19,"value":512},{"type":19,"value":1184}," 模式下，所有的 distance 都将是 0。",{"type":14,"tag":15,"props":1186,"children":1187},{},[1188],{"type":19,"value":1189},"当 sortOrderPriority 相同，再使用 renderOrderPriority 比较。",{"type":14,"tag":91,"props":1191,"children":1193},{"code":1192},"return rhs.module.renderOrderPriority.CompareTo(lhs.module.renderOrderPriority);\n",[1194],{"type":14,"tag":82,"props":1195,"children":1196},{"__ignoreMap":7},[1197],{"type":19,"value":1192},{"type":14,"tag":15,"props":1199,"children":1200},{},[1201,1203,1208,1210,1216],{"type":19,"value":1202},"renderOrderPriority 和 sortOrderPriority 类似，仅在 GraphicRaycaster 类中被覆写，也只有在 Canvas 的 renderMode 设置为 ",{"type":14,"tag":82,"props":1204,"children":1206},{"className":1205},[],[1207],{"type":19,"value":512},{"type":19,"value":1209}," 时才返回 ",{"type":14,"tag":82,"props":1211,"children":1213},{"className":1212},[],[1214],{"type":19,"value":1215},"canvas.rootCanvas.renderOrder",{"type":19,"value":1217},"，这是因为 Canvas 在其他几种 renderMode 下，渲染的先后顺序都和距离摄像机的距离有关。所以 renderOrderPriority 比较也是按照从大到小的顺序得到最终的结果。",{"type":14,"tag":26,"props":1219,"children":1220},{},[1221],{"type":14,"tag":30,"props":1222,"children":1223},{},[1224],{"type":19,"value":1225},"同属于一个 Raycaster 检测得到，但是它们的 sortingLayer 不一样",{"type":14,"tag":15,"props":1227,"children":1228},{},[1229],{"type":19,"value":1230},"对于 PhysicsRaycaster 检测得到的对象，sortingLayer 都为 0。",{"type":14,"tag":15,"props":1232,"children":1233},{},[1234],{"type":19,"value":1235},"对于 Physics2DRaycaster 检测得到的对象，如果对象上挂载有 SpriteRenderer 组件，那么 sortingLayer 对应的 sortingLayerID，否则也为 0。",{"type":14,"tag":15,"props":1237,"children":1238},{},[1239],{"type":19,"value":1240},"对于 GraphicRaycaster 检测所得，sortingLayer 就是所在 Canvas 的 sortingLayerID。",{"type":14,"tag":91,"props":1242,"children":1244},{"code":1243},"var rid = SortingLayer.GetLayerValueFromID(rhs.sortingLayer);\nvar lid = SortingLayer.GetLayerValueFromID(lhs.sortingLayer);\nreturn rid.CompareTo(lid);\n",[1245],{"type":14,"tag":82,"props":1246,"children":1247},{"__ignoreMap":7},[1248],{"type":19,"value":1243},{"type":14,"tag":15,"props":1250,"children":1251},{},[1252,1254,1260],{"type":19,"value":1253},"通过 ",{"type":14,"tag":82,"props":1255,"children":1257},{"className":1256},[],[1258],{"type":19,"value":1259},"SortingLayer.GetLayerValueFromID",{"type":19,"value":1261}," 方法计算 sortingLayer 最终的 sorting layer 值，同样是按照降序排列，因此计算得到的 sorting layer 值越大越先排在前面。",{"type":14,"tag":26,"props":1263,"children":1264},{},[1265],{"type":14,"tag":30,"props":1266,"children":1267},{},[1268],{"type":19,"value":1269},"sortingLayer 也相同，使用 sortingOrder 比较",{"type":14,"tag":15,"props":1271,"children":1272},{},[1273],{"type":19,"value":1274},"sortingOrder 和 sortingLayer 类似，PhysicsRaycaster 检测得到的对象 sortingOrder 为 0；Physics2DRaycaster 检测得到的对象是 SpriteRenderer 中的 sortingOrder；GraphicRaycaster 检测所得是所在 Canvas 的 sortingOrder。最终 sortingOrder 越大的对象越排前面。代码如下:",{"type":14,"tag":91,"props":1276,"children":1278},{"code":1277},"return rhs.sortingOrder.CompareTo(lhs.sortingOrder);\n",[1279],{"type":14,"tag":82,"props":1280,"children":1281},{"__ignoreMap":7},[1282],{"type":19,"value":1277},{"type":14,"tag":26,"props":1284,"children":1285},{},[1286],{"type":14,"tag":30,"props":1287,"children":1288},{},[1289],{"type":19,"value":1290},"sortingOrder 相同，使用 depth 比较",{"type":14,"tag":15,"props":1292,"children":1293},{},[1294],{"type":19,"value":1295},"PhysicsRaycaster 和 Physics2DRaycaster 中 depth 都被设置为了 0；GraphicRaycaster 检测所得的对象的 depth 就是继承自 Graphic 类的对象所在的 Graphic 的 depth，即 Canvas 下所有 Graphic 深度遍历的顺序。比较同样也是按照降序进行的，因此越嵌套在靠近 Canvas 的对象越排在前面。",{"type":14,"tag":26,"props":1297,"children":1298},{},[1299],{"type":14,"tag":30,"props":1300,"children":1301},{},[1302],{"type":19,"value":1303},"depth 相同，使用 distance 比较",{"type":14,"tag":15,"props":1305,"children":1306},{},[1307],{"type":19,"value":1308},"PhysicsRaycaster 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。",{"type":14,"tag":15,"props":1310,"children":1311},{},[1312],{"type":19,"value":1313},"Physics2DRaycaster 类中返回的是 Camera 的位置和射线碰撞点之间的距离。",{"type":14,"tag":15,"props":1315,"children":1316},{},[1317,1319,1328],{"type":19,"value":1318},"GraphicRaycaster 类中 distance ",{"type":14,"tag":1320,"props":1321,"children":1325},"a",{"href":1322,"rel":1323},"http://geomalgorithms.com/a06-_intersect-2.html",[1324],"nofollow",[1326],{"type":19,"value":1327},"计算",{"type":19,"value":1329},"如下:",{"type":14,"tag":91,"props":1331,"children":1333},{"code":1332},"var go = m_RaycastResults[index].gameObject;\nTransform trans = go.transform;\nVector3 transForward = trans.forward;\n// TODO why user DOT to caculate distance?\ndistance = Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) / Vector3.Dot(transForward, ray.direction);\n",[1334],{"type":14,"tag":82,"props":1335,"children":1336},{"__ignoreMap":7},[1337],{"type":19,"value":1332},{"type":14,"tag":15,"props":1339,"children":1340},{},[1341],{"type":19,"value":1342},"距离 distance 越小越靠前。",{"type":14,"tag":26,"props":1344,"children":1345},{},[1346],{"type":14,"tag":30,"props":1347,"children":1348},{},[1349],{"type":19,"value":1350},"最后如果上述情况都不能满足，使用 index 比较。先被射线检测到的对象排在前面。",{"type":14,"tag":15,"props":1352,"children":1353},{},[1354],{"type":19,"value":1355},"Raycaster 后段部分的流程: 取排过序的 RaycastResult 中第一个结果作为响应事件的输入事件的 pointerCurrentRaycast，根据它来在 Messaging System 中分发事件，大致代码如下:",{"type":14,"tag":91,"props":1357,"children":1359},{"code":1358},"// 获取 Raycast 结果中对应的 GameObject\nvar currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;\n// 分发事件\nExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.pointerDownHandler);\n",[1360],{"type":14,"tag":82,"props":1361,"children":1362},{"__ignoreMap":7},[1363],{"type":19,"value":1358},{"type":14,"tag":15,"props":1365,"children":1366},{},[1367],{"type":19,"value":1368},"Raycaster 在 Event System 中的作用和流程基本就是上述的内容。",{"title":7,"searchDepth":1370,"depth":1370,"links":1371},2,[1372,1373,1374,1375],{"id":67,"depth":1370,"text":70},{"id":141,"depth":1370,"text":144},{"id":301,"depth":1370,"text":304},{"id":378,"depth":1370,"text":381,"children":1376},[1377,1379,1380],{"id":390,"depth":1378,"text":390},3,{"id":537,"depth":1378,"text":540},{"id":1044,"depth":1378,"text":1044},"markdown","content:unity:2019-08-12-ugui-Raycasters.md","content","unity/2019-08-12-ugui-Raycasters.md","md","2019-08-12",[1388,1398,1525,1574,1626,1639,1751],{"title":1389,"_path":1390,"children":1391},"Art","/art",[1392,1395],{"title":1393,"_path":1394},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1396,"_path":1397},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1399,"_path":1400,"children":1401},"Dotnet","/dotnet",[1402,1405,1408,1411,1414,1417,1420,1423,1426,1429,1432,1435,1438,1441,1444,1447,1450,1453,1456,1459,1462,1465,1468,1471,1474,1477,1480,1483,1486,1489,1492,1495,1498,1501,1504,1507,1510,1513,1516,1519,1522],{"title":1403,"_path":1404},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1406,"_path":1407},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1409,"_path":1410},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1412,"_path":1413},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1415,"_path":1416},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":1418,"_path":1419},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1421,"_path":1422},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1424,"_path":1425},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1427,"_path":1428},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1430,"_path":1431},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1433,"_path":1434},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1436,"_path":1437},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1439,"_path":1440},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1442,"_path":1443},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1445,"_path":1446},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1448,"_path":1449},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1451,"_path":1452},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1454,"_path":1455},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1457,"_path":1458},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1460,"_path":1461},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1463,"_path":1464},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1466,"_path":1467},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1469,"_path":1470},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1472,"_path":1473},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1475,"_path":1476},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1478,"_path":1479},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1481,"_path":1482},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1484,"_path":1485},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1487,"_path":1488},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1490,"_path":1491},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1493,"_path":1494},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1496,"_path":1497},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1499,"_path":1500},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1502,"_path":1503},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1505,"_path":1506},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1508,"_path":1509},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1511,"_path":1512},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1514,"_path":1515},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1517,"_path":1518},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1520,"_path":1521},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1523,"_path":1524},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1526,"_path":1527,"children":1528},"Game","/game",[1529,1532,1535,1538,1541,1544,1547,1550,1553,1556,1559,1562,1565,1568,1571],{"title":1530,"_path":1531},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1533,"_path":1534},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1536,"_path":1537},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1539,"_path":1540},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1542,"_path":1543},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1545,"_path":1546},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1548,"_path":1549},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1551,"_path":1552},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1554,"_path":1555},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1557,"_path":1558},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1560,"_path":1561},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1563,"_path":1564},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1566,"_path":1567},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1569,"_path":1570},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1572,"_path":1573},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1575,"_path":1576,"children":1577},"Gyj","/gyj",[1578,1581,1584,1587,1590,1593,1596,1599,1602,1605,1608,1611,1614,1617,1620,1623],{"title":1579,"_path":1580},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1582,"_path":1583},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1585,"_path":1586},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1588,"_path":1589},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1591,"_path":1592},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1594,"_path":1595},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1597,"_path":1598},"玩法","/gyj/2022-08-22-wanfa",{"title":1600,"_path":1601},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1603,"_path":1604},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1606,"_path":1607},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1609,"_path":1610},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1612,"_path":1613},"门派内容相关","/gyj/2022-11-17-sect",{"title":1615,"_path":1616},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1618,"_path":1619},"种植","/gyj/2022-12-01-zhongzhi",{"title":1621,"_path":1622},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1624,"_path":1625},"跑商","/gyj/2023-11-01-paoshang",{"title":1627,"_path":1628,"children":1629},"Js","/js",[1630,1633,1636],{"title":1631,"_path":1632},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1634,"_path":1635},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1637,"_path":1638},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1640,"_path":1641,"children":1642},"Tool","/tool",[1643,1646,1649,1652,1655,1658,1661,1664,1667,1670,1673,1676,1679,1682,1685,1688,1691,1694,1697,1700,1703,1706,1709,1712,1715,1718,1721,1724,1727,1730,1733,1736,1739,1742,1745,1748],{"title":1644,"_path":1645},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1647,"_path":1648},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1650,"_path":1651},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1653,"_path":1654},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1656,"_path":1657},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1659,"_path":1660},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1662,"_path":1663},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1665,"_path":1666},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1668,"_path":1669},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1671,"_path":1672},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1674,"_path":1675},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1677,"_path":1678},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1680,"_path":1681},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1683,"_path":1684},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1686,"_path":1687},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1689,"_path":1690},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1692,"_path":1693},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1695,"_path":1696},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1698,"_path":1699},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1701,"_path":1702},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1704,"_path":1705},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1707,"_path":1708},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1710,"_path":1711},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1713,"_path":1714},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1716,"_path":1717},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1719,"_path":1720},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1722,"_path":1723},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1725,"_path":1726},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1728,"_path":1729},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1731,"_path":1732},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1734,"_path":1735},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1737,"_path":1738},"rider的使用","/tool/2022-08-02-rider-use",{"title":1740,"_path":1741},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1743,"_path":1744},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1746,"_path":1747},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1749,"_path":1750},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1752,"_path":1753,"children":1754},"Unity","/unity",[1755,1758,1761,1764,1767,1770,1773,1776,1777,1780,1783,1786,1789,1792,1795,1798,1801,1804,1807,1810,1813,1816,1819,1822,1825,1828,1831,1834,1837,1840,1843,1846,1849,1852,1855,1858,1861,1864,1867,1870,1873,1876,1879,1882,1885,1888,1891,1894,1897,1900,1903,1906,1909,1912,1915,1918,1921,1924,1927,1930,1933,1936,1939,1942,1945,1948,1951,1954,1957,1960,1963,1966],{"title":1756,"_path":1757},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1759,"_path":1760},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1762,"_path":1763},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1765,"_path":1766},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1768,"_path":1769},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1771,"_path":1772},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1774,"_path":1775},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":8,"_path":4},{"title":1778,"_path":1779},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1781,"_path":1782},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1784,"_path":1785},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1787,"_path":1788},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1790,"_path":1791},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1793,"_path":1794},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1796,"_path":1797},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1799,"_path":1800},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1802,"_path":1803},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1805,"_path":1806},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1808,"_path":1809},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1811,"_path":1812},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1814,"_path":1815},"技能系统","/unity/2020-02-15-skill-system",{"title":1817,"_path":1818},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1820,"_path":1821},"角色状态设计","/unity/2020-02-17-character-states",{"title":1823,"_path":1824},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1826,"_path":1827},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1829,"_path":1830},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1832,"_path":1833},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1835,"_path":1836},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1838,"_path":1839},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1841,"_path":1842},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1844,"_path":1845},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1847,"_path":1848},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1850,"_path":1851},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1853,"_path":1854},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1856,"_path":1857},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1859,"_path":1860},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1862,"_path":1863},"unity的addressables","/unity/2020-09-12-addressables",{"title":1865,"_path":1866},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1868,"_path":1869},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1871,"_path":1872},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1874,"_path":1875},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1877,"_path":1878},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1880,"_path":1881},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1883,"_path":1884},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1886,"_path":1887},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1889,"_path":1890},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1892,"_path":1893},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1895,"_path":1896},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1898,"_path":1899},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1901,"_path":1902},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1904,"_path":1905},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1907,"_path":1908},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1910,"_path":1911},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1913,"_path":1914},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1916,"_path":1917},"ability","/unity/2020-11-16-dotssample",{"title":1919,"_path":1920},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1922,"_path":1923},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1925,"_path":1926},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1928,"_path":1929},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1931,"_path":1932},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1934,"_path":1935},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1937,"_path":1938},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1940,"_path":1941},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1943,"_path":1944},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1946,"_path":1947},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1949,"_path":1950},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1952,"_path":1953},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1955,"_path":1956},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1958,"_path":1959},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1961,"_path":1962},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1964,"_path":1965},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1967,"_path":1968},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041947]