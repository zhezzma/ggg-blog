[{"data":1,"prerenderedAt":1190},["Reactive",2],{"content-query-OPBkBxdkn5":3,"content-navigation-8C37fagqQL":608},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":602,"_id":603,"_source":604,"_file":605,"_extension":606,"date":607},"/unity/2019-08-12-ugui-eventsystem-sourcecode","unity",false,"","ugui的eventsystem源码解读","为什么想看看事件系统的实现很简单，策划又提奇奇怪怪的需求了！比如这些事件要穿透啦，那些事件要做特殊处理啦！之类的……依旧先贴出源码地址：Unity-Technologies / UI - Bitbucketbitbucket.org入手点好那么我们从何处入手呢？当然是我们的EventTrigger了！我们都知道，我们可以通过实现以下接口来实现事件捕捉：大家都爱用的EventTrigger具体怎么做我想大家已经明白了，也就是实现上线的接口中的函数，例如我要监听点击事件我就实现一下IPointerClickHandler然后挂在物体上就好了。这个技巧在很早的时候我在雨松的文章第一次看到，那时候也是",{"type":11,"children":12,"toc":582},"root",[13,25,31,36,48,56,61,71,76,84,89,108,117,126,131,140,145,154,159,167,176,181,190,195,204,209,214,219,224,233,238,246,253,258,266,271,276,283,288,297,302,309,314,321,326,335,340,349,354,361,366,375,380,388,397,402,422,429,434,441,446,451,458,463,471,476,483,495,502,507,515,527,534,539,546,551,559,564,572,577],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"为什么想看看事件系统的实现",[19],{"type":14,"tag":20,"props":21,"children":22},"strong",{},[23],{"type":24,"value":17},"text",{"type":14,"tag":26,"props":27,"children":28},"p",{},[29],{"type":24,"value":30},"很简单，策划又提奇奇怪怪的需求了！比如这些事件要穿透啦，那些事件要做特殊处理啦！之类的……",{"type":14,"tag":26,"props":32,"children":33},{},[34],{"type":24,"value":35},"依旧先贴出源码地址：",{"type":14,"tag":26,"props":37,"children":38},{},[39],{"type":14,"tag":40,"props":41,"children":45},"a",{"href":42,"rel":43},"https://link.zhihu.com/?target=https%3A//bitbucket.org/Unity-Technologies/ui",[44],"nofollow",[46],{"type":24,"value":47},"Unity-Technologies / UI - Bitbucketbitbucket.org",{"type":14,"tag":15,"props":49,"children":51},{"id":50},"入手点",[52],{"type":14,"tag":20,"props":53,"children":54},{},[55],{"type":24,"value":50},{"type":14,"tag":26,"props":57,"children":58},{},[59],{"type":24,"value":60},"好那么我们从何处入手呢？当然是我们的EventTrigger了！我们都知道，我们可以通过实现以下接口来实现事件捕捉：",{"type":14,"tag":26,"props":62,"children":63},{},[64,69],{"type":14,"tag":65,"props":66,"children":68},"img",{"alt":65,"src":67},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-fed09bee3103f18eb1ee5938dbfdc812_hd.jpg",[],{"type":24,"value":70},"大家都爱用的EventTrigger",{"type":14,"tag":26,"props":72,"children":73},{},[74],{"type":24,"value":75},"具体怎么做我想大家已经明白了，也就是实现上线的接口中的函数，例如我要监听点击事件我就实现一下IPointerClickHandler然后挂在物体上就好了。这个技巧在很早的时候我在雨松的文章第一次看到，那时候也是4.6时期UGUI刚出来的时候发现的。由于和当初的NGUI很像所以被大家广泛使用，但是也会发现如果全部实现了接口但是不实现的话可能会影响上层例如ScrollView的监听，下面我们看下去也可以知道到底是为啥。",{"type":14,"tag":15,"props":77,"children":79},{"id":78},"顺藤摸瓜",[80],{"type":14,"tag":20,"props":81,"children":82},{},[83],{"type":24,"value":78},{"type":14,"tag":26,"props":85,"children":86},{},[87],{"type":24,"value":88},"既然我们已经找到了这个宝贝，那我们就可以通过查找引用大法，顺藤摸瓜看看到底是什么地方在调用我们实现的接口。",{"type":14,"tag":26,"props":90,"children":91},{},[92,94,99,101,106],{"type":24,"value":93},"最后理出来所有事件的入口其实都是放在",{"type":14,"tag":20,"props":95,"children":96},{},[97],{"type":24,"value":98},"EventSystem",{"type":24,"value":100},"当中，而具体处理则是放在了",{"type":14,"tag":20,"props":102,"children":103},{},[104],{"type":24,"value":105},"InputModule",{"type":24,"value":107},"里面。在刚刚Enable的时候会更新输入模块列表，也就是我们可以看到的StandaloneInputModule以及TouchInputModule：",{"type":14,"tag":26,"props":109,"children":110},{},[111,115],{"type":14,"tag":65,"props":112,"children":114},{"alt":65,"src":113},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-8df2e07d1b1c5d050ce04c0afd436b16_hd.jpg",[],{"type":24,"value":116},"初始化InputModule",{"type":14,"tag":26,"props":118,"children":119},{},[120,124],{"type":14,"tag":65,"props":121,"children":123},{"alt":65,"src":122},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-054935593d03e1601cdf74d9e29839b0_hd.jpg",[],{"type":24,"value":125},"Unity自己提供的各种InputModule",{"type":14,"tag":26,"props":127,"children":128},{},[129],{"type":24,"value":130},"在EventSystem的Update当中就会分别调用这些InputModule",{"type":14,"tag":26,"props":132,"children":133},{},[134,138],{"type":14,"tag":65,"props":135,"children":137},{"alt":65,"src":136},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-8f1c906ba904af7ef5d374a45992a9e7_hd.jpg",[],{"type":24,"value":139},"EventSystem主循环",{"type":14,"tag":26,"props":141,"children":142},{},[143],{"type":24,"value":144},"首先Tick所有的输入模块，然后选出一个当前在使用的输入模块中的Process进行处理。",{"type":14,"tag":26,"props":146,"children":147},{},[148,152],{"type":14,"tag":65,"props":149,"children":151},{"alt":65,"src":150},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-0e03e0e59611f1fac21575bb3cc56b8f_hd.jpg",[],{"type":24,"value":153},"EventSystem处理函数",{"type":14,"tag":26,"props":155,"children":156},{},[157],{"type":24,"value":158},"最前面是判断是否处于聚焦状态，其实也就只是应用程序的聚焦状态。其中中间是针对Navigation也就是类似于通过键盘上下左右或者手柄进行UI位置切换的操作。最下面两句才是针对所有的Touch以及Mouse的操作的处理。",{"type":14,"tag":15,"props":160,"children":162},{"id":161},"触摸事件处理",[163],{"type":14,"tag":20,"props":164,"children":165},{},[166],{"type":24,"value":161},{"type":14,"tag":26,"props":168,"children":169},{},[170,174],{"type":14,"tag":65,"props":171,"children":173},{"alt":65,"src":172},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-88eee10ae51d59b799637945e8117fce_hd.jpg",[],{"type":24,"value":175},"处理输入事件",{"type":14,"tag":26,"props":177,"children":178},{},[179],{"type":24,"value":180},"首先看看，首先获取Pointer数据，然后对该数据进行处理。",{"type":14,"tag":15,"props":182,"children":184},{"id":183},"首先处理点击事件-processtouchpress",[185],{"type":14,"tag":20,"props":186,"children":187},{},[188],{"type":24,"value":189},"首先处理点击事件 ProcessTouchPress",{"type":14,"tag":26,"props":191,"children":192},{},[193],{"type":24,"value":194},"首先判断是为按下事件还是释放事件",{"type":14,"tag":26,"props":196,"children":197},{},[198,202],{"type":14,"tag":65,"props":199,"children":201},{"alt":65,"src":200},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-9947ebbae68433f48ef3a929a8b2001c_hd.jpg",[],{"type":24,"value":203},"处理点击事件",{"type":14,"tag":15,"props":205,"children":207},{"id":206},"按下的情形",[208],{"type":24,"value":206},{"type":14,"tag":26,"props":210,"children":211},{},[212],{"type":24,"value":213},"首先找到Raycast找到的对象如果为按下事件，如果按下的对象并不是之前Hover的对象，则触发进入事件。然后就处理PointerDown事件，如果找不到该事件的话就触发PointerClick事件。如果多次点击的话还会增加PointerEventData的clickTime，双击间隔是固定为0.3秒钟。同时保存下拖拽初始状态，如果有相对应的处理方法IInitializePotentialDragHandler的话就一起触发。",{"type":14,"tag":15,"props":215,"children":217},{"id":216},"放开的情形",[218],{"type":24,"value":216},{"type":14,"tag":26,"props":220,"children":221},{},[222],{"type":24,"value":223},"首先触发PointUp事件。之后寻找PointClick事件，并且触发。如果不存在的话那就查看是否存在Drag事件并且执行，最后再执行PointerExit事件。",{"type":14,"tag":15,"props":225,"children":227},{"id":226},"之后处理move以及drag事件",[228],{"type":14,"tag":20,"props":229,"children":230},{},[231],{"type":24,"value":232},"之后处理Move以及Drag事件",{"type":14,"tag":26,"props":234,"children":235},{},[236],{"type":24,"value":237},"主要还是触发Enter、Exit以及BeginDrag还有Drag等逻辑，比较业务向也就不再写了。",{"type":14,"tag":15,"props":239,"children":241},{"id":240},"点击事件处理",[242],{"type":14,"tag":20,"props":243,"children":244},{},[245],{"type":24,"value":240},{"type":14,"tag":26,"props":247,"children":248},{},[249],{"type":14,"tag":65,"props":250,"children":252},{"alt":65,"src":251},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e45c89369a8c438b54d3b8169863a8d6_hd.jpg",[],{"type":14,"tag":26,"props":254,"children":255},{},[256],{"type":24,"value":257},"写得比Touch更加紧凑，左键中建以及右键的处理都是分开的。而且实现方式与Touch也太像了，所以也就不再赘述了。",{"type":14,"tag":15,"props":259,"children":261},{"id":260},"射线检测",[262],{"type":14,"tag":20,"props":263,"children":264},{},[265],{"type":24,"value":260},{"type":14,"tag":26,"props":267,"children":268},{},[269],{"type":24,"value":270},"射线检测绝对是其中非常重要的一个东西，在NGUI中我们都知道事件触发靠射线检测，同样在UGUI中射线检测也是同样的存在。",{"type":14,"tag":26,"props":272,"children":273},{},[274],{"type":24,"value":275},"我们在上面的Touch事件处理的地方会看到这么一段代码：",{"type":14,"tag":26,"props":277,"children":278},{},[279],{"type":14,"tag":65,"props":280,"children":282},{"alt":65,"src":281},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-c17f0ef64287112427f0a1f74ed2b323_hd.jpg",[],{"type":14,"tag":26,"props":284,"children":285},{},[286],{"type":24,"value":287},"通过射线raycast来检测我们的射线数据中包含哪些东西。并且取其中的第一个并且进行事件触发。这个数据我们可以具体看RaycastResult这个类：",{"type":14,"tag":26,"props":289,"children":290},{},[291,295],{"type":14,"tag":65,"props":292,"children":294},{"alt":65,"src":293},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-942bda4b880dac3f71dfe3c00285c067_hd.jpg",[],{"type":24,"value":296},"射线检测的结果",{"type":14,"tag":26,"props":298,"children":299},{},[300],{"type":24,"value":301},"而具体cast的步骤则在下面这个函数中，其实是依次调用所有的Raycaster中的射线检测。",{"type":14,"tag":26,"props":303,"children":304},{},[305],{"type":14,"tag":65,"props":306,"children":308},{"alt":65,"src":307},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-116715b89672f76517469347d2d35ae1_hd.jpg",[],{"type":14,"tag":26,"props":310,"children":311},{},[312],{"type":24,"value":313},"我们会去Raycaster Manager中寻找所有的Raycaster。所有Raycast在Enable的时候就会自动注册到Raycaster Manager中",{"type":14,"tag":26,"props":315,"children":316},{},[317],{"type":14,"tag":65,"props":318,"children":320},{"alt":65,"src":319},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-61ed280285611f5e56d858e174fb8846_hd.jpg",[],{"type":14,"tag":26,"props":322,"children":323},{},[324],{"type":24,"value":325},"现在就明白Graphic Raycaster是用来做什么的了吧。当然除了Graphic Raycaster以外还有各种各样的Raycaster:",{"type":14,"tag":26,"props":327,"children":328},{},[329,333],{"type":14,"tag":65,"props":330,"children":332},{"alt":65,"src":331},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-6307b8a8e615d5c840203f91244d0e74_hd.jpg",[],{"type":24,"value":334},"Unity内部提供的各类Raycaster",{"type":14,"tag":26,"props":336,"children":337},{},[338],{"type":24,"value":339},"我们这里就只着重看一下Graphic Raycaster",{"type":14,"tag":15,"props":341,"children":343},{"id":342},"graphic-raycaster",[344],{"type":14,"tag":20,"props":345,"children":346},{},[347],{"type":24,"value":348},"Graphic Raycaster",{"type":14,"tag":26,"props":350,"children":351},{},[352],{"type":24,"value":353},"核心方法就是经过重写的Raycaster，这个函数帮助我们检测画布上被射线触发的地方并且返回结果。",{"type":14,"tag":26,"props":355,"children":356},{},[357],{"type":14,"tag":65,"props":358,"children":360},{"alt":65,"src":359},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e1049a6eef487dc07f5163b2f5df3a51_hd.jpg",[],{"type":14,"tag":26,"props":362,"children":363},{},[364],{"type":24,"value":365},"其实就是普通的射线检测，无非需要针对多屏幕、以及不同的Block模式进行判断，最终调用的是另外一个Raycast。",{"type":14,"tag":26,"props":367,"children":368},{},[369,373],{"type":14,"tag":65,"props":370,"children":372},{"alt":65,"src":371},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-d37195700a8277f762d5da5382e23fd5_hd.jpg",[],{"type":24,"value":374},"找到被射线穿过的Graphic",{"type":14,"tag":26,"props":376,"children":377},{},[378],{"type":24,"value":379},"获得射线所穿过的Graphic，将这些结果逐一加入到Result当中。在放入到Result之前会将这些Graphic根据深度进行排序。当然最终结果的筛选规则会有更多，例如是否在摄像机后面、是否大于最大射线距离等等。最终得到的就是我们最终射线结果。",{"type":14,"tag":15,"props":381,"children":383},{"id":382},"如何执行事件",[384],{"type":14,"tag":20,"props":385,"children":386},{},[387],{"type":24,"value":382},{"type":14,"tag":15,"props":389,"children":391},{"id":390},"直接调用事件-executeeventsexecute",[392],{"type":14,"tag":20,"props":393,"children":394},{},[395],{"type":24,"value":396},"直接调用事件 ExecuteEvents.Execute",{"type":14,"tag":26,"props":398,"children":399},{},[400],{"type":24,"value":401},"核心方法为ExecuteEvents.Execute，如果需要触发事件就调用该方法吧！我们需要向其中传3个参数：",{"type":14,"tag":403,"props":404,"children":405},"ul",{},[406,412,417],{"type":14,"tag":407,"props":408,"children":409},"li",{},[410],{"type":24,"value":411},"一个是传递的GameObject，也就是挂载事件的对象。",{"type":14,"tag":407,"props":413,"children":414},{},[415],{"type":24,"value":416},"第二个参数则是PointEventData，这个参数最终会传给事件处理函数，通常是UGUI自己对输入进行处理并且输出的。",{"type":14,"tag":407,"props":418,"children":419},{},[420],{"type":24,"value":421},"最后一个参数就是一个传入的delegate，用于接收各种EventData，最后经由一个验证函数来获得具体的EventData。",{"type":14,"tag":26,"props":423,"children":424},{},[425],{"type":14,"tag":65,"props":426,"children":428},{"alt":65,"src":427},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-de00fc2cb10360aede52694d0cb5710c_hd.jpg",[],{"type":14,"tag":26,"props":430,"children":431},{},[432],{"type":24,"value":433},"接下来我们就看一下具体是如何针对一个GameObject进行事件调用的：",{"type":14,"tag":26,"props":435,"children":436},{},[437],{"type":14,"tag":65,"props":438,"children":440},{"alt":65,"src":439},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-d6090585e8a6f6c36c638d487b363ec1_hd.jpg",[],{"type":14,"tag":26,"props":442,"children":443},{},[444],{"type":24,"value":445},"首先调用GetEventList然后获得具体有哪些Handler，然后逐一进行调用。如果handler的数量大于0则返回true。",{"type":14,"tag":26,"props":447,"children":448},{},[449],{"type":24,"value":450},"我们看一下获取EventList的规则：",{"type":14,"tag":26,"props":452,"children":453},{},[454],{"type":14,"tag":65,"props":455,"children":457},{"alt":65,"src":456},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-2d6a993c83da534a4c0ec78939d144b4_hd.jpg",[],{"type":14,"tag":26,"props":459,"children":460},{},[461],{"type":24,"value":462},"其实也只是判断了一下是否为IEventSystemHandler这么简单。",{"type":14,"tag":15,"props":464,"children":466},{"id":465},"向上查找",[467],{"type":14,"tag":20,"props":468,"children":469},{},[470],{"type":24,"value":465},{"type":14,"tag":26,"props":472,"children":473},{},[474],{"type":24,"value":475},"在很多地方例如Click事件触发的时候往往不是在该射线检测到的GameObject上，而是会向上查找Handler:",{"type":14,"tag":26,"props":477,"children":478},{},[479],{"type":14,"tag":65,"props":480,"children":482},{"alt":65,"src":481},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e50bb99557b9d0a2b43b77f5a92abda2_hd.jpg",[],{"type":14,"tag":26,"props":484,"children":485},{},[486,488,493],{"type":24,"value":487},"其中核心方法就是",{"type":14,"tag":20,"props":489,"children":490},{},[491],{"type":24,"value":492},"GetEventHandler",{"type":24,"value":494},"，我们看看其中的实现：",{"type":14,"tag":26,"props":496,"children":497},{},[498],{"type":14,"tag":65,"props":499,"children":501},{"alt":65,"src":500},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-ffd1913afa8218040803d0dd1889f696_hd.jpg",[],{"type":14,"tag":26,"props":503,"children":504},{},[505],{"type":24,"value":506},"获得UGUI会从射线检测到的GameObject开始，不断向上查找，直到根为止，如果找到则返回，如果找不到可以处理的相应事件则直接返回Null。",{"type":14,"tag":15,"props":508,"children":510},{"id":509},"事件链",[511],{"type":14,"tag":20,"props":512,"children":513},{},[514],{"type":24,"value":509},{"type":14,"tag":26,"props":516,"children":517},{},[518,520,525],{"type":24,"value":519},"除了获取EventHandler这种情形之外，还有触发GameObject树结构中所有挂载事件的物体。这个时候就有了我们上面看到的",{"type":14,"tag":20,"props":521,"children":522},{},[523],{"type":24,"value":524},"ExecuteHierarchy",{"type":24,"value":526},"，它的作用就是调用Hierarchy中所有挂载事件的GameObject。",{"type":14,"tag":26,"props":528,"children":529},{},[530],{"type":14,"tag":65,"props":531,"children":533},{"alt":65,"src":532},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-0c8983d7cf4d5e22c296ca5af93ac859_hd.jpg",[],{"type":14,"tag":26,"props":535,"children":536},{},[537],{"type":24,"value":538},"我们看到，该函数首先获取事件链，然后逐个进行触发，比较重要的就是获取事件链的过程：",{"type":14,"tag":26,"props":540,"children":541},{},[542],{"type":14,"tag":65,"props":543,"children":545},{"alt":65,"src":544},"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-3c2ddef8ca9458a8235db5cb8278bcb3_hd.jpg",[],{"type":14,"tag":26,"props":547,"children":548},{},[549],{"type":24,"value":550},"从下往上进行遍历，将所有拥有事件的对象通通都调用一遍就是这个事件链的本质。",{"type":14,"tag":15,"props":552,"children":554},{"id":553},"事件触发机制总结",[555],{"type":14,"tag":20,"props":556,"children":557},{},[558],{"type":24,"value":553},{"type":14,"tag":26,"props":560,"children":561},{},[562],{"type":24,"value":563},"不同的组件触发事件的方法都不一样，比如我们上面 看到的OnPointDown是用事件链，而PointClick则是使用的向上查找。我们要防止类似于PointClick这类事件，因为如果下层已经实现了该回调则上层回调则再也无法被调用到，因为已经被下层拦截，所以也不要一口气把所有的事件全给重载了，要用的时候再加呗。",{"type":14,"tag":15,"props":565,"children":567},{"id":566},"总结",[568],{"type":14,"tag":20,"props":569,"children":570},{},[571],{"type":24,"value":566},{"type":14,"tag":26,"props":573,"children":574},{},[575],{"type":24,"value":576},"总的来说UGUI的事件系统并不复杂，各个部分还是较为清晰的，如果我们的UI编写当中遇到了问题，或者我们要自己魔改一个组件出来都可以通过看源码来进行解决。",{"type":14,"tag":26,"props":578,"children":579},{},[580],{"type":24,"value":581},"了解了其中原理之后就算是事件穿透之类的也完全可以通过源码实现来倒推解决方案，不用到处搜索解决方案了！",{"title":7,"searchDepth":583,"depth":583,"links":584},2,[585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601],{"id":17,"depth":583,"text":17},{"id":50,"depth":583,"text":50},{"id":78,"depth":583,"text":78},{"id":161,"depth":583,"text":161},{"id":183,"depth":583,"text":189},{"id":206,"depth":583,"text":206},{"id":216,"depth":583,"text":216},{"id":226,"depth":583,"text":232},{"id":240,"depth":583,"text":240},{"id":260,"depth":583,"text":260},{"id":342,"depth":583,"text":348},{"id":382,"depth":583,"text":382},{"id":390,"depth":583,"text":396},{"id":465,"depth":583,"text":465},{"id":509,"depth":583,"text":509},{"id":553,"depth":583,"text":553},{"id":566,"depth":583,"text":566},"markdown","content:unity:2019-08-12-ugui-eventsystem-sourcecode.md","content","unity/2019-08-12-ugui-eventsystem-sourcecode.md","md","2019-08-12",[609,619,746,795,847,860,972],{"title":610,"_path":611,"children":612},"Art","/art",[613,616],{"title":614,"_path":615},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":617,"_path":618},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":620,"_path":621,"children":622},"Dotnet","/dotnet",[623,626,629,632,635,638,641,644,647,650,653,656,659,662,665,668,671,674,677,680,683,686,689,692,695,698,701,704,707,710,713,716,719,722,725,728,731,734,737,740,743],{"title":624,"_path":625},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":627,"_path":628},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":630,"_path":631},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":633,"_path":634},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":636,"_path":637},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":639,"_path":640},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":642,"_path":643},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":645,"_path":646},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":648,"_path":649},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":651,"_path":652},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":654,"_path":655},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":657,"_path":658},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":660,"_path":661},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":663,"_path":664},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":666,"_path":667},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":669,"_path":670},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":672,"_path":673},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":675,"_path":676},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":678,"_path":679},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":681,"_path":682},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":684,"_path":685},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":687,"_path":688},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":690,"_path":691},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":693,"_path":694},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":696,"_path":697},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":699,"_path":700},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":702,"_path":703},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":705,"_path":706},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":708,"_path":709},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":711,"_path":712},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":714,"_path":715},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":717,"_path":718},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":720,"_path":721},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":723,"_path":724},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":726,"_path":727},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":729,"_path":730},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":732,"_path":733},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":735,"_path":736},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":738,"_path":739},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":741,"_path":742},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":744,"_path":745},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":747,"_path":748,"children":749},"Game","/game",[750,753,756,759,762,765,768,771,774,777,780,783,786,789,792],{"title":751,"_path":752},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":754,"_path":755},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":757,"_path":758},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":760,"_path":761},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":763,"_path":764},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":766,"_path":767},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":769,"_path":770},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":772,"_path":773},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":775,"_path":776},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":778,"_path":779},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":781,"_path":782},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":784,"_path":785},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":787,"_path":788},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":790,"_path":791},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":793,"_path":794},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":796,"_path":797,"children":798},"Gyj","/gyj",[799,802,805,808,811,814,817,820,823,826,829,832,835,838,841,844],{"title":800,"_path":801},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":803,"_path":804},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":806,"_path":807},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":809,"_path":810},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":812,"_path":813},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":815,"_path":816},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":818,"_path":819},"玩法","/gyj/2022-08-22-wanfa",{"title":821,"_path":822},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":824,"_path":825},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":827,"_path":828},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":830,"_path":831},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":833,"_path":834},"门派内容相关","/gyj/2022-11-17-sect",{"title":836,"_path":837},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":839,"_path":840},"种植","/gyj/2022-12-01-zhongzhi",{"title":842,"_path":843},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":845,"_path":846},"跑商","/gyj/2023-11-01-paoshang",{"title":848,"_path":849,"children":850},"Js","/js",[851,854,857],{"title":852,"_path":853},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":855,"_path":856},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":858,"_path":859},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":861,"_path":862,"children":863},"Tool","/tool",[864,867,870,873,876,879,882,885,888,891,894,897,900,903,906,909,912,915,918,921,924,927,930,933,936,939,942,945,948,951,954,957,960,963,966,969],{"title":865,"_path":866},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":868,"_path":869},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":871,"_path":872},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":874,"_path":875},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":877,"_path":878},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":880,"_path":881},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":883,"_path":884},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":886,"_path":887},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":889,"_path":890},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":892,"_path":893},"mac下brew 使用","/tool/2020-01-13-brew",{"title":895,"_path":896},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":898,"_path":899},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":901,"_path":902},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":904,"_path":905},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":907,"_path":908},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":910,"_path":911},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":913,"_path":914},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":916,"_path":917},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":919,"_path":920},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":922,"_path":923},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":925,"_path":926},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":928,"_path":929},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":931,"_path":932},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":934,"_path":935},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":937,"_path":938},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":940,"_path":941},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":943,"_path":944},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":946,"_path":947},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":949,"_path":950},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":952,"_path":953},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":955,"_path":956},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":958,"_path":959},"rider的使用","/tool/2022-08-02-rider-use",{"title":961,"_path":962},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":964,"_path":965},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":967,"_path":968},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":970,"_path":971},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":973,"_path":974,"children":975},"Unity","/unity",[976,979,982,985,988,991,994,995,998,1001,1004,1007,1010,1013,1016,1019,1022,1025,1028,1031,1034,1037,1040,1043,1046,1049,1052,1055,1058,1061,1064,1067,1070,1073,1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118,1121,1124,1127,1130,1133,1136,1139,1142,1145,1148,1151,1154,1157,1160,1163,1166,1169,1172,1175,1178,1181,1184,1187],{"title":977,"_path":978},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":980,"_path":981},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":983,"_path":984},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":986,"_path":987},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":989,"_path":990},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":992,"_path":993},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":8,"_path":4},{"title":996,"_path":997},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":999,"_path":1000},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1002,"_path":1003},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1005,"_path":1006},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1008,"_path":1009},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1011,"_path":1012},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1014,"_path":1015},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1017,"_path":1018},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1020,"_path":1021},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1023,"_path":1024},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1026,"_path":1027},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1029,"_path":1030},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1032,"_path":1033},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1035,"_path":1036},"技能系统","/unity/2020-02-15-skill-system",{"title":1038,"_path":1039},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1041,"_path":1042},"角色状态设计","/unity/2020-02-17-character-states",{"title":1044,"_path":1045},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1047,"_path":1048},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1050,"_path":1051},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1053,"_path":1054},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1056,"_path":1057},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1059,"_path":1060},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1062,"_path":1063},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1065,"_path":1066},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1068,"_path":1069},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1071,"_path":1072},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1074,"_path":1075},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1077,"_path":1078},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1080,"_path":1081},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1083,"_path":1084},"unity的addressables","/unity/2020-09-12-addressables",{"title":1086,"_path":1087},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1089,"_path":1090},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1092,"_path":1093},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1095,"_path":1096},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1098,"_path":1099},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1101,"_path":1102},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1104,"_path":1105},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1107,"_path":1108},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1110,"_path":1111},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1113,"_path":1114},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1116,"_path":1117},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1119,"_path":1120},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1122,"_path":1123},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1125,"_path":1126},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1128,"_path":1129},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1131,"_path":1132},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1134,"_path":1135},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1137,"_path":1138},"ability","/unity/2020-11-16-dotssample",{"title":1140,"_path":1141},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1143,"_path":1144},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1146,"_path":1147},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1149,"_path":1150},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1152,"_path":1153},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1155,"_path":1156},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1158,"_path":1159},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1161,"_path":1162},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1164,"_path":1165},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1167,"_path":1168},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1170,"_path":1171},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1173,"_path":1174},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1176,"_path":1177},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1179,"_path":1180},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1182,"_path":1183},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1185,"_path":1186},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1188,"_path":1189},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041996]