[{"data":1,"prerenderedAt":1548},["Reactive",2],{"content-query-1lHODSVxob":3,"content-navigation-8C37fagqQL":966},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":960,"_id":961,"_source":962,"_file":963,"_extension":964,"date":965},"/unity/2019-08-11-ugui-eventmanager","unity",false,"","一次精通 eventmanager","我们先来看看eventmanager之前unity处理事件的方法,首当其冲的就是MonoBehavior上的事件回调，可以参看MonoBehaviour文档。这是一系列的OnMouse开头的回调函数。",{"type":11,"children":12,"toc":948},"root",[13,22,39,49,54,84,107,115,120,127,135,140,145,150,156,161,166,171,180,186,209,214,220,225,230,248,253,258,266,272,308,320,325,330,338,346,351,359,367,372,390,398,406,411,419,429,437,456,461,469,477,509,517,529,537,543,548,553,567,578,583,591,597,603,632,634,749,755,760,787,795,800,808,813,821,833,838,846,852,866,875,880,888,895,900,905,910,918,923,930,935,943],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"onmouse事件",[19],{"type":20,"value":21},"text","OnMouse事件",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26,28,37],{"type":20,"value":27},"我们先来看看eventmanager之前unity处理事件的方法,首当其冲的就是MonoBehavior上的事件回调，可以参看",{"type":14,"tag":29,"props":30,"children":34},"a",{"href":31,"rel":32},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/MonoBehaviour.html",[33],"nofollow",[35],{"type":20,"value":36},"MonoBehaviour",{"type":20,"value":38},"文档。这是一系列的OnMouse开头的回调函数。",{"type":14,"tag":40,"props":41,"children":43},"pre",{"code":42},"OnMouseDown\nOnMouseDrag\nOnMouseEnter\nOnMouseExit\nOnMouseOver\nOnMouseUp\n",[44],{"type":14,"tag":45,"props":46,"children":47},"code",{"__ignoreMap":7},[48],{"type":20,"value":42},{"type":14,"tag":23,"props":50,"children":51},{},[52],{"type":20,"value":53},"这个处理方式有以下几个特点：",{"type":14,"tag":55,"props":56,"children":57},"ul",{},[58,64,69,74,79],{"type":14,"tag":59,"props":60,"children":61},"li",{},[62],{"type":20,"value":63},"MonoBehavior所在的GameObject需要有Collider碰撞组件，并且Physics.queriesHitTriggers设置为True，这个在Edit -> Physics Settings -> Physics or Physics2D中设置。",{"type":14,"tag":59,"props":65,"children":66},{},[67],{"type":20,"value":68},"或者MonoBehavior所在的GameObject存在GUIElement。",{"type":14,"tag":59,"props":70,"children":71},{},[72],{"type":20,"value":73},"OnMouse处理函数可以是协程。",{"type":14,"tag":59,"props":75,"children":76},{},[77],{"type":20,"value":78},"GameObject所有MonoBehavior实现OnMouse的函数都会调用。",{"type":14,"tag":59,"props":80,"children":81},{},[82],{"type":20,"value":83},"Collider或GUIElement的层级顺序，会遮挡事件的传递。",{"type":14,"tag":23,"props":85,"children":86},{},[87,89,96,98,105],{"type":20,"value":88},"按照官方的解释，这是GUI事件的一部分，参看",{"type":14,"tag":29,"props":90,"children":93},{"href":91,"rel":92},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/EventFunctions.html",[33],[94],{"type":20,"value":95},"EventFunctions",{"type":20,"value":97},"。设计的初衷也是为了GUI服务的。参看",{"type":14,"tag":29,"props":99,"children":102},{"href":100,"rel":101},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/ExecutionOrder.html",[33],[103],{"type":20,"value":104},"ExecutionOrder",{"type":20,"value":106},"最后的unity执行流程图，会发现OnMouse事件是一个独立的Input Event。",{"type":14,"tag":23,"props":108,"children":109},{},[110],{"type":14,"tag":111,"props":112,"children":114},"img",{"alt":111,"src":113},"/images/2019-08-11-ugui-eventmanager/20171106145111819.png",[],{"type":14,"tag":23,"props":116,"children":117},{},[118],{"type":20,"value":119},"可以看到，OnMouse事件在，Physics事件之后，Update之前，记住这个顺序，后面会用到。并且，这是引擎本身回调的，就引擎使用而言可以看成是，消息驱动。至于引擎的实现，可是轮询也可以是消息驱动。",{"type":14,"tag":121,"props":122,"children":124},"h4",{"id":123},"在update中輪詢input物件",[125],{"type":20,"value":126},"在Update中輪詢Input物件",{"type":14,"tag":40,"props":128,"children":130},{"code":129},"public class ExampleClass : MonoBehaviour\n{ \n    public void Update() \n    { \n       if (Input.GetButtonDown(\"Fire1\")) \n       { \n            Debug.Log(Input.mousePosition); \n       } \n    }\n}\n",[131],{"type":14,"tag":45,"props":132,"children":133},{"__ignoreMap":7},[134],{"type":20,"value":129},{"type":14,"tag":23,"props":136,"children":137},{},[138],{"type":20,"value":139},"这是官方的例子，Input拥有各种输入设备的数据信息。每一帧不断的检测，查看有没有需要处理的输入信息，利用GameObject本身的层级顺序来控制Update的调用顺序，从而控制了Input的处理顺序。",{"type":14,"tag":23,"props":141,"children":142},{},[143],{"type":20,"value":144},"Input的信息由引擎自己设置的，明显Unity需要实现不同平台的事件处理，然后对Input进行设置。另外有一个InputManager面板用来配置Input相关属性的，在Edit -> Physics Settings -> Input中。",{"type":14,"tag":23,"props":146,"children":147},{},[148],{"type":20,"value":149},"由前面的执行流程图可知，OnMouse事件会在Update之前调用，当然我们也可以在OnMouse中使用Input，这样就变成了消息驱动，而不是轮询了。但这样的缺点是，事件必须由touch或pointer碰撞触发，比如键盘或控制器按钮的事件就没有办法捕获了。",{"type":14,"tag":15,"props":151,"children":153},{"id":152},"eventsystem",[154],{"type":20,"value":155},"EventSystem",{"type":14,"tag":23,"props":157,"children":158},{},[159],{"type":20,"value":160},"EventSystem组件主要负责处理输入、射线投射以及发送事件。一个场景中只能有一个EventSystem组件，并且需要BaseInputModule类型组件的协助才能工作。EventSystem在一开始的时候会把自己所属对象下的BaseInputModule类型组件加到一个内部列表，并且在每个Update周期通过接口UpdateModules接口调用这些基本输入模块的UpdateModule接口，然后BaseInputModule会在UpdateModule接口中将自己的状态修改成'Updated'，之后BaseInputModule的Process接口才会被调用。",{"type":14,"tag":23,"props":162,"children":163},{},[164],{"type":20,"value":165},"BaseInputModule是一个基类模块，负责发送输入事件（点击、拖拽、选中等）到具体对象。EventSystem下的所有输入模块都必须继承自BaseInputModule组件。StandaloneInputModule和TouchInputModule组件是系统提供的标准输入模块和触摸输入模块，我们可以通过继承BaseInputModule实现自己的输入模块。",{"type":14,"tag":23,"props":167,"children":168},{},[169],{"type":20,"value":170},"BaseRaycaster也是一个基类，前面说的输入模块要检测到鼠标事件必须有射线投射组件才能确定目标对象。系统实现的射线投射类组件有PhysicsRaycaster, Physics2DRaycaster, GraphicRaycaster。这个模块也是可以自己继承BaseRaycaster实现个性化定制。",{"type":14,"tag":23,"props":172,"children":173},{},[174],{"type":14,"tag":175,"props":176,"children":177},"strong",{},[178],{"type":20,"value":179},"总的来说，EventSystem负责管理，BaseInputModule负责输入，BaseRaycaster负责确定目标对象，目标对象负责接收事件并处理，然后一个完整的事件系统就有了。",{"type":14,"tag":15,"props":181,"children":183},{"id":182},"eventsystem與onmouse的區別",[184],{"type":20,"value":185},"EventSystem與OnMouse的區別",{"type":14,"tag":55,"props":187,"children":188},{},[189,194,199,204],{"type":14,"tag":59,"props":190,"children":191},{},[192],{"type":20,"value":193},"OnMouse 会先于 EventSystem 触发。因为EventSystem的源码显示，其在Update中去轮询检测处理Input的输入。而OnMouse事件先于Update调用。",{"type":14,"tag":59,"props":195,"children":196},{},[197],{"type":20,"value":198},"OnMouse脚本需要在同一个GameObject上挂载Collider才能检测。EventSystem的脚本会根据子节点的Collider来触发(平行节点不行)。",{"type":14,"tag":59,"props":200,"children":201},{},[202],{"type":20,"value":203},"Rigidbody有个特点，会把子节点所有的Collider统一检测和处理。也就是说，OnMouse脚本与RigidBody在一起就可以检测所有的子节点Collider，而不再需要同级的Collider。而EventSystem的脚本则不依赖于Rigidbody，都可以检测子节点的Collider。",{"type":14,"tag":59,"props":205,"children":206},{},[207],{"type":20,"value":208},"OnMouse依赖于Tag为MainCamera相机的Culling Mask来过滤射线。EventSystem则是依赖挂载Physics Raycaster的相机。",{"type":14,"tag":23,"props":210,"children":211},{},[212],{"type":20,"value":213},"另外，当在有Collider的子节点都挂载OnMouse或EventSystem事件的时候，只会触发一次事件。但在同一个GameObject上挂载多个脚本，就会触发多次。",{"type":14,"tag":15,"props":215,"children":217},{"id":216},"unity-raycasters-和事件处理",[218],{"type":20,"value":219},"Unity Raycasters 和事件处理",{"type":14,"tag":23,"props":221,"children":222},{},[223],{"type":20,"value":224},"Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。",{"type":14,"tag":23,"props":226,"children":227},{},[228],{"type":20,"value":229},"在 Unity Raycasters 中有三种类型的 Raycasters:",{"type":14,"tag":55,"props":231,"children":232},{},[233,238,243],{"type":14,"tag":59,"props":234,"children":235},{},[236],{"type":20,"value":237},"Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体",{"type":14,"tag":59,"props":239,"children":240},{},[241],{"type":20,"value":242},"Physics 2D Raycaster - 用于检测 2D 物体",{"type":14,"tag":59,"props":244,"children":245},{},[246],{"type":20,"value":247},"Physics Raycaster - 用于检测 3D 物体",{"type":14,"tag":23,"props":249,"children":250},{},[251],{"type":20,"value":252},"接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。",{"type":14,"tag":23,"props":254,"children":255},{},[256],{"type":20,"value":257},"Raycast 在 Event System 流程中所处的位置大致如下图:",{"type":14,"tag":23,"props":259,"children":260},{},[261],{"type":14,"tag":111,"props":262,"children":265},{"alt":263,"src":264},"unity_event_system_raycaster.png","/images/2019-08-11-ugui-eventmanager/unity_event_system_raycaster.png",[],{"type":14,"tag":267,"props":268,"children":270},"h3",{"id":269},"unity的事件处理",[271],{"type":20,"value":269},{"type":14,"tag":23,"props":273,"children":274},{},[275,277,283,285,291,293,299,301,306],{"type":20,"value":276},"当 Event System 处理输入事件并找到合适的接收者，将该接收者作为参数执行 ExecuteEvents 类中的 ",{"type":14,"tag":45,"props":278,"children":280},{"className":279},[],[281],{"type":20,"value":282},"Execute",{"type":20,"value":284}," 或 ",{"type":14,"tag":45,"props":286,"children":288},{"className":287},[],[289],{"type":20,"value":290},"ExecuteHierarchy",{"type":20,"value":292}," 方法；如果此时该接收对象 GameObject 绑定了 EventTrigger 组件，由于 EventTrigger 类实现了所有常用的 UI 事件接口(即实现了 ",{"type":14,"tag":45,"props":294,"children":296},{"className":295},[],[297],{"type":20,"value":298},"IEventSystemHandler",{"type":20,"value":300}," 接口)，因此会执行 EventTrigger 类中相应事件接口对应的方法，转而执行 EventTrigger 类的 ",{"type":14,"tag":45,"props":302,"children":304},{"className":303},[],[305],{"type":20,"value":282},{"type":20,"value":307}," 方法，最终回调在编辑器中设定的方法。",{"type":14,"tag":23,"props":309,"children":310},{},[311,313,318],{"type":20,"value":312},"所以如果当一个点击事件被触发,首先会拿到射线检测返回的gameobject，然后搜索当前的",{"type":14,"tag":175,"props":314,"children":315},{},[316],{"type":20,"value":317},"gameobejct以及其父节点",{"type":20,"value":319},"上面是否有实现了IPointerDownHandler的接口的控件，如果有实现了的就把newPressed赋值为这个控件的gameobject，如果没有，就去搜索实现了IPointerClickHandler这个接口的控件，如果没有在自身上找到的话，会依次地向父节点层层搜索，直到找到为止，然后依然是把newPressed赋值为这个控件的gameobject。接着会按照类似的方式去搜索自身以及父节点上是否有实现了IDragHandler的组件，如果有的话紧接着便会去触发OnPointerDown和OnDrag方法。",{"type":14,"tag":23,"props":321,"children":322},{},[323],{"type":20,"value":324},"当鼠标按下并抬起的时候，首先会触发IPointerUpHandler接口中的函数OnPointerUp()，然后会再次搜索当前gameobject以及其父节点上是否有实现了IPointerClickHandler接口的控件，如果有的的话，会和之前存下来的newPressd进行比较，看两者是否为同一个gameobject。如果两者为同一个gameobject的话就会触发Click事件。",{"type":14,"tag":23,"props":326,"children":327},{},[328],{"type":20,"value":329},"因此我们需要注意，如果一个物体没有父节点的话，那么只实现IPointerClickHandler接口便是可以接收到点击事件的。如果他有父节点，父节点挂载的脚本也是只实现IPointerClickHandler接口的话，点击事件也是可以接收到的。但是如果父节点实现了IPointerDownHandler和IPointerClickHandler接口，子节点只实现IPointerClickHandler接口的话，两者便会都接收不到点击事件，需要子节点也实现IPointerDownHandler这个接口才行。",{"type":14,"tag":23,"props":331,"children":332},{},[333],{"type":14,"tag":111,"props":334,"children":337},{"alt":335,"src":336},"unity_event_trigger_2.jpeg","/images/2019-08-11-ugui-eventmanager/unity_event_trigger_2.jpeg",[],{"type":14,"tag":23,"props":339,"children":340},{},[341],{"type":14,"tag":175,"props":342,"children":343},{},[344],{"type":20,"value":345},"事件透传",{"type":14,"tag":23,"props":347,"children":348},{},[349],{"type":20,"value":350},"如果事件被接收后,就不会再被父节点的监听处理,如果需要,则得使用message手动触发",{"type":14,"tag":40,"props":352,"children":354},{"code":353},"using UnityEngine;\nusing System.Collections;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n \npublic class Test : MonoBehaviour,IPointerClickHandler ,IPointerDownHandler,IPointerUpHandler\n{ \n \n    //监听按下\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.pointerDownHandler);\n    }\n \n    //监听抬起\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.pointerUpHandler);\n    }\n \n    //监听点击\n    public void OnPointerClick(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.submitHandler);\n        PassEvent(eventData,ExecuteEvents.pointerClickHandler);\n    }\n \n \n    //把事件透下去\n    public void  PassEvent\u003CT>(PointerEventData data,ExecuteEvents.EventFunction\u003CT> function)\n        where T : IEventSystemHandler\n    {\n        List\u003CRaycastResult> results = new List\u003CRaycastResult>();\n        EventSystem.current.RaycastAll(data, results); \n        GameObject current = data.pointerCurrentRaycast.gameObject ;\n        for(int i =0; i\u003C results.Count;i++)\n        {\n            if(current!= results[i].gameObject)\n            {\n                ExecuteEvents.Execute(results[i].gameObject, data,function);\n                //RaycastAll后ugui会自己排序，如果你只想响应透下去的最近的一个响应，这里ExecuteEvents.Execute后直接break就行。\n            }\n        }\n    }\n}\n",[355],{"type":14,"tag":45,"props":356,"children":357},{"__ignoreMap":7},[358],{"type":20,"value":353},{"type":14,"tag":23,"props":360,"children":361},{},[362],{"type":14,"tag":175,"props":363,"children":364},{},[365],{"type":20,"value":366},"事件忽略",{"type":14,"tag":23,"props":368,"children":369},{},[370],{"type":20,"value":371},"如果需要当前节点及子节点都不响应UI事件",{"type":14,"tag":55,"props":373,"children":374},{},[375,380,385],{"type":14,"tag":59,"props":376,"children":377},{},[378],{"type":20,"value":379},"勾选Raycast Targe",{"type":14,"tag":59,"props":381,"children":382},{},[383],{"type":20,"value":384},"在当前节点上添加一个组件CanvasGroup，然后取消其Interactable和Blocks Raycasts的勾选",{"type":14,"tag":59,"props":386,"children":387},{},[388],{"type":20,"value":389},"添加脚本",{"type":14,"tag":40,"props":391,"children":393},{"code":392},"using UnityEngine;\nusing System.Collections;\npublic class TouchIgnore : MonoBehaviour, ICanvasRaycastFilter\n{\n    public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)\n    {\n        return false;\n    }\n}\n",[394],{"type":14,"tag":45,"props":395,"children":396},{"__ignoreMap":7},[397],{"type":20,"value":392},{"type":14,"tag":23,"props":399,"children":400},{},[401],{"type":14,"tag":175,"props":402,"children":403},{},[404],{"type":20,"value":405},"事件阻止",{"type":14,"tag":23,"props":407,"children":408},{},[409],{"type":20,"value":410},"父子之间阻止向父级传递事件,只要在该对象加上一个EventTrigger起就可以了,代表这个事件已经被处理了.",{"type":14,"tag":40,"props":412,"children":414},{"code":413}," this.GameObject.GetOrAddComponent\u003CEventTrigger>()\n",[415],{"type":14,"tag":45,"props":416,"children":417},{"__ignoreMap":7},[418],{"type":20,"value":413},{"type":14,"tag":23,"props":420,"children":421},{},[422,424],{"type":20,"value":423},"比如一个案例,点击最顶级的遮罩(白色部分)窗口关闭,但是点击到窗口内部(红色部分)不做处理\n",{"type":14,"tag":111,"props":425,"children":428},{"alt":426,"src":427},"image-20200727011714966","/images/2019-08-11-ugui-eventmanager/image-20200727011714966.png",[],{"type":14,"tag":23,"props":430,"children":431},{},[432],{"type":14,"tag":175,"props":433,"children":434},{},[435],{"type":20,"value":436},"ugui事件和射线穿透的问题",{"type":14,"tag":23,"props":438,"children":439},{},[440,442,447,449,454],{"type":20,"value":441},"eventsystem也是向场景发送射线,然后找到",{"type":14,"tag":175,"props":443,"children":444},{},[445],{"type":20,"value":446},"第一个",{"type":20,"value":448},"触碰的有",{"type":14,"tag":175,"props":450,"children":451},{},[452],{"type":20,"value":453},"Raycast Target",{"type":20,"value":455},"的game object.然后在向这个gameobject的父级去找.",{"type":14,"tag":23,"props":457,"children":458},{},[459],{"type":20,"value":460},"所有如果ui即使全屏了,但是没有设置Raycast Target,仍然会穿透ui.射线会检测到下面的立方体,如图:",{"type":14,"tag":23,"props":462,"children":463},{},[464],{"type":14,"tag":111,"props":465,"children":468},{"alt":466,"src":467},"image-20200727010842873","/images/2019-08-11-ugui-eventmanager/image-20200727010842873.png",[],{"type":14,"tag":23,"props":470,"children":471},{},[472],{"type":14,"tag":175,"props":473,"children":474},{},[475],{"type":20,"value":476},"事件和handler的连接触发方式",{"type":14,"tag":478,"props":479,"children":480},"ol",{},[481,486,491],{"type":14,"tag":59,"props":482,"children":483},{},[484],{"type":20,"value":485},"对于某些ui组件，可以直接设置其对自己产生的事件的handler，如button的onpointerclick",{"type":14,"tag":59,"props":487,"children":488},{},[489],{"type":20,"value":490},"对于任何ui组件，都可以使用eventtrigger这个component，这个trigger放置在产生事件的UI组件上，里面包含了一个事件的类型，以及这个类型关联的处理函数，处理函数可以使用两种函数参数，一种是使用int string简单类型，一种是使用BaseEventData类型，因为当event发生时，会跟随者把这个事件包装成一个PointerEventData类型的参数送进来，里面包含ui事件的详细信息，包括鼠标在哪，而对于前一种简单类型，在编辑器上可以填写当事件发生时传什么参数，这就好比qt的signal和slot连接。",{"type":14,"tag":59,"props":492,"children":493},{},[494,496,501,503,507],{"type":20,"value":495},"强制让某个事件发生在某个handler上（也就是强制某个handler执行）：调用ExecuteEvents.Execute\u003C",{"type":14,"tag":175,"props":497,"children":498},{},[499],{"type":20,"value":500},"ICustomMessageTarget",{"type":20,"value":502},">(target, null, (x,y)=>x.Message1());",{"type":14,"tag":504,"props":505,"children":506},"br",{},[],{"type":20,"value":508},"这个调用将执行target身上所有继承 了ICustomMessageTarget接口的mono的Message1函数，个人认为这个和给target发送Message1 的sendmessage没什么区别，可能是我还没有立即好这个接口。",{"type":14,"tag":23,"props":510,"children":511},{},[512],{"type":14,"tag":175,"props":513,"children":514},{},[515],{"type":20,"value":516},"自定义事件处理",{"type":14,"tag":23,"props":518,"children":519},{},[520,522],{"type":20,"value":521},"建立一個 Script，繼承 Event Interfaces，這裡是IPointerDownHandler(點下事件)，",{"type":14,"tag":29,"props":523,"children":526},{"href":524,"rel":525},"http://docs.unity3d.com/Manual/SupportedEvents.html",[33],[527],{"type":20,"value":528},"看更多 Event 請點我",{"type":14,"tag":40,"props":530,"children":532},{"code":531},"using UnityEngine;\nusing UnityEngine.EventSystems;\n \npublic class EventTest : MonoBehaviour, IPointerDownHandler\n{\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        print(gameObject.name);\n    }\n}\n",[533],{"type":14,"tag":45,"props":534,"children":535},{"__ignoreMap":7},[536],{"type":20,"value":531},{"type":14,"tag":538,"props":539,"children":541},"h2",{"id":540},"阻止手动发送射线穿透ugui问题",[542],{"type":20,"value":540},{"type":14,"tag":23,"props":544,"children":545},{},[546],{"type":20,"value":547},"UGUI 提供了一个检测是否点击在UI上的方法\nEventSystem.current.IsPointerOverGameObject();\n在EventSystem的标准输入Standalone Input Model下是正常的，",{"type":14,"tag":23,"props":549,"children":550},{},[551],{"type":20,"value":552},"但是在Touch Input Module输入模式下不正常",{"type":14,"tag":23,"props":554,"children":555},{},[556,558,565],{"type":20,"value":557},"参考网络资料，解决办法(直接上",{"type":14,"tag":29,"props":559,"children":562},{"href":560,"rel":561},"http://blog.csdn.net/andyhebear/article/details/51433748",[33],[563],{"type":20,"value":564},"源码",{"type":20,"value":566},"):",{"type":14,"tag":40,"props":568,"children":573},{"code":569,"language":570,"meta":7,"className":571}," using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\n\npublic class PointerCheck : MonoBehaviour\n{\n //UGUI 提供了一个检测是否点击在UI上的方法\n    //EventSystem.current.IsPointerOverGameObject();\n    //但是该方法在PC上检测正常，结果拿到Android真机测试上，永远检测不到。\n    //方法一， 使用该方法的另一个重载方法，使用时给该方法传递一个整形参数\n    // 该参数即使触摸手势的 id\n    // int id = Input.GetTouch(0).fingerId;\n    //public static bool IsPointerOverGameObject(int fingerID) {\n    //    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(fingerID);//移动输入模式下一样不行\n \n    //}\n    public static bool IsPointerOverGameObject() {\n        //if (Input.touchCount > 0) {\n                        \n        //    int id = Input.GetTouch(0).fingerId;\n        //    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(id);//安卓机上不行\n        //}\n        //else {\n            //return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();\n            PointerEventData eventData = new PointerEventData(UnityEngine.EventSystems.EventSystem.current);\n            eventData.pressPosition = Input.mousePosition;\n            eventData.position = Input.mousePosition;\n \n            List\u003CRaycastResult> list = new List\u003CRaycastResult>();\n            UnityEngine.EventSystems.EventSystem.current.RaycastAll(eventData, list);\n            //Debug.Log(list.Count);\n            return list.Count > 0;\n       // }\n    }\n    //方法二 通过UI事件发射射线\n    //是 2D UI 的位置，非 3D 位置\n    public static bool IsPointerOverGameObject(Vector2 screenPosition) {\n        //实例化点击事件\n        PointerEventData eventDataCurrentPosition = new PointerEventData(UnityEngine.EventSystems.EventSystem.current);\n        //将点击位置的屏幕坐标赋值给点击事件\n        eventDataCurrentPosition.position = new Vector2(screenPosition.x, screenPosition.y);\n \n        List\u003CRaycastResult> results = new List\u003CRaycastResult>();\n        //向点击处发射射线\n        EventSystem.current.RaycastAll(eventDataCurrentPosition, results);\n \n        return results.Count > 0;\n    }\n    //方法三 通过画布上的 GraphicRaycaster 组件发射射线\n    public static bool IsPointerOverGameObject(Canvas canvas, Vector2 screenPosition) {\n        //实例化点击事件\n        PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n        //将点击位置的屏幕坐标赋值给点击事件\n        eventDataCurrentPosition.position = screenPosition;\n        //获取画布上的 GraphicRaycaster 组件\n        GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent\u003CGraphicRaycaster>();\n \n        List\u003CRaycastResult> results = new List\u003CRaycastResult>();\n        // GraphicRaycaster 发射射线\n        uiRaycaster.Raycast(eventDataCurrentPosition, results);\n \n        return results.Count > 0;\n    }\n// For Details => https://blog.csdn.net/andyhebear/article/details/51433748\n}\n","csharp",[572],"language-csharp",[574],{"type":14,"tag":45,"props":575,"children":576},{"__ignoreMap":7},[577],{"type":20,"value":569},{"type":14,"tag":23,"props":579,"children":580},{},[581],{"type":20,"value":582},"网友解决办法：",{"type":14,"tag":40,"props":584,"children":586},{"code":585},"      /// \u003Csummary>\n     /// Cast a ray to test if Input.mousePosition is over any UI object in EventSystem.current. This is a replacement\n     /// for IsPointerOverGameObject() which does not work on Android in 4.6.0f3\n     /// \u003C/summary>\n     private static bool IsPointerOverUIObject()\n     {\n         if (EventSystem.current == null)\n             return false;\n \n         // Referencing this code for GraphicRaycaster https://gist.github.com/stramit/ead7ca1f432f3c0f181f\n         // the ray cast appears to require only eventData.position.\n         PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n         eventDataCurrentPosition.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);\n \n         List\u003CRaycastResult> results = new List\u003CRaycastResult>();\n         EventSystem.current.RaycastAll(eventDataCurrentPosition, results);\n \n         return results.Count > 0;\n     }\n \n     /// \u003Csummary>\n     /// Cast a ray to test if screenPosition is over any UI object in canvas. This is a replacement\n     /// for IsPointerOverGameObject() which does not work on Android in 4.6.0f3\n     /// \u003C/summary>\n     private bool IsPointerOverUIObject(Canvas canvas, Vector2 screenPosition)\n     {\n         if (EventSystem.current == null)\n             return false;\n \n         // Referencing this code for GraphicRaycaster https://gist.github.com/stramit/ead7ca1f432f3c0f181f\n         // the ray cast appears to require only eventData.position.\n         PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n         eventDataCurrentPosition.position = screenPosition;\n \n         GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent\u003CGraphicRaycaster>();\n         List\u003CRaycastResult> results = new List\u003CRaycastResult>();\n         uiRaycaster.Raycast(eventDataCurrentPosition, results);\n         return results.Count > 0;\n     }\n",[587],{"type":14,"tag":45,"props":588,"children":589},{"__ignoreMap":7},[590],{"type":20,"value":585},{"type":14,"tag":15,"props":592,"children":594},{"id":593},"message-system改进的消息系统",[595],{"type":20,"value":596},"Message System（改进的消息系统）",{"type":14,"tag":267,"props":598,"children":600},{"id":599},"传统方式进行-message-通信",[601],{"type":20,"value":602},"传统方式进行 Message 通信",{"type":14,"tag":23,"props":604,"children":605},{},[606,608,614,616,622,624,630],{"type":20,"value":607},"传统消息通信，通常我们会使用 GameObject 类中的 ",{"type":14,"tag":45,"props":609,"children":611},{"className":610},[],[612],{"type":20,"value":613},"SendMessage",{"type":20,"value":615},"、",{"type":14,"tag":45,"props":617,"children":619},{"className":618},[],[620],{"type":20,"value":621},"SendMessageUpwards",{"type":20,"value":623}," 和 ",{"type":14,"tag":45,"props":625,"children":627},{"className":626},[],[628],{"type":20,"value":629},"BroadcastMessage",{"type":20,"value":631}," 方法",{"type":20,"value":633},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":14,"tag":635,"props":636,"children":637},"table",{},[638,662],{"type":14,"tag":639,"props":640,"children":641},"thead",{},[642],{"type":14,"tag":643,"props":644,"children":645},"tr",{},[646,650,654,658],{"type":14,"tag":647,"props":648,"children":649},"th",{},[],{"type":14,"tag":647,"props":651,"children":652},{},[653],{"type":20,"value":613},{"type":14,"tag":647,"props":655,"children":656},{},[657],{"type":20,"value":621},{"type":14,"tag":647,"props":659,"children":660},{},[661],{"type":20,"value":629},{"type":14,"tag":663,"props":664,"children":665},"tbody",{},[666,688,709,729],{"type":14,"tag":643,"props":667,"children":668},{},[669,675,680,684],{"type":14,"tag":670,"props":671,"children":672},"td",{},[673],{"type":20,"value":674},"自身节点",{"type":14,"tag":670,"props":676,"children":677},{},[678],{"type":20,"value":679},"√",{"type":14,"tag":670,"props":681,"children":682},{},[683],{"type":20,"value":679},{"type":14,"tag":670,"props":685,"children":686},{},[687],{"type":20,"value":679},{"type":14,"tag":643,"props":689,"children":690},{},[691,696,701,705],{"type":14,"tag":670,"props":692,"children":693},{},[694],{"type":20,"value":695},"兄弟节点",{"type":14,"tag":670,"props":697,"children":698},{},[699],{"type":20,"value":700},"×",{"type":14,"tag":670,"props":702,"children":703},{},[704],{"type":20,"value":700},{"type":14,"tag":670,"props":706,"children":707},{},[708],{"type":20,"value":700},{"type":14,"tag":643,"props":710,"children":711},{},[712,717,721,725],{"type":14,"tag":670,"props":713,"children":714},{},[715],{"type":20,"value":716},"父/祖先节点",{"type":14,"tag":670,"props":718,"children":719},{},[720],{"type":20,"value":700},{"type":14,"tag":670,"props":722,"children":723},{},[724],{"type":20,"value":679},{"type":14,"tag":670,"props":726,"children":727},{},[728],{"type":20,"value":700},{"type":14,"tag":643,"props":730,"children":731},{},[732,737,741,745],{"type":14,"tag":670,"props":733,"children":734},{},[735],{"type":20,"value":736},"子/孙节点",{"type":14,"tag":670,"props":738,"children":739},{},[740],{"type":20,"value":700},{"type":14,"tag":670,"props":742,"children":743},{},[744],{"type":20,"value":700},{"type":14,"tag":670,"props":746,"children":747},{},[748],{"type":20,"value":679},{"type":14,"tag":267,"props":750,"children":752},{"id":751},"messaging-system",[753],{"type":20,"value":754},"Messaging System",{"type":14,"tag":23,"props":756,"children":757},{},[758],{"type":20,"value":759},"在 UGUI 的 Event System 中，所有的事件通信都是用了 Messaging System 来实现，它也解决了传统方式进行 Message 通信中可能会遇到的一些问题。下面就来让我们好好看看这套 Messaging System。",{"type":14,"tag":23,"props":761,"children":762},{},[763,765,770,772,778,780,785],{"type":20,"value":764},"首先，要想让 Component 能够从 Messaging System 接收消息，Component 要实现 ",{"type":14,"tag":45,"props":766,"children":768},{"className":767},[],[769],{"type":20,"value":298},{"type":20,"value":771}," 这个接口。",{"type":14,"tag":45,"props":773,"children":775},{"className":774},[],[776],{"type":20,"value":777},"IPointerDownHandler",{"type":20,"value":779},"等都继承了",{"type":14,"tag":45,"props":781,"children":783},{"className":782},[],[784],{"type":20,"value":298},{"type":20,"value":786}," 接口",{"type":14,"tag":40,"props":788,"children":790},{"code":789},"public interface ICustomMessageTarget : IEventSystemHandler\n{\n    // functions that can be called via the messaging system\n    void Message1();\n    void Message2();\n}\n",[791],{"type":14,"tag":45,"props":792,"children":793},{"__ignoreMap":7},[794],{"type":20,"value":789},{"type":14,"tag":23,"props":796,"children":797},{},[798],{"type":20,"value":799},"实现这个接口 , 把这个脚本挂在某个物体上，这里假设为物体AAA",{"type":14,"tag":40,"props":801,"children":803},{"code":802},"public class CustomMessageTarget : MonoBehaviour, ICustomMessageTarget\n{\n    public void Message1()\n    {\n        Debug.Log (\"Message 1 received\");\n    }\n\n    public void Message2()\n    {\n        Debug.Log (\"Message 2 received\");\n    }\n}\n",[804],{"type":14,"tag":45,"props":805,"children":806},{"__ignoreMap":7},[807],{"type":20,"value":802},{"type":14,"tag":23,"props":809,"children":810},{},[811],{"type":20,"value":812},"在任何脚本中使用ExecuteEvents静态类发送Message，来执行接口中定义的方法",{"type":14,"tag":40,"props":814,"children":816},{"code":815},"ExecuteEvents.Execute\u003CICustomMessageTarget>(target, null, (x,y)=>x.Message1());\n",[817],{"type":14,"tag":45,"props":818,"children":819},{"__ignoreMap":7},[820],{"type":20,"value":815},{"type":14,"tag":23,"props":822,"children":823},{},[824,826,831],{"type":20,"value":825},"Excute泛型方法，有3个参数，第一个参数是发送message的gameobject对象，只有当对象上有",{"type":14,"tag":45,"props":827,"children":829},{"className":828},[],[830],{"type":20,"value":298},{"type":20,"value":832},"实现类的时候才可以，这个例子中自然就是AAA物体。",{"type":14,"tag":23,"props":834,"children":835},{},[836],{"type":20,"value":837},"ExecuteEvents静态类还有其他方法：",{"type":14,"tag":40,"props":839,"children":841},{"code":840},"EventSystems.ExecuteEvents.CanHandleEvent    判断给定的gameobejct是否能处理这个事件\nEventSystems.ExecuteEvents.Execute     执行事件\nEventSystems.ExecuteEvents.ExecuteHierarchy  是递归寻找适合的gameobject，并执行事件 \nEventSystems.ExecuteEvents.GetEventHandler   \nEventSystems.ExecuteEvents.ValidateEventData   \n",[842],{"type":14,"tag":45,"props":843,"children":844},{"__ignoreMap":7},[845],{"type":20,"value":840},{"type":14,"tag":15,"props":847,"children":849},{"id":848},"eventsystem-处理physics",[850],{"type":20,"value":851},"eventsystem 处理Physics",{"type":14,"tag":23,"props":853,"children":854},{},[855,857,864],{"type":20,"value":856},"首先，我们看一个官方文档的说明 ",{"type":14,"tag":29,"props":858,"children":861},{"href":859,"rel":860},"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/Raycasters.html",[33],[862],{"type":20,"value":863},"Raycasters",{"type":20,"value":865},"。",{"type":14,"tag":867,"props":868,"children":869},"blockquote",{},[870],{"type":14,"tag":23,"props":871,"children":872},{},[873],{"type":20,"value":874},"If multiple Raycasters are used then they will all have casting happen against them and the results will be sorted based on distance to the elements.",{"type":14,"tag":23,"props":876,"children":877},{},[878],{"type":20,"value":879},"当多个Raycaster被使用的时候，结果会按照元素之间的距离排序，然后事件就会按照这个顺序被传递。",{"type":14,"tag":538,"props":881,"children":883},{"id":882},"第一步",[884],{"type":14,"tag":175,"props":885,"children":886},{},[887],{"type":20,"value":882},{"type":14,"tag":23,"props":889,"children":890},{},[891],{"type":14,"tag":111,"props":892,"children":894},{"alt":111,"src":893},"/images/2019-08-11-ugui-eventmanager/v2-733f4cd159b935aeb26518e97b902a7d_hd.jpg",[],{"type":14,"tag":23,"props":896,"children":897},{},[898],{"type":20,"value":899},"在相机上添加Physics2DRaycaster，我这里只需要对Physics2D检测，如果是3D就用Physics3DRaycaster。Physics Raycaster 依赖一个相机，如果没有会自动添加。我挂载在相机上，射线检测就会依赖这个相机。",{"type":14,"tag":23,"props":901,"children":902},{},[903],{"type":20,"value":904},"这里我用在GameCamera上面，当然也可以放在UICamera上面，Physics Raycaster挂载在哪个相机上面，射线就依赖这个相机的Culling Mask。",{"type":14,"tag":23,"props":906,"children":907},{},[908],{"type":20,"value":909},"另外需要注意的是，Physics Raycaster所在的相机层级，也就是Depth，会影响到事件传递的顺序。比如，UI Camera层级高于Game Camera，就会永远先出发UI上的事件。同样，OnMouse事件会默认依赖Main Camera的层级。",{"type":14,"tag":538,"props":911,"children":913},{"id":912},"第二步",[914],{"type":14,"tag":175,"props":915,"children":916},{},[917],{"type":20,"value":912},{"type":14,"tag":23,"props":919,"children":920},{},[921],{"type":20,"value":922},"给需要碰撞检测的GameObject，添加Collider和EventSystem的事件处理回调接口。注意GameObject的Layer也要与Camera和Raycaster一致，才能正确被检测到。",{"type":14,"tag":23,"props":924,"children":925},{},[926],{"type":14,"tag":111,"props":927,"children":929},{"alt":111,"src":928},"/images/2019-08-11-ugui-eventmanager/v2-3c1713c6226906982501aa7c4dd8252d_hd.jpg",[],{"type":14,"tag":23,"props":931,"children":932},{},[933],{"type":20,"value":934},"事件接口实现脚本(图中的Test)需要Collider，事件才能正确回调，并且GameObject和相机的距离决定了Collider的层级，也就是事件阻挡关系。",{"type":14,"tag":538,"props":936,"children":938},{"id":937},"第三步",[939],{"type":14,"tag":175,"props":940,"children":941},{},[942],{"type":20,"value":937},{"type":14,"tag":23,"props":944,"children":945},{},[946],{"type":20,"value":947},"这样一来，EventSystem的SupportEvents的接口全部被应用到了Physics上面。也就不再需要自己手动去调用射线去检测Physics碰撞了。那么，还隐含着一个事情就是，EventSystem的IsPointerOverGameObject()就无法在判断对UI的点击了。因为现在点击到Physics也会让这个函数返回True。",{"title":7,"searchDepth":949,"depth":949,"links":950},2,[951,953,957,958,959],{"id":269,"depth":952,"text":269},3,{"id":540,"depth":949,"text":540,"children":954},[955,956],{"id":599,"depth":952,"text":602},{"id":751,"depth":952,"text":754},{"id":882,"depth":949,"text":882},{"id":912,"depth":949,"text":912},{"id":937,"depth":949,"text":937},"markdown","content:unity:2019-08-11-ugui-eventmanager.md","content","unity/2019-08-11-ugui-eventmanager.md","md","2019-08-11",[967,977,1104,1153,1205,1218,1330],{"title":968,"_path":969,"children":970},"Art","/art",[971,974],{"title":972,"_path":973},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":975,"_path":976},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":978,"_path":979,"children":980},"Dotnet","/dotnet",[981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017,1020,1023,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053,1056,1059,1062,1065,1068,1071,1074,1077,1080,1083,1086,1089,1092,1095,1098,1101],{"title":982,"_path":983},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":985,"_path":986},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":988,"_path":989},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":991,"_path":992},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":994,"_path":995},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":997,"_path":998},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1000,"_path":1001},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1003,"_path":1004},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1006,"_path":1007},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1009,"_path":1010},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1012,"_path":1013},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1015,"_path":1016},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1018,"_path":1019},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1021,"_path":1022},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1024,"_path":1025},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1027,"_path":1028},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1030,"_path":1031},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1033,"_path":1034},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1036,"_path":1037},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1039,"_path":1040},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1042,"_path":1043},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1045,"_path":1046},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1048,"_path":1049},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1051,"_path":1052},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1054,"_path":1055},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1057,"_path":1058},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1060,"_path":1061},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1063,"_path":1064},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1066,"_path":1067},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1069,"_path":1070},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1072,"_path":1073},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1075,"_path":1076},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1078,"_path":1079},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1081,"_path":1082},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1084,"_path":1085},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1087,"_path":1088},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1090,"_path":1091},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1093,"_path":1094},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1096,"_path":1097},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1099,"_path":1100},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1102,"_path":1103},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1105,"_path":1106,"children":1107},"Game","/game",[1108,1111,1114,1117,1120,1123,1126,1129,1132,1135,1138,1141,1144,1147,1150],{"title":1109,"_path":1110},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1112,"_path":1113},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1115,"_path":1116},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1118,"_path":1119},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1121,"_path":1122},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1124,"_path":1125},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1127,"_path":1128},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1130,"_path":1131},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1133,"_path":1134},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1136,"_path":1137},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1139,"_path":1140},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1142,"_path":1143},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1145,"_path":1146},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1148,"_path":1149},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1151,"_path":1152},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1154,"_path":1155,"children":1156},"Gyj","/gyj",[1157,1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190,1193,1196,1199,1202],{"title":1158,"_path":1159},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1161,"_path":1162},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1164,"_path":1165},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1167,"_path":1168},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1170,"_path":1171},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1173,"_path":1174},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1176,"_path":1177},"玩法","/gyj/2022-08-22-wanfa",{"title":1179,"_path":1180},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1182,"_path":1183},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1185,"_path":1186},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1188,"_path":1189},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1191,"_path":1192},"门派内容相关","/gyj/2022-11-17-sect",{"title":1194,"_path":1195},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1197,"_path":1198},"种植","/gyj/2022-12-01-zhongzhi",{"title":1200,"_path":1201},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1203,"_path":1204},"跑商","/gyj/2023-11-01-paoshang",{"title":1206,"_path":1207,"children":1208},"Js","/js",[1209,1212,1215],{"title":1210,"_path":1211},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1213,"_path":1214},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1216,"_path":1217},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1219,"_path":1220,"children":1221},"Tool","/tool",[1222,1225,1228,1231,1234,1237,1240,1243,1246,1249,1252,1255,1258,1261,1264,1267,1270,1273,1276,1279,1282,1285,1288,1291,1294,1297,1300,1303,1306,1309,1312,1315,1318,1321,1324,1327],{"title":1223,"_path":1224},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1226,"_path":1227},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1229,"_path":1230},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1232,"_path":1233},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1235,"_path":1236},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1238,"_path":1239},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1241,"_path":1242},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1244,"_path":1245},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1247,"_path":1248},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1250,"_path":1251},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1253,"_path":1254},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1256,"_path":1257},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1259,"_path":1260},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1262,"_path":1263},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1265,"_path":1266},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1268,"_path":1269},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1271,"_path":1272},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1274,"_path":1275},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1277,"_path":1278},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1280,"_path":1281},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1283,"_path":1284},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1286,"_path":1287},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1289,"_path":1290},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1292,"_path":1293},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1295,"_path":1296},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1298,"_path":1299},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1301,"_path":1302},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1304,"_path":1305},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1307,"_path":1308},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1310,"_path":1311},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1313,"_path":1314},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1316,"_path":1317},"rider的使用","/tool/2022-08-02-rider-use",{"title":1319,"_path":1320},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1322,"_path":1323},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1325,"_path":1326},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1328,"_path":1329},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1331,"_path":1332,"children":1333},"Unity","/unity",[1334,1337,1340,1343,1346,1349,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392,1395,1398,1401,1404,1407,1410,1413,1416,1419,1422,1425,1428,1431,1434,1437,1440,1443,1446,1449,1452,1455,1458,1461,1464,1467,1470,1473,1476,1479,1482,1485,1488,1491,1494,1497,1500,1503,1506,1509,1512,1515,1518,1521,1524,1527,1530,1533,1536,1539,1542,1545],{"title":1335,"_path":1336},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1338,"_path":1339},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1341,"_path":1342},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1344,"_path":1345},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1347,"_path":1348},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":8,"_path":4},{"title":1351,"_path":1352},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1354,"_path":1355},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1357,"_path":1358},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1360,"_path":1361},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1363,"_path":1364},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1366,"_path":1367},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1369,"_path":1370},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1372,"_path":1373},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1375,"_path":1376},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1378,"_path":1379},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1381,"_path":1382},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1384,"_path":1385},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1387,"_path":1388},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1390,"_path":1391},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1393,"_path":1394},"技能系统","/unity/2020-02-15-skill-system",{"title":1396,"_path":1397},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1399,"_path":1400},"角色状态设计","/unity/2020-02-17-character-states",{"title":1402,"_path":1403},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1405,"_path":1406},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1408,"_path":1409},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1411,"_path":1412},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1414,"_path":1415},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1417,"_path":1418},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1420,"_path":1421},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1423,"_path":1424},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1426,"_path":1427},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1429,"_path":1430},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1432,"_path":1433},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1435,"_path":1436},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1438,"_path":1439},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1441,"_path":1442},"unity的addressables","/unity/2020-09-12-addressables",{"title":1444,"_path":1445},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1447,"_path":1448},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1450,"_path":1451},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1453,"_path":1454},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1456,"_path":1457},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1459,"_path":1460},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1462,"_path":1463},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1465,"_path":1466},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1468,"_path":1469},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1471,"_path":1472},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1474,"_path":1475},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1477,"_path":1478},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1480,"_path":1481},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1483,"_path":1484},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1486,"_path":1487},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1489,"_path":1490},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1492,"_path":1493},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1495,"_path":1496},"ability","/unity/2020-11-16-dotssample",{"title":1498,"_path":1499},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1501,"_path":1502},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1504,"_path":1505},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1507,"_path":1508},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1510,"_path":1511},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1513,"_path":1514},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1516,"_path":1517},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1519,"_path":1520},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1522,"_path":1523},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1525,"_path":1526},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1528,"_path":1529},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1531,"_path":1532},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1534,"_path":1535},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1537,"_path":1538},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1540,"_path":1541},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1543,"_path":1544},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1546,"_path":1547},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779042001]