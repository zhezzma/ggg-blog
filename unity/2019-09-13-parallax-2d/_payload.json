[{"data":1,"prerenderedAt":1464},["Reactive",2],{"content-query-u0YLaaMwBD":3,"content-navigation-8C37fagqQL":882},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":876,"_id":877,"_source":878,"_file":879,"_extension":880,"date":881},"/unity/2019-09-13-parallax-2d","unity",false,"","2D游戏视差背景的实现","什么是视差背景？视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。简单地说，视差背景其实就是通过多层次的背景来模拟透视视差效果：就是当发生移动时，离照相机越近的背景移动越快；反之越慢。这样，我们的背景就会形成类似于透视视差的效果。那么，既然需要透视效果，为何不直接使用透视投影来做呢？这个原因是如果使用透视投影来产生视差的话，我们的远景必须真的是一个非常大的背景，你如果想模拟出一百倍于近景的远景，那么可能就需要相应尺寸的背景贴图。这种做法显然是",{"type":11,"children":12,"toc":869},"root",[13,22,28,33,38,43,58,63,68,91,96,101,109,114,129,136,141,148,153,171,176,189,194,199,204,214,219,225,230,237,242,247,253,258,265,270,275,281,286,293,298,303,308,314,319,325,330,336,341,347,352,357,362,369,377,383,388,396,410,415,423,430,435,449,454,459,464,482,489,497,505,510,515,520,525,533,541,546,551,555,560,565,570,575,583,591,596,600,604,608,613,618,623,630,635,640,647,652,657,665,670,678,683,688,696,701,706,711,716,728,738,745,750,755,769,776,790,795,800,805,810,824,829,834,842,847],{"type":14,"tag":15,"props":16,"children":18},"element","h4",{"id":17},"什么是视差背景",[19],{"type":20,"value":21},"text","什么是视差背景？",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":27},"视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。",{"type":14,"tag":23,"props":29,"children":30},{},[31],{"type":20,"value":32},"简单地说，视差背景其实就是通过多层次的背景来模拟透视视差效果：就是当发生移动时，离照相机越近的背景移动越快；反之越慢。这样，我们的背景就会形成类似于透视视差的效果。",{"type":14,"tag":23,"props":34,"children":35},{},[36],{"type":20,"value":37},"那么，既然需要透视效果，为何不直接使用透视投影来做呢？这个原因是如果使用透视投影来产生视差的话，我们的远景必须真的是一个非常大的背景，你如果想模拟出一百倍于近景的远景，那么可能就需要相应尺寸的背景贴图。这种做法显然是做不到的。当然，如果是3D 背景的话有其他方式，不过对于2D 游戏而言，最直接有效的还是多层次背景模拟出视差效果。我们这里也主要聊聊如果通过多层次背景滚动的方式实现视差效果。",{"type":14,"tag":23,"props":39,"children":40},{},[41],{"type":20,"value":42},"在整个视差背景实现过程中，需要完成两个主要工作：",{"type":14,"tag":44,"props":45,"children":46},"ol",{},[47,53],{"type":14,"tag":48,"props":49,"children":50},"li",{},[51],{"type":20,"value":52},"实现单层背景的滚动；",{"type":14,"tag":48,"props":54,"children":55},{},[56],{"type":20,"value":57},"复合多层背景的滚动，实现视差效果；",{"type":14,"tag":15,"props":59,"children":61},{"id":60},"实现单层背景的滚动",[62],{"type":20,"value":60},{"type":14,"tag":23,"props":64,"children":65},{},[66],{"type":20,"value":67},"背景滚动是实现视差效果的核心也是最重要的问题。背景滚动存在横向和纵向两种。所有使用视差背景的游戏都会有横向滚动的情况，而纵向滚动则未必都会有。我们这里以横向滚动来介绍背景滚动。我们有四种常规方式可以实现背景的滚动：",{"type":14,"tag":44,"props":69,"children":70},{},[71,76,81,86],{"type":14,"tag":48,"props":72,"children":73},{},[74],{"type":20,"value":75},"通过移动一个四边形顶点的 UV 移动形成滚动，之后就称之为 UV 滚动方式；",{"type":14,"tag":48,"props":77,"children":78},{},[79],{"type":20,"value":80},"通过滚动移动多个连续的背景精灵形成滚动，之后就称之为精灵滚动方式；",{"type":14,"tag":48,"props":82,"children":83},{},[84],{"type":20,"value":85},"添加背景层照相机，移动照相机形成滚动，之后就称之为照相机移动方式；",{"type":14,"tag":48,"props":87,"children":88},{},[89],{"type":20,"value":90},"精灵滚动方式和照相机移动方式混合使用，之后就称之为混合滚动方式；",{"type":14,"tag":23,"props":92,"children":93},{},[94],{"type":20,"value":95},"为了更好地解释这几种实现方式，需要几张图片用于介绍：",{"type":14,"tag":23,"props":97,"children":98},{},[99],{"type":20,"value":100},"我们使用一个黄框精灵代表屏幕取景区域：",{"type":14,"tag":23,"props":102,"children":103},{},[104],{"type":14,"tag":105,"props":106,"children":108},"img",{"alt":105,"src":107},"/images/2019-09-13-Parallax-2d/u-101952876756Yj6.png",[],{"type":14,"tag":23,"props":110,"children":111},{},[112],{"type":20,"value":113},"接下来是三张可拼接的背景精灵：",{"type":14,"tag":23,"props":115,"children":116},{},[117,121,125],{"type":14,"tag":105,"props":118,"children":120},{"alt":105,"src":119},"/images/2019-09-13-Parallax-2d/u-101952876820zdg.png",[],{"type":14,"tag":105,"props":122,"children":124},{"alt":105,"src":123},"/images/2019-09-13-Parallax-2d/u-101952876827Lvz.png",[],{"type":14,"tag":105,"props":126,"children":128},{"alt":105,"src":127},"/images/2019-09-13-Parallax-2d/u-101952876811twL.png",[],{"type":14,"tag":130,"props":131,"children":133},"h5",{"id":132},"uv-滚动方式",[134],{"type":20,"value":135},"UV 滚动方式：",{"type":14,"tag":23,"props":137,"children":138},{},[139],{"type":20,"value":140},"使用 UV 坐标移动形成滚动的效果看起来是这样的：",{"type":14,"tag":23,"props":142,"children":143},{},[144],{"type":14,"tag":105,"props":145,"children":147},{"alt":105,"src":146},"/images/2019-09-13-Parallax-2d/u-101952876924lOw.gif",[],{"type":14,"tag":23,"props":149,"children":150},{},[151],{"type":20,"value":152},"在 UV 坐标移动的方法中，我们只是用一个和照相机取景区域一样大的精灵作为背景渲染区域。然后通过调整它的 UV 坐标和采样方式实现平铺背景以及背景滚动。具体实现步骤：",{"type":14,"tag":44,"props":154,"children":155},{},[156,161,166],{"type":14,"tag":48,"props":157,"children":158},{},[159],{"type":20,"value":160},"准备一个覆盖整个屏幕的四边形顶点，并使用它显示背景贴图；",{"type":14,"tag":48,"props":162,"children":163},{},[164],{"type":20,"value":165},"调整 UV 坐标和纹理之间的采样方式，以实现纹理连续显示；",{"type":14,"tag":48,"props":167,"children":168},{},[169],{"type":20,"value":170},"移动时，修改四个顶点的 UV 坐标形成滚动；",{"type":14,"tag":23,"props":172,"children":173},{},[174],{"type":20,"value":175},"因为我们只使用一张精灵，我们区域采样的方式就是通过 UV 坐标。因此此方式下 UV 坐标存在两个作用：",{"type":14,"tag":44,"props":177,"children":178},{},[179,184],{"type":14,"tag":48,"props":180,"children":181},{},[182],{"type":20,"value":183},"UV 坐标的整数部分标记了当前采样位置使用哪一张背景贴图；",{"type":14,"tag":48,"props":185,"children":186},{},[187],{"type":20,"value":188},"UV 坐标小数部分为选中背景贴图的采样 UV 坐标；",{"type":14,"tag":23,"props":190,"children":191},{},[192],{"type":20,"value":193},"因此，此精灵的 UV 坐标必定会大于[0,1]区间。",{"type":14,"tag":23,"props":195,"children":196},{},[197],{"type":20,"value":198},"如果背景使用的背景贴图只有一张的话，这个问题很容易解决。我们只要设置图形 API（OpenGL 或 DirectX，这里以 OpenGL 为例）的纹理包装类型（即所谓的 wrapping 类型）即可。所谓的包装类型即指定了当 UV 坐标值在[ 0,1 ]区间之外时，如何获取纹理。那么这里，我们需要让一张纹理重复出现。在 OpenGL 中，我们需要调用此函数来完成包装类型的设置：glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );稍微解释一下此函数：glTexParameteri 函数会对指定的纹理的参数进行设置。我们这里针对2D 纹理（第一参数 GL_TEXTURE_2D）的 x 方向即横向（第二参数 GL_TEXTURE_WRAP_S）的包装模式设置为重复出现的方式（第三参数 GL_REPEAT）。",{"type":14,"tag":23,"props":200,"children":201},{},[202],{"type":20,"value":203},"不过如果背景是多张不同的纹理连续出现的话，就不能使用上面的方法解决了。这个时候我们需要编写一个简单的 shader 在 shader 中完成 UV 坐标映射。这里截取出演示 demo 中，获取纹理相关的 shader 代码（GLSL 代码）提供大家参考：",{"type":14,"tag":205,"props":206,"children":208},"pre",{"code":207},"//我们有三张背景贴图，对 UV 坐标对3取模，得到使用哪一种背景贴图。             \nint _index = int( mod( v_TexCoord.x, 3.0 ));\n//使用此贴图并使用 UV 坐标的小数部分进行像素采样。            \ngl_FragData[0] = texture( u_BackgroundTextures[_index], fract(v_TexCoord));  \n",[209],{"type":14,"tag":210,"props":211,"children":212},"code",{"__ignoreMap":7},[213],{"type":20,"value":207},{"type":14,"tag":23,"props":215,"children":216},{},[217],{"type":20,"value":218},"UV 方式有着非常良好的性能，但是缺点就是只能处理简单的平铺背景，对于有着复杂结构或是效果的滚动背景没有办法使用。",{"type":14,"tag":130,"props":220,"children":222},{"id":221},"精灵滚动方式",[223],{"type":20,"value":224},"精灵滚动方式：",{"type":14,"tag":23,"props":226,"children":227},{},[228],{"type":20,"value":229},"使用精灵滚动形成滚动的效果看起来是这样的：",{"type":14,"tag":23,"props":231,"children":232},{},[233],{"type":14,"tag":105,"props":234,"children":236},{"alt":105,"src":235},"/images/2019-09-13-Parallax-2d/u-10195287789913d.gif",[],{"type":14,"tag":23,"props":238,"children":239},{},[240],{"type":20,"value":241},"这种方式应该是比较直接的。我们首先使用背景精灵拼接出背景取景区域覆盖到的背景区域。然后在发生背景移动时，我们依然不需要移动背景取景区域，而是通过滚动移动所有的背景精灵来实现背景移动的效果。",{"type":14,"tag":23,"props":243,"children":244},{},[245],{"type":20,"value":246},"这种方式实现简单直接，但缺点是发生背景移动时，需要对所有的背景精灵进行移动。对于结构复杂元素较多的背景需要占用更多的性能。",{"type":14,"tag":130,"props":248,"children":250},{"id":249},"照相机移动方式",[251],{"type":20,"value":252},"照相机移动方式：",{"type":14,"tag":23,"props":254,"children":255},{},[256],{"type":20,"value":257},"使用照相机移动形成滚动的效果看起来是这样的：",{"type":14,"tag":23,"props":259,"children":260},{},[261],{"type":14,"tag":105,"props":262,"children":264},{"alt":105,"src":263},"/images/2019-09-13-Parallax-2d/u-101952878215omm.gif",[],{"type":14,"tag":23,"props":266,"children":267},{},[268],{"type":20,"value":269},"这种方式与精灵滚动方式正好相反。在这种方式下，我们需要使用背景精灵拼接出完整的背景。同时在背景移动时，不移动背景精灵转而移动背景取景区域来实现背景移动效果。",{"type":14,"tag":23,"props":271,"children":272},{},[273],{"type":20,"value":274},"这种方式在移动过程中由于只需要移动背景照相机，所以有种很好的移动性能。但是为了使用此方法。我们需要预先将整个背景全部拼接。这样导致同时存在过多的背景精灵在场景中。如果使用的游戏引擎没有场景管理器或是场景管理器性能不佳的情况下，此方式反而会带来额外的性能消耗。",{"type":14,"tag":130,"props":276,"children":278},{"id":277},"混合滚动方式",[279],{"type":20,"value":280},"混合滚动方式：",{"type":14,"tag":23,"props":282,"children":283},{},[284],{"type":20,"value":285},"使用混合滚动方式形成的滚动效果看起来是这样的：",{"type":14,"tag":23,"props":287,"children":288},{},[289],{"type":14,"tag":105,"props":290,"children":292},{"alt":105,"src":291},"/images/2019-09-13-Parallax-2d/u-101952878467iBp.gif",[],{"type":14,"tag":23,"props":294,"children":295},{},[296],{"type":20,"value":297},"顾名思义，混合移动混合了精灵移动和照相机移动两种方式。我们在移动背景取景区域的同时，适时地滚动背景精灵。使得背景取景区域内的背景正确。",{"type":14,"tag":23,"props":299,"children":300},{},[301],{"type":20,"value":302},"这种方式结合了精灵滚动方式和照相机移动方式。避免了精灵滚动方式移动过程中，因为需要移动所有背景精灵带来的额外性能开销；也避免了照相机移动方式中，需要预先构建完整的背景而导致场景中存在过多的背景精灵带来的额外性能开销。当然，和照相机移动方式一样，避免不了每一层背景都需要有一个独立的背景照相机。同时在代码实现良好的情况下，性能比前两者都要好。",{"type":14,"tag":15,"props":304,"children":306},{"id":305},"四种方式的优劣",[307],{"type":20,"value":305},{"type":14,"tag":130,"props":309,"children":311},{"id":310},"平均性能",[312],{"type":20,"value":313},"平均性能：",{"type":14,"tag":23,"props":315,"children":316},{},[317],{"type":20,"value":318},"UV 滚动方式只使用了一个四边形并且移动时也只是单纯改变了 UV 采样方式。它的性能是最好的；其次是混合滚动方式；照相机移动方式有更多的空间开销，同时此开销对性能的影响与游戏引擎的场景管理模块密切关联；精灵方式则有最大的移动性能消耗。",{"type":14,"tag":130,"props":320,"children":322},{"id":321},"对复杂背景的支持",[323],{"type":20,"value":324},"对复杂背景的支持：",{"type":14,"tag":23,"props":326,"children":327},{},[328],{"type":20,"value":329},"即四种方式所实现的背景可以有多复杂。UV 滚动方式碍于实现只能做简单的平铺背景的滚动效果；精灵滚动方式和混合滚动方式可以实现更为复杂一点的背景，可以在简单的平铺背景之上加入一些其他背景精灵元素；而照相机移动方式对背景的构建没有要求，它可以支持非常复杂的背景。",{"type":14,"tag":130,"props":331,"children":333},{"id":332},"是否可以无限延伸",[334],{"type":20,"value":335},"是否可以无限延伸：",{"type":14,"tag":23,"props":337,"children":338},{},[339],{"type":20,"value":340},"理论上四种方式都可以实现无限延伸。但是对于照相机移动方式来说，实现起来会比较麻烦。而另外三种方式都是循环利用同一个背景，所以天然支持无限延伸的背景。",{"type":14,"tag":130,"props":342,"children":344},{"id":343},"复合多层背景的滚动实现视差效果",[345],{"type":20,"value":346},"复合多层背景的滚动，实现视差效果：",{"type":14,"tag":23,"props":348,"children":349},{},[350],{"type":20,"value":351},"有了上面的工作，这一步也是顺其自然就可以完成：",{"type":14,"tag":23,"props":353,"children":354},{},[355],{"type":20,"value":356},"我们首先要构建多层背景，多层背景可以同时只是用一种滚动方式；也可以不同层背景使用不同的滚动方式。比如最远的背景由于基本上都是简单的平铺可以使用 UV 滚动方式构建；而再近一点细节较多的背景层可以考虑后几种滚动方式构建背景。",{"type":14,"tag":23,"props":358,"children":359},{},[360],{"type":20,"value":361},"之后是移动，我们需要根据每一层背景的距离决定其在移动过程中的移动速度。速度如何决定并没有统一的方法或是模式。总之，这一点听听美术们的意见是比较合适的。",{"type":14,"tag":363,"props":364,"children":366},"h3",{"id":365},"unity混合模式1",[367],{"type":20,"value":368},"Unity混合模式1",{"type":14,"tag":205,"props":370,"children":372},{"code":371},"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n/// \u003Csummary>\n/// Weiva Parallax\n/// 2D 视差效果\n/// 本组件背景视差效果是根据背景对象的世界坐标z值来计算。默认参数中的背景数组第一个元素为最远平面，\n/// 既与摄像机同步的平面，该对象之间的背景根据z值进行视差计算。也可以单独设置参数 synZ 强制设置最\n/// 远平面。大于最远平面的 z 值将会反超摄像机移动。\n/// weivain@qq.com\n/// www.weiva.com\n/// \u003C/summary>\npublic class WVParallax : MonoBehaviour {\n \n    [Header(\"背景图片对象，Element 0 为与摄像机同步的背景层\")]\n    public Transform[] backgrounds;\n \n    // 主摄像机\n    private Transform cam;\n    // 上一帧摄像机的位置\n    private Vector3 previousCamPos;\n    // 摄像机同步背景层的 z 值\n    [Header(\"摄像机同步背景层Z值，若0为背景层0\")]\n    public float synZ=0f;\n    [Header(\"偏移x系数\")]\n    public float parallaxScaleX=1f;\n    [Header(\"偏移y系数\")]\n    public float parallaxScaleY=1f;\n \n \n    // 初始化\n    void Start ()\n    {\n        cam = Camera.main.transform;\n        // 上一帧摄像机的位置\n        previousCamPos = cam.position;\n        if(synZ == 0 && null != backgrounds[0])\n        {\n            synZ = backgrounds[0].position.z;\n        }\n        if(synZ == 0)\n        {\n            synZ = 100f;\n        }\n         \n    }\n     \n    // 每一帧执行\n    void Update ()\n    {\n        // 获得摄像机和上一帧的偏移值\n        float parallax = previousCamPos.x - cam.position.x;\n \n        //摄像机偏移矢量\n        Vector3 camMove = cam.position - previousCamPos;\n        camMove.x *= parallaxScaleX;\n        camMove.y *= parallaxScaleY;\n \n        //同步背景\n        for (int i = 0; i \u003C backgrounds.Length; i++)\n        {\n            if (null == backgrounds[i]) continue;\n \n            Vector3 targetToMove = backgrounds[i].position + camMove * (backgrounds[i].position.z/synZ);\n            backgrounds[i].position = targetToMove;\n \n        }\n \n        // 更新上一帧摄像机的位置\n        previousCamPos = cam.position;\n    }\n}\n",[373],{"type":14,"tag":210,"props":374,"children":375},{"__ignoreMap":7},[376],{"type":20,"value":371},{"type":14,"tag":363,"props":378,"children":380},{"id":379},"unity混合模式2",[381],{"type":20,"value":382},"Unity混合模式2",{"type":14,"tag":23,"props":384,"children":385},{},[386],{"type":20,"value":387},"在Unity官方2D游戏Demo中已使用到了视差滚动技术，笔者对此 Demo 中的视差滚动技术进行了研究，Demo 中使用 BackgroundParallax 脚本实现了视差功能，笔者编写此脚本代码说明。",{"type":14,"tag":23,"props":389,"children":390},{},[391],{"type":14,"tag":105,"props":392,"children":395},{"alt":393,"src":394},"4","/images/2019-09-13-Parallax-2d/424-1024x415.jpg",[],{"type":14,"tag":23,"props":397,"children":398},{},[399,401],{"type":20,"value":400},"官方 demo ",{"type":14,"tag":402,"props":403,"children":407},"a",{"href":404,"rel":405},"https://assetstore.unity.com/packages/essentials/tutorial-projects/2d-platformer-11228",[406],"nofollow",[408],{"type":20,"value":409},"链接",{"type":14,"tag":23,"props":411,"children":412},{},[413],{"type":20,"value":414},"BackgroundParallax脚本代码说明：",{"type":14,"tag":205,"props":416,"children":418},{"code":417},"using UnityEngine;\nusing System.Collections;\n\npublic class BackgroundParallax : MonoBehaviour\n{\n    public Transform[] backgrounds;             // Array of all the backgrounds to be parallaxed.\n    public float parallaxScale;                 // The proportion of the camera's movement to move the backgrounds by.\n    public float parallaxReductionFactor;       // How much less each successive layer should parallax.\n    public float smoothing;                     // How smooth the parallax effect should be.\n\n\n    private Transform cam;                      // Shorter reference to the main camera's transform.\n    private Vector3 previousCamPos;             // The postion of the camera in the previous frame.\n\n\n    void Awake ()\n    {\n        // Setting up the reference shortcut.\n        cam = Camera.main.transform;\n    }\n\n\n    void Start ()\n    {\n        // The 'previous frame' had the current frame's camera position.\n        previousCamPos = cam.position;\n    }\n\n\n    void Update ()\n    {\n        // The parallax is the opposite of the camera movement since the previous frame multiplied by the scale.\n        float parallax = (previousCamPos.x - cam.position.x) * parallaxScale;\n\n        // For each successive background...\n        for(int i = 0; i \u003C backgrounds.Length; i++)\n        {\n            // ... set a target x position which is their current position plus the parallax multiplied by the reduction.\n            float backgroundTargetPosX = backgrounds[i].position.x + parallax * (i * parallaxReductionFactor + 1);\n\n            // Create a target position which is the background's current position but with it's target x position.\n            Vector3 backgroundTargetPos = new Vector3(backgroundTargetPosX, backgrounds[i].position.y, backgrounds[i].position.z);\n\n            // Lerp the background's position between itself and it's target position.\n            backgrounds[i].position = Vector3.Lerp(backgrounds[i].position, backgroundTargetPos, smoothing * Time.deltaTime);\n        }\n\n        // Set the previousCamPos to the camera's position at the end of this frame.\n        previousCamPos = cam.position;\n    }\n}\n",[419],{"type":14,"tag":210,"props":420,"children":421},{"__ignoreMap":7},[422],{"type":20,"value":417},{"type":14,"tag":424,"props":425,"children":427},"h2",{"id":426},"结合透视和正交相机在unity2d游戏中制作视差效果",[428],{"type":20,"value":429},"结合透视和正交相机在Unity2D游戏中制作视差效果",{"type":14,"tag":23,"props":431,"children":432},{},[433],{"type":20,"value":434},"在开发MimpiDreams时，我们知道我们想用背景和前景做丰富的视差层。在Steam版本中，有几个图层来管理。所以我们想出了一个可能并不是独一无二的方法，不过在这里还是想概括一下。",{"type":14,"tag":23,"props":436,"children":437},{},[438,440,447],{"type":20,"value":439},"在unity中有好多使用一个正交相机并用脚本移动图层来设置视差层级的教程。还有一些建议用透视相机和对象的Z轴深度。如果这么做了，设置合适的精灵排序就会变的困难，并且还不能使用优化技术和其他想在MimpiDreams中使用的透视相机的特性。经典的 Mimpi 只用了透视相机来创建，对此我们还有一些",{"type":14,"tag":402,"props":441,"children":444},{"href":442,"rel":443},"http://www.manew.com/forum-ask-1.html",[406],[445],{"type":20,"value":446},"问题",{"type":20,"value":448},"。为了节省填充率我们使用了不透明的对象，不过不得不用Z轴偏移来放置它们以免Z方向有冲突。然而，由于对它们应用了透视视角，它们就以不同的速度移动了。",{"type":14,"tag":23,"props":450,"children":451},{},[452],{"type":20,"value":453},"最好的方法是获得两者的优势。设置透视相机来渲染视差层，用正交相机来渲染有角色，平台，拼图等的主平面。",{"type":14,"tag":23,"props":455,"children":456},{},[457],{"type":20,"value":458},"当为视差使用透视相机时，就很容易设置它们了。在正交视差中，需要基于相机的距离来缩放每一个对象并放在适当的位置。Toby: The SecretMine的作者Lukáš Navrátil告诉我他差不多会花掉一半的工作时间来设置正交视差层。随着我们技术的结合，他可以做的更快。",{"type":14,"tag":23,"props":460,"children":461},{},[462],{"type":20,"value":463},"我和我的同事Jaroslav Stehlík一起开发了这种技术。现在让我们看一下如何设置。",{"type":14,"tag":23,"props":465,"children":466},{},[467,473,475,480],{"type":14,"tag":468,"props":469,"children":470},"strong",{},[471],{"type":20,"value":472},"Camera and Scene Setup",{"type":20,"value":474}," ",{"type":14,"tag":468,"props":476,"children":477},{},[478],{"type":20,"value":479},"相机和场景设置",{"type":20,"value":481},"\n层级视图很简单。将视差相机放在主相机的下边，这样它们会一起移动。",{"type":14,"tag":23,"props":483,"children":484},{},[485],{"type":14,"tag":105,"props":486,"children":488},{"alt":105,"src":487},"/images/2019-09-13-Parallax-2d/181708eqz39rii9vrvuopx.png.thumb.jpg",[],{"type":14,"tag":23,"props":490,"children":491},{},[492],{"type":14,"tag":468,"props":493,"children":494},{},[495],{"type":20,"value":496},"Main Camera",{"type":14,"tag":23,"props":498,"children":499},{},[500],{"type":14,"tag":468,"props":501,"children":502},{},[503],{"type":20,"value":504},"主相机",{"type":14,"tag":23,"props":506,"children":507},{},[508],{"type":20,"value":509},"Clear Flags: Don’tclear",{"type":14,"tag":23,"props":511,"children":512},{},[513],{"type":20,"value":514},"Culling Mask except parallax layer",{"type":14,"tag":23,"props":516,"children":517},{},[518],{"type":20,"value":519},"Projection",{"type":14,"tag":23,"props":521,"children":522},{},[523],{"type":20,"value":524},"Depth: -1",{"type":14,"tag":23,"props":526,"children":527},{},[528],{"type":14,"tag":468,"props":529,"children":530},{},[531],{"type":20,"value":532},"Parallax Camera Near",{"type":14,"tag":23,"props":534,"children":535},{},[536],{"type":14,"tag":468,"props":537,"children":538},{},[539],{"type":20,"value":540},"近距离视差相机",{"type":14,"tag":23,"props":542,"children":543},{},[544],{"type":20,"value":545},"Clear Flags: Depthonly",{"type":14,"tag":23,"props":547,"children":548},{},[549],{"type":20,"value":550},"Culling Mask",{"type":14,"tag":23,"props":552,"children":553},{},[554],{"type":20,"value":519},{"type":14,"tag":23,"props":556,"children":557},{},[558],{"type":20,"value":559},"Clipping Planes",{"type":14,"tag":23,"props":561,"children":562},{},[563],{"type":20,"value":564},"Near: 0.01",{"type":14,"tag":23,"props":566,"children":567},{},[568],{"type":20,"value":569},"Far: 10",{"type":14,"tag":23,"props":571,"children":572},{},[573],{"type":20,"value":574},"Depth: 0",{"type":14,"tag":23,"props":576,"children":577},{},[578],{"type":14,"tag":468,"props":579,"children":580},{},[581],{"type":20,"value":582},"Parallax Camera Far",{"type":14,"tag":23,"props":584,"children":585},{},[586],{"type":14,"tag":468,"props":587,"children":588},{},[589],{"type":20,"value":590},"远距离视差相机",{"type":14,"tag":23,"props":592,"children":593},{},[594],{"type":20,"value":595},"Clear Flags: SolidColor (or whatever else you want to use as a background)",{"type":14,"tag":23,"props":597,"children":598},{},[599],{"type":20,"value":550},{"type":14,"tag":23,"props":601,"children":602},{},[603],{"type":20,"value":519},{"type":14,"tag":23,"props":605,"children":606},{},[607],{"type":20,"value":559},{"type":14,"tag":23,"props":609,"children":610},{},[611],{"type":20,"value":612},"Near: 10",{"type":14,"tag":23,"props":614,"children":615},{},[616],{"type":20,"value":617},"Far: 500",{"type":14,"tag":23,"props":619,"children":620},{},[621],{"type":20,"value":622},"Depth: -2",{"type":14,"tag":23,"props":624,"children":625},{},[626],{"type":14,"tag":105,"props":627,"children":629},{"alt":105,"src":628},"/images/2019-09-13-Parallax-2d/camera.png",[],{"type":14,"tag":23,"props":631,"children":632},{},[633],{"type":20,"value":634},"主相机会渲染除正交模式中视差层级之外的所有东西。这需要熟练使用“CullingMask”。“Clipping Planes”解决基于Z轴方向哪个视差对象被哪个视差相机渲染的问题，因此前景在正交平面之前，背景则在它的后边。相机放在Z轴-10的位置，所以在Z \u003C 0的视差中的所有东西都会被近处的相机渲染，在Z > 0位置的对象就会被远处的相机渲染。“Depth”决定相机被渲染的正确顺序。",{"type":14,"tag":23,"props":636,"children":637},{},[638],{"type":20,"value":639},"现在在编辑器中需要把所有的视差对象放入视差层中，并将其他所有对象移出该层。",{"type":14,"tag":23,"props":641,"children":642},{},[643],{"type":14,"tag":105,"props":644,"children":646},{"alt":105,"src":645},"/images/2019-09-13-Parallax-2d/cameraview.png",[],{"type":14,"tag":23,"props":648,"children":649},{},[650],{"type":20,"value":651},"你需要考虑正交相机的尺寸和视角设置的透视区域。尤其想在游戏中使用变焦的时候，需要基于主相机的正交尺寸来设置视差的相机视角区域。关键是通常有一个特殊的平面（这个案例中为Z = 0），即视差层会和正交透视有同样的移动速度。这点很重要，因为稍后可以移动和缩放相机并且它会表现的很自然。在Mimpi Dreams开发初期，我们没有意识到那些并在视差设置中出现一些错误。我们不可以稍后更改它，因为它会复位所有的视差层。最后，由于我们没有过多的使用缩放，所以并没有产生多大影响。在下一个工程中，我们肯定会用这个设置。",{"type":14,"tag":23,"props":653,"children":654},{},[655],{"type":20,"value":656},"这里有一段可以设置缩放的代码。",{"type":14,"tag":205,"props":658,"children":660},{"code":659},"public float GetFieldOfView(float orthoSize, float distanceFromOrigin)\n{\n    // orthoSize\n    float a = orthoSize;\n    // distanceFromOrigin\n    float b = Mathf.Abs(distanceFromOrigin);\n \n    float fieldOfView = Mathf.Atan(a / b)  * Mathf.Rad2Deg * 2f;\n    return fieldOfView;\n}\n",[661],{"type":14,"tag":210,"props":662,"children":663},{"__ignoreMap":7},[664],{"type":20,"value":659},{"type":14,"tag":23,"props":666,"children":667},{},[668],{"type":20,"value":669},"如果想在Z轴移动相机，则需要更新视差相机的裁剪平面。",{"type":14,"tag":205,"props":671,"children":673},{"code":672},"// distanceFromOrigin\nfloat b = Mathf.Abs(mainCamera.transform.position.z);\n \n//change clipping planes based on main camera z-position\nfarCamera.nearClipPlane = b;\nfarCamera.farClipPlane = mainCamera.farClipPlane;\nnearCamera.farClipPlane = b;\nnearCamera.nearClipPlane = mainCamera.nearClipPlane;\n",[674],{"type":14,"tag":210,"props":675,"children":676},{"__ignoreMap":7},[677],{"type":20,"value":672},{"type":14,"tag":23,"props":679,"children":680},{},[681],{"type":20,"value":682},"如何变焦相机有两个选择。",{"type":14,"tag":23,"props":684,"children":685},{},[686],{"type":20,"value":687},"可以在Z轴移动主相机（并重新计算裁剪平面），或者可以改变主相机的正交尺寸（并重新计算视差相机的视角区域）。两个选择给出不同的效果，改变正交尺寸是更自然的选择。或者，可以结合这两种技术，看下边的视频。",{"type":14,"tag":23,"props":689,"children":690},{},[691],{"type":14,"tag":468,"props":692,"children":693},{},[694],{"type":20,"value":695},"unity 实例",{"type":14,"tag":23,"props":697,"children":698},{},[699],{"type":20,"value":700},"Jaroslav准备并给出了你们可以尝试并学习的unity工程。感谢unity提供精选案例的免费资源！",{"type":14,"tag":23,"props":702,"children":703},{},[704],{"type":20,"value":705},"可以从Github下载案例工程。",{"type":14,"tag":23,"props":707,"children":708},{},[709],{"type":20,"value":710},"工程是用Unity 5.3.3f1制作的。",{"type":14,"tag":23,"props":712,"children":713},{},[714],{"type":20,"value":715},"还要看一下展示案例的视频。",{"type":14,"tag":23,"props":717,"children":718},{},[719],{"type":14,"tag":402,"props":720,"children":723},{"href":721,"rel":722},"https://www.youtube.com/watch?v=ptdweDDyB8o&feature=youtu.be",[406],[724],{"type":14,"tag":105,"props":725,"children":727},{"alt":7,"src":726},"/images/2019-09-13-Parallax-2d/0%5B1%5D.jpg",[],{"type":14,"tag":23,"props":729,"children":730},{},[731,736],{"type":14,"tag":468,"props":732,"children":733},{},[734],{"type":20,"value":735},"编辑工作流程",{"type":20,"value":737},"\n在视差层设置对象最好的方法是在编辑模式下去播放游戏。可以移动角色（和相机）让玩家看到它并调整对象至实际视口。唯一的问题是播放模式下在unity中做出的更改不会保存。然而可以在播放模式下拷贝编辑过的对象并粘贴到编辑器中然后保存。我们创建一个有子集的“content”。这个content是在播放模式下编辑和复制过的。退出播放模式后，这个原始的content会被删除，新的content从剪切板粘贴过来，然后预制件就可以使用了。",{"type":14,"tag":23,"props":739,"children":740},{},[741],{"type":14,"tag":105,"props":742,"children":744},{"alt":105,"src":743},"/images/2019-09-13-Parallax-2d/181709gdpgid33t93vjfyf.png.thumb.jpg",[],{"type":14,"tag":23,"props":746,"children":747},{},[748],{"type":20,"value":749},"还有，不要忘记将新的对象放到视差层中。还可以编写或者使用一些编辑器工具来帮助你保存和自动完成对象层级设置。",{"type":14,"tag":23,"props":751,"children":752},{},[753],{"type":20,"value":754},"上边的案例实在编辑模式下执行的，所以可以在编辑器中用它来设置。不过我们在MimpiDreams中使用了这个工作流程，因为这对于美术设计在场景中移动很容易，并且他可以自己调整层级。",{"type":14,"tag":23,"props":756,"children":757},{},[758,763,764],{"type":14,"tag":468,"props":759,"children":760},{},[761],{"type":20,"value":762},"Summary",{"type":20,"value":474},{"type":14,"tag":468,"props":765,"children":766},{},[767],{"type":20,"value":768},"总结",{"type":14,"tag":23,"props":770,"children":771},{},[772],{"type":14,"tag":105,"props":773,"children":775},{"alt":105,"src":774},"/images/2019-09-13-Parallax-2d/181711j5s29z585k932ot6.gif",[],{"type":14,"tag":23,"props":777,"children":778},{},[779,784,785],{"type":14,"tag":468,"props":780,"children":781},{},[782],{"type":20,"value":783},"Some advantages of this solution",{"type":20,"value":474},{"type":14,"tag":468,"props":786,"children":787},{},[788],{"type":20,"value":789},"这种解决方案的优势：",{"type":14,"tag":23,"props":791,"children":792},{},[793],{"type":20,"value":794},"本地基本设置（脚本仅仅为了变焦）",{"type":14,"tag":23,"props":796,"children":797},{},[798],{"type":20,"value":799},"案例中更好的表现",{"type":14,"tag":23,"props":801,"children":802},{},[803],{"type":20,"value":804},"静态批处理，因为层级不会移动",{"type":14,"tag":23,"props":806,"children":807},{},[808],{"type":20,"value":809},"简单的编辑工作流程",{"type":14,"tag":23,"props":811,"children":812},{},[813,818,819],{"type":14,"tag":468,"props":814,"children":815},{},[816],{"type":20,"value":817},"Disadvantages",{"type":20,"value":474},{"type":14,"tag":468,"props":820,"children":821},{},[822],{"type":20,"value":823},"劣势:",{"type":14,"tag":23,"props":825,"children":826},{},[827],{"type":20,"value":828},"会产生更多的draw calls",{"type":14,"tag":23,"props":830,"children":831},{},[832],{"type":20,"value":833},"我们介绍了和Mimpi Dreams中制作视差效果不同的制作方法。你可能需要自定义一些东西。例如，我们显示所有摄像机的渲染纹理，不过在这边文章中，我想介绍最简单的设置。",{"type":14,"tag":205,"props":835,"children":837},{"code":836},"using UnityEngine;\nusing System.Collections;\n\n[ExecuteInEditMode]\npublic class CameraParallax : MonoBehaviour {\n\n  public Camera mainCamera;\n  public Camera farCamera;\n  public Camera nearCamera;\n\n  void OnEnable()\n  {\n      InitCameras();\n  }\n\n  void LateUpdate()\n  {\n      UpdateCameras();\n  }\n\n  public void InitCameras()\n  {\n      if(farCamera != null)\n      {\n          farCamera.transform.localPosition = Vector3.zero;\n          farCamera.transform.rotation = Quaternion.identity;\n          farCamera.transform.localScale = Vector3.one;\n          farCamera.orthographic = false;\n          farCamera.clearFlags = CameraClearFlags.SolidColor;\n          farCamera.depth = -2;\n          farCamera.transparencySortMode = TransparencySortMode.Orthographic;\n      }\n\n      if(mainCamera != null)\n      {\n          mainCamera.orthographic = true;\n          mainCamera.clearFlags = CameraClearFlags.Nothing;\n          mainCamera.depth = -1;\n      }\n\n      if(nearCamera != null)\n      {\n          nearCamera.transform.localPosition = Vector3.zero;\n          nearCamera.transform.rotation = Quaternion.identity;\n          nearCamera.transform.localScale = Vector3.one;\n          nearCamera.orthographic = false;\n          nearCamera.clearFlags = CameraClearFlags.Depth;\n          nearCamera.depth = 0;\n          nearCamera.transparencySortMode = TransparencySortMode.Orthographic;\n      }\n  }\n\n  public void UpdateCameras()\n  {\n      if(mainCamera == null || farCamera == null || nearCamera == null) return;\n\n      // orthoSize\n      float a = mainCamera.orthographicSize;\n      // distanceFromOrigin\n      float b = Mathf.Abs(mainCamera.transform.position.z);\n\n      //change clipping planes based on main camera z-position\n      farCamera.nearClipPlane = b;\n      farCamera.farClipPlane = mainCamera.farClipPlane;\n      nearCamera.farClipPlane = b;\n      nearCamera.nearClipPlane = mainCamera.nearClipPlane;\n\n      //update field fo view for parallax cameras\n      float fieldOfView = Mathf.Atan(a / b)  * Mathf.Rad2Deg * 2f;\n      nearCamera.fieldOfView = farCamera.fieldOfView = fieldOfView;\n  }\n\n}\n",[838],{"type":14,"tag":210,"props":839,"children":840},{"__ignoreMap":7},[841],{"type":20,"value":836},{"type":14,"tag":23,"props":843,"children":844},{},[845],{"type":20,"value":846},"原文链接：",{"type":14,"tag":848,"props":849,"children":850},"ul",{},[851,860],{"type":14,"tag":48,"props":852,"children":853},{},[854],{"type":14,"tag":402,"props":855,"children":858},{"href":856,"rel":857},"http://www.gamasutra.com/blogs/MichalBerlinger/20160323/268657/Combining_Perspective_and_Orthographic_Camera_for_Parallax_Effect_in_2D_Game.php",[406],[859],{"type":20,"value":856},{"type":14,"tag":48,"props":861,"children":862},{},[863],{"type":14,"tag":402,"props":864,"children":867},{"href":865,"rel":866},"https://github.com/MichalBerlinger/ParallaxDemo",[406],[868],{"type":20,"value":865},{"title":7,"searchDepth":870,"depth":870,"links":871},2,[872,874,875],{"id":365,"depth":873,"text":368},3,{"id":379,"depth":873,"text":382},{"id":426,"depth":870,"text":429},"markdown","content:unity:2019-09-13-Parallax-2d.md","content","unity/2019-09-13-Parallax-2d.md","md","2019-09-13",[883,893,1020,1069,1121,1134,1246],{"title":884,"_path":885,"children":886},"Art","/art",[887,890],{"title":888,"_path":889},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":891,"_path":892},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":894,"_path":895,"children":896},"Dotnet","/dotnet",[897,900,903,906,909,912,915,918,921,924,927,930,933,936,939,942,945,948,951,954,957,960,963,966,969,972,975,978,981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017],{"title":898,"_path":899},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":901,"_path":902},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":904,"_path":905},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":907,"_path":908},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":910,"_path":911},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":913,"_path":914},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":916,"_path":917},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":919,"_path":920},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":922,"_path":923},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":925,"_path":926},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":928,"_path":929},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":931,"_path":932},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":934,"_path":935},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":937,"_path":938},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":940,"_path":941},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":943,"_path":944},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":946,"_path":947},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":949,"_path":950},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":952,"_path":953},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":955,"_path":956},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":958,"_path":959},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":961,"_path":962},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":964,"_path":965},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":967,"_path":968},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":970,"_path":971},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":973,"_path":974},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":976,"_path":977},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":979,"_path":980},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":982,"_path":983},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":985,"_path":986},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":988,"_path":989},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":991,"_path":992},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":994,"_path":995},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":997,"_path":998},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1000,"_path":1001},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1003,"_path":1004},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1006,"_path":1007},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1009,"_path":1010},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1012,"_path":1013},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1015,"_path":1016},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1018,"_path":1019},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1021,"_path":1022,"children":1023},"Game","/game",[1024,1027,1030,1033,1036,1039,1042,1045,1048,1051,1054,1057,1060,1063,1066],{"title":1025,"_path":1026},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1028,"_path":1029},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1031,"_path":1032},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1034,"_path":1035},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1037,"_path":1038},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1040,"_path":1041},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1043,"_path":1044},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1046,"_path":1047},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1049,"_path":1050},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1052,"_path":1053},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1055,"_path":1056},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1058,"_path":1059},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1061,"_path":1062},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1064,"_path":1065},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1067,"_path":1068},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1070,"_path":1071,"children":1072},"Gyj","/gyj",[1073,1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118],{"title":1074,"_path":1075},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1077,"_path":1078},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1080,"_path":1081},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1083,"_path":1084},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1086,"_path":1087},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1089,"_path":1090},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1092,"_path":1093},"玩法","/gyj/2022-08-22-wanfa",{"title":1095,"_path":1096},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1098,"_path":1099},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1101,"_path":1102},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1104,"_path":1105},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1107,"_path":1108},"门派内容相关","/gyj/2022-11-17-sect",{"title":1110,"_path":1111},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1113,"_path":1114},"种植","/gyj/2022-12-01-zhongzhi",{"title":1116,"_path":1117},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1119,"_path":1120},"跑商","/gyj/2023-11-01-paoshang",{"title":1122,"_path":1123,"children":1124},"Js","/js",[1125,1128,1131],{"title":1126,"_path":1127},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1129,"_path":1130},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1132,"_path":1133},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1135,"_path":1136,"children":1137},"Tool","/tool",[1138,1141,1144,1147,1150,1153,1156,1159,1162,1165,1168,1171,1174,1177,1180,1183,1186,1189,1192,1195,1198,1201,1204,1207,1210,1213,1216,1219,1222,1225,1228,1231,1234,1237,1240,1243],{"title":1139,"_path":1140},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1142,"_path":1143},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1145,"_path":1146},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1148,"_path":1149},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1151,"_path":1152},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1154,"_path":1155},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1157,"_path":1158},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1160,"_path":1161},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1163,"_path":1164},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1166,"_path":1167},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1169,"_path":1170},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1172,"_path":1173},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1175,"_path":1176},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1178,"_path":1179},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1181,"_path":1182},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1184,"_path":1185},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1187,"_path":1188},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1190,"_path":1191},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1193,"_path":1194},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1196,"_path":1197},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1199,"_path":1200},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1202,"_path":1203},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1205,"_path":1206},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1208,"_path":1209},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1211,"_path":1212},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1214,"_path":1215},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1217,"_path":1218},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1220,"_path":1221},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1223,"_path":1224},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1226,"_path":1227},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1229,"_path":1230},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1232,"_path":1233},"rider的使用","/tool/2022-08-02-rider-use",{"title":1235,"_path":1236},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1238,"_path":1239},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1241,"_path":1242},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1244,"_path":1245},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1247,"_path":1248,"children":1249},"Unity","/unity",[1250,1253,1256,1259,1262,1265,1268,1271,1274,1277,1280,1283,1286,1289,1292,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392,1395,1398,1401,1404,1407,1410,1413,1416,1419,1422,1425,1428,1431,1434,1437,1440,1443,1446,1449,1452,1455,1458,1461],{"title":1251,"_path":1252},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1254,"_path":1255},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1257,"_path":1258},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1260,"_path":1261},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1263,"_path":1264},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1266,"_path":1267},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1269,"_path":1270},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1272,"_path":1273},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1275,"_path":1276},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1278,"_path":1279},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1281,"_path":1282},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1284,"_path":1285},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1287,"_path":1288},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1290,"_path":1291},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":8,"_path":4},{"title":1294,"_path":1295},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1297,"_path":1298},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1300,"_path":1301},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1303,"_path":1304},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1306,"_path":1307},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1309,"_path":1310},"技能系统","/unity/2020-02-15-skill-system",{"title":1312,"_path":1313},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1315,"_path":1316},"角色状态设计","/unity/2020-02-17-character-states",{"title":1318,"_path":1319},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1321,"_path":1322},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1324,"_path":1325},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1327,"_path":1328},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1330,"_path":1331},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1333,"_path":1334},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1336,"_path":1337},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1339,"_path":1340},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1342,"_path":1343},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1345,"_path":1346},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1348,"_path":1349},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1351,"_path":1352},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1354,"_path":1355},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1357,"_path":1358},"unity的addressables","/unity/2020-09-12-addressables",{"title":1360,"_path":1361},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1363,"_path":1364},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1366,"_path":1367},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1369,"_path":1370},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1372,"_path":1373},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1375,"_path":1376},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1378,"_path":1379},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1381,"_path":1382},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1384,"_path":1385},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1387,"_path":1388},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1390,"_path":1391},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1393,"_path":1394},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1396,"_path":1397},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1399,"_path":1400},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1402,"_path":1403},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1405,"_path":1406},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1408,"_path":1409},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1411,"_path":1412},"ability","/unity/2020-11-16-dotssample",{"title":1414,"_path":1415},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1417,"_path":1418},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1420,"_path":1421},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1423,"_path":1424},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1426,"_path":1427},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1429,"_path":1430},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1432,"_path":1433},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1435,"_path":1436},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1438,"_path":1439},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1441,"_path":1442},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1444,"_path":1445},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1447,"_path":1448},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1450,"_path":1451},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1453,"_path":1454},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1456,"_path":1457},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1459,"_path":1460},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1462,"_path":1463},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041586]