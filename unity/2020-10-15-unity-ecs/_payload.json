[{"data":1,"prerenderedAt":1643},["Reactive",2],{"content-query-usZZ7TEGXz":3,"content-navigation-8C37fagqQL":1061},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1055,"_id":1056,"_source":1057,"_file":1058,"_extension":1059,"date":1060},"/unity/2020-10-15-unity-ecs","unity",false,"","UNITY ECS 详解","DOTS面向数据栈编程ecs   在OOP方法中，数据不会被组织起来，而是会分散再整个内存中，这是因为使用了自动内存管理功能。job system 传统只使用了单线程,配合ecs提供了多线程解决方案brust compiler 将c#直接转换为汇编ECS核心概念这个图中，System读取了多个实体的Translation和Rotation组件，然后经过计算处理，将结果更新到LocalToWorld组件中。从图中你可以看到，实体A和B还有Renderer组件，但是C并没有。不过这并不会影响System的计算逻辑，因为这个系统不关心Renderer组件。原型 Archetypes多个组件的组合叫做",{"type":11,"children":12,"toc":1038},"root",[13,21,41,48,56,86,99,106,111,116,123,128,133,152,157,162,169,174,179,196,201,207,212,221,226,246,266,273,278,286,294,302,310,326,334,342,350,355,371,379,394,402,410,418,424,429,450,458,463,471,476,481,486,500,505,513,521,608,613,621,632,645,653,664,685,703,709,715,787,806,810,815,848,860,866,923,928,934,954,959,964,970,975],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":20},"text","DOTS面向数据栈编程",{"type":14,"tag":22,"props":23,"children":24},"ul",{},[25,31,36],{"type":14,"tag":26,"props":27,"children":28},"li",{},[29],{"type":19,"value":30},"ecs   在OOP方法中，数据不会被组织起来，而是会分散再整个内存中，这是因为使用了自动内存管理功能。",{"type":14,"tag":26,"props":32,"children":33},{},[34],{"type":19,"value":35},"job system 传统只使用了单线程,配合ecs提供了多线程解决方案",{"type":14,"tag":26,"props":37,"children":38},{},[39],{"type":19,"value":40},"brust compiler 将c#直接转换为汇编",{"type":14,"tag":42,"props":43,"children":45},"h1",{"id":44},"ecs核心概念",[46],{"type":19,"value":47},"ECS核心概念",{"type":14,"tag":15,"props":49,"children":50},{},[51],{"type":14,"tag":52,"props":53,"children":55},"img",{"alt":52,"src":54},"/images/2020-10-15-unity-ecs/ECSBlockDiagram.png",[],{"type":14,"tag":15,"props":57,"children":58},{},[59,61,68,70,76,78,84],{"type":19,"value":60},"这个图中，System读取了多个实体的",{"type":14,"tag":62,"props":63,"children":65},"code",{"className":64},[],[66],{"type":19,"value":67},"Translation",{"type":19,"value":69},"和",{"type":14,"tag":62,"props":71,"children":73},{"className":72},[],[74],{"type":19,"value":75},"Rotation",{"type":19,"value":77},"组件，然后经过计算处理，将结果更新到",{"type":14,"tag":62,"props":79,"children":81},{"className":80},[],[82],{"type":19,"value":83},"LocalToWorld",{"type":19,"value":85},"组件中。",{"type":14,"tag":15,"props":87,"children":88},{},[89,91,97],{"type":19,"value":90},"从图中你可以看到，实体A和B还有Renderer组件，但是C并没有。不过这并不会影响System的计算逻辑，因为这个系统不关心",{"type":14,"tag":62,"props":92,"children":94},{"className":93},[],[95],{"type":19,"value":96},"Renderer",{"type":19,"value":98},"组件。",{"type":14,"tag":100,"props":101,"children":103},"h2",{"id":102},"原型-archetypes",[104],{"type":19,"value":105},"原型 Archetypes",{"type":14,"tag":15,"props":107,"children":108},{},[109],{"type":19,"value":110},"多个组件的组合叫做一个原型。",{"type":14,"tag":15,"props":112,"children":113},{},[114],{"type":19,"value":115},"比如一个3D物体可能会包含用于transform的组件，包括移动、旋转、渲染，每个3D物体对应一个实体，但是他们都有同样的组件，所以ECS会把他们分类成是一类原型。",{"type":14,"tag":15,"props":117,"children":118},{},[119],{"type":14,"tag":52,"props":120,"children":122},{"alt":52,"src":121},"/images/2020-10-15-unity-ecs/ArchetypeDiagram.png",[],{"type":14,"tag":15,"props":124,"children":125},{},[126],{"type":19,"value":127},"在上图中，实体A和B的原型都是M，实体C的原型是N。",{"type":14,"tag":15,"props":129,"children":130},{},[131],{"type":19,"value":132},"你也可以通过在运行时添加或者移除component来改变一个实体的原型。例如：如果将实体B的Renderer组件移除，实体B的原型就会变成N。",{"type":14,"tag":15,"props":134,"children":135},{},[136,138,144,150],{"type":19,"value":137},"一个实体的原型是什么，决定了ECS会将实体的components也就是数据存在什么地方。",{"type":14,"tag":139,"props":140,"children":141},"strong",{},[142],{"type":19,"value":143},"ECS按块分配内存，每块用一个",{"type":14,"tag":62,"props":145,"children":147},{"className":146},[],[148],{"type":19,"value":149},"ArchetypeChunk",{"type":19,"value":151},"对象表示。",{"type":14,"tag":15,"props":153,"children":154},{},[155],{"type":19,"value":156},"一个块只包含一种原型，可以包含的多个实体的数据。如果一个块的内存满了，ECS会分配一个新的块来存储新的实体的components。",{"type":14,"tag":15,"props":158,"children":159},{},[160],{"type":19,"value":161},"如果你修改了实体的组件，那就相当于修改了实体的原型，这时候ECS会将实体的组件数据移到另外一个块中。",{"type":14,"tag":15,"props":163,"children":164},{},[165],{"type":14,"tag":52,"props":166,"children":168},{"alt":52,"src":167},"/images/2020-10-15-unity-ecs/ArchetypeChunkDiagram.png",[],{"type":14,"tag":15,"props":170,"children":171},{},[172],{"type":19,"value":173},"原型和内存块的关系是一对多的关系。这就意味着，如果想查询给定的一组component类型的所有实体，只需要在这些原型中搜索即可。这样会比在所有的实体中查找效率高很多。",{"type":14,"tag":15,"props":175,"children":176},{},[177],{"type":19,"value":178},"ECS在存储实体到内存块中没有特殊的排序，当创建一个实体或者实体的原型发生变化时，ECS会将它放到对应原型的第一个还有空间的内存块中。内存块中的数据会紧密排列。如果一个实体要被移出当前原型的内存块，这时候会有个空位，ECS会把这个内存块最后的实体数据移动到这个空位中。",{"type":14,"tag":15,"props":180,"children":181},{},[182,187,189,194],{"type":14,"tag":139,"props":183,"children":184},{},[185],{"type":19,"value":186},"注意",{"type":19,"value":188},"：原型中的",{"type":14,"tag":139,"props":190,"children":191},{},[192],{"type":19,"value":193},"共享组件",{"type":19,"value":195},"（后面会具体说这是个什么东东）的数据也会影响实体会被存在哪个内存块。同一个内存块中的所有实体的共享组件中的数据值都是相同的。如果你修改了共享组件中的数据，这个实体会被移到另外一个块中，有点类似修改了实体的原型。",{"type":14,"tag":15,"props":197,"children":198},{},[199],{"type":19,"value":200},"将共享组件的实体分到一个内存块中会提高处理他们的速度。比如Hybird Renderer（混合渲染）定义了RenderMesh组件来达成这个目的。",{"type":14,"tag":100,"props":202,"children":204},{"id":203},"实体-entity",[205],{"type":19,"value":206},"实体 Entity",{"type":14,"tag":15,"props":208,"children":209},{},[210],{"type":19,"value":211},"在代码层面，你就可以了解到，实体非常非常的简单。它的核心部分：",{"type":14,"tag":213,"props":214,"children":216},"pre",{"code":215},"public struct Entity\n{\n  public int Index;\n  public int Version; \n}\n",[217],{"type":14,"tag":62,"props":218,"children":219},{"__ignoreMap":7},[220],{"type":19,"value":215},{"type":14,"tag":15,"props":222,"children":223},{},[224],{"type":19,"value":225},"Index表示这个实体的ID，和身份证一样用于实体与实体之间区分。Version用于描述这个实体的生命周期，由于实体是可以重用的，那么就需要用Version来区分这个Entity是新生实体，还是即将销毁的实体。",{"type":14,"tag":15,"props":227,"children":228},{},[229,231,237,239,244],{"type":19,"value":230},"ECS中有一个",{"type":14,"tag":62,"props":232,"children":234},{"className":233},[],[235],{"type":19,"value":236},"EntityManager",{"type":19,"value":238},"类来管理一个World中的所有实体。",{"type":14,"tag":62,"props":240,"children":242},{"className":241},[],[243],{"type":19,"value":236},{"type":19,"value":245},"使用列表维护所有实体以及和实体关联的数据，以便达到最优的性能。",{"type":14,"tag":15,"props":247,"children":248},{},[249,251,257,259,264],{"type":19,"value":250},"虽然entity没有类型，但是可以根据entity关联的component将他们分组，也就是上一节讲的实体原型（EntityArchetype），EntityManager会持续跟踪这些实体原型。你可以使用已有的",{"type":14,"tag":62,"props":252,"children":254},{"className":253},[],[255],{"type":19,"value":256},"EntityArchetype",{"type":19,"value":258},"来创建entity，也可以提前创建",{"type":14,"tag":62,"props":260,"children":262},{"className":261},[],[263],{"type":19,"value":256},{"type":19,"value":265},"，以便后面的使用。",{"type":14,"tag":267,"props":268,"children":270},"h3",{"id":269},"创建entity",[271],{"type":19,"value":272},"创建Entity",{"type":14,"tag":15,"props":274,"children":275},{},[276],{"type":19,"value":277},"通过以下方法可以一次创建一个Entity：",{"type":14,"tag":22,"props":279,"children":280},{},[281],{"type":14,"tag":26,"props":282,"children":283},{},[284],{"type":19,"value":285},"使用ComponentType的数组来创建一个entity",{"type":14,"tag":213,"props":287,"children":289},{"code":288},"EntityManager.CreateEntity(ComponentType[])\n",[290],{"type":14,"tag":62,"props":291,"children":292},{"__ignoreMap":7},[293],{"type":19,"value":288},{"type":14,"tag":22,"props":295,"children":296},{},[297],{"type":14,"tag":26,"props":298,"children":299},{},[300],{"type":19,"value":301},"使用EntityArchetype来创建一个entity",{"type":14,"tag":213,"props":303,"children":305},{"code":304},"EntityManager.CreateEntity(EntityArchetype)\n",[306],{"type":14,"tag":62,"props":307,"children":308},{"__ignoreMap":7},[309],{"type":19,"value":304},{"type":14,"tag":22,"props":311,"children":312},{},[313],{"type":14,"tag":26,"props":314,"children":315},{},[316,318,324],{"type":19,"value":317},"通过",{"type":14,"tag":62,"props":319,"children":321},{"className":320},[],[322],{"type":19,"value":323},"EntityManager.Instantiate",{"type":19,"value":325},"复制一个已有的entity，包括它里面的数据",{"type":14,"tag":213,"props":327,"children":329},{"code":328},"EntityManager.Instantiate(Entity srcEntity);\nEntityManager.Instantiate(NativeArray\u003CEntity> srcEntities, NativeArray\u003CEntity> outputEntities)\n",[330],{"type":14,"tag":62,"props":331,"children":332},{"__ignoreMap":7},[333],{"type":19,"value":328},{"type":14,"tag":22,"props":335,"children":336},{},[337],{"type":14,"tag":26,"props":338,"children":339},{},[340],{"type":19,"value":341},"也可以创建一个空的Entity，在需要的时候在加上components。(您可以立即添加组件，也可以根据需要添加其他组件。)",{"type":14,"tag":213,"props":343,"children":345},{"code":344},"var entity = EntityManager.CreateEntity();\nEntityManager.AddComponent(Entity entity, ComponentType componentType)\n",[346],{"type":14,"tag":62,"props":347,"children":348},{"__ignoreMap":7},[349],{"type":19,"value":344},{"type":14,"tag":15,"props":351,"children":352},{},[353],{"type":19,"value":354},"你也可以通过下面的方法一次创建多个Entity：",{"type":14,"tag":22,"props":356,"children":357},{},[358],{"type":14,"tag":26,"props":359,"children":360},{},[361,363,369],{"type":19,"value":362},"使用",{"type":14,"tag":62,"props":364,"children":366},{"className":365},[],[367],{"type":19,"value":368},"CreateEntity",{"type":19,"value":370},"方法一次性填充多个新的Entity到一个NativeArry中，这些entity用同样的原型",{"type":14,"tag":213,"props":372,"children":374},{"code":373},"EntityManager.CreateEntity(EntityArchetype archetype, NativeArray\u003CEntity> entities)\n",[375],{"type":14,"tag":62,"props":376,"children":377},{"__ignoreMap":7},[378],{"type":19,"value":373},{"type":14,"tag":22,"props":380,"children":381},{},[382],{"type":14,"tag":26,"props":383,"children":384},{},[385,386,392],{"type":19,"value":362},{"type":14,"tag":62,"props":387,"children":389},{"className":388},[],[390],{"type":19,"value":391},"Instantiate",{"type":19,"value":393},"方法一次性复制多个entity，包含数据",{"type":14,"tag":213,"props":395,"children":397},{"code":396},"EntityManager.Instantiate(NativeArray\u003CEntity> srcEntities, NativeArray\u003CEntity> outputEntities)\n",[398],{"type":14,"tag":62,"props":399,"children":400},{"__ignoreMap":7},[401],{"type":19,"value":396},{"type":14,"tag":22,"props":403,"children":404},{},[405],{"type":14,"tag":26,"props":406,"children":407},{},[408],{"type":19,"value":409},"显式创建使用指定数量的实体填充的块，并使用CreateChunk创建给定原型",{"type":14,"tag":213,"props":411,"children":413},{"code":412},"EntityManager.CreateChunk(EntityArchetype, NativeArray\u003CArchetypeChunk>, Int32)\n",[414],{"type":14,"tag":62,"props":415,"children":416},{"__ignoreMap":7},[417],{"type":19,"value":412},{"type":14,"tag":267,"props":419,"children":421},{"id":420},"添加删除-component",[422],{"type":19,"value":423},"添加/删除 component",{"type":14,"tag":15,"props":425,"children":426},{},[427],{"type":19,"value":428},"创建完Entity后，你可以添加或者移除component。注意添加或移除component时，entity的原型会发生变化，这时候EntityManager需要将entity移到其他内存块，并将当前内存块的空位补上。",{"type":14,"tag":15,"props":430,"children":431},{},[432,434,440,442,448],{"type":19,"value":433},"对实体的更改导致结构性更改-会造成Entity原型变化的操作不能在Job里面执行，比如添加移除component、修改",{"type":14,"tag":62,"props":435,"children":437},{"className":436},[],[438],{"type":19,"value":439},"SharedComponentData",{"type":19,"value":441},"中的值、销毁entity。你可以将前面说的这几种操作放进",{"type":14,"tag":62,"props":443,"children":445},{"className":444},[],[446],{"type":19,"value":447},"EntityCommandBuffer",{"type":19,"value":449},"中，在job执行完成后执行这个command buffer。后面还会具体讲解CommandBuffer。",{"type":14,"tag":213,"props":451,"children":453},{"code":452},"struct Lifetime : IComponentData\n{\n    public byte Value;\n}\n\nclass LifetimeSystem : SystemBase\n{\n    EndSimulationEntityCommandBufferSystem m_EndSimulationEcbSystem;\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        // 从World中获取ECS系统并且存起来\n        m_EndSimulationEcbSystem = World\n            .GetOrCreateSystem\u003CEndSimulationEntityCommandBufferSystem>();\n    }\n\n    protected override void OnUpdate()\n    {\n        // 请求一个ECB并且转换成可并行的\n        var ecb = m_EndSimulationEcbSystem.CreateCommandBuffer().AsParallelWriter();\n        Entities\n            .ForEach((Entity entity, int entityInQueryIndex, ref Lifetime lifetime) =>\n        {\n            // 检测entity的lifetime，如果为0则销毁它\n            if (lifetime.Value == 0)\n            {\n                // 将entityInQueryIndex传给操作，这样ECS回放时能保证正确的顺序\n                ecb.DestroyEntity(entityInQueryIndex, entity);\n            }\n            else\n            {\n                lifetime.Value -= 1;\n            }\n        }).ScheduleParallel();\n\n        // 保证ECB system依赖当前这个Job\n        m_EndSimulationEcbSystem.AddJobHandleForProducer(this.Dependency);\n    }\n}\n",[454],{"type":14,"tag":62,"props":455,"children":456},{"__ignoreMap":7},[457],{"type":19,"value":452},{"type":14,"tag":15,"props":459,"children":460},{},[461],{"type":19,"value":462},"EntityManager也提供了方法用来添加、移除单个entity中的组件，也可以移除一个entity的NativeArray中的组件。后面组件部分会详细说明。",{"type":14,"tag":213,"props":464,"children":466},{"code":465},"EntityManager.AddComponent(Entity entity, ComponentType componentType)\n",[467],{"type":14,"tag":62,"props":468,"children":469},{"__ignoreMap":7},[470],{"type":19,"value":465},{"type":14,"tag":267,"props":472,"children":474},{"id":473},"访问实体数据",[475],{"type":19,"value":473},{"type":14,"tag":15,"props":477,"children":478},{},[479],{"type":19,"value":480},"遍历实体和组件最有效的方式时在一个并行化的Job中按顺序处理组件 . 这利用了CPU的多核性能，并避免CPU的缓存丢失",{"type":14,"tag":15,"props":482,"children":483},{},[484],{"type":19,"value":485},"ECS API提供了多种遍历的方式，每个都有自己的性能影响和限制. 下面是方法:",{"type":14,"tag":487,"props":488,"children":490},"h4",{"id":489},"systembaseentitiesforeach",[491],{"type":14,"tag":492,"props":493,"children":497},"a",{"href":494,"rel":495},"https://docs.unity3d.com/Packages/com.unity.entities@0.14/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities",[496],"nofollow",[498],{"type":19,"value":499},"SystemBase.Entities.ForEach",{"type":14,"tag":15,"props":501,"children":502},{},[503],{"type":19,"value":504},"使用一个job结构来有效的遍历实体.",{"type":14,"tag":213,"props":506,"children":508},{"code":507},"       Entities\n           .WithName(\"Update_Position\") // Shown in error messages and profiler\n           .WithAll\u003CLocalToWorld>() // Require the LocalToWorld component\n           .ForEach(\n               // Write to Displacement (ref), read Velocity (in)\n               (ref Position position, in Velocity velocity) =>\n               {\n                   //Execute for each selected entity\n                   position = new Position()\n                   {\n                       // dT is a captured variable\n                       Value = position.Value + velocity.Value * dT\n                   };\n               }\n           )\n           .ScheduleParallel(); // Schedule as a parallel job\n           \n",[509],{"type":14,"tag":62,"props":510,"children":511},{"__ignoreMap":7},[512],{"type":19,"value":507},{"type":14,"tag":15,"props":514,"children":515},{},[516],{"type":14,"tag":139,"props":517,"children":518},{},[519],{"type":19,"value":520},"实体查询",{"type":14,"tag":22,"props":522,"children":523},{},[524,535,546,557,577,588],{"type":14,"tag":26,"props":525,"children":526},{},[527,533],{"type":14,"tag":62,"props":528,"children":530},{"className":529},[],[531],{"type":19,"value":532},"WithAll\u003CT>",{"type":19,"value":534}," — 一个实体必须具有所有这些组件类型 (除了在lambda参数列表中找到所有组件类型之外)",{"type":14,"tag":26,"props":536,"children":537},{},[538,544],{"type":14,"tag":62,"props":539,"children":541},{"className":540},[],[542],{"type":19,"value":543},"WithAny\u003CT,U>",{"type":19,"value":545}," — 一个实体必须有一个或多个这样的组件类型.注意，允许使用WithAny指定单个组件类型;但是，由于实体必须有一个或多个这样的“可选”组件类型供查询选择，因此使用带有单个类型的WithAny等同于将该类型放在WithAll语句中。",{"type":14,"tag":26,"props":547,"children":548},{},[549,555],{"type":14,"tag":62,"props":550,"children":552},{"className":551},[],[553],{"type":19,"value":554},"WithNone\u003CT>",{"type":19,"value":556}," — 实体不能具有任何这些组件类型",{"type":14,"tag":26,"props":558,"children":559},{},[560,566,568,575],{"type":14,"tag":62,"props":561,"children":563},{"className":562},[],[564],{"type":19,"value":565},"WithChangeFilter\u003CT>",{"type":19,"value":567}," — 只选择子上次 ",{"type":14,"tag":492,"props":569,"children":572},{"href":570,"rel":571},"https://docs.unity3d.com/Packages/com.unity.entities@0.6/api/Unity.Entities.JobComponentSystem.html",[496],[573],{"type":19,"value":574},"JobComponentSystem",{"type":19,"value":576}," 更新以来，特性组件发生变化的实体",{"type":14,"tag":26,"props":578,"children":579},{},[580,586],{"type":14,"tag":62,"props":581,"children":583},{"className":582},[],[584],{"type":19,"value":585},"WithSharedComponentFilter",{"type":19,"value":587}," — 只选择拥有特定值的share component的块",{"type":14,"tag":26,"props":589,"children":590},{},[591,597,599,606],{"type":14,"tag":62,"props":592,"children":594},{"className":593},[],[595],{"type":19,"value":596},"WithStoreEntityQueryInField",{"type":19,"value":598}," — 把Entities.ForEach生成的 ",{"type":14,"tag":492,"props":600,"children":603},{"href":601,"rel":602},"https://docs.unity3d.com/Packages/com.unity.entities@0.6/api/Unity.Entities.EntityQuery.html",[496],[604],{"type":19,"value":605},"EntityQuery",{"type":19,"value":607}," 对象存储在一个 EntityQuery 字段里. 您可以使用这个EntityQuery对象用于获取符合条件的实体的数量.注意，这个函数在创建JobComponentSystem时将EntityQuery实例分配给您的字段. 这意味着您可以在第一次执行lambda函数之前使用查询。",{"type":14,"tag":15,"props":609,"children":610},{},[611],{"type":19,"value":612},"不要使用WithAny\u003CT、U>或WithNone向查询添加参数列表中的组件。所有添加到lambda函数参数列表中的组件都会自动添加到实体查询的WithAll列表中;向WithAll列表和WithAny或WithNone列表添加组件会创建一个不合逻辑的查询。",{"type":14,"tag":213,"props":614,"children":616},{"code":615}," Entities.WithAll\u003CLocalToWorld>()\n    .WithAny\u003CRotation, Translation, Scale>()\n    .WithNone\u003CLocalToParent>()\n    .ForEach((ref Destination outputData, in Source inputData) =>\n    {\n        /* do some work */\n    })\n    .Schedule(inputDeps);\n    \nEntities\n    .WithChangeFilter\u003CSource>()\n    .ForEach((ref Destination outputData,\n    in Source inputData) =>\n    {\n    /* Do work */\n    })\n    .Schedule(inputDeps);\n",[617],{"type":14,"tag":62,"props":618,"children":619},{"__ignoreMap":7},[620],{"type":19,"value":615},{"type":14,"tag":487,"props":622,"children":624},{"id":623},"ijobchunk",[625],{"type":14,"tag":492,"props":626,"children":629},{"href":627,"rel":628},"https://docs.unity3d.com/Packages/com.unity.entities@0.14/manual/chunk_iteration_job.html",[496],[630],{"type":19,"value":631},"IJobChunk",{"type":14,"tag":15,"props":633,"children":634},{},[635,637,643],{"type":19,"value":636},"遍历所有符合条件的内存块(called a ",{"type":14,"tag":638,"props":639,"children":640},"em",{},[641],{"type":19,"value":642},"Chunk",{"type":19,"value":644},")，其中包含的是符合条件的实体 . Job Execute() 方法可以用for循环遍历所有的块中的元素，你可以使用 IJobChunk 来执行比 IJobForEach更复杂的操作,同时保持最高效率.",{"type":14,"tag":213,"props":646,"children":648},{"code":647},"[BurstCompile]\nstruct UpdateJob : IJobChunk\n{\n    public ComponentTypeHandle\u003CInputA> InputATypeHandle;\n    public ComponentTypeHandle\u003CInputB> InputBTypeHandle;\n    [ReadOnly] public ComponentTypeHandle\u003COutput> OutputTypeHandle;\n    public uint LastSystemVersion;\n\n    public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n    {\n        var inputAChanged = chunk.DidChange(InputATypeHandle, LastSystemVersion);\n        var inputBChanged = chunk.DidChange(InputBTypeHandle, LastSystemVersion);\n\n        // If neither component changed, skip the current chunk\n        if (!(inputAChanged || inputBChanged))\n            return;\n\n        var inputAs = chunk.GetNativeArray(InputATypeHandle);\n        var inputBs = chunk.GetNativeArray(InputBTypeHandle);\n        var outputs = chunk.GetNativeArray(OutputTypeHandle);\n\n        for (var i = 0; i \u003C outputs.Length; i++)\n        {\n            outputs[i] = new Output { Value = inputAs[i].Value + inputBs[i].Value };\n        }\n    }\n}\n",[649],{"type":14,"tag":62,"props":650,"children":651},{"__ignoreMap":7},[652],{"type":19,"value":647},{"type":14,"tag":487,"props":654,"children":656},{"id":655},"manual-iteration",[657],{"type":14,"tag":492,"props":658,"children":661},{"href":659,"rel":660},"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/manual_iteration.html",[496],[662],{"type":19,"value":663},"Manual iteration",{"type":14,"tag":15,"props":665,"children":666},{},[667,669,675,677,683],{"type":19,"value":668},"如果以前的方法不足, 您可以手动遍历实体或块.例如，您可以获得一个包含实体的",{"type":14,"tag":62,"props":670,"children":672},{"className":671},[],[673],{"type":19,"value":674},"NativeArray",{"type":19,"value":676},"，或者您想要处理的实体的块，使用Job(比如",{"type":14,"tag":62,"props":678,"children":680},{"className":679},[],[681],{"type":19,"value":682},"IJobParallelFor",{"type":19,"value":684},")对它们进行遍历。",{"type":14,"tag":15,"props":686,"children":687},{},[688,694,696,701],{"type":14,"tag":492,"props":689,"children":692},{"href":690,"rel":691},"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/ecs_entity_query.html",[496],[693],{"type":19,"value":605},{"type":19,"value":695}," 类提供了一个构造一个你数据的视图方法，这个视图仅仅包含你算法或者程序中需要的特定的数据. 上面列表中的许多遍历方法都使用EntityQuery，无论是显式的还是内部的。就是可以通过 ",{"type":14,"tag":492,"props":697,"children":699},{"href":690,"rel":698},[496],[700],{"type":19,"value":605},{"type":19,"value":702}," 来只遍历符合条件的实体或组件",{"type":14,"tag":100,"props":704,"children":706},{"id":705},"系统-system",[707],{"type":19,"value":708},"系统 System",{"type":14,"tag":267,"props":710,"children":712},{"id":711},"disableautocreation",[713],{"type":19,"value":714},"DisableAutoCreation",{"type":14,"tag":22,"props":716,"children":717},{},[718,759],{"type":14,"tag":26,"props":719,"children":720},{},[721,723,729,731,737,738,744,746,752,753],{"type":19,"value":722},"如果只是单纯的createsystem,不会执行",{"type":14,"tag":62,"props":724,"children":726},{"className":725},[],[727],{"type":19,"value":728},"OnStartRunning",{"type":19,"value":730},",",{"type":14,"tag":62,"props":732,"children":734},{"className":733},[],[735],{"type":19,"value":736},"OnStopRunning",{"type":19,"value":730},{"type":14,"tag":62,"props":739,"children":741},{"className":740},[],[742],{"type":19,"value":743},"OnUpdate",{"type":19,"value":745},"..但是会执行",{"type":14,"tag":62,"props":747,"children":749},{"className":748},[],[750],{"type":19,"value":751},"OnCreate",{"type":19,"value":730},{"type":14,"tag":62,"props":754,"children":756},{"className":755},[],[757],{"type":19,"value":758},"OnDestroy",{"type":14,"tag":26,"props":760,"children":761},{},[762,768,770,775,776,781,782],{"type":14,"tag":62,"props":763,"children":765},{"className":764},[],[766],{"type":19,"value":767},"AddSystemToUpdateList",{"type":19,"value":769}," 且 Entities.ForEach中的query有结果才会执行",{"type":14,"tag":62,"props":771,"children":773},{"className":772},[],[774],{"type":19,"value":728},{"type":19,"value":730},{"type":14,"tag":62,"props":777,"children":779},{"className":778},[],[780],{"type":19,"value":736},{"type":19,"value":730},{"type":14,"tag":62,"props":783,"children":785},{"className":784},[],[786],{"type":19,"value":743},{"type":14,"tag":15,"props":788,"children":789},{},[790,792,797,799,804],{"type":19,"value":791},"所以可以使用",{"type":14,"tag":62,"props":793,"children":795},{"className":794},[],[796],{"type":19,"value":714},{"type":19,"value":798},",但不",{"type":14,"tag":62,"props":800,"children":802},{"className":801},[],[803],{"type":19,"value":767},{"type":19,"value":805},"添加到循环列表中,把一个system当作工具类使用",{"type":14,"tag":267,"props":807,"children":808},{"id":520},[809],{"type":19,"value":520},{"type":14,"tag":15,"props":811,"children":812},{},[813],{"type":19,"value":814},"一个System根据什么来决定处理哪些实体呢？这时候会用到一个叫实体查询(Entity Query)的东西。实体查询首先需要一些组件类型，然后根据你传入的组件类型的组合，在包含这些组件的原型中查询符合要求的实体。查询时可以指定下面三种类型：",{"type":14,"tag":22,"props":816,"children":817},{},[818,828,838],{"type":14,"tag":26,"props":819,"children":820},{},[821,826],{"type":14,"tag":139,"props":822,"children":823},{},[824],{"type":19,"value":825},"All",{"type":19,"value":827}," 必须包含All中所有的组件类型",{"type":14,"tag":26,"props":829,"children":830},{},[831,836],{"type":14,"tag":139,"props":832,"children":833},{},[834],{"type":19,"value":835},"Any",{"type":19,"value":837}," 必须包含Any中至少一个组件类型",{"type":14,"tag":26,"props":839,"children":840},{},[841,846],{"type":14,"tag":139,"props":842,"children":843},{},[844],{"type":19,"value":845},"None",{"type":19,"value":847}," 不能包含None中任意一个组件类型",{"type":14,"tag":15,"props":849,"children":850},{},[851,853,858],{"type":19,"value":852},"一次实体查询的结果会返回所有符合查询要求的内存块，你可以使用",{"type":14,"tag":62,"props":854,"children":856},{"className":855},[],[857],{"type":19,"value":631},{"type":19,"value":859},"来迭代遍历所有的组件",{"type":14,"tag":267,"props":861,"children":863},{"id":862},"jobs-作业",[864],{"type":19,"value":865},"Jobs 作业",{"type":14,"tag":15,"props":867,"children":868},{},[869,871,877,879,885,887,892,894,900,901,907,909,914,916,921],{"type":19,"value":870},"之前说过，ECS配合Job使用才能发挥多线程的威力。ECS提供了",{"type":14,"tag":62,"props":872,"children":874},{"className":873},[],[875],{"type":19,"value":876},"SystemBase",{"type":19,"value":878},"类，其中包含",{"type":14,"tag":62,"props":880,"children":882},{"className":881},[],[883],{"type":19,"value":884},"Entities.ForEach",{"type":19,"value":886},"方法，还包含了",{"type":14,"tag":62,"props":888,"children":890},{"className":889},[],[891],{"type":19,"value":631},{"type":19,"value":893},"的",{"type":14,"tag":62,"props":895,"children":897},{"className":896},[],[898],{"type":19,"value":899},"Schedule()",{"type":19,"value":69},{"type":14,"tag":62,"props":902,"children":904},{"className":903},[],[905],{"type":19,"value":906},"ScheduleParallel()",{"type":19,"value":908},"方法，可以在子线程中处理数据。",{"type":14,"tag":62,"props":910,"children":912},{"className":911},[],[913],{"type":19,"value":884},{"type":19,"value":915},"是最简单的方法，只需要几行代码就能实现。",{"type":14,"tag":62,"props":917,"children":919},{"className":918},[],[920],{"type":19,"value":631},{"type":19,"value":922},"可以用来处理比较复杂的情况。",{"type":14,"tag":15,"props":924,"children":925},{},[926],{"type":19,"value":927},"ECS会在主线程调度Job，根据System的顺序。当job调度后，ECS会追踪哪些job在读写哪些组件。需要读权限的job需要等待前面写权限的job执行完，反之亦然。Job调度器会使用job依赖来决定哪些job可以并行，哪些必须串行。",{"type":14,"tag":267,"props":929,"children":931},{"id":930},"system的组织",[932],{"type":19,"value":933},"System的组织",{"type":14,"tag":15,"props":935,"children":936},{},[937,939,945,946,952],{"type":19,"value":938},"ECS通过",{"type":14,"tag":62,"props":940,"children":942},{"className":941},[],[943],{"type":19,"value":944},"World",{"type":19,"value":69},{"type":14,"tag":62,"props":947,"children":949},{"className":948},[],[950],{"type":19,"value":951},"group",{"type":19,"value":953},"来组织system。默认情况下，ECS会创建一个默认的World，包含一些预定义的group组。它会找到工程中所有的System，实例化他们，并添加到预定义的group中。",{"type":14,"tag":15,"props":955,"children":956},{},[957],{"type":19,"value":958},"你可以指定同一个group中system的Update的执行顺序。Group也是一种system，所以你可以将一个group添加到另外一个group中。如果你没有指定顺序，system的执行顺序会不太确定，并不会按照它们创建的顺序。不过，同一个group中的所有system都会比下一个group中的system先执行。",{"type":14,"tag":15,"props":960,"children":961},{},[962],{"type":19,"value":963},"System的Update是在主线程中执行的，不过可以使用Job将工作分配到子线程中。",{"type":14,"tag":100,"props":965,"children":967},{"id":966},"组件-component",[968],{"type":19,"value":969},"组件 Component",{"type":14,"tag":42,"props":971,"children":973},{"id":972},"相关链接",[974],{"type":19,"value":972},{"type":14,"tag":22,"props":976,"children":977},{},[978,988,998,1008,1018,1028],{"type":14,"tag":26,"props":979,"children":980},{},[981],{"type":14,"tag":492,"props":982,"children":985},{"href":983,"rel":984},"https://docs.unity3d.com/Packages/com.unity.entities@0.14/manual/index.html",[496],[986],{"type":19,"value":987},"Entity Component System 官方文档",{"type":14,"tag":26,"props":989,"children":990},{},[991],{"type":14,"tag":492,"props":992,"children":995},{"href":993,"rel":994},"https://www.bilibili.com/video/BV1sD4y1Q7an",[496],[996],{"type":19,"value":997},"DOTS从原理到应用",{"type":14,"tag":26,"props":999,"children":1000},{},[1001],{"type":14,"tag":492,"props":1002,"children":1005},{"href":1003,"rel":1004},"https://www.bilibili.com/video/BV18J411t7G8",[496],[1006],{"type":19,"value":1007},"Unity DOTS技术详解",{"type":14,"tag":26,"props":1009,"children":1010},{},[1011],{"type":14,"tag":492,"props":1012,"children":1015},{"href":1013,"rel":1014},"https://connect.unity.com/u/enthervarope/column",[496],[1016],{"type":19,"value":1017},"Unity ECS简单示例",{"type":14,"tag":26,"props":1019,"children":1020},{},[1021],{"type":14,"tag":492,"props":1022,"children":1025},{"href":1023,"rel":1024},"https://blog.csdn.net/andrewfan/category_8967683.html",[496],[1026],{"type":19,"value":1027},"Unity中的ECS编程",{"type":14,"tag":26,"props":1029,"children":1030},{},[1031],{"type":14,"tag":492,"props":1032,"children":1035},{"href":1033,"rel":1034},"https://blog.csdn.net/lrh3025/category_9668656.html",[496],[1036],{"type":19,"value":1037},"Unity ECS_翻译",{"title":7,"searchDepth":1039,"depth":1039,"links":1040},2,[1041,1042,1048,1054],{"id":102,"depth":1039,"text":105},{"id":203,"depth":1039,"text":206,"children":1043},[1044,1046,1047],{"id":269,"depth":1045,"text":272},3,{"id":420,"depth":1045,"text":423},{"id":473,"depth":1045,"text":473},{"id":705,"depth":1039,"text":708,"children":1049},[1050,1051,1052,1053],{"id":711,"depth":1045,"text":714},{"id":520,"depth":1045,"text":520},{"id":862,"depth":1045,"text":865},{"id":930,"depth":1045,"text":933},{"id":966,"depth":1039,"text":969},"markdown","content:unity:2020-10-15-unity-ecs.md","content","unity/2020-10-15-unity-ecs.md","md","2020-10-15",[1062,1072,1199,1248,1300,1313,1425],{"title":1063,"_path":1064,"children":1065},"Art","/art",[1066,1069],{"title":1067,"_path":1068},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1070,"_path":1071},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1073,"_path":1074,"children":1075},"Dotnet","/dotnet",[1076,1079,1082,1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118,1121,1124,1127,1130,1133,1136,1139,1142,1145,1148,1151,1154,1157,1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190,1193,1196],{"title":1077,"_path":1078},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1080,"_path":1081},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1083,"_path":1084},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1086,"_path":1087},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1089,"_path":1090},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":1092,"_path":1093},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1095,"_path":1096},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1098,"_path":1099},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1101,"_path":1102},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1104,"_path":1105},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1107,"_path":1108},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1110,"_path":1111},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1113,"_path":1114},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1116,"_path":1117},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1119,"_path":1120},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1122,"_path":1123},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1125,"_path":1126},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1128,"_path":1129},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1131,"_path":1132},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1134,"_path":1135},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1137,"_path":1138},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1140,"_path":1141},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1143,"_path":1144},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1146,"_path":1147},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1149,"_path":1150},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1152,"_path":1153},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1155,"_path":1156},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1158,"_path":1159},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1161,"_path":1162},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1164,"_path":1165},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1167,"_path":1168},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1170,"_path":1171},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1173,"_path":1174},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1176,"_path":1177},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1179,"_path":1180},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1182,"_path":1183},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1185,"_path":1186},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1188,"_path":1189},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1191,"_path":1192},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1194,"_path":1195},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1197,"_path":1198},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1200,"_path":1201,"children":1202},"Game","/game",[1203,1206,1209,1212,1215,1218,1221,1224,1227,1230,1233,1236,1239,1242,1245],{"title":1204,"_path":1205},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1207,"_path":1208},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1210,"_path":1211},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1213,"_path":1214},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1216,"_path":1217},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1219,"_path":1220},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1222,"_path":1223},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1225,"_path":1226},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1228,"_path":1229},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1231,"_path":1232},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1234,"_path":1235},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1237,"_path":1238},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1240,"_path":1241},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1243,"_path":1244},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1246,"_path":1247},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1249,"_path":1250,"children":1251},"Gyj","/gyj",[1252,1255,1258,1261,1264,1267,1270,1273,1276,1279,1282,1285,1288,1291,1294,1297],{"title":1253,"_path":1254},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1256,"_path":1257},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1259,"_path":1260},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1262,"_path":1263},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1265,"_path":1266},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1268,"_path":1269},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1271,"_path":1272},"玩法","/gyj/2022-08-22-wanfa",{"title":1274,"_path":1275},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1277,"_path":1278},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1280,"_path":1281},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1283,"_path":1284},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1286,"_path":1287},"门派内容相关","/gyj/2022-11-17-sect",{"title":1289,"_path":1290},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1292,"_path":1293},"种植","/gyj/2022-12-01-zhongzhi",{"title":1295,"_path":1296},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1298,"_path":1299},"跑商","/gyj/2023-11-01-paoshang",{"title":1301,"_path":1302,"children":1303},"Js","/js",[1304,1307,1310],{"title":1305,"_path":1306},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1308,"_path":1309},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1311,"_path":1312},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1314,"_path":1315,"children":1316},"Tool","/tool",[1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392,1395,1398,1401,1404,1407,1410,1413,1416,1419,1422],{"title":1318,"_path":1319},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1321,"_path":1322},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1324,"_path":1325},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1327,"_path":1328},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1330,"_path":1331},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1333,"_path":1334},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1336,"_path":1337},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1339,"_path":1340},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1342,"_path":1343},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1345,"_path":1346},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1348,"_path":1349},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1351,"_path":1352},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1354,"_path":1355},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1357,"_path":1358},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1360,"_path":1361},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1363,"_path":1364},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1366,"_path":1367},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1369,"_path":1370},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1372,"_path":1373},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1375,"_path":1376},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1378,"_path":1379},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1381,"_path":1382},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1384,"_path":1385},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1387,"_path":1388},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1390,"_path":1391},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1393,"_path":1394},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1396,"_path":1397},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1399,"_path":1400},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1402,"_path":1403},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1405,"_path":1406},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1408,"_path":1409},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1411,"_path":1412},"rider的使用","/tool/2022-08-02-rider-use",{"title":1414,"_path":1415},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1417,"_path":1418},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1420,"_path":1421},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1423,"_path":1424},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1426,"_path":1427,"children":1428},"Unity","/unity",[1429,1432,1435,1438,1441,1444,1447,1450,1453,1456,1459,1462,1465,1468,1471,1474,1477,1480,1483,1486,1489,1492,1495,1498,1501,1504,1507,1510,1513,1516,1519,1522,1525,1528,1531,1534,1537,1540,1543,1544,1547,1550,1553,1556,1559,1562,1565,1568,1571,1574,1577,1580,1583,1586,1589,1592,1595,1598,1601,1604,1607,1610,1613,1616,1619,1622,1625,1628,1631,1634,1637,1640],{"title":1430,"_path":1431},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1433,"_path":1434},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1436,"_path":1437},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1439,"_path":1440},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1442,"_path":1443},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1445,"_path":1446},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1448,"_path":1449},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1451,"_path":1452},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1454,"_path":1455},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1457,"_path":1458},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1460,"_path":1461},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1463,"_path":1464},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1466,"_path":1467},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1469,"_path":1470},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1472,"_path":1473},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1475,"_path":1476},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1478,"_path":1479},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1481,"_path":1482},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1484,"_path":1485},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1487,"_path":1488},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1490,"_path":1491},"技能系统","/unity/2020-02-15-skill-system",{"title":1493,"_path":1494},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1496,"_path":1497},"角色状态设计","/unity/2020-02-17-character-states",{"title":1499,"_path":1500},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1502,"_path":1503},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1505,"_path":1506},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1508,"_path":1509},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1511,"_path":1512},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1514,"_path":1515},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1517,"_path":1518},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1520,"_path":1521},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1523,"_path":1524},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1526,"_path":1527},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1529,"_path":1530},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1532,"_path":1533},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1535,"_path":1536},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1538,"_path":1539},"unity的addressables","/unity/2020-09-12-addressables",{"title":1541,"_path":1542},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":8,"_path":4},{"title":1545,"_path":1546},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1548,"_path":1549},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1551,"_path":1552},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1554,"_path":1555},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1557,"_path":1558},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1560,"_path":1561},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1563,"_path":1564},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1566,"_path":1567},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1569,"_path":1570},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1572,"_path":1573},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1575,"_path":1576},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1578,"_path":1579},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1581,"_path":1582},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1584,"_path":1585},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1587,"_path":1588},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1590,"_path":1591},"ability","/unity/2020-11-16-dotssample",{"title":1593,"_path":1594},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1596,"_path":1597},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1599,"_path":1600},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1602,"_path":1603},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1605,"_path":1606},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1608,"_path":1609},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1611,"_path":1612},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1614,"_path":1615},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1617,"_path":1618},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1620,"_path":1621},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1623,"_path":1624},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1626,"_path":1627},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1629,"_path":1630},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1632,"_path":1633},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1635,"_path":1636},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1638,"_path":1639},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1641,"_path":1642},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779039600]