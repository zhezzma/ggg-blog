{"generatedAt":1710779032243,"generateTime":3131,"contents":[{"_path":"/art/2020-09-03-ps-ronghe-pics","_dir":"art","_draft":false,"_partial":false,"_locale":"","title":"如何用蒙版将两个图过渡融合","description":"1、首先打开PS软件，然后在PS中打开需要处理的图片。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、首先打开PS软件，然后在PS中打开需要处理的图片。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-09-03-ps-ronghe-pics/55e736d12f2eb93848c1edf4db628535e5dd6f0c"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、接下来将另一张图片拖入PS中，使其位于第一张图片上方，根据自己的的需要调整位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-09-03-ps-ronghe-pics/8ad4b31c8701a18be32d8549902f07082938fef6"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、接下来在页面右下方选择“添加矢量蒙版”小图标，点击小图标给第二张图片加上矢量蒙版。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-09-03-ps-ronghe-pics/b58f8c5494eef01fde1c8ec3eefe9925bc317da8"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、然后在左边工具栏中选择“渐变工具”，在上方工具栏中按下图红色箭头所指从设置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-09-03-ps-ronghe-pics/f2deb48f8c5494ee13da991f23f5e0fe99257e38"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5、最后在图片上按住鼠标从左向右拉到另一个位置松开，就可以将两张图边缘融合在一起了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-09-03-ps-ronghe-pics/342ac65c103853434bee16279d13b07eca808897"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"蒙版，其实就是ps运用黑、白和不同程度的灰色来控制画面显示的程度，就好像拿一块板子蒙着你的眼睛一样，黑色是完全不透光的木板，白色是一块玻璃板，灰色是一块半透明的玻璃板，黑色你完全看不到后面的情况，白色你会完全看到后面，而半透明玻璃你能看到后面，但是是不清晰的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"蒙版根据黑白灰,将图片处理成透明,半透明,和不透明."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以除了渐变工具.还可以用画笔工具.只要涂抹为黑白就可以."}]},{"type":"element","tag":"h3","props":{"id":"应用图层蒙版是不能执行的"},"children":[{"type":"text","value":"应用图层蒙版是不能执行的?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为你的图层是智能图层，你先要栅格化之后，才能执行你需要的操作~"}]},{"type":"element","tag":"h1","props":{"id":"去色"},"children":[{"type":"text","value":"去色"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用色彩范围或者其他东西.先去除大部分的黑色"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后周边肯定有一部分的灰色去除不掉的..然后再将这些颜色使用替换颜色..改成白色"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最后再用工具将图片平滑一下"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"应用图层蒙版是不能执行的","depth":3,"text":"应用图层蒙版是不能执行的?"}]}},"_type":"markdown","_id":"content:art:2020-09-03-ps-ronghe-pics.md","_source":"content","_file":"art/2020-09-03-ps-ronghe-pics.md","_extension":"md","date":"2020-09-03"},{"_path":"/art/2022-02-02-xiangsuhuarumen","_dir":"art","_draft":false,"_partial":false,"_locale":"","title":"像素画入门","description":"sdfa","layout":"page","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sdfa"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:art:2022-02-02-像素画入门.md","_source":"content","_file":"art/2022-02-02-像素画入门.md","_extension":"md","date":"2022-02-02"},{"_path":"/dotnet/2019-06-05-linux-dotnet-daemon","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Linux部署dotnetcore记录","description":"DaemonLinux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等...配置文件sudo vi /etc/systemd/system/KestrelDemoSer.service\n修改配置[Unit]\nDescription=KestrelDemo runni","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"daemon"},"children":[{"type":"text","value":"Daemon"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等..."}]},{"type":"element","tag":"h3","props":{"id":"配置文件"},"children":[{"type":"text","value":"配置文件"}]},{"type":"element","tag":"pre","props":{"code":"sudo vi /etc/systemd/system/KestrelDemoSer.service\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo vi /etc/systemd/system/KestrelDemoSer.service\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"修改配置"}]},{"type":"element","tag":"pre","props":{"code":"[Unit]\nDescription=KestrelDemo running on CentOS\n[Service]\nWorkingDirectory=/cusD/wwwroot/KesPublish\nType=simple\nUser=root\nGroup=root\nExecStart=/usr/bin/dotnet /cusD/wwwroot/KesPublish/KestrelDemo.dll\nRestart=always\n# Restart service after 10 seconds if the dotnet service crashes:\nRestartSec=10\nSyslogIdentifier=dotnet-example\nEnvironment=ASPNETCORE_ENVIRONMENT=Production\nEnvironment=DOTNET_PRINT_TELEMETRY_MESSAGE=false\n[Install]\nWantedBy=multi-user.target\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Unit]\nDescription=KestrelDemo running on CentOS\n[Service]\nWorkingDirectory=/cusD/wwwroot/KesPublish\nType=simple\nUser=root\nGroup=root\nExecStart=/usr/bin/dotnet /cusD/wwwroot/KesPublish/KestrelDemo.dll\nRestart=always\n# Restart service after 10 seconds if the dotnet service crashes:\nRestartSec=10\nSyslogIdentifier=dotnet-example\nEnvironment=ASPNETCORE_ENVIRONMENT=Production\nEnvironment=DOTNET_PRINT_TELEMETRY_MESSAGE=false\n[Install]\nWantedBy=multi-user.target\n"}]}]},{"type":"element","tag":"h3","props":{"id":"命令"},"children":[{"type":"text","value":"命令"}]},{"type":"element","tag":"pre","props":{"code":"systemctl enable KestrelDemoSer.service\nsystemctl start KestrelDemoSer.service\nsystemctl status KestrelDemoSer.service\nsudo journalctl -fu KestrelDemoSer.service  //查看日志\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"systemctl enable KestrelDemoSer.service\nsystemctl start KestrelDemoSer.service\nsystemctl status KestrelDemoSer.service\nsudo journalctl -fu KestrelDemoSer.service  //查看日志\n"}]}]},{"type":"element","tag":"h2","props":{"id":"jenkins"},"children":[{"type":"text","value":"jenkins"}]},{"type":"element","tag":"pre","props":{"code":"sudo systemctl stop edu\nsudo dotnet publish -c Release ${WORKSPACE}/src/Edu.Web/Edu.Web.csproj -o /usr/local/src/edu\nsudo systemctl start edu\n","language":"shell","meta":"","className":["language-shell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo systemctl stop edu\nsudo dotnet publish -c Release ${WORKSPACE}/src/Edu.Web/Edu.Web.csproj -o /usr/local/src/edu\nsudo systemctl start edu\n"}]}]},{"type":"element","tag":"h3","props":{"id":"efcore-update"},"children":[{"type":"text","value":"efcore update"}]},{"type":"element","tag":"pre","props":{"code":"dotnet ef database update --context Edu.EntityFrameworkCore.EduMigrationsDbContext --startup-project ./src/Edu.Web/Edu.Web.csproj --project ./src/Edu.EntityFrameworkCore.DbMigrations/Edu.EntityFrameworkCore.DbMigrations.csproj   -v\n","language":"shell","meta":"","className":["language-shell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"dotnet ef database update --context Edu.EntityFrameworkCore.EduMigrationsDbContext --startup-project ./src/Edu.Web/Edu.Web.csproj --project ./src/Edu.EntityFrameworkCore.DbMigrations/Edu.EntityFrameworkCore.DbMigrations.csproj   -v\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不能使用sudo的解决办法"}]},{"type":"element","tag":"pre","props":{"code":"sudo visudo\n\njenkins ALL=(ALL) NOPASSWD: ALL\n\nsystemctl restart jenkins\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo visudo\n\njenkins ALL=(ALL) NOPASSWD: ALL\n\nsystemctl restart jenkins\n"}]}]},{"type":"element","tag":"h2","props":{"id":"mysql"},"children":[{"type":"text","value":"mysql"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从windows迁移到linux时..mysql数据库的表明可能会有大小写敏感的问题\n修改mysql配置my.ini"}]},{"type":"element","tag":"pre","props":{"code":"lower_case_table_names = 0 //mysql会根据表名直接操作，大小写敏感。 \nlower_case_table_names = 1 //mysql会先把表名转为小写，再执行操作。 \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"lower_case_table_names = 0 //mysql会根据表名直接操作，大小写敏感。 \nlower_case_table_names = 1 //mysql会先把表名转为小写，再执行操作。 \n"}]}]},{"type":"element","tag":"h1","props":{"id":"windows下绝对路径启动问题"},"children":[{"type":"text","value":"windows下绝对路径启动问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注册成services后.他的启动目录是C:\\Windows\\System32..所以需要手动设置下contentRoot"}]},{"type":"element","tag":"pre","props":{"code":"F:\\DotHass.Blog\\aspnet-core\\src\\DotHass.Blog.Web\\bin\\Release\\publish\\DotHass.Blog.Web.exe --contentRoot F:\\DotHass.Blog\\aspnet-core\\src\\DotHass.Blog.Web\\bin\\Release\\publish\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"F:\\DotHass.Blog\\aspnet-core\\src\\DotHass.Blog.Web\\bin\\Release\\publish\\DotHass.Blog.Web.exe --contentRoot F:\\DotHass.Blog\\aspnet-core\\src\\DotHass.Blog.Web\\bin\\Release\\publish\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果启动失败..先查看错误日志..最好是用文件存储"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"daemon","depth":2,"text":"Daemon","children":[{"id":"配置文件","depth":3,"text":"配置文件"},{"id":"命令","depth":3,"text":"命令"}]},{"id":"jenkins","depth":2,"text":"jenkins","children":[{"id":"efcore-update","depth":3,"text":"efcore update"}]},{"id":"mysql","depth":2,"text":"mysql"}]}},"_type":"markdown","_id":"content:dotnet:2019-06-05-linux-dotnet-daemon.md","_source":"content","_file":"dotnet/2019-06-05-linux-dotnet-daemon.md","_extension":"md","date":"2019-06-05"},{"_path":"/dotnet/2019-10-29-time-wheel","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"时间轮的引入","description":"问题引入：在mmorpg游戏中，群战的时候，玩家释放技能，这时候会出现技能冷却时间，每一个技能都是一个定时器，或者在slg游戏中，玩家修建房屋，创建基地，都会产生一个延时操作，等到了指定时间后，完成房屋修建等任务！！！！！","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"问题引入：在mmorpg游戏中，群战的时候，玩家释放技能，这时候会出现技能冷却时间，每一个技能都是一个定时器，或者在slg游戏中，玩家修建房屋，创建基地，都会产生一个延时操作，等到了指定时间后，完成房屋修建等任务！！！！！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"轮询的尴尬：使用一个定时器，定时遍历多个链表，判定链表里面的任务是否到期！ 效率低下,每一次遍历都需要筛选定时器，时间复杂度O（n）."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多定时器的尴尬：同时创建多个定时器，每个定时器绑定到期任务，多定时器，会加大cpu的负荷，且任务的到期时间不同，必定会产生更多的定时器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决方案：时间轮的引入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-10-29-time-wheel/20180817103356853.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果所示：将同一时间的任务放在一起，组成一个链表，图中每个格子分别指向这样一个链表，定时器每到期一次，图中的指针移动一格，如此循环往复，当指针指向某个格子，代表这个链表里面的定时器可能到期（注意，这里是可能，因为时间轮是一个循环的圈，比如运行一圈需要时间50s,那么一个100s的定时器，虽然在槽位1的链表中，但是需要时间轮运行两圈，这个定时器才到期）"}]},{"type":"element","tag":"h2","props":{"id":"a-full-example"},"children":[{"type":"text","value":"A full example"}]},{"type":"element","tag":"pre","props":{"code":"/// <summary>\n/// Task fired repeatedly\n/// </summary>\nclass IntervalTimerTask : TimerTask\n{\n    public void Run(Timeout timeout)\n    {\n        Console.WriteLine($\"IntervalTimerTask is fired at {DateTime.UtcNow.Ticks / 10000000L}\");\n        timeout.Timer.NewTimeout(this, TimeSpan.FromSeconds(2));\n    }\n}\n\n/// <summary>\n/// Task only be fired for one time\n/// </summary>\nclass OneTimeTask : TimerTask\n{\n    readonly string _userData;\n    public OneTimeTask(string data)\n    {\n        _userData = data;\n    }\n\n    public void Run(Timeout timeout)\n    {\n        Console.WriteLine($\"{_userData} is fired at {DateTime.UtcNow.Ticks / 10000000L}\");\n    }\n}\n\n\nstatic void Main(string[] args)\n{\n    HashedWheelTimer timer = new HashedWheelTimer( tickDuration: TimeSpan.FromSeconds(1)\n        , ticksPerWheel: 100000\n        , maxPendingTimeouts: 0);\n\n    timer.NewTimeout(new OneTimeTask(\"A\"), TimeSpan.FromSeconds(5));\n    timer.NewTimeout(new OneTimeTask(\"B\"), TimeSpan.FromSeconds(4));\n    var timeout = timer.NewTimeout(new OneTimeTask(\"C\"), TimeSpan.FromSeconds(3));\n    timer.NewTimeout(new OneTimeTask(\"D\"), TimeSpan.FromSeconds(2));\n    timer.NewTimeout(new OneTimeTask(\"E\"), TimeSpan.FromSeconds(1));\n\n    timeout.Cancel();\n\n    timer.NewTimeout(new IntervalTimerTask(), TimeSpan.FromSeconds(5));\n    Console.WriteLine($\"{DateTime.UtcNow.Ticks / 10000000L} : Started\");\n    Console.ReadKey();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/// <summary>\n/// Task fired repeatedly\n/// </summary>\nclass IntervalTimerTask : TimerTask\n{\n    public void Run(Timeout timeout)\n    {\n        Console.WriteLine($\"IntervalTimerTask is fired at {DateTime.UtcNow.Ticks / 10000000L}\");\n        timeout.Timer.NewTimeout(this, TimeSpan.FromSeconds(2));\n    }\n}\n\n/// <summary>\n/// Task only be fired for one time\n/// </summary>\nclass OneTimeTask : TimerTask\n{\n    readonly string _userData;\n    public OneTimeTask(string data)\n    {\n        _userData = data;\n    }\n\n    public void Run(Timeout timeout)\n    {\n        Console.WriteLine($\"{_userData} is fired at {DateTime.UtcNow.Ticks / 10000000L}\");\n    }\n}\n\n\nstatic void Main(string[] args)\n{\n    HashedWheelTimer timer = new HashedWheelTimer( tickDuration: TimeSpan.FromSeconds(1)\n        , ticksPerWheel: 100000\n        , maxPendingTimeouts: 0);\n\n    timer.NewTimeout(new OneTimeTask(\"A\"), TimeSpan.FromSeconds(5));\n    timer.NewTimeout(new OneTimeTask(\"B\"), TimeSpan.FromSeconds(4));\n    var timeout = timer.NewTimeout(new OneTimeTask(\"C\"), TimeSpan.FromSeconds(3));\n    timer.NewTimeout(new OneTimeTask(\"D\"), TimeSpan.FromSeconds(2));\n    timer.NewTimeout(new OneTimeTask(\"E\"), TimeSpan.FromSeconds(1));\n\n    timeout.Cancel();\n\n    timer.NewTimeout(new IntervalTimerTask(), TimeSpan.FromSeconds(5));\n    Console.WriteLine($\"{DateTime.UtcNow.Ticks / 10000000L} : Started\");\n    Console.ReadKey();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The output of the sample is something like"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-10-29-time-wheel/console.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c# 的实现"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/wangjia184/HashedWheelTimer","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/wangjia184/HashedWheelTimer"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/fanrice123/HashedWheelTimer.NET","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/fanrice123/HashedWheelTimer.NET"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"a-full-example","depth":2,"text":"A full example"}]}},"_type":"markdown","_id":"content:dotnet:2019-10-29-time-wheel.md","_source":"content","_file":"dotnet/2019-10-29-time-wheel.md","_extension":"md","date":"2019-10-29"},{"_path":"/dotnet/2019-11-01-lock-step","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"帧同步的相关问题","description":"Lock-Step我们把游戏的前进分为一帧帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"lock-step"},"children":[{"type":"text","value":"Lock-Step"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"我们把游戏的前进分为一帧帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都等于延迟最高的那个人。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"由于大家的turn一致，以及输入固定，所以每一步所有客户端的计算结果都一致的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们来看看具体的执行流程:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/113252_S4Vd_1859679.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图中我们可以明显看到，这种囚徒模式的帧同步，在第二帧的时候，因为玩家1有延迟，而导致第二帧的同步时间发生延迟，从而导致所有玩家都在等待，出现卡顿现象"}]},{"type":"element","tag":"h2","props":{"id":"bucket-synchronization乐观锁"},"children":[{"type":"text","value":"Bucket Synchronization(乐观锁)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"囚徒模式的帧同步，有一个致命的缺陷就是，若联网的玩家有一个网速慢了，势必会影响其他玩家的体验，因为服务器要等待所有输入达到之后再同步到所有的c端。另外如果中途有人掉线了，游戏就会无法继续或者掉线玩家无法重连，因为在严格的帧同步的情况下，中途加入游戏是从技术上来讲是非常困难的。因为你重新进来之后，你的初始状态和大家不一致，而且你的状态信息都是丢失状态的，比如，你的等级，随机种子，角色的属性信息等。 比如玩过早期的冰封王座都知道，一旦掉线基本这局就废了，需要重开，至于为何没有卡顿的现象，因为那时都是解决方案都是采用局域网的方式，所以基本是没有延迟问题的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后期为了解决这个问题，如今包括王者荣耀，服务器会保存玩家当场游戏的游戏指令以及状态信息，在玩家断线重连的时候，能够恢复到断线前的状态。不过这个还是无法解决帧同步的问题，因为严格的帧同步，是要等到所有玩家都输入之后，再去通知广播client更新，如果A服务器一直没有输入同步过来，大家是要等着的，那么如何解决这个问题？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用“定时不等待”的乐观方式在每次Interval时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新。如此帧率的时钟在由服务器控制，当客户端有操作的时候及时的发送服务器，然后服务端每秒钟20-50次向所有客户端发送更新消息。如下图:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/113303_rNd5_1859679.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图中，我们看到服务器不会再等到搜集完所有用户输入再进行下一帧，而是按照固定频率来同步玩家的输入信息到每一个c端，如果有玩家网络延迟，服务器的帧步进是不会等待的，比如上图中，在第二帧的时候，玩家A的网速慢，那么他这个时候，会被网速快的玩家给秒了（其他游戏也差不多）。但是网速慢的玩家不会卡到快的玩家，只会感觉自己操作延迟而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Bucket Synchronization 是 Lock-Step 的改良算法. 算法流程可以参考下图:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/bucket.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Bucket Synchronization 算法应用于网状网络, 网络中有一个 master 节点(也是 client)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"master 在启动之初, 会对所有 client 做网络对时, 计算网络包的超时时间."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"master 会设置一个 bucket 时间, 在每个 bucket 时间节点, master 执行收集到的所有 step 指令, 并将更新推送到所有的 client 上. (上图的例子是一个简化流程, 只有俩 client, 没有 master 推送)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"master 对收集到的 step 包做超时校验机制, 如果收到的 step 指令包的时间戳, 延迟超过了预设的阈值, 就当作超时包丢弃."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与 Lock-Step 相比, Bucket Synchronization 改进的是: 设置了 bucket 的概念, 执行每一帧的时间是固定的 bucket 时间节点, 而不必等到收到所有的 client step 指令, 从而网络不再受最差的 client 限制."}]},{"type":"element","tag":"h2","props":{"id":"timewrap-synchronization"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"TimeWrap Synchronization"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它是一个基于某些状态支持回滚(rollback)的同步算法。有点类似HL的做法。\n简言之，就是对每个操作指令的执行后保存一个状态快照(snapshot)，\n各个peer按照自己的预测先行显示，但在发生一致性冲突的情况下，\n回滚到上一个状态，并重新将指令序列在基于回滚后的快照的基础上再\n执行一次，以获得正确的当前状态。"}]},{"type":"element","tag":"h2","props":{"id":"trailing-state-synchronization"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Trailing State Synchronization"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对TimeWrap Synchronization的一种改进。TimeWrap方案中建立snapshot是\n以指令数量(1或少量几个指令)间隔为单位；而TSS方案则以某种延迟值(100ms)\n间隔为单位对游戏做snapshot(比如100ms前做一个，200ms前做一个...)。\n当发生一致性冲突时，寻找最远需要开始计算的snapshot，并将该snapshot到\n现在为止的时间内的指令重新执行，得到正确的最新状态。"}]},{"type":"element","tag":"h2","props":{"id":"state-hash"},"children":[{"type":"text","value":"State Hash"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在实现中客户端需要计算一些关键信息的hash值，提供给服务器以便发现游戏中的同步问题，例如玩家的位置信息，各个客户端计算结果是否一致等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端执行完每个逻辑帧后，会根据游戏的状态计算出一个Hash值，用其标定一个具体的游戏状态。不同客户端通过对比这个值，即可判断客户端之间是否保持同步，平常也可用于不同步Debug。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏外挂的种类有很多，这里所谈的外挂仅指会更改游戏逻辑执行或数值的外挂，应该也是题主最关心的类型。对于帧同步防外挂，因为游戏逻辑执行在本地，假如某个客户端使用了外挂的话，那么必然会导致其计算出的State Hash与其他客户端不一致。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、 客户端自验证（PVP 3人及以上）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PVP3人及以上的战斗中，客户端上报服务器各自计算的State Hash，服务器可以通过对比State Hash判断具体哪一个客户端发生了不同步。当然，不同步也可能是客户端BUG，不同步也不一定就结算不一致。根绝不同的需求，你也可以在发现不同步后马上中断游戏。这个方法的缺点主要在于3人以下或者单机模式的话就没法使用了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、客户端分布式验证"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如客户端的核心逻辑写得足够干净和独立的话，服务器可以将某一场战斗的数据下发给一个空闲客户端，令其新起一个线程慢慢地计算验证，再将结果上报至服务器。能做到这一点的话，任何战斗模式都可以进行验证了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、服务器验证"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与客户端分布式验证相同，客户端逻辑如果足够干净和独立，那么服务器也可以自己验算战斗结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、服务器统计与运营策略"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"非单机模式下，服务器都根据客户端的State Hash对战斗的同步情况进行记录。将经常发生不同步的客户端标记出来，然后进一步处理。运营可以为玩家每日不同步可结算的次数设定一个阈值，超过则当日之后的战斗结算均无效。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1和4是任何帧同步游戏都可以做的，2与3对游戏的框架要求比较高。我们的游戏因为是从单机版改造过来的，所以也只做了1和4。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"游戏逻辑的回滚"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回滚逻辑，就是我们解决问题的方案。可以这样理解，客户端的时间，领先服务器，客户端不需要服务器确认帧返回才执行指令，而是玩家输入，立刻执行（其他玩家的输入，按照其最近一个输入做预测，或者其他更优化的预测方案），然后将指令发送给服务器，服务器收到后给客户端确认，客户端收到确认后，如果服务确认的操作，和之前执行的一样（自己和其他玩家预测的操作），将不做任何改变，如果不一样（预测错误），就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧，然后再追上当前客户端的帧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此处逻辑较为复杂，我尝试举个例子说明下。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当前客户端（A，B）执行到100帧，服务器执行到97帧。在100帧的时候，A执行了移动，B执行了攻击，A和B都通知服务器：我已经执行到100帧，我的操作是移动（A），攻击（B）。服务器在自己的98帧或99帧收到了A，B的消息，存在对应帧的操作数据中，等服务器执行到100帧的时候（或提前），将这个数据广播给AB。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后A和B立刻开始执行100帧，A执行移动，预测B不执行操作。而B执行攻击，预测A执行攻击（可能A的99帧也是攻击），A和B各自预测对方的操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在A和B执行完100帧后，他们会各自保存100帧的状态快照，以及100帧各自的操作（包括预测的操作），以备万一预测错误，做逻辑回滚。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行几帧后，A，B来到了103帧，服务器到了100帧，他开始广播数据给AB，在一定延迟后，AB收到了服务器确认的100帧的数据，这时候，AB可能已经执行到104了。A和B各自去核对服务器的数据和自己预测的数据是否相同。例如A核对后，100帧的操作，和自己预测的一样，A不做任何处理，继续往前。而B核对后，发现在100帧，B对A的预测，和服务器确认的A的操作，是不一样的（B预测的是攻击，而实际A的操作是移动），B就回滚到上一个确认一样的帧，即99帧，然后根据确认的100帧操作去执行100帧，然后快速执行101"},{"type":"element","tag":"del","props":{},"children":[{"type":"text","value":"103的帧逻辑，之后继续执行104帧，其中（101"}]},{"type":"text","value":"104）还是预测的逻辑帧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为客户端对当前操作的立刻执行，这个操作手感，是完全和pve（不联网状态）是一样的，不存在任何delay。所以，能做到绝佳的操作手感。当预测不一样的时候，做逻辑回滚，快速追回当前操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样，对于网络好的玩家，和网络不好的玩家，都不会互相影响，不会像lockstep一样，网络好的玩家，会被网络不好的玩家lock住。也不会被网络延迟lock住，客户端可以一直往前预测。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于网络好的玩家（A），可以动态调整（根据动态的latency），让客户端领先服务器少一些，尽量减少预测量，就会尽量减少回滚，例如网络好的，可能客户端只领先2~3帧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于网络不好的玩家（B），动态调整，领先服务器多一些，根据latency调整，例如领先5帧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，A可能预测错的情况，只有2~3帧，而网络不好的B，可能预测错误的帧有5帧。通过优化的预测技术，和消息通知的优化，可以进一步减少A和B的预测错误率。对于A而言，战斗是顺畅的，手感很好，少数情况的回滚，优化好了，并不会带来卡顿和延迟感。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"重点优化的是B，即网络不好的玩家，他的操作体验。因为客户端不等待服务器确认，就执行操作，所以B的操作手感，和A是一致的，区别只在于，B因为延迟，预测了比较多的帧，可能导致预测错，回滚会多一些。比如按照B的预测，应该在100帧击中A，但是因为预测错误A的操作，回滚重新执行后，B可能在100帧不会击中A。这对于B来说，通过插值和一些平滑方式，B的感受是不会有太大区别的，因为B看自己，操作自己都是及时反馈的，他感觉自己是平滑的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方式，保证了网络不好的B的操作手感，和A一致。回滚导致的一些轻微的抖动，都是B看A的抖动，通过优化（插值，平滑等），进一步减少这些后，B的感受是很好的。我们测试在200~300毫秒随机延迟的情况下，B的操作手感良好。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里，客户端提前服务器的方式，并且在延迟增大的情况下，客户端将加速，和"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/cOGn8-rHWLIxdDz-R3pXDg","rel":["nofollow"]},"children":[{"type":"text","value":"守望先锋的处理方式"}]},{"type":"text","value":"是一样的。当然，他们肯定比我做得好很多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"希望我已经大致讲清楚了这个逻辑，大家参看几篇链接的文章，能体会更深。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里，我要强调的一点是，我们这里的预测执行，是真实逻辑的预测，和很多介绍帧同步文章提到的预测是不同的。有些文章介绍的预测执行，只是view层面的预测，例如前摇动作和位移，但是逻辑是不会提前执行的，还是要等服务器的返回。这两种预测执行（View的预测执行，和真实逻辑的预测执行）是完全不是一个概念的，这里需要仔细地区分。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里有很多的可以优化的点，我就不一一介绍了，以后可能零散地再谈。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"游戏逻辑的快照（snapshot）"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们的逻辑之所以能回滚，都是基于对每一帧状态可以处理快照，存储下每一帧的状态，并可以回滚到任何一帧的状态。在"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//mauve.mizuumi.net/2012/07/05/understanding-fighting-game-networking/","rel":["nofollow"]},"children":[{"type":"text","value":"Understanding Fighting Game Networking"}]},{"type":"text","value":" 文章和"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/cOGn8-rHWLIxdDz-R3pXDg","rel":["nofollow"]},"children":[{"type":"text","value":"守望先锋网络"}]},{"type":"text","value":" 文章中，都一笔带过了快照的说明。他们说的快照，可能略有不同，但是思路，都是能保存下每一帧的状态。如果去处理快照（Understanding那篇文章做的是模拟器游戏，可以方便地以内存快照的方式来做），是一个难点，这也是我"},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/38280972","rel":["nofollow"]},"children":[{"type":"text","value":"前面文章"}]},{"type":"text","value":"提到ECS在这个方式下的应用，云风的解释："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-253646290632dd9ed3ca6453c4b754b5_1440w.jpg"},"children":[]},{"type":"text","value":"云风博客截图，地址"},{"type":"element","tag":"a","props":{"href":"https://blog.codingnow.com/2017/06/overwatch_ecs.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.codingnow.com/2017/06/overwatch_ecs.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS是一个好的处理方式，并且我找到"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//www.kisence.com/2017/11/12/guan-yu-zheng-tong-bu-de-xie-xin-de/","rel":["nofollow"]},"children":[{"type":"text","value":"一篇文章"}]},{"type":"text","value":"，也这样做了（我看过他开源的demo，做得还不够好，应该还是demo阶段，不太像是一个成型的项目）。这篇文章的思路是很清晰的，并且也点到了一些实实在在的痛点，解决思路也基本是正确的，可以参看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这块，我做得比较早了，当时守望先锋的文章还没出，我的战斗也没有基于ECS，所以，在处理快照上，只有自己理顺逻辑来做了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我的思路是，通过一个回滚接口，需要数据回滚的部分，实现接口，各自处理自己的保存快照和回滚。就像我们序列化一个复杂的配置，每个配置各自序列化自己的部分，最终合并成一个序列化好的文件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，定义接口，和快照数据的reader和writer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-5052de9e1c12b7e87d2f452b29fdef61_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-b666f214abd2a804e885237c5bcc119b_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-2f49a68d6fd54381d8e7bdf3ffdfb283_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，就是每个模块，自己去处理自己的takeSnapshot和rollback，例如："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-96bb5917e8a766ef79323613179f404d_1440w.jpg"},"children":[]},{"type":"text","value":"简单的数值回滚"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-1573d2a9eeec5b5d8e7e663a8e06f487_1440w.jpg"},"children":[]},{"type":"text","value":"复制的列表回滚和调用子模块回滚"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"思路理顺以后，就可以很方便地处理了，注意write和read的顺序，注意处理好list，就解决了大部分问题。当然，在实现逻辑的过程中，时刻要注意，一个模块如何回滚（例如获取随机数也需要回滚）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有一个更简单的方式，就是给属性打Attribute，然后写通用的方法。例如，我早"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"期的实现方案"}]},{"type":"text","value":"："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-05fee97a51c743b54d8dca8074fe042f_1440w.jpg"},"children":[]},{"type":"text","value":"给属性打标签"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据标签，通用的读写方法，通过反射来读写，就不需要每个模块自己去实现自己的方法了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-01-lock-step/v2-c27132db564887adc282fe621f2357e3_1440w.jpg"},"children":[]},{"type":"text","value":"部分代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方法，能很好地解决大部分问题，甚至前面提到的"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/suzuke/TrueSync/tree/master/Assets/TrueSync/Engine/Math","rel":["nofollow"]},"children":[{"type":"text","value":"Truesync"}]},{"type":"text","value":"，也是用的这种方式来做。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是这种方法有个难以回避的问题，就是GC，因为基于反射，当我们调用field的GetValue和SetValue的时候，GC难以避免。并且，因为全自动，不方便处理一些特殊逻辑，调试优化也不方便，最后改成了现有的方式，虽然看起来笨重一些，但是可控性更强，我后续做的很多优化，都方便很多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于快照，也有很多可以优化的点，无论是GC内存上的，还是运行效率上的，都需要优化好，否则，可能带来性能问题。这块优化，有空另辟文章再细谈吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们有了快照，就可以支持回滚，甚至跳转。例如我们要看战斗录像，如果没有快照，我们要跳到1000帧，就需要从第一帧，根据保存的操作指令，一直快速执行到1000帧，而有了快照，可以直接跳到1000帧，不需要执行中间的过程，如果需要在不同的帧之间切换，只需要跳转即可，这将带来巨大的帮助。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考文章："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Minimization of Latency in Cheat-Proof Real-Time Gaming by Trusting Time-Stamp Servers"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"End-to-end transmission control mechanisms for multiparty interactive applicatins on the Internet"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dead Reckoning: Latency Hiding for Networked Games"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"An Efficient Synchronization Mechanism for Mirrored Game Architectures"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/community/detail/117819","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/community/detail/117819"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/38468615","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/38468615"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"lock-step","depth":2,"text":"Lock-Step"},{"id":"bucket-synchronization乐观锁","depth":2,"text":"Bucket Synchronization(乐观锁)"},{"id":"timewrap-synchronization","depth":2,"text":"TimeWrap Synchronization"},{"id":"trailing-state-synchronization","depth":2,"text":"Trailing State Synchronization"},{"id":"state-hash","depth":2,"text":"State Hash"}]}},"_type":"markdown","_id":"content:dotnet:2019-11-01-lock-step.md","_source":"content","_file":"dotnet/2019-11-01-lock-step.md","_extension":"md","date":"2019-11-01"},{"_path":"/dotnet/2019-11-01-state-sync-npc","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"状态同步的相关问题","description":"怪物状态同步在一个地图当中，玩家的状态同步之后，则需要同步地图中怪物的位置信息，怪物的位置信息同步方式一般有两种实现方式基于客户端的状态同步一个地图中的怪物状态，实际上是由地图中玩家所决定的，当玩家施加攻击、使用技能，都会改变怪物的状态。在MapleStroy的设计当中，怪物的位置计算是属于离线计算，这也就是说，服务器不参与怪物的状态，这样的好处是节约流量、减缓服务器压力，但是坏处是，会出现怪物静止、吸怪等外挂手段。在移植MapleStroy的过程中，为了同步官方和考虑移动平台流量问题，因此采用此种手段。实现策略：怪物的位置由第一个进入该地图的玩家决定。这也就是说，当第一个玩家进入该地图之后，","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"怪物状态同步"},"children":[{"type":"text","value":"怪物状态同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在一个地图当中，玩家的状态同步之后，则需要同步地图中怪物的位置信息，怪物的位置信息同步方式一般有两种实现方式"}]},{"type":"element","tag":"h3","props":{"id":"基于客户端的状态同步"},"children":[{"type":"text","value":"基于客户端的状态同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个地图中的怪物状态，实际上是由地图中玩家所决定的，当玩家施加攻击、使用技能，都会改变怪物的状态。在MapleStroy的设计当中，怪物的位置计算是属于离线计算，这也就是说，服务器不参与怪物的状态，这样的好处是节约流量、减缓服务器压力，但是坏处是，会出现怪物静止、吸怪等外挂手段。在移植MapleStroy的过程中，为了同步官方和考虑移动平台流量问题，因此采用此种手段。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现策略："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怪物的位置由第一个进入该地图的玩家决定。这也就是说，当第一个玩家进入该地图之后，控制着当前地图中所有怪物的移动状态。当第二个玩家进入该地图之后，第一个玩家会广播当前所有怪物的状态，第二个玩家根据这些数据包进行改变。当然其他玩家发生了攻击，或者激怒怪物的操作后，也会广播这个消息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同时怪物的移动也是采用基于预言的状态同步，大体实现和玩家移动相似。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怪物的同步在传统的端游里，是完全由服务器的怪物AI系统触发，客户端只是纯粹的接受服务器下发的怪物状态数据。对于手机游戏里，由于手机上很难出现像PC里那样的外挂，所以怪物的AI可以考虑放在客户端触发，同时减少怪物的状态同步。详细说明如下："}]},{"type":"element","tag":"h4","props":{"id":"a-怪物的随机移动不同步"},"children":[{"type":"text","value":"a) 怪物的随机移动不同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在地图上，怪物都会有一个固定的位置。怪物没有进入战斗状态时，就会在这个固定位置的周围走来走去，随机的移动。这个随机的移动设定由每个客户端自己控制，这样怪物的随机移动，就不用消息广播进行同步了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于客户端自己控制怪物的随机走动，所以会出现不同客户端里，怪物位置不一样的问题。但由于怪物随机移动的范围较小，所以这个问题不是很明显，在手机上是可以接受的。角色打怪时，是扇形的伤害范围，所以即使怪物坐标在不同的客户端有点不一致，打怪的效果也可以接受。"}]},{"type":"element","tag":"h4","props":{"id":"b-怪物的行为同步"},"children":[{"type":"text","value":"b) 怪物的行为同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当有角色攻击被动怪物，或者进入主动怪物的视野范围内时，怪物的AI就被这个角色所在的客户端锁定了，同时怪物进入攻击状态。攻击的判断完全由锁定怪物AI的客户端进行处理，同时这个客户端会将这个怪物的行为上发到服务器，由服务器广播给周围的其他玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怪物的AI锁定，使用抢占式，即谁最先发消息给服务器申请怪物的AI锁定，谁就获得了怪物的控制权，直到怪物死亡或脱离战斗状态。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怪物可以每进行一次攻击，客户端就发一个消息给服务器。这样做，消息还是有点多，特别是一群怪围着几个角色进行攻击时，消息广播还是有点多。所以可以将状态的概念向上扩大，只同步怪物在攻击哪个玩家，而不同步每一次的攻击，然后由每个客户端根据怪物固定的攻击速度各自去表现。这样一个怪去攻击一个玩家，就只会有一次消息广播了。"}]},{"type":"element","tag":"h4","props":{"id":"c-精英怪和boss怪的ai"},"children":[{"type":"text","value":"c) 精英怪和BOSS怪的AI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"精英怪和BOSS怪由于数量较少，而且比较重要，所以不能由客户端来申请AI控制权，而是服务器根据某种策略来控制。所使用的策略可以考虑角色的伤害值、防御值、角色与BOSS的距离远近等，根据这些因素，服务器计算出BOSS怪当前最适合攻击的对象（比如血量最少的玩家，最脆弱的法师等），然后将AI控制权发给那个客户端，由那个客户端控制攻击行为，同时通过消息让服务器同步给其他玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总结：怪物的同步方式的选择，就是尽量减少消息的广播，同时让游戏效果在可接受的范围内。怪物AI的这个处理方式，实际上是同时省去了游戏服务器的怪物AI模块（端游一般是专门用的一个进程或者另外一台物理服务器来进行怪物AI的计算），从而简化了MMO游戏的开发难度，同时保证了较好的游戏体验。"}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/5dbdf81c4e69","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.jianshu.com/p/5dbdf81c4e69"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"怪物状态同步","depth":2,"text":"怪物状态同步","children":[{"id":"基于客户端的状态同步","depth":3,"text":"基于客户端的状态同步"}]}]}},"_type":"markdown","_id":"content:dotnet:2019-11-01-state-sync-npc.md","_source":"content","_file":"dotnet/2019-11-01-state-sync-npc.md","_extension":"md","date":"2019-11-01"},{"_path":"/dotnet/2019-11-02-state-sync-skill","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"状态同步--技能系统的同步机制分析","description":"https://www.cnblogs.com/sevenyuan/p/6678317.html","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/sevenyuan/p/6678317.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/sevenyuan/p/6678317.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.lt-tree.com/2019/09/21/%E8%81%94%E7%BD%91%E6%88%98%E6%96%97%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.lt-tree.com/2019/09/21/%E8%81%94%E7%BD%91%E6%88%98%E6%96%97%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/best789248/article/details/78434114","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/best789248/article/details/78434114"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/49482294","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/49482294"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/course/detail/10098","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/course/detail/10098"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/course/detail/10099","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/course/detail/10099"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/course/detail/10112","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/course/detail/10112"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/course/detail/10100","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/course/detail/10100"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven:zh-cn","rel":["nofollow"]},"children":[{"type":"text","value":"https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven:zh-cn"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/38326478","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/38326478"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/38605352","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/38605352"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2019-11-02-state-sync-skill.md","_source":"content","_file":"dotnet/2019-11-02-state-sync-skill.md","_extension":"md","date":"2019-11-02"},{"_path":"/dotnet/2019-11-05-quartz","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Creating a Quartz.NET hosted service with ASP.NET Core","description":"In this post I describe how to run Quartz.NET jobs using an ASP.NET Core hosted service. I show how to create a simple IJob, a custom IJobFactory, and a QuartzHostedService that runs jobs while your application is running. I'll also touch on some of the issues to aware of, namely of using scoped services inside singleton classes.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this post I describe how to run Quartz.NET jobs using an "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2","rel":["nofollow"]},"children":[{"type":"text","value":"ASP.NET Core hosted service"}]},{"type":"text","value":". I show how to create a simple "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":", a custom "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobFactory"}]},{"type":"text","value":", and a "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"QuartzHostedService"}]},{"type":"text","value":" that runs jobs while your application is running. I'll also touch on some of the issues to aware of, namely of using scoped services inside singleton classes."}]},{"type":"element","tag":"h2","props":{"id":"introduction-what-is-quartznet"},"children":[{"type":"text","value":"Introduction - what is Quartz.NET?"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#introduction-what-is-quartz-net-","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-11-05-quartz/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As per "},{"type":"element","tag":"a","props":{"href":"https://www.quartz-scheduler.net/","rel":["nofollow"]},"children":[{"type":"text","value":"their website"}]},{"type":"text","value":":"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Quartz.NET is a full-featured, open source job scheduling system that can be used from smallest apps to large scale enterprise systems."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It's an old staple of many ASP.NET developers, used as a way of running background tasks on a timer, in a reliable, clustered, way. Using Quartz.NET with ASP.NET Core is pretty similar - Quartz.NET supports .NET Standard 2.0, so you can easily use it in your applications."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Quartz.NET has two main concepts:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"job"}]},{"type":"text","value":". This is the background tasks that you want to run on some sort of schedule."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"scheduler"}]},{"type":"text","value":". This is responsible for running jobs based on triggers, on a time-based schedule."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ASP.NET Core has good support for running \"background tasks\" via way of "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services","rel":["nofollow"]},"children":[{"type":"text","value":"hosted services"}]},{"type":"text","value":". Hosted services are started when your ASP.NET Core app starts, and run in the background for the lifetime of the application. By creating a Quartz.NET hosted service, you can use a standard ASP.NET Core application for running your tasks in the background."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This sort of non-HTTP scenario is also possible with the \"generic host\", "},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/the-asp-net-core-generic-host-namespace-clashes-and-extension-methods/","rel":["nofollow"]},"children":[{"type":"text","value":"but for various reasons"}]},{"type":"text","value":" I generally don't use those at the moment. This should hopefully improve in ASP.NET Core 3.0 with the extra investment going into these non-HTTP scenarios."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While it's possible to create "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2#timed-background-tasks","rel":["nofollow"]},"children":[{"type":"text","value":"a \"timed\" background service"}]},{"type":"text","value":", (that runs a tasks every 10 minutes, for example), Quartz.NET provides a far more robust solution. You can ensure tasks only run at specific times of the day (e.g. 2:30am), or only on specific days, or any combination by using a "},{"type":"element","tag":"a","props":{"href":"https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html","rel":["nofollow"]},"children":[{"type":"text","value":"Cron trigger"}]},{"type":"text","value":". It also allows you to run multiple instances of your application in a clustered fashion, so that only a single instance can run a given task at any one time."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this post I'll show the basics of creating a Quartz.NET job and scheduling it to run on a timer in a hosted service."}]},{"type":"element","tag":"h2","props":{"id":"installing-quartznet"},"children":[{"type":"text","value":"Installing Quartz.NET"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#installing-quartz-net","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Quartz.NET is a .NET Standard 2.0 NuGet package, so it should be easy to install in your application. For this test I created an ASP.NET Core project and chose the Empty template. You can install the Quartz.NET package using "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"dotnet add package Quartz"}]},{"type":"text","value":". If you view the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":".csproj"}]},{"type":"text","value":" for the project, it should look something like this:"}]},{"type":"element","tag":"pre","props":{"className":["language-xml"],"code":"<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp2.2</TargetFramework>\n    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.AspNetCore.App\" />\n    <PackageReference Include=\"Quartz\" Version=\"3.0.7\" />\n  </ItemGroup>\n\n</Project>\n","language":"xml","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp2.2</TargetFramework>\n    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.AspNetCore.App\" />\n    <PackageReference Include=\"Quartz\" Version=\"3.0.7\" />\n  </ItemGroup>\n\n</Project>\n"}]}]},{"type":"element","tag":"h2","props":{"id":"creating-an-ijob"},"children":[{"type":"text","value":"Creating an IJob"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-an-ijob","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For the actual background work we are scheduling, we're just going to use a \"hello world\" implementation that writes to an "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ILogger<>"}]},{"type":"text","value":" (and hence to the console). You should implement the Quartz interface "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":" which contains a single asynchronous "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Execute()"}]},{"type":"text","value":" method. Note that we're using dependency injection here to inject the logger into the constructor."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Microsoft.Extensions.Logging;\nusing Quartz;\nusing System.Threading.Tasks;\n\n[DisallowConcurrentExecution]\npublic class HelloWorldJob : IJob\n{\n    private readonly ILogger<HelloWorldJob> _logger;\n    public HelloWorldJob(ILogger<HelloWorldJob> logger)\n    {\n        _logger = logger;\n    }\n\n    public Task Execute(IJobExecutionContext context)\n    {\n        _logger.LogInformation(\"Hello world!\");\n        return Task.CompletedTask;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Microsoft.Extensions.Logging;\nusing Quartz;\nusing System.Threading.Tasks;\n\n[DisallowConcurrentExecution]\npublic class HelloWorldJob : IJob\n{\n    private readonly ILogger<HelloWorldJob> _logger;\n    public HelloWorldJob(ILogger<HelloWorldJob> logger)\n    {\n        _logger = logger;\n    }\n\n    public Task Execute(IJobExecutionContext context)\n    {\n        _logger.LogInformation(\"Hello world!\");\n        return Task.CompletedTask;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I also decorated the job with the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[DisallowConcurrentExecution]"}]},{"type":"text","value":" attribute. This attribute "},{"type":"element","tag":"a","props":{"href":"https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/more-about-jobs.html#job-state-and-concurrency","rel":["nofollow"]},"children":[{"type":"text","value":"prevents Quartz.NET from trying to run the same job concurrently"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h2","props":{"id":"creating-an-ijobfactory"},"children":[{"type":"text","value":"Creating an IJobFactory"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-an-ijobfactory","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Next, we need to tell Quartz how it should create instances of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":". By default, Quartz will try and \"new-up\" instances of the job using "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Activator.CreateInstance"}]},{"type":"text","value":", effectively calling "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"new HelloWorldJob()"}]},{"type":"text","value":". Unfortunately, as we're using constructor injection, that won't work. Instead, we can provide a custom "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobFactory"}]},{"type":"text","value":" that hooks into the ASP.NET Core dependency injection container ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServiceProvider"}]},{"type":"text","value":"):"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Microsoft.Extensions.DependencyInjection;\nusing Quartz;\nusing Quartz.Spi;\nusing System;\n\npublic class SingletonJobFactory : IJobFactory\n{\n    private readonly IServiceProvider _serviceProvider;\n    public SingletonJobFactory(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler)\n    {\n        return _serviceProvider.GetRequiredService(bundle.JobDetail.JobType) as IJob;\n    }\n\n    public void ReturnJob(IJob job) { }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Microsoft.Extensions.DependencyInjection;\nusing Quartz;\nusing Quartz.Spi;\nusing System;\n\npublic class SingletonJobFactory : IJobFactory\n{\n    private readonly IServiceProvider _serviceProvider;\n    public SingletonJobFactory(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler)\n    {\n        return _serviceProvider.GetRequiredService(bundle.JobDetail.JobType) as IJob;\n    }\n\n    public void ReturnJob(IJob job) { }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This factory takes an "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServiceProvider"}]},{"type":"text","value":" in the constructor, and implements the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobFactory"}]},{"type":"text","value":" interface. The important method is the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NewJob()"}]},{"type":"text","value":" method, in which the factory has to return the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":" requested by the Quartz scheduler. In this implementation we delegate directly to the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServiceProvider"}]},{"type":"text","value":", and let the DI container find the required instance. The cast to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":" at the end is required because the non-generic version of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetRequiredService"}]},{"type":"text","value":" returns an "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"object"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ReturnJob"}]},{"type":"text","value":" method is where the scheduler tries to return (i.e. destroy) a job that was created by the factory. Unfortunately, there's no mechanism for doing so with the built-in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServiceProvider"}]},{"type":"text","value":". We can't create a new "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IScopeService"}]},{"type":"text","value":" that fits into the required Quartz API, so we're stuck only being able to create singleton jobs."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is important. With the above implementation, it is only safe to create "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":" implementations that are "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Singletons"}]},{"type":"text","value":" (or transient)."}]}]},{"type":"element","tag":"h2","props":{"id":"configuring-the-job"},"children":[{"type":"text","value":"Configuring the Job"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#configuring-the-job","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I'm only showing a single "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":" implementation here, but we want the Quartz hosted service to be a generic implementation that works for any number of jobs. To help with that, we create a simple DTO called "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobSchedule"}]},{"type":"text","value":" that we'll use to define the timer schedule for a given job type:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\n\npublic class JobSchedule\n{\n    public JobSchedule(Type jobType, string cronExpression)\n    {\n        JobType = jobType;\n        CronExpression = cronExpression;\n    }\n\n    public Type JobType { get; }\n    public string CronExpression { get; }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\n\npublic class JobSchedule\n{\n    public JobSchedule(Type jobType, string cronExpression)\n    {\n        JobType = jobType;\n        CronExpression = cronExpression;\n    }\n\n    public Type JobType { get; }\n    public string CronExpression { get; }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobType"}]},{"type":"text","value":" is the .NET type of the job ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HelloWorldJob"}]},{"type":"text","value":" for our example), and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CronExpression"}]},{"type":"text","value":" is a "},{"type":"element","tag":"a","props":{"href":"https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html","rel":["nofollow"]},"children":[{"type":"text","value":"Quartz.NET Cron expression"}]},{"type":"text","value":". Cron expressions allow complex timer scheduling so you can set rules like \"fire every half hour between the hours of 8 am and 10 am, on the 5th and 20th of every month\". Just be sure to "},{"type":"element","tag":"a","props":{"href":"https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html","rel":["nofollow"]},"children":[{"type":"text","value":"check the documentation"}]},{"type":"text","value":" for examples as not all Cron expressions used by different systems are interchangeable."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We'll add the job to DI and configure its schedule in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Startup.ConfigureServices()"}]},{"type":"text","value":":"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing Quartz;\nusing Quartz.Impl;\nusing Quartz.Spi;\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Add Quartz services\n    services.AddSingleton<IJobFactory, SingletonJobFactory>();\n    services.AddSingleton<ISchedulerFactory, StdSchedulerFactory>();\n\n    // Add our job\n    services.AddSingleton<HelloWorldJob>();\n    services.AddSingleton(new JobSchedule(\n        jobType: typeof(HelloWorldJob),\n        cronExpression: \"0/5 * * * * ?\")); // run every 5 seconds\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing Quartz;\nusing Quartz.Impl;\nusing Quartz.Spi;\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Add Quartz services\n    services.AddSingleton<IJobFactory, SingletonJobFactory>();\n    services.AddSingleton<ISchedulerFactory, StdSchedulerFactory>();\n\n    // Add our job\n    services.AddSingleton<HelloWorldJob>();\n    services.AddSingleton(new JobSchedule(\n        jobType: typeof(HelloWorldJob),\n        cronExpression: \"0/5 * * * * ?\")); // run every 5 seconds\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This code adds four things as singletons to the DI container:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SingletonJobFactory"}]},{"type":"text","value":" shown earlier, used for creating the job instances."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"An implementation of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ISchedulerFactory"}]},{"type":"text","value":", the built-in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StdSchedulerFactory"}]},{"type":"text","value":", which handles scheduling and managing jobs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HelloWorldJob"}]},{"type":"text","value":" job itself"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"An instance of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobSchedule"}]},{"type":"text","value":" for the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HelloWorldJob"}]},{"type":"text","value":" with a Cron expression to run every 5 seconds."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There's only one piece missing now that brings them all together, the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"QuartzHostedService"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h2","props":{"id":"creating-the-quartzhostedservice"},"children":[{"type":"text","value":"Creating the QuartzHostedService"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-the-quartzhostedservice","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"QuartzHostedService"}]},{"type":"text","value":" is an implementation of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHostedService"}]},{"type":"text","value":" that sets up the Quartz scheduler, and starts it running in the background. Due to the design of Quartz, we can implement "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHostedService"}]},{"type":"text","value":" directly, instead of the "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/background-tasks-with-ihostedservice","rel":["nofollow"]},"children":[{"type":"text","value":"more common approach of deriving from the base "}]},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BackgroundService"}]},{"type":"text","value":" class. The full code for the service is listed below, and I'll discuss it afterwards."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Hosting;\nusing Quartz;\nusing Quartz.Spi;\n\npublic class QuartzHostedService : IHostedService\n{\n    private readonly ISchedulerFactory _schedulerFactory;\n    private readonly IJobFactory _jobFactory;\n    private readonly IEnumerable<JobSchedule> _jobSchedules;\n\n    public QuartzHostedService(\n        ISchedulerFactory schedulerFactory,\n        IJobFactory jobFactory,\n        IEnumerable<JobSchedule> jobSchedules)\n    {\n        _schedulerFactory = schedulerFactory;\n        _jobSchedules = jobSchedules;\n        _jobFactory = jobFactory;\n    }\n    public IScheduler Scheduler { get; set; }\n\n    public async Task StartAsync(CancellationToken cancellationToken)\n    {\n        Scheduler = await _schedulerFactory.GetScheduler(cancellationToken);\n        Scheduler.JobFactory = _jobFactory;\n\n        foreach (var jobSchedule in _jobSchedules)\n        {\n            var job = CreateJob(jobSchedule);\n            var trigger = CreateTrigger(jobSchedule);\n\n            await Scheduler.ScheduleJob(job, trigger, cancellationToken);\n        }\n\n        await Scheduler.Start(cancellationToken);\n    }\n\n    public async Task StopAsync(CancellationToken cancellationToken)\n    {\n        await Scheduler?.Shutdown(cancellationToken);\n    }\n\n    private static IJobDetail CreateJob(JobSchedule schedule)\n    {\n        var jobType = schedule.JobType;\n        return JobBuilder\n            .Create(jobType)\n            .WithIdentity(jobType.FullName)\n            .WithDescription(jobType.Name)\n            .Build();\n    }\n\n    private static ITrigger CreateTrigger(JobSchedule schedule)\n    {\n        return TriggerBuilder\n            .Create()\n            .WithIdentity($\"{schedule.JobType.FullName}.trigger\")\n            .WithCronSchedule(schedule.CronExpression)\n            .WithDescription(schedule.CronExpression)\n            .Build();\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Hosting;\nusing Quartz;\nusing Quartz.Spi;\n\npublic class QuartzHostedService : IHostedService\n{\n    private readonly ISchedulerFactory _schedulerFactory;\n    private readonly IJobFactory _jobFactory;\n    private readonly IEnumerable<JobSchedule> _jobSchedules;\n\n    public QuartzHostedService(\n        ISchedulerFactory schedulerFactory,\n        IJobFactory jobFactory,\n        IEnumerable<JobSchedule> jobSchedules)\n    {\n        _schedulerFactory = schedulerFactory;\n        _jobSchedules = jobSchedules;\n        _jobFactory = jobFactory;\n    }\n    public IScheduler Scheduler { get; set; }\n\n    public async Task StartAsync(CancellationToken cancellationToken)\n    {\n        Scheduler = await _schedulerFactory.GetScheduler(cancellationToken);\n        Scheduler.JobFactory = _jobFactory;\n\n        foreach (var jobSchedule in _jobSchedules)\n        {\n            var job = CreateJob(jobSchedule);\n            var trigger = CreateTrigger(jobSchedule);\n\n            await Scheduler.ScheduleJob(job, trigger, cancellationToken);\n        }\n\n        await Scheduler.Start(cancellationToken);\n    }\n\n    public async Task StopAsync(CancellationToken cancellationToken)\n    {\n        await Scheduler?.Shutdown(cancellationToken);\n    }\n\n    private static IJobDetail CreateJob(JobSchedule schedule)\n    {\n        var jobType = schedule.JobType;\n        return JobBuilder\n            .Create(jobType)\n            .WithIdentity(jobType.FullName)\n            .WithDescription(jobType.Name)\n            .Build();\n    }\n\n    private static ITrigger CreateTrigger(JobSchedule schedule)\n    {\n        return TriggerBuilder\n            .Create()\n            .WithIdentity($\"{schedule.JobType.FullName}.trigger\")\n            .WithCronSchedule(schedule.CronExpression)\n            .WithDescription(schedule.CronExpression)\n            .Build();\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"QuartzHostedService"}]},{"type":"text","value":" has three dependencies: the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ISchedulerFactory"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobFactory"}]},{"type":"text","value":" we configured in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Startup"}]},{"type":"text","value":", and an "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IEnumerable"}]},{"type":"text","value":". We only added a single "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobSchedule"}]},{"type":"text","value":" to the DI container (for the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HelloWorldJob"}]},{"type":"text","value":"), but if you register more job schedules with the DI container they'll all be injected here."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync"}]},{"type":"text","value":" is called when the application starts up and is where we configure Quartz. We start by creating an instance of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IScheduler"}]},{"type":"text","value":", assigning it to a property for use later, and setting the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobFactory"}]},{"type":"text","value":" for the scheduler to the injected instance:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public async Task StartAsync(CancellationToken cancellationToken)\n{\n    Scheduler = await _schedulerFactory.GetScheduler(cancellationToken);\n    Scheduler.JobFactory = _jobFactory;\n\n    // ...\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task StartAsync(CancellationToken cancellationToken)\n{\n    Scheduler = await _schedulerFactory.GetScheduler(cancellationToken);\n    Scheduler.JobFactory = _jobFactory;\n\n    // ...\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Next, we loop through the injected job schedules, and create a Quartz "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobDetail"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ITrigger"}]},{"type":"text","value":" for each one using the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateJob"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateTrigger"}]},{"type":"text","value":" helper methods at the end of the class. If you don't like how this part works, or need more control over the configuration, you can easily customise it by extending the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobSchedule"}]},{"type":"text","value":" DTO as you see fit."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public async Task StartAsync(CancellationToken cancellationToken)\n{\n    // ...\n    foreach (var jobSchedule in _jobSchedules)\n    {\n        var job = CreateJob(jobSchedule);\n        var trigger = CreateTrigger(jobSchedule);\n\n        await Scheduler.ScheduleJob(job, trigger, cancellationToken);\n    }\n    // ...\n}\n\nprivate static IJobDetail CreateJob(JobSchedule schedule)\n{\n    var jobType = schedule.JobType;\n    return JobBuilder\n        .Create(jobType)\n        .WithIdentity(jobType.FullName)\n        .WithDescription(jobType.Name)\n        .Build();\n}\n\nprivate static ITrigger CreateTrigger(JobSchedule schedule)\n{\n    return TriggerBuilder\n        .Create()\n        .WithIdentity($\"{schedule.JobType.FullName}.trigger\")\n        .WithCronSchedule(schedule.CronExpression)\n        .WithDescription(schedule.CronExpression)\n        .Build();\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task StartAsync(CancellationToken cancellationToken)\n{\n    // ...\n    foreach (var jobSchedule in _jobSchedules)\n    {\n        var job = CreateJob(jobSchedule);\n        var trigger = CreateTrigger(jobSchedule);\n\n        await Scheduler.ScheduleJob(job, trigger, cancellationToken);\n    }\n    // ...\n}\n\nprivate static IJobDetail CreateJob(JobSchedule schedule)\n{\n    var jobType = schedule.JobType;\n    return JobBuilder\n        .Create(jobType)\n        .WithIdentity(jobType.FullName)\n        .WithDescription(jobType.Name)\n        .Build();\n}\n\nprivate static ITrigger CreateTrigger(JobSchedule schedule)\n{\n    return TriggerBuilder\n        .Create()\n        .WithIdentity($\"{schedule.JobType.FullName}.trigger\")\n        .WithCronSchedule(schedule.CronExpression)\n        .WithDescription(schedule.CronExpression)\n        .Build();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, once all the jobs are scheduled, you call "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Scheduler.Start()"}]},{"type":"text","value":" to actually start the Quartz.NET scheduler processing in the background. When the app shuts down, the framework will call "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StopAsync()"}]},{"type":"text","value":", at which point you can call "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Scheduler.Stop()"}]},{"type":"text","value":" to safely shut down the scheduler process."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public async Task StopAsync(CancellationToken cancellationToken)\n{\n    await Scheduler?.Shutdown(cancellationToken);\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task StopAsync(CancellationToken cancellationToken)\n{\n    await Scheduler?.Shutdown(cancellationToken);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"You can register the hosted service using the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddHostedService()"}]},{"type":"text","value":" extension method in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Startup.ConfigureServices"}]},{"type":"text","value":":"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public void ConfigureServices(IServiceCollection services)\n{\n    // ...\n    services.AddHostedService<QuartzHostedService>();\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void ConfigureServices(IServiceCollection services)\n{\n    // ...\n    services.AddHostedService<QuartzHostedService>();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If you run the application, you should see the background task running every 5 seconds and writing to the Console (or wherever you have logging configured)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Background service writing Hello World to console repeatedly","src":"/images/2019-11-05-quartz/quartz_service.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"using-scoped-services-in-jobs"},"children":[{"type":"text","value":"Using scoped services in jobs"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#using-scoped-services-in-jobs","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There's one big problem with the implementation as described in this post: you can only create Singleton or Transient jobs. That means you can't use any dependencies that are registered as Scoped services. For example, you can't inject an EF Core "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DatabaseContext"}]},{"type":"text","value":" into your "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":" implementation, as you'll have a "},{"type":"element","tag":"a","props":{"href":"http://blog.ploeh.dk/2014/06/02/captive-dependency/","rel":["nofollow"]},"children":[{"type":"text","value":"captive dependency"}]},{"type":"text","value":" problem."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Working around this isn't a big issue: you can inject an "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServiceProvider"}]},{"type":"text","value":" and create your own scope, "},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/the-dangers-and-gotchas-of-using-scoped-services-when-configuring-options-in-asp-net-core/#3-creating-a-new-scope-in-iconfigureoptions","rel":["nofollow"]},"children":[{"type":"text","value":"similar to the solution for a similar problem in a previous post"}]},{"type":"text","value":". For example, if you need to use a scoped service in your "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HelloWorldJob"}]},{"type":"text","value":", you could use something like the following:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class HelloWorldJob : IJob\n{\n    // Inject the DI provider\n    private readonly IServiceProvider _provider;\n    public HelloWorldJob( IServiceProvider provider)\n    {\n        _provider = provider;\n    }\n\n    public Task Execute(IJobExecutionContext context)\n    {\n        // Create a new scope\n        using(var scope = _provider.CreateScope())\n        {\n            // Resolve the Scoped service\n            var service = scope.ServiceProvider.GetService<IScopedService>();\n            _logger.LogInformation(\"Hello world!\");\n        }\n\n        return Task.CompletedTask;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class HelloWorldJob : IJob\n{\n    // Inject the DI provider\n    private readonly IServiceProvider _provider;\n    public HelloWorldJob( IServiceProvider provider)\n    {\n        _provider = provider;\n    }\n\n    public Task Execute(IJobExecutionContext context)\n    {\n        // Create a new scope\n        using(var scope = _provider.CreateScope())\n        {\n            // Resolve the Scoped service\n            var service = scope.ServiceProvider.GetService<IScopedService>();\n            _logger.LogInformation(\"Hello world!\");\n        }\n\n        return Task.CompletedTask;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This ensures a new scope is created every time the job runs, so you can retrieve (and dispose) scoped services inside the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":". Unfortunately things do get a little messy. In the next post I'll show a variation on this approach that is a little cleaner."}]},{"type":"element","tag":"h2","props":{"id":"summary"},"children":[{"type":"text","value":"Summary"},{"type":"element","tag":"a","props":{"href":"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#summary","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://andrewlock.net/assets/img/icons-link.svg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this post I introduced Quartz.NET and showed how you could use it to schedule background jobs to run in ASP.NET Core using "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHostedService"}]},{"type":"text","value":". The example shown in this post is best for singleton or transient jobs, which isn't ideal, as consuming scoped services is clumsy. In the next post, I'll show a variation on this approach that makes using scoped services easier."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/andrewlock/blog-examples/tree/master/QuartzHostedService","rel":["nofollow"]},"children":[{"type":"text","value":"Example source code for this post"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/HangfireIO/Cronos","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/HangfireIO/Cronos"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/HangfireIO/Hangfire","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/HangfireIO/Hangfire"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/quartznet/quartznet","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/quartznet/quartznet"}]}]}]},{"type":"element","tag":"h3","props":{"id":"hangfire-与quartznet对比"},"children":[{"type":"text","value":"Hangfire 与quartz.net对比"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在项目没有引入Hangfire之前，一直使用的是Quartz.net。个人认为Quartz.net在定时任务处理方面优势如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支持秒级单位的定时任务处理，但是Hangfire只能支持分钟及以上的定时任务处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原因在于Hangfire用的是开源的"},{"type":"element","tag":"a","props":{"href":"https://github.com/atifaziz/NCrontab","rel":["nofollow"]},"children":[{"type":"text","value":"NCrontab"}]},{"type":"text","value":"组件，跟linux上的crontab指令相似。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"更加复杂的触发器，日历以及任务调度处理"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可配置的定时任务"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是为什么要换Hangfire? 很大的原因在于项目需要一个后台可监控的应用，不用每次都要从服务器拉取日志查看，在没有ELK的时候相当不方便。Hangfire控制面板不仅提供监控，也可以手动的触发执行定时任务。如果在定时任务处理方面没有很高的要求，比如一定要5s定时执行，Hangfire值得拥有。抛开这些，Hangfire优势太明显了："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"持久化保存任务、队列、统计信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重试机制"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多语言支持"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支持任务取消"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支持按指定"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Job Queue"}]},{"type":"text","value":"处理任务"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器端工作线程可控，即job执行并发数控制"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分布式部署，支持高可用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"良好的扩展性，如支持IOC、Hangfire Dashboard授权控制、Asp.net Core、持久化存储等"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说了这么多的优点，我们可以有个案例，例如秒杀场景：用户下单->订单生成->扣减库存，Hangfire对于这种分布式的应用处理也是适用的，最后会给出实现。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"introduction-what-is-quartznet","depth":2,"text":"Introduction - what is Quartz.NET?"},{"id":"installing-quartznet","depth":2,"text":"Installing Quartz.NET"},{"id":"creating-an-ijob","depth":2,"text":"Creating an IJob"},{"id":"creating-an-ijobfactory","depth":2,"text":"Creating an IJobFactory"},{"id":"configuring-the-job","depth":2,"text":"Configuring the Job"},{"id":"creating-the-quartzhostedservice","depth":2,"text":"Creating the QuartzHostedService"},{"id":"using-scoped-services-in-jobs","depth":2,"text":"Using scoped services in jobs"},{"id":"summary","depth":2,"text":"Summary","children":[{"id":"hangfire-与quartznet对比","depth":3,"text":"Hangfire 与quartz.net对比"}]}]}},"_type":"markdown","_id":"content:dotnet:2019-11-05-quartz.md","_source":"content","_file":"dotnet/2019-11-05-quartz.md","_extension":"md","date":"2019-11-05"},{"_path":"/dotnet/2019-12-01-datetimeoffset","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"DatetimeOffset和Datetime的区别","description":"  [Fact]\n        public void TestDatetimeoffset2()\n        {\n            var a = DateTimeOffset.Now;\n            var b = a.ToLocalTime();\n            var c = a.ToUniversalTime();\n\n            Assert.Equal(b, c);\n        }\n上面的abc都是一个值    [Fact]\n        public void TestDatetimeoffset3()\n        {\n    ","body":{"type":"root","children":[{"type":"element","tag":"pre","props":{"code":"  [Fact]\n        public void TestDatetimeoffset2()\n        {\n            var a = DateTimeOffset.Now;\n            var b = a.ToLocalTime();\n            var c = a.ToUniversalTime();\n\n            Assert.Equal(b, c);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  [Fact]\n        public void TestDatetimeoffset2()\n        {\n            var a = DateTimeOffset.Now;\n            var b = a.ToLocalTime();\n            var c = a.ToUniversalTime();\n\n            Assert.Equal(b, c);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的abc都是一个值"}]},{"type":"element","tag":"pre","props":{"code":"    [Fact]\n        public void TestDatetimeoffset3()\n        {\n            var a = DateTime.Now;\n            var b = a.ToLocalTime();\n            var c = a.ToUniversalTime();\n\n            Assert.Equal(b, c);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    [Fact]\n        public void TestDatetimeoffset3()\n        {\n            var a = DateTime.Now;\n            var b = a.ToLocalTime();\n            var c = a.ToUniversalTime();\n\n            Assert.Equal(b, c);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的值是不等的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"datetimeoffset使用efcore存储到datetime字段都是0时区的...取出来后如果显示再web可以toLocalTime"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果是游戏中使用,除非是发送给用户显示..否则不需要toLocalTime.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1，DateTime"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"表示时间上的一刻，通常以日期和当天时间来表示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2， DateTimeOffset"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"表示一个时间点，通常以相对于协调世界时（UTC）的日期和时间来表示"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/dotnet/standard/datetime/performing-arithmetic-operations","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/en-us/dotnet/standard/datetime/performing-arithmetic-operations"}]}]},{"type":"element","tag":"pre","props":{"code":"\nusing System;\n\npublic enum TimeComparison\n{\n   EarlierThan = -1,\n   TheSameAs = 0,\n   LaterThan = 1\n}\n\npublic class DateManipulation\n{\n   public static void Main()\n   {\n      DateTime localTime = DateTime.Now;\n      DateTime utcTime = DateTime.UtcNow;\n      \n      Console.WriteLine(\"Difference between {0} and {1} time: {2}:{3} hours\", \n                        localTime.Kind.ToString(), \n                        utcTime.Kind.ToString(), \n                        (localTime - utcTime).Hours, \n                        (localTime - utcTime).Minutes);\n      Console.WriteLine(\"The {0} time is {1} the {2} time.\", \n                        localTime.Kind.ToString(), \n                        Enum.GetName(typeof(TimeComparison), localTime.CompareTo(utcTime)), \n                        utcTime.Kind.ToString());  \n   }\n}\n// If run in the U.S. Pacific Standard Time zone, the example displays \n// the following output to the console:\n//    Difference between Local and Utc time: -7:0 hours\n//    The Local time is EarlierThan the Utc time.      \n\n\npublic class DateTimeOffsetManipulation\n{\n   public static void Main()\n   {\n      DateTimeOffset localTime = DateTimeOffset.Now;\n      DateTimeOffset utcTime = DateTimeOffset.UtcNow;\n      \n      Console.WriteLine(\"Difference between local time and UTC: {0}:{1:D2} hours\", \n                        (localTime - utcTime).Hours, \n                        (localTime - utcTime).Minutes);\n      Console.WriteLine(\"The local time is {0} UTC.\", \n                        Enum.GetName(typeof(TimeComparison), localTime.CompareTo(utcTime)));  \n   }\n}\n// Regardless of the local time zone, the example displays \n// the following output to the console:\n//    Difference between local time and UTC: 0:00 hours.\n//    The local time is TheSameAs UTC.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nusing System;\n\npublic enum TimeComparison\n{\n   EarlierThan = -1,\n   TheSameAs = 0,\n   LaterThan = 1\n}\n\npublic class DateManipulation\n{\n   public static void Main()\n   {\n      DateTime localTime = DateTime.Now;\n      DateTime utcTime = DateTime.UtcNow;\n      \n      Console.WriteLine(\"Difference between {0} and {1} time: {2}:{3} hours\", \n                        localTime.Kind.ToString(), \n                        utcTime.Kind.ToString(), \n                        (localTime - utcTime).Hours, \n                        (localTime - utcTime).Minutes);\n      Console.WriteLine(\"The {0} time is {1} the {2} time.\", \n                        localTime.Kind.ToString(), \n                        Enum.GetName(typeof(TimeComparison), localTime.CompareTo(utcTime)), \n                        utcTime.Kind.ToString());  \n   }\n}\n// If run in the U.S. Pacific Standard Time zone, the example displays \n// the following output to the console:\n//    Difference between Local and Utc time: -7:0 hours\n//    The Local time is EarlierThan the Utc time.      \n\n\npublic class DateTimeOffsetManipulation\n{\n   public static void Main()\n   {\n      DateTimeOffset localTime = DateTimeOffset.Now;\n      DateTimeOffset utcTime = DateTimeOffset.UtcNow;\n      \n      Console.WriteLine(\"Difference between local time and UTC: {0}:{1:D2} hours\", \n                        (localTime - utcTime).Hours, \n                        (localTime - utcTime).Minutes);\n      Console.WriteLine(\"The local time is {0} UTC.\", \n                        Enum.GetName(typeof(TimeComparison), localTime.CompareTo(utcTime)));  \n   }\n}\n// Regardless of the local time zone, the example displays \n// the following output to the console:\n//    Difference between local time and UTC: 0:00 hours.\n//    The local time is TheSameAs UTC.\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从实例中可以看出，DateTimeOffset是取相对于UTC的日期和时间来表示的，所以DateTimeOffset.Now和DateTimeOffset.UtcNow的值是一样的。而DateTime不同，是以日期和当前时间来显示的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就是说..如果你用DateTime进行加减运算要么只用DateTime.Now..要么只用DateTime.UtcNow..混用会出现不可预期的错误"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而DateTimeOffset的无论是用now还是utcnow加减都一样,因为他代表的是一个时间点...如果是为了客户端显示使用可以转换成本地时间再tostring"}]},{"type":"element","tag":"h1","props":{"id":"还有就是不要混用不要将datetime当成datetimeoffset使用"},"children":[{"type":"text","value":"还有就是不要混用..不要将datetime当成datetimeoffset使用,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当需要使用DateTimeOffset的Date等字段的时候,"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要及时转成DateTimeOffset,需要使用new方法并设置时区转成datetimeoffset"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"直接赋值,会出现时区问题"}]}]},{"type":"element","tag":"pre","props":{"code":"var now = new DateTimeOffset(1977,1,1,14,0,0,TimeSpan.Zero);\nvar mt = now.AddDays(1).Date;\nDateTimeOffset d = mt; //这里直接赋值会有当前时区\nvar mto= new DateTimeOffset(mt,TimeSpan.Zero);\n\nConsole.WriteLine(now); //1/1/1977 2:00:00 PM +00:00\nConsole.WriteLine(mt); //1/2/1977 12:00:00 AM\nConsole.WriteLine(d);//1/2/1977 12:00:00 AM +08:00\nConsole.WriteLine(mto);//1/2/1977 12:00:00 AM +00:00\n\nConsole.WriteLine(mto == mt); //false\nConsole.WriteLine(d == mto); //false\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var now = new DateTimeOffset(1977,1,1,14,0,0,TimeSpan.Zero);\nvar mt = now.AddDays(1).Date;\nDateTimeOffset d = mt; //这里直接赋值会有当前时区\nvar mto= new DateTimeOffset(mt,TimeSpan.Zero);\n\nConsole.WriteLine(now); //1/1/1977 2:00:00 PM +00:00\nConsole.WriteLine(mt); //1/2/1977 12:00:00 AM\nConsole.WriteLine(d);//1/2/1977 12:00:00 AM +08:00\nConsole.WriteLine(mto);//1/2/1977 12:00:00 AM +00:00\n\nConsole.WriteLine(mto == mt); //false\nConsole.WriteLine(d == mto); //false\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2019-12-01-datetimeoffset.md","_source":"content","_file":"dotnet/2019-12-01-datetimeoffset.md","_extension":"md","date":"2019-12-01"},{"_path":"/dotnet/2020-01-05-big-little-endian","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"大小端字节序(Big Endian和Little Endian)","description":"Big Endian是指低地址存放最高有效字节（MSB），而Little Endian则是低地址存放最低有效字节（LSB）。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"那么何为字节序endia呢"},"children":[{"type":"text","value":"那么何为字节序（Endia）呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Big Endian是指低地址存放最高有效字节（MSB），而Little Endian则是低地址存放最低有效字节（LSB）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"大端模式"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例子："}]},{"type":"element","tag":"pre","props":{"code":"0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\n\n0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\n\n0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在大端模式下，前32位应该这样读:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":" e6 84 6c 4e"}]},{"type":"text","value":" ( 假设int占4个字节)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"记忆方法: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"地址的增长顺序与值的增长顺序相反"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"小端模式"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例子："}]},{"type":"element","tag":"pre","props":{"code":"0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\n\n0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\n\n0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在小端模式下，前32位应该这样读: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"4e 6c 84 e6"}]},{"type":"text","value":"( 假设int占4个字节)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"记忆方法: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"地址的增长顺序与值的增长顺序相同"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有图有真相，举个例子，数字 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0x12345678"}]},{"type":"text","value":" 在两种不同字节序CPU中的存储顺序如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"pic1","src":"/images/2020-01-05-big-little-endian/20160414225024808"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"为什么会有这样的情况呢"},"children":[{"type":"text","value":"为什么会有这样的情况呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Motorola的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"PowerPC"}]},{"type":"text","value":"系列CPU采用Big Endian方式存储数据。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Intel的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"x86"}]},{"type":"text","value":"系列CPU采用Little Endian方式存储数据。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ARM既可以工作在大端模式，也可以工作在小端模式。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"再来说说，一些我所收集到的情况吧。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Windos(x86,x64)和Linux(x86,x64)都是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Little Endian"}]},{"type":"text","value":"操作系统"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在ARM上，我见到的都是用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Little Endian"}]},{"type":"text","value":"方式存储数据。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"C/C++语言编写的程序里数据存储顺序是跟编译平台"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"所在的CPU相关"}]},{"type":"text","value":"的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"JAVA编写的程序则唯一采用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Big Endian"}]},{"type":"text","value":"方式来存储数据。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有网络协议也都是采用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Big Endian"}]},{"type":"text","value":"的方式来传输数据的。所以有时我们也会把"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Big Endian"}]},{"type":"text","value":"方式称之为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"网络字节序"}]},{"type":"text","value":"。"}]}]},{"type":"element","tag":"h2","props":{"id":"为什么要注意字节序的问题呢"},"children":[{"type":"text","value":"为什么要注意字节序的问题呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能这么问。当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？尤其是当你把你在微机上运算的结果运用到计算机群上去的话。在这里我想说说两种语言。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的 0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。什么？竟然变成另外一个数字了？是的，就是这种后果。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。"}]},{"type":"element","tag":"h1","props":{"id":"网络字节序"},"children":[{"type":"text","value":"网络字节序"}]},{"type":"element","tag":"h2","props":{"id":"一在进行网络通信时是否需要进行字节序转换"},"children":[{"type":"text","value":"一、在进行网络通信时是否需要进行字节序转换？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原因如下：网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。"}]},{"type":"element","tag":"h2","props":{"id":"二网络字节序"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"二、网络字节序"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;"}]},{"type":"element","tag":"h1","props":{"id":"c-大端转换"},"children":[{"type":"text","value":"c# 大端转换"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c#在windows平台上是小端字节序(Windos(x86,x64)和Linux(x86,x64)都是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Little Endian"}]},{"type":"text","value":"操作系统,不止是c#)。网络发送字节流是按大端序发送，也就是从左到右发送，和c#的小端序相反，造成网关不能正常识别协议。所以需要转换"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"大小端转换"}]}]},{"type":"element","tag":"pre","props":{"code":"int x = 439041118;  // 十六进制为 1A2B3C5E\n\nstring s = null;\n\nbyte[] b = BitConverter.GetBytes( x );\n\ns = BitConverter.ToString( b ); // 小端模式\nConsole.WriteLine( s ); // 小端输出 为 5E-3C-2B-1A\n\nArray.Reverse( b ); // 反转\n\ns = BitConverter.ToString( b ); // 大端模式\nConsole.WriteLine( \"{0:x}\", s ); // 大端输出 为 1A-2B-3C-5E\n\nConsole.ReadKey();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"int x = 439041118;  // 十六进制为 1A2B3C5E\n\nstring s = null;\n\nbyte[] b = BitConverter.GetBytes( x );\n\ns = BitConverter.ToString( b ); // 小端模式\nConsole.WriteLine( s ); // 小端输出 为 5E-3C-2B-1A\n\nArray.Reverse( b ); // 反转\n\ns = BitConverter.ToString( b ); // 大端模式\nConsole.WriteLine( \"{0:x}\", s ); // 大端输出 为 1A-2B-3C-5E\n\nConsole.ReadKey();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"C# 判断数据在此计算机结构中存储时的字节顺序（“Endian”性质），即大端还是小端"}]}]},{"type":"element","tag":"pre","props":{"code":"int data = 439041118; // 十六进制为 1A2B3C5E\nbyte[] bData = BitConverter.GetBytes( data );\n            \nif (BitConverter.IsLittleEndian) // 若为 小端模式\n{\n   Array.Reverse( bData ); // 转换为 大端模式               \n}\nstring s = BitConverter.ToString( bData );\n\nConsole.WriteLine(s);\n\nConsole.ReadKey();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"int data = 439041118; // 十六进制为 1A2B3C5E\nbyte[] bData = BitConverter.GetBytes( data );\n            \nif (BitConverter.IsLittleEndian) // 若为 小端模式\n{\n   Array.Reverse( bData ); // 转换为 大端模式               \n}\nstring s = BitConverter.ToString( bData );\n\nConsole.WriteLine(s);\n\nConsole.ReadKey();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一些封装"}]}]},{"type":"element","tag":"pre","props":{"code":"\n//翻转byte数组\npublic static void ReverseBytes(byte[] bytes)\n{\n    byte tmp;\n    int len = bytes.Length;\n\n    for (int i = 0; i < len / 2; i++ )\n    {\n        tmp = bytes[len - 1 - i];\n        bytes[len - 1 - i] = bytes[i];\n        bytes[i] = tmp;\n    }\n}\n\n//规定转换起始位置和长度\n public static void ReverseBytes(byte[] bytes, int start, int len)\n {\n     int end = start + len - 1;\n     byte tmp;\n     int i = 0;\n     for (int index = start; index < start + len/2; index++,i++)\n     {\n         tmp = bytes[end - i];\n         bytes[end - i] = bytes[index];\n         bytes[index] = tmp;\n     }\n }\n\n// 翻转字节顺序 (16-bit)\npublic static UInt16 ReverseBytes(UInt16 value)\n{\n  return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);\n}\n\n\n// 翻转字节顺序 (32-bit)\npublic static UInt32 ReverseBytes(UInt32 value)\n{\n  return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |\n         (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;\n}\n\n\n// 翻转字节顺序 (64-bit)\npublic static UInt64 ReverseBytes(UInt64 value)\n{\n  return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |\n         (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |\n         (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |\n         (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n//翻转byte数组\npublic static void ReverseBytes(byte[] bytes)\n{\n    byte tmp;\n    int len = bytes.Length;\n\n    for (int i = 0; i < len / 2; i++ )\n    {\n        tmp = bytes[len - 1 - i];\n        bytes[len - 1 - i] = bytes[i];\n        bytes[i] = tmp;\n    }\n}\n\n//规定转换起始位置和长度\n public static void ReverseBytes(byte[] bytes, int start, int len)\n {\n     int end = start + len - 1;\n     byte tmp;\n     int i = 0;\n     for (int index = start; index < start + len/2; index++,i++)\n     {\n         tmp = bytes[end - i];\n         bytes[end - i] = bytes[index];\n         bytes[index] = tmp;\n     }\n }\n\n// 翻转字节顺序 (16-bit)\npublic static UInt16 ReverseBytes(UInt16 value)\n{\n  return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);\n}\n\n\n// 翻转字节顺序 (32-bit)\npublic static UInt32 ReverseBytes(UInt32 value)\n{\n  return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |\n         (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;\n}\n\n\n// 翻转字节顺序 (64-bit)\npublic static UInt64 ReverseBytes(UInt64 value)\n{\n  return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |\n         (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |\n         (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |\n         (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外c#直接提供了网络字节序转换方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Net.IPAddress.HostToNetworkOrder"}]},{"type":"text","value":"（本机到网络转换）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Net.IPAddress.NetworkToHostOrder"}]},{"type":"text","value":"(网络字节转成本机)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"推荐使用这种方法，简单有效。"}]},{"type":"element","tag":"pre","props":{"code":"short x = 6;\nshort b = System.Net.IPAddress.HostToNetworkOrder(x); //把x转成相应的大端字节数\nbyte[] bb = System.BitConverter.GetBytes(b);//这样直接取到的就是大端字节序字节数组。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"short x = 6;\nshort b = System.Net.IPAddress.HostToNetworkOrder(x); //把x转成相应的大端字节数\nbyte[] bb = System.BitConverter.GetBytes(b);//这样直接取到的就是大端字节序字节数组。\n"}]}]},{"type":"element","tag":"h2","props":{"id":"对于字符串型"},"children":[{"type":"text","value":"对于字符串型："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 System.Text.Encoding.Default.GetBytes();直接取字串对应字节数组。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不知道为什么这个方法取到的直接就是大端字节数组。不用转换。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后来查了一下，关于字串的字节序问题，因为gbk和utf-8都是以单个字节表示数字的，所以不存在字节序问题，在多个不同系统架构都用。对于utf-16，则是以双字节表示一个整数，所以为会有字节序问题，分大小端unicode。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"System.Text.Encoding.Default.GetBytes();在我的简体中文系统上是以gb2312的编码，也就是单个字来进行编码的，所以也不会有字节序问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"补充：“**对于任何字符编码，编码单元的顺序是由编码方案指定的，与endian无关。**例如GBK的编码单元是字节，用两个字节表示一个汉字。这两个字节的顺序是固定的，不受CPU字节序的影响。UTF-16的编码单元是word（双字节），word之间的顺序是编码方案指定的，word内部的字节排列才会受到endian的影响。”，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以utf-8也没有字节序的问题。字节序问题之存在于需要使用两个字节以上来表示整数。而UTF-8只是一串字节流，不存在字节序问题，不过将这些字节流翻译成Unicode比其他的传输方式复杂。以字节为单位编码的，无论一个汉字是多少个字节，都无字节序问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你注意，字节序问题不是指多个字节传输的先后，这个是固定的无异议的。而是指一个多字节编码在机器中的表示方式问题。\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"char str[] = \"abaksdkakskasklasflk\"；"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个无字节序问题。但\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int  str[] = {0x11223344, 2, 3 }"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就有字节序问题了。因为str[0]同样数值不同机器中表示不同。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而剩下的， 就是字符编码内部的字节序了。比如UTF-16是用两个字节表示一个字符，但是这两个字节内部如何排序，系统并不知道，所以必须指定字节序。但是UTF-8由于几个字节表示并不相同，一定要从那个表示长度的字节开始读，相当于一开始就知道该从哪里是队头队尾，所以不存在字节序问题。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"为什么会有这样的情况呢","depth":2,"text":"为什么会有这样的情况呢？"},{"id":"为什么要注意字节序的问题呢","depth":2,"text":"为什么要注意字节序的问题呢？"},{"id":"一在进行网络通信时是否需要进行字节序转换","depth":2,"text":"一、在进行网络通信时是否需要进行字节序转换？"},{"id":"二网络字节序","depth":2,"text":"二、网络字节序"},{"id":"对于字符串型","depth":2,"text":"对于字符串型："}]}},"_type":"markdown","_id":"content:dotnet:2020-01-05-big-little-endian.md","_source":"content","_file":"dotnet/2020-01-05-big-little-endian.md","_extension":"md","date":"2020-01-05"},{"_path":"/dotnet/2020-01-06-dll-load","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"dll文件的加载","description":"程序的运行要去加载所需要的dll文件，在程序运行的时候往往会遇到dll找不到的问题，或者不能确定所加载的dll文件是否是自己所需要的dll，遇到dll出问题的时候往往会不知所措，但是一旦知道了dll的加载顺序，按这个去查找解决就会方便和得心应手了。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"程序的运行要去加载所需要的dll文件，在程序运行的时候往往会遇到dll找不到的问题，或者不能确定所加载的dll文件是否是自己所需要的dll，遇到dll出问题的时候往往会不知所措，但是一旦知道了dll的加载顺序，按这个去查找解决就会方便和得心应手了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)先搜索可执行文件所在路径，再搜索系统路径：%PATH%（环境变量所配置的路径）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般Path中的值为：%SystemRoot%\\system32;%SystemRoot%;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2)然后按下列顺序搜索 DLL："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、当前进程的可执行模块所在的目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、当前目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、Windows 系统目录。GetSystemDirectory 函数检索此目录的路径。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、Windows 目录。GetWindowsDirectory 函数检索此目录的路径。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5、PATH 环境变量中列出的目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有时候确定了加载的dll文件确实是自己所想加载的dll文件，但是还会发生错误的可能原因，就是dll文件被损坏，此时需要重新替换现有的dll文件；或者dll文件和所用的头文件（.h文件）不匹配，即是头文件中的函数，在dll文件中没有实现，这样的话，找到对应的dll文件就ok了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"AssemblyLoadContext"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上AssemblyLoadContext是AppDomain的继承者，它提供相同而且更多的功能-除了安全边界（隔离）。最小的安全边界是进程，因此你将需要使用进程间通信来正确隔离数据和代码执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"官网文档中提到Appdomain已经过时了，为了兼容旧的版本，提供了部分功能。建议在.NET Core3.0及更高的版本使用AssemblyLoadContext。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"从AppDomain迁移到AssemblyLoadContext"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也许你仍在应用程序中使用AppDomain。现在，以下代码显示如何用AssemblyLoadContext的相应方法去替换掉AppDomain方法："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取所有程序集"}]}]},{"type":"element","tag":"pre","props":{"code":"var assembliesInAppDomain = AppDomain.CurrentDomain.GetAssemblies();\nvar assembliesInAssemblyLoadContext = AssemblyLoadContext.Default.Assemblies;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var assembliesInAppDomain = AppDomain.CurrentDomain.GetAssemblies();\nvar assembliesInAssemblyLoadContext = AssemblyLoadContext.Default.Assemblies;\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加载一个程序集"}]}]},{"type":"element","tag":"pre","props":{"code":"AppDomain.CurrentDomain.Load(AssemblyName.GetAssemblyName(\"path\"));\nAssemblyLoadContext.Default.LoadFromAssemblyName(AssemblyName.GetAssemblyName(\"path\"));\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AppDomain.CurrentDomain.Load(AssemblyName.GetAssemblyName(\"path\"));\nAssemblyLoadContext.Default.LoadFromAssemblyName(AssemblyName.GetAssemblyName(\"path\"));\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加载一个程序集 路径或者字节数组:"}]}]},{"type":"element","tag":"pre","props":{"code":"AppDomain.CurrentDomain.Load(File.ReadAllBytes(\"path\"));\nAssemblyLoadContext.Default.LoadFromStream(File.OpenRead(\"path\"));// orAssemblyLoadContext.Default.LoadFromAssemblyPath(\"path\");\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AppDomain.CurrentDomain.Load(File.ReadAllBytes(\"path\"));\nAssemblyLoadContext.Default.LoadFromStream(File.OpenRead(\"path\"));// orAssemblyLoadContext.Default.LoadFromAssemblyPath(\"path\");\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试封装的获取程序集方法GetAssemblies"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"准备工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建一个控制台程序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加一个类库项目，命名为AA.Service"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在控制台应用程序，添加一个类TypeFinder代码如下："}]},{"type":"element","tag":"pre","props":{"code":"public class TypeFinder\n    {\n        /// <summary>\n        /// 获取物理路径 \n        /// </summary>\n        /// <returns>\\bin\\Debug\\netcoreapp3.0</returns>\n        public virtual string GetBinDirectory()\n        {\n            return AppContext.BaseDirectory;\n        }\n        /// <summary>\n        /// 获取程序集\n        /// </summary>\n        /// <returns></returns>\n        public IList<Assembly> GetAssemblies()\n        {\n            var binPath = GetBinDirectory();\n            var addedAssemblyNames = new List<string>();\n            var assemblies = new List<Assembly>();\n\n            //\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a=>IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n                addedAssemblyNames.Add(assembly.FullName);\n            }\n\n            foreach (var dllPath in Directory.GetFiles(binPath, \"*.dll\",\n                 SearchOption.TopDirectoryOnly))\n            {\n                try\n                {\n                    var an = AssemblyName.GetAssemblyName(dllPath);\n                    if (!addedAssemblyNames.Contains(an.FullName))\n                    {\n                        AssemblyLoadContext.Default.LoadFromAssemblyName(an);\n                    }\n                }\n                catch (BadImageFormatException ex)\n                {\n                    Trace.TraceError(ex.ToString());\n                }\n            }\n\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a => IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n\n                assemblies.Add(assembly);\n            }\n            return assemblies;\n        }\n\n        /// <summary>\n        /// 排除系统程序集\n        /// </summary>\n        /// <param name=\"assemblyName\"></param>\n        /// <returns></returns>\n        private bool IsNotSysAssembly(string assemblyName) \n        {\n            return !assemblyName.StartsWith(\"Microsoft.\")\n                      && !assemblyName.StartsWith(\"System.\")\n                      && !assemblyName.StartsWith(\"Newtonsoft.\")\n                      && assemblyName != \"netstandard\";\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class TypeFinder\n    {\n        /// <summary>\n        /// 获取物理路径 \n        /// </summary>\n        /// <returns>\\bin\\Debug\\netcoreapp3.0</returns>\n        public virtual string GetBinDirectory()\n        {\n            return AppContext.BaseDirectory;\n        }\n        /// <summary>\n        /// 获取程序集\n        /// </summary>\n        /// <returns></returns>\n        public IList<Assembly> GetAssemblies()\n        {\n            var binPath = GetBinDirectory();\n            var addedAssemblyNames = new List<string>();\n            var assemblies = new List<Assembly>();\n\n            //\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a=>IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n                addedAssemblyNames.Add(assembly.FullName);\n            }\n\n            foreach (var dllPath in Directory.GetFiles(binPath, \"*.dll\",\n                 SearchOption.TopDirectoryOnly))\n            {\n                try\n                {\n                    var an = AssemblyName.GetAssemblyName(dllPath);\n                    if (!addedAssemblyNames.Contains(an.FullName))\n                    {\n                        AssemblyLoadContext.Default.LoadFromAssemblyName(an);\n                    }\n                }\n                catch (BadImageFormatException ex)\n                {\n                    Trace.TraceError(ex.ToString());\n                }\n            }\n\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a => IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n\n                assemblies.Add(assembly);\n            }\n            return assemblies;\n        }\n\n        /// <summary>\n        /// 排除系统程序集\n        /// </summary>\n        /// <param name=\"assemblyName\"></param>\n        /// <returns></returns>\n        private bool IsNotSysAssembly(string assemblyName) \n        {\n            return !assemblyName.StartsWith(\"Microsoft.\")\n                      && !assemblyName.StartsWith(\"System.\")\n                      && !assemblyName.StartsWith(\"Newtonsoft.\")\n                      && assemblyName != \"netstandard\";\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在控制台应用程序添加引用AA.Service类库，生成查看bin文件，出现了AA.Service.dll"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-06-dll-load/640.webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用代码输出(排除系统dll以Microsoft、system开头的)程序集："}]},{"type":"element","tag":"pre","props":{"code":"var assemblies= new TypeFinder().GetAssemblies();        \nforeach (var a in assemblies)             \n{                \nConsole.WriteLine(a.FullName);            \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var assemblies= new TypeFinder().GetAssemblies();        \nforeach (var a in assemblies)             \n{                \nConsole.WriteLine(a.FullName);            \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"输出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-06-dll-load/640.webp"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-01-06-dll-load.md","_source":"content","_file":"dotnet/2020-01-06-dll-load.md","_extension":"md","date":"2020-01-06"},{"_path":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"延迟补偿在C/S架构游戏协议设计和优化中的应用","description":"第一人称角色网络游戏的设计是一项很有挑战性的工作。网络环境下的健壮性，是动作游戏能否成功的一个重要因素。另外，PC上面的开发者需要考虑到玩家层次不齐的机器配置以及网络状况，很多用户的硬件配置跟网络跟当前最好的配置跟网络有一定差距。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"_1综述"},"children":[{"type":"text","value":"1.综述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一人称角色网络游戏的设计是一项很有挑战性的工作。网络环境下的健壮性，是动作游戏能否成功的一个重要因素。另外，PC上面的开发者需要考虑到玩家层次不齐的机器配置以及网络状况，很多用户的硬件配置跟网络跟当前最好的配置跟网络有一定差距。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"宽带网络的出现有利于在线游戏开发，但是开发者还是需要考虑网络延迟和其它网络特性。而且宽带网络在美国被广泛采用还需要一段时间，在世界上其它国家可能需要更长的一段时间。另外，很多宽带网络质量很差，用户虽然偶尔能够享受到高带宽，但更多的时候他们不得不面对高延迟和高丢包率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们应该提供给玩家良好的游戏。本篇文章讨论了如何提供给玩家顶尖的操作体验；介绍了很多在线动作游戏中采用的C/S架构背景。此外，我们还讨论了如何通过一个预测模型来掩饰延迟带来的影响。文章的最后描述了一个叫做延迟补偿的机制，弥补了因为网络质量不好带来的负面影响"}]},{"type":"element","tag":"h1","props":{"id":"_2cs游戏的基本架构"},"children":[{"type":"text","value":"2.C/S游戏的基本架构"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"网络上可玩的大部分动作游戏都是C/S结构游戏基础上修改完成的，比如半条命以及其修改版反恐精英、军团要塞，以及一些基于quake3引擎和虚幻引擎的游戏。这类游戏都有一个用来执行游戏逻辑的服务器以及连接到这个服务器的多个客户端。客户端仅仅是用来接收玩家的操作并发给服务器，服务器对这些操作作出响应，移动玩家周围物体，并将游戏世界的信息发给客户端显示出来。当然世界的游戏系统有更多组件，我们这样简化有利于分析预测和延迟补偿。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于这种考虑，典型的C/S游戏引擎通常看起来是这样的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"General Client / Server Architecture","src":"/images/2020-02-02-Latency_Compensating_Methods_in_ClientServer_In-game_Protocol_Design_and_Optimization/Lagcomp1.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了便于讨论，我们假定客户端跟服务器之间已经建立连接；客户端的每一帧循环如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取帧开始时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采集用户输入"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据模拟时间将移动命令打包发送给服务器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取处理服务器传过来的数据包"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据服务器数据包的内容决定可见物体及其状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"渲染场景"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取帧结束时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"结束时间减去开始时间就是下一帧的模拟时间"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端每完成一个帧循环，就用“frametime”来决定下一帧需要多少时间，如果帧率恒定，“frametime”就是准确的，否则就没办法获得准确的“frametime”（因为在没一帧开始你不可能知道这一帧需要多长时间）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器的循环大同小异："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取帧开始时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"读取客户端发过来的操作信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据客户端操作执行逻辑运算"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采用上一个循环得到的模拟时间来模拟服务器控制的物体移动状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对每一个连接的客户端，发送打包相应的物体/世界状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取帧结束时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"结束时间减去开始时间就是下一帧的模拟时间"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个模型中，非玩家物体完全由服务器控制其状态，每个玩家根据服务器发过来的数据包控制自己的移动。这是一种很自然的方法，当然还有其它的方法也可以完成这个功能。"}]},{"type":"element","tag":"h1","props":{"id":"_3用户消息的内容"},"children":[{"type":"text","value":"3.用户消息的内容"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于half-life引擎的游戏用户消息都很简单，只需要封装在一个包含几个关键成员的结构中："}]},{"type":"element","tag":"pre","props":{"code":"typedef struct usercmd_s\n{\n    // Interpolation time on client\n    short lerp_msec;  \n    // Duration in ms of command\n    byte msec;    \n    // Command view angles.\n    vec3_t viewangles;  \n    // intended velocities\n    // Forward velocity.\n    float forwardmove;  \n    // Sideways velocity.\n    float sidemove;   \n    // Upward velocity.\n    float upmove;  \n    // Attack buttons\n    unsigned short buttons; \n    //\n    // Additional fields omitted...\n    //\n} usercmd_t;\n","language":"c++","meta":"","className":["language-c++"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"typedef struct usercmd_s\n{\n    // Interpolation time on client\n    short lerp_msec;  \n    // Duration in ms of command\n    byte msec;    \n    // Command view angles.\n    vec3_t viewangles;  \n    // intended velocities\n    // Forward velocity.\n    float forwardmove;  \n    // Sideways velocity.\n    float sidemove;   \n    // Upward velocity.\n    float upmove;  \n    // Attack buttons\n    unsigned short buttons; \n    //\n    // Additional fields omitted...\n    //\n} usercmd_t;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结构中最关键的变量时msec,viewangles,forward,side,upmove和buttons。msec表示这个命令执行对应的毫秒数（也就是上面提到的“frametime”）。viewangles是一个三维向量，表示玩家的朝向。forward,side和upmove表示玩家是否通过键盘、鼠标或控制杆控制移动。最后，buttons这个字段包含一个或多个比特，标志玩家是否按着某些按键。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于C/S架构的游戏采用以上数据结构运行如下：客户端创建命令并发送到服务器，服务器响应这些命令并把更新了的世界和物体位置信息发回客户端，客户端收到以后进行渲染。这种方式非常简单，但是在实际应用中效果差强人意，用户会感觉到网络连接带来的明显延迟。这主要是由于客户端完全没有逻辑操作，发出消息以后就等待服务器响应。如果客户端跟服务器有500ms的延迟，客户端执行了操作到看到操作的结果就需要500ms，这种延迟在局域网通常可以接受（因为通常延迟比较小），但在因特网上是没法接受的"}]},{"type":"element","tag":"h1","props":{"id":"_4客户端预测"},"children":[{"type":"text","value":"4.客户端预测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有一种方法可以改善这种情况：客户端本地即时执行移动操作，假定服务器即时通知客户端可以执行操作，这种方法可以称为客户端预测。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用客户端运动预测以后，客户端就不再是一个“小型客户端”，不再单单响应服务器命令；但也不是说客户端可以像没有中央服务器的p2p游戏完全自治。服务器仍然在运行并保证在客户端跟服务器运行结果不一致的情况下纠正客户端错误的模拟。由于网络延迟，修正在一个网络传输周期以后才会执行，这个时候纠正信息通常已经过期，这样会导致明显的位置漂移，因为客户端收到的修正信息是过去某个时间的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了使客户端运动预测有效，我们采用以下方法：还是客户端采样并生成命令发送到服务器，但是每个包含生成时间的命令在客户端本地存起来并在预测算法中使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"预测的过程中，我们把服务器确认的移动信息作为开始，这样客户端就可以确定服务器执行上次命令以后游戏中玩家的准确信息（比如位置）。如果网络有延迟，这个确认命令也会有一定延迟。假设客户端运行帧率为50fps，网络延时为100ms，这样在客户端收到服务器的确认命令的时候，本地命令队列中已经有5条信息，这5条信息被用来执行客户端预测。假设执行完全预测【1】客户端在收到来自服务器的最新信息后，就开始按照与服务器相同的逻辑执行本地消息队列中的5个命令。这些命令执行以后得到当前状态（最重要的是位置），然后根据玩家的状态信息渲染当前帧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在半条命这个游戏中，客户端跟服务器采用相同的代码来计算移动，这样可以减小客户端预测跟服务器之间的误差。这些代码位于HLSDK中的pm_shared/（意思是“player movement shared”）。这段代码的输入是玩家操作和客户端的初始状态，输出是玩家操作以后的状态。客户端算法大致如下："}]},{"type":"element","tag":"pre","props":{"code":"\"from state\" <- state after last user command acknowledged by the server;\n\n\"command\" <- first command after last user command acknowledged by server;\n\nwhile (true)\n{\n    run \"command\" on \"from state\" to generate \"to state\";\n    if (this was the most up to date \"command\")\n    break;\n\n    \"from state\" = \"to state\";\n    \"command\" = next \"command\";\n};\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\"from state\" <- state after last user command acknowledged by the server;\n\n\"command\" <- first command after last user command acknowledged by server;\n\nwhile (true)\n{\n    run \"command\" on \"from state\" to generate \"to state\";\n    if (this was the most up to date \"command\")\n    break;\n\n    \"from state\" = \"to state\";\n    \"command\" = next \"command\";\n};\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"玩家的初始状态和预测结果用来渲染场景。命令的执行过程就是：将玩家状态复制到共享数据结构中，执行玩家操作（执行hlsdk中pm_shared中的共用代码），然后将结果复制到目标状态（to state）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个系统中有几个需要注意的地方，首先，由于网络延迟，客户端又在不停地以一定速度（客户端帧率）生成命令，一个命令通常会被客户端多次执行，知道得到服务器的确定以后将其从命令列表中删除（这就是半条命中的滑动窗口）。首先要考虑的是如何处理共享代码中生成的声效和动画效果。因为命令可能会被多次执行，预测位置的过程被多次执行的时候要注意避免重声等不正确的效果。另外，服务器也要避免客户端意见预测的效果。然而，客户端必须重新运行旧的命令，否则就没法根据服务器来纠正客户端的预测错误。解决方法很简单：客户端将没有执行的客户端命令进行标记，如果这些命令在客户端第一次执行，则播放相应的效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外需要注意的是服务器不处理，只有客户端才有的一些数据；如果没有这种类型的数据，我们可以如上面所述，以服务器第一条消息作为起点进行预测得到下一帧状态（包括用来渲染的位置信息）。然而，如果有些逻辑是纯客户端的，服务器不会处理（比如玩家蹲下来眼睛的位置-然而这也不是纯客户端信息，因为服务器也会处理这个数据），这种情况下我们需要将预测的中间结果存起来。可以用一个滑动窗口完成这项工作，其中“开始状态”是开始，以后每次执行一个玩家命令预测完成后，填写窗口中的下一个状态；当服务器通知某个命令被接受并执行以后，从窗口中查找服务器处理的是哪条命令并将相应的数据传到下一个帧的“起始状态”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"到此为止，我们描述了客户端的运动预测。quakeworld2中采用了这种类型的预测"}]},{"type":"element","tag":"h1","props":{"id":"_5开火过程中的客户端预测"},"children":[{"type":"text","value":"5.开火过程中的客户端预测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面描述的系统可以很自然地用于武器开火效果预测。客户端玩家需要记录一些状态，比如身上有哪些武器，正在使用的是哪一个，每把武器都还剩多少弹药。有了这些信息，开火逻辑可以建立在运动逻辑上面，只需要在客户端和服务器使用的命令里面加上玩家开火的按键信息。在半条命中，为了简单，武器开火逻辑代码也跟运动代码一样也作为“共享代码”。所有会影响到武器状态的变量，比如弹药、下次可开火时间、正在播放那个武器动画，都作为服务器的状态，这些状态会通知给客户端用来预测武器状态。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端武器开火预测包括预测武器切换、部署、手枪皮套。这样，玩家会感觉游戏中的移动和武器状态100%受他控制。这在减小网络延迟给玩家带来的不爽上面迈出了一大步。"}]},{"type":"element","tag":"h1","props":{"id":"_6一些工作"},"children":[{"type":"text","value":"6.一些工作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器需要将必要的字段发给客户端，并且处理很多中间状态，有人可能有这样的疑问，为什么不把服务器逻辑取消，让客户端广播自己的位置，也就是将所有的移动、开火逻辑放在客户端。这样，客户端就会给服务器发送类似这样的结果报告：“我在X位置，我爆了玩家2的脑袋”。如果客户端可信的话，这样做是可以的，很多军方仿真系统就是这样做的（他们是一个封闭系统，所有客户端都可信）。点对点的游戏也是这么做的。对于半条命来说不可以这样做，因为客户端可能“欺骗”服务器。如果我们以这种方法封装状态数据，就会诱导玩家破解客户端【3】。对于我们的游戏来说这样做奉献太大，我们还是选择采用服务器模式来做校验。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端进行运动和武器效果预测是非常可行的。例如quake3就支持这样的预测。这个系统需要注意一点，在判断目标的时候需要考虑到延迟（比如即时射击武器）。换句话说，虽然你看到自己用\\即时\\武器进行了射击，你自己的位置也是最新的，射击结果仍然跟延迟有关。例如，如果你射击一个玩家，这个玩家沿与你实现垂直的方向奔跑，假设你客户端延迟为100ms，玩家奔跑速度是500单位每秒，这样你需要瞄准玩家前方50单位才能准确击中。延迟越大，就需要更大的提前量。靠感觉弥补延迟太困难了。为了减轻这种效果，quake3对你的射击播放一个短音来进行确定。这样，玩家可以算出快速发射武器的时候需要多大的提前量，同时调整提前量直到听到稳定的音调串。如果延迟比较大，而你的对手又在不断躲避，就很难获得足够的反馈判断。如果延迟也不断变化，就更难了。"}]},{"type":"element","tag":"h1","props":{"id":"_7目标的显示"},"children":[{"type":"text","value":"7.目标的显示"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"影响玩家游戏体验的另一个重要方面是客户端如何渲染其它玩家。两种基本的判断机制是：外推法和内插法【4】"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"外推法把其它玩家/物体看作一个点，这个点开始的位置、方向、速度已知，沿着自己的弹道向前移动。因此，假设延时是100ms，最新的协议通知客户端这个玩家奔跑速度是500单位每秒，方向垂直于玩家视线，客户端就可以假设事实上这个玩家当前实际的位置已经向前移动了50个单位。客户端可以在这个外推的位置渲染这个玩家，这样本地玩家就差不多可以正确瞄准。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"外推法的最大缺点是玩家的移动并不是完全弹道的，而是不确定的并且高\"jerk\"【5】。大部分FPS游戏采用非现实的玩家系统，玩家可以随时转弯，可以在任意角度作用不现实的加速度，因此外推法得到的结果经常是错误地。开发者可以通过限制外推时间来减轻外推误差（比如quake限制不能超过100ms）。这种限制使得在客户端收到玩家正确位置以后，纠错不至于太大。当前大部分玩家的网络延迟高于150ms，玩家必须对游戏中的其他玩家进行外推以便正确击中。如果别的玩家因为外推错误，被服务器拉回，游戏体验将非常差。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一种方法叫插值法。插值法可以这样理解：客户端物体实际移动位置总是滞后一段时间。举个例子，如果服务器每秒同步10次世界信息，客户端渲染的时候会有100ms滞后。这样，每一帧渲染的时候，我们通过最新收到的位置信息和前100ms的位置信息（或者上一帧渲染位置）进行差值得到结果。我们每收到一个物体位置的更新信息，（每秒10个更新意味着每100ms收到一个更新）接下来的100ms我们就可以朝这个新的位置移动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一个更新包没有收到，有2种处理方法：第一、用上面介绍的外推法（有可能产生较大误差）；第二、保持玩家位于当前位置直到收到下一个更新包（会导致玩家移动顿挫）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内插法的大致过程如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个更新包包含生成的服务器时间戳【6】"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据客户端当前时间，客户端通过减去时间差（100ms）计算 一个目标时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果计算得到的目标时间在上一个更新时间和上上个更新时间之间，这些时间戳可以决定目标时间在过去的时间间隙中的情况"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"目标时间情况用来通过插值计算结果（如位置、角度）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面提到的插值法，本质上是客户端缓存了接下来100ms的数据。对于每一个周围的玩家，他们都位于过去某个时间的位置，根据每一个具体的时间点进行插值。如果偶尔发生丢包，我们就将插值时间延长到200ms。这样我们就可以忽略一次更新（假设同步频率还是10次每秒），玩家还可以移动到合理的目标位置，这样进行插值通常不会有什么问题。当然，插值多少时间需要权衡，因为这种方法是用延时（玩家更难击中）来换取平滑。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，上述插值方法（客户端通过2个更新信息插值并且朝最新更新位置移动）需要服务器更新信息间隔固定。对于所谓的“视觉效果因素”，这种方式很难处理，“视觉效果因素”是这样的：假设我们插值的物体是弹球（这种模型可以准确描述某些玩家）。极端情况下，球或者在空中，或者正在碰地板。然而，通常情况下球在这两种状态之间。如果我们只插值上一个位置，这个位置可能既不在地面上，也不是最高点，这样，弹球弹的效果就被平滑掉了，好像永远没有弹到地面一样。这是一个经典问题，增加采样率可以减轻这种影响，但是仍然有可能我们采样不到球在地面的点跟最高点，这些点会给平滑掉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，不同用户网络状况不同，强迫每个用户都以固定速度更新（比如每秒10次）效果不是很好，在半条命中，用户每秒可以请求任意数量的更新包（没有限制）。这样，高速网络用户可以每秒更新50次，只要用户愿意。半条命的默认设置是每秒每个用户（以及游戏中其它物体）发送20次更新，以100ms为时间窗口进行插值。【7】"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了避免“反弹球\"平滑问题，我们在插值的过程中采用了一个不同的算法，这种算法中我们对每一个可能插值的物体记录了一个完整的“历史位置”信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"历史位置信息记录了物体的时间戳、远点、角度（以及其它我们需要插值计算的数据）。我们每收到一个服务器的更新，我们就创建一条包含时间戳的记录，其中包含原始位置、角度信息。在插值过程中，我们用上面的方法计算目标时间，然后搜索位置历史信息，找到包含目标时间的记录区间。然后用找到的信息插值计算当前帧的位置。这样我们就可以平滑跟踪到包含所有采样点的曲线。如果客户端帧率比服务器更新频率大，我们就可以将采样点平滑处理，减小上面提到的平滑处理带来的问题（当然没法避免，因为采用频率限制，而世界本身是连续的）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是，上面提到的插值方法使用的时候，物体有时候会被服务器拉回，而不是快速移动。当然我们也可以平滑地将物体移动一段较长的距离，这样看起来物体移动很快。更新的过程中我们可以设一个标志表示不插值或清除历史记录，或者如果起始点与目标点距离过长，我们就认为数据不正常。这种情况我们就将物体直接拉过去。并以这个位置为起始点进行插值。"}]},{"type":"element","tag":"h1","props":{"id":"_8延迟补偿"},"children":[{"type":"text","value":"8.延迟补偿"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"插值也会带来延迟，所以考虑延迟补偿的过程中需要理解插值过程。玩家看到的别的物体是经过插值计算出来的，所以插值过程中需要考虑在服务器上玩家的目标是否正确。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"延迟补偿是服务器执行的一种策略，当服务器收到客户端命令并执行的过程中，根据客户端的具体情况进行归一。延迟补偿可以看做服务器处理用户命令的时候回退一段时间，退到客户端发送命令时候的准确时间。算法流程如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器执行客户端命令之前执行以下操作："},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"计算玩家正确的延迟"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对每个玩家，从服务器历史信息中找到发送给玩家信息和收到玩家响应的信息。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于每一个玩家，将其拉回到这个更新时间（插值得到的精确时间）中执行用户命令。这个回退时间需要考虑到命令执行的时候的网络延时和插值量【8】"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行玩家命令（包括武器开火等。）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将所有移动的、错位的玩家移动到他们当前正确位置。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：我们把时间往后推算的时候，需要考虑那个时候玩家的状态，比如玩家是或者还是已经已经死掉，玩家是否处于躲避状态。执行运动补偿以后，玩家就可以直接瞄准目标进行设计，而不需要计算一个提前量。当然，这种方案是游戏中的权衡设计。"}]},{"type":"element","tag":"h1","props":{"id":"_9游戏涉及中延迟补偿的使用"},"children":[{"type":"text","value":"9.游戏涉及中延迟补偿的使用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用延迟补偿以后，每个玩家游戏的过程中感觉不到明显延迟。在这里需要理解可能会产生一些矛盾和不一致。当然，验证服务器和无逻辑的客户端老系统也会有自相矛盾的情况。最后，这个这种事游戏设计决定的。对于半条命，我们相信采用延迟补偿是正确的游戏决定。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"老系统的一个问题是，由于网络延迟，目标需要有一个提前量。瞄准敌人进行射击几乎总是不能击中。这种不一致导致射击很不真实，响应也不可控制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用延迟补偿以后带来的是另一种形式的不一致。对于大部分玩家，他们只需要专注于得到更多的射击技能来武装他们（当然他们也是需要瞄准的）。延时补偿使得玩家只需要直接瞄准他的目标并按下开火按钮即可（对于即时击中武器【9】）。不一致也时有发生，但是是在击中以后。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，如果一个延时比较大的玩家击中一个延时比较小的玩家并且得到一分，低延时的玩家会感觉高延时玩家“在角落里被击中”【10】。这种情况下，低延迟玩家可能已经从角落里冲出，而高延时玩家看到的是过去的信息。每一个有延迟的玩家都有一个朝向别的玩家的直的视线，直的视线指向一个瞄准点然后开火。这个时候，低延时的玩家可能已经跑到角落里并且蹲在一个箱子后面，如果高延迟玩家延迟比较大，比如500ms，这是经常发生的；这样当高延时玩家的命令传到服务器的时候，已经隐藏起来的玩家需要取一个历史位置并计算是否击中，在这种极端情况下，低延时玩家会觉得他再角落里被击中了。然而，对于高延时玩家来说，他是正对着别的玩家开火的。从游戏设计的角度来讲，我们需要这样决定：让每个玩家即时与世界交互并开火。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此外，在正常战斗中，上面提到的不一致并不明显。对于第一人称射击游戏，有两种典型情况。第一、考虑两个玩家直线跑向对方并且开火；这种情况下，延时补偿只会把玩家在移动直线上往后拉。被击中的玩家看他的射击者在前方，这样就不会有“子弹拐到角落里”的情况发生。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二种情况是两个玩家中的一个射击，另外一个玩家在垂直于第一个玩家视线的方向冲锋。这种情况下的解决问题的原理与刚才不同。刚才提到的冲锋的玩家视野差不多是90°（至少第一人称射击游戏是这样），因此，这个玩家看不到正在射击他的那个人。因此他被击中也不会感觉奇怪或者错误（谁让你在空旷区域狂奔呢，活该）。当然，如果你开发的是一个坦克游戏，或者在你的游戏中玩家朝一个方向跑的时候可以看到别的方向，错误可能就会比较明显，你可能发现玩家设计方向不对。"}]},{"type":"element","tag":"h1","props":{"id":"_10总结"},"children":[{"type":"text","value":"10.总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"延迟补偿是当前动作游戏改善延迟影响的一种方法。是否采用这种方法取决于游戏设计者，因为如何设计直接影响到游戏的体验。对于把那条命、军团要塞、cs这样的游戏，延迟补偿所带来的效果提升显著大于其带来的错误。"}]},{"type":"element","tag":"h1","props":{"id":"脚注"},"children":[{"type":"text","value":"脚注"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【1】在半条命引擎中，预测的过程中允许一定的延迟，但不能容忍实际网络延迟这么大的延迟。通过调整参数，我们可以控制预测过程中的延迟，这个参数pushlatency是一个负数，以毫秒为单位表示预测过程中的延迟。如果这个值大于（绝对值）实际网络延迟，这时预测就是完全的预测（译注：客户端服务器完全同步）。这种情况下玩家感觉不到任何延迟。实际应用中，一些人错误地认为参数pushlatency应该设为实际网络延迟的一半，这种情况下玩家移动仍然有网络延迟一半的延迟（感觉类似于冰面移动）。基于这个原因，实际应用总应该总是采用完全预测，pushlatency这个变量应该从半条命引擎中移除"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【2】"},{"type":"element","tag":"a","props":{"href":"http://www.quakeforge.net/files/q1source.zip","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.quakeforge.net/files/q1source.zip"}]},{"type":"text","value":" (Return)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【3】关于作弊和反作弊的问题超出了本篇文章讨论的范围"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【4】虽然混合纠正方法也可以使用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【5】“jerk”用来度量使玩家改变加速度的作用的快慢"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【6】本文假设计算连接延时的时候客户端与服务器完全同步，也就是说，每次更新的时候客户端收到服务器发过来的时间被直接当做客户端的时间使用。这样，客户端跟服务器完全匹配，只是客户端稍微晚一点（晚多少取决于延时多少）。平滑客户端时钟差值可以有很多方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【7】更新时间间隔没必要是固定的。因为对于剧烈运动的游戏，如果带宽不够，很有可能客户端发过来的数据超过了处理能力。如果采用固定更新间隔，在发完一个更新包以后就需要等待一个固定更新周期时间以后再发下一个包。这种逻辑不能很好地使用带宽。因此，服务器发给每个客户端数据包以后，应该自己决定下一个包什么时候发，决定的依据是用户的带宽、用户设置的每秒更新频率。如果用户要求更新20次每秒，那么需要等待50ms以后下个更新包才能发送。如果激活了带宽限制（而服务器帧率又足够高），我们可能就需要等待比如61ms（或其他值）以后发送下一个更新包。因此，半条命游戏数据包发送间隔是随机的。基于服务器的这种情况，将启动点作为一个变量，移动到最新目标点进行插值这种方法效果欠佳。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【8】半条命代码中usercmd_t结构中变量lerp_msec前面描述过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【9】对于发射导弹的武器，延迟补偿有更多需要解决的问题。假如\\导弹是由服务器处理的，那么导弹应该位于哪个时间区间？每次导弹准备发射的时候，是否需要把每个玩家往后拉一段时间的？如果是这样，那么需要往后拉多少？这些问题是需要考虑的。在半条命中，为了避免这种问题，我们对导弹不进行延迟补偿（这并不意味着客户端不进行声音预测，只是实际的导弹不进行延迟补偿）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"【10】用户社区通常采用这种情况来描述不一致性。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization","rel":["nofollow"]},"children":[{"type":"text","value":"https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-Latency_Compensating_Methods_in_ClientServer_In-game_Protocol_Design_and_Optimization.md","_source":"content","_file":"dotnet/2020-02-02-Latency_Compensating_Methods_in_ClientServer_In-game_Protocol_Design_and_Optimization.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-latency_compensating-rtt","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"延迟补偿和对时的相关总结","description":"国内的网络游戏多是客户端/服务器方式，而对于游戏实时性要求比较高的网游，如 果采用客户端发送时间包给服务器，服务器校验后再下发给客户端表现的话，网络延时 和抖动都会恶化游戏体验。对于客户端和服务器的同步问题， 一般有两种算法解决：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"国内的网络游戏多是客户端/服务器方式，而对于游戏实时性要求比较高的网游，如 果采用客户端发送时间包给服务器，服务器校验后再下发给客户端表现的话，网络延时 和抖动都会恶化游戏体验。对于客户端和服务器的同步问题， 一般有两种算法解决："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"① 、客户端和服务器之间进行对时后，客户端发送数据包给服务器，服务器根据收 到的客户端数据包先后进行排序，先到达的服务器端的事件包被判定为先发生，后到达 服务器的事件包被判定为后发生。在此情况下，往往网络延时较大的客户端先发送了游 戏事件包，但由于网络延时和抖动的影响，后到达服务器，而被判定为后发生时间，这 样对该客户端就不公平了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"② 、客户端和服务器进行对时后，客户端预测服务器收到客户端数据包的时间，并 把该时间写入数据包中发送给服务器，在网络抖动比较大的情况下，这种情况可以保证一定的公平性。但是还是出现了上述的情况，网络延时大的数据包预测的到达时间也就 更晚，依然会出现先发生的事件被服务器判定为后发生，同样不能保证游戏的公平性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，在现有的解决网络实时性较差问题的技术方案中，当采用TimeWarp同步机制 时，则需要保存数量较多的快照，同时也会使回滚的次数较多，导致过多的消耗内存和 CPU资源，以及降低游戏体验；对于国内网络游戏采用的网络时间同步机制，无论服务器 根据客户端数据包到达的时间进行排序，或客户端预测服务器收到客户端数据包的时间 并把该时间写入数据包中发送给服务器，对于网络延时越大的玩家同样会降低游戏体 验。"}]},{"type":"element","tag":"h2","props":{"id":"网络对时"},"children":[{"type":"text","value":"网络对时"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大部分的强交互网游会做对时, 使 client 和 server 保持时间基本一致."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-02-Latency_Compensating-rtt/iyeruicpsm.png"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"client 带上本地时间 t0 向 server 发送对时请求."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"server 回复当前自己的系统时间 t1."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"client ack 收到 server 回复时的本地时间 t2."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果只有 client 关心对时结果, 这时可以优化到"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"只做1,2步甚至只做第2步"}]},{"type":"text","value":", 相当于 client 主动发起 ping;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样, 如果只有 server 关心对时结果, sever 主动发起 ping (第2,3步)即可."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单次对时往往会受到网络波动的影响, 所以一般还需要做多次统计一个比较合理的时间偏移."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"网络对时, 一般在进游戏之初做. 如果在游戏过程中发现有网络波动过大的情况(在下行协议包中带上 server 的时间, 很容易检查到提前或者滞后), 也需要重新发起对时."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"考虑到反外挂(比如加速齿轮, 或者减速器)的因素, server 端需要对主动发起的client对时请求做一些安全校验, 例如时间递增, 是否满足阈值等等."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"光从对时的角度来看, UDP 协议比 TCP 更合适一些, 不过取决于项目需要."}]},{"type":"element","tag":"h2","props":{"id":"服务器和客户端时间差算法-st0st2-2ct12"},"children":[{"type":"text","value":"服务器和客户端时间差算法 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"(st0+st2-2ct1)/2"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200221152318844","src":"/images/2020-02-02-Latency_Compensating-rtt/image-20200221152318844.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"两种理解方式"},"children":[{"type":"text","value":"两种理解方式"}]},{"type":"element","tag":"h4","props":{"id":"第一种方式"},"children":[{"type":"text","value":"第一种方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ct1-st0 = &0 +(ct1-st1) "}]},{"type":"text","value":"  延迟+ 时间差(同一时刻下客户端减去服务端的时间差)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"st2-ct1 = &1+(st2-ct2)"}]},{"type":"text","value":"  延迟+ 时间差(同一时刻下服务端减去客户端的时间差)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们需要的就是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"st2-ct2"}]},{"type":"text","value":" 由上可以转换为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"-(ct1-st1) = st2-ct2"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现假设 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"o = st2-ct2 "}]},{"type":"text","value":"同时假设延迟相等 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p = &0 = &1"}]}]},{"type":"element","tag":"pre","props":{"code":"ct1-st0 = p - o\n\nst2-ct1 = p + o\n\nct1-st0-st2+ct1 = -2o\n\no =(st0+st2-2ct1)/2\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ct1-st0 = p - o\n\nst2-ct1 = p + o\n\nct1-st0-st2+ct1 = -2o\n\no =(st0+st2-2ct1)/2\n"}]}]},{"type":"element","tag":"h4","props":{"id":"第二种方式"},"children":[{"type":"text","value":"第二种方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&0 = &1 = (st2-st0)/2 "}]},{"type":"text","value":"    我们知道"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(st2-st0)/2"}]},{"type":"text","value":"是单次延迟 即"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"st2-ct1 = &1+(st2-ct2)"}]},{"type":"text","value":"  延迟+ 时间差(同一时刻下服务端减去客户端的时间差)"}]},{"type":"element","tag":"pre","props":{"code":" st2-ct1 = (st2-st0)/2 + o\n\n 2st2-2ct1 = st2-st0 + 2o\n\n o = (st0+st2-2ct1)/2\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" st2-ct1 = (st2-st0)/2 + o\n\n 2st2-2ct1 = st2-st0 + 2o\n\n o = (st0+st2-2ct1)/2\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://patents.google.com/patent/CN101577715A/zh","rel":["nofollow"]},"children":[{"type":"text","value":"https://patents.google.com/patent/CN101577715A/zh"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器获得服务器与客户端的时间差值后，与服务器接收到来自客户端的数据包的时间做差值可以获得客户端在游 戏过程中实际向服务器发送数据包的时间，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"并通过客户端在游戏过程 中实际向服务器发送数据包的时间来判定在游戏时间中事件发生的实际顺序"}]},{"type":"text","value":"， 从而较好的保持了游戏的公平性，提高了游戏玩家的游戏体验。"}]},{"type":"element","tag":"h4","props":{"id":"检查安全性"},"children":[{"type":"text","value":"检查安全性"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"第一次连接的对时..时差不该查过三分钟."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"校验包客户端有没有修改时间,能够求得发包的时间,对比服务器接收到包的时间以及延迟"}]}]},{"type":"element","tag":"h2","props":{"id":"移动的延迟补偿"},"children":[{"type":"text","value":"移动的延迟补偿."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用了客户端预测的话,客户端的移动位置要优先于服务端的,因为有来回两次延迟.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于状态同步以服务端为准,使用服务器校对不会出什么问题."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以这里的补偿是补偿从客户端到服务端这段延迟."}]},{"type":"element","tag":"pre","props":{"code":"public class move\n{\n    DatetimeOffset clientTime\n}\nvar o = xxx;//服务端和客户端的时间差\nvar startMoveTime =   move.clientTime+o;\nvar delay = DateTimeOffset.Now()-startMoveTime;//延迟时间\n\n//todo:将延迟时间参与到pos的计算当中\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class move\n{\n    DatetimeOffset clientTime\n}\nvar o = xxx;//服务端和客户端的时间差\nvar startMoveTime =   move.clientTime+o;\nvar delay = DateTimeOffset.Now()-startMoveTime;//延迟时间\n\n//todo:将延迟时间参与到pos的计算当中\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用了服务器校对不补偿也并没有什么太大的问题,因为最终仍然是以服务器为准的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是补偿了之后减少了延迟,会更平缓一点."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://patents.google.com/patent/CN102404279A/zh","rel":["nofollow"]},"children":[{"type":"text","value":"https://patents.google.com/patent/CN102404279A/zh"}]}]},{"type":"element","tag":"h2","props":{"id":"boss攻击的延迟补偿"},"children":[{"type":"text","value":"boss攻击的延迟补偿."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200221164609309","src":"/images/2020-02-02-Latency_Compensating-rtt/image-20200221164609309.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"玩家ct2的时候开始移动,但是服务器收到的时候已经是st4"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而服务器st2的时候boss发动了攻击.这个时候.玩家在服务器的位置是在ct3"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要boss把攻击作为关键事件...直到客户端有ct4事件出来时再执行st2,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以使用时间轮算法触发关键事件"}]},{"type":"element","tag":"h2","props":{"id":"玩家-的延迟补偿"},"children":[{"type":"text","value":"玩家 的延迟补偿"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是由于客户端使用了插值算法造成的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如fps游戏,玩家看到的敌人的位置永远是过去的,当你开枪的时候,那个人其实已不在那个位置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以需要记录游戏的世界状态..找到子弹打出时那一刻的世界状态.然后判定"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://patents.google.com/patent/CN102739608A/zh","rel":["nofollow"]},"children":[{"type":"text","value":"https://patents.google.com/patent/CN102739608A/zh"}]}]},{"type":"element","tag":"h2","props":{"id":"一些模拟恶劣网络环境工具"},"children":[{"type":"text","value":"一些模拟恶劣网络环境工具"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://jagt.github.io/clumsy/cn/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://jagt.github.io/clumsy/cn/index.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"网络对时","depth":2,"text":"网络对时"},{"id":"服务器和客户端时间差算法-st0st2-2ct12","depth":2,"text":"服务器和客户端时间差算法 (st0+st2-2ct1)/2","children":[{"id":"两种理解方式","depth":3,"text":"两种理解方式"}]},{"id":"移动的延迟补偿","depth":2,"text":"移动的延迟补偿."},{"id":"boss攻击的延迟补偿","depth":2,"text":"boss攻击的延迟补偿."},{"id":"玩家-的延迟补偿","depth":2,"text":"玩家 的延迟补偿"},{"id":"一些模拟恶劣网络环境工具","depth":2,"text":"一些模拟恶劣网络环境工具"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-Latency_Compensating-rtt.md","_source":"content","_file":"dotnet/2020-02-02-Latency_Compensating-rtt.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-net-sync-client-server-game-architecture","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"快节奏多人游戏同步(1)-ClientServer架构","description":"PART 1 概述本文是关于探索快节奏多人游戏的技术和算法系列的第一篇，因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论。。。任何类型的游戏开发都是某种挑战，然而在多人游戏中我们还有更多全新的问题函待解决～最最 Interesting 的地方在于其核心问题其实是人类和物理！- - 好吧其实是作弊和地理限制造成的网络延时。。PART 2 反作弊所有的一切的起源都是作弊。作为一个游戏开发者，你一般不会去担心有人在你的单人游戏中去作弊 - 因为他的行为不会给其他人带来影响，一个作弊的玩家可能并不会按你设计的套路去进行游戏，但是游戏是他的，他们有权利去选择怎","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"part-1-概述"},"children":[{"type":"text","value":"PART 1 概述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文是关于探索快节奏多人游戏的技术和算法系列的第一篇，因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论。。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任何类型的游戏开发都是某种挑战，然而在多人游戏中我们还有更多全新的问题函待解决～最最 Interesting 的地方在于其核心问题其实是人类和物理！- - 好吧其实是作弊和地理限制造成的网络延时。。"}]},{"type":"element","tag":"h2","props":{"id":"part-2-反作弊"},"children":[{"type":"text","value":"PART 2 反作弊"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有的一切的起源都是作弊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作为一个游戏开发者，你一般不会去担心有人在你的单人游戏中去作弊 - 因为他的行为不会给其他人带来影响，一个作弊的玩家可能并不会按你设计的套路去进行游戏，但是游戏是他的，他们有权利去选择怎么去玩。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多人游戏则不同。在任何的有竞争关系的游戏中，一个作弊玩家不仅仅给自己带来了更好的体验，他也毁了其他的玩家的游戏。作为开发者，你可能希望避免出现这样的情况，因为这会让玩家流失。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了防止作弊，有很多事可以去做，但是最重要最（可能也是唯一有意义的）的事非常简单：不要相信玩家。就做最坏的打算：所有玩家都想要作弊。"}]},{"type":"element","tag":"h2","props":{"id":"part-3-权威服务器和静默客户端"},"children":[{"type":"text","value":"PART 3 权威服务器和静默客户端"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有一个非常简单的解决方案 - 你将游戏中所有的逻辑都放在你控制的服务器来做，而客户端只是游戏的旁观者，换句话说，你游戏的客户端把输入（按键，命令）发送到服务器，服务器来运行这个游戏，然后你把结果返回给客户端。这就是常说的权威服务器，因为游戏世界中发生的一切都在服务器中进行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然，你的服务器还是可能被发现漏洞，但是这就不属于我们要谈论的范围了。使用权威服务器可以防止很多的漏洞，比如，服务器不信任玩家的在客户端的血量，客户端想要作弊，把本地的血量调到10000%，但服务器知道血量只有10% - 当玩家被攻击的时候它还是会死掉，不管客户端的血量是多少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器同样不信任玩家的位置。你可能会这样做，在这一秒你告诉服务器“我在（10，10）”，然而下一秒你告诉服务器“我在（20，10）”，这样就可以穿过一堵墙或者超快速的移动。但是，权威服务器知道玩家在（10，10），当客户端告知服务器他要往右动一格的时候，客户端的位置会由服务器来处理，将位置更新为（11，10），然后告知玩家“你在（11，10）”。如下图所示:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"A simple client-server interaction.","src":"/images/2020-02-02-client-server-game-architecture/fpm1-01.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总的来说，游戏的状态由服务器独自管理。客户端将动作发送给服务器，服务器来周期性地更新游戏状态，然后将新的游戏状态发送给客户端，客户端对结果进行渲染呈现。。"}]},{"type":"element","tag":"h2","props":{"id":"part-4-考虑网络问题"},"children":[{"type":"text","value":"PART 4 考虑网络问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的处理方式对于回合制的游戏非常适合，比如策略游戏或者棋牌类的游戏。它在LAN中也能工作的很好，在这种情况下，通信是瞬发的。但是对于一些对实时性要求很高的游戏，而且在internet环境中，这种解决方案就会出问题了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面来谈一些物理的问题。假如你在旧金山，连接了一个在纽约的服务器，两地相距4000km或者2500英里（大概是里斯本到莫斯科的距离）。任何东西都不能比光快吧，即使是Internet上的数据（数据传播的底层可能是光的脉冲，线缆中的电子，或者是电磁波），光传播的速度大概是300000km/s，所以传播4000km需要13ms。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这听起来可能很快，但这实际是最乐观的情况 - 假设数据传播的速度是光速，沿着直线传播，这些通常是不可能的。在真实情况下，数据是由无数个路由经过一系列的跳（在计算机网络里的属于叫做hops）进行传播的，而且大部分的传播速度都达不到光速；路由在传播的时候也会产生一些延迟，因为包必须被打包，检查和分发。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以保险起见，我们假设数据从客户端到服务器需要50ms，这接近最好的场景了 - 当你在纽约而服务器在东京呢？假设网络因为什么原因发生阻塞了呢？100ms，200ms，500ms的延迟也是有可能的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回到我们的例子，你的客户端将输入“我按下了向右的按键”发给服务器，服务器在50ms之后获取了数据，现在假设服务器能够立即响应并且将结果返回，那么客户端在50ms之后获得新的游戏状态“你现在在（1，0）”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从你的视角来看，情况是这样的：你按下了向右的按键，但是什么事都没发生，直到一百年后你的角色向右移动了一格。这样的延迟是显而易见的，当然延迟半秒不仅仅是显而易见，它让整个游戏没法玩了。"}]},{"type":"element","tag":"h2","props":{"id":"part-5-总结"},"children":[{"type":"text","value":"PART 5 总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过网络连接的多人游戏是超级有趣的，但是引入了一系列的难题和挑战。权威服务器架构能够防止很多的作弊，但是直接用这种方法会让游戏的响应变得迟缓。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在下面的文章，我们会介绍我们怎么围绕权威服务器来建立一个系统，能够最小的减少玩家的延迟体验，就像在玩单机游戏一样顺畅。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gabrielgambetta.com/client-server-game-architecture.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gabrielgambetta.com/client-server-game-architecture.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"part-1-概述","depth":2,"text":"PART 1 概述"},{"id":"part-2-反作弊","depth":2,"text":"PART 2 反作弊"},{"id":"part-3-权威服务器和静默客户端","depth":2,"text":"PART 3 权威服务器和静默客户端"},{"id":"part-4-考虑网络问题","depth":2,"text":"PART 4 考虑网络问题"},{"id":"part-5-总结","depth":2,"text":"PART 5 总结"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-net-sync-client-server-game-architecture.md","_source":"content","_file":"dotnet/2020-02-02-net-sync-client-server-game-architecture.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"快节奏多人游戏同步(2)-客户端预测与服务器校对","description":"PART 1 概述在第一篇文章中，我们介绍了一种权威服务器的C-S模型，在这种模型中，客户端只将输入发送到服务器中，当收到来自服务器的游戏状态更新的时候再将结果渲染出来。单纯地依赖这种模型会导致玩家输入命令和画面更新之间的延迟感，比如，当玩家按下向右的按钮，然后玩家等了半秒钟才开始移动，因为首先客户端需要把输入传给服务器，然后服务器处理了出入之后计算出新的游戏状态，然后再将新的游戏状态传回给客户端。在实际的网络环境中，延迟可能会达到零点几秒，这时游戏就有点感觉延迟了，最坏的情况是直接没法玩了。在这篇文章中，我们将找到减小这种延迟感的方法，甚至能够消除这种延迟。PART 2 客户端预测虽然存在着","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"part-1-概述"},"children":[{"type":"text","value":"PART 1 概述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在第一篇文章中，我们介绍了一种权威服务器的C-S模型，在这种模型中，客户端只将输入发送到服务器中，当收到来自服务器的游戏状态更新的时候再将结果渲染出来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单纯地依赖这种模型会导致玩家输入命令和画面更新之间的延迟感，比如，当玩家按下向右的按钮，然后玩家等了半秒钟才开始移动，因为首先客户端需要把输入传给服务器，然后服务器处理了出入之后计算出新的游戏状态，然后再将新的游戏状态传回给客户端。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Effect of network delays.","src":"/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-01.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在实际的网络环境中，延迟可能会达到零点几秒，这时游戏就有点感觉延迟了，最坏的情况是直接没法玩了。在这篇文章中，我们将找到减小这种延迟感的方法，甚至能够消除这种延迟。"}]},{"type":"element","tag":"h2","props":{"id":"part-2-客户端预测"},"children":[{"type":"text","value":"PART 2 客户端预测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然存在着作弊的玩家，但是大部分时候服务器是处理有效访问的（来自非作弊玩家的），这也意味着服务器收到大部分的输入都是有效的，而且游戏状态的更新也是按照预期的，也即是说：如果你的角色在（10，10），然后方向键右被按下了，那么你的角色就会移动到（11，10）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以利用这一点，如果游戏世界的确定性足够（给定一个游戏状态和一些列的输入，得到的结果是完全可预测的）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在假设有100ms的延迟，角色移动一格需要花费100ms，使用之前说的实现方式，那么整个动作完成需要花费200ms:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Network delay + animation.","src":"/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-02.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为游戏世界是确定的，我们假设传送到服务器的输入都能够成功执行。在这种假设下，客户端能够预测游戏世界在接受输入后的状态，并且绝大部分情况下，结果是正确的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与之前说的将客户端的输入发送到客户端然后等待服务器的响应再在客户端做出反应，我们可以将两者同时进行，即当在发送输入信息的时候，就当作它们已经正确执行，通常服务器返回的结果和客户端的执行的结果是一致的:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Animation plays while the server confirms the action.","src":"/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-03.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在玩家输入和运行结果之间就没有任何延迟存在了，同时服务器还是权威服务器。（如果有作弊的客户端发送无用的消息，他可以把角色放在他想要的任何地方，但这并不会影响到服务器，也就是其他玩家也不会受到他的影响）。"}]},{"type":"element","tag":"h2","props":{"id":"part-3-同步问题"},"children":[{"type":"text","value":"PART 3 同步问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在上面的例子里，我选用了一些比较特例的数字来让所有事情看起都很完美，现在假设另一种情况，假设现在服务器延时250ms，移动一格花费100ms，现在玩家按了两下方向键右，想要往右移动两格。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用之前我们说的技术，情况如下图所示"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Predicted state and authoritative state mismatch.","src":"/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-04.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"于是我们在 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"t = 250 ms"}]},{"type":"text","value":" 的时候就会面临一个非常 interesting 的问题，当接收到新的游戏状态时，客户端预测的位置已经到达 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"x = 12"}]},{"type":"text","value":"，但是服务器认为最新的坐标是 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"x = 11"}]},{"type":"text","value":"，因为权威服务器的缘故，客户端必须将角色移回 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"x = 11"}]},{"type":"text","value":"，但是紧接着，新的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"x = 12"}]},{"type":"text","value":" 的状态在 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"t = 350"}]},{"type":"text","value":" 的时间到达，因此角色的位置又顺移回去了。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从玩家的角度来看，他按下两次向右按钮后，角色向右移动两格，原地停留50ms后，向左顺移一格，又原地停留100ms再向右顺移一格，很明显这种情况令人难以接受。"}]},{"type":"element","tag":"h2","props":{"id":"part-4-服务器校对"},"children":[{"type":"text","value":"PART 4 服务器校对"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决上面说的问题的办法就是你得意识到，客户端所看到的世界是当前的，但是因为延迟，客户端得到的游戏状态都是过去的，当服务器在发送更新的时候，它并没有把客户端发来的所有的命令都处理掉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这并不是一个非常严重的问题，首先，客户端在每次请求的时候加上一个编号，在我们的例子中，第一次按键请求编号为 #1，第二次按键的请求编号为 #2。服务器回复的时候将其处理过最后一个请求的编号包含在消息中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Client-side prediction + server reconciliation.","src":"/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-05.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当t = 250的时候，服务器说“基于#1的输入请求，你的位置是11”.因为服务器是权威的，所以角色的位置是x=11， 现在假设客户端保存了一份发送到服务器的请求，基于新的游戏状态，它知道服务器已经处理了请求 #1，所以他将这个备份丢弃掉，但是客户端知道服务器还需要将#2请求的回复发过来，所以再一次进行客户端预测，客户端可以基于上次服务器发来的状态和#2输入来计算当前的状态。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以当t=250ms的时候，客户端得到“经过#1的输入之后，x=11”，它将#1输入的拷贝丢弃掉，但是还有一份并没有得到服务器返回的#2的拷贝，客户端将内部游戏状态更新为服务器所发来的游戏状态，也就是x=11，然后将所有未收到回复但已经发送给服务器的输入用于预测，在上面的例子，输入就是向右移动，最终状态就是x=12，这是正确的。当t=350的时候，一个新的游戏状态从服务器获得；这种情况它说“基于#2输入，x=12”。在这是，客户端将#2请求之前的请求都丢弃，然后将游戏状态更新为x=12，没有需要预测的输入，所以不需要预测，现在得到的结果都是正确的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端具体如何处理，这里有一个统一的处理方式："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据server的new state更新#1里的缓存状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"回滚input到#1，将#1之后的所有缓存的操作都应用到#1的new state中进行计算，得到最新的结果"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端根据最新的结果进行更新"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将#1的状态和input 从缓存buffer里删除"}]}]},{"type":"element","tag":"h2","props":{"id":"part-5-误差"},"children":[{"type":"text","value":"PART 5 误差"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面讨论的例子里只讨论了移动，但是这个方法在其他方面也可以使用。比如，在一个回合制的游戏里，当玩家攻击其他玩家的时候，你可以播放飙血的特效和伤害值，但是你不应该在收到服务器回复之前直接更新玩家的血量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为游戏状态的复杂性，它并不能保证是绝对可逆的，你也许希望只有再收到服务器确认的时候才将一个玩家杀死，即使这个玩家的血量降到负的了。（但假象一种情况，一个玩家实际上已经死了，但是在没有收到服务器确认之前他使用了药包，这个时候你该怎么处理？）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这又带来了一个有趣的问题，即使世界是绝对的确定的，并且没有玩家在作弊，还是有客户端的预测和服务器不吻合的情况。上面说的情况在单人游戏中不会出现，但是在多人接入同一个服务器的时候就会发生，这个问题会在下面的文章中进行讨论。"}]},{"type":"element","tag":"h2","props":{"id":"part-6-总结"},"children":[{"type":"text","value":"PART 6 总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当使用权威服务器的时候，你需要给玩家即时的响应，即使是当在等待服务器处理出入。为了达到这样的目的，客户端模拟出输入的结果，当收到服务器的回复时，客户端的游戏状态需要通过服务器的回复和还未处理的输入进行重新计算。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"part-1-概述","depth":2,"text":"PART 1 概述"},{"id":"part-2-客户端预测","depth":2,"text":"PART 2 客户端预测"},{"id":"part-3-同步问题","depth":2,"text":"PART 3 同步问题"},{"id":"part-4-服务器校对","depth":2,"text":"PART 4 服务器校对"},{"id":"part-5-误差","depth":2,"text":"PART 5 误差"},{"id":"part-6-总结","depth":2,"text":"PART 6 总结"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-net-sync-client-side-prediction-and-server-reconciliation.md","_source":"content","_file":"dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-net-sync-entity-interpolation","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"快节奏多人游戏同步(3)-Entity插值","description":"PART 1 概述在本系列的「第一篇文章」中，我们介绍了关于权威服务器及其反作弊特性，然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题。在「第二篇文章」中，我们提出了「客户端预测」的方案来克服这个困难。以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下，可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术。在本文中，我们将会讨论在在同一台服务器上有「其他玩家控制的角色」的情况。PART 2 服务器 time step在之前的文章中，我们的服务器的实现非常简单，它负责处理客户端的输入并更新游戏状态，最后将结果发送回客户端。如果有多个玩家在一起玩，那服务端主循","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"part-1-概述"},"children":[{"type":"text","value":"PART 1 概述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在本系列的「第一篇文章」中，我们介绍了关于权威服务器及其反作弊特性，然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题。在「第二篇文章」中，我们提出了「客户端预测」的方案来克服这个困难。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下，可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在本文中，我们将会讨论在在同一台服务器上有「其他玩家控制的角色」的情况。"}]},{"type":"element","tag":"h2","props":{"id":"part-2-服务器-time-step"},"children":[{"type":"text","value":"PART 2 服务器 time step"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在之前的文章中，我们的服务器的实现非常简单，它负责处理客户端的输入并更新游戏状态，最后将结果发送回客户端。如果有多个玩家在一起玩，那服务端主循环的逻辑有所不同了。\n在接下来的场景中，几个客户端玩家会同时发送数据，玩家发出操作指令会非常频繁（高APM的玩家，一秒钟可能发出10个以上的操作指令），如果服务端每收到某个玩家的一条指令，就去执行input逻辑，然后广播游戏状态，这样的性能是非常差的，会消耗很多的cpu和bandwidth。\n一个更好的办法是，利用一个queue，将客户端的输入信息缓存起来，在服务端，游戏状态以一定的频率(例如100ms一次)进行更新，每次更新的时间间隔(100ms)，就被称之为time step。\n在每个更新循环迭代中，服务端处理queue里面所有的input，然后逐个进行计算，将最后计算的结果更新到所有客户端。\n总体来说，整个游戏世界的更新和客户端的输入频率、数量是相对独立的，它的更新频率也是可控的。"}]},{"type":"element","tag":"h2","props":{"id":"part-3-低频更新处理"},"children":[{"type":"text","value":"PART 3 低频更新处理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从客户端来看，这个方法运行的很平滑，客户端的预测行为独立于服务端的更新，所以它依然可以使用预测技术。不过，由于真个游戏世界的状态以一个比较低的频率进行更新，那么本地客户端对其他玩家知道的信息就很少了，信息越少的话，其他玩家的行为动作要模拟的话，就不会很准确。\n本地客户端收到其他玩家更新坐标的消息，如何进行处理呢，有一个最简单的办法就是，每次直接使用收到的坐标进行更新，但这样看起来会有抖动，每100ms更新一次坐标，就得抖动一次，如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Client 1 as seen by Client 2.","src":"/images/2020-02-02-net-sync-entity-interpolation/fpm3-01.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对Client2来说，Client1的位置最开始再p(10,10)，不一会直接跳到p(11,10)，100ms后又跳到(12,0)，这样的体验是很差的。那么，如何改善游戏体验呢？ 针对不同的游戏，有不同的处理方式，一般来说，客户端的行为越方便预测，就越容易做平滑处理。"}]},{"type":"element","tag":"h2","props":{"id":"part-4-航位推测法"},"children":[{"type":"text","value":"PART 4 航位推测法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设你在玩赛车游戏。一辆速度非常快的汽车是可以预测的——例如，如果它以每秒100米的速度行驶，一秒钟后，它将比它开始行驶的地方提前大约100米。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么是大约呢？在那一秒内，汽车可能加速或减速了一点，或者向右或向左转了一点——这里的关键词是“一点”。汽车的机动性是这样的：在高速行驶时，无论玩家实际做什么，其在任何时间点的位置都高度依赖于其先前的位置、速度和方向。换句话说，赛车不能立即进行180度转弯。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于每100毫秒发送一次更新的服务器，这是如何工作的？客户端接收到服务器发送来的每个其他车的速度和行驶方向；在接下来的100毫秒内，它不会接收到任何新信息，但仍需要显示它们的运行情况。要做的最简单的事情是假设汽车的航向和加速度在100毫秒内保持不变，并使用该参数在本地运行汽车物理。然后，100毫秒后，当服务器更新到达时，汽车的位置被修正。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据许多因素，校正可以是大的或相对小的。如果玩家把车保持在直线上，并且不改变车速，那么预测的位置将与修正的位置完全相同。另一方面，如果玩家撞到什么东西，预测的位置将是非常错误的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请注意，推算定位可以应用于低速情况，例如战列舰。实际上，“dead reckoning”一词起源于航海。"}]},{"type":"element","tag":"h2","props":{"id":"part-5-实体插值"},"children":[{"type":"text","value":"PART 5 实体插值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有许多情况航位推是没法处理的 - 对于玩家的方向和速度可以瞬间改变的都不行，比如3D射击，玩家经常快速跑动，停下，快速转向等，在这种情况下，航位推算法就非常无力了。因为位置和速度和前面的数据无关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以选择在接到服务器的请求的时候直接更新玩家的位置，而客户端看到的就是网上其他的玩家每100ms跳一下，感觉会非常奇怪。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你现在拥有的是每100ms由服务器传送过来的权威数据，现在要做的是如何在这100ms内让网络角色看起来非常自然，解决问题的关键就是将网络玩家显示在过去的某个时刻。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Client 2 renders Client 1 in the past, interpolating last known positions.","src":"/images/2020-02-02-net-sync-entity-interpolation/fpm3-02.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用来插值的t=900和t=1000的数据依赖于游戏。插值通常都可以处理得很好。如果不是这种方法，你可能需要服务器发送更加详细的移动信息了 - 比如更多的位置采样点，或者每10ms发送一次(你不必发十倍的数据 - 因为你发的微小的位移数据，在这种情况下数据的格式可以很好的优化一下)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当使用这种技术的时候，每一个玩家都和游戏世界有一点点不同步，因为每个玩家看到自己的世界是当前的，但是其他的玩家都是过去的。但即使是快速的游戏，这100ms的延迟都不是那么明显。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有一种情况除外 - 当你需要时间和空间的准确性的时候，比如一个玩家射击另一个玩家的时候，因为其他的玩家都是存在于过去的某个时候，你的瞄准其实是有100ms的延迟的 - 也就是说，你设计的目标是100ms的某个目标！ 这个问题我们下一篇会进行讨论。"}]},{"type":"element","tag":"h2","props":{"id":"part-6-总结"},"children":[{"type":"text","value":"PART 6 总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在权威服务器的环境中，有着不确定的服务器更新和网络延迟，在这种情况下你还要给玩家平滑的移动。在第二篇中，我们展示了一种客户端预测和服务器调和的技术，来实现实时的角色控制，这样的方案让玩家能够得到即时的反馈，移除了致命的延迟。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其他玩家的同步还是一个问题，但是，在这篇文章中，我们提出了两种解决方案。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一种是航位推技术，这种模拟需要entity的位置能够通过前一个时候的位置，速度，加速度来推算出来，当不满足这种情况的时候，航位推就没用了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二种是插值技术，不预测将来的位置，只是使用服务器传来的数据，这种就会造成显示的entity总是过去的某个时刻。最后的结果就是玩家的角色总是当前时刻，而其他看到的entity都是过去的某个时刻，这种情况可以产生一种难以置信的无缝体验。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是，当游戏需要高速离散的准确性的时候，比如射击或者移动物体，美景就破灭了：你看其他玩家的位置和服务器的位置不一致，别的玩家看你的位置也不是正确的，这样爆头就不可能发生了！很多游戏都有爆头这一说，我们将在下面的文章中来讨论这个问题。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gabrielgambetta.com/entity-interpolation.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gabrielgambetta.com/entity-interpolation.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"part-1-概述","depth":2,"text":"PART 1 概述"},{"id":"part-2-服务器-time-step","depth":2,"text":"PART 2 服务器 time step"},{"id":"part-3-低频更新处理","depth":2,"text":"PART 3 低频更新处理"},{"id":"part-4-航位推测法","depth":2,"text":"PART 4 航位推测法"},{"id":"part-5-实体插值","depth":2,"text":"PART 5 实体插值"},{"id":"part-6-总结","depth":2,"text":"PART 6 总结"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-net-sync-entity-interpolation.md","_source":"content","_file":"dotnet/2020-02-02-net-sync-entity-interpolation.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-net-sync-lag-compensation","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"快节奏多人游戏同步(4)-延时补偿","description":"PART 1 概述之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些：服务器从客户端收到带有时间戳的输入信息；服务器处理输入并且更新世界状态；服务器向所有客户端发送游戏世界的快照客户端发送输入并且模拟游戏的结果；客户端获取世界更新将自身预测的状态和服务器发送来的状态进行同步；将其他客户端控制的实体插值到过去的状态从玩家的角度来看，以上行为会导致两个重要的结果：玩家看到 自己 处于 现在玩家看到 其他玩家 处于 过去这其实并没有什么大不了的问题，但是对于时间和空间非常敏感的事件就会造成很大的问题；比如在射击游戏中爆掉敌人的头！PART 2 延时补偿假设你正","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"part-1-概述"},"children":[{"type":"text","value":"PART 1 概述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器从客户端收到带有时间戳的输入信息；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器处理输入并且更新世界状态；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器向所有客户端发送游戏世界的快照"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端发送输入并且模拟游戏的结果；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端获取世界更新"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将自身预测的状态和服务器发送来的状态进行同步；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将其他客户端控制的实体插值到过去的状态"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从玩家的角度来看，以上行为会导致两个重要的结果："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"玩家看到 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"自己"}]},{"type":"text","value":" 处于 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"现在"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"玩家看到 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"其他玩家"}]},{"type":"text","value":" 处于 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"过去"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这其实并没有什么大不了的问题，但是对于时间和空间非常敏感的事件就会造成很大的问题；比如在射击游戏中爆掉敌人的头！"}]},{"type":"element","tag":"h2","props":{"id":"part-2-延时补偿"},"children":[{"type":"text","value":"PART 2 延时补偿"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设你正用狙击枪完美的瞄准目标的头部，此时射击绝对万无一失。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然而却没打到。。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么会发生这种事情。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为我们之前解释过的 client-server 架构，你瞄准的是 100ms 之前的玩家的头，而不是开枪的时候的玩家的头。。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在某种程度上相当于你在一个光速非常非常慢的宇宙中进行游戏，你瞄准的是敌人过去的位置，当你扣下扳机的时候他早就走远了。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比较幸运的是有一个相对简单的解决方案，对几乎所有的玩家都是友好的，下面来解释一下它的工作流程："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开火的时候，客户端发送开火指令到服务器，同时包含开火的一瞬间确切的时间和方向。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这是关键的一步。由于服务器获取所有带有时间戳的输入，因此它可以在过去的任何时刻重构世界。特别是，它可以在任何时间点按照任何客户端眼中的样子重建世界。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这意味着服务器可以准确地知道你开枪的那一刻你的武器瞄准了什么。这是你的敌人过去的头部位置，但服务器知道这是他的头部在你当前客户端所在的位置。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器在该时间点处理快照，并更新客户端。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"于是皆大欢喜～"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器很开心是因为他是服务器，他永远都很开心。。。哦好冷啊"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你很开心是因为你瞄准目标头部并射击，完成了一记漂亮的爆头"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你的敌人可能是唯一不完全开心的哪个，如果他站在原地被你爆头那就是他的问题，但是如果他在移动的话，只能说明你是特别厉害的狙击手。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是如果他在掩体附近，然后移动到掩体内部的安全位置后才被命中了呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好吧这的确有可能发生，但这就是你要为此付出的代价，因为你可以射击「过去的他」，他可能在进入掩体后几毫秒被射击。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从某种程度上来说这是不公平的，但这是大家接受程度最高的解决方案了，明明瞄准开枪最后却 miss 问题更大～"}]},{"type":"element","tag":"h2","props":{"id":"part-3-总结"},"children":[{"type":"text","value":"PART 3 总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这篇文章是快节奏多人游戏同步这个系列的最后一篇了，虽然这类问题很难得到完美解答，但是对相关概念有了清晰理解以后再看也并不是那么困难。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然本文的读者都是游戏开发者，但依然有着另一部分读者对此很感兴趣，那就是玩家们。对玩家来说去理解诸如此类问题依然是一件很有趣的事情。"}]},{"type":"element","tag":"h3","props":{"id":"扩展阅读"},"children":[{"type":"text","value":"扩展阅读"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是一些参考资料包括文章和源码之类的，可以帮助大家更方便的理解相关概念。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与本文相关性最高的文章如下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gabrielgambetta.com/lag-compensation.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gabrielgambetta.com/lag-compensation.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gabrielgambetta.com/client-side-prediction-live-demo.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gabrielgambetta.com/client-side-prediction-live-demo.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/","rel":["nofollow"]},"children":[{"type":"text","value":"What Every Programmer Needs to Know About Game Networking"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization","rel":["nofollow"]},"children":[{"type":"text","value":"Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.springer.com/article/10.1007/s00530-012-0271-3#Sec17","rel":["nofollow"]},"children":[{"type":"text","value":"https://link.springer.com/article/10.1007/s00530-012-0271-3#Sec17"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/search?l=C%23&q=lag+compensation&type=Repositories","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/search?l=C%23&q=lag+compensation&type=Repositories"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/search?l=C%23&p=1&q=Fast-Paced+Multiplayer&type=Repositories","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/search?l=C%23&p=1&q=Fast-Paced+Multiplayer&type=Repositories"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/JoaoBorks/unity-fastpacedmultiplayer","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/JoaoBorks/unity-fastpacedmultiplayer"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/gamestdio/timeline","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/gamestdio/timeline"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"part-1-概述","depth":2,"text":"PART 1 概述"},{"id":"part-2-延时补偿","depth":2,"text":"PART 2 延时补偿"},{"id":"part-3-总结","depth":2,"text":"PART 3 总结","children":[{"id":"扩展阅读","depth":3,"text":"扩展阅读"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-net-sync-lag-compensation.md","_source":"content","_file":"dotnet/2020-02-02-net-sync-lag-compensation.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"守望先锋等FPS游戏的网络同步","description":"在一个采用C/S架构的游戏中，客户端和服务端的游戏状态有差异是不可避免的。客户端和服务端各自都维护了一份游戏状态。这两份游戏状态依赖网络包通信保持同步。但由于各客户端到服务端的时延具有不确定性，游戏状态同步变得非常困难。通常服务端在游戏拓扑中承载的是状态仲裁者的角色，客户端玩家看到的“经验证”的有效游戏状态总是延后于服务端的游戏状态。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在一个采用C/S架构的游戏中，客户端和服务端的游戏状态有差异是不可避免的。客户端和服务端各自都维护了一份游戏状态。这两份游戏状态依赖网络包通信保持同步。但由于各客户端到服务端的时延具有不确定性，游戏状态同步变得非常困难。通常服务端在游戏拓扑中承载的是状态仲裁者的角色，客户端玩家看到的“经验证”的有效游戏状态总是延后于服务端的游戏状态。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"网络时延是必然存在的，所以游戏状态的不同步也是必然存在的。但我们可以通过技术手段尽量减轻不同步问题对用户体验带来的影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技术术语："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Latency"}]},{"type":"text","value":"：Latency指的是数据包从客户端发送到服务端再收到服务端回包所用的时间，通常被称为RTT。虽然单程的数据包传输时间并不总是等于RTT/2，但是简单起见我们可以认为两者是相等的。下文说到Latency都是说一个RTT时间，单程Latency则是指RTT/2。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"80年代有个工具叫ping使用ICMP echo测试延迟，所以人们常把RTT和ping联系起来。ping这个指令现在还在用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hit Box"}]},{"type":"text","value":"：角色的3D模型代表了哪些区域是参与到“命中”计算的。你看不到hit box，你只能看到模型。hit box可能比模型大，也可能比模型小，也有可能很不精确，这都取决于具体的实现。我们知道，tick rate会影响命中判定，但是hit box不精确可能对玩家在是否命中方面的感受影响更大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Tick Rate"}]},{"type":"text","value":"：Tick Rate指游戏服务端更新游戏状态的频率。单位是hertz。如果服务器的Tick Rate是64，这就意味着服务端每秒钟最多向客户端发送64次数据包。这些同步数据包包括了游戏状态更新，比如player和场景对象位置等。一次tick的长度就是其持续时间，单位为ms。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如，64 rate时tick长度是15.6ms，20 rate时是50ms，10 rate时是100ms"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Client Update Rate"}]},{"type":"text","value":"：这是客户端接收服务端更新的频率。比如说，如果client update rate是20，而服务器tick rate是64，那么从体验上来说，这个客户端实际是在和一个tick rate为20的服务器联机。通常这个是配在客户端本地的，也有可能是写死的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Framerate"}]},{"type":"text","value":"：这个是指客户端每秒最多可以渲染多少帧，通常被称为FPS"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"6）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Refresh Rate"}]},{"type":"text","value":"：显示设备每秒钟刷新多少次。单位为hertz。如果framerate是30，一个显示频率为60的设备将把每个画面显示两次。反过来，如果framerate是120，但是显示频率为60，那么显示设备只能显示每秒60帧。显示设备的频率比framerate大，提升framerate才有意义。大多数显示设备频率是60或120。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"7）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Interpolation"}]},{"type":"text","value":"：这是一种平滑场景对象移动的技术。实际上内插值所做的就是在场景对象的两个位置之间做插值，以让运动过程平滑。插值延迟通常是2tick，也不尽然。举个内插值的例子，如果一个玩家沿着一条直线移动，在tick1的时候位置在0.5m，在tick2的时候位置在1m，内插值的作用就是让客户端看起来是平滑的从0.5m移到1m。但是服务器实际看到的是离散的位置，要么在0.5m或1m，不可能在中间的某个位置。如果没有插值，游戏的抖动将非常明显，特别是在从服务端更新了一个运动对象的位置后。内插值只在客户端做，实际上减慢了将整个游戏状态绘制到屏幕上的速率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"8）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Extrapolation"}]},{"type":"text","value":"：这是客户端补偿延迟的另一种技术。客户端将场景对象的位置做外插值，这样就不会导致绘制的时候没有更新到新数据。通常优先使用内插值，特别是FPS游戏，因为玩家的移动是不可预期的，外插值的结果可能通常是错的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"9）"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Lag Compensation"}]},{"type":"text","value":"：延迟补偿是服务端减小客户端延迟影响的一种方法。如果没有延迟补偿，或者延迟补偿做的不好，由于客户端看到的是经过延迟后的游戏状态，玩家要命中目标就必须使用一些预判技巧。实际上，延迟补偿所做的，就是当服务器从客户端收到操作（比如开枪）后，将操作发生时间往回调一个单向时延的时间。服务端游戏状态和客户端游戏状态的时间差异（也被称为\"Client Delay\"）可用下式给出："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ClientDelay = (1/2 * Latency) + InterpolationDelay"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"延迟补偿的实际操作步骤："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Player A看到Player B向一个角落跑去"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Player A开枪，其客户端把这个操作发送给服务器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"假定A的延迟的一半是Xms，那么Xms后服务器将收到Player A的操作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器从记录的历史信息中找到A开枪时B所在的位置。一般情况下，服务器应该往回看 (Xms + Player A's interpolation delay) 来回滚到A开枪时的游戏状态。但是这个时间是可以调的，取决于开发者希望延迟补偿算法如何工作。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务器判定这次的开枪是否命中。如果子弹的轨迹和目标模型的hit box相交，就认为是命中了。在这个例子中，我们假定命中了。在Player B看来，他觉得自己已经躲到墙后面了。但是Player B看到的游戏状态所处的时间和Server认定的开枪时间是有差异的，可以表示为：\n(1/2 * PlayerALatency + 1/2 * PlayerBLatency + TimeSinceLastTick)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在下一次tick中，服务器使用计算结果更新所有客户端：Player A看到自己命中了目标，Player B看到自己掉血或挂掉了。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是，如果两个玩家对射，而且都命中了，游戏如何处理就取决于实现了。比如说在CS中，如果先收到的射击操作命中了目标玩家，那么后续收到的那个玩家的射击就会被丢弃。这样就避免了两个玩家的射击请求在同一帧，然后都命中，都挂掉。在Overwatch中，这种情况是可能的。这里是有取舍的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照CS的做法，网络较好的玩家是有很大优势的。经常会有“我在挂掉前打中了目标，但是他没死”的情况。你甚至在挂掉前能听到你的枪响和命中的声音，却没对目标造成伤害。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若是在Overwatch中，玩家反应时间的差异对结果影响较小。比如说，如果服务器tick rate是64，若Player A比Player B早15ms射击，那么双方的射击都是在同一个15.6ms tick之内，所以最终结果是双方都命中，都死掉了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果延迟补偿过度，就会出现“我朝目标早前的位置开枪，却还是命中他了”。\n若延迟补偿不足，则会出现“我必须对目标的移动做预判，这样才能命中”。\n服务器做延迟补偿所记录的历史数据应该是有限的，不然高延迟的玩家会明显拖累其他玩家的游戏体验。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Overwatch中，服务端延迟补偿也被称为Favoring the shooter("},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//www.vg247.com/2016/04/05/overwatch-devs-talk-netcode-and-favouring-the-shooter/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.vg247.com/2016/04/05/overwatch-devs-talk-netcode-and-favouring-the-shooter/"}]},{"type":"text","value":", "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//www.pcgamesn.com/overwatch/overwatch-netcode","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.pcgamesn.com/overwatch/overwatch-netcode"}]},{"type":"text","value":")，也就是说，如果你在自己屏幕上瞄准了目标并射击，那么很大概率将命中目标。也有例外情况。比如，若你射击目标的那一刻，目标跳跃躲开了，这时服务器认为目标做了一个完美的闪避，可能会被判断未命中。所以计算命中时并不总是使用射击那一刻的信息。这是为了玩家体验打的补丁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你是要设计一套同步方案，根据设计目的不同可能有不同的方案。公平性、即时反馈、网络流量等都可能是重要的设计目标。可以参考以下因素："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1）网络链接。延迟越低越好。选择一个延迟最低的服务器开始游戏是很重要的。网络上的拥塞程度也会导致网络延迟。延迟补偿可以帮助解决“射击和命中”的问题，但是如果你的网络不好，更多的情况下，你可能会体验到“已经跑到墙后面还是被打中”或者“我先射击但还是死掉了”的情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2）如果你的客户端frame rate很低（只要低于显示设备刷新频率或跟他差不多），会导致感受延迟变大，通常比tick rate带来的问题更严重。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3）尽量使用内插值。大多数游戏使用的内插值间隔是tick间隔的两倍，主要考虑到如果一个数据包丢掉了，玩家的移动中断也不会在屏幕上表现出来。如果网络状况很好，没有丢包，把插值间隔设置为tick间隔是没有问题的。但是如果有丢包，就会导致抖动。比如在CS中，这对体验的影响比把服务端tick rate从20调高到64带来的体验影响更明显。如果这个值设的太低，会导致极大的抖动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4）如果有可能，你应该增加游戏的client update rate来优化体验。其代价是CPU和带宽消耗。对于客户端来说，除非你家的网络带宽非常低，增加CPU和带宽消耗是可以接受的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5）如果你的显示设备刷新率是60hz，那么很有可能你根本感受不到tick rate在64和128会有什么差异，因为由于tick rate差异导致的改变根本无法通过你的显示设备体现出来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"6）通常来说，服务端tick rate越高，用户交互就越流畅，也更准确。当然网络同步量也越大。如果我们对比tick rate64（CS比赛）和20（Overwatch Beta服务器宣传的帧率），两者因为帧率差异导致的最大可感受延迟是35ms.平均情况下是17.5ms.大多数人是察觉不到其中的差异的，但是有经验的玩家通常是能感受到的。高的tick rate并不会影响到延迟补偿的工作。所以有时候，你还是会有明明自己已经跑到墙后面了可是还是死了的体验。把tick rate提高到64并不能解决这个问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"7）Responsiveness: 当你按下按键的时候，需要能立刻看到反馈。这对动作游戏和FPS游戏都是非常重要的。有多个因素会影响即时反馈。首先，客户端发送玩家的输入应该是即时的。其次，客户端不等服务端回应就根据玩家的输入做状态预测和插值。在Overwatch中，客户端会维护一个历史纪录用于验证客户端预测的准确性。最后，服务端tick rate也会影响反馈。投射物的模拟也应和玩家做类似处理，并加上飞行时间，让玩家对反馈产生的时间有预期。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"8）处理丢包。在Overwatch中，丢包是通过在客户端加速“命令帧”和在服务端设置命令缓存来解决的("},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and"}]},{"type":"text","value":", "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//www.gad.qq.com/article/detail/28682","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gad.qq.com/article/detail/28682"}]},{"type":"text","value":"). 首先，系统采用确定性模拟技术，将时间量化为“命令帧”。每个命令帧都固定为16毫秒（比赛时是7毫秒）。服务端和客户端模拟都运行在保持同步的时钟和这个量化值之上，保持固定的更新频率。当客户端意识到丢包时，会比约定频率更快的模拟，而服务端则将命令缓冲区增大。客户端发送指令的频率加快，而服务端缓冲变大以容忍更多的丢包。客户端的指令数据包包含了未经服务端确认过的所有指令，这样服务端就有机会在实际模拟并发送确认包前更新缓冲区。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"延迟改进"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"暴雪表示会采用一些技术来改进延迟的情况："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"把网络状况相近的玩家匹配到一起，这样相对公平"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"提供60帧tick的服务器，目前是20帧的服务器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"网络稳定时候，直接使用客户端指令，而不是缓存48ms的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"网络波动时候，回溯加一个上限，比如250ms，不再是无限回溯了"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and","rel":["nofollow"]},"children":[{"type":"text","value":"Overwatch - Gameplay Architecture and Netcode - GDCVault"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://gad.qq.com/article/detail/28682","rel":["nofollow"]},"children":[{"type":"text","value":"《守望先锋》架构设计与网络同步 - GAD"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://gad.qq.com/article/detail/28219","rel":["nofollow"]},"children":[{"type":"text","value":"《守望先锋》中的网络脚本化的武器和技能系统 - GAD"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.gdcvault.com/play/1024653/Networking-Scripted-Weapons-and-Abilities","rel":["nofollow"]},"children":[{"type":"text","value":"Networking Scripted Weapons and Abilities in Overwatch - GDC Vault"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.codingnow.com/2017/06/overwatch_ecs.html","rel":["nofollow"]},"children":[{"type":"text","value":"浅谈《守望先锋》中的 ECS 架构 - 云风的 BLOG"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/25703934","rel":["nofollow"]},"children":[{"type":"text","value":"GDC 2017 技术选荐合辑 - 知乎专栏"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/28825322","rel":["nofollow"]},"children":[{"type":"text","value":"守望先锋等 FPS 游戏的网络同步 - 知乎专栏"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.gamereplays.org/overwatch/portals.php?show=page&name=overwatch-a-guide-to-understanding-netcode","rel":["nofollow"]},"children":[{"type":"text","value":"A guide to understanding netcode - GAMEREPLAYS.ORG"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-overwatch-a-guide-to-understanding-netcode.md","_source":"content","_file":"dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-02-source_multiplayer_networking","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"起源引擎网络同步模型","description":"Source引擎的多人游戏使用基于UDP通信的C/S架构。游戏以服务器逻辑作为世界权威，客户端和服务器通过UDP协议(20~30packet/s）通信。客户端从服务器接收信息并基于当前世界状态渲染画面和输出音频。客户端以固定频率发送操作输入到服务器。客户端仅与游戏服务器，而不是彼此之间通信。多人游戏必须处理基于网络消息同步所带来的一系列问题。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Source引擎的多人游戏使用基于UDP通信的C/S架构。游戏以服务器逻辑作为世界权威，客户端和服务器通过UDP协议(20~30packet/s）通信。客户端从服务器接收信息并基于当前世界状态渲染画面和输出音频。客户端以固定频率发送操作输入到服务器。客户端仅与游戏服务器，而不是彼此之间通信。多人游戏必须处理基于网络消息同步所带来的一系列问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"网络的带宽是有限的，所以服务器不能为每一个世界的变化发送新的更新数据包发送到所有客户端。相反，服务器以固定的频率取当前世界状态的快照并广播这些快照到客户端。网络数据包需要一定的时间量的客户端和服务器（RTT的一半）来往。这意味着客户端时间相对服务器时间总是稍有滞后。此外，客户端输入数据包同步到服务器也有一定网络传输时间，所以服务器处理客户端输入也存在延迟的。不同的客户端因为网络带宽和通信线路不同也会存在不同的网络延时。随着服务器和客户端之间的这些网络延迟增大, 网络延迟可能会导致逻辑问题。比如在快节奏的动作游戏中，在几毫秒的延迟甚至就会导致游戏卡顿的感觉，玩家会觉得很难打到对方玩家或运动的物体。此外除了带宽限制和网络延迟还要考虑网络传输中会有消息丢失的情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175512800-299175149.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决网络通信引入的一系列问题，Source引擎在服务器同步时采用了数据压缩和延迟补偿的逻辑，客户端采用了预测运行和插值平滑处理等技术来获得更好的游戏体验。"}]},{"type":"element","tag":"h3","props":{"id":"基本网络模型"},"children":[{"type":"text","value":"基本网络模型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器以一个固定的时间间隔更新模拟游戏世界。默认情况下，时间步长为15ms，以66.66次每秒的频率更新模拟游戏世界，但不同游戏可以指定更新频率。在每个更新周期内服务器处理传入的用户命令，运行物理模拟步，检查游戏规则，并更新所有的对象状态。每一次模拟更新tick之后服务器会决定是否更新当前时间快照以及每个客户端当前是否需更新。较高的tickrate增加了模拟精度，需要服务器和客户端都有更多可用的CPU和带宽资源。客户通常只能提供有限的带宽。在最坏的情况下，玩家的调制解调器连接不能获得超过5-7KB /秒的流量。如果服务器的数据更新发送频率超过了客户端的带宽处理限制，丢包是不可避免的。因此客户端可以通过在控制台设置接受带宽限制，以告诉服务器其收到的带宽容量。这是客户最重要的网络参数，想要获得最佳的游戏体验的话必须正确的设置此参数。客户端可以通过设置cl_updaterate（默认20）来改变获得快照平的频率，但服务器永远不会发送比tickerate更多的更新或超过请求的客户端带宽限制。服务器管理员可以通过sv_minrate和sv_maxrate(byte/s)限制客户端的上行请求频率。当然快照更新同步频率都受到sv_minupdaterate和sv_maxupdaterate（快照/秒）的限制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端使用与服务端tickrate一样的频率采样操作输入创建用户命令。用户命令基本上是当前的键盘和鼠标状态的快照。客户端不会把每个用户命令都立即发送到服务器而是以每秒（通常是30）的速率发送命令包。这意味着两个或更多个用户的命令在同一包内传输。客户可以增加与的cl_cmdrate命令速率。这可以提高响应速度，但需要更多的出口带宽。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏数据使用增量更新压缩来减少网络传输。服务器不会每次都发送一个完整的世界快照，而只会更新自上次确认更新(通过ACK确认)之后所发生的变化（增量快照)。客户端和服务器之间发送的每个包都会带有ACK序列号来跟踪网络数据流。当游戏开始时或客户端在发生非常严重的数据包丢失时, 客户可以要求全额快照同步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用户操作的响应速度(操作到游戏世界中的可视反馈之间的时间)是由很多因素决定的，包括服务器/客户端的CPU负载，更新频率，网络速率和快照更新设置，但主要是由网络包的传输时间确定。从客户端发送命令到服务器响应, 再到客户端接收此命令对应的服务器响应被称为延迟或ping（或RTT）。低延迟在玩多人在线游戏时有显著的优势。客户端本地预测和服务器的延迟补偿技术可以尽量为网络较差的游戏玩家提供相对公平的体验。如果有良好的带宽和CPU可用，可以通过调整网络设置以获得更好的体验, 反之我们建议保持默认设置，因为不正确的更改可能导致负面影响大于实际效益。"}]},{"type":"element","tag":"h3","props":{"id":"enitiy插值平滑"},"children":[{"type":"text","value":"Enitiy插值平滑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常情况下客户端接收每秒约20个快照更新。如果世界中的对象（实体）直接由服务器同步的位置呈现，物体移动和动画会看起来很诡异。网络通信的丢包也将导致明显的毛刺。解决这个问题的关键是要延迟渲染，玩家位置和动画可以在两个最近收到快照之间的连续插值。以每秒20快照为例，一个新的快照更新到达时大约每50毫秒。如果客户端渲染延迟50毫秒，客户端收到一个快照，并在此之前的快照之间内插(Source默认为100毫秒的插补周期)；这样一来，即使一个快照丢失，总是可以在两个有效快照之间进行平滑插值。如下图显示传入世界快照的到达时间："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175529456-2030374817.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在客户端接收到的最后一个快照是在tick 344或10.30秒。客户的时间将继续在此快照的基础上基于客户端的帧率增加。下一个视图帧渲染时间是当前客户端的时间10.32减去0.1秒的画面插值延迟10.20。在我们的例子下一个渲染帧的时间是10.22和所有实体及其动画都可以基于快照340和342做正确的插值处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然我们有一个100毫秒的延迟插值，如果快照342由于丢包缺失，插值可以使用快照340和344来进行平滑处理。如果连续多个快照丢失，插值处理可能表现不会很好，因为插值是基于缓冲区的历史快照进行的。在这种情况下，渲染器会使用外推法（cl_extrapolate 1），并尝试基于其已知的历史，为实体做一个基于目前为止的一个简单线性外推。外推只会快照更新包连续丢失（cl_extrapolate_amount）0.25秒才会触发，因为该预测之后误差将变得太大。实体内会插导致100毫秒默认（cl_interp 0.1）的恒定视图“滞后”，就算你在listenserver（服务器和客户端在同一台机器上）上玩游戏。这并不是说你必须提前预判动画去瞄准射击，因为服务器端的滞后补偿知道客户端实体插值并纠正这个误差。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最近Source引擎的游戏有cl_interp_ratioCVaR的。有了这个，你可以轻松，安全地通过设置cl_interp为0，那么增加的cl_updaterate的值（这同时也会受限于服务器tickrate）来减少插补周期。你可以用net_graph 1检查您的最终线性插值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果打开sv_showhitboxes，你会看到在服务器时间绘制的玩家包围盒，这意味着他们在前进的线性插值时期所呈现的播放器模式。"}]},{"type":"element","tag":"h3","props":{"id":"输入预测"},"children":[{"type":"text","value":"输入预测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们假设一个玩家有150毫秒的网络延迟，并开始前进。前进键被按下的信息被存储在用户命令，并发送至服务器。用户命令是由移动代码逻辑处理，玩家的角色将在游戏世界中向前行走。这个世界状态的变化传送到所有客户端的下一个快照的更新。因此玩家看到自己开始行动的响应会有150毫秒延迟，这种延迟对于高频动作游戏(体育，设计类游戏)会有明显的延迟感。玩家输入和相应的视觉反馈之间的延迟会产生一种奇怪的，不自然的感觉，使得玩家很难移动或精确瞄准。客户端的输入预测（cl_predict 1）执行是一种消除这种延迟的方法，让玩家的行动感到更即时。与其等待服务器来更新自己的位置，在本地客户端只是预测自己的用户命令的结果。因此，客户端准确运行相同的代码和规则服务器将使用来处理用户命令。预测完成后，当地的玩家会移动到新位置，而服务器仍然可以看到他在老地方。150毫秒后，客户会收到包含基于他早期预测用户命令更改服务器的快照。客户端会将预测位置同服务器的位置对比。如果它们是不同的，则发生了预测误差。这表明，在客户端没有关于其他实体的正确信息和环境时，它处理用户命令。然后，客户端必须纠正自己的位置，因为服务器拥有客户端预测最终决定权。如果cl_showerror 1开启，客户端可以看到，当预测误差发生。预测误差校正可以是相当明显的，并且可能导致客户端的视图不规则跳动。通过在一定时间（cl_smoothtime）逐渐纠正这个错误，错误可以顺利解决。预测误差平滑处理可以通过设置cl_smooth 0来关闭。预测只对本地玩家以及那些只收它影响的实体有效，因为预测的工作原理是使用客户端的操作来预测的。对于其他玩家没法做有效预测, 因为没有办法立即从他们身上得到操作信息。"}]},{"type":"element","tag":"h3","props":{"id":"延迟补偿"},"children":[{"type":"text","value":"延迟补偿"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    比方说，一个玩家在10.5s的时刻射击了一个目标。射击信息被打包到用户命令，该命令通过网络的方式发送至服务器。服务器持续模拟游戏世界，目标可能已经移动到一个不同的位置。用户命令到达服务器时间10.6时服务器就无法检测到射击命中，即使玩家已经在目标准确瞄准。这个错误需要由服务器侧进行延迟补偿校正。延迟补偿系统使所有玩家最近位置的历史一秒。如果在执行用户的命令，服务器预计在命令创建什么时间如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"命令执行时间=当前服务器时间 - 数据包延迟 - 客户端查看插值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后服务器会将所有其他玩家回溯到命令执行时的位置，他们在命令执行时间。用户指令被执行，并正确地检测命中。用户命令处理完成后，玩家将会恢复到原来的位置。由于实体插值包含在公式中，可能会导致意外的结果。服务器端可以启用sv_showimpacts 1，显示服务器和客户端射击包围盒位置差异："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175552144-269867355.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"该画面在主机上设置延迟200毫秒(net_fakelag设置)时获取的，射击真实命中玩家。红色命中包围盒显示了客户端那里是100毫秒+插补周期前的目标位置。此后，目标继续向左移动，而用户命令被行进到服务器。用户命令到达后，服务器恢复基于所述估计的命令执行时间目标位置（蓝色击中盒）。服务器回溯演绎，并确认命中（客户端看到流血效果）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为在时间测量精度的误差客户端和服务器命中包围盒不完全匹配。对于快速移动的物体甚至几毫秒的误差也会导致几英寸的误差。多人游戏击中检测不是基于像素的完美匹配，此外基于tickrate模拟的运动物体的速度也有精度的限制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然击中检测服务器上的逻辑如此复杂为什么不把命中检查放在客户端呢？如果在客户端进行命中检查, 玩家位置和像素命中处理检测都可以精准的进行。客户端将只告诉服务器用“打”的消息一直打到什么样的玩家。因为游戏服务器不能信任客户端这种重要决定。因为即使客户端是“干净”的，并通过了Valve反作弊保护，但是报文可以被截获修改然后发送到游戏服务器。这些“作弊代理”可以注入“打”的消息到网络数据包而不被VAC被检测。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"网络延迟和滞后补偿可能会引起真实的世界不可能的逻辑。例如，您可能被你看不到的目标所击中。服务器移到你的命中包围盒时光倒流，你仍然暴露给了攻击者。这种不一致问题不能通过一般化的防范解决，因为相对网络包传输的速度。在现实世界中，因为光传播如此之快，你，每个人都在你身边看到同一个世界，所以你才你没有注意到这个问题。"}]},{"type":"element","tag":"h3","props":{"id":"网络视图net_graph"},"children":[{"type":"text","value":"网络视图NET_Graph"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Source引擎提供了一些工具来检查您的客户端连接速度和质量。使用net_graph 2可以启用相关的视图。下面的曲线图中，第一行显示每秒当前的渲染的帧，您的平均延迟时间，以及的cl_updaterate的当前值。第二行显示在最后进来的数据包（快照），平均传入带宽和每秒接收的数据包的字节大小。第三行显示刚刚传出的数据包（用户命令）相同的数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175609190-66628227.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认的网络设置是专门为通过互联网连接的游戏服务器设计的。可以适用大多数客户机/服务器的硬件和网络配置工作。对于网络游戏，应该在客户端上进行调整，唯一的控制台变量是“rate”，它定义客户端可用的字节/网络连接带宽。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在一个良好的网络环境中，服务器和所有客户端都具有必要的硬件资源可用，可以调整带宽和更新频率设置，来获得更多的游戏精度。增加tickrate通常可以提高运动和射击精度，但会消耗更多的服务器CPU资源。tickrate 100运行的服务器的负载大概是tickrate 66运行时的约1.5倍, 因此如果CPU性能不足可能会导致严重的计算滞后，尤其是在玩家数量比较多的时候。建议对具有更高tickrate超的游戏服务器预留必要的CPU资源。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果游戏服务器使用较高tickrate运行时，客户端可以在带宽可用的情况下增加他们的快照更新率（的cl_updaterate）和用户命令速率（的cl_cmdrate）。快照更新速率由服务器tickrate限制，一台服务器无法发送每个时钟周期的一个以上的更新。因此，对于一个tickrate66服务器，为的cl_updaterate最高的客户价值，将是66。如果你增加快照率遇到，你必须再次打开它。与增加的cl_updaterate你也可以降低画面插值延迟（cl_interp）。默认的插值延迟为0.1秒(默认的cl_updaterate为20) 视图内插延迟会导致移动的玩家会比静止不动的玩家更早发现对方。这种效果是不可避免的，但可以通过减小视图内插值延迟来减小。如果双方玩家正在移动，画面滞后会延迟影响双方玩家,双方玩家都不能获利。快照速率和视图延迟插值之间的关系如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"插补周期= MAX(cl_interp，cl_interp_ratio /cl_updaterate)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以设置cl_interp为0，仍然有插值的安全量。也可以把cl_updaterate增加，进一步降低你的插补周期，但不会超过更新tickrate(66)或客户端的网络处理能力。"}]},{"type":"element","tag":"h3","props":{"id":"tips"},"children":[{"type":"text","value":"Tips"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不要瞎改终端配置除非你完全确定你在干嘛"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    如果客户端和服务器没有足够CPU和网络资源，绝大多数所所谓高性能优化都是起负面作用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不要关闭画面插值和延迟补偿"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    这样并不能代理移动和设计精准度提升"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优化设置可能不会对每个客户端都有效"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果是你是在游戏里或者SourceTv里第一视角观看你看到的画面和玩家可能不一样"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"观战者的画面没有延迟补偿"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking","rel":["nofollow"]},"children":[{"type":"text","value":"https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"基本网络模型","depth":3,"text":"基本网络模型"},{"id":"enitiy插值平滑","depth":3,"text":"Enitiy插值平滑"},{"id":"输入预测","depth":3,"text":"输入预测"},{"id":"延迟补偿","depth":3,"text":"延迟补偿"},{"id":"网络视图net_graph","depth":3,"text":"网络视图NET_Graph"},{"id":"tips","depth":3,"text":"Tips"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-02-Source_Multiplayer_Networking.md","_source":"content","_file":"dotnet/2020-02-02-Source_Multiplayer_Networking.md","_extension":"md","date":"2020-02-02"},{"_path":"/dotnet/2020-02-03-orleans-deployment","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"orleans的部署模式","description":"过去的 10 年里，很多公司都在使用蓝绿部署（发布）来实现热部署，这种部署方式具有安全、可靠的特点。蓝绿部署虽然算不上“ Sliver Bullet”，但确实很实用。\n蓝绿部署是最常见的一种0 downtime部署的方式，是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。蓝绿部署原理上很简单，就是通过冗余来解决问题。通常生产环境需要两组配置（蓝绿配置），一组是active的生产环境的配置（绿配置），一组是inactive的配置（蓝绿配置）。用户访问的时候，只会让用户访问active的服务器集群。在绿色环境（active）运行当前生产环境中的应用，也就是旧版本应用version1。当你想要升级到version2 ，在蓝色环境（inactive）中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。随后需要监测新版本应用，也就是version2 是否有故障和异常。如果运行良好，就可以删除version1 使用的资源。如果运行出现了问题，可以通过负载均衡器指向快速回滚到绿色环境。\n蓝绿部署的优点：\n这种方式的好处在你可以始终很放心的去部署inactive环境，如果出错并不影响生产环境的服务，如果切换后出现问题，也可以在非常短的时间内把再做一次切换，就完成了回滚。而且同时在线的只有一个版本。蓝绿部署无需停机，并且风险较小。\n(1) 部署版本1的应用（一开始的状态），所有外部请求的流量都打到这个版本上。\n(2) 部署版本2的应用，版本2的代码与版本1不同(新功能、Bug修复等)。\n(3) 将流量从版本1切换到版本2。\n(4) 如版本2测试正常，就删除版本1正在使用的资源（例如实例），从此正式用版本2。\n从过程不难发现，在部署的过程中，应用始终在线。并且，新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响。这样风险很小，并且，只要老版本的资源不被删除，理论上，可以在任何时间回滚到老版本。\n蓝绿部署的弱点：\n使用蓝绿部署需要注意的一些细节包括：\n1、当切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果数据库后端无法处理，会是一个比较麻烦的问题。\n2、有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止；\n3、需要提前考虑数据库与应用部署同步迁移/回滚的问题。\n4、蓝绿部署需要有基础设施支持。\n5、在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。\n6、另外，这种方式不好的地方还在于冗余产生的额外维护、配置的成本，以及服务器本身运行的开销。\n蓝绿部署适用的场景：\n1、不停止老版本，额外搞一套新版本，等测试发现新版本OK后，删除老版本。\n2、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。\n3、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"蓝绿部署bluegreen-deployment"},"children":[{"type":"text","value":"蓝绿部署（Blue/Green Deployment）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"过去的 10 年里，很多公司都在使用蓝绿部署（发布）来实现热部署，这种部署方式具有安全、可靠的特点。蓝绿部署虽然算不上“ Sliver Bullet”，但确实很实用。\n蓝绿部署是最常见的一种0 downtime部署的方式，是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。蓝绿部署原理上很简单，就是通过冗余来解决问题。通常生产环境需要两组配置（蓝绿配置），一组是active的生产环境的配置（绿配置），一组是inactive的配置（蓝绿配置）。用户访问的时候，只会让用户访问active的服务器集群。在绿色环境（active）运行当前生产环境中的应用，也就是旧版本应用version1。当你想要升级到version2 ，在蓝色环境（inactive）中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。随后需要监测新版本应用，也就是version2 是否有故障和异常。如果运行良好，就可以删除version1 使用的资源。如果运行出现了问题，可以通过负载均衡器指向快速回滚到绿色环境。\n蓝绿部署的优点：\n这种方式的好处在你可以始终很放心的去部署inactive环境，如果出错并不影响生产环境的服务，如果切换后出现问题，也可以在非常短的时间内把再做一次切换，就完成了回滚。而且同时在线的只有一个版本。蓝绿部署无需停机，并且风险较小。\n(1) 部署版本1的应用（一开始的状态），所有外部请求的流量都打到这个版本上。\n(2) 部署版本2的应用，版本2的代码与版本1不同(新功能、Bug修复等)。\n(3) 将流量从版本1切换到版本2。\n(4) 如版本2测试正常，就删除版本1正在使用的资源（例如实例），从此正式用版本2。\n从过程不难发现，在部署的过程中，应用始终在线。并且，新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响。这样风险很小，并且，只要老版本的资源不被删除，理论上，可以在任何时间回滚到老版本。\n蓝绿部署的弱点：\n使用蓝绿部署需要注意的一些细节包括：\n1、当切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果数据库后端无法处理，会是一个比较麻烦的问题。\n2、有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止；\n3、需要提前考虑数据库与应用部署同步迁移/回滚的问题。\n4、蓝绿部署需要有基础设施支持。\n5、在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。\n6、另外，这种方式不好的地方还在于冗余产生的额外维护、配置的成本，以及服务器本身运行的开销。\n蓝绿部署适用的场景：\n1、不停止老版本，额外搞一套新版本，等测试发现新版本OK后，删除老版本。\n2、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。\n3、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。"}]},{"type":"element","tag":"h1","props":{"id":"滚动发布rolling-update"},"children":[{"type":"text","value":"滚动发布（rolling update）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"滚动发布，一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。\n这种方式也有很多缺点，例如：\n(1) 没有一个确定OK的环境。使用蓝绿部署，我们能够清晰地知道老版本是OK的，而使用滚动发布，我们无法确定。\n(2) 修改了现有的环境。\n(3) 如果需要回滚，很困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚。此时，脾气不好的程序猿很可能想掀桌子，因为回滚是一个痛苦，并且漫长的过程。\n(4) 有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容/缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。\n并不是说滚动发布不好，滚动发布也有它非常合适的场景。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-03-orleans-Deployment/20190516171224267.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"orleans支持-蓝绿部署模型以及滚动部署模型"},"children":[{"type":"text","value":"orleans支持 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"蓝绿部署模型"}]},{"type":"text","value":"以及"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"滚动部署模型"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ClusterId：这是Orleans集群的唯一ID。使用此ID的所有客户端和Silo将能够直接相互通信。但是，您可以选择ClusterId对不同的部署使用不同的名称。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ServiceId：这是您的应用程序的唯一ID，将由某些提供程序（例如持久性提供程序）使用。此ID应该保持稳定，并且在整个部署中都不应更改。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Orleans has both "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ClusterId"}]},{"type":"text","value":" & "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ServiceId"}]},{"type":"text","value":" to support the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"blue/green deployment model"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this model, each deployment slot will have a distinct "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ClusterId"}]},{"type":"text","value":" (eg, the values could be \"blue-slot\" & \"green-slot\") but they will always have the same "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ServiceId"}]},{"type":"text","value":" (eg, \"my-service\"). The \"blue-slot\" silos will only talk to other \"blue-slot\" silos."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"However"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Grain A"}]},{"type":"text","value":" in the blue cluster and "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Grain A"}]},{"type":"text","value":" in the green cluster will still share the same storage - if they are both active then one will see a conflict when writing to the state if the other activation has already written it."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This allows for the state in the database to remain consistent when multiple clusters are active (which is usually a short period of time - during the upgrade)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If you do not use blue/green deployments then you can set "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ClusterId"}]},{"type":"text","value":" & "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ServiceId"}]},{"type":"text","value":" to the same value."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To say this in a different way:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ClusterId"}]},{"type":"text","value":" + "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ServiceId"}]},{"type":"text","value":" are used for cluster membership"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ServiceId"}]},{"type":"text","value":" is used for storage"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/dotnet/orleans/issues/5696#issuecomment-503595998","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/dotnet/orleans/issues/5696#issuecomment-503595998"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-02-03-orleans-Deployment.md","_source":"content","_file":"dotnet/2020-02-03-orleans-Deployment.md","_extension":"md","date":"2020-02-03"},{"_path":"/dotnet/2020-02-06-consistent_hash","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"一致性hash算法","description":"应用场景负载均衡和分布式场景随着业务的扩展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常使用的数据，我们可以使用Redis作为缓存机制，减少数据层的压力。因此，重构后的系统架构如下图所示：\n优化最简单的策略就是，把常用的数据保存到Redis中，为了实现高可用使用了3台Redis（没有设置集群，集群至少要6台）。每次Redis请求会随机发送到其中一台，但是这种策略会引发如下两个问题：同一份数据可能在多个Redis数据库，造成数据冗余某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中要","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"应用场景"},"children":[{"type":"text","value":"应用场景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"负载均衡"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"分布式场景"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随着业务的扩展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常使用的数据，我们可以使用Redis作为缓存机制，减少数据层的压力。因此，重构后的系统架构如下图所示：\n"},{"type":"element","tag":"img","props":{"alt":"简单架构","src":"/images/2020-02-06-Consistent_Hash/3560038521-5c37267165ddf_articlex.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优化最简单的策略就是，把常用的数据保存到Redis中，为了实现高可用使用了3台Redis（没有设置集群，集群至少要6台）。每次Redis请求会随机发送到其中一台，但是这种策略会引发如下两个问题："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同一份数据可能在多个Redis数据库，造成数据冗余"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要解决上述的问题，我们需要稍稍改变一些key存入Redis的规则："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"使用hash算法"}]},{"type":"text","value":"\n例如，有三台Redis，对于每次的访问都可以通过计算hash来求得hash值。\n如公式 h=hash(key)%3，我们把Redis编号设置成0,1,2来保存对应hash计算出来的值，h的值等于Redis对应的编号。\n但是hash算法也会面临容错性和扩展性的问题。容错性是指当系统中的某个服务出现问题时，不能影响其他系统。扩展性是指当加入新的服务器后，整个系统能正确高效运行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现假设有一台Redis服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个key就要按h = Hash(key) % 2重新计算。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样，如果新增一台服务器，规则也同样需要重新计算，h = Hash(key) % 4。因此，系统中如果有服务器更变，会直接影响到Hash值，大量的key会重定向到其他服务器中，造成缓存命中率降低，而这种情况在分布式系统中是十分糟糕的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的变更不会造成大量的哈希重定位。一致性哈希算法由此而生~"}]},{"type":"element","tag":"h2","props":{"id":"_2-一致性哈希算法"},"children":[{"type":"text","value":"2 一致性哈希算法"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简单的说，一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"哈希环","src":"/images/2020-02-06-Consistent_Hash/1926833502-5c372671647ce_articlex.png"},"children":[]},{"type":"text","value":"\n整个空间按顺时针方向组织，0和2^32-1在零点中方向重合。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来，把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。\n"},{"type":"element","tag":"img","props":{"alt":"哈希环2","src":"/images/2020-02-06-Consistent_Hash/1992706399-5c37267165131_articlex.png"},"children":[]},{"type":"text","value":"\n然后，我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"哈希环3","src":"/images/2020-02-06-Consistent_Hash/2362548025-5c3726711599a_articlex.png"},"children":[]},{"type":"text","value":"\n根据一致性哈希算法，数据A会被定为到Server 1上，数据B被定为到Server 2上，而C、D被定为到Server 3上。"}]},{"type":"element","tag":"h2","props":{"id":"_3-容错性和扩展性"},"children":[{"type":"text","value":"3 容错性和扩展性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么使用一致性哈希算法的容错性和扩展性如何呢？"}]},{"type":"element","tag":"h3","props":{"id":"_31-容错性"},"children":[{"type":"text","value":"3.1 容错性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如RedisService2宕机了，那么会怎样呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Redis2宕机","src":"/images/2020-02-06-Consistent_Hash/2142503411-5c37267117f14_articlex.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，数据B对应的节点保存到RedisService3中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。"}]},{"type":"element","tag":"h3","props":{"id":"_32-扩展性"},"children":[{"type":"text","value":"3.2 扩展性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面考虑另一种情况，假如增加一台服务器Redis4，具体位置如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"RedisServicee4","src":"/images/2020-02-06-Consistent_Hash/1713186145-5c37267126a94_articlex.png"},"children":[]},{"type":"text","value":"\n原本数据C是保存到Redis3中，但由于增加了Redis4，数据C被保存到Redis4中。干扰的也只有Redis3而已，其他数据不会受到影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性"}]},{"type":"element","tag":"h2","props":{"id":"_4-虚拟节点"},"children":[{"type":"text","value":"4 虚拟节点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前面部分都是讲述到Redis节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，我们的的系统有两台Redis，分布的环位置如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"哈希环","src":"/images/2020-02-06-Consistent_Hash/2099070812-5c37267114872_articlex.png"},"children":[]},{"type":"text","value":"\n这会产生一种情况，Redis4的hash范围比Redis3的hash范围大，导致数据大部分都存储在Redis4中，数据存储不平衡。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决这种数据存储不平衡的问题，一致性哈希算法引入了"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"虚拟节点机制"}]},{"type":"text","value":"，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"称为虚拟节点"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、 RedisService1#2、 RedisService1#3、 RedisService2#1、 RedisService2#2、 RedisService2#3，具体位置如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"虚拟节点","src":"/images/2020-02-06-Consistent_Hash/4164216256-5c3726711ca88_articlex.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"32甚至更大"}]},{"type":"text","value":"，因此即使"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"很少的服务节点"}]},{"type":"text","value":"也能做到相对"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"均匀的数据分布"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/tg123/ConsistentSharp","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/tg123/ConsistentSharp"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Consistent_hashing","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Consistent_hashing"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_2-一致性哈希算法","depth":2,"text":"2 一致性哈希算法"},{"id":"_3-容错性和扩展性","depth":2,"text":"3 容错性和扩展性","children":[{"id":"_31-容错性","depth":3,"text":"3.1 容错性"},{"id":"_32-扩展性","depth":3,"text":"3.2 扩展性"}]},{"id":"_4-虚拟节点","depth":2,"text":"4 虚拟节点"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-06-Consistent_Hash.md","_source":"content","_file":"dotnet/2020-02-06-Consistent_Hash.md","_extension":"md","date":"2020-02-06"},{"_path":"/dotnet/2020-02-07-aoi","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"地图的aoi","description":"为什么要进行视野管理？1.如果不进行视野管理，流量上来看，假设平均每秒5个移动包（80字节），1个技能包（160字节），单人每秒多少？500kb。2.客户端表现来看，客户端受屏幕大小影响，离得远的玩家看不见，没有必要发给客户端。客户端性能所限，玩家多，放各种 技能，当然会看。3.从性能上考虑，服务端不用遍历全场景对象…也会大大减少性能消耗。格子LandIncServer将每个场景看做是由n个land（块）组成，每个land就是一个大小固定的正方形，默认512 * 512。比如一个scene的尺寸为1200 * 700：则需要6个land来表示:PatchLand进一步被划分为若干个Patch（","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"为什么要进行视野管理"},"children":[{"type":"text","value":"为什么要进行视野管理？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.如果不进行视野管理，流量上来看，假设平均每秒5个移动包（80字节），1个技能包（160字节），单人每秒多少？500kb。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.客户端表现来看，客户端受屏幕大小影响，离得远的玩家看不见，没有必要发给客户端。客户端性能所限，玩家多，放各种 技能，当然会看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.从性能上考虑，服务端不用遍历全场景对象…也会大大减少性能消耗。"}]},{"type":"element","tag":"h1","props":{"id":"格子"},"children":[{"type":"text","value":"格子"}]},{"type":"element","tag":"h2","props":{"id":"land"},"children":[{"type":"text","value":"Land"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IncServer将每个场景看做是由n个land（块）组成，每个land就是一个大小固定的正方形，默认512 * 512。比如一个scene的尺寸为1200 * 700："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-07-aoi/IncServer-Scene-RealScene.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"则需要6个land来表示:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-07-aoi/IncServer-Scene.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"patch"},"children":[{"type":"text","value":"Patch"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Land进一步被划分为若干个Patch（格子）。以patch为单位，land的边长是2的整数次幂。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-07-aoi/IncServer-Scene-Patch.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"分块管理"},"children":[{"type":"text","value":"分块管理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"World对游戏对象的管理以patch为单位，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"每个patch都对应有一个对象链表"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"整个world中所有的对象链表的链表头可依次存储于一个一维数组中，这样根据对象的世界坐标，即可方便的计算出其所属的patch以及对应的对象链表。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-07-aoi/IncServer-Scene-ObjectLink.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设对象的坐标为(x, z)，patch的边长为patch_size，land的边长为land_size，整个场景在x方向上有land_x个land，则对象所属的对象链表的索引计算方式为："}]},{"type":"element","tag":"pre","props":{"code":"index = (z / patch_size) * (land_x * (land_size / patch_size)) + (x / patch_size);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"index = (z / patch_size) * (land_x * (land_size / patch_size)) + (x / patch_size);\n"}]}]},{"type":"element","tag":"h3","props":{"id":"incserver的aoi"},"children":[{"type":"text","value":"IncServer的AOI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与常见的九宫格不同，IncServer支持NEAR、MIDDLE、FAR、FULL四种视野范围："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-07-aoi/IncServer-Scene-ViewRange.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"NEAR：当前对象所位于的patch"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MIDDLE：与NEAR相邻的patch"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"FAR：与MID相邻的patch（NEAR除外）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"FULL：NEAR + MIDDILE + FAR"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过在实际开发中，所有对象的视野都是FULL，即每个对象都能看到以自己所在patch为中心前后左右各两个patch（总计25个patch）内的其他对象。之后的讨论均假设"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"所有游戏对象的视野范围均为FULL"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果对象B进入对象A的视野范围，则根据A对象类型，可能会触发不同的逻辑，比如："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对象A是玩家：将B对象"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"序列化"}]},{"type":"text","value":"到对象A的客户端。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对象B是怪物：执行对象进入怪物视野的逻辑，比如激活AI等。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后文将以上情况称之为在对象A的视野中加载对象B，简称为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"视野加载"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h3","props":{"id":"九宫格"},"children":[{"type":"text","value":"九宫格"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们首先绘制一个2D的地图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":" 3.1 网络法实现AOI算法  - 图1","src":"/images/2020-02-07-aoi/3276b001c9ca66df2fd93650fc75bc3d.jpeg"},"children":[]},{"type":"text","value":"我们给这个地图定义一些数值："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"场景相关数值计算"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"场景大小： 250*250 ， w(x轴宽度) = 250，l(y轴长度) = 250"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"x轴格子数量：nx = 5"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"y轴格子数量：ny = 5"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子宽度: dx = w / nx = 250 / 5 = 50"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子长度: dy = l / ny = 250 / 5 = 50"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子的x轴坐标：idx"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子的y轴坐标：idy"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子编号：id = idy *nx + idx (利用格子坐标得到格子编号)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子坐标：idx = id % nx , idy = id / nx (利用格子id得到格子坐标)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子的x轴坐标: idx = id % nx (利用格子id得到x轴坐标编号)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"格子的y轴坐标: idy = id / nx (利用格子id得到y轴坐标编号)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上几个数值，请参考图，简单过一下，就可以理解的，初中的几何计算而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"九宫格也是打格子的方式之一，把地图划分为很多小格子，每个格子记录格子内的玩家，每个玩家的aoi范围是以自己为中心范围内的九个格子，九个格子的大小略大于屏幕大小，同样的有三个主要的操作：enter,move,leave"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"enter:根据玩家坐标，加入到所属的格子中，通过计算以这个格子的为中心的九个格子，这九个格子内的玩家就要被通知有新玩家初始化，同时这个新玩家初始化九个格子内的所有玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"move:根据移动前位置的格子，计算出移动前的oldaoi集合，根据当前位置的格子，计算出当前的curaoi集合，如果oldaoi, curaoi为同一个格子，则通知格子内的所有玩家该玩家在移动。如果oldaoi,curaoi不是同一个格子，即发生了跨格子的操作，那么要将该玩家从旧格子移除，同时加入新格子。同时分别遍历oldaoi,curaoi,计算出需要通知玩家消失的格子集合，通知玩家出生的格子集合，以及通知玩家移动的格子集合。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"leave:玩家离开地图，将玩家从对应的格子里面删除，同时通知aoi集合有玩家离开。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器大格子的大小，以3*3的格子要总比客户端显示范围要大一点为原则。比客户端大一点，是为了预留资源加载的时间。\n　　如下图所示，绿色表示手机客户端的显示区域，当角色A在格子6中时，他可以看到1,2,3,5,6,7,9,10,11这9个格子里的内容，那么当他的状态发生变化时，就需要同步给在这9个格子里的所有玩家；同样，当这9个格子里的有玩家或者怪物的状态改变时，也需要都同步给角色A。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-07-aoi/1430365886_455802.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当角色A移动到角色B所在的格子(7)，则他将不再看到1,5,9这三个格子里的内容，同时他将新看到4,8,12这三个格子里的地图内容（玩家和怪物）。所以这个过程中，服务器要下发消息，删除角色A所在的客户端里的1,5,9这三个格子里的地图内容，同时下发消息新增4,8,12这三个格子里的地图内容（类型一）。\n　　推荐大格子具体的大小，按客户端iPhone4S的960"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"640分辨来制定，取屏幕长宽的1/2大一些，可以定为640"}]},{"type":"text","value":"360。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/artasccope/GameFW.AOI","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/artasccope/GameFW.AOI"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.bookstack.cn/read/zinx/78aa012966213643.md","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bookstack.cn/read/zinx/78aa012966213643.md"}]}]}]},{"type":"element","tag":"h3","props":{"id":"灯塔法"},"children":[{"type":"text","value":"灯塔法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓灯塔法，即将大地图划分成有限的小格子，在每个小格子中间放一个灯塔，这个灯塔管理两个队列：一个是本格子内所有的对象集合，另一个是对本灯塔感兴趣的对象集合（简称观察者）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而地图上的每个对象，维护一个视野队列：该队列为其视野范围内的所有对象，即自身感兴趣的所有对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个对象在地图上面运动：分为三个操作：enter，move，leave."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"enter:当对象进入地图的时候，根据对象的当前位置和对象的感知距离，可以获取到该对象能观察到的所有灯塔，遍历这些灯塔，将该对象添加为其观察者。同时将这些对象添加到自己的视野队列中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"move:当对象开始移动的时候，对象从一个点到另一个店，那么视野范围必然发生变化。此刻需要将对象从老的灯塔的观察者列表移除，同时将对象添加进新的灯塔的观察者列表。此外，还需要跟新玩家的视野队列，因为视野范围变化，视野内的对象也相应变化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"leave:当对象离开的时候，将自身从附近灯塔的观察者队列中移除。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过灯塔法，每当物体发生变化，我们能马上根据其当前位置，定位到他的所在的灯塔，同时找到它视野范围内相关联的物体。这样避免了遍历地图上所有玩家进行处理的方式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然灯塔的格子大小划分要因地制宜，格子越小，消耗内存越大，同时计算量变大。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/Bestpoker/AOI","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/Bestpoker/AOI"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/NetEase/pomelo-aoi","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/NetEase/pomelo-aoi"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/ahuangege/tower-aoi","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/ahuangege/tower-aoi"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前几天把pomelo中的tower aoi的js实现看了一遍，总结如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"js代码写得不是很好，发现了几个小问题；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"“对象(包括观察者)出现”“对象(包括观察者)消失”“对象(包括观察者)位置变化”“观察者位置变化”的回调通知(前三者通知对应灯塔区域的观察者，第四个通知观察者本身)没有可测试的样例，采用的话需要自己实现和测试；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"只考虑了起点和终点，移动路径上的玩家被忽视了，路径短的话也可能不是问题(长路径切分成多个短路径做位置更新)；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"观察者可能收到超出自己视野范围的消息；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"优点是可处理视野不同的观察者，相对于普通扫格子的实现在代码层面耦合度降低、效率提升不明显(把扫格子实现的地格看做一个灯塔区域，在地格上记录观察者就可以模拟这种灯塔模型，削去了遍历周边地格所有对象的逻辑)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这里做的是四边形灯塔区域，云风提的那种六边形灯塔区域减少查询灯塔个数是特指视野半径<=六边形边长的一半这种情况"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"tower aoi其实就是处理地图视野的一个设计，类似于订阅-发布，我订阅某一块区域表示对这一块区域感兴趣，那么有对象在这一块区域出现消失移动你就通知我"}]}]},{"type":"element","tag":"h1","props":{"id":"十字链表法"},"children":[{"type":"text","value":"十字链表法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里以2d游戏为例，3d游戏顺势扩展即可。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓十字链表法，即维护两天链表，一条根据地图上所有物体的x坐标从小到大依次插入链表，一条根据地图上所有物体的y坐标从小到大依次插入链表，可以想象成一个十字架。这样便把地图上的所有对象按序分配到了x,y链表上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里的链表为双向链表，双向链表的好处是，获取到链表中的一个节点，便可以向前和向后遍历。这样，当我们拿到一个对象时，要获取该对象的视野范围就变得非常简单。避免了从头到尾遍历所有对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先根据x坐标，在x链表上找到该节点，然后从该节点向前和向后遍历，根据x方向的视野范围找出需要识别的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后根据y坐标，在y链表上找到该节点，然后从该节点向前和向后遍历，根据y方向的视野范围找出需要识别的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拿到x,y链表上需要关注的对象，然后取他们的交集，这便是玩家视野范围内的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于对象在地图上的enter,move,leave 。根据前面的思路就变得非常简单"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/zhepama/AOI","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/zhepama/AOI"}]}]}]},{"type":"element","tag":"h4","props":{"id":"十字链表基本原理"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"十字链表基本原理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据二维地图，将其分成x轴和y轴两个链表。如果是三维地图，则还需要维护多一个z轴的链表。将对象的坐标值按照从小到大相应的排列在相应的坐标轴上面。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加到AOI（ADD）: 根据新增对象的X,Y坐标,依次遍历X,Y轴坐标链表,这里有两个目的,一个是获得这个新增对象的坐标在X,Y轴坐标的位置,另一方面获得该通知哪些结点.通知的范围,每个对象可以自己定制自己的通知范围。必须X,Y坐标同时都在通知范围内才可以进入通知集合，我们要按照从小到大进行插入。例如X轴坐标为:"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"a->b->c->d->e->f->g->h"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设新增一个对象z,它最终所在的位置是c和d之间,需要重新在链表的头部开始遍历寻找z的位置，比如z的X轴位置是5："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"a(0)->b(1)->c(2)->d(3)->e(4)-z(5)->f(6)->g(7)->h(8)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是这样会发现一个问题，如果需要管理的坐标少还可以。但如果有很多个坐标比如1W个坐标，那这个链表会很长，如果每次都需要从头部开始查找效率就很低。针对这样的插入方法目前大家常用的有快速排序、分治、按区域划分格子等方式。"}]},{"type":"element","tag":"h4","props":{"id":"目前常用的排序算法"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"目前常用的排序算法"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"快速排序（Quicksort）是对"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306","rel":["nofollow"]},"children":[{"type":"text","value":"冒泡排序"}]},{"type":"text","value":"的一种改进。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695","rel":["nofollow"]},"children":[{"type":"text","value":"递归"}]},{"type":"text","value":"进行，以此达到整个数据变成有序"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%BA%8F%E5%88%97/1302588","rel":["nofollow"]},"children":[{"type":"text","value":"序列"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分治算法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"按区域划分格子"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"该方法是把区域划分成多个格子，比如X坐标1到X坐标4为一个格子我们（暂时称之为A格子），坐标5到X坐标9为一个格子（暂时称之为B格子）。这样做的好处是，当你插入的坐标是2的时候，我们只需要遍历A格子里面的数据找到自己位置就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综合以上三种方法，大家一眼就看出来了。是的，按区域划分格子的方式是目前最佳的方式。从时间复杂度等等所有方便都是这个最佳，但是这个方法也有一个很大的问题，用这样的方式插入是很快了，但查找范围内的坐标就变的很困难了。大家可以仔细考虑一下或者自己写一个DEMO。你马上会发现，当我知道我的位置的情况下，我该如何查找周围玩家呢，是的。这样的话十字链就没有什么用了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然会有人说我在每个格子之间用链表进行连接就可以了，那么问题又来了。该如何连接，肯定有很复杂的代码才可以完成这样逻辑。就算是你能完成这个链表的连接，但这些逻辑会提升了时间复杂度。"}]},{"type":"element","tag":"h4","props":{"id":"快慢针"},"children":[{"type":"text","value":"快慢针"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓快慢针就是，总有一个指针快于一个指针。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现方式是，插入的时候把链表分成多份、比如链表长度为10，快的指针每次移动4个，然后对比当前节点如果位置小于的话，把慢指针指向快指针的位置，快指针继续向后面4个格子移动，直到找到大于的节点为止，这时候慢指针开始向前移动一个一个的对比位置就可以了。如果一直没有找到大于的节点，那就表示要插入的位置是当前链表最后的位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相信大家已经看明白了，是的。这样的情况下效率就很高了，唯一的问题就是这个时间复杂度不稳定。使用这个方式，查找周围玩家直接前后查找移动就可以了。效率也非常高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"快慢针实现："}]},{"type":"element","tag":"pre","props":{"code":"if (First == null)\n{\n      node.Link.YNode = AddFirst(AoiPool.Instance.Fetch<LinkedListNode<AoiNode>>(node).Value);\n}\nelse\n{\n       var slowCursor = First;\n\n       var skip = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(Count) /\n                     Convert.ToDouble(_skipCount)));\n\n       if (Last.Value.Position.Y > node.Position.Y)\n       {\n            for (var i = 0; i < _skipCount; i++)\n            {\n                 // 移动快指针\n\n                 var fastCursor = FastCursor(i * skip, skip);\n\n                 // 如果快指针的值小于插入的值，把快指针赋给慢指针，当做当前指针。\n\n                 if (fastCursor.Value.Position.Y <= node.Position.Y)\n                 {\n                       slowCursor = fastCursor;\n\n                            continue;\n                 }\n\n                 // 慢指针移动到快指针位置\n\n                 while (slowCursor != fastCursor)\n                 {\n                      if (slowCursor == null) break;\n\n                      if (slowCursor.Value.Position.Y >= node.Position.Y)\n                      {\n                           node.Link.YNode = AddBefore(slowCursor,\n                                    AoiPool.Instance.Fetch<LinkedListNode<AoiNode>>(node).Value);\n\n                           return;\n                        }\n\n                       slowCursor = slowCursor.Next;\n\n                        }\n                    }\n                }\n\nif (node.Link.YNode == null)\n{\n       node.Link.YNode = AddLast(AoiPool.Instance.Fetch<LinkedListNode<AoiNode>>(node).Value);\n}\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (First == null)\n{\n      node.Link.YNode = AddFirst(AoiPool.Instance.Fetch<LinkedListNode<AoiNode>>(node).Value);\n}\nelse\n{\n       var slowCursor = First;\n\n       var skip = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(Count) /\n                     Convert.ToDouble(_skipCount)));\n\n       if (Last.Value.Position.Y > node.Position.Y)\n       {\n            for (var i = 0; i < _skipCount; i++)\n            {\n                 // 移动快指针\n\n                 var fastCursor = FastCursor(i * skip, skip);\n\n                 // 如果快指针的值小于插入的值，把快指针赋给慢指针，当做当前指针。\n\n                 if (fastCursor.Value.Position.Y <= node.Position.Y)\n                 {\n                       slowCursor = fastCursor;\n\n                            continue;\n                 }\n\n                 // 慢指针移动到快指针位置\n\n                 while (slowCursor != fastCursor)\n                 {\n                      if (slowCursor == null) break;\n\n                      if (slowCursor.Value.Position.Y >= node.Position.Y)\n                      {\n                           node.Link.YNode = AddBefore(slowCursor,\n                                    AoiPool.Instance.Fetch<LinkedListNode<AoiNode>>(node).Value);\n\n                           return;\n                        }\n\n                       slowCursor = slowCursor.Next;\n\n                        }\n                    }\n                }\n\nif (node.Link.YNode == null)\n{\n       node.Link.YNode = AddLast(AoiPool.Instance.Fetch<LinkedListNode<AoiNode>>(node).Value);\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"实现方式"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"实现方式"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Move（当角色移动后通知AOI）："}]}]},{"type":"element","tag":"pre","props":{"code":"#region 移动X轴\n\n            if (Math.Abs(node.Position.X - x) > 0)\n            {\n                if (x > node.Position.X)\n                {\n                    var cur = node.Link.XNode.Next;\n\n                    while (cur != null)\n                    {\n                        if (x < cur.Value.Position.X)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n\n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Next == null)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Next;\n                    }\n                }\n                else\n                {\n                    var cur = node.Link.XNode.Previous;\n\n                    while (cur != null)\n                    {\n                        if (x > cur.Value.Position.X)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Previous == null)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Previous;\n                    }\n                }\n            }\n\n            #endregion\n\n            #region 移动Y轴\n\n            if (Math.Abs(node.Position.Y - y) > 0)\n            {\n                if (y > node.Position.Y)\n                {\n                    var cur = node.Link.YNode.Next;\n\n                    while (cur != null)\n                    {\n                        if (y < cur.Value.Position.Y)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Next == null)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Next;\n                    }\n                }\n                else\n                {\n                    var cur = node.Link.YNode.Previous;\n\n                    while (cur != null)\n                    {\n                        if (y > cur.Value.Position.Y)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Previous == null)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Previous;\n                    }\n                }\n            }\n\n            \n            #end-region\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#region 移动X轴\n\n            if (Math.Abs(node.Position.X - x) > 0)\n            {\n                if (x > node.Position.X)\n                {\n                    var cur = node.Link.XNode.Next;\n\n                    while (cur != null)\n                    {\n                        if (x < cur.Value.Position.X)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n\n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Next == null)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Next;\n                    }\n                }\n                else\n                {\n                    var cur = node.Link.XNode.Previous;\n\n                    while (cur != null)\n                    {\n                        if (x > cur.Value.Position.X)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Previous == null)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Previous;\n                    }\n                }\n            }\n\n            #endregion\n\n            #region 移动Y轴\n\n            if (Math.Abs(node.Position.Y - y) > 0)\n            {\n                if (y > node.Position.Y)\n                {\n                    var cur = node.Link.YNode.Next;\n\n                    while (cur != null)\n                    {\n                        if (y < cur.Value.Position.Y)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Next == null)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Next;\n                    }\n                }\n                else\n                {\n                    var cur = node.Link.YNode.Previous;\n\n                    while (cur != null)\n                    {\n                        if (y > cur.Value.Position.Y)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Previous == null)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Previous;\n                    }\n                }\n            }\n\n            \n            #end-region\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"查找周围（按照指定的范围查找自己周围玩家）："}]}]},{"type":"element","tag":"pre","props":{"code":"for (var i = 0; i < 2; i++)\n            {\n                var cur = i == 0 ? node.Link.XNode.Next : node.Link.XNode.Previous;\n\n                while (cur != null)\n                {\n                    if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) > area.X)\n                    {\n                        break;\n                    }\n                    else if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) <= area.Y)\n                    {\n                        if (Distance(node.Position, cur.Value.Position) <= area.X)\n                        {\n                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);\n                        }\n                    }\n\n                    cur = i == 0 ? cur.Next : cur.Previous;\n                }\n            }\n\n            for (var i = 0; i < 2; i++)\n            {\n               var cur = i == 0 ? node.Link.YNode.Next : node.Link.YNode.Previous;\n\n                while (cur != null)\n                {\n                    if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) > area.Y)\n                    {\n                        break;\n                    }\n                    else if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) <= area.X)\n                    {\n                        if (Distance(node.Position, cur.Value.Position) <= area.Y)\n                        {\n                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);\n                        }\n                    }\n\n                    cur = i == 0 ? cur.Next :cur.Previous;\n                }\n            }\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"for (var i = 0; i < 2; i++)\n            {\n                var cur = i == 0 ? node.Link.XNode.Next : node.Link.XNode.Previous;\n\n                while (cur != null)\n                {\n                    if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) > area.X)\n                    {\n                        break;\n                    }\n                    else if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) <= area.Y)\n                    {\n                        if (Distance(node.Position, cur.Value.Position) <= area.X)\n                        {\n                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);\n                        }\n                    }\n\n                    cur = i == 0 ? cur.Next : cur.Previous;\n                }\n            }\n\n            for (var i = 0; i < 2; i++)\n            {\n               var cur = i == 0 ? node.Link.YNode.Next : node.Link.YNode.Previous;\n\n                while (cur != null)\n                {\n                    if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) > area.Y)\n                    {\n                        break;\n                    }\n                    else if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) <= area.X)\n                    {\n                        if (Distance(node.Position, cur.Value.Position) <= area.Y)\n                        {\n                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);\n                        }\n                    }\n\n                    cur = i == 0 ? cur.Next :cur.Previous;\n                }\n            }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"优缺点"},"children":[{"type":"text","value":"优缺点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"九宫格"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"优点: cpu消耗小"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缺点: 内存开销大,内存消耗不仅和实体数有关,还和场景大小成正比"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"十字链表"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"优点: 内存开销小,内存消耗仅和实体数有关,和场景大小无关"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缺点: cpu消耗高,每次移动都需要计算视野差,当实体在小区域堆积严重时效率更差"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"为什么要进行视野管理","depth":2,"text":"为什么要进行视野管理？"},{"id":"land","depth":2,"text":"Land"},{"id":"patch","depth":2,"text":"Patch"},{"id":"分块管理","depth":2,"text":"分块管理","children":[{"id":"incserver的aoi","depth":3,"text":"IncServer的AOI"},{"id":"九宫格","depth":3,"text":"九宫格"},{"id":"灯塔法","depth":3,"text":"灯塔法"}]},{"id":"优缺点","depth":2,"text":"优缺点"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-07-aoi.md","_source":"content","_file":"dotnet/2020-02-07-aoi.md","_extension":"md","date":"2020-02-07"},{"_path":"/dotnet/2020-02-09-room-elo","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"游戏的匹配机制ELO","description":"https://www.jianshu.com/p/edc5d341956a","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/edc5d341956a","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.jianshu.com/p/edc5d341956a"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/weixin_30876945/article/details/98079738?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/weixin_30876945/article/details/98079738?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/yekoufeng/article/details/80573857?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/yekoufeng/article/details/80573857?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-02-09-room-elo.md","_source":"content","_file":"dotnet/2020-02-09-room-elo.md","_extension":"md","date":"2020-02-09"},{"_path":"/dotnet/2020-02-10-icloneable","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"C# 深浅复制","description":"关于深浅复制大家可参考MSDN：https://msdn.microsoft.com/zh-cn/library/system.object.memberwiseclone.aspx","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于深浅复制大家可参考MSDN："},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/zh-cn/library/system.object.memberwiseclone.aspx","rel":["nofollow"]},"children":[{"type":"text","value":"https://msdn.microsoft.com/zh-cn/library/system.object.memberwiseclone.aspx"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓深浅复制可解读为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"浅复制：C#语言种的MemberwiseClone方法仅仅是再内存种创建一个新对象，然后将原有对象的所有字段直接复制过去，无论是值类型还是引用类型，是值类型的就复制值类型，是应用类型的就复制引用本身（而不会复制所引用的对象），因此，是浅拷贝。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是:  在利用MemberwiseClone()创建新对象的时候，不会像利用new的时候一样，也就是不会先执行字段的创建和构造方法条用的过程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"深复制：如果字段是值类型的，则对字段执行逐位复制，如果字段是引用类型的，则把引用类型的对象指向"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一个全新的对象！"}]}]},{"type":"element","tag":"h2","props":{"id":"icloneable接口"},"children":[{"type":"text","value":"ICloneable接口"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ICloneable接口包含一个Clone方法，可以用来创建当前对象的拷贝。"}]},{"type":"element","tag":"pre","props":{"code":"public interface ICloneable \n{ \n    object Clone(); \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public interface ICloneable \n{ \n    object Clone(); \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ICloneable的问题是Clone方法并不会显式地指定是执行浅拷贝或深拷贝，因此调用者将无法确定实际情况。因此，有一些关于把ICloneable从.NET框架中淘汰的讨论。MSDN文档似乎暗示Clone方法是进行的深拷贝，但是文档没有明确的说明："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ICloneable接口包含一个成员方法，Clone，意在支持超过MemberWiseClone所提供的功能... MemberWiseClone进行的是浅拷贝..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类型安全的克隆"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ICloneable的另一个缺点是Clone方法返回的是一个对象，因此每次调用Clone都要进行一次强制类型转换。"}]},{"type":"element","tag":"pre","props":{"code":"Person joe = new Person(); \njoe.Name = \"Joe Smith\"; \nPerson joeClone = (Person)joe.Clone();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Person joe = new Person(); \njoe.Name = \"Joe Smith\"; \nPerson joeClone = (Person)joe.Clone();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一种可以避免进行强制类型转换的方式是提供你自己的类型安全的Clone方法。注意，你依然要提供ICloneable.Clone方法的以满足iCloneable接口的要求。"}]},{"type":"element","tag":"pre","props":{"code":"public class Person : ICloneable \n{ \n    public string Name; \n    object ICloneable.Clone() \n    { \n        return this.Clone(); \n    } \n    public Person Clone() \n    { \n        return (Person)this.MemberwiseClone(); \n    } \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Person : ICloneable \n{ \n    public string Name; \n    object ICloneable.Clone() \n    { \n        return this.Clone(); \n    } \n    public Person Clone() \n    { \n        return (Person)this.MemberwiseClone(); \n    } \n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"手工克隆"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个能够保证对象完全按照你所想的那样进行克隆的方式是手工克隆对象的每一个域（field）。这种方式的缺点是麻烦而且容易出错：如果你在类中增 加了一个域，你很可能会忘记更新Clone方法。还要在克隆引用对象指向原始对象的时候，注意避免无限循环引用。下面是一个进行深拷贝的简单例子："}]},{"type":"element","tag":"pre","props":{"code":"public class Person : ICloneable \n{ \n    public string Name; \n    public Person Spouse; \n    public object Clone() \n    { \n        Person p = new Person(); \n        p.Name = this.Name; \n        if (this.Spouse != null) \n            p.Spouse = (Person)this.Spouse.Clone(); \n        return p; \n    } \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Person : ICloneable \n{ \n    public string Name; \n    public Person Spouse; \n    public object Clone() \n    { \n        Person p = new Person(); \n        p.Name = this.Name; \n        if (this.Spouse != null) \n            p.Spouse = (Person)this.Spouse.Clone(); \n        return p; \n    } \n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用MemberWiseClone方法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MemberWiseClone是Object类的受保护方法，能够通过创建一个新对象，并把所有当前对象中的非静态域复制到新对象中，从而创建一 个浅拷贝。对于值类型的域，进行的是按位拷贝。对于引用类型的域，引用会被赋值而引用的对象则不会。因此，原始对象及其克隆都会引用同一个对象。注意，这 种方法对派生类都是有效的，也就是说，你只需在基类中定义一次Clone方法。下面是一个简单的例子："}]},{"type":"element","tag":"pre","props":{"code":"public class Person : ICloneable \n{ \n    public string Name; \n    public Person Spouse; \n    public object Clone() \n    { \n        return this.MemberwiseClone(); \n    } \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Person : ICloneable \n{ \n    public string Name; \n    public Person Spouse; \n    public object Clone() \n    { \n        return this.MemberwiseClone(); \n    } \n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"用反射进行克隆"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用反射进行克隆是使用Activator.CreateInstance方法来创建一个相同类型的新对象，然后用反射对所有域进行浅拷贝。这种方法 的优点是它是全自动的，不需要在对象中添加或删除成员的时候修改克隆方法。另外它也能被写成提供深拷贝的方法。缺点是使用了反射，因此会比较慢，而且在部 分受信任的环境中是不可用的。示例代码"}]},{"type":"element","tag":"pre","props":{"code":"private static TOut TransReflection<TIn, TOut>(TIn tIn)\n        {\n            TOut tOut = Activator.CreateInstance<TOut>();\n            var tInType = tIn.GetType();\n            foreach (var itemOut in tOut.GetType().GetProperties())\n            {\n                var itemIn = tInType.GetProperty(itemOut.Name); ;\n                if (itemIn != null)\n                {\n                    itemOut.SetValue(tOut, itemIn.GetValue(tIn));\n                }\n            }\n            return tOut;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private static TOut TransReflection<TIn, TOut>(TIn tIn)\n        {\n            TOut tOut = Activator.CreateInstance<TOut>();\n            var tInType = tIn.GetType();\n            foreach (var itemOut in tOut.GetType().GetProperties())\n            {\n                var itemIn = tInType.GetProperty(itemOut.Name); ;\n                if (itemIn != null)\n                {\n                    itemOut.SetValue(tOut, itemIn.GetValue(tIn));\n                }\n            }\n            return tOut;\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"调用一百万次耗时：2464毫秒"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用序列化进行克隆"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"克隆一个对象的最简单的方法是将它序列化并立刻反序列化为一个新对象。和反射方法一样，序列化方法是自动的，无需在对对象成员进行增删的时候做出修 改。缺点是序列化比其他方法慢，甚至比用反射还慢，所有引用的对象都必须是可序列化的（Serializable）。另外，取决于你所使用的序列化的类型 （XML，SOAP，二进制）的不同，私有成员可能不能像期望的那样被克隆。示例代码在这里，这里和这里。"}]},{"type":"element","tag":"pre","props":{"code":"StudentSecond ss= JsonConvert.DeserializeObject<StudentSecond>(JsonConvert.SerializeObject(s));\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"StudentSecond ss= JsonConvert.DeserializeObject<StudentSecond>(JsonConvert.SerializeObject(s));\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**调用一百万次耗时：**2984毫秒"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://wiki.unity3d.com/index.php/ObjectCopier","rel":["nofollow"]},"children":[{"type":"text","value":"http://wiki.unity3d.com/index.php/ObjectCopier"}]}]},{"type":"element","tag":"pre","props":{"code":"using System;\nusing System.Collections;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.IO;\n \n/// <summary>\n/// Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx\n/// \n/// Provides a method for performing a deep copy of an object.\n/// Binary Serialization is used to perform the copy.\n/// </summary>\npublic static class ObjectCopier\n{\n    /// <summary>\n    /// Perform a deep Copy of the object.\n    /// </summary>\n    /// <typeparam name=\"T\">The type of object being copied.</typeparam>\n    /// <param name=\"source\">The object instance to copy.</param>\n    /// <returns>The copied object.</returns>\n    public static T Clone<T>(this T source)\n    {\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(\"The type must be serializable.\", \"source\");\n        }\n \n        // Don't serialize a null object, simply return the default for that object\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n \n        IFormatter formatter = new BinaryFormatter();\n        Stream stream = new MemoryStream();\n        using (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(0, SeekOrigin.Begin);\n            return (T)formatter.Deserialize(stream);\n        }\n     }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Collections;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.IO;\n \n/// <summary>\n/// Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx\n/// \n/// Provides a method for performing a deep copy of an object.\n/// Binary Serialization is used to perform the copy.\n/// </summary>\npublic static class ObjectCopier\n{\n    /// <summary>\n    /// Perform a deep Copy of the object.\n    /// </summary>\n    /// <typeparam name=\"T\">The type of object being copied.</typeparam>\n    /// <param name=\"source\">The object instance to copy.</param>\n    /// <returns>The copied object.</returns>\n    public static T Clone<T>(this T source)\n    {\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(\"The type must be serializable.\", \"source\");\n        }\n \n        // Don't serialize a null object, simply return the default for that object\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n \n        IFormatter formatter = new BinaryFormatter();\n        Stream stream = new MemoryStream();\n        using (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(0, SeekOrigin.Begin);\n            return (T)formatter.Deserialize(stream);\n        }\n     }\n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用IL进行克隆"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一种罕见的解决方案是使用IL（中间语言）来进行对象克隆。这种方式创建一个动态方法（DynamicMethod），获取中间语言生成器 （ILGenerator），向方法中注入代码，把它编译成一个委托，然后执行这个委托。委托会被缓存，因此中间语言只在初次克隆的时候才会生成，后续的 克隆都不会重新生成一遍。尽管这种方法比使用反射快，但是这种方法难以理解和维护。示例代码"}]},{"type":"element","tag":"pre","props":{"code":"　 public static class TransExpV2<TIn, TOut>\n    {\n\n        private static readonly Func<TIn, TOut> cache = GetFunc();\n        private static Func<TIn, TOut> GetFunc()\n        {\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), \"p\");\n            List<MemberBinding> memberBindingList = new List<MemberBinding>();\n\n            foreach (var item in typeof(TOut).GetProperties())\n            {\n　　　　　　　　　if (!item.CanWrite)\n　　　　　　　　　　    continue;\n\n                MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));\n                MemberBinding memberBinding = Expression.Bind(item, property);\n                memberBindingList.Add(memberBinding);\n            }\n\n            MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());\n            Expression<Func<TIn, TOut>> lambda = Expression.Lambda<Func<TIn, TOut>>(memberInitExpression, new ParameterExpression[] { parameterExpression });\n\n            return lambda.Compile();\n        }\n\n        public static TOut Trans(TIn tIn)\n        {\n            return cache(tIn);\n        }\n\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"　 public static class TransExpV2<TIn, TOut>\n    {\n\n        private static readonly Func<TIn, TOut> cache = GetFunc();\n        private static Func<TIn, TOut> GetFunc()\n        {\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), \"p\");\n            List<MemberBinding> memberBindingList = new List<MemberBinding>();\n\n            foreach (var item in typeof(TOut).GetProperties())\n            {\n　　　　　　　　　if (!item.CanWrite)\n　　　　　　　　　　    continue;\n\n                MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));\n                MemberBinding memberBinding = Expression.Bind(item, property);\n                memberBindingList.Add(memberBinding);\n            }\n\n            MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());\n            Expression<Func<TIn, TOut>> lambda = Expression.Lambda<Func<TIn, TOut>>(memberInitExpression, new ParameterExpression[] { parameterExpression });\n\n            return lambda.Compile();\n        }\n\n        public static TOut Trans(TIn tIn)\n        {\n            return cache(tIn);\n        }\n\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"StudentSecond ss= TransExpV2.Trans(s);"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"*"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"调用一百万次耗时：107毫秒*"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用扩展方法进行克隆"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Havard Stranden用扩展方法（extention method）创建了一个自定义的克隆框架。这个框架能够创建对象及其引用的对象的深拷贝，不管对象结构有多复杂。缺点是，这是一个不提供源代码的自定义 框架（更新：现在已经包括源代码了，参见本文评论），并且它不能在不使用无参数构造器的时候，拷贝由私有方法创建的对象。另一个问题，也是所有自动化的深 克隆方法共有的问题是，深拷贝通常需要灵活地处理不能进行简单自动化特殊情况（例如未受管理的资源）。"}]},{"type":"element","tag":"h3","props":{"id":"一个测试类"},"children":[{"type":"text","value":"一个测试类"}]},{"type":"element","tag":"pre","props":{"code":"\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\nnamespace dotnet_samples_test\n{\n\n    public class Person : ICloneable \n    {\n        public IdInfo IdInfo;\n        public int Age { get; set; }\n        public string Name { get; set; }\n        public string Address { get; set; }\n        public List<string> Phones { get; set; } = new List<string>();\n        public object Clone()\n        {\n            return this.MemberwiseClone();\n        }\n\n        public Person ShallowCopy()\n        {\n            return (Person)this.Clone();\n        }\n\n        public Person DeepCopy()\n        {\n            var result =  (Person)this.Clone();\n            result.IdInfo = result.IdInfo.DeepCopy();\n            result.Phones = result.Phones.ToList();\n            return result;\n        }\n    }\n\n\n    public class IdInfo\n    {\n        public int IdNumber;\n        public IdInfo(int IdNumber)\n        {\n            this.IdNumber = IdNumber;\n        }\n\n        public object Clone()\n        {\n            return this.MemberwiseClone();\n        }\n\n        public IdInfo ShallowCopy()\n        {\n            return (IdInfo)this.Clone();\n        }\n\n        public IdInfo DeepCopy()\n        {\n            var result =  (IdInfo)this.Clone();\n\n            return result;\n        }\n\n    }\n\n\n\n\n\n    [TestClass]\n    public class CloneTest1\n    {\n        [TestMethod]\n        public void TestMethod1()\n        {\n            var person1 = new Person\n            {\n                Name = \"長澤雅美\",\n                Age = 30,\n                Address = \"日本静岡縣磐田市\",\n                Phones = new List<string> { \"9\", \"1\", \"1\" },\n                IdInfo = new IdInfo(1)\n            };\n            var person2 = person1.ShallowCopy();\n            person2.IdInfo.IdNumber = 2;\n            person2.Phones.RemoveAt(0);\n            person2.Name=\"冈本伊朗\";\n            Console.WriteLine(\"person1的名字:\"+person1.Name);\n            Console.WriteLine(\"person1第一个数字是:\"+person1.Phones[0]);\n            Console.WriteLine(\"person1id是:\"+person1.IdInfo.IdNumber);\n\n                      Console.WriteLine(\"person2的名字:\"+person2.Name);\n            Console.WriteLine(\"person2第一个数字是:\"+person2.Phones[0]);\n            Console.WriteLine(\"person2id是:\"+person2.IdInfo.IdNumber);\n            Assert.AreEqual(person1.IdInfo.IdNumber,person2.IdInfo.IdNumber);\n        }\n\n        [TestMethod]\n        public void TestMethod2()\n        {\n            var person1 = new Person\n            {\n                Name = \"長澤雅美\",\n                Age = 30,\n                Address = \"日本静岡縣磐田市\",\n                Phones = new List<string> { \"9\", \"1\", \"1\" },\n                IdInfo = new IdInfo(1)\n            };\n            var person2 = person1.DeepCopy();\n            person2.IdInfo.IdNumber = 2;\n            person2.Phones.RemoveAt(0);\n            \n            Console.WriteLine(\"person1的名字:\"+person1.Name);\n            Console.WriteLine(\"person1第一个数字是:\"+person1.Phones[0]);\n            Console.WriteLine(\"person1id是:\"+person1.IdInfo.IdNumber);\n\n            Console.WriteLine(\"person2的名字:\"+person2.Name);\n            Console.WriteLine(\"person2第一个数字是:\"+person2.Phones[0]);\n            Console.WriteLine(\"person2id是:\"+person2.IdInfo.IdNumber);\n\n            Assert.AreEqual(person1.IdInfo.IdNumber,person2.IdInfo.IdNumber);\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\nnamespace dotnet_samples_test\n{\n\n    public class Person : ICloneable \n    {\n        public IdInfo IdInfo;\n        public int Age { get; set; }\n        public string Name { get; set; }\n        public string Address { get; set; }\n        public List<string> Phones { get; set; } = new List<string>();\n        public object Clone()\n        {\n            return this.MemberwiseClone();\n        }\n\n        public Person ShallowCopy()\n        {\n            return (Person)this.Clone();\n        }\n\n        public Person DeepCopy()\n        {\n            var result =  (Person)this.Clone();\n            result.IdInfo = result.IdInfo.DeepCopy();\n            result.Phones = result.Phones.ToList();\n            return result;\n        }\n    }\n\n\n    public class IdInfo\n    {\n        public int IdNumber;\n        public IdInfo(int IdNumber)\n        {\n            this.IdNumber = IdNumber;\n        }\n\n        public object Clone()\n        {\n            return this.MemberwiseClone();\n        }\n\n        public IdInfo ShallowCopy()\n        {\n            return (IdInfo)this.Clone();\n        }\n\n        public IdInfo DeepCopy()\n        {\n            var result =  (IdInfo)this.Clone();\n\n            return result;\n        }\n\n    }\n\n\n\n\n\n    [TestClass]\n    public class CloneTest1\n    {\n        [TestMethod]\n        public void TestMethod1()\n        {\n            var person1 = new Person\n            {\n                Name = \"長澤雅美\",\n                Age = 30,\n                Address = \"日本静岡縣磐田市\",\n                Phones = new List<string> { \"9\", \"1\", \"1\" },\n                IdInfo = new IdInfo(1)\n            };\n            var person2 = person1.ShallowCopy();\n            person2.IdInfo.IdNumber = 2;\n            person2.Phones.RemoveAt(0);\n            person2.Name=\"冈本伊朗\";\n            Console.WriteLine(\"person1的名字:\"+person1.Name);\n            Console.WriteLine(\"person1第一个数字是:\"+person1.Phones[0]);\n            Console.WriteLine(\"person1id是:\"+person1.IdInfo.IdNumber);\n\n                      Console.WriteLine(\"person2的名字:\"+person2.Name);\n            Console.WriteLine(\"person2第一个数字是:\"+person2.Phones[0]);\n            Console.WriteLine(\"person2id是:\"+person2.IdInfo.IdNumber);\n            Assert.AreEqual(person1.IdInfo.IdNumber,person2.IdInfo.IdNumber);\n        }\n\n        [TestMethod]\n        public void TestMethod2()\n        {\n            var person1 = new Person\n            {\n                Name = \"長澤雅美\",\n                Age = 30,\n                Address = \"日本静岡縣磐田市\",\n                Phones = new List<string> { \"9\", \"1\", \"1\" },\n                IdInfo = new IdInfo(1)\n            };\n            var person2 = person1.DeepCopy();\n            person2.IdInfo.IdNumber = 2;\n            person2.Phones.RemoveAt(0);\n            \n            Console.WriteLine(\"person1的名字:\"+person1.Name);\n            Console.WriteLine(\"person1第一个数字是:\"+person1.Phones[0]);\n            Console.WriteLine(\"person1id是:\"+person1.IdInfo.IdNumber);\n\n            Console.WriteLine(\"person2的名字:\"+person2.Name);\n            Console.WriteLine(\"person2第一个数字是:\"+person2.Phones[0]);\n            Console.WriteLine(\"person2id是:\"+person2.IdInfo.IdNumber);\n\n            Assert.AreEqual(person1.IdInfo.IdNumber,person2.IdInfo.IdNumber);\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"icloneable接口","depth":2,"text":"ICloneable接口","children":[{"id":"一个测试类","depth":3,"text":"一个测试类"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-02-10-Icloneable.md","_source":"content","_file":"dotnet/2020-02-10-Icloneable.md","_extension":"md","date":"2020-02-10"},{"_path":"/dotnet/2020-02-11-gc","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"C#引用类型对象在循环引用时会不会内存泄漏","description":"对于垃圾收集（GC）, 我们需要考虑三件事情：哪些内存需要回收？如何判断是垃圾对象？垃圾回收算法有哪些？","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于垃圾收集（GC）, 我们需要考虑三件事情：哪些内存需要回收？如何判断是垃圾对象？垃圾回收算法有哪些？"}]},{"type":"element","tag":"h2","props":{"id":"一gc的工作区域"},"children":[{"type":"text","value":"一、GC的工作区域"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1、不是GC的工作区域"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2)栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作，每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具有确定性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这几个区域不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2、GC的工作区域（哪些内存需要GC回收？）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)垃圾回收重点关注的是堆和方法区部分的内存。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    因为一个接口中的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配和回收都是动态的，所以垃圾回收器所关注的主要是这部分的内存。"}]},{"type":"element","tag":"h2","props":{"id":"二垃圾对象的判定"},"children":[{"type":"text","value":"二、垃圾对象的判定"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，哪些还活着。对象死去的时候才需要回收。"}]},{"type":"element","tag":"h4","props":{"id":"_1引用计数法"},"children":[{"type":"text","value":"1、引用计数法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1)可即刻回收垃圾，每个对象都知道自己的被引用数，当counter为0时，对象就会把自己作为空闲空间连接到空闲链表，也就是在对象变成垃圾的同时就会被回收."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2）最大暂停时间短，每次通过指向mutator生成垃圾时，这部分垃圾都会被回收，大幅削减了mutator的最大暂停时间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1)引用和去引用伴随加法和减法，影响性能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2)很难处理循环引用"}]},{"type":"element","tag":"h4","props":{"id":"_2可达性分析算法"},"children":[{"type":"text","value":"2、可达性分析算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Java语言是通过可达性分析算法来判断对象是否存活的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-11-gc/1090617-20180621212836385-64372595.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C#与Java中，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GC采用的是GC Root 的链路可达性分析算法解决的GC标记问题"}]},{"type":"text","value":"。原理就是一个对象只要有GC Root引用，就不会释放"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":".NET中可以当作GC Root的对象有如下几种："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、全局变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、静态变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、栈上的所有局部变量(JIT)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、栈上传入的参数变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5、寄存器中的变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在Java中，可以当做GC Root的对象有以下几种："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、虚拟机（JVM）栈中的引用的对象"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、方法区中的类静态属性引用的对象"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、方法区中的常量引用的对象（主要指声明为final的常量值）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、本地方法栈中JNI的引用的对象"}]},{"type":"element","tag":"h2","props":{"id":"三垃圾回收算法"},"children":[{"type":"text","value":"三、垃圾回收算法"}]},{"type":"element","tag":"h4","props":{"id":"_1标记-清除算法"},"children":[{"type":"text","value":"1、标记-清除算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简单来说有两个步骤：标记、清除。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1). 标记阶段：找到所有可访问的对象，做个标记"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2). 清除阶段：遍历堆，把未被标记的对象回收\n"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-11-gc/1090617-20180621213112064-1445464345.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺 点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)因为涉及大量的内存遍历工作，所以执行性能较低，这也会导致“stop the world”时间较长，java程序吞吐量降低；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2)对象被清除之后，被清除的对象留下内存的空缺位置会造成内存不连续，空间浪费。"}]},{"type":"element","tag":"h4","props":{"id":"_2标记整理压缩算法"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2、标记整理(压缩)算法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"标记-整理算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)、标记阶段：它的第一个阶段与标记/清除算法是一模一样的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2)、整理阶段：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。\n"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-11-gc/1090617-20180621213518377-283931527.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"列表显然少了许多开销。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"标记/整理算法唯一的缺点就是效率也不高。不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。"}]},{"type":"element","tag":"h4","props":{"id":"_3复制算法"},"children":[{"type":"text","value":"3、复制算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制算法简单来说就是把内存一分为二，但只使用其中一份，在垃圾回收时，将正在使用的那份内存中存活的对象复制到另一份空白的内存中，最后将正在使用的内存空间的对象清除，完成垃圾回收。\n"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-11-gc/1090617-20180621213541943-2048983954.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点\n复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。\n缺点\n复制算法的代价是将内存缩小为原来的一半，这个太要命了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意（重要）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一块为Eden（伊面区）和两块较小的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Survivor（幸存区）空间(默认比例->8:1:1)。每次使用Eden和其中的一块Survivor，垃圾回收时候将上述两块中存活的对象复制到另外一块Survivor上，同时清理上述Eden和Survivor。所以每次新生代就可以使用90%"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"的内存。只有10%的内存是浪费的。(不能保证每次新生代都少于10%的对象存活，当在垃圾回收复制时候如果一块Survivor不够时候，需要老年代来分担，大对象直接进入老年代)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总的来讲：复制算法不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）"}]},{"type":"element","tag":"h4","props":{"id":"_4三种算法总结"},"children":[{"type":"text","value":"4、三种算法总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相同点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2)在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"区别"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"三种算法比较："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    效率：复制算法>标记-整理算法>标记-清除算法；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    内存整齐度：复制算法=标记-整理算法>标记-清除算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    内存利用率：标记-整理算法=标记-清除算法>复制算法"}]},{"type":"element","tag":"h4","props":{"id":"_5分代收集算法"},"children":[{"type":"text","value":"5、分代收集算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先这不是一种新算法，它是一种思想。现在使用的Java虚拟机并不是只是使用一种内存回收机制，而是分代收集的算法。就是将内存根据对象存活的周期划分为几块。一般是把堆分为新生代、和老年代。短命对"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"象存放在新生代中，长命对象放在老年代中。\n"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-11-gc/1090617-20180621214050767-1145517463.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个图是我拷贝来的，但要记住java8以后，已经没有永久区了，之前永久区存放的东西基本上放到了元空间中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于不同的代，采用不同的收集算法："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    新生代：由于存活的对象相对比较少，因此可以采用复制算法该算法效率比较快。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    老年代：由于存活的对象比较多哈，可以采用标记-清除算法或是标记-整理算法。"}]},{"type":"element","tag":"h2","props":{"id":"各平台gc算法"},"children":[{"type":"text","value":"各平台GC算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于Mono和unity ，集成的是开源项目BOEHM ，BOEHM算法采用标记清除法,il2cpp也是实现了boehm算法"}]},{"type":"element","tag":"h1","props":{"id":"关于c和java中的循环引用"},"children":[{"type":"text","value":"关于c#和java中的循环引用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"循环引用指的是A引用了B，而B又引用了A。在写代码的时候，都难免会这样写：地图引用了战斗单位，战斗单位又引用了地图。。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如图：（来源于国外大神的解释）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"小议C#引用类型对象在循环引用时会不会内存泄漏","src":"/images/2020-02-11-mem/5b1933eb47c2a.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当A没有再被其他类引用，则A，B，C都应该被垃圾回收。如果判断该对象是否需要被回收的依据是基于引用计数的，那上面代码就会是这样：B被C和A引了，引用计数为2，C被B引了，引用计数为1，这样内存就泄露了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以C#的GC并没有用引用计数。GC有一些“根”，对象都挂在上面。从“根”往其子结点进行遍历，就可以标注出哪些对象是被使用的。A对象没有被其他引用，A作为B，C的入口，所以A,B,C都变成了被回收的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要是涉及到的对象不能从GC Roots"},{"type":"element","tag":"a","props":{"href":"https://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/","rel":["nofollow"]},"children":[{"type":"text","value":"强引用"}]},{"type":"text","value":"可到达，垃圾回收器都会进行清理来释放内存。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综上，C#在做循环引用的时候是不会出现垃圾回收问题的。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一gc的工作区域","depth":2,"text":"一、GC的工作区域"},{"id":"二垃圾对象的判定","depth":2,"text":"二、垃圾对象的判定"},{"id":"三垃圾回收算法","depth":2,"text":"三、垃圾回收算法"},{"id":"各平台gc算法","depth":2,"text":"各平台GC算法"}]}},"_type":"markdown","_id":"content:dotnet:2020-02-11-gc.md","_source":"content","_file":"dotnet/2020-02-11-gc.md","_extension":"md","date":"2020-02-11"},{"_path":"/dotnet/2020-02-12-netcore-mono-netframework","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"扒一扒.net、.net framework、mono和Unity","description":"1.什么是CLR？CLR（Common Language Runtime）即公共语言运行时，是一个由多种编程语言使用的“运行时”，我的理解是就是运行环境，类似于jvm虚拟机的东西，只不过CLR并不关心你用的语言是什么，无论你用的是C#，或者C++等，当通过编译器编译后，都会转换为CLR可以识别的中间语言IL2.CLR的工作方式CLR是不和模块工作的，它和程序集工作，如下当加载了公共语言运行时时，电脑必须安装了.NET Framework,同时CLR会检测目标平台，如32位Windows，或64位windows，然后决定创建对应的进程；如图1-2，托管程序集同时包含元数据和IL，当编译器把源代码","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.什么是CLR？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CLR（Common Language Runtime）即公共语言运行时，是一个由多种编程语言使用的“运行时”，我的理解是就是运行环境，类似于jvm虚拟机的东西，只不过CLR并不关心你用的语言是什么，无论你用的是C#，或者C++等，当通过编译器编译后，都会转换为CLR可以识别的中间语言IL"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.CLR的工作方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CLR是不和模块工作的，它和程序集工作，如下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/v2-5efca0f8c5f31440e6d17c766a6cc6b6_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当加载了公共语言运行时时，电脑必须安装了.NET Framework,同时CLR会检测目标平台，如32位Windows，或64位windows，然后决定创建对应的进程；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如图1-2，托管程序集同时包含元数据和IL，当编译器把源代码转换为中间语言IL后，为了执行方法，CLR会把方法的IL转换为本机（native）CPU指令，即JIT（just in time“即时”）编译"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/v2-e12d13ed3e967c0b7463fb2764034d87_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在方法执行前，CLR会检测代码引用的所有类型，然后分配一个内部数据结构来管理引用访问，在这个数据结构中每个方法会有一个对应的记录项，每个记录项都包含地址，根据地址找到函数的实现，CLR将每个记录项都设置成（指向）一个内部的未编档函数，即JITCompiler当方法首次调用WriteLine时，JITCompiler会被调用，将方法的IL代码编译为本机的CPU指令。当方法第一次被调用时，JIT编译器会验证IL代码，当第二次时，由于第一次已经完成了验证和编译，所以第二次会直接执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.Mono"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"mono即基于.NET Framework 的开源实现，基于C#的ECMA标准，包含C#编译器和CLR。mono使C#拥有了跨平台的能力。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.为什么Mono能跨平台？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为它使用了CIL（Common Intermediate Language）的通用中间语言，也叫MSIL的指令集，CIL可以在任何支持CLI（Common Language Infrastructure）“通用语言基础结构”的环境下运行，由于CIL能运行在所有支持CLI的环境中，比如.net运行时或者mono运行时，也就是说和具体的平台或者CPU无关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".net从一个抽象上来说其实是一个理念，即使得多种语言编写的程序能够通过一个通用的runtime运行在不同的操作系统以及硬件平台上。但光有理念不行，还需要实现，我们这里把对于.net里面的某个实现叫做.net platform（比如.net framework就是一个在windows上实现的.net platform，mono则是一个跨平台的.net platform）。一个.net platform想要达成.net的目标，就需要一些组件，比如上图中CLR通用语言运行时，比如FCL基础类库，比如各种语言的编译器，编译器编译出来的东西想要能在CLR中运行，那也需要遵循一定的标准，这就是CLI和CIL，CIL规定了编译输出的规则，而CLI规定了编译器输入语言的规则，只有符合这种标准的语言才能编译成CIL语言运行在CLR中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了现在有了CIL和CLR，程序员可以用符合CLI的语言比如C#编写程序了，然后将其编译成CIL，最后在CLR中运行。但是问题来了，程序员开发程序的时候需要用到一些功能以及数据结构，不可能所有的功能细节都自己实现，不然开发成本也太高了，所以就需要提供一些基础类库，方便程序员进行开发，那么需要提供哪些基础类库呢？这也需要一个标准，而.Net Standard就是用于这个目的，它规定了某个.net platform需要提供哪些API给开发者。这样的话加入一个开发者在.net platform A（比如.net framework）上开发了一个项目，然后想迁移到.net platform B（比如Mono）上，那么只要两个platform实现了同一个.net standard那么源代码就无需修改可以直接编译运行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过还有一个问题，假如我有一台机器，装了.net platform A（比如.net framework）和.net platform B（比如Mono），那么我在A上编译出来的一个.net程序放到B上可以运行么？理论上应该没问题，毕竟CIL是统一的，虽然一个是A的CLR一个是B的CLR，但是它们都是用来处理CIL程序，就像java代码编译出来既可以运行在JVM上也可以运行在delvik上一样。然而实际上不一定，因为CIL本身也不是一成不变的，它也有自己的版本，看下面这个文档："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/bb822049.aspx","rel":["nofollow"]},"children":[{"type":"text","value":"https://msdn.microsoft.com/en-us/library/bb822049.aspx"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"里面的表格详细说明了.net framework和CLR版本之间的关系，从.net framework 2.0到3.5使用的是CLR 2.0，.net framework 4.0以后使用的是CLR 4.0，中间没有CLR 3.0版本。这也就意味着CIL语言本身也在发生变化，面向CLR 4.0编译出来的程序自然是不能运行在CLR 2.0上的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说那到底什么是.net framework呢？个人理解从抽象角度说.net framework是对.net标准（这个标准具体包括CLI，CIL，.net standard等）在windows平台上的一套实现，具体上说.net framework包含一整套解决方案，包含许多字组件，比如编译器、CLR、FCL等等，其中每个组件都有自己的版本，比如编译器有自己的版本用于适应不同版本的语言，比如.net framework 3.5的编译器只支持到C# 3.0，最新已经到C# 7.0了；每个版本的.net framework提供的FCL也在不断丰富，比如System.LINQ到.net framework 3.5才有；CLR的版本也会不同，之前已经说过了。因此.net framework的版本其实就是其组件版本的一个集合，高版本的.net framework中的每个子组件都进行了一定的版本更新。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实正常来说.net framework只是对.net标准的一套实现而已，其他的对于.net标准的实现完全可以将各种不同版本的组件组合起来用，比如我一套.net platform提供了.net framework 4.0的FCL和面向C# 6.0的编译器，但用的是CLR 2.0的运行时，这并没有什么问题，只要编译器和运行时匹配就行了（mono就是这么干的）。但是由于.net是微软提出来的而且.net framework是微软开发的，那别的.net platform实现自然就已.net framework为标杆，每个版本的.net framework都提供了一些新的features，支持.net framework x.x就是说这个.net platform实现了x.x版本.net framework的特性，比如下面是mono主页上的文档："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144055880.png"},"children":[]},{"type":"text","value":" "},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144129490.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到上面说的是.net 4.6 4.5，这里表示的其实是.net framework，这个图片的意思就是最新版本的mono已经实现了.net framework 4.6中支持C# 6的特性，以及此外还可以发现只有.net 3.5和2.0是mono完全实现了其所有特性。准确的说其实是mono实现了.net framework的大部分feature，并且还提供了一些mono自己的class library。Mono和.net framework大致有一个对应关系，如这篇文章所说："},{"type":"element","tag":"a","props":{"href":"http://www.cnblogs.com/zhaoqingqing/archive/2016/08/12/5762867.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.cnblogs.com/zhaoqingqing/archive/2016/08/12/5762867.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144146834.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个表似乎不完全正确，mono 2.0实现了System.LinQ组件，这个组件在.net 3.5中提供，所以mono 2.0对应的应该是.net 2.0/3.5，即两者之和。不过还是可以当做一个参考。所以说加入一个程序集是用.net framework 3.5构建的，引用了一些dll如system.core以及system.linq，那么要想把其导入mono项目中，就必须保证mono的版本高于2.0，不然会找不到相应的引用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有一点需要注意，网上很多讲.net版本的时候讲.net framework version和CLR version混为一谈，有些时候说的.net 2.0指的其实是CLR 2.0。另外有些人把System.Environment.Version误以为是.ne framework版本，其实不是，msdn上说的很明确，这个值指的是CLR的版本："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144202709.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外还有一点值得注意，在vs中构建一个.net framework 3.5的项目时是，引用的System.dll是在系统的.net v2.0目录下的，也就是说.net framework不是独立的，而是依赖于.net framework 2.0.不过.net 4.0以后的版本好像就不是这样了，每次新版本都是独立的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后谈一下Unity，Unity为了跨平台使用了Mono，其使用的Mono版本可以通过代码或者命令行方式获得，unity forum上已经有牛人说明了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://answers.unity3d.com/questions/259448/how-to-determine-mono-version-of-unity-.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://answers.unity3d.com/questions/259448/how-to-determine-mono-version-of-unity-.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我自己的测试结果是mono 2.0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144215834.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查了一下mono官网，mono 2.0是08年的老古董（Unity居然还在用，貌似是版权问题，没有深究），而用vs打开一下Unity中的脚本，查看一下项目构建文件.csproj："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144232772.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到Unity用的是.net 3.5，所以难道Unity的脚本是用.net framework 3.5构建的？显然不是。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们知道vs有一个东西叫VSTU，它最大的作用就是可以用vs的断点调试功能调试Unity Editor。Unity中的脚本在vs中打开的时候会构建一个VSTU项目。VSTU项目虽然跟普通VS项目看上去很像，但其实VSTU项目本质上并不是真正的vs项目，如果你右键项目->属性是没有反应的（VSTU 2.1以前有反应，之后就禁用了），而且右键项目中的引用也不会有添加引用选项，其实VSTU是把vs当做了一个功能强大的编辑器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但VSTU不只是利用了VS进行语法检查这么简单，它的另一个作用就是断点调试。在没有断点调试的情况下，Unity使用自己的编译器进行编译，生成Assembly-CSharp.dll（在/Library/目录中），点击Play按钮的时候用的是这个dll，而用VS进行断点调试的时候则会用VS的编译器编译出Assembly-CSharp.dll以及pdb文件，在\\Temp\\UnityVS_obj\\Debug\\目录中，此时点击Play用的就是这个dll。当然build出exe的时候用的还是自己的编译器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"VSTU对项目进行了限制，不能直接在VS中添加新的dll，但可以拷贝到Unity项目的Asset目录下，这样Unity会重新构建VSTU项目，把拷进去的dll显示在引用列表里面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"VSTU构建的项目是基于.net framework 3.5的。因为Unity用的是mono 2.0啊，mono 2.0实现的feature包括.net framework 2.0和3.5，而UnityEngine.dll引用了System.Core.dll，而这个dll在.net framework 3.5才有，如果是是基于.net framework 2.0构建，那么第一有些mono 2.0支持的feature在vs里面就会找不到，另外也无法断点调试，因为编译通不过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实也可以在Unity的安装目录中寻找一些端倪，在windows下为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C:\\Program Files\\Unity\\Editor\\Data\\Mono\\lib\\mono\\2.0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个目录2.0目测就是mono的版本，目录中有很多dll，比如System.*.dll，这说明unity自带了mono项目，提供了mono 2.0中实现的基础类库。虽然Unity的脚本可以在像VS以及MonoDeveloper中打开，但是在build的时候用的还是Unity自带的Mono中的编译器，而Mono 2.0仅支持到C# 3.0，所以有些最新的语法在Unity里面是无法编译通过的（Unity 5.3.5 p8提供了一个新的编译器mono 4.4用于测试，但是似乎没有下文了）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总结一下就是，Unity使用的是mono 2.0，支持C# 3.0，提供与.net framework 3.5/2.0 API兼容的类库（mono 2.0实现了.net framework 2.0 + 3.5的feature，但是没有实现.net framework 3.0的WPF的feature，所以官网的说法是**.Net 2.0/3.5 framework profile**），使用了与CLR 2.0兼容的mono runtime，因此用vs构建Unity的dll需要.net framework 3.5以下，不然runtime不兼容；如果要用到UnityEngine等Unity的功能必须用.net framework 3.5这个版本，不然vs项目找不到System.Core.dll，无法通过编译，如果只是一些工具类，不需要引用UnityEngine.dll，那么用.net framework 2.0构建是可以的。vs只是一个第三方构建工具，想要构建出Unity能用的dll就不能使用Unity（Mono 2.0）不支持的feature。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后有一点之前一直在困扰我，但今天稍微有点想通了，就是Unity的Player Setting里面有个API compability Level："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144252210.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个只有两个选项：.Net 2.0和.Net 2.0 Subnet，这个说实话让人很不解，从字面上讲是指API兼容，那兼容到.net 2.0难道是指兼容.net framework 2.0的FCL API？但Unity可以用到.net framework 3.5的一些库啊。网上找了一通以后发现了如下网址："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/412/Documentation/ScriptReference/MonoCompatibility.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/412/Documentation/ScriptReference/MonoCompatibility.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以及这个Question："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity3d.com/threads/unity-supports-c-3-5-or-2-0.111440/","rel":["nofollow"]},"children":[{"type":"text","value":"https://forum.unity3d.com/threads/unity-supports-c-3-5-or-2-0.111440/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中有一句话很关键："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"The 2.0 there is likely a good reflection of what you have at least"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以梳理一下就是.Net 2.0和.Net 2.0 Subnet是指编写的C#代码能够引用的函数集合的不同，如果选择了subset那么dll就不会被导入到项目中来。比如同一个项目用.Net 2.0和.Net 2.0 Subnet构建出来的目录如下，可以很明显看到两者的差别。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144306179.png"},"children":[]},{"type":"text","value":"  "},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-12-netcore-mono-netframework/20170423144321069.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当新建一个Unity项目时，只会有一些核心的dll会被导入到项目中，其他的dll需要从外部拷贝到项目的Asset文件夹下，VSTU项目中是不能直接添加引用的，个人感觉VSTU对项目的限制有点多，像是把开发者当成傻子，因为你在用Unity那么这些功能就给你禁用掉，不过目测可以通过修改.sln或者.csproj文件来实现一些特殊需要。那.net framework 3.5呢？其实Unity支持的是.net framework 2.0 + 3.5，跳过了3.0，因为3.0是WPF的，Unity不需要，.net 2.0指的是你至少可以用哪些feature。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity最近因为加入了.Net基金会，出了几个用最新mono的测试版："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity3d.com/threads/upgraded-mono-net-in-editor-on-5-5-0b4.433541/","rel":["nofollow"]},"children":[{"type":"text","value":"https://forum.unity3d.com/threads/upgraded-mono-net-in-editor-on-5-5-0b4.433541/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 5.5.0 b4里面API compability Level增加了一个4.6选项，其实是把原来的mono 2.0换成mono 4.6进行测试，mono 4.6支持C# 6.0，并且开发者可以使用.net 4.6的API写程序，然而也不知道什么时候能有稳定版。而且mono都快要被淘汰了，以后目测都是IL2CPP了。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/w-wfy/p/7450167.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/w-wfy/p/7450167.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/wzjssssssssss/article/details/80196314","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/wzjssssssssss/article/details/80196314"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-02-12-netcore-mono-netframework.md","_source":"content","_file":"dotnet/2020-02-12-netcore-mono-netframework.md","_extension":"md","date":"2020-02-12"},{"_path":"/dotnet/2020-02-13-csharp-run","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"c#编译和运行启动原理","description":"用C#编写的源代码被编译为一种符合CLI规范的中间语言（IL）。IL代码与资源（例如位图和字符串）一起作为一种称为程序集的可执行文件存储在磁盘上，通常具有的扩展名为.exe（应用程序）或.dll（库）。程序集包含清单，它提供有关程序集的类型、版本、区域性和安全要求等信息。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用C#编写的源代码被编译为一种符合CLI规范的中间语言（IL）。IL代码与资源（例如位图和字符串）一起作为一种称为程序集的可执行文件存储在磁盘上，通常具有的扩展名为.exe（应用程序）或.dll（库）。程序集包含清单，它提供有关程序集的类型、版本、区域性和安全要求等信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行C#程序时，程序集将加载到CLR中，它可能会根据清单中的信息执行不同的操作。然后，如果符合安全要求，CLR就会执行实时（JIT）编译以将IL代码转换为本机机器指令。CLR还提供与自动垃圾回收、异常处理和资源管理有关的其他服务。由CLR执行的代码有时会称为“托管代码”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"["},{"type":"element","tag":"img","props":{"alt":"什么是C#语言？作用有哪些？","src":"/images/2020-02-13-csharp-run/094920_15170513.gif"},"children":[]},{"type":"text","value":"]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-13-csharp-run/v2-757e0e6e8813e7441cd758121e564729_1440w.jpg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"编译器"},"children":[{"type":"text","value":"编译器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/","rel":["nofollow"]},"children":[{"type":"text","value":"CSC.exe"}]},{"type":"text","value":"是C＃编译器，可以编译您的C＃代码并生成可执行（.exe）文件，动态链接库（.dll）或代码模块（.netmodule）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild","rel":["nofollow"]},"children":[{"type":"text","value":"MSBuild"}]},{"type":"text","value":"是Microsoft Build Engine，可用于从Visual Studio生成"},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/ide/solutions-and-projects-in-visual-studio","rel":["nofollow"]},"children":[{"type":"text","value":"项目和解决方案"}]},{"type":"text","value":" 。 此外，即使我编写了一些.cs文件和一个自定义项目文件（.xxproj）来构建它们，我们也可以使用msbuild.exe并使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"msbuild xxx.xxproj"}]},{"type":"text","value":"类的命令来构建它们。 请参阅"},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/msbuild/walkthrough-creating-an-msbuild-project-file-from-scratch","rel":["nofollow"]},"children":[{"type":"text","value":"本文档"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"它们之间的关系："}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果我只有几个.cs文件，并且想要编译它们以输出.exe及其它内容，那么csc.exe就足够了。 "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe","rel":["nofollow"]},"children":[{"type":"text","value":"在命令行中"}]},{"type":"text","value":" （ "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"by cmd.exe or other things"}]},{"type":"text","value":" ） 使用它来编译代码。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果创建项目文件（.xxproj）以更好地控制资源，.cs文件和其他文件，则可以"},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-command-line-reference","rel":["nofollow"]},"children":[{"type":"text","value":"在命令行中使用msbuild"}]},{"type":"text","value":"来构建它们以输出.exe或其他内容。 我们应该知道的一点是，msbuild.exe不仅可以构建C＃代码，而且还可以构建"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VB.net, C++, F#"}]},{"type":"text","value":" ...当我使用msbuild使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"msbuild xx.csproj"}]},{"type":"text","value":"类的命令来构建C＃代码时，它将"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"call csc.exe to compile C# code and pass parameters read from the .csproj file to it"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尽管msbuild是Visual Studio中的构建系统，但它并不依赖于Visual Studio。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"您可能想知道msbuild传递给特定构建的csc的信息。 在这种情况下，只需使用msbuild的详细程度开关即可："}]},{"type":"element","tag":"pre","props":{"code":"msbuild MyProject.csproj /target:rebuild /verbosity:diag\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"msbuild MyProject.csproj /target:rebuild /verbosity:diag\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请参阅"},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/msbuild/obtaining-build-logs-with-msbuild?view=vs-2015&redirectedfrom=MSDN","rel":["nofollow"]},"children":[{"type":"text","value":"使用MSBuild获取构建日志"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"h3","props":{"id":"mono系列"},"children":[{"type":"text","value":"mono系列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mono C＃编译器被认为是C＃1.0，C＃2.0，C＃3.0，C＃4.0，C＃5.0和C＃6.0（ECMA）的完整功能，并且部分支持C＃7。"},{"type":"element","tag":"a","props":{"href":"https://www.mono-project.com/docs/about-mono/languages/csharp/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.mono-project.com/docs/about-mono/languages/csharp/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从历史上看，存在相同编译器的各种版本。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"gmcs：编译器以2.0 mscorlib为目标。引用2.0概要文件库（在.NET 2.0和.NET 3.5中定义的API）并公开完整的C＃3.0语言。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"smcs：以2.1 mscorlib为目标的编译器，以构建Moonlight应用程序。 引用2.1概要文件库（为Silverlight定义的API）并公开完整的C＃3.0语言。这是用于创建Silverlight / Moonlight应用程序的编译器。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"dmcs：编译器针对4.0 mscorlib。引用4.0概要文件库（.NET 4.0中定义的API）并支持C＃4.0。"}]}]},{"type":"element","tag":"h2","props":{"id":"编译为-msil"},"children":[{"type":"text","value":"编译为 MSIL"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"编译为托管代码时，编译器将源代码转换为 Microsoft 中间语言 (MSIL)，这是一组独立于 CPU 且可以有效地转换为本机代码的说明。 MSIL 包括有关加载、存储、初始化和调用对象方法的说明，以及有关算术和逻辑运算、控制流、直接内存访问、异常处理和其他操作的说明。 代码可以运行之前，必须将 MSIL 转换为特定于 CPU 的代码，通常通过 "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_msil_to_native_code","rel":["nofollow"]},"children":[{"type":"text","value":"实时 (JIT) 编译器"}]},{"type":"text","value":"实现。 由于公共语言运行时为其支持的每个计算机基础结构提供一个或多个 JIT 编译器，同一组的 MSIL 可以在任何受支持的基础结构上进行 JIT 编译和运行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当编译器生成 MSIL 时，它还生成元数据。 元数据描述代码中的类型，包括每种类型的定义、每种类型的成员的签名、代码引用的成员以及运行时在执行时间使用的其他数据。 MSIL 和元数据包含在一个可移植的可执行 (PE) 文件中，该文件基于且扩展已发布的 Microsoft PE 和历来用于可执行内容的通用对象文件格式 (COFF)。 容纳 MSIL 或本机代码以及元数据的这种文件格式使操作系统能够识别公共语言运行时映像。 文件中元数据的存在以及 MSIL 使代码能够描述自身，这意味着将不需要类型库或接口定义语言 (IDL)。 运行时在执行期间会根据需要从文件中查找并提取元数据。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"什么是非托管代码(unmanaged code)？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"非托管代码，直接编译成目标计算机码，在"}]},{"type":"element","tag":"a","props":{"href":"http://baike.baidu.com/view/159628.htm","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"公共语言运行库"}]}]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"环境的外部，由操作系统直接执行的代码，代码必须自己提供垃圾回收，类型检查，安全支持等服务。如需要内存管理等服务，必须显示调用操作系统的接口，通常调用Windows SDK所提供的API来实现内存管理。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当项目选择名字以MFC，ATL，Win32开头的项目类型，那么这个项目所产生的就是非托管程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"非托管代码就是在Visual Studio .NET 2002发布之前所创建的代码。例如Visual Basic 6, Visual C++ 6, 最糟糕的是，连那些依然残存在你的硬盘中、拥有超过15年历史的陈旧C编译器所产生的代码都是非托管代码。托管代码直接编译成目标计算机的机械码，这些代码只能运行在编译出它们的计算机上，或者是其它相同处理器或者几乎一样处理器的计算机上。非托管代码不能享受一些运行库所提供的服务，例如安全和内存管理等。如果非托管代码需要进行内存管理等服务，就必须显式地调用操作系统的接口，通常来说，它们会调用Windows SDK所提供的API来实现。就最近的情况来看，非托管程序会通过COM接口来获取操作系统服务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"跟Visual Studio平台的其他编程语言不一样，Visual C++可以创建非托管程序。当你创建一个项目，并且选择名字以M FC，ATL或者Win32开头的项目类型，那么这个项目所产生的就是非托管程序。"}]}]},{"type":"element","tag":"h2","props":{"id":"将-msil-编译为本机代码"},"children":[{"type":"text","value":"将 MSIL 编译为本机代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"运行 Microsoft 中间语言 (MSIL) 前，必须根据CLR公共语言运行时将其编译为目标计算机基础结构的本机代码。 .NET Framework 提供两种方法来执行此转换："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":".NET Framework 实时 (JIT) 编译器。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":".NET Framework "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator","rel":["nofollow"]},"children":[{"type":"text","value":"Ngen.exe（本机映像生成器）"}]},{"type":"text","value":"。"}]}]},{"type":"element","tag":"h3","props":{"id":"由-jit-编译器编译"},"children":[{"type":"text","value":"由 JIT 编译器编译"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在加载和执行程序集的内容时，JIT 编译在应用程序运行时按需将 MSIL 转换为本机代码。 由于公共语言运行时为每个受支持的 CPU 基础结构提供 JIT 编译器，开发人员可以构建一组 MSIL 程序集，这些程序集可以进行 JIT 编译并可在具有不同计算机基础结构的不同计算机上运行。 但是，如果你的托管代码调用特定于平台的本机 API 或特定于平台的类库，它将仅在该操作系统上运行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JIT 编译将执行期间可能永远不会调用的某些代码的可能性考虑在内。 它根据需要在执行期间转换 MSIL，而不是使用时间和内存来将 PE 文件中所有 MSIL 转换为本机代码，并在内存中存储生成的本机代码，以便该进程上下文中的后续调用可以对其进行访问。 加载类型并将其初始化时，加载程序创建并将存根附加到类型中的每个方法。 第一次调用某个方法时，存根将控件传递给 JIT 编译器，后者将该方法的 MSIL 转换为本机代码，并将存根修改为直接指向生成的本机代码。 因此，对 JIT 编译的方法的后续调用会直接转到本机代码。"}]},{"type":"element","tag":"h3","props":{"id":"使用-ngenexe-的安装时代码生成"},"children":[{"type":"text","value":"使用 NGen.exe 的安装时代码生成"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于在调用该程序集中定义的各个方法时，JIT 编译器将程序集的 MSIL 转换为本机代码，因此它在运行时中对性能产生负面影响。 在大多数情况下，这种性能降低的程度是可以接受的。 更为重要的是，由 JIT 编译器生成的代码会绑定到触发编译的进程上。 它无法在多个进程之间进行共享。 若要允许生成的代码跨应用程序的多个调用或跨共享一组程序集的多个进程进行共享，则公共语言运行时支持预编译模式。 这种预编译模式使用 "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator","rel":["nofollow"]},"children":[{"type":"text","value":"Ngen.exe（本机映像生成器）"}]},{"type":"text","value":"将 MSIL 程序集转换为本机代码，非常类似 JIT 编译器执行的操作。 但是，Ngen.exe 的操作在三个方面不同于 JIT 编译器的操作："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"它在运行应用程序之前而非运行该应用程序时，将 MSIL 转换为本机代码。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"它一次编译整个程序集，而不是一次编译一种方法。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"它将本机映像缓存中生成的代码作为磁盘上的文件保存。"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上每个人都知道的是，所有.Net语言都将被编译成为一个叫做IL汇编的中间语言。但是计算机是如何执行这个中间代码的，却是很多人不知道，甚至理解错误了的。JIT是.NET程序运行的重要部件之一，全称是即时编译器。很多人都以为JIT其实就是跟Java VM差不多的东西，是一个Interpreter，在运行时读取IL汇编代码，然后模拟成x86代码（也就是俗称的虚拟机）。但是事实上，.NET使用的是更为高级的技术。 .Net程序被加载入内存以后，当某段IL代码被第一次运行的时候，JIT编译器就会将这段IL代码，全部编译成本地代码，然后再执行。这也就是为什么.NET程序第一次运行都启动很慢的原因！ 随.NET库，微软还附带了一个工具，可以事先将.NET程序所有的IL代码都编译成本地代码并保存在缓存区中，这样一来，这个程序就跟c++编译的一模一样了，没有任何区别，运行时也可以脱离JIT了（这里不要混淆了，这里不是说可以脱离.NET库，而是说不需要在进行即时编译这个过程了）。所以，请不要将.NET和Java混为一谈，两个的运行效率根本不是一个等级的！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JIT的优化指的是可以针对本地CPU，在编译时进行优化。传统程序在编译时，为了保证兼容性，通常使用最通用的指令集（比如古老的386指令集）来编译。而JIT知道CPU的具体类型，可以充分利用这些附加指令集进行编译，这样的性能提升是很可观的。"}]}]},{"type":"element","tag":"h1","props":{"id":"运行"},"children":[{"type":"text","value":"运行"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。那Windows是怎么区分可执行文件和非可执行文件的呢？我们调用LoadLibrary传递了一个文件名，系统是如何判断这个文件是一个合法的动态库呢？这就涉及到PE文件结构了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C#生成的exe既然是window下可执行文件，那也就是标准的PE文件，和普通win32的exe文件格式一样。我们来看下exe文件的格式："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"dll文件本质上和exe一样，只是少了入口函数。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-13-csharp-run/884430-20160313213206835-2135598609.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MS-DOC MZ Header和MS-DOS Stub是为了兼容DOS系统存在的，目的是使这个exe在DOS下执行时弹出一个提示\"This program cannot be run in DOS mode\"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PE Header包含了这个文件的一些信息，如：文件创建日期，文件类型，Section的数量，Optional Header的大小等等。详细可以参考Winnt.h里的结构_IMAGE_FILE_HEADER。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PE Optional Header则包含了文件的版本号以及重要的基地址和AddressOfEntryPoint（RVA-Relative Virtual Address)，这是程序执行的入口地址，双击exe后就从这里开始执行。对C#程序来说，这里指向的是.net的核心库MsCorEE.dll的_CorExeMain()函数。当然这是针对XP系统的，XP以后的系统，OS Loader已经可以判断出这个PE是否包含CLR头来决定是否运行MsCorEE.dll的_CorExeMain()函数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Section有很多，包括代码节，数据节等，C#程序会把CLR头，元数据，IL放在这里面。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CLR是什么呢，全称Common Language Runtime，公共语言运行时，CLR主要是管理程序集，托管堆内存，异常处理和线程同步等等。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CLR头具体可以参考CorHdr.h中的IMAGE_COR20_HEADER结构，如下："}]},{"type":"element","tag":"pre","props":{"code":"typedef struct IMAGE_COR20_HEADER\n    {\n        // CLR版本信息\n        ULONG cb;\n        USHORT MajorRuntimeVersion;\n        USHORT MinorRuntimeVersion;\n\n        IMAGE_DATA_DIRECTORY MetaData; //元数据\n        ULONG Flags;\n        ULONG EntryPointToken;  //入口函数Main的标识\n\n\n        IMAGE_DATA_DIRECTORY Resources;  //资源\n        IMAGE_DATA_DIRECTORY StrongNameSignature;  //强名称标识\n\n\n        // Regular fixup and binding information\n        IMAGE_DATA_DIRECTORY CodeManagerTable;\n        IMAGE_DATA_DIRECTORY VTableFixups;\n        IMAGE_DATA_DIRECTORY ExportAddressTableJumps;\n\n        // Precompiled image info (internal use only - set to zero)\n        IMAGE_DATA_DIRECTORY ManagedNativeHeader;\n\n    }\n    IMAGE_COR20_HEADER;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"typedef struct IMAGE_COR20_HEADER\n    {\n        // CLR版本信息\n        ULONG cb;\n        USHORT MajorRuntimeVersion;\n        USHORT MinorRuntimeVersion;\n\n        IMAGE_DATA_DIRECTORY MetaData; //元数据\n        ULONG Flags;\n        ULONG EntryPointToken;  //入口函数Main的标识\n\n\n        IMAGE_DATA_DIRECTORY Resources;  //资源\n        IMAGE_DATA_DIRECTORY StrongNameSignature;  //强名称标识\n\n\n        // Regular fixup and binding information\n        IMAGE_DATA_DIRECTORY CodeManagerTable;\n        IMAGE_DATA_DIRECTORY VTableFixups;\n        IMAGE_DATA_DIRECTORY ExportAddressTableJumps;\n\n        // Precompiled image info (internal use only - set to zero)\n        IMAGE_DATA_DIRECTORY ManagedNativeHeader;\n\n    }\n    IMAGE_COR20_HEADER;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"元数据很重要，验证代码类型安全，GC的对象引用跟踪还有我们常用的反射都需要用到元数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"元数据主要由定义表，引用表，清单表组成。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义表包括应用所有的类型，方法，字段，属性，参数，事件的定义,代码里任何的定义项都可以在这个表里找到，反射就是靠这个表只要一个名字就能得到属性或函数。运行时的类型安全检查也离不开它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"引用表包括程序集，类型和成员的引用，我们知道GC在回收内存时先默认认为所有对象都是垃圾，然后通过线程栈上的根（cpu寄存器，局部变量，参数，静态变量）找引用的对象，能找到的说明还在使用就去掉垃圾标记，这个表可以让GC在回收内存时方便从根找到所有引用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"清单表主要是程序集，文件，资源的定义。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在来看看双击后是怎样运行的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-13-csharp-run/884430-20160313222148397-1732805152.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"双击文件后OS Loader加载PE文件并解析，在PE Optional Header里找到基地址和RVA，通过这两个确定了程序的入口地址，这个地址指向MsCorEE.dll的_CorExeMain()，执行它。_CorExeMain()开始执行，选择加载合适版本的CLR，CLR开始运行，CLR运行时会分配一个连续的地址空间用作托管堆，并用一个指针NextObjPtr指到开始位置，下次分配内存时就从指针指的位置开始。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CLR运行后从CLR头里找到应用程序入口标识，也就是Main()方法的MethodDefToken，通过这个标识在元数据表MethodDef里找到Main方法的偏移位置，这样就可以找到Main()的IL代码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CLR检查Main方法里面是否有没加载的类型，没有的话就加载进来并在托管堆上建一个类型对象，类型对象包含静态字段，方法，基类的引用。然后给类型的方法表里每个方法一个存根，存根是用于标识是否被JIT编译过。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JIT: just-in-time Compiler，即时编译器。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JIT编译之前CLR会对Main方法的代码进行验证，确保类型安全且元数据正确，一切没问题后先检查类型方法表里这个方法的存根，不为空的话表示已经编译过就不需要再次编译，没有的话JIT把这段IL代码编译成本地代码保存到内存中并方法表的存根做上标记，然后JIT返回编译前的位置并把原来CLR指向JIT的地址修改为指向本地代码的地址，这样函数的本地代码开始执行。程序执行到哪里就编译到哪里，没有执行到的就不会加载和编译，同样的代码再次执行的话就直接在内存里拿了，这也是为什么第一次运行C#时比较慢而后面就快的原因。这样就开始陆续执行所有的代码，程序也就跑起来了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在内存上，运行线程会把函数的参数和局部变量压入线程栈上，栈上的空间默认是1M，方法的参数和局部变量都会压到函数的栈帧上，方法里的对象在托管堆NextObjPtr指向的位置分配内存并把内存地址存到栈上的局部变量里。CLR会给托管堆上的每个对象包括对象类型都添加两个字段，一个对象类型指针，一个同步块索引。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说起栈帧，大家在调试代码时应该都喜欢用CallStack吧，这可以通过看调用栈很方便来定位出问题的具体原因，这个CallStack也就是方法的栈帧的具体显示，一级一级的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对象类型指针从字面上就很容易知道跟类型有关。CLR刚开始运行时就分配了一个Type的对象类型，他的对象类型指针指向自己，后面创建的对象类型的对象类型指针指针就指向这个Type，而new出来的对象的对象类型指针就指向它的类型，这样所有对象都能找到自己的类型使CLR在运行时能确保类型安全。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同步块索引的格式是前6个标志位加后面26位内容（32位系统），作用则有好几个。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\1. 调用对象的gethashcode()后标志位改变一位，后26位会存储对象的hashcode，保证对象生命周期内hashcode的唯一；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\2. lock时用到，CLR会维护一个同步块数组，每项由一个指向同步块的指针和对象指针组成，lock时同样改变标识位，然后去同步块数组找一个闲置项，后26则变成这项在数组中的索引，有人要问了，刚才hashcode不是用了这26位吗，现在变了，hashcode岂不是丢了。确实，hashcode在lock之后不能直接存到索引了，不过同步块中专门准备了一个字段用来存hashcode，所以可以转移到同步块中，这样设计是为了节省内存，因为大部分情况下是不用lock的，也就不需要增加多余的同步块。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外为什么是索引而不是地址呢，因为同步块数组的大小不是固定的，随着对象的增多而变大，在内存上的位置可能会发生变化，所以用索引就不用管数组在哪个位置了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当线程进入lock后检查同步块的m_motion，发现没有标识则进入lock区域并把标识改变，如果已经有同一个线程进去则把计数器加1，如果已经有其他线程则等待。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\3. 垃圾回收时的标识，GC触发时首先认为所有的对象都是垃圾，由局部变量，寄存器，静态变量这些根向上找，凡是包含的对象都认为还有引用，在同步块索引上修改一位标识，当所有对象都遍历过后没有标识的对象就会被清掉，然后再是整理内存、修改引用地址等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看个简单的例子，只用于演示，不考虑合理性："}]},{"type":"element","tag":"pre","props":{"code":"using System;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int height = 170;\n            int weight = 60;\n            People.Find();\n            People developer = new Developer()(height, weight);\n            bool isHealthyWeight = developer.IsHealthyWeight();\n            bool isRich = developer.IsRich();\n        }\n    }\n\n    class People\n    {\n        int _height;\n        int _weight;\n\n        public People(int height, int weight)\n        {\n            _height = height;\n            _weight = weight;\n        }\n\n        public virtual bool IsRich();\n\n        public bool IsHealthyWeight()\n        {\n            var healthyWeight = (Height - 80) * 0.7;\n            return Weight <= healthyWeight * 1.1 && Weight >= healthyWeight * 0.9;\n        }\n\n        public static string Find(string id) { return \"\"; }\n    }\n\n    class Developer : People\n    {\n        public Developer(int height, int weight) : base(height, weight)\n        { }\n\n        public override bool IsRich()\n        {\n            return false;\n        }\n    }\n    \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int height = 170;\n            int weight = 60;\n            People.Find();\n            People developer = new Developer()(height, weight);\n            bool isHealthyWeight = developer.IsHealthyWeight();\n            bool isRich = developer.IsRich();\n        }\n    }\n\n    class People\n    {\n        int _height;\n        int _weight;\n\n        public People(int height, int weight)\n        {\n            _height = height;\n            _weight = weight;\n        }\n\n        public virtual bool IsRich();\n\n        public bool IsHealthyWeight()\n        {\n            var healthyWeight = (Height - 80) * 0.7;\n            return Weight <= healthyWeight * 1.1 && Weight >= healthyWeight * 0.9;\n        }\n\n        public static string Find(string id) { return \"\"; }\n    }\n\n    class Developer : People\n    {\n        public Developer(int height, int weight) : base(height, weight)\n        { }\n\n        public override bool IsRich()\n        {\n            return false;\n        }\n    }\n    \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-13-csharp-run/884430-20160313222410850-1585024295.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"*"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图片不清楚可以放大看"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先判断类型是否都加载，用到了int，bool，string，这些是在mscorlib.dll程序集的system命名空间下，所以先加载mscorlib.dll程序集，再把int，bool，string加到类型对象里。另外还有我们自己定义的Developer和People，也把类型对象创建好，另外也别忘了基类object，也要加载进来。（实际上还有double啊，这里就没画了）另外继承类的类型对象里面都有个字段指向基类，所以才能往上执行到基类方法表里的方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"局部变量都在线程栈上，Find()方法是静态方法，直接去People类型对象的方法表里去找，找到后看是否有存根标识，没有的话做JIT编译，有的话直接运行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"developer的实例化虽然是用People定义的，但实例还是Developer，所以developer的类型对象指针指向Developer，对象里除了类型对象指针还有实例字段，包括基类的。内存分配在托管堆上，并把地址给到线程栈上的变量中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虚函数也一样，在运行时已经确定是Developer，所以会调用Developer方法表里的IsRich方法，一样先JIT，再运行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上就是一个简单的C#程序的运行过程和在内存上的表现，本篇主要内容来自CLR via C#这本书"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/brookshi/p/5273281.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/brookshi/p/5273281.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_to_msil","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_to_msil"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/standard/clr","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-cn/dotnet/standard/clr"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/qtiger/p/11176575.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/qtiger/p/11176575.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"编译器","depth":2,"text":"编译器","children":[{"id":"mono系列","depth":3,"text":"mono系列"}]},{"id":"编译为-msil","depth":2,"text":"编译为 MSIL"},{"id":"将-msil-编译为本机代码","depth":2,"text":"将 MSIL 编译为本机代码","children":[{"id":"由-jit-编译器编译","depth":3,"text":"由 JIT 编译器编译"},{"id":"使用-ngenexe-的安装时代码生成","depth":3,"text":"使用 NGen.exe 的安装时代码生成"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-02-13-csharp-run.md","_source":"content","_file":"dotnet/2020-02-13-csharp-run.md","_extension":"md","date":"2020-02-13"},{"_path":"/dotnet/2020-05-29-abp-start","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"abp新建项目指南","description":"替换数据库为mysql替换mysql,Dothass.Blog.EntityFrameworkCore项目中<PackageReference Include=\"Volo.Abp.EntityFrameworkCore.MySQL\" Version=\"2.8.0\" />\n删除之前的迁移目录修改连接字符串 项目Dothass.Blog.DbMigrator和Dothass.Blog.Web.. //详情请见https://www.connectionstrings.com/mysql/\n \"ConnectionStrings\": {\n    \"Default\": server=localhost","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"替换数据库为mysql"},"children":[{"type":"text","value":"替换数据库为mysql"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"替换mysql,Dothass.Blog.EntityFrameworkCore项目中"}]}]},{"type":"element","tag":"pre","props":{"code":"<PackageReference Include=\"Volo.Abp.EntityFrameworkCore.MySQL\" Version=\"2.8.0\" />\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<PackageReference Include=\"Volo.Abp.EntityFrameworkCore.MySQL\" Version=\"2.8.0\" />\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"删除之前的迁移目录"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"修改连接字符串 项目"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Dothass.Blog.DbMigrator"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Dothass.Blog.Web"}]},{"type":"text","value":".."}]}]},{"type":"element","tag":"pre","props":{"code":" //详情请见https://www.connectionstrings.com/mysql/\n \"ConnectionStrings\": {\n    \"Default\": server=localhost;port=3306;database=dothass.blog;uid=root;password=123456\"\n },\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" //详情请见https://www.connectionstrings.com/mysql/\n \"ConnectionStrings\": {\n    \"Default\": server=localhost;port=3306;database=dothass.blog;uid=root;password=123456\"\n },\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生成新的迁移,nuget包管理器.默认项目设置为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Dothass.Blog.EntityFrameworkCore.DbMigrations"}]}]}]},{"type":"element","tag":"pre","props":{"code":"Add-Migration Init\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Add-Migration Init\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相关链接: "},{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Entity-Framework-Core-MySQL","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.abp.io/zh-Hans/abp/latest/Entity-Framework-Core-MySQL"}]}]},{"type":"element","tag":"h1","props":{"id":"初始化项目"},"children":[{"type":"text","value":"初始化项目"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将三个项目copy到程序中.然后在web项目中添加依赖"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"typeof(AbpExtensionWebModule)"}]},{"type":"text","value":"即可"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"修改migrationservice,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DotHass.Blog.Domain"}]},{"type":"text","value":"项目下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BlogDbMigrationService"}]}]}]},{"type":"element","tag":"pre","props":{"code":"  private async Task SeedDataAsync(Tenant tenant = null)\n  {\n        Logger.LogInformation($\"Executing {(tenant == null ? \"host\" : tenant.Name + \" tenant\")} database seed...\");\n\n        //IdentityDataSeedContributor : IDataSeedContributor ---> IIdentityDataSeeder\n        //手动实例化上下文,来设置admin的email和密码..或者替换IIdentityDataSeeder的service\n        var seedContext = new DataSeedContext(tenant?.Id);\n        var configurationSection = _configuration.GetSection(\"Identity\");\n        seedContext.WithProperty(\"AdminEmail\", configurationSection[\"AdminEmail\"]);\n        seedContext.WithProperty(\"AdminPassword\", configurationSection[\"AdminPassword\"]);\n\n        //PermissionDataSeedContributor : IDataSeedContributor  --->IPermissionDataSeeder\n        //为amidn添加权限 -- 一般来说不用改什么,但是需要在BlogDbMigratorModule中引用你设置权限的模块依赖..否则找不到你添加的权限\n\n        await _dataSeeder.SeedAsync(seedContext);\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  private async Task SeedDataAsync(Tenant tenant = null)\n  {\n        Logger.LogInformation($\"Executing {(tenant == null ? \"host\" : tenant.Name + \" tenant\")} database seed...\");\n\n        //IdentityDataSeedContributor : IDataSeedContributor ---> IIdentityDataSeeder\n        //手动实例化上下文,来设置admin的email和密码..或者替换IIdentityDataSeeder的service\n        var seedContext = new DataSeedContext(tenant?.Id);\n        var configurationSection = _configuration.GetSection(\"Identity\");\n        seedContext.WithProperty(\"AdminEmail\", configurationSection[\"AdminEmail\"]);\n        seedContext.WithProperty(\"AdminPassword\", configurationSection[\"AdminPassword\"]);\n\n        //PermissionDataSeedContributor : IDataSeedContributor  --->IPermissionDataSeeder\n        //为amidn添加权限 -- 一般来说不用改什么,但是需要在BlogDbMigratorModule中引用你设置权限的模块依赖..否则找不到你添加的权限\n\n        await _dataSeeder.SeedAsync(seedContext);\n    }\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行项目Dothass.Blog.DbMigrator初始化数据"}]}]},{"type":"element","tag":"h1","props":{"id":"关于客户端js"},"children":[{"type":"text","value":"关于客户端js"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行 yarn & gulp 将所有包都会将自己的资源复制到wwwroot/libs文件夹中. 否则一些模块例如博客的js时不会起作用的"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-05-29-abp-start.md","_source":"content","_file":"dotnet/2020-05-29-abp-start.md","_extension":"md","date":"2020-05-29"},{"_path":"/dotnet/2020-06-11-identityserver-use","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"2020 06 11 IdentityServer Use","description":"DotHass.Lobby.Domain\\IdentityServer\\IdentityServerDataSeedContributor.cs 中 CreateClientsAsync()","stitle":"IdentityServer使用指南","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DotHass.Lobby.Domain\\IdentityServer\\IdentityServerDataSeedContributor.cs 中 CreateClientsAsync()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会在dataseed的时候生成默认数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When I try to send a HTTPS POST request from a desktop (Servers are in production environment) the following message is displayed inside the console :"}]},{"type":"element","tag":"pre","props":{"code":"Error: unable to verify the first certificate\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Error: unable to verify the first certificate\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Postman -> Preferences -> General -> SSL certificate validation -> OFF"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"it works"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://localhost:5000/.well-known/openid-configuration","rel":["nofollow"]},"children":[{"type":"text","value":"https://localhost:5000/.well-known/openid-configuration"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/connect/token","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/connect/token"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"image-20200613165200371","src":"/images/2020-06-11-IdentityServer-use/image-20200613165200371.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/connect/userinfo","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/connect/userinfo"}]},{"type":"text","value":" 将type设置成bearer token,token填入上面获得的access_token"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200613165246959","src":"/images/2020-06-11-IdentityServer-use/image-20200613165246959.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.注意发布release后.配置表中的  ..如果配置错误将会认证失败"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"appsettings.json"}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"App\": {\n    \"SelfUrl\": \"http://localhost:5000\"\n  },\n  \"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;User Id=root;Password=123456;Database=dothass.blog\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"http://localhost:5000\"\n  },\n  \"IdentityServer\": {\n    \"Clients\": {\n      \"Blog_App\": {\n        \"ClientId\": \"Blog_App\"\n      }\n    }\n  }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"App\": {\n    \"SelfUrl\": \"http://localhost:5000\"\n  },\n  \"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;User Id=root;Password=123456;Database=dothass.blog\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"http://localhost:5000\"\n  },\n  \"IdentityServer\": {\n    \"Clients\": {\n      \"Blog_App\": {\n        \"ClientId\": \"Blog_App\"\n      }\n    }\n  }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"appsettings.Development.json"}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"App\": {\n    \"SelfUrl\": \"https://localhost:44377\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"https://localhost:44377\"\n  }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"App\": {\n    \"SelfUrl\": \"https://localhost:44377\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"https://localhost:44377\"\n  }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还要注意请求的域名是否一样,127.0.0.1或者localhost...可能返回结果即使一样.但是不能授权."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"a","props":{"href":"http://jwt.calebb.net/%E8%A7%A3%E6%9E%90%E7%9C%8B%E4%B8%8Baccess_token","rel":["nofollow"]},"children":[{"type":"text","value":"http://jwt.calebb.net/解析看下access_token"}]}]},{"type":"element","tag":"pre","props":{"code":"{\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592054993,\n exp: 1623590993,\n iss: \"http://127.0.0.1:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592054993,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592054993,\n exp: 1623590993,\n iss: \"http://127.0.0.1:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592054993,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"}]}]},{"type":"element","tag":"pre","props":{"code":"    {\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592055396,\n exp: 1623591396,\n iss: \"http://localhost:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592055396,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    {\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592055396,\n exp: 1623591396,\n iss: \"http://localhost:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592055396,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"}]}]},{"type":"element","tag":"h1","props":{"id":"错误"},"children":[{"type":"text","value":"错误"}]},{"type":"element","tag":"pre","props":{"code":"System.InvalidOperationException: IDX20803: Unable to obtain configuration from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.IO.IOException: IDX20804: Unable to retrieve document from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.\n ---> System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure.\n   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"System.InvalidOperationException: IDX20803: Unable to obtain configuration from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.IO.IOException: IDX20804: Unable to retrieve document from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.\n ---> System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure.\n   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看出来这些问题是和SSL证书有关，经过排查，发现IdentityServer4配置中：使用了"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"IP"}]},{"type":"text","value":"的形式配置的授权地址，但是SSL证书是以域名形式申请的，这就造成了SSL证书不能验证通过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决方法："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"将授权地址配置为域名:端口的形式"}]},{"type":"text","value":"，完美解决上述问题。注意域名为SSL证书申请时用到的域名。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"localhost使用的是开发证书,也是类似域名,127.0.0.1也是有问题的"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-06-11-IdentityServer-use.md","_source":"content","_file":"dotnet/2020-06-11-IdentityServer-use.md","_extension":"md","date":"2020-06-11"},{"_path":"/dotnet/2020-07-05-abp-database-user","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"关于abp的用户的一些问题","description":"abp的dbcontext是分成两种的,一个是程序运行的dbcontext,一个是数据迁移的dbcontext","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"数据迁移上下文"},"children":[{"type":"text","value":"数据迁移上下文"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp的dbcontext是分成两种的,一个是程序运行的dbcontext,一个是数据迁移的dbcontext"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundMigrationsDbContext.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Include modules to your migration db context */\n\n            builder.ConfigurePermissionManagement();\n            builder.ConfigureSettingManagement();\n            builder.ConfigureBackgroundJobs();\n            builder.ConfigureAuditLogging();\n            builder.ConfigureIdentity();\n            builder.ConfigureIdentityServer();\n            builder.ConfigureFeatureManagement();\n            builder.ConfigureTenantManagement();\n\n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n            builder.ConfigureBlogging();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Include modules to your migration db context */\n\n            builder.ConfigurePermissionManagement();\n            builder.ConfigureSettingManagement();\n            builder.ConfigureBackgroundJobs();\n            builder.ConfigureAuditLogging();\n            builder.ConfigureIdentity();\n            builder.ConfigureIdentityServer();\n            builder.ConfigureFeatureManagement();\n            builder.ConfigureTenantManagement();\n\n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n            builder.ConfigureBlogging();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundDbContext.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Configure the shared tables (with included modules) here */\n\n            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n            });\n \n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Configure the shared tables (with included modules) here */\n\n            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n            });\n \n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到他们共同执行了 builder.ConfigurePlayGround();"}]},{"type":"element","tag":"h2","props":{"id":"为什么这样设计"},"children":[{"type":"text","value":"为什么这样设计?"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为了模块间不产生依赖,例如用户表,迁移dbcontext中使用了IdentityUser,而运行的dbcontext使用了appuser进行了对其的映射,"},{"type":"element","tag":"a","props":{"href":"https://github.com/abpframework/abp/issues/1998","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/abpframework/abp/issues/1998"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如何为user添加属性."},{"type":"element","tag":"a","props":{"href":"https://github.com/abpframework/abp/issues/2453","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/abpframework/abp/issues/2453"}]}]}]},{"type":"element","tag":"h1","props":{"id":"如何共用user"},"children":[{"type":"text","value":"如何共用user"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们来看下定义的Iuser接口"}]},{"type":"element","tag":"pre","props":{"code":"    public interface IUser : IAggregateRoot<Guid>, IMultiTenant\n    {\n        string UserName { get; }\n\n        [CanBeNull]\n        string Email { get; }\n\n        [CanBeNull]\n        string Name  { get; }\n\n        [CanBeNull]\n        string Surname { get; }\n\n        bool EmailConfirmed { get; }\n\n        [CanBeNull]\n        string PhoneNumber { get; }\n\n        bool PhoneNumberConfirmed { get; }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public interface IUser : IAggregateRoot<Guid>, IMultiTenant\n    {\n        string UserName { get; }\n\n        [CanBeNull]\n        string Email { get; }\n\n        [CanBeNull]\n        string Name  { get; }\n\n        [CanBeNull]\n        string Surname { get; }\n\n        bool EmailConfirmed { get; }\n\n        [CanBeNull]\n        string PhoneNumber { get; }\n\n        bool PhoneNumberConfirmed { get; }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"dbcontext中的配置字段"}]},{"type":"element","tag":"pre","props":{"code":"        public static void ConfigureAbpUser<TUser>(this EntityTypeBuilder<TUser> b)\n            where TUser : class, IUser\n        {\n            b.Property(u => u.TenantId).HasColumnName(nameof(IUser.TenantId));\n            b.Property(u => u.UserName).IsRequired().HasMaxLength(AbpUserConsts.MaxUserNameLength).HasColumnName(nameof(IUser.UserName));\n            b.Property(u => u.Email).IsRequired().HasMaxLength(AbpUserConsts.MaxEmailLength).HasColumnName(nameof(IUser.Email));\n            b.Property(u => u.Name).HasMaxLength(AbpUserConsts.MaxNameLength).HasColumnName(nameof(IUser.Name));\n            b.Property(u => u.Surname).HasMaxLength(AbpUserConsts.MaxSurnameLength).HasColumnName(nameof(IUser.Surname));\n            b.Property(u => u.EmailConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.EmailConfirmed));\n            b.Property(u => u.PhoneNumber).HasMaxLength(AbpUserConsts.MaxPhoneNumberLength).HasColumnName(nameof(IUser.PhoneNumber));\n            b.Property(u => u.PhoneNumberConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.PhoneNumberConfirmed));\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static void ConfigureAbpUser<TUser>(this EntityTypeBuilder<TUser> b)\n            where TUser : class, IUser\n        {\n            b.Property(u => u.TenantId).HasColumnName(nameof(IUser.TenantId));\n            b.Property(u => u.UserName).IsRequired().HasMaxLength(AbpUserConsts.MaxUserNameLength).HasColumnName(nameof(IUser.UserName));\n            b.Property(u => u.Email).IsRequired().HasMaxLength(AbpUserConsts.MaxEmailLength).HasColumnName(nameof(IUser.Email));\n            b.Property(u => u.Name).HasMaxLength(AbpUserConsts.MaxNameLength).HasColumnName(nameof(IUser.Name));\n            b.Property(u => u.Surname).HasMaxLength(AbpUserConsts.MaxSurnameLength).HasColumnName(nameof(IUser.Surname));\n            b.Property(u => u.EmailConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.EmailConfirmed));\n            b.Property(u => u.PhoneNumber).HasMaxLength(AbpUserConsts.MaxPhoneNumberLength).HasColumnName(nameof(IUser.PhoneNumber));\n            b.Property(u => u.PhoneNumberConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.PhoneNumberConfirmed));\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"dbcontext中的user表是如何创建,更新和使用的.."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UserLookupService.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看下查找,其中"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IdentityUserRepositoryExternalUserLookupServiceProvider : IExternalUserLookupServiceProvider,"}]}]},{"type":"element","tag":"pre","props":{"code":" public async Task<TUser> FindByIdAsync(Guid id, CancellationToken cancellationToken = default)\n        {\n            var localUser = await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n\n            if (ExternalUserLookupServiceProvider == null)\n            {\n                return localUser;\n            }\n\n            if (SkipExternalLookupIfLocalUserExists && localUser != null)\n            {\n                return localUser;\n            }\n\n            IUserData externalUser;\n\n            try\n            {\n                externalUser = await ExternalUserLookupServiceProvider.FindByIdAsync(id, cancellationToken);\n                if (externalUser == null)\n                {\n                    if (localUser != null)\n                    {\n                        //TODO: Instead of deleting, should be make it inactive or something like that?\n                        await WithNewUowAsync(() => _userRepository.DeleteAsync(localUser, cancellationToken: cancellationToken));\n                    }\n\n                    return null;\n                }\n            }\n            catch (Exception ex)\n            {\n                Logger.LogException(ex);\n                return localUser;\n            }\n\n            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n\n            return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public async Task<TUser> FindByIdAsync(Guid id, CancellationToken cancellationToken = default)\n        {\n            var localUser = await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n\n            if (ExternalUserLookupServiceProvider == null)\n            {\n                return localUser;\n            }\n\n            if (SkipExternalLookupIfLocalUserExists && localUser != null)\n            {\n                return localUser;\n            }\n\n            IUserData externalUser;\n\n            try\n            {\n                externalUser = await ExternalUserLookupServiceProvider.FindByIdAsync(id, cancellationToken);\n                if (externalUser == null)\n                {\n                    if (localUser != null)\n                    {\n                        //TODO: Instead of deleting, should be make it inactive or something like that?\n                        await WithNewUowAsync(() => _userRepository.DeleteAsync(localUser, cancellationToken: cancellationToken));\n                    }\n\n                    return null;\n                }\n            }\n            catch (Exception ex)\n            {\n                Logger.LogException(ex);\n                return localUser;\n            }\n\n            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n\n            return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据上面代码可见,如果找不到该用户..会自动创建一个,如何继承了IUpdateUserData则会更新"}]},{"type":"element","tag":"pre","props":{"code":"            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更新还可以通过eventbus"}]},{"type":"element","tag":"pre","props":{"code":"    public class BlogUserSynchronizer :\n        IDistributedEventHandler<EntityUpdatedEto<UserEto>>,\n        ITransientDependency\n    {\n        protected IBlogUserRepository UserRepository { get; }\n        protected IBlogUserLookupService UserLookupService { get; }\n\n        public BlogUserSynchronizer(\n            IBlogUserRepository userRepository, \n            IBlogUserLookupService userLookupService)\n        {\n            UserRepository = userRepository;\n            UserLookupService = userLookupService;\n        }\n\n        public async Task HandleEventAsync(EntityUpdatedEto<UserEto> eventData)\n        {\n            var user = await UserRepository.FindAsync(eventData.Entity.Id);\n            if (user == null)\n            {\n                user = await UserLookupService.FindByIdAsync(eventData.Entity.Id);\n                if (user == null)\n                {\n                    return;\n                }\n            }\n\n            if (user.Update(eventData.Entity))\n            {\n                await UserRepository.UpdateAsync(user);\n            }\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public class BlogUserSynchronizer :\n        IDistributedEventHandler<EntityUpdatedEto<UserEto>>,\n        ITransientDependency\n    {\n        protected IBlogUserRepository UserRepository { get; }\n        protected IBlogUserLookupService UserLookupService { get; }\n\n        public BlogUserSynchronizer(\n            IBlogUserRepository userRepository, \n            IBlogUserLookupService userLookupService)\n        {\n            UserRepository = userRepository;\n            UserLookupService = userLookupService;\n        }\n\n        public async Task HandleEventAsync(EntityUpdatedEto<UserEto> eventData)\n        {\n            var user = await UserRepository.FindAsync(eventData.Entity.Id);\n            if (user == null)\n            {\n                user = await UserLookupService.FindByIdAsync(eventData.Entity.Id);\n                if (user == null)\n                {\n                    return;\n                }\n            }\n\n            if (user.Update(eventData.Entity))\n            {\n                await UserRepository.UpdateAsync(user);\n            }\n        }\n    }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"如何给identityuser添加额外的属性"},"children":[{"type":"text","value":"如何给IdentityUser添加额外的属性"}]},{"type":"element","tag":"h2","props":{"id":"extra-properties"},"children":[{"type":"text","value":"Extra Properties"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先IdentityUser已经被定义,虽然我们可以通过dbcontext配置修改数据表的字段,,但是不能被映射,所以有了Extra Properties"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities"}]}]},{"type":"element","tag":"h2","props":{"id":"映射"},"children":[{"type":"text","value":"映射"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会在数据库中创建字段"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AppUser.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        public virtual string Sex { get; private set; }\n\n        private AppUser()\n        {\n\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public virtual string Sex { get; private set; }\n\n        private AppUser()\n        {\n\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundDbContext.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n\n                b.Property(x => x.Sex).HasMaxLength(128);\n            });\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n\n                b.Property(x => x.Sex).HasMaxLength(128);\n            });\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundEfCoreEntityExtensionMappings.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"       public static void Configure()\n        {\n            PlayGroundModulePropertyConfigurator.Configure();\n\n            OneTimeRunner.Run(() =>\n            {\n                /* You can configure entity extension properties for the\n                 * entities defined in the used modules.\n                 *\n                 * The properties defined here becomes table fields.\n                 * If you want to use the ExtraProperties dictionary of the entity\n                 * instead of creating a new field, then define the property in the\n                 * PlayGroundDomainObjectExtensions class.\n                 *\n                 * Example:\n                 *\n                 * ObjectExtensionManager.Instance\n                 *    .MapEfCoreProperty<IdentityUser, string>(\n                 *        \"MyProperty\",\n                 *        b => b.HasMaxLength(128)\n                 *    );\n                 *\n                 * See the documentation for more:\n                 * https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Extending-Entities\n                 */\n\n                ObjectExtensionManager.Instance\n                      .MapEfCoreProperty<IdentityUser, string>(\n                  nameof(AppUser.Sex),\n                  b => b.HasMaxLength(128)\n                      );\n            });\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"       public static void Configure()\n        {\n            PlayGroundModulePropertyConfigurator.Configure();\n\n            OneTimeRunner.Run(() =>\n            {\n                /* You can configure entity extension properties for the\n                 * entities defined in the used modules.\n                 *\n                 * The properties defined here becomes table fields.\n                 * If you want to use the ExtraProperties dictionary of the entity\n                 * instead of creating a new field, then define the property in the\n                 * PlayGroundDomainObjectExtensions class.\n                 *\n                 * Example:\n                 *\n                 * ObjectExtensionManager.Instance\n                 *    .MapEfCoreProperty<IdentityUser, string>(\n                 *        \"MyProperty\",\n                 *        b => b.HasMaxLength(128)\n                 *    );\n                 *\n                 * See the documentation for more:\n                 * https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Extending-Entities\n                 */\n\n                ObjectExtensionManager.Instance\n                      .MapEfCoreProperty<IdentityUser, string>(\n                  nameof(AppUser.Sex),\n                  b => b.HasMaxLength(128)\n                      );\n            });\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们来看看生成的迁移表"}]},{"type":"element","tag":"pre","props":{"code":"    public partial class Added_Sex_T_User : Migration\n    {\n        protected override void Up(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.AddColumn<string>(\n                name: \"Sex\",\n                table: \"AbpUsers\",\n                maxLength: 128,\n                nullable: true);\n        }\n\n        protected override void Down(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.DropColumn(\n                name: \"Sex\",\n                table: \"AbpUsers\");\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public partial class Added_Sex_T_User : Migration\n    {\n        protected override void Up(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.AddColumn<string>(\n                name: \"Sex\",\n                table: \"AbpUsers\",\n                maxLength: 128,\n                nullable: true);\n        }\n\n        protected override void Down(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.DropColumn(\n                name: \"Sex\",\n                table: \"AbpUsers\");\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200714123314743","src":"/images/2020-07-05-abp-database-migration/image-20200714123314743.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它时如何被添加到迁移dbcontext中的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AbpEntityTypeBuilderExtensions.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        public static void ConfigureByConvention(this EntityTypeBuilder b)\n        {\n            b.TryConfigureConcurrencyStamp();\n            b.TryConfigureExtraProperties();  //配置扩展属性,就是ExtraProperties字段\n            b.TryConfigureObjectExtensions();//就是这里对象扩展,ObjectExtensionManager.Instance添加属性,然后从这里再根据类型读取出来\n            b.TryConfigureMayHaveCreator();\n            b.TryConfigureMustHaveCreator();\n            b.TryConfigureSoftDelete();\n            b.TryConfigureDeletionTime();\n            b.TryConfigureDeletionAudited();\n            b.TryConfigureCreationTime();\n            b.TryConfigureLastModificationTime();\n            b.TryConfigureModificationAudited();\n            b.TryConfigureMultiTenant();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static void ConfigureByConvention(this EntityTypeBuilder b)\n        {\n            b.TryConfigureConcurrencyStamp();\n            b.TryConfigureExtraProperties();  //配置扩展属性,就是ExtraProperties字段\n            b.TryConfigureObjectExtensions();//就是这里对象扩展,ObjectExtensionManager.Instance添加属性,然后从这里再根据类型读取出来\n            b.TryConfigureMayHaveCreator();\n            b.TryConfigureMustHaveCreator();\n            b.TryConfigureSoftDelete();\n            b.TryConfigureDeletionTime();\n            b.TryConfigureDeletionAudited();\n            b.TryConfigureCreationTime();\n            b.TryConfigureLastModificationTime();\n            b.TryConfigureModificationAudited();\n            b.TryConfigureMultiTenant();\n        }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"同步"},"children":[{"type":"text","value":"同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以创建"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"自己的表"}]},{"type":"text","value":"来存储属性,而不是创建新实体并映射到同一表. 你通常复制原始实体的一些值. 例如可以将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Name"}]},{"type":"text","value":" 字段添加到你自己的表中,它是原表中 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Name"}]},{"type":"text","value":" 字段的副本."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种情况下你不需要处理迁移问题,但是需要处理数据复制问题. 当重复的值发生变化时,你应该在表中同步相同的变化. 你可以使用本地或分布式"},{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Event-Bus","rel":["nofollow"]},"children":[{"type":"text","value":"事件总线"}]},{"type":"text","value":"订阅原始实体的更改事件. 这是根据来自另一个微服务的数据推荐的方法,特别是如果它们有单独的物理数据库(你可以在网络中搜索关于微服务设计的数据共享,这是一个广泛的主题)."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"为什么这样设计","depth":2,"text":"为什么这样设计?"},{"id":"extra-properties","depth":2,"text":"Extra Properties"},{"id":"映射","depth":2,"text":"映射"},{"id":"同步","depth":2,"text":"同步"}]}},"_type":"markdown","_id":"content:dotnet:2020-07-05-abp-database-user.md","_source":"content","_file":"dotnet/2020-07-05-abp-database-user.md","_extension":"md","date":"2020-07-05"},{"_path":"/dotnet/2020-07-10-abp-doc","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"abp的dOC模块使用","description":"配置原理abp 使用拉的方式从github直接请求,然后存储到数据库作为缓存注意开发环境下,他会从github直接拉取而不会经过数据库缓存,所以会很慢关于版本当你写完书的时候.打个tag,然后把tag的版本号填入上方的..最新版本的分支名称即可关于多语言注意多语言abp使用了缓存..所以如果你更改了docs-langs.json,需要重启服务器,或者清空缓存{\n    \"Languages\":[\n      {\n        \"DisplayName\" : \"English\",\n        \"Code\" : \"en\",\n        \"IsDefault\": false\n      }","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"配置"},"children":[{"type":"text","value":"配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200716181126415","src":"/images/2020-07-10-abp-doc/image-20200716181126415.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp 使用拉的方式从github直接请求,然后存储到数据库作为缓存"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意开发环境下,他会从github直接拉取而不会经过数据库缓存,所以会很慢"}]},{"type":"element","tag":"h1","props":{"id":"关于版本"},"children":[{"type":"text","value":"关于版本"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当你写完书的时候.打个tag,然后把tag的版本号填入上方的..最新版本的分支名称即可"}]},{"type":"element","tag":"h1","props":{"id":"关于多语言"},"children":[{"type":"text","value":"关于多语言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意多语言abp使用了缓存..所以如果你更改了docs-langs.json,需要重启服务器,或者清空缓存"}]},{"type":"element","tag":"pre","props":{"code":"{\n    \"Languages\":[\n      {\n        \"DisplayName\" : \"English\",\n        \"Code\" : \"en\",\n        \"IsDefault\": false\n      },\n      {\n        \"DisplayName\" : \"简体中文\",\n        \"Code\" : \"zh\",\n        \"IsDefault\": true\n      }\n    ]\n  }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n    \"Languages\":[\n      {\n        \"DisplayName\" : \"English\",\n        \"Code\" : \"en\",\n        \"IsDefault\": false\n      },\n      {\n        \"DisplayName\" : \"简体中文\",\n        \"Code\" : \"zh\",\n        \"IsDefault\": true\n      }\n    ]\n  }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"关于参数doc-params"},"children":[{"type":"text","value":"关于参数[doc-params]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp使用了scriban文本模板语言引擎."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/lunet-io/scriban","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/lunet-io/scriban"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体的示例参见:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&DB=EF&Tiered=No","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&DB=EF&Tiered=No"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.md","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.md"}]}]}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"parameters\": [\n    {\n      \"name\": \"UI\",\n      \"displayName\": \"UI\",\n      \"values\": {\n        \"MVC\": \"MVC / Razor Pages\",\n        \"NG\": \"Angular\"\n      }\n    },\n    {\n      \"name\": \"DB\",\n      \"displayName\": \"Database\",\n      \"values\": {\n        \"EF\": \"Entity Framework Core\",\n        \"Mongo\": \"MongoDB\"\n      }\n    },\n    {\n      \"name\": \"Tiered\",\n      \"displayName\": \"Tiered\",\n      \"values\": {\n        \"No\": \"Not Tiered\",\n        \"Yes\": \"Tiered\"\n      }\n    }\n  ]\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"parameters\": [\n    {\n      \"name\": \"UI\",\n      \"displayName\": \"UI\",\n      \"values\": {\n        \"MVC\": \"MVC / Razor Pages\",\n        \"NG\": \"Angular\"\n      }\n    },\n    {\n      \"name\": \"DB\",\n      \"displayName\": \"Database\",\n      \"values\": {\n        \"EF\": \"Entity Framework Core\",\n        \"Mongo\": \"MongoDB\"\n      }\n    },\n    {\n      \"name\": \"Tiered\",\n      \"displayName\": \"Tiered\",\n      \"values\": {\n        \"No\": \"Not Tiered\",\n        \"Yes\": \"Tiered\"\n      }\n    }\n  ]\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"markdow中使用"}]},{"type":"element","tag":"pre","props":{"code":"//[doc-params]\n{\n    \"UI\": [\"MVC\",\"NG\"],\n    \"DB\": [\"EF\", \"Mongo\"],\n    \"Tiered\": [\"Yes\", \"No\"]\n}\n本教程介绍了如何创建一个新的{{if UI == \"MVC\"}} ASP.NET Core MVC web {{else if UI == \"NG\"}} Angular {{end}}. 配置并运行它.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//[doc-params]\n{\n    \"UI\": [\"MVC\",\"NG\"],\n    \"DB\": [\"EF\", \"Mongo\"],\n    \"Tiered\": [\"Yes\", \"No\"]\n}\n本教程介绍了如何创建一个新的{{if UI == \"MVC\"}} ASP.NET Core MVC web {{else if UI == \"NG\"}} Angular {{end}}. 配置并运行它.\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生成的html"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200718164036943","src":"/images/2020-07-10-abp-doc/image-20200718164036943.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当切换ui的值后的显示,我们看到字符发生了改变"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200718164137023","src":"/images/2020-07-10-abp-doc/image-20200718164137023.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"关于doc-template"},"children":[{"type":"text","value":"关于[doc-template]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还没看到如何用"}]},{"type":"element","tag":"h1","props":{"id":"_404"},"children":[{"type":"text","value":"404"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为访问github如果超时就会出现404."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以建议控制台设置代理然后运行"}]},{"type":"element","tag":"pre","props":{"code":"$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ndotnet run .\\IG.Www.Web.csproj\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ndotnet run .\\IG.Www.Web.csproj\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-07-10-abp-doc.md","_source":"content","_file":"dotnet/2020-07-10-abp-doc.md","_extension":"md","date":"2020-07-10"},{"_path":"/dotnet/2020-07-15-abp-default-language","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"abp默认语言规则","description":"abp是依托与aspnetcore的.我们先来看看aspnetcore是怎么实现的","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"abp默认语言规则"},"children":[{"type":"text","value":"abp默认语言规则"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp是依托与aspnetcore的.我们先来看看aspnetcore是怎么实现的"}]},{"type":"element","tag":"pre","props":{"code":"\n    services.Configure<RequestLocalizationOptions>(options =>\n        {\n            var supportedCultures = new List<CultureInfo>\n            {\n                new CultureInfo(\"en-US\"),\n                new CultureInfo(\"en\"),\n                new CultureInfo(\"fr-FR\"),\n                new CultureInfo(\"fr\")\n            };\n\n            options.DefaultRequestCulture = new RequestCulture(\"en-US\");\n            options.SupportedCultures = supportedCultures;\n            options.SupportedUICultures = supportedCultures;\n        });\n        \n        \n        //中间件\n        app.UseRequestLocalization();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n    services.Configure<RequestLocalizationOptions>(options =>\n        {\n            var supportedCultures = new List<CultureInfo>\n            {\n                new CultureInfo(\"en-US\"),\n                new CultureInfo(\"en\"),\n                new CultureInfo(\"fr-FR\"),\n                new CultureInfo(\"fr\")\n            };\n\n            options.DefaultRequestCulture = new RequestCulture(\"en-US\");\n            options.SupportedCultures = supportedCultures;\n            options.SupportedUICultures = supportedCultures;\n        });\n        \n        \n        //中间件\n        app.UseRequestLocalization();\n"}]}]},{"type":"element","tag":"h2","props":{"id":"中间件request的语言判断"},"children":[{"type":"text","value":"中间件request的语言判断"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在每次请求里 "},{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNet/Localization/RequestLocalizationOptions/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"RequestLocalizationOptions"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/RequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"RequestCultureProvider"}]},{"type":"text","value":" 列表会被遍历，第一个provider 会被使用来判断请求使用的文化。默认的 provider 来自"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RequestLocalizationOptions"}]},{"type":"text","value":" 类,如果没有非空的 provider，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DefaultRequestCulture"}]},{"type":"text","value":" 被使用。所以如果发现语言不是按照逻辑顺序显示,先检查请求网址,再检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cookie"}]},{"type":"text","value":"(很难注意到),最后检查acceptlanguage"}]},{"type":"element","tag":"h3","props":{"id":"querystringrequestcultureprovider"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/QueryStringRequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"QueryStringRequestCultureProvider"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的例子指定了具体的区域性（语言和区域）设置为西班牙语/墨西哥："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/?culture=es-MX&ui-culture=es-MX","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/?culture=es-MX&ui-culture=es-MX"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你仅仅使用（culture 或者 ui-culture）中的一个参数进行传递，查询字符串 provider 将使用你传递一个值来设置这两个参数。例如，仅设置culture，将会同样设置 Culture 和 UICulture："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/?culture=es-MX","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/?culture=es-MX"}]}]},{"type":"element","tag":"h3","props":{"id":"cookierequestcultureprovider"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/CookieRequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"CookieRequestCultureProvider"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CookieRequestCultureProvider 的 DefaultCookieName 返回用于跟踪用户的首选区域性信息默认的 Cookie 名称。默认的 Cookie 名称是 “.AspNetCore.Culture”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"cookie 的格式是 c=%LANGCODE%|uic=%LANGCODE%, c 为区域信息 和 uic 为 UI 区域信息，例如："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c=’en-UK’|uic=’en-US’"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果仅指定 culture 或 UI culture中的一个，指定的区域性信息将同时用于 culture和 UI culture。"}]},{"type":"element","tag":"h3","props":{"id":"acceptlanguageheaderrequestcultureprovider"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/AcceptLanguageHeaderRequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"AcceptLanguageHeaderRequestCultureProvider"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个一般是根据浏览器的设置进行访问的\n"},{"type":"element","tag":"img","props":{"alt":"image-20200719113919074","src":"/images/2020-07-15-abp-default-language/image-20200719113919074.png"},"children":[]},{"type":"text","value":"\n不同的浏览器默认语言不同,chrome浏览器可以再语言里设置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-15-abp-default-language/c83d70cf3bc79f3d3ec73c6db4a1cd11728b294d.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"cultures"},"children":[{"type":"text","value":"Cultures"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SupportedCultures"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"CultureInfo"}]},{"type":"text","value":" 对象决定了和文化相关的函数，如日期，时间，数字和货币格式的结果。同时决定了文字如何排序，大小写转换以及字符串比较。参考"},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.currentculture(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"CultureInfo.CurrentCulture"}]},{"type":"text","value":" 获取更多关于服务器如何获取文化的信息。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SupportedUICultures"}]},{"type":"text","value":" 决定如何通过 "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.resources.resourcemanager(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"ResourceManager"}]},{"type":"text","value":" 查找翻译字符串（从 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":".resx"}]},{"type":"text","value":" 文件）。 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"ResourceManager"}]},{"type":"text","value":" 只是通过 CurrentUICulture 简单的查找指定文化的字符串。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".NET 的每个线程都会拥有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CurrentCulture"}]},{"type":"text","value":" 和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CurrentUICulture"}]},{"type":"text","value":" 对象。当 ASP.NET Core 在渲染与文化相关的函数的时候会检视这些对象值。例如，如果当前线程的区域性设置为 “en-US” （英语、美国）， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DateTime.Now.ToLongDateString() \"Thursday, February 18, 2016\""}]},{"type":"text","value":" ，但如果 CurrentCulture 设置为 “es-ES”（西班牙语、西班牙），输出将会是 “jueves, 18 de febrero de 2016”。"}]},{"type":"element","tag":"h2","props":{"id":"abp的实现"},"children":[{"type":"text","value":"abp的实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Volo.Abp.AspNetCore项目中DefaultAbpRequestLocalizationOptionsProvider.cs"}]},{"type":"element","tag":"pre","props":{"code":"#GetLocalizationOptionsAsync()\n#根据设置获取默认语言,如果默认语言为en\nvar languages = await languageProvider.GetLanguagesAsync();\nvar defaultLanguage = await settingProvider.GetOrNullAsync(LocalizationSettingNames.DefaultLanguage);\n\nvar options = !languages.Any()\n? new RequestLocalizationOptions()\n: new RequestLocalizationOptions\n{\nDefaultRequestCulture = DefaultGetRequestCulture(defaultLanguage, languages),\n\nSupportedCultures = languages\n.Select(l => l.CultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray(),\n\nSupportedUICultures = languages\n.Select(l => l.UiCultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray()\n};\n\n#如果设置中的默认语言不存在,则选取第一个语言作为默认语言\nprivate static RequestCulture DefaultGetRequestCulture(string defaultLanguage, IReadOnlyList<LanguageInfo> languages)\n{\n    if (defaultLanguage == null)\n    {\n    var firstLanguage = languages.First();\n    return new RequestCulture(firstLanguage.CultureName, firstLanguage.UiCultureName);\n    }\n\n    var (cultureName, uiCultureName) = LocalizationSettingHelper.ParseLanguageSetting(defaultLanguage);\n    return new RequestCulture(cultureName, uiCultureName);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#GetLocalizationOptionsAsync()\n#根据设置获取默认语言,如果默认语言为en\nvar languages = await languageProvider.GetLanguagesAsync();\nvar defaultLanguage = await settingProvider.GetOrNullAsync(LocalizationSettingNames.DefaultLanguage);\n\nvar options = !languages.Any()\n? new RequestLocalizationOptions()\n: new RequestLocalizationOptions\n{\nDefaultRequestCulture = DefaultGetRequestCulture(defaultLanguage, languages),\n\nSupportedCultures = languages\n.Select(l => l.CultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray(),\n\nSupportedUICultures = languages\n.Select(l => l.UiCultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray()\n};\n\n#如果设置中的默认语言不存在,则选取第一个语言作为默认语言\nprivate static RequestCulture DefaultGetRequestCulture(string defaultLanguage, IReadOnlyList<LanguageInfo> languages)\n{\n    if (defaultLanguage == null)\n    {\n    var firstLanguage = languages.First();\n    return new RequestCulture(firstLanguage.CultureName, firstLanguage.UiCultureName);\n    }\n\n    var (cultureName, uiCultureName) = LocalizationSettingHelper.ParseLanguageSetting(defaultLanguage);\n    return new RequestCulture(cultureName, uiCultureName);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后中间件是"}]},{"type":"element","tag":"pre","props":{"code":"app.UseAbpRequestLocalization();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"app.UseAbpRequestLocalization();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"中间件使用的是AbpRequestLocalizationMiddleware,其实它只是对aspnetcore的RequestLocalizationMiddleware进行了一层包装"}]},{"type":"element","tag":"h3","props":{"id":"如何修改默认语言"},"children":[{"type":"text","value":"如何修改默认语言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先注意浏览器发送的中文的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"accept-language"}]},{"type":"text","value":"的值与ABP值是不一样的:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"浏览器(如Chrome)的值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"zh-CN"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"而ABP的简体中文的值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"zh-Hans"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先修改配置文件appsettings.json"}]},{"type":"element","tag":"pre","props":{"code":"\"Settings\": {\n    \"Abp.Localization.DefaultLanguage\": \"zh-Hans\"\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\"Settings\": {\n    \"Abp.Localization.DefaultLanguage\": \"zh-Hans\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后在中间件中删除AcceptLanguageHeaderRequestCultureProvider"}]},{"type":"element","tag":"pre","props":{"code":"app.UseAbpRequestLocalization(options =>\n    {\n        options.RequestCultureProviders.RemoveAll(provider => provider is AcceptLanguageHeaderRequestCultureProvider);\n    }\n);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"app.UseAbpRequestLocalization(options =>\n    {\n        options.RequestCultureProviders.RemoveAll(provider => provider is AcceptLanguageHeaderRequestCultureProvider);\n    }\n);\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"中间件request的语言判断","depth":2,"text":"中间件request的语言判断","children":[{"id":"querystringrequestcultureprovider","depth":3,"text":"QueryStringRequestCultureProvider"},{"id":"cookierequestcultureprovider","depth":3,"text":"CookieRequestCultureProvider"},{"id":"acceptlanguageheaderrequestcultureprovider","depth":3,"text":"AcceptLanguageHeaderRequestCultureProvider"}]},{"id":"cultures","depth":2,"text":"Cultures"},{"id":"abp的实现","depth":2,"text":"abp的实现","children":[{"id":"如何修改默认语言","depth":3,"text":"如何修改默认语言"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-07-15-abp-default-language.md","_source":"content","_file":"dotnet/2020-07-15-abp-default-language.md","_extension":"md","date":"2020-07-15"},{"_path":"/dotnet/2020-08-09-orleans-best-practices","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Orleans 最佳实践","description":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"重入"},"children":[{"type":"text","value":"重入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为访问grain一般是需要跨服务器的，所以可重入是很有必要的。。"}]},{"type":"element","tag":"h1","props":{"id":"无状态grain"},"children":[{"type":"text","value":"无状态Grain"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"grain永远是运行在服务端的,包括无状态的."}]},{"type":"element","tag":"h1","props":{"id":"time"},"children":[{"type":"text","value":"time"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"time是单线程的.."}]},{"type":"element","tag":"h2","props":{"id":"错误"},"children":[{"type":"text","value":"错误"}]},{"type":"element","tag":"pre","props":{"code":"        public override async Task OnActivateAsync()\n        {\n\n            if (this.TimerDisposable == null)\n            {\n                this.TimerDisposable = RegisterTimer(\n                            this.SaveChanges,\n                            \"timer\",\n                            TimeSpan.FromMilliseconds(0),\n                            TimeSpan.FromMilliseconds(1)\n                            );\n            }\n\n            await base.OnActivateAsync();\n        }\n\n\n\n        private Task SaveChanges(object arg)\n        {\n            this.persisitent.State.num++;\n\n            return this.persisitent.WriteStateAsync();\n        }\n\n        public async Task StartUp()\n        {\n            this.persisitent.State.num = 0;\n            await this.WriteStateAsync();\n        }\n        \n        \n           var grain = this.GrainFactory.GetGrain<ITimeTestGrain>(1000);\n\n            await grain.StartUp();\n        \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public override async Task OnActivateAsync()\n        {\n\n            if (this.TimerDisposable == null)\n            {\n                this.TimerDisposable = RegisterTimer(\n                            this.SaveChanges,\n                            \"timer\",\n                            TimeSpan.FromMilliseconds(0),\n                            TimeSpan.FromMilliseconds(1)\n                            );\n            }\n\n            await base.OnActivateAsync();\n        }\n\n\n\n        private Task SaveChanges(object arg)\n        {\n            this.persisitent.State.num++;\n\n            return this.persisitent.WriteStateAsync();\n        }\n\n        public async Task StartUp()\n        {\n            this.persisitent.State.num = 0;\n            await this.WriteStateAsync();\n        }\n        \n        \n           var grain = this.GrainFactory.GetGrain<ITimeTestGrain>(1000);\n\n            await grain.StartUp();\n        \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上代码当duetime设置为0的时候,会有类型的错误"}]},{"type":"element","tag":"pre","props":{"code":"Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原因猜测,grain未激活完成的时候,如果为0的时候,这个时候time的callback(SaveChanges)还没有加入到任务队列,就调用了state,而之后也立即同时调用了state这个时候就会报错."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决方案:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要设置duetime为0"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"或者不要在OnActivateAsync中RegisterTimer,在Activate后再RegisterTimer"}]}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"错误","depth":2,"text":"错误"}]}},"_type":"markdown","_id":"content:dotnet:2020-08-09-Orleans-Best-Practices.md","_source":"content","_file":"dotnet/2020-08-09-Orleans-Best-Practices.md","_extension":"md","date":"2020-08-09"},{"_path":"/dotnet/2020-08-10-param-attribute","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"c#特性参数","description":"可以通过反射获取这些特性然后做处理class Program\n{\n    static void Main(string[] args)\n    {\n        var message = new MessageData {\n\n            Header=\"header...\",\n            Body=\"body....\",\n            Footer=\"footer...\",\n        };\n\n        Type objT = typeof(Program);\n        Type fromBodyT = typeof(FromBodyAt","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以通过反射获取这些特性然后做处理"}]},{"type":"element","tag":"pre","props":{"code":"class Program\n{\n    static void Main(string[] args)\n    {\n        var message = new MessageData {\n\n            Header=\"header...\",\n            Body=\"body....\",\n            Footer=\"footer...\",\n        };\n\n        Type objT = typeof(Program);\n        Type fromBodyT = typeof(FromBodyAttribute);\n        MethodInfo method = objT.GetMethod(\"Test\");\n\n        ParameterInfo[] paramsInfo = method.GetParameters();\n        var parameters= new List<object>(paramsInfo.Length);\n        foreach (ParameterInfo parameterInfo in paramsInfo)\n        {\n            var parameter = new object();\n            if (parameterInfo.CustomAttributes.Any(i => i.AttributeType == fromBodyT))\n                parameter = message.Body;\n            parameters.Add(parameter);\n        }\n\n\n        object result = method.Invoke(null, parameters.ToArray());\n        Console.WriteLine(result);\n\n\n    }\n    public class FromBodyAttribute : Attribute\n    {\n    }\n    public static string Test([FromBody] string body)\n    {\n        return body;\n    }\n    class MessageData\n    {\n\n        public string Body { get; set; }\n        public string Header { get; set; }\n        public string Footer { get; set; }\n\n    }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Program\n{\n    static void Main(string[] args)\n    {\n        var message = new MessageData {\n\n            Header=\"header...\",\n            Body=\"body....\",\n            Footer=\"footer...\",\n        };\n\n        Type objT = typeof(Program);\n        Type fromBodyT = typeof(FromBodyAttribute);\n        MethodInfo method = objT.GetMethod(\"Test\");\n\n        ParameterInfo[] paramsInfo = method.GetParameters();\n        var parameters= new List<object>(paramsInfo.Length);\n        foreach (ParameterInfo parameterInfo in paramsInfo)\n        {\n            var parameter = new object();\n            if (parameterInfo.CustomAttributes.Any(i => i.AttributeType == fromBodyT))\n                parameter = message.Body;\n            parameters.Add(parameter);\n        }\n\n\n        object result = method.Invoke(null, parameters.ToArray());\n        Console.WriteLine(result);\n\n\n    }\n    public class FromBodyAttribute : Attribute\n    {\n    }\n    public static string Test([FromBody] string body)\n    {\n        return body;\n    }\n    class MessageData\n    {\n\n        public string Body { get; set; }\n        public string Header { get; set; }\n        public string Footer { get; set; }\n\n    }\n\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-10-param-attribute.md","_source":"content","_file":"dotnet/2020-08-10-param-attribute.md","_extension":"md","date":"2020-08-10"},{"_path":"/dotnet/2020-08-11-httpcontextaccessor-asynclocal","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","description":"在 DotNetCore 当中不再像 MVC5 那样可以通过 HttpContext.Current 来获取到当前请求的上下文。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 DotNetCore 当中不再像 MVC5 那样可以通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpContext.Current"}]},{"type":"text","value":" 来获取到当前请求的上下文。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过微软提供了一个 IHttpContextAccessor 来让我们访问当前请求的 Http 上下文，其定义\n如下："}]},{"type":"element","tag":"pre","props":{"code":"namespace Microsoft.AspNetCore.Http\n{\n    public interface IHttpContextAccessor\n    {\n        HttpContext HttpContext { get; set; }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Http\n{\n    public interface IHttpContextAccessor\n    {\n        HttpContext HttpContext { get; set; }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要使用的话需要将其添加到 Ioc 容器当中，在 Startup 类的 ConfigureService 我们可以将其默认实现注册到 Ioc 之中。"}]},{"type":"element","tag":"pre","props":{"code":"public void ConfigureService(IServiceCollection services) {\n    services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void ConfigureService(IServiceCollection services) {\n    services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么我们可以来看看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpContextAccessor"}]},{"type":"text","value":" 的具体实现:"}]},{"type":"element","tag":"pre","props":{"code":"using System.Threading;\n\nnamespace Microsoft.AspNetCore.Http\n{\n    public class HttpContextAccessor : IHttpContextAccessor\n    {\n        private static AsyncLocal<HttpContext> _httpContextCurrent = new AsyncLocal<HttpContext>();\n\n        public HttpContext HttpContext\n        {\n            get\n            {\n                return _httpContextCurrent.Value;\n            }\n            set\n            {\n                _httpContextCurrent.Value = value;\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Threading;\n\nnamespace Microsoft.AspNetCore.Http\n{\n    public class HttpContextAccessor : IHttpContextAccessor\n    {\n        private static AsyncLocal<HttpContext> _httpContextCurrent = new AsyncLocal<HttpContext>();\n\n        public HttpContext HttpContext\n        {\n            get\n            {\n                return _httpContextCurrent.Value;\n            }\n            set\n            {\n                _httpContextCurrent.Value = value;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在其内部主要是用了一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<HttpContext>"}]},{"type":"text","value":" 来保存一个 HttpContext 实例，那么 Accessor 是什么时候被赋值的呢？答案就是在每次 HTTP 请求的时候会将其赋值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 是什么东西？\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 是在 .Net 4.6 之后推出的一个对象，该对象接受一个泛型参数，其主要作用是保存异步等待上下文中共享某个变量的值。\n而异步方法是基于 Task 的自动线程调度，在异步上下文切换的时候可能导致数据丢失。例如在 await 调用之前对某个变量进行了赋值，而这个变量是多个线程间共享的，当 await 调用返回之前的调用点的时候，可能调用点之后的代码还处在之前的线程上，也有可能被调度到其他线程上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子："}]},{"type":"element","tag":"pre","props":{"code":"static async Task TestMethod() {\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static async Task TestMethod() {\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 await 等待任务执行完成之后，后面的代码输出的 ID 与调用之前的 ID 不一样，说明发生了线程切换："}]},{"type":"element","tag":"pre","props":{"code":"\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Img","src":"/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c93755a0.png"},"children":[]},{"type":"text","value":"\n从代码上看他们似乎在同一个线程，但是在执行的时候就已经发生了线程切换的操作了。\n而我们在这里如果使用一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadLocal<T>"}]},{"type":"text","value":"变量来存储的话，会发生什么事情呢？"}]},{"type":"element","tag":"pre","props":{"code":"static ThreadLocal<int> _threadLocal = new ThreadLocal<int>();\nstatic AsyncLocal<int> _asyncLocal = new AsyncLocal<int>();\n\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n\nstatic async Task TestMethod() {\n    _threadLocal.Value = 1000;\n    _asyncLocal.Value = 2000;\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static ThreadLocal<int> _threadLocal = new ThreadLocal<int>();\nstatic AsyncLocal<int> _asyncLocal = new AsyncLocal<int>();\n\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n\nstatic async Task TestMethod() {\n    _threadLocal.Value = 1000;\n    _asyncLocal.Value = 2000;\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Img","src":"/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c938eec4.png"},"children":[]},{"type":"text","value":"\nSO，在这里解释一下， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadLocal"}]},{"type":"text","value":" 是用于为不同的线程保存不同的变量值的，即同一个变量在不同线程当中存储的值可以不一样。在这里使用是为了保证在 TestMethod 方法中变量的唯一性，这个在同步方法用是没问题的，但这里使用了 await 关键字导致等待异步调用结束后代码已经被调度到其他的线程了，所以这里没用。而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 正是为了这种情况而准备的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这就解释了为什么是单例却在每个线程是不同的值."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-11-httpcontextaccessor-asynclocal.md","_source":"content","_file":"dotnet/2020-08-11-httpcontextaccessor-asynclocal.md","_extension":"md","date":"2020-08-11"},{"_path":"/dotnet/2020-08-15-kestrel-source-code","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Kestrel源码分析","description":"Kestrel是http://ASP.NET Core框架内置的默认Web Server 什么是Web Server? 根据维基百科的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Kestrel是"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core框架内置的默认Web Server 什么是Web Server? 根据"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Web_server","rel":["nofollow"]},"children":[{"type":"text","value":"维基百科"}]},{"type":"text","value":"的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。"}]},{"type":"element","tag":"h2","props":{"id":"定义-iserverihttpapplicationtcontext"},"children":[{"type":"text","value":"定义 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core定义了两个基本的接口"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"，及"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"接口定义了Web Server的基本功能，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"则定义了处理HTTP协议的应用程序的基本功能，我们首先来看下这两个定义:"}]},{"type":"element","tag":"h2","props":{"id":"web-服务器-iserver"},"children":[{"type":"text","value":"Web 服务器 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents a server.\n    /// </summary>\n    public interface IServer : IDisposable\n    {\n        /// <summary>\n        /// A collection of HTTP features of the server.\n        /// </summary>\n        IFeatureCollection Features { get; }\n\n        /// <summary>\n        /// Start the server with an application.\n        /// </summary>\n        /// <param name=\"application\">An instance of <see cref=\"IHttpApplication{TContext}\"/>.</param>\n        /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n        /// <param name=\"cancellationToken\">Indicates if the server startup should be aborted.</param>\n        Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken);\n\n        /// <summary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.</param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents a server.\n    /// </summary>\n    public interface IServer : IDisposable\n    {\n        /// <summary>\n        /// A collection of HTTP features of the server.\n        /// </summary>\n        IFeatureCollection Features { get; }\n\n        /// <summary>\n        /// Start the server with an application.\n        /// </summary>\n        /// <param name=\"application\">An instance of <see cref=\"IHttpApplication{TContext}\"/>.</param>\n        /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n        /// <param name=\"cancellationToken\">Indicates if the server startup should be aborted.</param>\n        Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken);\n\n        /// <summary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.</param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Features"}]},{"type":"text","value":" 是一个功能集合，其中可以包含所有应用程序需要的，用以处理HTTP协议各个阶段和组成部分的功能集，以接口的形式注入到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Features"}]},{"type":"text","value":"中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync"}]},{"type":"text","value":"方法可以启动IServer对象，用来接受用户请求。包含两个参数："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"。 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplicatoin<TContext>"}]},{"type":"text","value":"是最终处理HTTP请求的应用程序入口点，在ASP.NET Core应用程序中，默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"实现是："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HostingApplication"}]},{"type":"text","value":"，我们会在稍后的部分进行详细的介绍。 而"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"用来响应中断应用程序启动的请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StopAsync"}]},{"type":"text","value":"方法用来处理停止服务的请求，接受一个参数"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"，用来响应中断停止应用程序的请求。"}]},{"type":"element","tag":"h2","props":{"id":"http应用程序-ihttpapplicationtcontext"},"children":[{"type":"text","value":"Http应用程序 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents an application.\n    /// </summary>\n    /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n    public interface IHttpApplication<TContext>\n    {\n        /// <summary>\n        /// Create a TContext given a collection of HTTP features.\n        /// </summary>\n        /// <param name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.</param>\n        /// <returns>The created TContext.</returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// <summary>\n        /// Asynchronously processes an TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext that the operation will process.</param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// <summary>\n        /// Dispose a given TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext to be disposed.</param>\n        /// <param name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.</param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents an application.\n    /// </summary>\n    /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n    public interface IHttpApplication<TContext>\n    {\n        /// <summary>\n        /// Create a TContext given a collection of HTTP features.\n        /// </summary>\n        /// <param name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.</param>\n        /// <returns>The created TContext.</returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// <summary>\n        /// Asynchronously processes an TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext that the operation will process.</param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// <summary>\n        /// Dispose a given TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext to be disposed.</param>\n        /// <param name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.</param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"接口的定义包含了三个方法： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateContext"}]},{"type":"text","value":"方法用来创建处理请求的上下文中所需要的所有相关数据，组成"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象，由接口的实现自己定义类型， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ProcessRequestAsync"}]},{"type":"text","value":"方法使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateContext"}]},{"type":"text","value":"方法创建的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象处理本次请求。 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DisposeContext"}]},{"type":"text","value":"方法在完成请求的处理后，负责释放"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象。"}]},{"type":"element","tag":"h2","props":{"id":"实现-kestrelserver"},"children":[{"type":"text","value":"实现 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core提供了默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"，下面我们就来看看"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"具体都做了些什么。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":" 定义在dotnet/aspnetcore项目中（"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore","rel":["nofollow"]},"children":[{"type":"text","value":"GITHUB REPO"}]},{"type":"text","value":"）。 项目名称为：Microsoft.AspNetCore.Server.Kestrel.Core 名称空间.AspNetCore.Server.Kestrel.Core "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore/blob/master/src/Servers/Kestrel/Core/src/KestrelServer.cs","rel":["nofollow"]},"children":[{"type":"text","value":"源代码"}]}]}]},{"type":"element","tag":"h2","props":{"id":"服务器启动端口监听协议解析及请求处理"},"children":[{"type":"text","value":"服务器启动：端口监听，协议解析及请求处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先看一下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync()"}]},{"type":"text","value":"方法的代码实现："}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"public async Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"首先会检查服务器的"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F","rel":["nofollow"]},"children":[{"type":"text","value":"字节序"}]},{"type":"text","value":"，目前是不支持大端序的。 然后检查最大请求长度限制的设置项，以及服务器是否已经启动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddressBinder"}]},{"type":"text","value":"对预先配置的IP地址或终结点(EndPoint)名称进行监听，开始接受客户端的请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当每有一个新的HTTP请求通过TCP协议或其他协议和服务器成功简历连接后，AddressBinder使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadPool.UnsafeQueueUserWorkItem()"}]},{"type":"text","value":"方法将"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法添加到线程池中，等待线程池的调度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果此时进程有可用的线程，就会调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法，处理用户的HTTP请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法默认使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件，处理新接入的用户请求，当设置了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MaxConcurrentConnections"}]},{"type":"text","value":"值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"True"}]},{"type":"text","value":"时，则会默认使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConnectionLimitMiddleware"}]},{"type":"text","value":"中间件，限制最大可用连接数，如果当前请求数已经达到最大可接受连接数，则拒绝用户的请求并断开连接，否则调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件，继续处理用户的请求。"}]},{"type":"element","tag":"h2","props":{"id":"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection"},"children":[{"type":"text","value":"处理HTTP请求 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件负责组装连接相关的上下文数据"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionContext"}]},{"type":"text","value":"，并使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]},{"type":"text","value":"类处理用户请求。"}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"internal class HttpConnectionMiddleware<TContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication<TContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication<TContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get<IMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"internal class HttpConnectionMiddleware<TContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication<TContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication<TContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get<IMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n"}]}]},{"type":"element","tag":"h3","props":{"id":"http版本控制-httpconnection"},"children":[{"type":"text","value":"HTTP版本控制 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当用户创建"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]},{"type":"text","value":"类时，在初始化过程中，会根据用户请求声明的HTTP协议版本，分别创建对应版本的Connection类，并使用该类处理用户请求："}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"public async Task ProcessRequestsAsync<TContext>(IHttpApplication<TContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection<TContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get<IConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get<IConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task ProcessRequestsAsync<TContext>(IHttpApplication<TContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection<TContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get<IConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get<IConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HTTP1和HTTP2处理HTTP协议的方式有所不同，HTTP1协议解析完成后，会立即调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"处理请求，HTTP2协议解析完成后，会再次调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadPool.UnsafeQueueUserWorkItem()"}]},{"type":"text","value":"方法等待线程池可用线程。"}]},{"type":"element","tag":"h2","props":{"id":"结束语"},"children":[{"type":"text","value":"结束语"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"服务的代码量并不下，其中主要是辅助接受用户请求和解析HTTP协议的代码，在这里不做详细的介绍，各位读者有兴趣的，可以详细阅读源代码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"服务在接受和处理请求时，都用到了线程池，可以极大的提高服务器的吞吐量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后面，我们还会详细介绍系统默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"实现，看看ASP.NET Core是如何将HTTP转发到Controller和Action，其中又有哪些精妙的代码呢。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"定义-iserverihttpapplicationtcontext","depth":2,"text":"定义 - IServer、IHttpApplication<TContext>"},{"id":"web-服务器-iserver","depth":2,"text":"Web 服务器 - IServer"},{"id":"http应用程序-ihttpapplicationtcontext","depth":2,"text":"Http应用程序 - IHttpApplication<TContext>"},{"id":"实现-kestrelserver","depth":2,"text":"实现 - KestrelServer"},{"id":"服务器启动端口监听协议解析及请求处理","depth":2,"text":"服务器启动：端口监听，协议解析及请求处理。"},{"id":"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection","depth":2,"text":"处理HTTP请求 - HttpConnectionMiddleware<ServiceContext>、HttpConnection","children":[{"id":"http版本控制-httpconnection","depth":3,"text":"HTTP版本控制 - HttpConnection"}]},{"id":"结束语","depth":2,"text":"结束语"}]}},"_type":"markdown","_id":"content:dotnet:2020-08-15-Kestrel-source-code.md","_source":"content","_file":"dotnet/2020-08-15-Kestrel-source-code.md","_extension":"md","date":"2020-08-15"},{"_path":"/dotnet/2020-08-16-concurrentdictionary","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"ConcurrentDictionary并发字典","description":"ConcurrentDictionary主要用于要从多个线程（或异步任务）修改字典的情景中。如果来自单个线程，则可以根据需要使用尽可能多的代码使用标准Dictionary；）","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConcurrentDictionary主要用于要从多个线程（或异步任务）修改字典的情景中。如果来自单个线程，则可以根据需要使用尽可能多的代码使用标准Dictionary；）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果您查看ConcurrentDictionary上的方法，则会发现一些有趣的方法，例如TryAdd，TryGetValue，TryUpdate和TryRemove。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，若使用普通的Dictionary类时可能会看到下面的代码"}]},{"type":"element","tag":"pre","props":{"code":"// There are better ways to do this... but we need an example ;)\nif (!dictionary.ContainsKey(id))\n    dictionary.Add(id, value);\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// There are better ways to do this... but we need an example ;)\nif (!dictionary.ContainsKey(id))\n    dictionary.Add(id, value);\n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多线程中同时调用该段代码,并且使用相同的id来调用Add,它将引发异常。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConcurrentDictionary方法TryAdd为您处理该问题，并将返回true/false，告诉您是否已添加它（或该键是否已在字典中）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，除非您在代码的多线程部分中进行工作，否则您可能仅可以使用标准的Dictionary类。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-16-ConcurrentDictionary.md","_source":"content","_file":"dotnet/2020-08-16-ConcurrentDictionary.md","_extension":"md","date":"2020-08-16"},{"_path":"/dotnet/2020-08-17-netcore-options","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"IOptions、IOptionsMonitor以及IOptionsSnapshot","description":"ASP.NET Core引入了Options模式，使用类来表示相关的设置组。简单的来说，就是用强类型的类来表达配置项，这带来了很多好处。\n初学者会发现这个框架有3个主要的面向消费者的接口：IOptions、IOptionsMonitor以及IOptionsSnapshot。\n这三个接口初看起来很类似，所以很容易引起困惑，什么场景下该用哪个接口呢？","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"背景"},"children":[{"type":"text","value":"背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ASP.NET Core引入了Options模式，使用类来表示相关的设置组。简单的来说，就是用强类型的类来表达配置项，这带来了很多好处。\n初学者会发现这个框架有3个主要的面向消费者的接口：IOptions、IOptionsMonitor以及IOptionsSnapshot。\n这三个接口初看起来很类似，所以很容易引起困惑，什么场景下该用哪个接口呢？"}]},{"type":"element","tag":"h1","props":{"id":"示例"},"children":[{"type":"text","value":"示例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先从一小段代码着手（TestOptions类只有一个字符串属性Name，代码略）："}]},{"type":"element","tag":"pre","props":{"code":"class Program\n{\n    static void Main(string[] args)\n    {\n        var builder = new ConfigurationBuilder();\n        builder.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true); //注意最后一个参数值，true表示配置文件更改时会重新加载。\n        var configuration = builder.Build();\n        var services = new ServiceCollection();\n        services.AddOptions();\n        services.Configure<TestOptions>(configuration); //这里通过配置文件绑定TestOptions\n        var provider = services.BuildServiceProvider();\n        Console.WriteLine(\"修改前：\");\n        Print(provider);\n\n        Change(provider); //使用代码修改Options值。\n        Console.WriteLine(\"使用代码修改后：\");\n        Print(provider);\n\n        Console.WriteLine(\"请修改配置文件。\");\n        Console.ReadLine(); //等待手动修改appsettings.json配置文件。\n        Console.WriteLine(\"修改appsettings.json文件后：\");\n        Print(provider);\n    }\n\n    static void Print(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            var options1 = sp.GetRequiredService<IOptions<TestOptions>>();\n            var options2 = sp.GetRequiredService<IOptionsMonitor<TestOptions>>();\n            var options3 = sp.GetRequiredService<IOptionsSnapshot<TestOptions>>();\n            Console.WriteLine(\"IOptions值: {0}\", options1.Value.Name);\n            Console.WriteLine(\"IOptionsMonitor值: {0}\", options2.CurrentValue.Name);\n            Console.WriteLine(\"IOptionsSnapshot值: {0}\", options3.Value.Name);\n            Console.WriteLine();\n        }\n    }\n\n    static void Change(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            sp.GetRequiredService<IOptions<TestOptions>>().Value.Name = \"IOptions Test 1\";\n            sp.GetRequiredService<IOptionsMonitor<TestOptions>>().CurrentValue.Name = \"IOptionsMonitor Test 1\";\n            sp.GetRequiredService<IOptionsSnapshot<TestOptions>>().Value.Name = \"IOptionsSnapshot Test 1\";\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Program\n{\n    static void Main(string[] args)\n    {\n        var builder = new ConfigurationBuilder();\n        builder.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true); //注意最后一个参数值，true表示配置文件更改时会重新加载。\n        var configuration = builder.Build();\n        var services = new ServiceCollection();\n        services.AddOptions();\n        services.Configure<TestOptions>(configuration); //这里通过配置文件绑定TestOptions\n        var provider = services.BuildServiceProvider();\n        Console.WriteLine(\"修改前：\");\n        Print(provider);\n\n        Change(provider); //使用代码修改Options值。\n        Console.WriteLine(\"使用代码修改后：\");\n        Print(provider);\n\n        Console.WriteLine(\"请修改配置文件。\");\n        Console.ReadLine(); //等待手动修改appsettings.json配置文件。\n        Console.WriteLine(\"修改appsettings.json文件后：\");\n        Print(provider);\n    }\n\n    static void Print(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            var options1 = sp.GetRequiredService<IOptions<TestOptions>>();\n            var options2 = sp.GetRequiredService<IOptionsMonitor<TestOptions>>();\n            var options3 = sp.GetRequiredService<IOptionsSnapshot<TestOptions>>();\n            Console.WriteLine(\"IOptions值: {0}\", options1.Value.Name);\n            Console.WriteLine(\"IOptionsMonitor值: {0}\", options2.CurrentValue.Name);\n            Console.WriteLine(\"IOptionsSnapshot值: {0}\", options3.Value.Name);\n            Console.WriteLine();\n        }\n    }\n\n    static void Change(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            sp.GetRequiredService<IOptions<TestOptions>>().Value.Name = \"IOptions Test 1\";\n            sp.GetRequiredService<IOptionsMonitor<TestOptions>>().CurrentValue.Name = \"IOptionsMonitor Test 1\";\n            sp.GetRequiredService<IOptionsSnapshot<TestOptions>>().Value.Name = \"IOptionsSnapshot Test 1\";\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"appsettings.json文件："}]},{"type":"element","tag":"pre","props":{"code":"{\n    \"Name\": \"Test 0\"\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n    \"Name\": \"Test 0\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的代码，首先从appsettings.json文件读取配置，然后向容器注册依赖配置文件的TestOptions，接着分别打印IOptions<>,IOptionsMonitor<>和IOptionsSnapshot<>的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着通过代码来修改TestOptions的值，打印。\n然后通过修改appsettings.json文件来修改TestOptions的值，打印。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"我们仅注册了一次TestOptions，却可以分别通过IOptions<>,IOptionsMonitor<>和IOptionsSnapshot<>接口来获取TestOptions的值。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们把appsettings.json文件中Name的值修改为Test 2，那么上面这段代码的输出是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-17-netcore-options/94928-20200323160553644-291512622.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"分析"},"children":[{"type":"text","value":"分析"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以看到第一次通过代码修改IOptions<>和IOptionsMonitor<>的值后，再次打印都被更新了，但是IOptionsSnapshot<>没有，为什么呢？\n让我们从Options框架的源代码着手，理解为什么会这样。\n当我们需要使用Options模式时，我们都会调用定义在OptionsServiceCollectionExtensions类上的扩展方法AddOptions(this IServiceCollection services)。"}]},{"type":"element","tag":"pre","props":{"code":"var services = new ServiceCollection();\nservices.AddOptions();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var services = new ServiceCollection();\nservices.AddOptions();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们观察AddOptions方法的实现："}]},{"type":"element","tag":"pre","props":{"code":"public static IServiceCollection AddOptions(this IServiceCollection services)\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptions<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Scoped(typeof(IOptionsSnapshot<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitor<>), typeof(OptionsMonitor<>)));\n    services.TryAdd(ServiceDescriptor.Transient(typeof(IOptionsFactory<>), typeof(OptionsFactory<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitorCache<>), typeof(OptionsCache<>)));\n    return services;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static IServiceCollection AddOptions(this IServiceCollection services)\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptions<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Scoped(typeof(IOptionsSnapshot<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitor<>), typeof(OptionsMonitor<>)));\n    services.TryAdd(ServiceDescriptor.Transient(typeof(IOptionsFactory<>), typeof(OptionsFactory<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitorCache<>), typeof(OptionsCache<>)));\n    return services;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从上面的代码我们可以得知，IOptions<>和IOptionsMonitor<>被注册为单例服务，而IOptionsSnapshot<>被注册为范围服务。\n由于IOptions<>和IOptionsMonitor<>都被注册为单例服务，因此每次获取的都是同一个实例，所以更改了以后的值是保留的。\n而IOptionsSnapshot<>被注册为范围服务，所以每次创建新范围时获取的都是一个新的值，外部的更改只对当次有效，不会保留到下次（不能跨范围，对于ASP.NET Core来说不能跨请求）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们继续看第二次修改，第二次修改配置文件后IOptionsMonitor<>和IOptionsSnapshot<>的值更新了，而IOptions<>的值没有更新。\nIOptions<>好理解，它被注册为单例服务，第一次访问的时候生成实例并加载配置文件中的值，此后再也不会读取配置文件，所以它的值不会更新。\nIOptionsSnapshot<>被注册为范围服务，每次重新生成一个新的范围时，它都会从配置文件中获取值，因此它的值会更新。\n但是，IOptionsMonitor<>呢，它被注册为单例，为什么也会更新呢？\n让我们回到AddOptions的源代码，我们留意到IOptionsMonitor<>的实现是OptionsManager<>。\n当我们打开OptionsManager的源代码时，一切都很清楚了。\n它的构造函数如下："}]},{"type":"element","tag":"pre","props":{"code":"public OptionsMonitor(IOptionsFactory<TOptions> factory, IEnumerable<IOptionsChangeTokenSource<TOptions>> sources, IOptionsMonitorCache<TOptions> cache)\n{\n    _factory = factory;\n    _sources = sources;\n    _cache = cache;\n\n    foreach (var source in _sources)\n    {\n        var registration = ChangeToken.OnChange(\n                () => source.GetChangeToken(),\n                (name) => InvokeChanged(name),\n                source.Name);\n\n        _registrations.Add(registration);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public OptionsMonitor(IOptionsFactory<TOptions> factory, IEnumerable<IOptionsChangeTokenSource<TOptions>> sources, IOptionsMonitorCache<TOptions> cache)\n{\n    _factory = factory;\n    _sources = sources;\n    _cache = cache;\n\n    foreach (var source in _sources)\n    {\n        var registration = ChangeToken.OnChange(\n                () => source.GetChangeToken(),\n                (name) => InvokeChanged(name),\n                source.Name);\n\n        _registrations.Add(registration);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原来OptionsMonitor的更新能力是从IOptionsChangeTokenSource而来，但是这个接口的实例又是谁呢？\n我们回到最开始的代码的第10行："}]},{"type":"element","tag":"pre","props":{"code":"services.Configure<TestOptions>(configuration);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"services.Configure<TestOptions>(configuration);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个定义在Microsoft.Extensions.Options.ConfigurationExtensions.dll的扩展方法，最后实际调用的是它的一个重载方法，代码如下："}]},{"type":"element","tag":"pre","props":{"code":"public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config, Action<BinderOptions> configureBinder)\n    where TOptions : class\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    if (config == null)\n    {\n        throw new ArgumentNullException(nameof(config));\n    }\n\n    services.AddOptions();\n    services.AddSingleton<IOptionsChangeTokenSource<TOptions>>(new ConfigurationChangeTokenSource<TOptions>(name, config));\n    return services.AddSingleton<IConfigureOptions<TOptions>>(new NamedConfigureFromConfigurationOptions<TOptions>(name, config, configureBinder));\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config, Action<BinderOptions> configureBinder)\n    where TOptions : class\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    if (config == null)\n    {\n        throw new ArgumentNullException(nameof(config));\n    }\n\n    services.AddOptions();\n    services.AddSingleton<IOptionsChangeTokenSource<TOptions>>(new ConfigurationChangeTokenSource<TOptions>(name, config));\n    return services.AddSingleton<IConfigureOptions<TOptions>>(new NamedConfigureFromConfigurationOptions<TOptions>(name, config, configureBinder));\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"秘密就在上面的第15行，ConfigurationChangeTokenSource，它引用了代表配置文件的对象config，所以配置文件更新，IOptionsMonitor就会跟着更新。"}]},{"type":"element","tag":"h1","props":{"id":"结论"},"children":[{"type":"text","value":"结论"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOptions<>是单例，因此一旦生成了，除非通过代码的方式更改，它的值是不会更新的。\nIOptionsMonitor<>也是单例，但是它通过IOptionsChangeTokenSource<> 能够和配置文件一起更新，也能通过代码的方式更改值。\nIOptionsSnapshot<>是范围，所以在配置文件更新的下一次访问，它的值会更新，但是它不能跨范围通过代码的方式更改值，只能在当前范围（请求）内有效。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"官方文档是这样介绍的：\nIOptionsMonitor用于检索选项和管理TOptions实例的选项通知，它支持下面的场景："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"实例更新通知。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"命名实例。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重新加载配置。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"选择性的让实例失效。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOptionsSnapshot在需要对每个请求重新计算选项的场景中非常有用。\nIOptions可以用来支持Options模式，但是它不支持前面两者所支持的场景，如果你不需要支持上面的场景，你可以继续使用IOptions。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以你应该根据你的实际使用场景来选择到底是用这三者中的哪一个。\n"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"一般来说，如果你依赖配置文件，那么首先考虑IOptionsMonitor<>，如果不合适接着考虑IOptionsSnapshot<>，最后考虑IOptions<>。*"}]},{"type":"text","value":"\n***有一点需要注意，在ASP.NET Core应用中IOptionsMonitor可能会导致同一个请求中选项的值不一致——当你正在修改配置文件的时候——这可能会引发一些奇怪的bug。\n如果这个对你很重要，请使用IOptionsSnapshot，它可以保证同一个请求中的一致性，但是它可能会带来轻微的性能上的损失。\n如果你是在app启动的时候自己构造Options（比如在Startup类中）："}]},{"type":"element","tag":"pre","props":{"code":"services.Configure<TestOptions>(opt => opt.Name = \"Test 0\");\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"services.Configure<TestOptions>(opt => opt.Name = \"Test 0\");\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOptions<>最简单，也许是一个不错的选择，Configure扩展方法还有其他重载可以满足你的更多需求。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-17-netcore-options.md","_source":"content","_file":"dotnet/2020-08-17-netcore-options.md","_extension":"md","date":"2020-08-17"},{"_path":"/dotnet/2020-11-13-reflection-method","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":".NET Core/Framework 创建委托以大幅度提高反射调用的性能","description":"都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为反射得到的方法创建一个委托，此后调用此委托将能够提高近乎直接调用方法本身的性能。（当然 Emit 也能够帮助我们显著提升性能，不过直接得到可以调用的委托不是更加方便吗？）"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h3","props":{"id":"性能对比数据"},"children":[{"type":"text","value":"性能对比数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"性能对比数据","src":"/images/2020-11-13-Reflection-Method/20180227195855828"},"children":[]},{"type":"text","value":"\n▲ 没有什么能够比数据更有说服力（注意后面两行是有秒数的）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可能我还需要解释一下那五行数据的含义："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"直接调用（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"应该没有什么比直接调用函数本身更有性能优势的吧"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"做一个跟直接调用的方法功能一模一样的委托（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"本文重点"}]},{"type":"text","value":" 将反射出来的方法创建一个委托，然后调用这个委托（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"看看吧，性能跟直接调差别也不大嘛"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"先反射得到方法，然后一直调用这个方法（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缓存都不用，从头开始反射然后调用得到的方法（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"100 多倍的性能损失了"}]},{"type":"text","value":"）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是测试代码，可以更好地理解上图数据的含义："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace Walterlv.Demo\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // 调用的目标实例。\n            var instance = new StubClass();\n\n            // 使用反射找到的方法。\n            var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) });\n            Assert.IsNotNull(method);\n\n            // 将反射找到的方法创建一个委托。\n            var func = InstanceMethodBuilder<int, int>.CreateInstanceMethod(instance, method);\n\n            // 跟被测方法功能一样的纯委托。\n            Func<int, int> pureFunc = value => value;\n\n            // 测试次数。\n            var count = 10000000;\n\n            // 直接调用。\n            var watch = new Stopwatch();\n            watch.Start();\n            for (var i = 0; i < count; i++)\n            {\n                var result = instance.Test(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接调用\");\n\n            // 使用同样功能的 Func 调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = pureFunc(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用\");\n\n            // 使用反射创建出来的委托调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = func(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用\");\n\n            // 使用反射得到的方法缓存调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = method.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用\");\n\n            // 直接使用反射调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) })\n                    ?.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接使用反射调用\");\n        }\n\n        private class StubClass\n        {\n            public int Test(int i)\n            {\n                return i;\n            }\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace Walterlv.Demo\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // 调用的目标实例。\n            var instance = new StubClass();\n\n            // 使用反射找到的方法。\n            var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) });\n            Assert.IsNotNull(method);\n\n            // 将反射找到的方法创建一个委托。\n            var func = InstanceMethodBuilder<int, int>.CreateInstanceMethod(instance, method);\n\n            // 跟被测方法功能一样的纯委托。\n            Func<int, int> pureFunc = value => value;\n\n            // 测试次数。\n            var count = 10000000;\n\n            // 直接调用。\n            var watch = new Stopwatch();\n            watch.Start();\n            for (var i = 0; i < count; i++)\n            {\n                var result = instance.Test(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接调用\");\n\n            // 使用同样功能的 Func 调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = pureFunc(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用\");\n\n            // 使用反射创建出来的委托调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = func(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用\");\n\n            // 使用反射得到的方法缓存调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = method.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用\");\n\n            // 直接使用反射调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) })\n                    ?.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接使用反射调用\");\n        }\n\n        private class StubClass\n        {\n            public int Test(int i)\n            {\n                return i;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"如何实现"},"children":[{"type":"text","value":"如何实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现的关键就在于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MethodInfo.CreateDelegate"}]},{"type":"text","value":" 方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此方法有两个重载："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要求传入一个类型，而这个类型就是应该转成的委托的类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拿上面的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StubClass"}]},{"type":"text","value":" 来说明会更直观一些："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"private class StubClass\n{\n    public int Test(int i)\n    {\n        return i;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private class StubClass\n{\n    public int Test(int i)\n    {\n        return i;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前者得到的委托相当于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int Test(int i)"}]},{"type":"text","value":" 方法，后者得到的委托相当于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int Test(StubClass instance, int i)"}]},{"type":"text","value":" 方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单独使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateDelegate"}]},{"type":"text","value":" 方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics.Contracts;\n\nnamespace Walterlv.Demo\n{\n    public static class InstanceMethodBuilder<T, TReturnValue>\n    {\n        /// <summary>\n        /// 调用时就像 var result = func(t)。\n        /// </summary>\n        [Pure]\n        public static Func<T, TReturnValue> CreateInstanceMethod<TInstanceType>(TInstanceType instance, MethodInfo method)\n        {\n            if (instance == null) throw new ArgumentNullException(nameof(instance));\n            if (method == null) throw new ArgumentNullException(nameof(method));\n\n            return (Func<T, TReturnValue>) method.CreateDelegate(typeof(Func<T, TReturnValue>), instance);\n        }\n\n        /// <summary>\n        /// 调用时就像 var result = func(this, t)。\n        /// </summary>\n        [Pure]\n        public static Func<TInstanceType, T, TReturnValue> CreateMethod<TInstanceType>(MethodInfo method)\n        {\n            if (method == null)\n                throw new ArgumentNullException(nameof(method));\n\n            return (Func<TInstanceType, T, TReturnValue>) method.CreateDelegate(typeof(Func<TInstanceType, T, TReturnValue>));\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics.Contracts;\n\nnamespace Walterlv.Demo\n{\n    public static class InstanceMethodBuilder<T, TReturnValue>\n    {\n        /// <summary>\n        /// 调用时就像 var result = func(t)。\n        /// </summary>\n        [Pure]\n        public static Func<T, TReturnValue> CreateInstanceMethod<TInstanceType>(TInstanceType instance, MethodInfo method)\n        {\n            if (instance == null) throw new ArgumentNullException(nameof(instance));\n            if (method == null) throw new ArgumentNullException(nameof(method));\n\n            return (Func<T, TReturnValue>) method.CreateDelegate(typeof(Func<T, TReturnValue>), instance);\n        }\n\n        /// <summary>\n        /// 调用时就像 var result = func(this, t)。\n        /// </summary>\n        [Pure]\n        public static Func<TInstanceType, T, TReturnValue> CreateMethod<TInstanceType>(MethodInfo method)\n        {\n            if (method == null)\n                throw new ArgumentNullException(nameof(method));\n\n            return (Func<TInstanceType, T, TReturnValue>) method.CreateDelegate(typeof(Func<TInstanceType, T, TReturnValue>));\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"泛型的多参数版本可以使用泛型类型生成器生成，我在 "},{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/WPwalter/article/details/79216183","rel":["nofollow"]},"children":[{"type":"text","value":"生成代码，从 "}]},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"到"}]},{"type":"text","value":" —— 自动生成多个类型的泛型 - 吕毅 一文中写了一个泛型生成器，可以稍加修改以便适应这种泛型类。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"性能对比数据","depth":3,"text":"性能对比数据"},{"id":"如何实现","depth":3,"text":"如何实现"}]}},"_type":"markdown","_id":"content:dotnet:2020-11-13-Reflection-Method.md","_source":"content","_file":"dotnet/2020-11-13-Reflection-Method.md","_extension":"md","date":"2020-11-13"},{"_path":"/dotnet/2020-11-24-flags","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"C＃枚举中使用Flags特性","description":"假如有类型 Show 的定义如下十進位表示法\n[Flags]\nenum Days\n{\n    None      = 0,  // 0000 0000\n    Sunday    = 1,  // 0000 0001\n    Monday    = 2,  // 0000 0010\n    Tuesday   = 4,  // 0000 0100\n    Wednesday = 8,  // 0000 1000\n    Thursday  = 16, // 0001 0000\n    Friday    = 32, // 0010 0000\n    Saturday  = 64  // 010","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如有类型 Show 的定义如下"}]},{"type":"element","tag":"pre","props":{"code":"十進位表示法\n[Flags]\nenum Days\n{\n    None      = 0,  // 0000 0000\n    Sunday    = 1,  // 0000 0001\n    Monday    = 2,  // 0000 0010\n    Tuesday   = 4,  // 0000 0100\n    Wednesday = 8,  // 0000 1000\n    Thursday  = 16, // 0001 0000\n    Friday    = 32, // 0010 0000\n    Saturday  = 64  // 0100 0000\n}\n位元移位表示法\n[Flags]\nenum Days\n{\n    None      = 0,      // 0000 0000\n    Sunday    = 1 << 0, // 0000 0001\n    Monday    = 1 << 1, // 0000 0010\n    Tuesday   = 1 << 2, // 0000 0100\n    Wednesday = 1 << 3, // 0000 1000\n    Thursday  = 1 << 4, // 0001 0000\n    Friday    = 1 << 5, // 0010 0000\n    Saturday  = 1 << 6  // 0100 0000\n}\n二進位表示法 (C# 7.2新增)\n[Flags]\nenum Days\n{\n    None      = 0b_0000_0000, // 0000 0000\n    Sunday    = 0b_0000_0001, // 0000 0001\n    Monday    = 0b_0000_0010, // 0000 0010\n    Tuesday   = 0b_0000_0100, // 0000 0100\n    Wednesday = 0b_0000_1000, // 0000 1000\n    Thursday  = 0b_0001_0000, // 0001 0000\n    Friday    = 0b_0010_0000, // 0010 0000\n    Saturday  = 0b_0100_0000  // 0100 0000\n}\n \n十六進位表示法\n[Flags]\nenum RenderType\n{\n   None = 0x0,\n   DataUri = 0x1,\n   GZip = 0x2,\n   ContentPage = 0x4,\n   ViewPage = 0x8,\n   HomePage = 0x10 // Next two values could be 0x20, 0x40\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"十進位表示法\n[Flags]\nenum Days\n{\n    None      = 0,  // 0000 0000\n    Sunday    = 1,  // 0000 0001\n    Monday    = 2,  // 0000 0010\n    Tuesday   = 4,  // 0000 0100\n    Wednesday = 8,  // 0000 1000\n    Thursday  = 16, // 0001 0000\n    Friday    = 32, // 0010 0000\n    Saturday  = 64  // 0100 0000\n}\n位元移位表示法\n[Flags]\nenum Days\n{\n    None      = 0,      // 0000 0000\n    Sunday    = 1 << 0, // 0000 0001\n    Monday    = 1 << 1, // 0000 0010\n    Tuesday   = 1 << 2, // 0000 0100\n    Wednesday = 1 << 3, // 0000 1000\n    Thursday  = 1 << 4, // 0001 0000\n    Friday    = 1 << 5, // 0010 0000\n    Saturday  = 1 << 6  // 0100 0000\n}\n二進位表示法 (C# 7.2新增)\n[Flags]\nenum Days\n{\n    None      = 0b_0000_0000, // 0000 0000\n    Sunday    = 0b_0000_0001, // 0000 0001\n    Monday    = 0b_0000_0010, // 0000 0010\n    Tuesday   = 0b_0000_0100, // 0000 0100\n    Wednesday = 0b_0000_1000, // 0000 1000\n    Thursday  = 0b_0001_0000, // 0001 0000\n    Friday    = 0b_0010_0000, // 0010 0000\n    Saturday  = 0b_0100_0000  // 0100 0000\n}\n \n十六進位表示法\n[Flags]\nenum RenderType\n{\n   None = 0x0,\n   DataUri = 0x1,\n   GZip = 0x2,\n   ContentPage = 0x4,\n   ViewPage = 0x8,\n   HomePage = 0x10 // Next two values could be 0x20, 0x40\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"& 按位与"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"| 按位或"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"^ 按位异或"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"~取反"}]}]},{"type":"element","tag":"h2","props":{"id":"并集-添加"},"children":[{"type":"text","value":"并集 (添加)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a|b: 并集(所有的和,相同部分只算一次);"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A | B\n{'英语', '物理', '语文', '政治', '化学', '数学', '生物', '地理', '历史'}\n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A | B\n{'英语', '物理', '语文', '政治', '化学', '数学', '生物', '地理', '历史'}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182659146","src":"/images/2020-11-24-flags/image-20210404182659146.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"差集-去除"},"children":[{"type":"text","value":"差集 (去除)"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & (~B)\n{'物理', '生物', '化学'}\n>>> B & (~A)\n{'政治', '历史', '地理'}\n  \n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & (~B)\n{'物理', '生物', '化学'}\n>>> B & (~A)\n{'政治', '历史', '地理'}\n  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182718872","src":"/images/2020-11-24-flags/image-20210404182718872.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"补集对称差集"},"children":[{"type":"text","value":"补集(对称差集)"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A ^ B\n{'物理', '生物', '化学', '政治', '历史', '地理'}\n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A ^ B\n{'物理', '生物', '化学', '政治', '历史', '地理'}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182742701","src":"/images/2020-11-24-flags/image-20210404182742701.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182802570","src":"/images/2020-11-24-flags/image-20210404182802570.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"交集-检查"},"children":[{"type":"text","value":"交集  (检查)"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & B\n{'英语', '语文', '数学'}\n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & B\n{'英语', '语文', '数学'}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者"}]},{"type":"element","tag":"pre","props":{"code":"  Show show = Show.A | Show.B;\n  show.HasFlag(Show.A);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  Show show = Show.A | Show.B;\n  show.HasFlag(Show.A);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从性能上看通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&"}]},{"type":"text","value":" 的性能会比 HasFlag 高，但是从可读性上 HasFlag 更友好，如果你的代码没有性能问题推荐使用 HasFlag 方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182612251","src":"/images/2020-11-24-flags/image-20210404182612251.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"并集-添加","depth":2,"text":"并集 (添加)"},{"id":"差集-去除","depth":2,"text":"差集 (去除)"},{"id":"补集对称差集","depth":2,"text":"补集(对称差集)"},{"id":"交集-检查","depth":2,"text":"交集  (检查)"}]}},"_type":"markdown","_id":"content:dotnet:2020-11-24-flags.md","_source":"content","_file":"dotnet/2020-11-24-flags.md","_extension":"md","date":"2020-11-24"},{"_path":"/dotnet/2020-12-11-chrome-login-fail","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"谷歌浏览器下netcore登录失败问题","description":"IntroductionWhen you use HTTP on your Identity Server 4 enabled website, users may not login because of the changes made by Chrome in the version 8x. This occurs when you use HTTP schema in your website. The issue is explained here https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#h","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"introduction"},"children":[{"type":"text","value":"Introduction"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When you use HTTP on your Identity Server 4 enabled website, users may not login because of the changes made by Chrome in the version 8x. This occurs when you use HTTP schema in your website. The issue is explained here "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication"}]}]},{"type":"element","tag":"h2","props":{"id":"how-to-solve-it"},"children":[{"type":"text","value":"How to solve it?"}]},{"type":"element","tag":"h3","props":{"id":"step-1"},"children":[{"type":"text","value":"Step-1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Create the below extension in your *"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":".Web"}]},{"type":"text","value":" project."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    public static class SameSiteCookiesServiceCollectionExtensions\n    {\n        /// <summary>\n        /// -1 defines the unspecified value, which tells ASPNET Core to NOT\n        /// send the SameSite attribute. With ASPNET Core 3.1 the\n        /// <seealso cref=\"SameSiteMode\" /> enum will have a definition for\n        /// Unspecified.\n        /// </summary>\n        private const SameSiteMode Unspecified = (SameSiteMode)(-1);\n\n        /// <summary>\n        /// Configures a cookie policy to properly set the SameSite attribute\n        /// for Browsers that handle unknown values as Strict. Ensure that you\n        /// add the <seealso cref=\"Microsoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware\" />\n        /// into the pipeline before sending any cookies!\n        /// </summary>\n        /// <remarks>\n        /// Minimum ASPNET Core Version required for this code:\n        ///   - 2.1.14\n        ///   - 2.2.8\n        ///   - 3.0.1\n        ///   - 3.1.0-preview1\n        /// Starting with version 80 of Chrome (to be released in February 2020)\n        /// cookies with NO SameSite attribute are treated as SameSite=Lax.\n        /// In order to always get the cookies send they need to be set to\n        /// SameSite=None. But since the current standard only defines Lax and\n        /// Strict as valid values there are some browsers that treat invalid\n        /// values as SameSite=Strict. We therefore need to check the browser\n        /// and either send SameSite=None or prevent the sending of SameSite=None.\n        /// Relevant links:\n        /// - https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1\n        /// - https://tools.ietf.org/html/draft-west-cookie-incrementalism-00\n        /// - https://www.chromium.org/updates/same-site\n        /// - https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// - https://bugs.webkit.org/show_bug.cgi?id=198181\n        /// </remarks>\n        /// <param name=\"services\">The service collection to register <see cref=\"CookiePolicyOptions\" /> into.</param>\n        /// <returns>The modified <see cref=\"IServiceCollection\" />.</returns>\n        public static IServiceCollection ConfigureNonBreakingSameSiteCookies(this IServiceCollection services)\n        {\n            services.Configure<CookiePolicyOptions>(options =>\n            {\n                options.MinimumSameSitePolicy = Unspecified;\n                options.OnAppendCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n                options.OnDeleteCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n            });\n\n            return services;\n        }\n\n        private static void CheckSameSite(HttpContext httpContext, CookieOptions options)\n        {\n            if (options.SameSite == SameSiteMode.None)\n            {\n                var userAgent = httpContext.Request.Headers[\"User-Agent\"].ToString();\n\n                if (DisallowsSameSiteNone(userAgent))\n                {\n                    options.SameSite = Unspecified;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Checks if the UserAgent is known to interpret an unknown value as Strict.\n        /// For those the <see cref=\"CookieOptions.SameSite\" /> property should be\n        /// set to <see cref=\"Unspecified\" />.\n        /// </summary>\n        /// <remarks>\n        /// This code is taken from Microsoft:\n        /// https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// </remarks>\n        /// <param name=\"userAgent\">The user agent string to check.</param>\n        /// <returns>Whether the specified user agent (browser) accepts SameSite=None or not.</returns>\n        private static bool DisallowsSameSiteNone(string userAgent)\n        {\n            // Cover all iOS based browsers here. This includes:\n            //   - Safari on iOS 12 for iPhone, iPod Touch, iPad\n            //   - WkWebview on iOS 12 for iPhone, iPod Touch, iPad\n            //   - Chrome on iOS 12 for iPhone, iPod Touch, iPad\n            // All of which are broken by SameSite=None, because they use the\n            // iOS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite iOS versions lower\n            // than 12 are not supporting SameSite at all. Starting with version 13\n            // unknown values are NOT treated as strict anymore. Therefore we only\n            // need to check version 12.\n            if (userAgent.Contains(\"CPU iPhone OS 12\")\n               || userAgent.Contains(\"iPad; CPU OS 12\"))\n            {\n                return true;\n            }\n\n            // Cover Mac OS X based browsers that use the Mac OS networking stack.\n            // This includes:\n            //   - Safari on Mac OS X.\n            // This does not include:\n            //   - Chrome on Mac OS X\n            // because they do not use the Mac OS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite MacOS X versions lower\n            // than 10.14 are not supporting SameSite at all. Starting with version\n            // 10.15 unknown values are NOT treated as strict anymore. Therefore we\n            // only need to check version 10.14.\n            if (userAgent.Contains(\"Safari\")\n               && userAgent.Contains(\"Macintosh; Intel Mac OS X 10_14\")\n               && userAgent.Contains(\"Version/\"))\n            {\n                return true;\n            }\n\n            // Cover Chrome 50-69, because some versions are broken by SameSite=None\n            // and none in this range require it.\n            // Note: this covers some pre-Chromium Edge versions,\n            // but pre-Chromium Edge does not require SameSite=None.\n            // Notes from Thinktecture:\n            // We can not validate this assumption, but we trust Microsofts\n            // evaluation. And overall not sending a SameSite value equals to the same\n            // behavior as SameSite=None for these old versions anyways.\n            if (userAgent.Contains(\"Chrome/5\") || userAgent.Contains(\"Chrome/6\"))\n            {\n                return true;\n            }\n\n            if (GetChromeVersion(userAgent) >= 80)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private static int GetChromeVersion(string userAgent)\n        {\n            try\n            {\n                return Convert.ToInt32(userAgent.Split(\"Chrome/\")[1].Split('.')[0]);\n            }\n            catch (Exception)\n            {\n                return 0;\n            }\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    public static class SameSiteCookiesServiceCollectionExtensions\n    {\n        /// <summary>\n        /// -1 defines the unspecified value, which tells ASPNET Core to NOT\n        /// send the SameSite attribute. With ASPNET Core 3.1 the\n        /// <seealso cref=\"SameSiteMode\" /> enum will have a definition for\n        /// Unspecified.\n        /// </summary>\n        private const SameSiteMode Unspecified = (SameSiteMode)(-1);\n\n        /// <summary>\n        /// Configures a cookie policy to properly set the SameSite attribute\n        /// for Browsers that handle unknown values as Strict. Ensure that you\n        /// add the <seealso cref=\"Microsoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware\" />\n        /// into the pipeline before sending any cookies!\n        /// </summary>\n        /// <remarks>\n        /// Minimum ASPNET Core Version required for this code:\n        ///   - 2.1.14\n        ///   - 2.2.8\n        ///   - 3.0.1\n        ///   - 3.1.0-preview1\n        /// Starting with version 80 of Chrome (to be released in February 2020)\n        /// cookies with NO SameSite attribute are treated as SameSite=Lax.\n        /// In order to always get the cookies send they need to be set to\n        /// SameSite=None. But since the current standard only defines Lax and\n        /// Strict as valid values there are some browsers that treat invalid\n        /// values as SameSite=Strict. We therefore need to check the browser\n        /// and either send SameSite=None or prevent the sending of SameSite=None.\n        /// Relevant links:\n        /// - https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1\n        /// - https://tools.ietf.org/html/draft-west-cookie-incrementalism-00\n        /// - https://www.chromium.org/updates/same-site\n        /// - https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// - https://bugs.webkit.org/show_bug.cgi?id=198181\n        /// </remarks>\n        /// <param name=\"services\">The service collection to register <see cref=\"CookiePolicyOptions\" /> into.</param>\n        /// <returns>The modified <see cref=\"IServiceCollection\" />.</returns>\n        public static IServiceCollection ConfigureNonBreakingSameSiteCookies(this IServiceCollection services)\n        {\n            services.Configure<CookiePolicyOptions>(options =>\n            {\n                options.MinimumSameSitePolicy = Unspecified;\n                options.OnAppendCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n                options.OnDeleteCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n            });\n\n            return services;\n        }\n\n        private static void CheckSameSite(HttpContext httpContext, CookieOptions options)\n        {\n            if (options.SameSite == SameSiteMode.None)\n            {\n                var userAgent = httpContext.Request.Headers[\"User-Agent\"].ToString();\n\n                if (DisallowsSameSiteNone(userAgent))\n                {\n                    options.SameSite = Unspecified;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Checks if the UserAgent is known to interpret an unknown value as Strict.\n        /// For those the <see cref=\"CookieOptions.SameSite\" /> property should be\n        /// set to <see cref=\"Unspecified\" />.\n        /// </summary>\n        /// <remarks>\n        /// This code is taken from Microsoft:\n        /// https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// </remarks>\n        /// <param name=\"userAgent\">The user agent string to check.</param>\n        /// <returns>Whether the specified user agent (browser) accepts SameSite=None or not.</returns>\n        private static bool DisallowsSameSiteNone(string userAgent)\n        {\n            // Cover all iOS based browsers here. This includes:\n            //   - Safari on iOS 12 for iPhone, iPod Touch, iPad\n            //   - WkWebview on iOS 12 for iPhone, iPod Touch, iPad\n            //   - Chrome on iOS 12 for iPhone, iPod Touch, iPad\n            // All of which are broken by SameSite=None, because they use the\n            // iOS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite iOS versions lower\n            // than 12 are not supporting SameSite at all. Starting with version 13\n            // unknown values are NOT treated as strict anymore. Therefore we only\n            // need to check version 12.\n            if (userAgent.Contains(\"CPU iPhone OS 12\")\n               || userAgent.Contains(\"iPad; CPU OS 12\"))\n            {\n                return true;\n            }\n\n            // Cover Mac OS X based browsers that use the Mac OS networking stack.\n            // This includes:\n            //   - Safari on Mac OS X.\n            // This does not include:\n            //   - Chrome on Mac OS X\n            // because they do not use the Mac OS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite MacOS X versions lower\n            // than 10.14 are not supporting SameSite at all. Starting with version\n            // 10.15 unknown values are NOT treated as strict anymore. Therefore we\n            // only need to check version 10.14.\n            if (userAgent.Contains(\"Safari\")\n               && userAgent.Contains(\"Macintosh; Intel Mac OS X 10_14\")\n               && userAgent.Contains(\"Version/\"))\n            {\n                return true;\n            }\n\n            // Cover Chrome 50-69, because some versions are broken by SameSite=None\n            // and none in this range require it.\n            // Note: this covers some pre-Chromium Edge versions,\n            // but pre-Chromium Edge does not require SameSite=None.\n            // Notes from Thinktecture:\n            // We can not validate this assumption, but we trust Microsofts\n            // evaluation. And overall not sending a SameSite value equals to the same\n            // behavior as SameSite=None for these old versions anyways.\n            if (userAgent.Contains(\"Chrome/5\") || userAgent.Contains(\"Chrome/6\"))\n            {\n                return true;\n            }\n\n            if (GetChromeVersion(userAgent) >= 80)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private static int GetChromeVersion(string userAgent)\n        {\n            try\n            {\n                return Convert.ToInt32(userAgent.Split(\"Chrome/\")[1].Split('.')[0]);\n            }\n            catch (Exception)\n            {\n                return 0;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"step-2"},"children":[{"type":"text","value":"Step-2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Assume that your project name is "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Acme.BookStore"}]},{"type":"text","value":". Then open "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AcmeBookStoreWebModule.cs"}]},{"type":"text","value":" class."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Add the following line to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConfigureServices()"}]},{"type":"text","value":" method."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"context.Services.ConfigureNonBreakingSameSiteCookies();\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"context.Services.ConfigureNonBreakingSameSiteCookies();\n"}]}]},{"type":"element","tag":"h3","props":{"id":"step-3"},"children":[{"type":"text","value":"Step-3"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Go to"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnApplicationInitialization()"}]},{"type":"text","value":" method in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AcmeBookStoreWebModule.cs"}]},{"type":"text","value":" add "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"app.UseCookiePolicy();"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n        var app = context.GetApplicationBuilder();\n        var env = context.GetEnvironment();\n\n        if (env.IsDevelopment())\n        {\n                app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n                app.UseErrorPage();\n                app.UseHsts();\n        }\n         // Before UseAuthentication or anything else that writes cookies.\n        app.UseCookiePolicy(); //<--- added this --->\n\n    //....\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n        var app = context.GetApplicationBuilder();\n        var env = context.GetEnvironment();\n\n        if (env.IsDevelopment())\n        {\n                app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n                app.UseErrorPage();\n                app.UseHsts();\n        }\n         // Before UseAuthentication or anything else that writes cookies.\n        app.UseCookiePolicy(); //<--- added this --->\n\n    //....\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It's all! You are ready to go!"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Referenced from "},{"type":"element","tag":"a","props":{"href":"https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"introduction","depth":2,"text":"Introduction"},{"id":"how-to-solve-it","depth":2,"text":"How to solve it?","children":[{"id":"step-1","depth":3,"text":"Step-1"},{"id":"step-2","depth":3,"text":"Step-2"},{"id":"step-3","depth":3,"text":"Step-3"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-12-11-chrome-login-fail.md","_source":"content","_file":"dotnet/2020-12-11-chrome-login-fail.md","_extension":"md","date":"2020-12-11"},{"_path":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Converting between Structs and Byte Arrays","description":"In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more information through inheritance, attributes, and more.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more information through inheritance, attributes, and more."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"However, sometimes we need to extract the data contained in these types – for example for sending network messages, or saving to disk. In this post we will look into converting between structs and byte arrays, to make exactly this possible."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We will compare different ways of doing so, and analyse them for performance and easy of use."}]},{"type":"element","tag":"h2","props":{"id":"why-byte-arrays"},"children":[{"type":"text","value":"Why byte arrays?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The reason we will be looking into serialising our data into byte arrays is because these are essentially the most fundamental data storage format. We can easily write them to a network buffer or stream, or to a file."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are many alternatives and none of them will be right for every single use case. For example, I like to use JSON files to store settings, scripts, and text-based assets, as well as asset meta data."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In those cases performance is not the most important consideration. Instead it is more valuable to be able to edit and review files easily inside a text editor."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In situations where performance is important however – such as the mentioned networking or compact file storage – serialising only the relevant data itself and skipping the encoding and formatting inherent to clear text files can be key."}]},{"type":"element","tag":"h2","props":{"id":"why-structures"},"children":[{"type":"text","value":"Why structures?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several reasons for why we are talking about structures specifically."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"First, I want to make a clear distinction between data and behaviour, by using a type that contains exactly the data we are interested in serialising."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Secondly, structures are much more reliable and controllable when it comes to binary data layout. We will see how this is important for our last method of serialisation."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Overall, we can use structures to directly represent the data that will be written into our byte array. For our example of networking this means that we have a clear one to one correspondence between our structures and our network messages."}]},{"type":"element","tag":"h2","props":{"id":"binaryformatter"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In our first method of converting between structs and byte arrays, we will make use of .NET’s "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":" class."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The entire purpose of that class is to serialise an object into binary format (i.e. a byte array) – as well as deserialising the same back into objects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The class offers a lot of functionality – most of which we are not interested in here. Of interest to us are only two methods: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Serialize()"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Deserialize()"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"These methods allow us to read/write our data to any stream. In many cases we could use this to write to a network – or file – buffer or stream directly. For our purpose – and for ease of testing, we will use the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MemoryStream"}]},{"type":"text","value":" class which is little more than a stream wrapper around a byte array in the first place."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here are two generic methods that do exactly this:"}]},{"type":"element","tag":"pre","props":{"code":"public static byte[] Serialize<T>(T data)\n    where T : struct\n{\n    var formatter = new BinaryFormatter();\n    var stream = new MemoryStream();\n    formatter.Serialize(stream, data);\n    return stream.ToArray();\n}\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var stream = new MemoryStream(array);\n    var formatter = new BinaryFormatter();\n    return (T)formatter.Deserialize(stream);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static byte[] Serialize<T>(T data)\n    where T : struct\n{\n    var formatter = new BinaryFormatter();\n    var stream = new MemoryStream();\n    formatter.Serialize(stream, data);\n    return stream.ToArray();\n}\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var stream = new MemoryStream(array);\n    var formatter = new BinaryFormatter();\n    return (T)formatter.Deserialize(stream);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"These methods can now be easily used like this:"}]},{"type":"element","tag":"pre","props":{"code":"[Serializable] // BinaryFormatter needs this attribute\nstruct MyStruct\n{\n    // some fields here\n}\n\nvar data = new MyStruct();\nvar bytes = Serialize(data);\nvar data2 = Deserialize<MyStruct>(bytes);\n// data and data2 now contain the same values\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Serializable] // BinaryFormatter needs this attribute\nstruct MyStruct\n{\n    // some fields here\n}\n\nvar data = new MyStruct();\nvar bytes = Serialize(data);\nvar data2 = Deserialize<MyStruct>(bytes);\n// data and data2 now contain the same values\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This looks great!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It seems that we have found a solution that is both easy to use, and requires almost no work if we want to expand it. Allowing for the conversion of new structs simple requires the addition of the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Serializable"}]},{"type":"text","value":" attribute, while we have to do nothing at all if we modify our structures to include more, less, or different data."}]},{"type":"element","tag":"h3","props":{"id":"performance"},"children":[{"type":"text","value":"Performance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"How about performance?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I wrote a little test that both serialises and deserialises hundreds of thousands of times, and repeats that process several times to make sure we get accurate results. You can find the full code of it "},{"type":"element","tag":"a","props":{"href":"https://github.com/amulware/genericgamedev-tests/tree/master/src/StructByteArrayConversion","rel":["nofollow"]},"children":[{"type":"text","value":"on my GitHub"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here are the results:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":",\n– converting a 16 byte structs to an array one million times takes 4.86 seconds;\n– converting an array to a 16 byte struct one million times takes 3.85 seconds."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This means that a single call to either of our methods takes less than 5 microseconds."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"That is pretty good!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"With this performance we can easily write and read thousands of networking messages per second before we will notice the performance impact. That is easily enough for most games and other real-time applications."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There is another kind of performance measurement that is important however – and especially so when it comes to networking: Bandwidth."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The struct I ran the tests with consisted of exactly 16 bytes. That means that in principle we should be able to write it into a byte array with length 16. The BinaryFormatter however – and this is related to the other features it has – writes a total of 218 bytes to the array."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Suffice it to say: That is a whole lot more."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The advantage of this is, that the object that is deserialised will actually be of the correct type. I merely made the method generic so that we could perform the cast and return the structure boxed in the result of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter.Deserialize()"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are cases were we care less about the amount of data, and prefer to handle our data in this way. For this post however, I want to find a method that results in an array as small as possible."}]},{"type":"element","tag":"h2","props":{"id":"binarywriterbinaryreader"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Our second case study will be two other .NET classes: "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.io.binaryreader(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":" and "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.io.binarywriter(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"BinaryReader"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"These classes are much simpler. They do little more than allowing us to write and read primitive types like integers and booleans to and from an arbitrary stream."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This means that we cannot write the entire structure to our stream with just a single line of code any more. Instead we need to write and read all fields manually:"}]},{"type":"element","tag":"pre","props":{"code":"struct MyStruct\n{\n    int anInteger;\n    float aFloat;\n    long aLong;\n\n    public byte[] ToArray()\n    {\n        var stream = new MemoryStream();\n        var writer = new BinaryWriter(stream);\n\n        writer.Write(this.anInteger);\n        writer.Write(this.aFloat);\n        writer.Write(this.aLong);\n\n        return stream.ToArray();\n    }\n\n    public static MyStruct FromArray(byte[] bytes)\n    {\n        var reader = new BinaryReader(new MemoryStream(bytes));\n\n        var s = default(MyStruct);\n\n        s.anInteger = reader.ReadInt32();\n        s.aFloat = reader.ReadSingle();\n        s.aLong = reader.ReadInt64();\n\n        return s;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct MyStruct\n{\n    int anInteger;\n    float aFloat;\n    long aLong;\n\n    public byte[] ToArray()\n    {\n        var stream = new MemoryStream();\n        var writer = new BinaryWriter(stream);\n\n        writer.Write(this.anInteger);\n        writer.Write(this.aFloat);\n        writer.Write(this.aLong);\n\n        return stream.ToArray();\n    }\n\n    public static MyStruct FromArray(byte[] bytes)\n    {\n        var reader = new BinaryReader(new MemoryStream(bytes));\n\n        var s = default(MyStruct);\n\n        s.anInteger = reader.ReadInt32();\n        s.aFloat = reader.ReadSingle();\n        s.aLong = reader.ReadInt64();\n\n        return s;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using these methods is similarly easy to the ones above:"}]},{"type":"element","tag":"pre","props":{"code":"var data = new MyStruct();\nvar array = data.ToArray();\nvar data2 = MyStruct.FromArray(array);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var data = new MyStruct();\nvar array = data.ToArray();\nvar data2 = MyStruct.FromArray(array);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this case, the returned array is indeed exactly 16 bytes long."}]},{"type":"element","tag":"h3","props":{"id":"performance-1"},"children":[{"type":"text","value":"Performance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"But how does this manual approach measure up in performance?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Very well!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In my test, the times for serialising and deserialising went from 4.86 and 3.85 down to 0.50 and 0.20 seconds respectively (again for one million conversions each)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It turns out this approach is not only space efficient, but it is also around ten times faster than the previous one – seemingly no reason to look back!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In fact, there is an optimisation we can make to increase performance even further: We do not have to create new "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MemoryStream"}]},{"type":"text","value":"s and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":"s for each method call. Instead we can reuse them – either by having static ones (watch out for thread-safety!) or by keeping them in whatever object manages for example our network traffic."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Doing so drops my measured time down to 0.14 and 0.11 seconds respectively."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that the same optimisation can be applied to the first method. However – while positive – the performance increase is much less than in this case, relative to the overall much worse time."}]},{"type":"element","tag":"h3","props":{"id":"some-concerns"},"children":[{"type":"text","value":"Some concerns"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If we do look back to the code however, note how if we add another structure that we would like to serialise, we have to add the two methods to it, and adapt them to its fields."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Further, if we change one of our structures, we have to make sure to reflect that change in both of these methods. We are bound to forget – especially when adding a new field – which could easily result in a small debugging nightmare."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ideally we can find a solution that is fast, uses little space, and does not require us to continuously maintain our serialisation code."}]},{"type":"element","tag":"h2","props":{"id":"marshalling"},"children":[{"type":"text","value":"Marshalling"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The last approach we will take a look at is that of marshalling."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Marshalling refers to using both managed and unmanaged data and the transfer between them. By default, any object created in C# lives in managed memory, which has a lot of advantages – such as automatic garbage collection. Using unmanaged memory on the other hand is more difficult in C#, and requires us to allocate and free space manually. If we forget to do so, we may cause memory leaks that will eventually cause our application to crash."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"All of the functionality we are interested in can be found in the static "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal(v=vs.100).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"Marshal"}]},{"type":"text","value":" class."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Specifically, we will use:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.SizeOf()"}]},{"type":"text","value":"\nto determine the byte size of our structs;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.AllocHGlobal()"}]},{"type":"text","value":"\nto allocate unmanaged memory;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.StructureToPtr()"}]},{"type":"text","value":"\nto marshal (copy) our structure to the allocated unmanaged memory;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.PtrToStructure()"}]},{"type":"text","value":"\nto marshal (copy) from unmanaged memory back to our structure;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.Copy()"}]},{"type":"text","value":"\nto copy between the unmanaged memory and our byte array;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.FreeHGlobal()"}]},{"type":"text","value":"\nto free the allocated memory;"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using these methods we can construct the following methods:"}]},{"type":"element","tag":"pre","props":{"code":"public static byte[] Serialize<T>(T s)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var array = new byte[size];\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.StructureToPtr(s, ptr, true);\n    Marshal.Copy(ptr, array, 0, size);\n    Marshal.FreeHGlobal(ptr);\n    return array;\n}\n\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.Copy(array, 0, ptr, size);\n    var s = (T)Marshal.PtrToStructure(ptr, typeof(T));\n    Marshal.FreeHGlobal(ptr);\n    return s;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static byte[] Serialize<T>(T s)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var array = new byte[size];\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.StructureToPtr(s, ptr, true);\n    Marshal.Copy(ptr, array, 0, size);\n    Marshal.FreeHGlobal(ptr);\n    return array;\n}\n\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.Copy(array, 0, ptr, size);\n    var s = (T)Marshal.PtrToStructure(ptr, typeof(T));\n    Marshal.FreeHGlobal(ptr);\n    return s;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that due to the unsafety of using unmanaged memory, we may want to use a "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/zwc8s4fz.aspx","rel":["nofollow"]},"children":[{"type":"text","value":"try – finally"}]},{"type":"text","value":" block to make sure the memory will always be freed, even if something goes wrong. For brevity, this is left out here."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When testing our code, which again is as easy to use as before – in fact the method signatures are exactly the same as our first pair – we see that it indeed works as we hope."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Without any code inside our structures and completely generic methods there is no need to write or maintain any code when adding or modifying structures."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Further the resulting array is the expected 16 bytes long."}]},{"type":"element","tag":"h3","props":{"id":"performance-2"},"children":[{"type":"text","value":"Performance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When running these methods through the tests, converting structs to byte arrays and vice versa takes a mere 0.47 and 0.60 seconds respectively (again for one million calls)."}]},{"type":"element","tag":"h2","props":{"id":"comparison"},"children":[{"type":"text","value":"Comparison"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here is a table with the results from the performance tests:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"16 byte struct"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"struct to array"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"array to struct"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary formatter (218 byte array!)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4.86s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3.85s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary writer/reader"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.50s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.20s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"binary w/r (singleton)"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.14s"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.11s"}]}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"marshalling"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.47s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.60s"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clearly, if what we care about most is performance, writing and reading our data manually, using shared "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]},{"type":"text","value":" objects is the fastest method."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On the other hand, the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal"}]},{"type":"text","value":" methods allow for much easier reuse and make our code significantly more robust to change since there is no code to update and maintain."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To provide some more data, here are the results from the same test, but this time with a 128 byte structure:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"128 byte struct"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"struct to array"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"array to struct"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary formatter (218 byte array!)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"17.32s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"14.47s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary writer/reader"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1.48s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.66s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"binary w/r (singleton)"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.78s"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.56s"}]}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"marshalling"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.84s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.75s"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We can see that the relative ordering of the different measurements is still the same. However, note how the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]},{"type":"text","value":" measurements are getting significantly closer to the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal"}]},{"type":"text","value":" ones."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While I would not necessarily encourage structures of this size, I would argue that marshalling is the best approach for large structures in almost every case. The slightly slower performance is easily justified by the much more maintainable code."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In fact, I would go as far and say that even for small structures the ease of using marshalling is still top advantageous despite the lower performance."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the end, binary serialization is unlikely to ever be a bottleneck, and unless it is, we should choose the option that fulfils our requirements of small array size and ease of use."}]},{"type":"element","tag":"h2","props":{"id":"conclusion"},"children":[{"type":"text","value":"Conclusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We took a look at three – and a half – different ways of converting between structs and byte arrays."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Judging by memory usage, performance, and ease of use, there is no clear winner – only a clear loser unless we specifically need the additional functionality of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"However, in marshalling we found a method that is reasonably fast, while acing our other requirements."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While in extremely performance critical code we may want to write our data manually, marshalling is likely the best alternative in the vast majority of cases."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Feel free to let me know if you agree with this analysis, or if you have other methods of achieving the same result that may be worth looking into."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Enjoy the pixels!"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"why-byte-arrays","depth":2,"text":"Why byte arrays?"},{"id":"why-structures","depth":2,"text":"Why structures?"},{"id":"binaryformatter","depth":2,"text":"BinaryFormatter","children":[{"id":"performance","depth":3,"text":"Performance"}]},{"id":"binarywriterbinaryreader","depth":2,"text":"BinaryWriter/BinaryReader","children":[{"id":"performance-1","depth":3,"text":"Performance"},{"id":"some-concerns","depth":3,"text":"Some concerns"}]},{"id":"marshalling","depth":2,"text":"Marshalling","children":[{"id":"performance-2","depth":3,"text":"Performance"}]},{"id":"comparison","depth":2,"text":"Comparison"},{"id":"conclusion","depth":2,"text":"Conclusion"}]}},"_type":"markdown","_id":"content:dotnet:2021-05-01-Converting-between-Structs-and-Byte-Arrays.md","_source":"content","_file":"dotnet/2021-05-01-Converting-between-Structs-and-Byte-Arrays.md","_extension":"md","date":"2021-05-01"},{"_path":"/dotnet/2022-08-15-equal-hashcode","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","description":"先看一个不负责任的写法//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n  ","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看一个不负责任的写法"}]},{"type":"element","tag":"pre","props":{"code":"//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n        }\n        public override bool Equals(object obj)\n        {\n            return true;\n        }\n \n    }\n    class Program\n    {\n            \n        static void Sum<T>() where T : MyMethod, new()\n        {\n            T t1 = new T();\n            T t2 = new T();\n             \n            t1.a = 3; t2.a = 4;//不会报错           \n             //t1.a=3;t2.a=3;报错，字典中已经存在相同键\n             Dictionary<MyMethod, int> d = new Dictionary<MyMethod, int>();\n            d.Add(t1, 1);\n            d.Add(t2, 2);\n            \n            \n        }\n        static void Main(string[] args)\n        {\n            \n            Sum<MyMethod>();\n            Console.Read();\n \n        }\n       \n    }\n \n}\n \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n        }\n        public override bool Equals(object obj)\n        {\n            return true;\n        }\n \n    }\n    class Program\n    {\n            \n        static void Sum<T>() where T : MyMethod, new()\n        {\n            T t1 = new T();\n            T t2 = new T();\n             \n            t1.a = 3; t2.a = 4;//不会报错           \n             //t1.a=3;t2.a=3;报错，字典中已经存在相同键\n             Dictionary<MyMethod, int> d = new Dictionary<MyMethod, int>();\n            d.Add(t1, 1);\n            d.Add(t2, 2);\n            \n            \n        }\n        static void Main(string[] args)\n        {\n            \n            Sum<MyMethod>();\n            Console.Read();\n \n        }\n       \n    }\n \n}\n \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说Dictionary的Add的具体实现,ILSpy反编译中C#Dictionary的Add方法源码："}]},{"type":"element","tag":"pre","props":{"code":"public void Add(TKey key, TValue value)\n{\n    this.Insert(key, value, true);\n}\n \n \nprivate void Insert(TKey key, TValue value, bool add)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n    if (this.buckets == null)\n    {\n        this.Initialize(0);\n    }\n    \n    int num = this.comparer.GetHashCode(key) & 2147483647;\n    int num2 = num % this.buckets.Length;\n    int num3 = 0;\n    for (int i = this.buckets[num2]; i >= 0; i = this.entries[i].next)\n    {\n        //如果hash值和字典中某个值的hash值相等 且 两个值的Equals返回值为True Trow 异常：已添加了具有相同键的项。\n        if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))\n        {\n            if (add)\n            {\n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            this.entries[i].value = value;\n            this.version++;\n            return;\n        }\n        num3++;\n    }\n    int num4;\n    if (this.freeCount > 0)\n    {\n        num4 = this.freeList;\n        this.freeList = this.entries[num4].next;\n        this.freeCount--;\n    }\n    else\n    {\n        if (this.count == this.entries.Length)\n        {\n            this.Resize();\n            num2 = num % this.buckets.Length;\n        }\n        num4 = this.count;\n        this.count++;\n    }\n    this.entries[num4].hashCode = num;\n    this.entries[num4].next = this.buckets[num2];\n    this.entries[num4].key = key;\n    this.entries[num4].value = value;\n    this.buckets[num2] = num4;\n    this.version++;\n    if (num3 > 100 && HashHelpers.IsWellKnownEqualityComparer(this.comparer))\n    {\n        this.comparer = (IEqualityComparer<TKey>)HashHelpers.GetRandomizedEqualityComparer(this.comparer);\n        this.Resize(this.entries.Length, true);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Add(TKey key, TValue value)\n{\n    this.Insert(key, value, true);\n}\n \n \nprivate void Insert(TKey key, TValue value, bool add)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n    if (this.buckets == null)\n    {\n        this.Initialize(0);\n    }\n    \n    int num = this.comparer.GetHashCode(key) & 2147483647;\n    int num2 = num % this.buckets.Length;\n    int num3 = 0;\n    for (int i = this.buckets[num2]; i >= 0; i = this.entries[i].next)\n    {\n        //如果hash值和字典中某个值的hash值相等 且 两个值的Equals返回值为True Trow 异常：已添加了具有相同键的项。\n        if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))\n        {\n            if (add)\n            {\n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            this.entries[i].value = value;\n            this.version++;\n            return;\n        }\n        num3++;\n    }\n    int num4;\n    if (this.freeCount > 0)\n    {\n        num4 = this.freeList;\n        this.freeList = this.entries[num4].next;\n        this.freeCount--;\n    }\n    else\n    {\n        if (this.count == this.entries.Length)\n        {\n            this.Resize();\n            num2 = num % this.buckets.Length;\n        }\n        num4 = this.count;\n        this.count++;\n    }\n    this.entries[num4].hashCode = num;\n    this.entries[num4].next = this.buckets[num2];\n    this.entries[num4].key = key;\n    this.entries[num4].value = value;\n    this.buckets[num2] = num4;\n    this.version++;\n    if (num3 > 100 && HashHelpers.IsWellKnownEqualityComparer(this.comparer))\n    {\n        this.comparer = (IEqualityComparer<TKey>)HashHelpers.GetRandomizedEqualityComparer(this.comparer);\n        this.Resize(this.entries.Length, true);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当每次调用Dictionary的Add方法时，参数都将与Dictionary中的值进行Equals，大家都知道DIctionary是用Hash值进行存储的，而hash值的计算方法是通过Object.GetHashCode实现的，如果这2个方法不一致，那么很容易就出现问题，特别是Dictionary中的Add方法这种情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"个人理解Dictionary的Add方法的实现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Add()->GetHashCode(),Equals()->判断2个hashcode是否相等 和Equals返回值是否为True->若同时成立，抛异常。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GetHashCode的目的不是为一个对象生成唯一的标识符，而是为了实现基于哈希表的数据结构，如Dictionary<K, V>或HashSet。 哈希函数需要确保如果x == ==y，那么x.GetHashCode()==  y.GetHashCode()，但反过来就不对了：两个不同的对象可以有相同的哈希代码。这种情况被称为哈希碰撞。 如果存在碰撞，哈希表结构仍然可以工作，但它们的运行速度较慢，因为你的程序必须花时间来分辨你要搜索的是哪个碰撞对象。因此，一个好的散列函数将努力使碰撞最小化。(注意，如果一个类有232个以上的可能值，要完全避免碰撞在数学上是不可能的，因为有鸽子笼原则）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，你如何为你的类写一个好的GetHashCode实现呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"做一些复杂的数学运算，将你的类的每一个字段转换为int，然后通过剖析来确定其中的系数的最佳值？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据Troelsen的说法，不需要。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要在你的 \"最独特 \"的字符串字段上调用GetHashCode()就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写System.String.GetHashCode的开发者知道他们在做什么，所以只要使用它，你就会自动利用他们的 \"坚实的哈希码算法\"。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2022-08-15-equal-hashcode.md","_source":"content","_file":"dotnet/2022-08-15-equal-hashcode.md","_extension":"md","date":"2022-08-15"},{"_path":"/game/2021-01-20-perlin-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"使用柏林噪声算法生成地图","description":"柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得奥斯卡科技成果奖（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的改进版柏林噪声算法。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。\n如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/doc/oscar.html","rel":["nofollow"]},"children":[{"type":"text","value":"奥斯卡科技成果奖"}]},{"type":"text","value":"（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/noise/","rel":["nofollow"]},"children":[{"type":"text","value":"改进版柏林噪声算法"}]},{"type":"text","value":"。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。\n如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://images2015.cnblogs.com/blog/608996/201707/608996-20170721155322355-1352334868.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/608996-20170721155322355-1352334868.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正如图所示，柏林噪声算法可以用来模拟许多自然中的噪声现象。接下来让我们从数理上分析算法的实现原理。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"基本原理"},"children":[{"type":"text","value":"基本原理#"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：事先声明，本节内容大多源于"},{"type":"element","tag":"a","props":{"href":"http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html","rel":["nofollow"]},"children":[{"type":"text","value":"this wonderful article by Matt Zucker"}]},{"type":"text","value":"，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们从最基本的柏林噪声函数看起：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"public double perlin(double x, double y, double z);"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"函数接收"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x,y,z"}]},{"type":"text","value":"三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x,y,z"}]},{"type":"text","value":"的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-bfbbc85ed4afee99.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-bfbbc85ed4afee99.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子来理解伪随机，比如我们从圆周率π（3.14159...）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-ad4b0120e857b5d3.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-ad4b0120e857b5d3.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图2：各顶点上的梯度向量随机选取结果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用这些特殊梯度向量的原因在"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/paper445.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"Ken Perlin's SIGGRAPH 2002 paper: Improving Noise"}]},{"type":"text","value":"这篇文章里有具体讲解。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：许多介绍柏林噪声算法的文章都是根据最初版柏林噪声算法来讲解的，预定义的梯度表不是本文所说的这12个向量。如图2所示的梯度向量就是最初版算法所随机出来的梯度向量，不过这两种算法的原理都是一样的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-6dde06b2b941253d.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-6dde06b2b941253d.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图3:各个距离向量"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，对每个顶点的梯度向量和距离向量做"},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Dot_product","rel":["nofollow"]},"children":[{"type":"text","value":"点积"}]},{"type":"text","value":"运算，我们就可以得出每个顶点的影响值：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad.x * dist.x + grad.y * dist.y + grad.z * dist.z"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"dot(vec1,vec2) = cos(angle(vec1,vec2)) * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"dot(vec1,vec2) = cos(angle(vec1,vec2)) * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说，如果两向量指向同一方向，点积结果为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"1 * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"1 * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果两向量指向相反方向，则点积结果为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"-1 * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-1 * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果两向量互相垂直，则点积结果为0。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"0 * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"0 * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。下面通过一副彩色图，直观地看下各顶点的影响值："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-0c7ca0db2126715a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-0c7ca0db2126715a.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图4：2D柏林噪声的影响值"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"// Below are 4 influence values in the arrangement:\n// [g1] | [g2]\n// -----------\n// [g3] | [g4]\nint g1, g2, g3, g4;\nint u, v;   // These coordinates are the location of the input coordinate in its unit square.  \n            // For example a value of (0.5,0.5) is in the exact center of its unit square.\n\nint x1 = lerp(g1,g2,u);\nint x2 = lerp(g3,h4,u);\n\nint average = lerp(x1,x2,v);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Below are 4 influence values in the arrangement:\n// [g1] | [g2]\n// -----------\n// [g3] | [g4]\nint g1, g2, g3, g4;\nint u, v;   // These coordinates are the location of the input coordinate in its unit square.  \n            // For example a value of (0.5,0.5) is in the exact center of its unit square.\n\nint x1 = lerp(g1,g2,u);\nint x2 = lerp(g3,h4,u);\n\nint average = lerp(x1,x2,v);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"fade函数"}]},{"type":"text","value":"，通常也被称为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ease curve"}]},{"type":"text","value":"(也作为缓动函数在游戏中广泛使用)："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-27f5e6997742a89a.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-27f5e6997742a89a.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图5：ease curve"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"代码实现"},"children":[{"type":"text","value":"代码实现#"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在本节开始前我需要重申一遍，代码实现是C#版本。相比"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/noise/","rel":["nofollow"]},"children":[{"type":"text","value":"Ken Perlin的Java版本实现"}]},{"type":"text","value":"做了小小的改动，主要是增加了代码的整洁性和可读性，支持噪声重复（瓦片重复）特性。代码完全开源，可免费使用（考虑到这毕竟不是我原创发明的算法 - Ken Perlin才是！）"}]},{"type":"element","tag":"h2","props":{"id":"准备工作"},"children":[{"type":"text","value":"准备工作##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一步，我们需要先声明一个排列表（permutation table），或者直接缩写为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组就行了。数组长度为256，分别随机、无重复地存放了0-255这些数值。为了避免缓存溢出，我们再重复填充一次数组的值，所以数组最终长度为512："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"private static readonly int[] permutation = { 151,160,137,91,90,15,                 // Hash lookup table as defined by Ken Perlin.  This is a randomly\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    // arranged array of all numbers from 0-255 inclusive.\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\nprivate static readonly int[] p;                                                    // Doubled permutation to avoid overflow\n\nstatic Perlin() {\n    p = new int[512];\n    for(int x=0;x<512;x++) {\n        p[x] = permutation[x%256];\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private static readonly int[] permutation = { 151,160,137,91,90,15,                 // Hash lookup table as defined by Ken Perlin.  This is a randomly\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    // arranged array of all numbers from 0-255 inclusive.\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\nprivate static readonly int[] p;                                                    // Doubled permutation to avoid overflow\n\nstatic Perlin() {\n    p = new int[512];\n    for(int x=0;x<512;x++) {\n        p[x] = permutation[x%256];\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组会在算法后续的哈希计算中使用到，用于确定一组输入最终挑选哪个梯度向量（从前面所列出的12个梯度向量中挑选）。后续代码会详细展示"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组的用法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，我们开始编写柏林噪声函数："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double perlin(double x, double y, double z) {\n    if(repeat > 0) {                                    // If we have any repeat on, change the coordinates to their \"local\" repetitions\n        x = x%repeat;\n        y = y%repeat;\n        z = z%repeat;\n    }\n    \n    int xi = (int)x & 255;                              // Calculate the \"unit cube\" that the point asked will be located in\n    int yi = (int)y & 255;                              // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\n    int zi = (int)z & 255;                              // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\n    double xf = x-(int)x;\n    double yf = y-(int)y;\n    double zf = z-(int)z;\n    // ...\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double perlin(double x, double y, double z) {\n    if(repeat > 0) {                                    // If we have any repeat on, change the coordinates to their \"local\" repetitions\n        x = x%repeat;\n        y = y%repeat;\n        z = z%repeat;\n    }\n    \n    int xi = (int)x & 255;                              // Calculate the \"unit cube\" that the point asked will be located in\n    int yi = (int)y & 255;                              // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\n    int zi = (int)z & 255;                              // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\n    double xf = x-(int)x;\n    double yf = y-(int)y;\n    double zf = z-(int)z;\n    // ...\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的代码很直观。首先，对输入坐标使用求余运算符%，求出[0,repeat)范围内的余数。紧接着声明"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"xi, yi, zi"}]},{"type":"text","value":"三个变量。它们代表了输入坐标落在了哪个单元正方形里。我们还要限制坐标在[0,255]这个范围内，避免访问数组"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"时，出现数组越界错误。这也产生了一个副作用：柏林噪声每隔256个整数就会再次重复。但这不是太大的问题，因为算法不仅能处理整数，还能处理小数。最后，我们通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"xf, yf, zf"}]},{"type":"text","value":"三个变量（也就是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x,y,z"}]},{"type":"text","value":"的小数部分值），确定了输入坐标在单元正方形里的空间位置（就是前面所示的小蓝点）。"}]},{"type":"element","tag":"h2","props":{"id":"fade函数"},"children":[{"type":"text","value":"Fade函数##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们需要用代码表示前面所提到的fade函数（图5）。正如上文所提，函数的数学表示：\n"},{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码实现如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public static double fade(double t) {\n                                                        // Fade function as defined by Ken Perlin.  This eases coordinate values\n                                                        // so that they will ease towards integral values.  This ends up smoothing\n                                                        // the final output.\n    return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3\n}\n\npublic double perlin(double x, double y, double z) {\n    // ...\n\n    double u = fade(xf);\n    double v = fade(yf);\n    double w = fade(zf);\n\n    // ...\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static double fade(double t) {\n                                                        // Fade function as defined by Ken Perlin.  This eases coordinate values\n                                                        // so that they will ease towards integral values.  This ends up smoothing\n                                                        // the final output.\n    return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3\n}\n\npublic double perlin(double x, double y, double z) {\n    // ...\n\n    double u = fade(xf);\n    double v = fade(yf);\n    double w = fade(zf);\n\n    // ...\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码所计算得出的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"u / v / w"}]},{"type":"text","value":"变量将在后面的插值计算中使用到。"}]},{"type":"element","tag":"h2","props":{"id":"哈希函数"},"children":[{"type":"text","value":"哈希函数##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声哈希函数用于给每组输入计算返回一个唯一、确定值。哈希函数在维基百科的定义如下："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法，输入数据有任何细微的不同，都会令输出结果完全不一样"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面代码就是柏林噪声算法所使用的哈希函数。它使用了早前我们声明的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double perlin(double x, double y, double z) {\n    // ...\n\n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n\n    // ...\n}\n\npublic int inc(int num) {\n    num++;\n    if (repeat > 0) num %= repeat;\n    \n    return num;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double perlin(double x, double y, double z) {\n    // ...\n\n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n\n    // ...\n}\n\npublic int inc(int num) {\n    num++;\n    if (repeat > 0) num %= repeat;\n    \n    return num;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码的哈希函数，对包围着输入坐标（小蓝点）的周围8个单元正方形的索引坐标进行了哈希计算。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"inc()"}]},{"type":"text","value":"函数用于将输入值增加1，同时保证范围在[0,repeat)内。如果不需要噪声重复，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"inc()"}]},{"type":"text","value":"函数可以简化成单纯将输入值增加1。由于哈希结果值是从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组中得到的，所以哈希函数的返回值范围限定在[0,255]内。"}]},{"type":"element","tag":"h2","props":{"id":"梯度函数"},"children":[{"type":"text","value":"梯度函数##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我时常认为Ken Perlin的最初版算法里的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad()"}]},{"type":"text","value":"函数写法过于复杂，令人费解。我们只要明白"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad()"}]},{"type":"text","value":"函数的作用在于计算随机选取的梯度向量以及顶点位置向量的点积。Ken Perlin巧妙地使用了位翻转(bit-flipping)技巧来实现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public static double grad(int hash, double x, double y, double z) {\n    int h = hash & 15;                                    // Take the hashed value and take the first 4 bits of it (15 == 0b1111)\n    double u = h < 8 /* 0b1000 */ ? x : y;                // If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.\n    \n    double v;                                             // In Ken Perlin's original implementation this was another conditional operator (?:).  I\n                                                          // expanded it for readability.\n    \n    if(h < 4 /* 0b0100 */)                                // If the first and second significant bits are 0 set v = y\n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)  // If the first and second significant bits are 1 set v = x\n        v = x;\n    else                                                  // If the first and second significant bits are not equal (0/1, 1/0) set v = z\n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static double grad(int hash, double x, double y, double z) {\n    int h = hash & 15;                                    // Take the hashed value and take the first 4 bits of it (15 == 0b1111)\n    double u = h < 8 /* 0b1000 */ ? x : y;                // If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.\n    \n    double v;                                             // In Ken Perlin's original implementation this was another conditional operator (?:).  I\n                                                          // expanded it for readability.\n    \n    if(h < 4 /* 0b0100 */)                                // If the first and second significant bits are 0 set v = y\n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)  // If the first and second significant bits are 1 set v = x\n        v = x;\n    else                                                  // If the first and second significant bits are not equal (0/1, 1/0) set v = z\n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面代码则是以另一种令人容易理解的方式完成了这个任务（而且在很多语言版本的运行效率都优于前面一种）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"// Source: http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html\npublic static double grad(int hash, double x, double y, double z)\n{\n    switch(hash & 0xF)\n    {\n        case 0x0: return  x + y;\n        case 0x1: return -x + y;\n        case 0x2: return  x - y;\n        case 0x3: return -x - y;\n        case 0x4: return  x + z;\n        case 0x5: return -x + z;\n        case 0x6: return  x - z;\n        case 0x7: return -x - z;\n        case 0x8: return  y + z;\n        case 0x9: return -y + z;\n        case 0xA: return  y - z;\n        case 0xB: return -y - z;\n        case 0xC: return  y + x;\n        case 0xD: return -y + z;\n        case 0xE: return  y - x;\n        case 0xF: return -y - z;\n        default: return 0; // never happens\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Source: http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html\npublic static double grad(int hash, double x, double y, double z)\n{\n    switch(hash & 0xF)\n    {\n        case 0x0: return  x + y;\n        case 0x1: return -x + y;\n        case 0x2: return  x - y;\n        case 0x3: return -x - y;\n        case 0x4: return  x + z;\n        case 0x5: return -x + z;\n        case 0x6: return  x - z;\n        case 0x7: return -x - z;\n        case 0x8: return  y + z;\n        case 0x9: return -y + z;\n        case 0xA: return  y - z;\n        case 0xB: return -y - z;\n        case 0xC: return  y + x;\n        case 0xD: return -y + z;\n        case 0xE: return  y - x;\n        case 0xF: return -y - z;\n        default: return 0; // never happens\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上的源码可以"},{"type":"element","tag":"a","props":{"href":"http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html","rel":["nofollow"]},"children":[{"type":"text","value":"点击这里"}]},{"type":"text","value":"查看。无论如何，上面的两种实现并没有实质差别。他们都是从以下12个向量里随机挑选一个作为梯度向量：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随机挑选结果其实取决于前一步所计算得出的哈希值（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad()"}]},{"type":"text","value":"函数的第一个参数）。后面3个参数则代表由输入点指向顶点的距离向量（最终拿来与梯度向量进行点积）。"}]},{"type":"element","tag":"h2","props":{"id":"插值整合"},"children":[{"type":"text","value":"插值整合##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"经过前面的几步计算，我们得出了8个顶点的影响值，并将它们进行平滑插值，得出了最终结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double perlin(double x, double y, double z) {\n    // ...\n\n    double x1, x2, y1, y2;\n    x1 = lerp(    grad (aaa, xf  , yf  , zf),           // The gradient function calculates the dot product between a pseudorandom\n                grad (baa, xf-1, yf  , zf),             // gradient vector and the vector from the input coordinate to the 8\n                u);                                     // surrounding points in its unit cube.\n    x2 = lerp(    grad (aba, xf  , yf-1, zf),           // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\n                grad (bba, xf-1, yf-1, zf),             // values we made earlier.\n                  u);\n    y1 = lerp(x1, x2, v);\n\n    x1 = lerp(    grad (aab, xf  , yf  , zf-1),\n                grad (bab, xf-1, yf  , zf-1),\n                u);\n    x2 = lerp(    grad (abb, xf  , yf-1, zf-1),\n                  grad (bbb, xf-1, yf-1, zf-1),\n                  u);\n    y2 = lerp (x1, x2, v);\n    \n    return (lerp (y1, y2, w)+1)/2;                      // For convenience we bind the result to 0 - 1 (theoretical min/max before is [-1, 1])\n}\n\n// Linear Interpolate\npublic static double lerp(double a, double b, double x) {\n    return a + x * (b - a);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double perlin(double x, double y, double z) {\n    // ...\n\n    double x1, x2, y1, y2;\n    x1 = lerp(    grad (aaa, xf  , yf  , zf),           // The gradient function calculates the dot product between a pseudorandom\n                grad (baa, xf-1, yf  , zf),             // gradient vector and the vector from the input coordinate to the 8\n                u);                                     // surrounding points in its unit cube.\n    x2 = lerp(    grad (aba, xf  , yf-1, zf),           // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\n                grad (bba, xf-1, yf-1, zf),             // values we made earlier.\n                  u);\n    y1 = lerp(x1, x2, v);\n\n    x1 = lerp(    grad (aab, xf  , yf  , zf-1),\n                grad (bab, xf-1, yf  , zf-1),\n                u);\n    x2 = lerp(    grad (abb, xf  , yf-1, zf-1),\n                  grad (bbb, xf-1, yf-1, zf-1),\n                  u);\n    y2 = lerp (x1, x2, v);\n    \n    return (lerp (y1, y2, w)+1)/2;                      // For convenience we bind the result to 0 - 1 (theoretical min/max before is [-1, 1])\n}\n\n// Linear Interpolate\npublic static double lerp(double a, double b, double x) {\n    return a + x * (b - a);\n}\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"利用倍频实现更自然的噪声"},"children":[{"type":"text","value":"利用倍频实现更自然的噪声#"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后让我们再思考下，除了前面所讲的计算，还有其他办法可以令噪声结果更加自然吗？虽然柏林噪声算法一定程度上模拟了自然噪声，但仍没有完全表现出自然噪声的不规律性。举个现实例子，现实地形会有大段连绵、高耸的山地，也会有丘陵和蚀坑，更小点的有大块岩石，甚至更小的鹅卵石块，这都属于地形的一部分。那如何让柏林噪声算法模拟出这样的自然噪声特性，解决方法也很简单：我们可以使用不同的频率（frequencies）和振幅（amplitudes）参数进行多几次柏林噪声计算，然后将结果叠加在一起。频率是指采样数据的间隔，振幅是指返回值的幅度范围。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-6f96e55ed8d87b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-6f96e55ed8d87b04.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图6：不同频率和振幅参数下的柏林噪声结果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将所有结果叠加在一起，我们就能得到以下结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-c69b2bf9e253defb.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-c69b2bf9e253defb.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图7：图6所有噪声的叠加结果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很明显，这样的噪声结果更加令人信服。上面的6组噪声被称之为噪声的不同"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"倍频(Octave)"}]},{"type":"text","value":"。随着倍频增大，噪声对于最终叠加噪声的影响程度变小。当然，倍频组数的增加，会线性地增加代码执行时间，在游戏运行时使用噪声算法，再好不要使用超过几组倍频（比如，当你想在60fps下模拟火焰特效时，最好不要这么干）。然而，做数据预处理时，就很适合使用多组倍频叠加来模拟更自然的噪声（比如用于提前生成游戏地形等）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那我们应该分别挑选多大的频率和振幅来进行噪声计算呢？这个可以通过"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"persistence"}]},{"type":"text","value":"参数确定。"},{"type":"element","tag":"a","props":{"href":"http://freespace.virgin.net/hugo.elias/models/m_perlin.htm","rel":["nofollow"]},"children":[{"type":"text","value":"Hugo Elias"}]},{"type":"text","value":"对persistence的定义使用如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-b7093e0ea840d56c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-b7093e0ea840d56c.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-006ffe9e12825253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-006ffe9e12825253.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上公式"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"i"}]},{"type":"text","value":"的值取决于倍频数量，代码实现也很简单："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double OctavePerlin(double x, double y, double z, int octaves, double persistence) {\n    double total = 0;\n    double frequency = 1;\n    double amplitude = 1;\n    double maxValue = 0;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += perlin(x * frequency, y * frequency, z * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2;\n    }\n    \n    return total/maxValue;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double OctavePerlin(double x, double y, double z, int octaves, double persistence) {\n    double total = 0;\n    double frequency = 1;\n    double amplitude = 1;\n    double maxValue = 0;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += perlin(x * frequency, y * frequency, z * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2;\n    }\n    \n    return total/maxValue;\n}\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"unity"},"children":[{"type":"text","value":"UNITY"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"准备工作","depth":2,"text":"准备工作##"},{"id":"fade函数","depth":2,"text":"Fade函数##"},{"id":"哈希函数","depth":2,"text":"哈希函数##"},{"id":"梯度函数","depth":2,"text":"梯度函数##"},{"id":"插值整合","depth":2,"text":"插值整合##"}]}},"_type":"markdown","_id":"content:game:2021-01-20-Perlin-map.md","_source":"content","_file":"game/2021-01-20-Perlin-map.md","_extension":"md","date":"2021-01-20"},{"_path":"/game/2021-01-21-wave-collapse-function","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"波函数坍塌算法生成地图","description":"什么是“波函数坍塌”？这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"什么是波函数坍塌"},"children":[{"type":"text","value":"什么是“波函数坍塌”？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才有了一个比较霸气的名字而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"开发这些模型或者贴图合成技术是为了能使用一块很小的由人工制作的贴图或者模型来生成大量相似的贴图或者模型。这样可以有效的减少人工作业，提升效率。当然可能有人会有这样的疑问，现在基于GAN的AI看起来能够生成又是动画又是图片的，还有这种技术存在的必要吗? 答案当然是有存在的必要，首先GAN需要海量的样本去训练，有生成这么多样本的劲，大概早就做完游戏了，其次是AI生成的不一定能满足业务需求，而且使用者并没有调教的可能性，而在做贴图或者模型合成时，实际上只需要一个样本就可以完成所有的工作了。接下来要简要介绍下基本的原理。"}]},{"type":"element","tag":"h2","props":{"id":"基本原理"},"children":[{"type":"text","value":"基本原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“波函数坍塌“主要是依赖于样本相邻各点的布局结构，以这些结构作为特征，在一个更大的空间上生成满足样本结构约束的新数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以贴图合成为例，假设在输入贴图中有且仅有一点坐标是 x,y，颜色为"},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/6.svg"},"children":[]},{"type":"text","value":" ，上下左右四个点的颜色分别是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/5.svg"},"children":[]},{"type":"text","value":" 。那么在输出贴图中，如果存在一点颜色为 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/6.svg"},"children":[]},{"type":"text","value":" ，那么它的上下左右四个点的颜色必须是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/5.svg"},"children":[]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上我们可以建立更复杂的相邻布局约束，比如说以贴图中某个点周围的不仅上下左右，还有对角线上的4个点，总共八个点建立约束条件，甚至是上下左右四个点的上下左右总共12个点。不过本文只会探讨受上下左右四个点约束的情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以我们的算法就是根据输入贴图提供的这种约束关系来生成输出贴图。这是一个搜索的过程，实际上是一个np hard问题，也就是说，只有当我们搜索了所有的可能性时，才一定能获得一个结果，当然这个结果可能是成功合成贴图，也可能是失败了，当对最终生成图片存在外界约束时，会有更大的可能性失败。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然以贴图为例来说明，但是本文的初衷是为了能够生2d游戏的地图，所以接下来将仅介绍2d下的离散模型合成技术。在2d游戏开发中，一般会用瓦片（tiles）贴图来构成地图，其中瓦片会有特定的几何形状，然后通过瓦片的放置来完成地图。本文以及提供的代码只会考虑正方形的瓦片，对于正方形瓦片来说就和上面的解释完全一致了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后不得不列一下我觉得还蛮重要的公式，该公式描述了上文中提及的一致性约束。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设输入模型为 E，输出模型为 M ，那么当 M与 E 一致时，则对于 M中任意一点 x ，存在 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/8.svg"},"children":[]},{"type":"text","value":" ，且 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/8.svg"},"children":[]},{"type":"text","value":" 属于 E ，满足："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/7.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中， x 是 M中一点，而 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/8.svg"},"children":[]},{"type":"text","value":" 是 E中一点， "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/9.svg"},"children":[]},{"type":"text","value":" 则是几何纬度上正负向的单位向量，3维下是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/4.svg"},"children":[]},{"type":"text","value":" ，2维下则是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/3.svg"},"children":[]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来当然是要介绍具体的算法了。但是首先还是需要将问题重新描述一下。"}]},{"type":"element","tag":"h2","props":{"id":"描述问题"},"children":[{"type":"text","value":"描述问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们需要通过一个样例模型，然后给予一个种子来生成一个更大的模型。在2d情况下，模型会被描述为一个二维矩阵，矩阵中的每个点都是一个非负整数，不同的整数代表一个瓦片的种类，0表示空瓦片。我们需要设定输出模型的大小比如一个10*10的矩阵，然后通过一个特定的种子来生成随机数，根据这个随机数去遍历所有的可能性并找到一个合适的解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以我们的程序至少需要做下面几件事："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"载入瓦片信息，种类编号和瓦片的图片。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"载入输入模型信息，即输入模型矩阵，矩阵的值为瓦片种类id，然后分析输入模型，得到约束条件矩阵。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据约束矩阵，以及随机数去搜索输出模型。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"输出（可视化）输出模型。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显然，第三步是最为麻烦的，也是最困难的，其次是第二步，我们需要得到一个约束矩阵，然后第一和第四步都是常规操作。"}]},{"type":"element","tag":"h2","props":{"id":"获得约束矩阵"},"children":[{"type":"text","value":"获得约束矩阵"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"约束矩阵描述了在输入模型中，相邻点的布局关系。当我们为输出模型布局时，我们可以在某一点填入一个特定的瓦片id，然后当填充这个瓦片相邻的四个瓦片时，通过查询约束矩阵，我们可以知道在当前瓦片id下，它上方的位置只能是特定的几个id。同理就可以推导出其他三个瓦片能够选择的id。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以当生成一个2d模型时，需要4个约束矩阵，分别代表x轴正向，负向，和y轴正向，负向的约束。每个约束矩阵的长度为总的瓦片id数，宽度也是总的瓦片id数，其值为bool或者是0或1，用来表示当当前点上的瓦片id是某个值时，其相邻对应位置瓦片允许的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写个简单的例子，对于输入模型矩阵 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/2.svg"},"children":[]},{"type":"text","value":" 的正的右侧，也就是x轴正方向，可以得到如下的约束规则：0-1，1-2，2-3，2-1，1-0，0-0。整理成矩阵也就是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/1.svg"},"children":[]},{"type":"text","value":" ，这个矩阵等于它的转置矩阵，然后我们会有4个类似这样的约束矩阵对应不同方向的邻居，我们使用当前的瓦片id去查询就可以得到相邻瓦片允许填入的瓦片id了。"}]},{"type":"element","tag":"h2","props":{"id":"搜索算法"},"children":[{"type":"text","value":"搜索算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"搜索算法部分是最为困难的部分了。我们需要保存一个记录矩阵（catalog），该矩阵与最终输出模型大小相同，比如输出模型是10"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"10的这个记录矩阵也是10"}]},{"type":"text","value":"10的。在这个记录矩阵中，每个元素会是一个集合，表示当前该点可以填入的瓦片id的集合，当该点可填入瓦片id集合为空集时，说明走了一条错误的路径，需要回退。然后我们的搜索算法会按照之前走过来的路径回退到上一个操作点，同时这个记录矩阵也需要回退相应的步数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于记录矩阵的回退，需要记录一个类似数据库的ahead log的东西，来记录所有对记录矩阵的操作，当产生回退时，只需要沿着这log向前恢复就可以。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于搜索算法的前进和回退，在我参考的论文里没有提及具体的方式，经过一段时间的尝试，我建立了一颗树来记录搜索的路径，当产生回退时，树的当前节点会被标记为不可通行，便不会向这片树枝搜索了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-21-wave-collapse-function/v2-37deccf09bca15112c03e8169fc3c525_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如上图所示，灰色的节点表示还没探索到，实际上还不在树里，红色的节点表示需要回退的节点。蓝色的节点表示已探索或者待探索的节点，绿色的箭头表示已经探索的路径。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"五边形节点表示根节点，一旦在根节点发生回退说明，搜索失败，并没有找到合适的输出模型。正方形节点表示选择点操作，当游标在正方形节点上时，等于选取该节点记录的点为当前点。圆形节点则表示，为当前点选择了一个特定的瓦片，该瓦片的种类取决于记录矩阵在该点允许的选择，然后会根据约束矩阵，更新记录矩阵，当发现更新后记录矩阵存在空集便会回退。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终会有如下的搜索过程："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"建立搜索树，找到所有的点，并将其放在根节点下边，随机选一个节点，将游标移动到该节点，设定该节点对应的点为当前节点，然后根据记录矩阵中的值，随机选择一个瓦片填入，并根据约束矩阵更新记录矩阵。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"找到剩余所有没有瓦片的点，将这些节点加入当前节点后面，然后将根据这些点与当前所选中的点的距离，计算一个权重，离得最近的会被最先搜索，如果没有新的节点可以选择，则生成成功。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据权重和生成的随机数以及选择一个节点，根据记录矩阵在该点的瓦片集合以及随机数为该节点选择一个瓦片，然后根据约束矩阵以及当前选择去更新记录矩阵中相邻点的记录："}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果更新中发现某相邻点可选瓦片为空，则需要回退到上一个圆形节点，与此同时记录矩阵也要回退上一个圆形节点之后的操作，并将该节点标为禁止通行，并返回第2步，如果发现当前节点在根节点，则生成失败。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果不为空，则根据随机数选择一个瓦片填入，并根据约束矩阵更新记录矩阵，然后返回第2步。"}]}]},{"type":"element","tag":"h2","props":{"id":"链接"},"children":[{"type":"text","value":"链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian%5C_docid=0M2y2bvM","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian\\_docid=0M2y2bvM"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/65495333","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/65495333"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/mxgmn/WaveFunctionCollapse","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/mxgmn/WaveFunctionCollapse"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/BorisTheBrave/DeBroglie","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/BorisTheBrave/DeBroglie"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"什么是波函数坍塌","depth":2,"text":"什么是“波函数坍塌”？"},{"id":"基本原理","depth":2,"text":"基本原理"},{"id":"描述问题","depth":2,"text":"描述问题"},{"id":"获得约束矩阵","depth":2,"text":"获得约束矩阵"},{"id":"搜索算法","depth":2,"text":"搜索算法"},{"id":"链接","depth":2,"text":"链接"}]}},"_type":"markdown","_id":"content:game:2021-01-21-wave-collapse-function.md","_source":"content","_file":"game/2021-01-21-wave-collapse-function.md","_extension":"md","date":"2021-01-21"},{"_path":"/game/2021-01-22-civ-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"文明6地图生成算法","description":"作者：哈里叔叔\n链接：https://www.zhihu.com/question/52019284/answer/1476187895\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作者：哈里叔叔\n链接："},{"type":"element","tag":"a","props":{"href":"https://www.zhihu.com/question/52019284/answer/1476187895","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.zhihu.com/question/52019284/answer/1476187895"}]},{"type":"text","value":"\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}]},{"type":"element","tag":"h3","props":{"id":"对称性对抗游戏简介"},"children":[{"type":"text","value":"对称性对抗游戏简介"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对称性对抗游戏是指参与游戏的玩家所拥有的资源、交互方式、受制规则、最终目标是相同或相近的，是一种公平、对称的零和游戏。如《英雄无敌》《文明》《卡坦岛》等游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们参考文明的4X要素["},{"type":"element","tag":"a","props":{"href":"#ref_1"},"children":[{"type":"text","value":"1]"}]},{"type":"text","value":"搭建了一个多人回合制战略游戏，如下图所示：地图开始被“战争迷雾”所覆盖。玩家必须派遣探险者进入这片迷雾中，以揭露要扩张的土地，要开发的资源以及要消灭的对手。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_720w.jpg"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"地图的平衡性指标"},"children":[{"type":"text","value":"地图的平衡性指标"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们参考["},{"type":"element","tag":"a","props":{"href":"#ref_2"},"children":[{"type":"text","value":"2]"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"#ref_3"},"children":[{"type":"text","value":"3]"}]},{"type":"text","value":"两篇参考文献制定出评估对称性对抗游戏地图平衡性的两点指标。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1. 战略特征（Strategic Feature）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"战略特征是指玩家在游戏中可以利用的战略资源。 战略特征的平衡是指每一名玩家在一定时间内获得基本相同的资源（包括类型和数量）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面两张图显示了两名玩家战略特征不平衡的情况，蓝色玩家初始时可以获得更多的矿产资源，而黄色玩家的出生点附近几乎没有矿产资源，这会导致游戏初期黄色玩家的发展受限。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2. 玩家占位符（player placeholder）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"玩家初始的出生点占位的分布也会影响游戏的平衡性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面两张图显示了玩家初始占位符分布密度不同导致游戏性不平衡的情况。左图的玩家初始分布密集，这会导致这个地区的玩家在游戏前期相互碾压、发展受限；而右图中的黄色玩家在游戏前期缺少竞争，能够更好地发展自身建设。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了以上两点对游戏平衡性的影响之外，战略游戏地图的随机地图还要考虑到：地图的美观性、根据玩家的偏好定制参数、生成地图的效率等要求。"}]},{"type":"element","tag":"h3","props":{"id":"地图的生成过程"},"children":[{"type":"text","value":"地图的生成过程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1. 根据玩家的偏好定制地图参数"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在新建游戏之前，我们会让玩家根据自己的喜好定制地图参数，包括地图的尺寸、玩家的总数量、地图的类型（盘古大陆、大洲、海岛群）、水体比例、植被比例、岩石比例与资源的比例等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2. 生成地图的轮廓：柏林噪声"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声（Perlin noise）指由Ken Perlin发明的自然噪声生成算法["},{"type":"element","tag":"a","props":{"href":"#ref_4"},"children":[{"type":"text","value":"4]"}]},{"type":"text","value":"。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与椒盐噪声相比，柏林噪声有较好的连续性分布，可以更好的模拟自然界中的地形分布与地表装饰物分布。利用柏林噪声生成自然地图可以参考B站视频："},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1sJ411e7nt","rel":["nofollow"]},"children":[{"type":"text","value":"柏林噪声程序化生成随机地图"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"#ref_5"},"children":[{"type":"text","value":"5]"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声的生成采用伪随机数的生成方式，相同的“随机数种子”会生成相同的地貌。这也是很多随机地图生成器中会暴露“种子”让玩家根据种子生成地图的原因。如果想跟好朋友分享某个生成结果比较好的地图，只需要共享“种子”字符串，就能在随机地图生成器中还原出所生成的地形，而不需要把整个地图文件保存到本地再分享。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity官方自带生成柏林函数的函数。我们引用了柏林噪声js库来进行地形的实现。我们利用柏林噪声的采样尺度来决定地图的类型是连续的大陆型地图还是离散的大洲型地图；将随机取到的连续噪声均衡化作为地图的高度图，根据用户设置的水体占比来制定海平面高度，最终生成的地形结果如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3. 玩家出生点的选择：米切尔最佳候选算法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了保证每位玩家两两之间的初始分布不会过近，我们在生成游戏地形后，在陆地上对玩家初始占位符进行均匀采样。为了兼顾效果与效率，我们最终选用米切尔最佳候选 算法（best candidate）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"米切尔最佳候选算法是一种渐进、增量式的均匀采样方法。它每一轮采样都是从多个随机采样点中，保留与之前轮的所有采样点中最小距离最大的点作为本轮的采样结果。更加具体直观的算法解释可以参考:"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//bindog.github.io/blog/2014/08/09/visualizing-algorithms/","rel":["nofollow"]},"children":[{"type":"text","value":"算法可视化"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"#ref_6"},"children":[{"type":"text","value":"6]"}]},{"type":"text","value":"中有关米切尔候选算法的部分"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示：黑色点是之前轮已经确定的采样点，灰色点是本轮随机采样的候选点，每个候选点都选出与之前轮采样点中距离最近的距离，再从中选出最小距离最大的红色点作为本轮采样的结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"利用这种采样方式采样出玩家的初始占位符，可以避免任意两个玩家之间的距离过近导致游戏平衡性被破坏，如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4. 战略资源的分布"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采样出玩家的分布之后，我们将地图单元格分为两种类型：每个玩家占位符附近距离N以内的单元格为玩家区域（Player Zones），不隶属于任何玩家区域的单元格被称为隔离区或自然区（Natural Zones）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了让每名玩家在游戏初始时具有公平的战略特征，我们对每位玩家的玩家区域内定额分配植被、岩石与矿产资源。根据用户设定的植被、岩石与资源占比分别计算出每位玩家区应当分配到的植被、岩石与资源数量，然后在每个玩家区域内不重不漏地采样出相等数量的植被、岩石与资源单元格。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于自然区，我们按照玩家设置的参数，采用米切尔候选算法均匀采样每一种资源。这样可以保证每位玩家在游戏初始时能够得到数量一致的战略特征。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5. 边界情况处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用以上方式生成的地图在某些情况下会产生不好的结果，例如当水体比例过低时生成海岛地形，会导致水体不够划分不出海岛地形；当水体比例过高时，会由于陆地单元格分布不均导致出生在不同规模大小的岛屿上的玩家能够得到的战略资源再度失衡。对于这些边界情况，我们利用种子生长与泛洪填充等启发式生成方法生成地图，优先保证地图类型能够满足用户的需求，并尽可能保证水体与各种战略特征的资源逼近用户的设定。以下是我们在水体占比过低与水体占比过高时生成的地图，可以看出在这两种情况下依然能够保证所生成地图的平衡性："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_720w.jpg"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"生成地图质量的定量评估"},"children":[{"type":"text","value":"生成地图质量的定量评估"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了判断我们的生成随机地图算法是否具有良好的平衡性指标，我们设计了一套地图自动扩张算法：每个玩家以出生点占位符为种子，轮流从目前领土所毗邻的无人单元格中抽取一个进行占领以扩张势力范围，直到地图中所有的单元格都被有且只有一个玩家占领；然后我们统计每个玩家占领到的资源数量、距离最近的敌人距离，以及每个玩家与多少数量的玩家领土相邻。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实验组是我们的算法生成的地图，对照组是根据水体与各种资源的比例随机采样地形、随机采样玩家分布得到的地图。如下方左侧是实验组生成的地图，右侧是对照组生成的地图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实验组与对照组各生成100次地图，统计每个玩家与其他势力最小距离的均值与方差、扩张完成后各资源占有量的均值与方差以及每位玩家潜在冲突势力的均值与方差，统计的结果如下所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过定量的统计结果可以看出，我们的方法生成的地图，玩家之间有更大的平均极小距离，这说明每位玩家的出生点占位符设置更加平衡；各种资源的分布方差均比对照组小，说明我们的战略特征分配与朴素的随机生成的地图相比更加均衡。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综上所述，我们的地图生成结果能够保证对称性多人对抗战略游戏的平衡性。"}]},{"type":"element","tag":"h3","props":{"id":""},"children":[]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"对称性对抗游戏简介","depth":3,"text":"对称性对抗游戏简介"},{"id":"地图的平衡性指标","depth":3,"text":"地图的平衡性指标"},{"id":"地图的生成过程","depth":3,"text":"地图的生成过程"},{"id":"生成地图质量的定量评估","depth":3,"text":"生成地图质量的定量评估"},{"id":"","depth":3,"text":""}]}},"_type":"markdown","_id":"content:game:2021-01-22-civ-map.md","_source":"content","_file":"game/2021-01-22-civ-map.md","_extension":"md","date":"2021-01-22"},{"_path":"/game/2021-01-23-roguelike-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"roguelike地牢生成算法","description":"引言文章作者：Mike Anderson随机生成的地图是 Roguelike 类游戏最独特的一点，它让游戏变得很有乐趣，因为玩家永远要面对新的挑战。但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。在这篇文章里，我会将自己在开发一款名为 Tyrant 的 Roguelike 游戏中使用的方法记录下来。我怀疑这可能只能算是一个原型，但是我之前也没有见过什么一本正经讲述生成 Roguelike 地图算法","body":{"type":"root","children":[{"type":"element","tag":"h4","props":{"id":"引言"},"children":[{"type":"text","value":"引言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文章作者："},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Mike_Anderson","rel":["nofollow"]},"children":[{"type":"text","value":"Mike Anderson"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随机生成的地图是 "},{"type":"element","tag":"a","props":{"href":"https://indienova.com/tag/roguelike/","rel":["nofollow"]},"children":[{"type":"text","value":"Roguelike"}]},{"type":"text","value":" 类游戏最独特的一点，它让游戏变得很有乐趣，因为玩家永远要面对新的挑战。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这篇文章里，我会将自己在开发一款名为 "},{"type":"element","tag":"a","props":{"href":"http://sourceforge.net/projects/tyrant/","rel":["nofollow"]},"children":[{"type":"text","value":"Tyrant"}]},{"type":"text","value":" 的 Roguelike 游戏中使用的方法记录下来。我怀疑这可能只能算是一个原型，但是我之前也没有见过什么一本正经讲述生成 Roguelike 地图算法的文章。而且，它工作得还是比较令人满意的，所以，我愿意将它分享给大家。"}]},{"type":"element","tag":"h4","props":{"id":"这款算法的目标"},"children":[{"type":"text","value":"这款算法的目标"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在写任何代码之前，了解自己的目标总是很重要的，这对编程很有帮助，哪怕你随后会做无数的修改。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个地牢（"},{"type":"element","tag":"a","props":{"href":"https://indienova.com/tag/dungeon/","rel":["nofollow"]},"children":[{"type":"text","value":"Dungeon"}]},{"type":"text","value":"）应该包含以下要点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一组相互连通的房间、门和通道"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个入口（向上走的楼梯）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个出口（向下走的楼梯）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有的空间必须能够到达"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后一点尤其重要。要知道，你的玩家在契而不舍的努力之后，应该能够顺利通过这一层，不要让他们失望。另外，如果放了某个物品到地图上的某个空间，它应该不会被藏在无法到达的地方。"}]},{"type":"element","tag":"h4","props":{"id":"计划"},"children":[{"type":"text","value":"计划"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在我写 Tyrant 的时候，我尝试了很多种不同的算法来生成地图，这里所讲的是我能做到的最好的一个，也是目前游戏中使用的那个。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我的灵感来自于此：“如果我是地下城的一个居民，那么我该怎么去建设我的地牢呢？”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显然，我并不会将我的地下城建造成一个一个看起来不错的小房间，然后在中间用长长的通道连接起来。所以，当我需要为我的小怪物们提供更多空间的时候，我应该是拿起我的斧头，挖一个更大一些的洞。这样当他们有所需要的时候就会增加一些新房间——尽管它们看起来可能杂乱无章。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有些地下城主可能想要用吊桥呀、陷阱呀什么的来守护比较“有趣”的房间，但是这些需求都异曲同工。由一个小的地牢开始，慢慢向四周扩散，直到整个地牢形成。这就是我们的计划。"}]},{"type":"element","tag":"h4","props":{"id":"算法"},"children":[{"type":"text","value":"算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个算法里面，“元素”代表着某种地图元素，比如：大房间、小房间、通道、圆形竞技场、保险柜等等。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将整个地图填满土"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在地图中间挖一个房间出来"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"选中某一房间（如果有多个的话）的墙壁"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"确定要修建某种新元素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"查看从选中的墙延伸出去是否有足够的空间承载新的元素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有的话继续，不然就返回第 3 步"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"从选中的墙处增加新的元素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"返回第 3 步，直到地牢建设完成"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在地图的随机点上安排上楼和下楼的楼梯"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最后，放进去怪兽和物品"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 1、2 步很简单。只要你创建好地图就可以去做到。我发现，写一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fillRect"}]},{"type":"text","value":" 指令用来填充一个区域是比较有效的做法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 3 步麻烦一些。你不能随意的寻找一个方块区域去添加你的元素，因为规则是要将元素添加到当前的地牢当中。这样会使得连接看起来比较不错，也确保了所有的区域都可以到达。Tyrant 的做法是：在地图上随机选择一个方块，直到找到横向或者纵向毗邻一个干净的方块那个。这样做的好处是：它给了你一个近乎公平的方式去选择某一面墙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 4 步不太困难。我自己写了一个随机方法来决定建造哪一种元素。你可以自己定义它们，调整某些元素出现的权重，这会让你的地牢有自己的特点和侧重点。一个规划比较好的地牢会有很多规矩的房间，中间有长而且直的走廊连接。而洞穴则可能有一堆打洞以及曲折的小道等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 5 步更复杂一些，而且也是整个算法的核心。针对每一种元素，你需要知道它会占用的空间大小。然后你要去判断它是否和已经有的元素相交。Tyrant 使用了相对简单的一种方法：它会先得到要创建的元素所占用的空间大小，得到这个空间的数据，然后检查是否这个空间由土填满。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 6 步决定是否创建这个元素。如果这个待确定的空间包含有除了土之外的内容，那么就回到第 3 步继续。注意，大部分元素在这步都会被打回。不过这不是个问题，因为处理时间可以忽略。Tyrant 尝试着将某个元素加入 300 次左右到地牢中去，一般只有 40 次左右会通过这步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 7 步会将新元素添加到地图上去。在这步，你还可以增加一些有趣的元素，比如动物、居民、秘道门和财宝什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 8 步返回去创建更多的房间。确切的次数跟你地牢的尺寸以及其它参数有关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 9 步要看个人喜好了。最简单的方法就是随机的去查找方块，直到找到一个空的位置去放置楼梯。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 10 步就是随机的创建怪兽。Tyrant 在这一步才加入游戏中大多数的怪兽，由少量的特殊怪兽或者生物会在生成房间的时候添加进去。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就这样啦，这里所说的只是算法的规则，具体还要您自己去实现啦。"}]},{"type":"element","tag":"h4","props":{"id":"例子"},"children":[{"type":"text","value":"例子"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，在看了半天算法之后，我们来一个例子吧："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Key:"}]},{"type":"element","tag":"pre","props":{"code":"# = 地板\nD = 门\nW = 正在考查中的墙\nC = 宝箱\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# = 地板\nD = 门\nW = 正在考查中的墙\nC = 宝箱\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\1. 第一个房间"}]},{"type":"element","tag":"pre","props":{"code":"#####\n#####\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####\n#####\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\2. 随机选择一面墙"}]},{"type":"element","tag":"pre","props":{"code":"#####\n#####W\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####\n#####W\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\3. 为新的通道元素进行区域搜索（包括两边的空间）"}]},{"type":"element","tag":"pre","props":{"code":"#####**********\n#####W*********\n#####**********\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####**********\n#####W*********\n#####**********\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\4. 是空的，可以添加元素"}]},{"type":"element","tag":"pre","props":{"code":"#####\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\5. 选择另外一面墙"}]},{"type":"element","tag":"pre","props":{"code":"#####     W\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####     W\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\6. 扫描寻找新的房间所占用空间："}]},{"type":"element","tag":"pre","props":{"code":"       ******\n       ******\n       ******\n       ******\n       ******\n#####  ***W**\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"       ******\n       ******\n       ******\n       ******\n       ******\n#####  ***W**\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\7. 这个地区也可以，那就添加一个新房间，再往里面扔一个宝箱 C（Chest）："}]},{"type":"element","tag":"pre","props":{"code":"        ####\n        ###C\n        ####\n        ####\n#####     D  \n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        ####\n        ###C\n        ####\n        ####\n#####     D  \n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\8. 跟前面做法一样，我们增加一个新的通道元素"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\9. 这一次，我们试着为第二个房间增加一个通道元素"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #\n        #### #\n        ###C*******\n        ####W******\n        ####*******\n#####     D  #\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #\n        #### #\n        ###C*******\n        ####W******\n        ####*******\n#####     D  #\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\10. 扫描失败了，已经被占用"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\11. 比较特别的元素，一个菱形的房间"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #   ###\n        #### #  #####\n        ###C # #######\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #   ###\n        #### #  #####\n        ###C # #######\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\12. 添加一个隐藏的暗门，以及充满陷阱的通道："}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #   ###\n        #### #  #####\n        ###C # #######S###T##TT#T##\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #   ###\n        #### #  #####\n        ###C # #######S###T##TT#T##\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\13. 继续……"}]},{"type":"element","tag":"h4","props":{"id":"总结"},"children":[{"type":"text","value":"总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，这就是我的算法，我希望它对你有用，或者从一个有趣的角度去看如何解决一个问题。"}]},{"type":"element","tag":"h4","props":{"id":"代码实现"},"children":[{"type":"text","value":"代码实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Java 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Java_Example_of_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"Java 代码实现"}]},{"type":"text","value":"\n你可以通过 "},{"type":"element","tag":"a","props":{"href":"http://openprocessing.org/visuals/?visualID=18822","rel":["nofollow"]},"children":[{"type":"text","value":"Open Processing"}]},{"type":"text","value":" 在浏览器里面运行它（需要做一些小修改）。它会创建一个图形化的地牢。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Python Curses 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Python_Curses_Example_of_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"Python Curses 代码实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"C++ 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=C%2B%2B_Example_of_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"C++ 代码实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"C# 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=CSharp_Example_of_a_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"C# 代码实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原文地址："},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"链接"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-01-23-roguelike-map.md","_source":"content","_file":"game/2021-01-23-roguelike-map.md","_extension":"md","date":"2021-01-23"},{"_path":"/game/2021-01-23-spelunky-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"Spelunky关卡生成","description":"关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"part1-创建solution-path-关卡通路"},"children":[{"type":"text","value":"Part1. 创建Solution path - 关卡通路"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"算法的第一部分是生成关卡的 Critical Path（通路），关卡由 16 个房间按照 4x4 的网格组成。方法是先在第一排随机找到一个起始房间，然后随机使相邻的房间成为通路的一部分，一直到最后一排，生成出口。找到通路之后，连接这些房间，然后再随机补充上非通路部分的房间，打通这些房间。如图顺序所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/spelunky-map-generation-steps.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后为这些房间随机选取对应的预定义好的关卡模块。根据 Spelunky 的教学文章["},{"type":"element","tag":"a","props":{"href":"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/#reference","rel":["nofollow"]},"children":[{"type":"text","value":"3]"}]},{"type":"text","value":"，这里有 4 种不同的房间类型："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530045.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个关卡由16个房间按照4x4的网格方式组成，这里有4种不同的房间类型："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"0：不在critical path上，不会产生任何出口（可被忽略的）次要房间 (感谢洋芋君指出之前的翻译问题)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1：左右一定有出口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2：左右下一定有出口，如果有2号room在上方，也一定有上方出口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3：左右上一定有出口"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一步在最顶部这行随机选取一格创建一个Start Room，房间类型对开始的房间来说没太大影响。一般来说，Start Room类型我们会选1或者2。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当一个Room被创建，首先总是类型1(左右)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后要决定往哪边走。取一个均匀分布的随机数，从1到5。当1或2时，critical path向左；当3或4时，critical path向右；当5时，path向下。（当critical path碰到屏幕边缘，立即向下移动并同时切换左右方向。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这有个问题，如果我们向左或右移动，是OK的，因为我们创建的Room是一定有左右出口的。但我们要向下走，我们就得改变我们当前所在的房间了。所以生成器重写房间类型为2，覆盖当前的房间，现在我们可以向下移动了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当生成器移到下一个房间，会问我们最后创建的那个房间（也就是刚才我们头顶上那个）类型是不是2（底部有出口）。 如果是2，那么当前这个房间类型一定要是2或3（上方有出口）。因为2、3类型都有左右出口，启动算法从头再来一次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果到了底部这一行，我们要尝试向下，那肯定不行了，我们放置一个Exit Room来取代向下的房间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们已经生成了整个critical path（关卡通路，即图中那些暗红色的格子，游戏中是不显示的，这里只是为了举例）。接下来要做的最后一件事，我们要把4x4的网格中的空余部分放上类型为0的房间，这些房间并不在critical path上。这些房间在任何方向都不一定有出口，所以有时候会生成一些围墙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一列中有3或者4个Room 0，那这一列房间有几率成为一个蛇窝。如果我们要生成蛇窝的话，从上到下，放一列房间，类型为7 8 9，或者7 8 8 9，取决于我们希望这个蛇窝有多深。(这里的蛇和宝石并不像其他敌人那样随机生成，因为它们是这种地形的一部分，所以位置基本是固定出现。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530075.png_webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"蛇窝"}]}]},{"type":"element","tag":"h1","props":{"id":"part2-创建房间-关卡生成算法的第二部分生成room我们先不考虑那些障碍物陷阱敌人和宝箱什么的"},"children":[{"type":"text","value":"Part2. 创建房间 关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530105.png_webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Spelunky并不像其他大部分游戏（平台游戏，platformer）在传统的2D tile-base的平台游戏中，你用关卡编辑器做出的地图可能看起来像这样："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530119.png_webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种类型编辑器里，是这样的，比如，在（64,128）这个位置是草的tile。但Spelunky完全不是这样。\n上一部分我们了解了Spelunky有4种基本房间类型（types）。这每个房间类型有8-16个模板。这些模板具备一个房间的基本布局，包括一些静态和概率tile的组合。\nRoom Templates（房间模板）\n每个房间类型都有一堆不同的模板。\n"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"译注：Derek Yu使用不同的布局，做了一系列的房间设计。比如你掉出去的房间（DROP）、掉入的房间（LANDING）、可以穿过的走廊（CORRIDOR）、不在关卡通路上的房间（NON-CRITICAL）。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"房间模板，嗯……看起来就像下面这样："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1100000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"40L6000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11P0000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11L0000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11L5000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1100000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1100000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1111111111"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个模板由10x8 的tile网格组成。\"0\"表示空，\"1\"表示100%是砖块，\"L\"是梯子，\"P\"是爬梯子上去的平台(platform)。现在你在看这个模板， 嗯，下面一排是地面，左边是2个tile宽的墙，上面有个小缺口，有个梯子可以爬到那。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Static and Probabilistic Tiles( 静态和概率Tile )"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"static tile就像传统关卡编辑器里一样，你让这里有个砖块，那这就永远是砖块了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面模板里的\"4\" tile，就是probabilistic tile。\"4\"表示那有25%的几率会是一个能推动的障碍物，出现在梯子的顶部旁边。有经验的Spelunky玩家会一下认出这个：有时你爬到一个梯子顶部，旁边有个障碍物，你得推它，就可以进到下一个房间。有时候爬到梯子顶上旁边就没有这玩意。还有比如“这有33%的几率会出现个尖刺”，或者“这有一半的几率是空的，或者是砖块”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Obstacle Block( 障碍块）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"5\"和\"6\"就是所谓的Obstacle Block。Obstacle Block由 5x3 的tile网格组成，是个有趣的小结构，会让玩家针对这个障碍来思考自己的策略。Obstacle block本身也会由一些概率tile组成。下面是\"5\" 这个模板，表示放置在地上（\"6\"表示放置在空中）:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"00000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"00102"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"71177"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"规则和之前的一样，0是空，1是砖块。你能看出来，这是个小台阶。\"7\"有33%的几率是个尖刺，或者为空。如果运气不好，这里就得跳到那个台阶上面避开尖刺。\"2\"表示有一半的几率味空，或者是砖块。这就有意思了，有可能有个小砖块让你落脚不用踩到尖刺，也有可能除了小台阶，旁边都是空的，玩家得跳到上面去。你可以看出，这么个小障碍块，如果设计的好的话，游戏自己就会随机生成很多很多有意思的场景。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"译于2018-Jan-20"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原文链接最好用chrome打开，对，要科学，你懂了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://tinysubversions.com/spelunkyGen/","rel":["nofollow"]},"children":[{"type":"text","value":"http://tinysubversions.com/spelunkyGen/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://tinysubversions.com/spelunkyGen2/","rel":["nofollow"]},"children":[{"type":"text","value":"http://tinysubversions.com/spelunkyGen2/"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://indienova.com/u/root/blogread/5454","rel":["nofollow"]},"children":[{"type":"text","value":"https://indienova.com/u/root/blogread/5454"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/","rel":["nofollow"]},"children":[{"type":"text","value":"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-01-23-Spelunky-map.md","_source":"content","_file":"game/2021-01-23-Spelunky-map.md","_extension":"md","date":"2021-01-23"},{"_path":"/game/2021-06-12-edgar-code-read","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"Edgar源代码解读","description":"生成类LevelGeneratorBase  最基本的生成方法类包括Generate和GenerateCoroutineDungeonGeneratorBase 一般都会继承于该类Generate流程创建playload,即IPipelineTask的上下文创建pipelineTask,包括三个InputTask,GeneratorTask,PostProcessingTaskPipelineRunner执行管道任务,将playload赋值给各个pipelineTask然后执行pipelinetask的Process()函数pipelineTask你可以继承LevelGeneratorBase","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"生成类"},"children":[{"type":"text","value":"生成类"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LevelGeneratorBase"}]},{"type":"text","value":"  最基本的生成方法类包括"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Generate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GenerateCoroutine"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DungeonGeneratorBase"}]},{"type":"text","value":" 一般都会继承于该类"}]}]},{"type":"element","tag":"h4","props":{"id":"generate流程"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Generate"}]},{"type":"text","value":"流程"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建playload,即IPipelineTask的上下文"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建pipelineTask,包括三个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InputTask"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratorTask"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PostProcessingTask"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PipelineRunner执行管道任务,将playload赋值给各个pipelineTask然后执行pipelinetask的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Process()"}]},{"type":"text","value":"函数"}]}]},{"type":"element","tag":"h4","props":{"id":"pipelinetask"},"children":[{"type":"text","value":"pipelineTask"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以继承"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LevelGeneratorBase"}]},{"type":"text","value":"  然后分别覆盖"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetInputTask()"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetGeneratorTask()"}]},{"type":"text","value":",还有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetPostProcessingTask()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InputTask"}]},{"type":"text","value":"   一般来说是FixedLevelGraphInputTask,主要是用来设置Payload.LevelDescription"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratorTask"}]},{"type":"text","value":"   主要是通过GraphBasedGeneratorGrid2D来设置Payload.GeneratedLevel 和 Payload.GeneratorStats,还有会实例化"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Generated Level/Room template instances"}]},{"type":"text","value":"以及下面的房间,参见"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratorUtils.TransformLayout"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PostProcessingTask"}]},{"type":"text","value":"  主要是根据PriorityCallbacks按照优先顺序执行回调函数,默认的回调函数,通过配置有以下"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"InitializeSharedTilemaps 即实例化"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratedLevel/Tilemaps"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CopyTilesToSharedTilemaps 将rooms下的tile复制到SharedTilemaps 下"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CenterGrid 将Generated Level下的子对象设置为0,0"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DisableRoomTemplatesRenderers    禁用roomtemapltes下的显示"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DisableRoomTemplatesColliders  禁用roomtemplates下的碰撞"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"还可以通过继承DungeonGeneratorPostProcessBase写你自己的后处理函数"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"door-sockets"},"children":[{"type":"text","value":"Door sockets"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门锁..就是走廊和房间选中同一个锁,就能匹配的上"}]},{"type":"element","tag":"h2","props":{"id":"对于连接处"},"children":[{"type":"text","value":"对于连接处"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他会按照顺序copy到sharedtilemaps.所以,位于连接处的tile,如果后面的会覆盖前面的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210630183742467","src":"/images/2021-06-12-edgar-code-read/image-20210630183742467.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210630183825008","src":"/images/2021-06-12-edgar-code-read/image-20210630183825008.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终的合成则是下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210630183914172","src":"/images/2021-06-12-edgar-code-read/image-20210630183914172.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"生成类","depth":3,"text":"生成类"},{"id":"door-sockets","depth":3,"text":"Door sockets"},{"id":"对于连接处","depth":2,"text":"对于连接处"}]}},"_type":"markdown","_id":"content:game:2021-06-12-edgar-code-read.md","_source":"content","_file":"game/2021-06-12-edgar-code-read.md","_extension":"md","date":"2021-06-12"},{"_path":"/game/2021-06-15-rpgbuilder","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"rpgbuild的一些备注","description":"skills   相当于 采矿技能,种植技能 ,制作技能level templates 只是升级属性..比如角色等级,skill等级.weapon等级weapontemplates  相当于拳法精通..斧头精通..枪法精通.棍法精通这些..而且有相关的技能和属性Races  种族,定义了可选职业,以及 weapontemplates  ,以及初始stat等classes  职业定义了stat以及技能树,和魔法书","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"skills   相当于 采矿技能,种植技能 ,制作技能"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"level templates 只是升级属性..比如角色等级,skill等级.weapon等级"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"weapontemplates  相当于拳法精通..斧头精通..枪法精通.棍法精通这些..而且有相关的技能和属性"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Races  种族,定义了可选职业,以及 weapontemplates  ,以及初始stat等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"classes  职业定义了stat以及技能树,和魔法书"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-06-15-rpgbuilder.md","_source":"content","_file":"game/2021-06-15-rpgbuilder.md","_extension":"md","date":"2021-06-15"},{"_path":"/game/2021-08-05-game-task-design","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"游戏人物设计","description":"前言我知道没人爱看理论文章。可偶尔也得定期坐下来写点枯燥的设计理论文章，以防本旗舰彻底变成一个专业游戏评论博客。虽然我在写评论的时候从来都是本着“写评论是为了写设计要点”的方针，但是这事情干多了，还是不免会陷入就事论事的陷阱之中。也经常会有人问“FNV和F1、F2的任务系统不是一样的吗”这种问题，有时候也还是应该总结一下，写点理论文章。整理一下工作文档，再定期写一些抽象的文字对自己是有好处的。任务的概念与发展简史：从具体，到抽象，再到具体“老僧三十年前未参禅时，见山是山，见水是水。及至拿来，亲见知识，有个入处，见山不是山，见水不是水。而今得个休歇处，依前见山只是山，见水只是水。”——《五灯会元","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"前言"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我知道没人爱看理论文章。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可偶尔也得定期坐下来写点枯燥的设计理论文章，以防本旗舰彻底变成一个专业游戏评论博客。虽然我在写评论的时候从来都是本着“写评论是为了写设计要点”的方针，但是这事情干多了，还是不免会陷入就事论事的陷阱之中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也经常会有人问“FNV和F1、F2的任务系统不是一样的吗”这种问题，有时候也还是应该总结一下，写点理论文章。整理一下工作文档，再定期写一些抽象的文字对自己是有好处的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"任务的概念与发展简史：从具体，到抽象，再到具体"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"“老僧三十年前未参禅时，见山是山，见水是水。及至拿来，亲见知识，有个入处，见山不是山，见水不是水。而今得个休歇处，依前见山只是山，见水只是水。”"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"——《五灯会元》卷十七《青原惟信禅师》"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"任务是什么？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不管你是玩家还是设计者，你可能都没有仔细考虑过这个问题。\n任务似乎是那种“慢慢浸透了整个行业”的设计要素，我们甚至找不到游戏中任务系统的第一个发明人。\n但当你看到任务的时候，你就会认出它们。\n任务就是魔兽世界里面那些头顶着问号和感叹号的家伙们。\n任务就是使命召唤里面那些不停在屏幕一侧刷新的作战目标和前进方向。\n任务就是360的成就和PS3的奖杯列表里面密密麻麻令人眼晕的文字。\n任务就是网络游戏里在左下角刷个不停的的游戏活动提示。\n总之，任务就是游戏的时候告诉你“你现在应该去干什么”的那些系统，这些任务完成以后，你通常会得到对应的报酬。把用户需要的帮助、行为和报酬打个包，就能得到一个任务；接着，设计师就可以往任务里面插进各种各样的其他要素。\n“看，我这里有胡萝卜。你干完什么什么就肯定能得到胡萝卜哦！”\n这个设计的思路实在太过简单，但当我们回过头来看，却发现这个设计已经统治了整个行业。从FPS到RPG，甚至手机游戏和网页游戏，到处都充斥着任务和类任务系统的身影。\n因为任务实在是太好用了。它就是游戏行业对所谓的“叙事五要素”的综合解答。\n我们都知道，不管是小说、电影还是电视，都有五个经典的问题：时间、地点、人物、事件、原因，也就是When、Where、Whom、What、Why。对于游戏行业来说，这五个问题却没有这么简单。\n你用文字表述？玩家根本不看。你用其他表达方式表述？这些解决方案又没有通用性。\n而在一个任务之中，这些问题同时都会被展示出来。\n你能不能做这个任务？你应该去什么地方？你为什么要做这个任务，能得到什么东西？任务要怎么完成？用户现在到底应该做什么，怎么做？\n设计师总归要把这些东西告诉用户的，而任务是个比其他展示形式更为完善的解答。\n玩家需要的东西，帮助、行动和报酬，只要打开任务列表就一目了然了。\n所以现代游戏里到处都是任务、成就和目标，而游戏用户也飞快接受了它们。\n那些从不玩游戏的人看到现代的大型游戏，经常会问类似这样的问题：“这个角色光这么跑来跑去/打打杀杀是要干什么呢？”\n自从有了任务，这种问题总算也能回答了。\n但是——\n为什么我们的现代游戏中有这么多无聊的任务呢？为什么我们都讨厌Farm呢？为什么有的游戏任务好，有的游戏任务就差呢？要怎么做才能做出更好玩的任务呢？\n这都不是简单地把帮助、行动和报酬打个包就能解决的问题。肯定还有什么比“把帮助、行动和报酬打包”更根本的东西，存在在任务之中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"思想的起源"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也许任务最早的思想源头来自现实。\n如果说是现实中的“任务”概念，历史倒是很明确的。那些管理学大师们主张把工作分拆成一个又一个独立的模块，每个模块自然由许多任务组成。把这些任务分解到人头上，就是成功的管理了。\n但这种官僚而枯燥的管理方式，显然不应该是任务设计的起源。\n你们有谁觉得拿到每周工作任务表的时候觉得特高兴特好玩么？没有吧？\n你们会因为工作任务特复杂特有挑战性觉得充满了乐趣么？不会吧？\n明明工作也有行动啊。明明工作完了也能得到报酬啊。\n为什么工作就不好玩呢？\n但是在游戏里接到一排复杂的任务的时候，我们就会觉得好玩。\n应该这么说，游戏任务设计借鉴了管理学上的模型，但是其发展自有其源流，可谓殊途同归。\n所以，我们还是要沿着游戏本身的发展脉络，回溯到“任务”是隐含条件的古早时代中去。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"见山是山：没有任务的时代"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"早期的游戏当然没有任务，这似乎是个不容置疑的事实。\n最早的游戏，不管是太空侵略者还是Pong，包括Atari上那些东西，都只是光点、线段和色块，连显示文字的能力都不太有，自然没有任务的空间。\n超级玛丽的屏幕左上角不会有个对话框，告诉你你还需要踩死3只蘑菇才能获得5个金币的报酬。\n而在勇者斗恶龙里面，国王也只会让你去打倒恶龙，不会告诉你“你打倒恶龙需要屠龙剑，我在小地图上已经把它的位置标出来了，你顺着雷达走去就好”。\n至于游戏的另外来源呢？那些桌面游戏也同样没有任务。\n战棋游戏贡献的核心是数值系统和规则表。桌面角色扮演游戏则带来了迷宫、成长和宏大华丽的叙事。\n不管你是爱玩龙与地下城还是魂斗罗，你都不会见到类似今天主流游戏这样的任务。\n那时候的快乐似乎也很纯粹——\n稍等。\n早期的游戏确实没有任务，但是，这并不代表早期游戏没有“目的”。\n即便机能受到限制，即使整个行业都还出于萌芽期，但是游戏带给人们的快乐其实是没有变化的。\n比如我们玩超级玛丽这样的横板动作游戏，最初始的动力就是“我要打通这一关”。如果换成任务制的语言，就是“你要不停地反复到达屏幕的尽头”，以便看到更多的关卡、敌人和BOSS。\n当然，打通这一关以后，我的目标立刻就会变成“我想打通整个游戏”。那我就需要知道，“杀死库巴大王可以看到一段和公主的动画小电影”，或者“在地下城关卡有隐藏的房间到达就可以跳关”。\n然后，假定我没满足于打通关，还想用尽可能少的命打通关，我就需要想办法利用游戏的系统，比如“吃100个金币奖励一条命”、“吃蘑菇可以变大”、“吃花可以喷火”。这同样可以换成任务制的语言，比如“收集57/100个金币，获得自动复活药”。\n接着呢？我的朋友打得比我还好，他的分数比我更高，我还想打高分。我就必须开始研究杀死什么样的怪物可以获得怎样的分数回报好向他炫耀。那么，“一只乌龟跳一下等于100分”的任务回报也是可行的了。\n你看，如果用现代任务设计中的语言，完全可以把整个超级玛丽的系统都翻译过来。早期游戏没有任务，却并不代表他们没有今天游戏这些任务的要素。他们只是没有使用“任务设计”这种工具而已。如果是RPG类游戏，那就更方便了：不管是魔法门还是勇者斗恶龙，都可以非常容易地把冒险日志和攻略转化成任务化的语言。\n早期游戏的设计师们同样深谙“必须让玩家知道现在他应该要干什么”这个道理。只是在他们的时代中，游戏还是一件很新锐的玩具，并不需要掌握那么多的用户，也不需要努力让所有人都来理解游戏的目的，只要他们自己觉得“展示成这样玩家就能理解了吧”就可以了。\n早期游戏有游戏目的，只是他们还没有任务制来让玩家掌握目的；他们希望玩家自己可以探索出这些目的来。\n他们见山是山，是因为山在那里，而且也只需要接待懂得如何爬山的人就好了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"见山不是山：任务导向勃发的年代"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大概是从90年代中期开始，无论是东方还是西方，无论是家用机还是PC游戏，大家都开始逐渐采用任务设计了。\n任务的出现不是一个一夜之间的事件。现在回头看那个时期的游戏，可以发现有大量的“复合设计”：普通的主线剧情或日志和以列表形式出现的任务同时出现在游戏的系统里。\n玩家可以直接点击任务名获取单个任务的详情，也可以阅读庞大的日志，或者直接冲进游戏的关卡里打打杀杀。如果说上面的说法不太具体，你回忆一下暗黑破坏神（Diablo）或者博得之门（Baldur’s Gate），就能立刻明白“混合”这种说法的含义。日系游戏则更偏爱“列表”式的任务呈现方法，玩家需要到一个统一的“任务中心”去获取和完成任务，这种思路被大规模继承到了后来的网络游戏里，很多网络游戏都把任务设计集中在一点上完成。\n然后，在不知不觉中，游戏中的任务提示越来越明确，任务获得和完成越来越清楚，回报也越来越明显了。不光是角色扮演游戏有了任务和目标，模拟游戏、即时战略游戏、FPS和TPS射击游戏、动作游戏也纷纷从善如流加入了任务和目标。不管哪个游戏，只要打开菜单，总有个地方告诉你“你现在应该去干什么”。\n任务制被大规模采用的主要原因，其实并不是任务制本身有多少优势；而是游戏已经逐渐复杂化了，谁也不敢保证玩家能通过自己的探索就理解游戏所有的设计。\n有很多业内人士指出，那是因为现代游戏发展得太复杂了。他们觉得应该回到游戏的本原去，做些独立游戏，做些大家一看就会玩的东西，才是正确的道路。评论家和华尔街追捧那些独立游戏，追捧各种各样的创意小游戏，对360和PS3上的作品嗤之以鼻。\n真的吗？难道电影业会因为一个长镜头到底无法处理庞大的信息量，就指责说这是电影导演和编剧的错误，他们试图用电影承载太多的内容，所以整个电影业都应该回到用摄影机拍摄一些五分钟短片的年代去，以便可以继续用一个长镜头处理到底？\n显然不是。\n任务是一种如此好用的特殊语言，5分钟就能教会一个从没玩过这个游戏的人这个游戏的规则，并指导着他一步一步把这个游戏打通。\n任务时代的高潮出现在进入21世纪以后，到魔兽世界的时代到达巅峰。\n在魔兽世界和怪物猎人这样的游戏中，所有的设计都被任务统一起来，你不接任务几乎无法进行游戏。不管是叙事、系统还是教学，一切都有相对的任务进行指引。GTA这样的沙盘游戏更是整个就以任务展开剧情，不完成任务连地图都不会开启。\n同样，这个时代的其他游戏也在进行着疯狂的任务化和目标化：每个FPS游戏都有目标列表，多数的关卡都可以选择，就连赛车游戏也充满了限定条件的任务挑战模式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是，并不是任务本身好玩，而是任务想要达成的那些目的好玩。一旦搞错了因果关系，任务设计很容易滑入到“为了任务而任务”的歧途上去。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"见山只是山：重新淡化任务的年代"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把所有东西都任务化没问题吗？不要紧的，没有问题！\n——但就算这么说，在看到伦敦：地狱门里面用程序代码来生成任务的时候，人们心里也会忍不住打鼓吧。\n任务的泛滥很快就产生了一些负面效果。\n在任务列表把所有游戏内容都规范化、标准化的同时，“乏味”这个魔鬼也开始进入了这个系统。当我们看到任务列表越来越长，而每个任务的格式也越来越相似的时候，忍不住就有了“这是工作”的错觉。一旦玩家有了“这是工作”的错觉，他们就会抛弃这些设计。\n尤其是在某些网络游戏和纯任务制游戏中，这种乏味的感觉到达了顶峰。\n我就不多举例子了，但是你们每个人脑海中肯定都有一大排无聊到爆的纯任务制游戏和网络游戏列表。\n在这样的游戏中，典型的任务就是“打死多少个某种怪”、“打死多少个某种怪然后从他们身上拿回掉落”、“打死某种怪的BOSS”，然后如此重复循环。如果游戏的怪物设计有点特色还好，如果所有的怪物只有数值不同，打通这种游戏简直是折磨。\n这种游戏多了当然会产生反弹。\n在发售日期距离现在更近的游戏中，我们已经不太经常看到“任务中心”或者“关卡列表”这种东西了；取而代之的是重新复活的“发现设计目标”模式。\n很多任务是通过提示出现的。如果玩家没有完成过某个特定操作，或者没有发现线索，这个任务就不会在任务列表里出现。就算是魔兽世界式的问号、感叹号这样的明显提示，设计师在后来的版本中也在努力增加着任务本身的变化性，把任务获得、推进、完成的方法变得更为多样。\n与其说是“淡化”任务，不如说是大家对任务制设计的理解已经更加精进，更加娴熟。\nFNV就是一个好例子：虽然基本的设计元素仍然是那些任务，但是任务的变化已经更为多样，入口、出口和完成方式也更加变化多端。现代FPS/TPS游戏也不再像以前那么强调关卡和目标的概念，而更喜欢用类似成就的被动处理方法来提示玩家正确的玩法。\n同样，类任务设计也大行其道。在网络游戏里面，厂商们已经忍不住把任务从策划手里拿了出来，改名叫作“活动”、“每日”和“运镖”之类五花八门的名目。XBOX360的成就和PS3的奖杯只是换了个名字，两者其实也是明显的类任务设计。就连往常应该毫无“任务”可言的对战FPS/TPS游戏，也忍不住加入了升级、连杀奖励、称号这样的类任务系统，鼓励大家带着目的去打每一盘对战。\n总之，任务还是任务，在设计师的脑海和他们的工作文档中，大概还是这么组织的；只是，他们正在努力让用户看不到那个乏味的大任务列表。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"回到概念"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正如上面的简史所说，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"任务是一个被完全“凭空创造”出来的概念"}]},{"type":"text","value":"。\n就如电影和电视中的“镜头”，或者戏剧创作中的“幕”和“场”，是创造者为了创作方便，也为了观众接受方便而创作的概念。\n也就是说，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"“任务”无论对故事、对可玩性还是对互动来说，其实都是不必要的"}]},{"type":"text","value":"。\n导演用自然的一个长镜头到底，理论上也能拍电影——他们要真这么干了还能成为大师。当然，你做一个没有任务的游戏成不了大师。\n但是，人类和动物的区别就在于我们可以使用工具。“任务”正是我们这个行业所创造出来的最犀利的工具之一，这种设计理念甚至已经不仅仅限于游戏之中了，渗透到了现代社会的许多角落中去。\n顺便说一句，要知道我们游戏行业已经创造了多少超乎常理的设计概念了？去看看刚刚出了DVDRIP的电影《Scott.Pilgrim.Vs.The.World》吧。对游戏没有了解的人不可能知道为什么群众给这片子在IMDB上投了8.0分的。\n一个好的游戏设计师，应当在心中时刻有着“任务”的概念；但是他不应当被任务的固有概念所束缚。\n当他需要剧情的时候，他应该能够把各种各样的剧情和故事熟练拆解成各种所需要的任务形式，并分配下去；当他需要游戏性的时候，他也应当能够将这种游戏性所需要的所有知识和操作，分散在不同的任务和目标之中。\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让玩家每时每刻都知道他应当去做什么，这就是整个任务设计的核心。"}]},{"type":"text","value":"\n事情的关键并不是设计任务。\n你不应该为了设计任务而设计任务。\n那些充斥在三流游戏中的草率任务，正是在这种“我们需要500个任务”的粗暴指示下产生的。\n在如今的时代，如果一个任务只是因为“我需要填满任务列表”而存在，那这个任务就应该毫不犹豫地被删除。\n作为一个游戏设计师，你应该要保证："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"你所设计的每一个任务，都有明确的设计目的。因为任务只是表象，设计目的才是真正的血肉。"}]},{"type":"text","value":"\n哪怕是最不起眼的“去杀10条狼”的Farm任务，实际上也是可以有设计目的的。我将在接下来的“任务的设计方法”一节中深入这个问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"照例，我知道你们都不爱看的枯燥无聊的理论文章……第二部分。说真的我没想到这个命题竟然能扯出这么多，写起来收不住了……所以这篇只是设计方法的（上）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"工具箱"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任务设计的方法说简单很简单，就是对各种设计手法的灵活使用。说复杂也复杂，因为任务的种类实在是多种多样。一个像魔兽世界这样庞大的游戏起码能分类出几十种不同的任务形式，如果细化到设计师们交给程序的需求列表这种程度，这个数字肯定会增加到三位数或者四位数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要把多种多样的设计目的、游戏内容和故事情节分解成任务的形式，你必须先对任务这个工具箱本身了若指掌。那些大号的电钻和锤子要放在最下面，钳子和螺丝刀在中层，螺母和螺钉装在顶层的塑料袋里。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，在正式进入主题之前，我先说一下这个工具箱的各层结构。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要解决的第一个问题是“这是个什么样的任务”，由设计目的决定的是任务的执行方式。我这个任务是要用来指引用户呢，满足用户的收集欲望呢，提供一种全新的游戏内容呢，还是方便关卡制作呢？从这个角度去思考任务的执行方式，就能把纷繁复杂的任务形式梳理清楚。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来的问题是“用户怎么获得这个任务”，由展示方法决定的是任务的逻辑结构。怎么把一个任务呈现给用户？把怎样的任务呈现给什么类型的用户？怎么给用户提供对一个任务的期待？在逻辑结构层来解决。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后的一个问题是“各种各样的任务怎么管理”，由管理方法决定的是任务的分层模型；对玩家来说，这个分层模型也同时决定了他所看到的界面组织形式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从这里再前进一步就是“任务相关的制作资源怎么管理”，这个说起来就太枯燥乏味了，我这篇文章可能不会提到。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后一步是“预先告知用户任务回报”，这是个博大精深的话题，就算谈到我也只会是泛泛而谈。如果真要深入论述，恐怕得等到这架"},{"type":"element","tag":"a","props":{"href":"https://necromanov.wordpress.com/","rel":["nofollow"]},"children":[{"type":"text","value":"战略航空军的旗舰"}]},{"type":"text","value":"上出现一篇叫“游戏数值设计”的理论性文章以后了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些设计工具出现的时间有早有晚，有些仍然在发展中，有些工具已经产生了各种各样的变体。但是无论出现早晚，每种工具都有其优势和劣势。考虑到这是个进步非常迅速变化也非常快的领域，如果读者有什么意见也请自由发表。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"执行方式：从设计目的出发"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任务的执行方式设计是现代游戏设计中最多变，也是最需要创造力的范畴。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在执行方式这节中，我不打算像那些典型的“游戏教学书籍”那样用庞大枯燥的列表淹没你们——看那些“玩法教学书籍”是绝对学不会怎么设计的。同样，我也不需要重复一遍各种流行游戏中的任务设计，鹦鹉学舌的文章没有任何意义可言。与其有空看这种无意义的文章，还不如随便装个游戏抓紧时间打一打。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我会从“任务的设计目的”入手，从设计者和玩家两方面的动机出发把任务分成六个大类以及一个灵活的附加类。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MoveTo型任务（移动）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Farm型任务（重复）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Collect型任务（收集）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt型任务（狩猎）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Puzzle型任务（解谜）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Challenge型任务（挑战）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"附加类：Storytelling型任务（叙事）"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于我国是游戏设计后发国家，有些设计概念用中文表述可能不是太清晰，所有的类型都带个英文命名……总之你们知道Farm任务指代的是“重复作业”而不是“种田”就好了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MoveTo型任务（移动任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人类是这样一种生物：他们声称自己喜欢自由。但对大多数人来说，如果真的把自由的选择权给了他们，他们就会不知所措。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，1990年的每个游戏中，都有庞大的地下城和分支对话。2010年的绝大多数游戏中，你只需要跟着任务黄点的指示，从一个黄点跑到下一个黄点。这是一个有点冷酷的事实，多数人并不是真的喜欢自由，或者喜欢选择——他们只是装作喜欢而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以我们必须要给这些人设计MoveTo型任务。别给他们选择权，直接告诉他们现在应该去哪里吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MoveTo型任务是所有任务形式中最原始的一个，它的目的就是让玩家移动，或者说“跑路”。不管是魔戒的“到魔多去销毁戒指”还是西游记的“到西天去取经”，都是典型的Moveto任务。超级玛莉要从左到右突破所有关卡，雪人兄弟不往上冲就会被拖死，几乎所有FPS都要奔向一个又一个Checkpoint，这些也都是Moveto任务。从广义上来讲，甚至那些指示玩家如何按键移动人物、如何使用鼠标/手柄的教学目标都是Moveto类别的一种。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它的设计目的也非常显而易见：指引玩家行动，展示游戏内容。这个目的类型几乎和整个游戏史一样久远：既然你设计了游戏，当然要告诉玩家里面有些什么吧！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对玩家来说，完成MoveTo任务的目的是看到更多的没有看过的新内容；对设计者来说，MoveTo任务的目的除了展示玩家没有看过的新鲜设计内容之外，还要起到控制任务复杂度、关卡和脚本位置、Debug等等设计各种规范化的重要作用。在完成一个MoveTo任务之后，我们几乎可以笃定玩家必定在某个位置——这实在是太适合作为一段脚本的开头了。同样，对测试和Debug人员来说，移动任务也起到了重要的降低工作复杂度的作用——几乎是各种类沙盘游戏中唯一一个能起到该作用的设计手段。你不知道玩家什么时候去打哪里的怪，你也不知道玩家会怎么理解一个谜题，但是一个移动任务的结束地点肯定是个固定点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“这不都是废话吗！”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"肯定有好多读者要这么说了吧……且慢，且慢。从这个简单的事实陈述里面，能够导出一个很重要的问题，我把这个事实陈述换种说法看看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“如果玩家跟着这种任务移动到了新地点，却没有新的游戏内容呢？”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你看到问题所在了。设计师设计Moveto任务除了指引之外，还有一个规范任务行动区间的作用；而玩家则不能理解这种作用，他们会觉得一段看不到任何内容的纯跑路是非常无聊枯燥的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"事实也是如此。偶尔做一两个还好，如果连续几个任务都是纯跑路，路上没有任何游戏内容，哪怕报酬再好，玩家也是很烦躁的。从根本的设计目的上来说，跑路任务就不应该是用来消耗玩家时间的。成天让他在毫无内容变化的地方跑来跑去，不枯燥才怪呢！你能怪玩家想要自动跑路吗？你能怪他想要传送系统吗？显然不能。这甚至不能用回报来加以平衡；毕竟跑路的过程中，玩家什么也没干。你可以偶尔给玩家大笔的横财，但你不能老给他横财，长此以往必将吊起玩家的口味，让你想给他真正的回报的时候也没得可给。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从这个简单的陈述中，我们可以推论出现代MoveTo任务设计的指导思想：“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如果玩家不能看到任何新内容，就不要让他去做一个MoveTo任务"}]},{"type":"text","value":"”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用设计目的这个标准来看，许多传统的任务设计方式都是有问题的。比如说，一个任务做完了以后，为什么一定要跑路回去交？如果没有任何新内容或者下阶段展开的话，有必要吗？一个关系到多个相关NPC的连续任务，需要让玩家跑来跑去吗？有没有什么代替方法？如果还不行，那么你就需要给玩家提供方便的移动方式：载具、出租车、自动跑路、瞬间移动，什么都行。这不是“现代浮躁的玩家不懂得游戏性”，而是“你根本没有给玩家提供任何游戏性”，这两者之间的区别是显而易见的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而这条规则当然也可以反过来用：“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在有重要的新游戏内容的情况下，你必须用Moveto任务来保证这些内容不被玩家错过"}]},{"type":"text","value":"”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这类情况下，MoveTo类型的任务则是绝对必要的，不能完全被方便移动方式所代替。最典型的用法，就如同介绍一个大型新场景给玩家的时候，最好能用MoveTo任务把你这个场景的各个设计要点交待清楚。一座主城需要让玩家了解各个功能区；一个副本需要让玩家了解各个关键设计所在；哪怕是一段大型的即时电影演出，玩家也需要观摩电影的指引。在这些情况下，不要用快速移动方式代替你的MoveTo任务；在可能的情况下，甚至可以限制玩家移动来保证BUG数量能够得到控制。回去交任务也并不是都是没有用的操作，有些时候交任务本身可能也是一个设计要点，这个例子就比如荒野大镖客RDR里面回家那一段的杰出演出。我们不应该对“快速移动”或者“自动跑路”这样的设计要素一棍子打死，而应该区分对待。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那如果设计师一定要插入一段内容不太丰富的MoveTo任务呢？倒也不是不能设计，只要你改换一下任务的类型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我可以提供这么几个任务设计的例子。在通常的设计方法中，这些都被归类于不同的任务类别，甚至不同的游戏性；但如果从设计目的考虑，你会发现他们本质上都是MovTo类的任务。跑到某个地方采集一组药草，安装一个炸弹，拉动一个开关什么的，本质上有区别吗？其实没有。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师有一段路必需要求玩家跑两遍->在这两遍路上产生不同的、无法跳过的敌人。用不同的敌人来制造差异性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师有一个大关卡必须要求玩家先到最里面然后再出来->在进去的时候是一个MoveTo任务，在脱出的时候是一个强制推进的MoveTo型任务，可能是有时间限制、炸弹、毒气、洪水，总之你自己去想吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师希望控制玩家特定的移动路径，或者交待重要的NPC剧情/性格->把MoveTo任务改写成一个护送任务，这是MoveTo任务的一个子类型。让NPC沿着事先设好的固定点移动，同时控制玩家不能离开NPC过远。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师不在乎玩家怎么移动，但希望玩家看到这个区域内所有的重要点->把MoveTo任务改写成一个多段的物品收集/地点到达任务。设定几个操作点，让玩家去完成特定的操作，同时完成区域的交待工作。这种任务虽然以收集、解谜甚至Farm的形式出现，但本质上还是MoveTo型任务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师有一个复杂的关卡，但他希望玩家能按顺序完成这个关卡->把一个单一目标的MoveTo任务改写成一个连续而拥有多段目标的MoveTo任务。拆开路点，让用户每时每刻都有个短路点等在前面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以从这个基础上发挥你的设计能力和创造力，继续改善你的设计。关键仍然是设计目的，只要不是拖延游戏时间，玩家就不会讨厌MoveTo任务。难道有人会讨厌看激烈的大场面？那还玩什么游戏啊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上，不管是出于叙事考虑、设计考虑还是测试考虑，几乎每个任务的第一步都会是一个MoveTo型任务，这也是我把这个类别放在第一位的原因。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Farm型任务（重复任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师不应该用MoveTo任务来拖延游戏时间。那他们应该用什么工具呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然是Farm任务。我说的不是种田，Farm在这里也不当种田讲（虽然在目前最流行的开心农场和Farmville里，他们的“Farm任务”真的是在种田……但理论还是应该更普适一点）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那Farm任务到底是什么呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务的历史同样非常久远，可以追溯到游戏的史前期，甚至比Moveto类型还要早。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们总是说“打怪练功”、“打怪练功”。早在卷轴滚动技术出现之前，人们就开始玩各种只有一个固定画面的游戏，并且在这个固定的画面上用几个像素点对抗另外一些几个像素点组成的太空侵略者们。然后他们开始玩各种动作游戏，这些游戏的主题仍然是打怪（或者被怪打，总之还是有怪的）。然后是射击游戏，还是打怪。然后是角色扮演游戏，这次不光是打怪，还有升级……总之，光一个打怪就能覆盖80%的游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，打怪能得到什么呢？对这个问题的思考产生了Farm任务。一开始设计师们只是简单地计算分数，鼓励玩家的虚荣心；但这种行为很快就不够了，玩家们需要更明确的回报，设计师们就开始在游戏里加入什么奖命啊、奖励武器啊之类的新花样。终于，那些RPG设计师们把这些东西包装成了标准范式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随着设计师们在“打怪”和“练功”两者之间建立了明确的关系，Farm任务也由此产生。通常认为，只要在这两者之间建立联系的任务，就是Farm任务。所有那些让你去杀7只鸡15头猪20个兽人45个德国佬然后给你金币银币美刀钞票的任务，也全都是Farm任务。如果在广义上放宽到“所有需要反复熟练操作的游戏”，那Farm任务几乎能覆盖100%的类型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么这么命名呢？理由也很简单。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"种田有什么特点？主要就是两条，第一条是“田每年都要种，反反复复的种”，第二条是“种瓜得瓜，种豆得豆”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务有什么特点？同样是两条，第一条是“重复进行一样的工作”（打怪为主），第二条是“你费了多少力和时间，就有多少回报”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说，Farm任务的核心就是“重复”和“回报”。只要把握住这个核心要点，你就能轻易地识别出各种各样的Farm任务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而这些就是设计师们赖以拖延游戏时间的神兵利器。从一开始，就算没有Farm任务，游戏也很好玩，人们也要趴在电视/电脑/手机前面玩太空侵略者，超级玛丽，勇者斗恶龙，使命召唤和愤怒的小鸟。加上回报以后，群众不就会想要“多打一个任务”，“再多打一个任务”了吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多完美啊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好，那么我们现在知道了设计师侧的设计目的是“拖延时间”。那么玩家呢？对玩家来说，“重复”除了拖延时间之外还有什么用处？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个也再明显不过了——有个成语叫“熟能生巧”。人们为何要不停玩一样的游戏呢？自然是因为他们越玩越好啊。游戏技巧的提高本身，就已经是一件非常强力的武器了，足以拉着一部分人在游戏面前反复尝试。如果这种技巧的提高还伴随着各种游戏数值的提高，他们就更忍不住了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他们提高技巧，开启新内容，挑战新内容，再提高技巧，如此反复。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就是说，Farm任务的设计目的也分两个方面：设计师想用这种设计拖延用户的游戏时间，把他们拴在自己的游戏上；另一方面是用户，他们希望通过这些Farm任务熟悉游戏和熟练操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看起来真是太完美了。设计师们拖延了时间，用户自己也乐意，大家还有额外回报。加个没啥实际用途的升级槽，玩家就该高兴死了吧？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么……喜欢反复完成“干掉15头迅猛龙/干掉15头老虎/干掉15头豹子”这类任务的人请举手。有人吗？喂，举手啊？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好吧，为什么现在的Farm任务越设计越烦人了呢？明明是这么一个你情我愿的设计模式啊。它怎么就越做越无聊了呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务之所以能击中大量玩家心中的软肋，其原因和种田一样：“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"付出总有回报"}]},{"type":"text","value":"”。付出努力，收获与之相应的回报，永远是最令人兴奋的YY故事主线。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务比现实有一个最大的优点：游戏里的回报从不赖账。现实是难以预测的，谋事在人，成事在天；游戏则是个非常公平的裁判。在完成了Farm任务以后，玩家可以得到非常确实的回报，系统绝不会贪污，不会打官腔，也不会踢皮球，该升级升级，该捞钱捞钱。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种回报有一种短暂而强烈的上瘾性，几乎我们每个人都体会过那种看着回报一次次增加或者角色一次次成长的兴奋感，脑内的兴奋物质——大概是内啡肽吧，如果不是请纠正——大量分泌。如果你不太玩游戏，那么就想象看着自己投资的股票市值不停上升的景象吧，带来的快感和上瘾性有其相似之处。对于初次接触游戏的人，这种上瘾性尤其可怕——在现实中可能一辈子也获得不了的成就感和安全感，在游戏里只用几天就能满足了。所以那些第一次玩网络游戏的人纷纷沉迷，办公室里的白领们忙着偷菜，Facebook上的洋人们在Farmville面前纷纷垂首……谁也不是内啡肽的对手。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但如果你想做一个真正了不起的游戏，你就不能过于依赖这种廉价的Farm成瘾性，它更不该是你作为一个游戏设计师的唯一依赖。把猴子关在笼子里，他每次去拿同样的香蕉都会感到兴奋，用户可不会……好吧，至少有很大一部分用户会逐渐产生抗药性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"确实，有些人会一直满足于这种成瘾性，但也有很多人不会。对游戏了解不多的人往往对这种上瘾性大惊失色，从而对此口诛笔伐，指责电子海洛因；一些对游戏浅尝辄止的轻度用户体验过上瘾性后对它产生了抗体，却会觉得“游戏什么的不过如此大同小异”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说实话，连猴子都能抄来一个Farm-升级系统，还要游戏设计师干什么？那可不是你的本事，而是用户大脑中内啡肽的本事啊。集中36只猴子，里面肯定有一只能押中轮盘赌的数字；如果你只是简单地做了打怪升级的Farm任务，那就意味着你和猴子一样，完全把运气寄托在用户身上，希望他们中的绝大多数人都还没对这种兴奋物质分泌模式产生抗性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你觉得这样就够了，当然也可以。最近的一只猴子公司估值都有51亿美元了，可以得很呢……但既然这是一篇设计理论文章，就该写出点儿比猴子转轮盘赌更多的东西来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那除了“重复”和“回报”以外，玩家还想要什么？再想想之前那句话，“熟能生巧”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"没错，他们还要技能的提高。如果有技能的提高，没有回报他们都一遍遍玩游戏。让我们再看看前面那几个Farm任务。猎龙，猎虎，猎豹。玩家完成这几个任务之后，技术提高了吗？对游戏内容更熟悉了吗？除了那点银币和经验他们得到别的了吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你该知道这几个Farm任务的问题出在哪里了吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然是重复一样枯燥乏味的操作，技术不仅得不到任何提高，就算提高了也没用的话，就别怨用户上外挂啊！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务要做好，关键问题并不是你这个Farm任务本身的文本或者程序脚本写出高潮来，而是你这个游戏打怪部分本身必须有趣，而且有深度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"深度可以分成两个方面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"玩家的技术可以提高"}]},{"type":"text","value":"。这里有好多个方面可以提高，他的角色数值可以提高；他本人的操作能力可以提高；他对游戏的知识也可以提高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"这个提高必须有用，而且总是有用"}]},{"type":"text","value":"。这一点总是被很多设计师忽略，所以我想强调一下。如果提高知识对游戏进程/游戏效率并无影响的话，那它就不是一个提高；数值和操作能力也是一样的。如果提高造成的效果近乎可以忽略——干掉这个设计要素。反正你不干掉它玩家也不会在乎，谁在意我杀一个怪是用4.8秒还是4.6秒？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要做到这两点，你设计的游戏毫无疑问会拥有一张“成长阶梯表”，这是一件比猴子画的升级槽复杂而有趣得多的东西。你的游戏有多少种怪物，这些怪物有多少相关知识，玩家要消灭这些怪物需要多少操作能力和角色数值，和他们对应的有多少Farm任务，这些Farm任务完成以后能获得多少种不同的回报……等等等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在这些Farm任务就是有明确设计目的了：它们就是引导玩家通向这张成长表的桥梁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要保证玩家能提高技能，而且这些技能对他进一步玩游戏有帮助，Farm任务就没有问题。甚至都不用Farm任务的额外奖励，玩家们自己都会去找最有效率的打怪升级方式；如果游戏设计能做到这个方式随着“成长阶梯表”不停变化的话，整个游戏就不会显得那么枯燥乏味。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏设计师们务必要记住，你要在Farm任务中设计的是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一种需要不断“重复”的游戏内容，它应当是经得起不断重复的"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"照例，也有几点补充。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是不是要做出游戏深度，就一定要把Farm任务做得很难或者很复杂？**–>**不一定。单纯地提高难度往往只是增加枯燥而已，单纯地提高操作复杂度肯定只是增加乏味。你只需要保证“相应的难度有相应的回报”就可以了。让没有技能或者厌恶复杂度的玩家接受低风险的回报，让喜欢挑战和提高技能的玩家去面对高风险高回报，别盲目地做那些对深度玩家好玩但是难死庸手的东西。如果要做，给他们相应的高回报，这样也能顺利地把玩家分开档次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是不是能够通过调整随机性来改善Farm任务的重复性？我加点状态变化啦随机怪物啦随机掉落啦什么的怎样？**–>**不是。务必记住，深度只是第二级的目的，在你实现这个目的之前，要先保证第一阶段“付出总有回报”的Farm任务公式没有受到破坏。种田的特点是固定的投入和固定的产出，就算有随机的天灾也应当能够以人力进行应对。不要用你对随机性的偏爱破坏Farm部分，那是另外一个设计目的完全不同的类型任务：Hunt任务的范畴。当然，可以有意外惊喜，也可以有累计奖励，没有玩家讨厌意外惊喜或者累积奖励。但是，别做过分的随机性。Farm的用户最讨厌天灾了。如果非要有天灾，给他们设计对策，掌握对策就能战胜的天灾立刻就变成游戏深度了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一定要做无聊的Farm任务来拖延时间该怎么办？开发周期来不及了呀！**–>**无论如何，加点儿调剂。改变一下回报的种类，把不同的Farm任务明确分开。玩家其实不怕重复做一件事，他们更怕“只能做一件事”，例如最终幻想13里面的刷乌龟……一旦一个游戏只能做一件事，这不仅是玩家不满的源泉，更是对整个游戏制作资源的极大浪费，游戏设计师们应该感到耻辱。所以，在成长阶梯表上，时刻考虑多提供几个不同方向的Farm任务作为选择。甚至，不同的打法给不同的回报。只要你的“付出就有回报”这个原则是确定的，根据完成方法的不同给不同的回报并不会降低Farm本身带来的乐趣。还不行……偶尔插点纯正内啡肽吧。但如果真的要插，这次就千万别给玩家他还要Farm多久的提示了，他爱Farm多久Farm多久——永恒之塔的100遍Farm任务恐怕是游戏设计史上最愚蠢的设计之一了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这次还是两个重要大类……继续继续。常见任务种类这就差不多了，剩下的2+1种其实都是特殊用途了，还得再整理整理思路。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Collect型任务（收集任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说完了MoveTo型的任务和Farm型的任务，接下来可以说点确实没啥内涵的东西了。Collect任务就是任务里最好设计的一类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"几乎每类常见游戏设计都是冲着某一种人性的弱点去的，收集任务也不例外。有人完全不收集任何东西吗？从藏书、集邮、标本制作、奢侈品购买、艺术品收藏一直到首办、变形金刚、网络资源下载狂，一般人总归会忍不住去收集某些自己喜欢的东西。小学生就会本能地收集弹珠啦、烟标啦之类的东西，可见这确实是人类基本的爱好之一。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"收集任务收集的并不一定是装备或者道具；收集装备或者道具的任务，也并不一定是出于收集目的所设计的。比如最简单的“打某种怪随机掉落n个专属物品”这种任务，从形式上来说是收集型任务，本质上却不是。这种任务是Farm型任务的一种变种，用来填千篇一律的Farm型任务表的。类似的，“到若干固定地点取得特定任务物品”也同样不是Collect任务，而是Moveto任务。但如果这种掉落品有其特殊的规律和值得研究的多样性，它却又可以成为收集任务的一部分了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么呢？因为收集任务设计中，最重要的就是“收集欲”。**所有不能激发收集欲望的任务都不是好的收集任务。**人们并不想收集那些完全一样的东西。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说实话，收集欲望这东西本身没啥好说的，几条基本规律开天辟地以来就没改过，而且都是地球人都知道的设计原则，还做不到就是设计师的错了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就像金融衍生品的核心就是“打包与交换”这个概念一样，收集设计的核心就是“标准化与列表化”，把杂乱无章的物品合并，并组织成有逻辑的收集表。把相同的物品组织成收集内容，在内容的基础上产生逻辑，把过大的列表分成多级别的小表。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"收集任务的设计目的就是赤裸裸地利用人类本能的收集欲甚至收集强迫症，来推销设计师们想卖的东西"}]},{"type":"text","value":"，最典型也是最混蛋的设计就是臭名昭著的成就系统。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至于详细的设计要点么，我随便一列，你们也随便一看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，容易理解，容易入门。能够大众化的收集爱好通常都入门很容易，在游戏里也不例外。集邮的开始只是几张纪念邮票，钱币的入门也不过是几个平常找零回来的硬币，一个奢侈品狂姑娘的起步可能只是一个三流品牌的包包。好的收集品通常应该在玩家不知不觉间入手，然后给他展开一幅未来的庞大画卷。正面例子我就不多说了，反面例子么，COD7就是一个近在咫尺的例子。我估计肯定有好多用户直到通关也没发现游戏里有情报箱可以收集吧？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，提示明确。什么东西能收集，收集了有好处，应该有明确的提示。在开放式的沙盘游戏，比如荒野大镖客、辐射这样的作品里，这点特别重要——因为你完全无法控制玩家什么时候拿到什么物品。如果实在不能像FNV一样用游戏内的任务进行提示，用一些超游戏的手段进行提示也是合理的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再次，阶段和收集目标清晰。弹珠为什么只是小孩子的收集品？因为弹珠和弹珠彼此之间的区别实在太小了。收集设计也是同样的道理，每个阶段都要有自己的特色，收集完一定数量以后要立刻给玩家回报，别去搞那些容易令人放弃的“贯穿性收集”。我刚批评过的哥特4就不说了，贯穿整个游戏的多种“漏掉一个就完了”的收集品实在是令人无语。COD7也很令人绝望，如果说有比从头到尾都没发现一个情报箱更惨的事情，那就是打了大半游戏以后才拾取到第一个情报箱……所有不能回去重新收集的收集品，起码应该给一个数量提示吧。就像臭名昭著的金融行业一样，“贪婪”和“恐惧”也是永远的设计主题。人类很难抗拒把已经有相当进程的收集项目收集完的冲动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，留下充足的想象空间。有哪个现实中的收集领域有尽头呢？在一个领域后面接着的是另一个领域，在一个类型后面接着的是另一个类型。每个能够流行开来的收集爱好都有着几乎无穷无尽的深度，游戏用不到做到这种程度，但是相当深度的收集目标也是必要的。已经收集的内容是进一步收集的垫脚石，已经收集到的奖励装备可以通过收集进一步升级，都是提供深度的简单办法。再深入就可以引入类似鉴定、随机属性或者隐藏属性这样的高级收集爱好者才会喜欢的要素，模仿现实收集行业里捡漏和鉴宝的要素。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其他……其他真没什么好写的了。能做到这些，有收集癖的人就会欢欢地去做了；至于没有收集癖的那少数人，还是在收集回报上想办法吧。至于那些连贪婪和恐惧都没有的冷静强者，估计也不会来玩游戏吧？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，我想谈另一个问题：收集设计思路的扩展用法。利用收集癖好本身不算什么了不起的设计，但怎样利用收集癖好来引导用户就是个艺术了。从开放的角度来想，只要能激发用户收集欲，收集的是什么其实无所谓。你到底要在收集任务里推销些什么呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把眼光放远一点，不要把收集设计仅仅局限在任务上。最传统的想法是收集道具，这当然没有问题；音乐、CG、回想、图鉴这些想法比收集道具前进了一步，但本质上也区别不大。\n最简单的例子是成就。收集成就把收集的领域扩大到了“行为”方面。成就是挑战性设计，但把挑战们打包成一个成就系统，就是典型的收集设计了。这个类型改变的效果是非常明显的，现在几乎每个游戏都在努力做着类似成就的系统，瞄准的就是那些收集型玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关卡同样可以做成一种收集。谁规定所有关卡都要马上开放给玩家的？一点点解锁、凭票制、时间制、积分制都是可以考虑的设计。几乎每个音乐游戏都有用颜色清晰标明的不同难度及其评价，打开这个界面本身就是一种收集性质的激励。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"收集在装备设计中同样有大量应用。最经典的收集装备设计就是魔兽世界的套装……我上面说的入手简单、阶段目标清晰、提示明确、想象空间充足全齐了，可以当作一个经典的收集设计范例。暗黑破坏神的镶嵌是另外一个把收集要素融入到装备系统的好例子。这里值得一提的收集设计是“隐性收集装备”，也就是从数值角度按照套装设计，却并不写明的套装。在收集品过多的情况下，可以考虑用这个思路来设计。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更进一步，制造业还是一种收集。用收集任务的角度来看制造业系统设计，很多问题就迎刃而解了。要怎么安排制造业生产的装备？要如何引导玩家去获得各种不同来源的道具，然后投入制造？要怎么安排制造业的阶梯性？用收集的理念来设计，会比用简单的公式合成或者复杂的真实系制造理念好玩得多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现阶段能想到的收集设计，个人认为是剧情线索的收集。这是一项真正愿者上钩的收集。那些最好的小说，实际上也是把细节和叙事线索什么的隐藏在字里行间，直到所有线索汇集，才一气呵成讲完所有的故事，塑造出令人印象深刻的人物。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前这方面有几个很好的尝试，比如Bioshock系列，通过录音和关卡的完美结合来安排收集性质的线索叙事；FNV在结构上已经是线索收集-任务展开的形式了，可惜的是影响要素还并没有按照收集系统来设计，缺乏了一些形式美感，也不容易让一般玩家领会到那种草蛇灰线伏线千里的气势。在没有任何提示下，有多少人能发现凯撒的死亡竟然会影响好几个八竿子都打不着的遥远任务的展开线索？在叙事领域，目前还没有将线索收集作为核心收集要素的例子，最多也就是Bioshock这样无伤大雅的补充；但我个人觉得，类似作品的出现也不会太远了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt型任务（狩猎任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"自古以来狩猎就是人类的本能，在游戏世界里也不例外。当然，打死那些没啥抵抗能力的家畜不算狩猎，所谓Hunt任务，就是要拿出最好的武器和装备，和相对更强大的敌人进行生死的决斗，并获得惊人的报酬——俗称打BOSS。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果说Farm任务对应的是动作游戏中的杂兵，那么Hunt任务对应的就是动作游戏中的Boss战。\n如果说Farm任务对应的是代表幸福安宁满足感的内啡肽，那么Hunt任务对应的就是亢奋专注快感的多巴胺。\n如果说Farm任务的目的是设计成“普通玩家经过努力后不用脑也可以完成”，那么Hunt任务就应该保证成为“玩家反复磨练技术后得到的报偿”。\nOK，到此为止。理论上是该这么说的啦……实际上不是这么回事。把上面那些基本常识记下来，然后来考虑一下真正的设计目的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计Hunt任务的目的和考验玩家什么的没有任何关系。你设计首领战不是为了让玩家打不过去，而是为了让他的辛苦练习和成长有用武之地。真正的设计目的是消费。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt任务和BOSS战的设计，对应的是玩家的消费"}]},{"type":"text","value":"（当然还有投资，但这两者在游戏中就和现实经济中一样难以区分）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说，如果说其他类型的任务起到的是积累的作用，那么Hunt任务（当然还有PVP）就要起到消费的作用：在其他内容中取得的技能、等级和消耗品在这里被用掉，并变成玩家们最爱的回报和装备不动产。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个游戏的BOSS战可不是设计到谁都打不过去就是好的。想要做这种内容，去做怒首领蜂好了，听说直到今天在整个世界也只有一个人类可以打败二周目真绯蜂改发狂，而且大家还没有在录像上亲见。你通过传送每小时打败10次巴尔和考验玩家有任何关系么？你集结25个人和一个有钱的老板，去刷一个大副本和考验玩家有任何关系么？什么关系都没有啊。\n无他，唯手熟尔。Farm任务是连外挂也能完成的任务，而Hunt任务就应该是要求操作熟练度和专克外挂的那些内容。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说到这里，最重要的是什么简直呼之欲出。主要有两个问题，门槛和随机性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门槛部分的设计思想很简单，保证用户大多数的资产都能在某个Hunt任务中用上。所有的武器、职业和技能都有优势领域自然最好，大部分有用也很不错。让不同的Hunt任务之间所需要的门槛错开也是很重要的，有些BOSS可能是硬性的数值门槛，有些可能是队伍组成/技能熟练门槛，有些可能是特殊装备门槛、时间门槛甚至用户金钱/资产门槛。不要太轻视这个部分：除了让用户怎么捞以外，让用户捞到的东西有用也是非常重要的。如果条件允许的话，负责设计重要的门槛BOSS的游戏设计师最好同时负责数值或系统的设计，至少也要有项目内数值或系统设计的经验。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说随机性。随机性看起来很简单，但其实也有不少小窍门。核心的指导思想么……我就说的浅白且反动一点了：**距离现实中的赌博（或者彩票）设计越近，那么随机性的设计就越令人舒服。**不算金融衍生品的话，赌博是人类掌握的最有效的财富消灭器，久经考验。如果这个游戏设计的目的是让人反复玩，那么Hunt任务和BOSS设计就要当仁不让，扛起作为赌场的责任来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最无聊的BOSS就是那种可以按照固定套路简单地对付，但是期望回报还一直非常高的BOSS。买100块随机返回80~120块奖金的彩票会有人爱买吗？一个这种高级BOSS就能毁掉整个游戏，最典型的例子就是FF13，网游里面也有大量“只有一个BOSS有人在刷”的游戏。当一个游戏所有的Hunt部分都变成Farm的时候，这个游戏的生命也就差不多到头了。性质非常类似的糟糕设计是“一切BOSS都可以用同样的招数简单的处理”，这会让玩家觉得不管是熟练操作还是角色成长都没有任何实际意义。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外一种乍看之下很好，其实却很令人烦躁的随机性设计就是所谓“平均化几率”。BOSS确实会很多招数，但他只是每次以相同的概率抽取几个差不多难度的招数。好不容易打倒了某个BOSS，这个BOSS却只会以平均的概率掉落各种相同等级的装备（在魔兽世界的某些BOSS中这种设计特别常见）。平均化随机的问题在于，事实上的回报和给玩家造成的期望不符。比如BOSS掉落三种装备，几率全是1/3。一般玩家自然会想“打三次应该就能都掉出来了吧”，实际上却不是这么回事——大多数时候起码要打4次或者5次才能都掉出来（感兴趣的人可以自己算算，我就不附公式了）。这个心理期望概率和实际概率的误差在重复次数不是太多的时候会非常明显。可以参考一下轮盘的设计：如果回报严格遵循算数平均的话，就应该给不同风险偏好的用户不同的赔率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从这里再进一步，就是在“玩法的随机性”和“回报的随机性”之间建立逻辑关系。流行的赌博形式可以分为四种：赔率规则非常简单，但是玩法策略充满可控性和对抗性的赌博（例如二十一点和得克萨斯扑克）；赔率规则非常复杂，但是玩法策略非常简单或者完全不可操控的赌博（例如轮盘）；赔率和玩法都非常简单的赌博（例如彩票，老虎机）；赔率和玩法都非常复杂的赌博（例如麻将，赛马）。其中第三种是最有趣的。六合彩本身是一个纯粹随机的游戏，但是由于回报倍率惊人，而且形式十分迷惑人，人们忍不住发展出了众多的“彩票逻辑”。计算数字概率啦，改变投注策略啦，就仿佛六合彩那几个数字和赛马或足球一样是有规律可循的一般……人们是多么热爱虚幻的操控感啊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么回到随机性设计的问题上来。在目前的BOSS设计中，玩家的行动或行动策略对他所能获得的回报有影响吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和赌博一对比，就显示出多数游戏在这方面设计的空白和乏力。暗黑破坏神显然是没有的，魔兽世界也基本是没有的，赌注状态仅有“能打过”和“打不过”两级门槛，用户并不能下更大的赌注，或者提高自己赢得赌注的几率。有些游戏倒是拉开了回报赔率的差距，同样一个BOSS可能掉落等级差距极大的回报，但这个回报赔率的区别并不取决于玩家所做出的赌注决策，只是纯粹碰运气而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是否可以适当强化不同BOSS之间的赌博公式区别，让不同的BOSS拥有不同的回报赔率，并且这个赔率可以随着玩家的选择而改变呢？有些游戏选择了根据打法改变掉落表，有些游戏则引入了时间和评价之类的其他影响因素，不过在这方面的尝试仍然远远不够。比如，能不能制作一个类似轮盘或者赛马赌票的Hunt任务系统呢？能不能刻意限制玩家打BOSS的次数，让“无限下注赌场”变成“有限下注赌场”呢？顺着“赌场下注”的思路想下去，应该还有更多有趣的想法吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Puzzle型任务（解谜任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果这篇文章写作于1990年而不是2010年，肯定会写“Puzzle型任务的设计目的是智力挑战和由此带来的愉悦感”。就像神秘岛里的层层机关，就像国家宝藏里的条条线索，抽丝剥茧到最后揭开所有谜题……多有趣啊。\n就连在大众传媒和一般人的想象中，游戏设计师们干的也应该是类似这样的工作：他们（经常也有她们，通常还是些美妞……可恶，我恨现实）坐在一些塑胶玩具和毛绒玩具中间，对着一些色彩斑斓的电脑屏幕画画图，连连线，就做出来了一些类似愤怒的小鸟和植物大战僵尸的可爱游戏，然后大赚其钱。\n多美好的想象啊。大众传媒还觉得魔兽世界的测试员是世界上最好最有趣的十个工作之一呢……你们敢找个魔兽世界的Tester来么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"遗憾的是，现在是2010年，一个互联网络已经大行其道的年代，所以这一段不会这么写。人类的智力在Google面前实在不值一提，再难的谜题在搜索引擎面前也会被分秒解决。智力挑战？抱歉一般人不喜欢这个。大家能面对的智力挑战到头就是雷顿教授（而且还要查攻略），稍微差点儿就是脑白金，一本字书或者一篇长文能秒掉百分之八十的用户，你还挑战他们的智力？开什么玩笑啊。\n所以，解谜任务在网络时代分出了两条支流。简单的那条支流瞄准的是操作，把“智力”简化成了简单重复操作考验，代表作品就如同脑白金、Puzzle Quest和愤怒的小鸟；难的那条支流则担负着另外一个任务，这类Puzzle型任务的最主要设计目的不是“智力挑战”，而是“用户交流”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先说“操作性谜题”。操作性谜题……本质上不是谜题。它们是一些通过程序生成的小游戏，只是装成谜题的样子而已。\n最低档的操作性谜题就仿佛国内网游非常流行的“每日文化答题”，用户只需要背背题库就好——为了每日领赏，他们也确实对题库倒背如流（我时常想，如果专门开个雅思题库或者GRE题库服务器，没准比新东方教学效果还好呢）。俄罗斯方块衍生系和宝石迷阵衍生系也非常受欢迎，做成和游戏内系统挂钩的或者3D视角的也不算费事（Puzzle Quest就算是个最典型的例子了）。再强一点的放拼字游戏或者数独，虽然抄起来很省心，只要设计师们改头换面一番就能瞬间生成数以千计的谜题表——脑白金是最好的例子了。喜欢动作性的设计师可以像愤怒的小鸟一样照抄某些经典的动作或者解谜游戏设计，反正愤怒的小鸟自己也不过是照抄那些前辈，例如百战天虫什么的（事实上这个抛物线解谜类型久远到电脑都还没出现就已经有了，如果十七世纪会解这种谜题，你就可以在任意一家国家的炮兵中找到一份好工作）。再往上才是“自己设计操作性谜题任务”——虽然大众媒体都吹捧这种做法，但我非常非常不推荐这条道路。一百个放在Appstore或者Xboxlive上的原创小游戏里，起码有九十五个无人问津。一百个放在主流游戏里面的解谜小游戏，起码有九十个是垃圾。劳民伤财呀，何苦呢？\n那么这种谜题任务用来干吗呢？目的也很简单，这大概是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"成本最低的用来调剂节奏和拖延游戏时间的方法"}]},{"type":"text","value":"。设计操作性谜题任务几乎不需要什么游戏设计师，只需要些谜题数据库就能搞定了，而这点努力能换回玩家成千上万的游戏时间。它们也很适合做那些跨等级和横跨整个游戏的固定任务/每日任务，这样设计内容方面就不用操心了，只要简单调整调整题库的难度表和回报比例就成。除了“天才的设计师自己钩钩画画出来”的小游戏之外，剩下的操作性谜题都是久经考验，一般人也都玩得非常好，用户引导方面同样不用费心。\n就只是这样？没错，就只是这样，我想不出有什么更深刻的设计目标了。除了“低成本内容”外，没有其他意义，甭指望用户会因为你做了一个比愤怒的小鸟还好玩还漂亮的小游戏就凑过来，因为他们买的本来就是愤怒的小鸟而不是其他。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说“交流性谜题任务”。交流性谜题的设计目的就是让玩家们在游戏内或者游戏外勾勾搭搭，吵吵嚷嚷，间接"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"提高游戏的黏着度"}]},{"type":"text","value":"。\n最简单的交流性谜题自然是“多人合作”Puzzle任务了。在任务里强制让玩家们协作解除机关就能达成最简单的强制多人合作，再进一步就是让玩家们在战术/移动层上达成配合的解谜任务。玩家们在行动上的配合，或者强制限时推进同样非常好用，可以逼着用户们强化彼此之间的关系等级，构建出一些要求比野队、随机副本或者G团更高的任务内容。\n“寻求帮助”也是一种很好的交流性任务。大多数有任务的游戏，都有不止一种职业，设计师可以通过这种需要其他职业能力的任务来强化沟通。如果把这种任务放大到关卡或者副本的层面上来看，还可以发掘出更多变的用法：例如某个副本，有要求一个五人队伍中有四个战士才能完成的交流性Puzzle任务，也就无形间提供了整个副本的另外一套强制打法。\n再往上一层的目的就是想办法引导玩家去进行游戏外的讨论，这通过普通任务就很难做到了——搜索引擎和教程仍然是无敌的。通常来说，要让一个任务在玩家中造成分歧，用“隐藏”或者“推理”这种寻常手段是没用的，这种手段最多能制造一些“XXX地区还差两个任务没做成就完不成求助”这样的低水平讨论。你必须要做到两点：第一，隐藏一部份数据和逻辑。第二，构造虚假的线索。争论，只有争论才是制造分歧和掩盖谜题真相的最有力武器。构造虚假的线索，隐藏关键的数据，让玩家在他的直觉和逻辑之间产生矛盾。这事儿暴雪干得精熟，Square Enix也不遑多让。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后我还是用实例来说明，说个我所知道的“交流性谜题”（其实不是谜题任务了，但是设计目的差不多）的设计例子吧。你们都知道暗黑破坏神2那臭名昭著的“物品掉落率增加7%护符（俗称SC）”吧？由于可以增加7%的掉落率，所有人都喜欢它。在某大型网络游戏里面，有个类似的设计，某些职业和装备上有个属性叫做“物品掉落率增加”的、看起来就像SC一样非常重要的属性。官方只是草草一说“这个属性可以增加物品的掉落率啊”就结束了，然后几个设计师在非官方的场合透露过“确实是有改变率的啊”。争论由此展开。由于持有技能的职业通常在大Raid中不太重要，有这种属性的装备本身战斗力通常非常低下，那到底要怎么才能最大化利益呢？一个Raid团应该带几个这种掉落率相关群众，又应该怎么围绕它们来安排战术呢？技术党们争论不止，自然想到了测试，结果发现——这个属性的效果是根据目标BOSS和掉落物种类的不同而变化的。对于大多数低等便宜原料来说掉落率常常倍增，但是对于各种装备、高级原料、宝石什么的就很难说了……于是持各种论调的技术党们争辩不止，论坛上定期出现“最新一期掉落率实测结果！推翻传统论调”的月经贴，各国人民组团时左右为难。\n我相信设计师们一定在偷笑吧。例子到此为止——Puzzle任务应该也不用再多说了。想办法创造出新的谜题和话题点，创造更多的争辩和分歧吧。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"只有能产生分歧的问题，才是互联网和搜索引擎无法战胜的内容。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Challenge型任务（挑战任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Challenge型任务的设计目的是“玩家分层”和“虚荣心”。如果说以上前几类任务的最终设计目的都是“让所有用户都能完成”的话，那么挑战型任务设计的目的只有一个："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让绝大多数用户只能部分地完成它"}]},{"type":"text","value":"（注意不是完不成它，一个用户不感兴趣或怎么也完不成的挑战是相当失败的）。“人人都有”的东西大家不太感兴趣，只有“人无我有”才是可恶的虚荣心。\n这个类型任务的设计思路直接继承了原始时代“分数”的设计目标，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让用户分层化"}]},{"type":"text","value":"。人生的目的就是打到最高分，每天的最高分，每周的最高分，每月的最高分，每服务器的最高分，历史的最高分……强者们，高手们，人民币日元美元欧元战士们，你们炫耀的时候到了！\n“挑战么……增加难度不就行了？”\n不要把这事儿想得太容易。没错，难度变化是几乎每个游戏都有的基础。变更数量、变更敌方属性、变更敌方行动规律（玩家管这叫AI，虽然实质上这和AI关系非常小）。同样的内容，改变一下数值和容错率就能提供完全不同的难度，是大家喜闻乐见的挑战自我和挑战他人的形式。这里棘手的问题，主要是怎么把这些难度变化任务展示给一般玩家……大多数游戏的设计是完全失败的，只有少数精英玩家会去挑战高难度。我印象里最成功的设计恐怕还是暴雪的暗黑破坏神，强逼着一般用户去挑战最高难度反复刷刷刷。如果你想让玩家挑战不同难度的相同任务，首先要控制难度种类不超过四种（最多五种吧，再多一般人就直接忽略了），然后是尽量让他们认为这是一次通关顺序上不同的内容——而不是反复进行同样的内容。\n可对精英玩家来说，这是远远不够的。设计师们总在抱怨用户弱智，他们总能发现，用户中最弱的那一部分永远比人类所能想象的程度还要弱。反过来说，用户们最强的那一部分也是强到几乎无止境的。反射神经论毫秒计算的只是基础，高手们的肉眼不光可以分辨单独帧，甚至还能分辨出每个单独帧延迟的时间；你的十个指头每分钟最多输出一百个有意义的操作，有的高手每分钟能输出五百个；你觉得能弹个钢琴已经很了不起了，可用户里多的是有绝对音感加精准操作媲美职业钢琴师的高手；你能在甩狙击枪的过程中命中目标？高手还能用肉眼对抛物线做积分呢。设计师当然要尽全力设计各种各样的高难度内容，这是他们当然的职责。但光靠难度是不够的，谁能斗过无敌的玩家呢？甭管是噩梦还是神级难度都有人无伤通关，设计目标是50分钟的内容可能会被突破到两三分钟，理论上决不可能的精确操作会被打到100%命中，高手的手指和外挂无异。光从难度入手是不够的，还得另想办法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外的办法，就是设计师放弃去挑战玩家，而是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让玩家挑战自己和其他玩家的极限"}]},{"type":"text","value":"。无论是单机还是网游，都在试图走这个方向，设计那些让强力用户和强力用户自身进行极限挑战的内容。所以，挑战任务设计的核心，其实是“你要让玩家们在什么样的项目上分出高下”。由于挑战本身就是一种快乐，是否要在这里设计对应的回报都存在很大争议——从结果来看，通常有没有回报都可以。有些人喜欢留个象征性的入门回报，有些人喜欢留个分级制但是上不封顶的回报，有些人喜欢留个只给冠军的回报——怎么操作都行的，反正挑战任务的目标是玩家的好胜心和虚荣心；既然是“虚”荣心，当上冠军这件事情本身已经足以让那些高手们手舞足蹈了。除了回报之外，改善挑战任务的组织同样有不错的小说。理论上来说，挑战任务直接散布在整个游戏中是可以的；但像荒野大镖客RDR一样，用一些等级和列表把这些挑战任务组织起来会更好一些。看到100个挑战任务像芝麻一样分布在游戏里会令不少人抓狂；但如果挑战任务的组织结构是4"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"10（容易）、3"}]},{"type":"text","value":"10（普通）、2"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"10（困难）、1"}]},{"type":"text","value":"10（噩梦），那同样数量的挑战任务能让更多的人上钩。\n撇开难度不说，还有几种被广泛使用的低成本Challenge类任务设计手法——呃，我就不提人民币/美元充值榜和道具/装备排行榜了，那些太邪恶了，要用也得想办法立个牌坊再说。PVP要素也不多提了，给一个任务制作协作模式或者对抗模式的成本太高，基本可以视作完全做了个不同的新任务了——八成还得搭做一张新地图什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"精确操作：传统上来说，分数主要就是用来奖励精确操作的——偶尔也用来奖励一下下面说的其他几类挑战任务。千万别设计那种“谁来了都能打满分”的分数统计任务，如果有这种内容，请果断砍掉，没有任何意义。精确操作通常有两种表现形式，一种是“操作得越准越好”，另一种是“操作得不出错就好”，前者考验反应，后者考验意识。这个对非网络游戏来说是非常常用的设计手段，但对网络游戏来说有个棘手的延时问题（同时也衍生出了外挂问题）。选择哪种，只取决于你所需要的游戏类型。前者更适合做分数排行榜，设计毫无失误的连击和目押；后者更适合做网络游戏和各种用来展现神一般的意识和飘忽的操作的内容。\n时间限制和时间统计：时限任务是最最最好做的挑战任务了。甭管什么内容，你都可以加个时间限制在那里，立马就可以开始计时排名。倒数计时可以强化紧张感，顺序计时可以用来做用户水准评价。再弱智的游戏都可以有时间挑战任务，怎么都能加进去的……只是有一个小小的问题，似乎有很大一部分玩家生理上本能讨厌计时。我个人的建议是，尽量少用倒计时，把倒计时任务丢在关键位置和某些可选任务里，不要做全局化的计时任务系统（也就是那种所有任务都自带一个计时器的禁忌设计）。这种东西偶尔有几个可以，走到哪儿都有就会破坏整个游戏的节奏感，还会吓跑患有隐性闹钟恐惧症的玩家。如果打算大量使用时间相关的设计，可以考虑用其他的方式变通处理，例如限定时间的BUFF或者道具，或者用“全世界/全服务器第一个达成某某目标”这样的变通手段来做。\n探索与意外发现：也就是“完成度”，同样是加起来不费什么大事儿的内容。和时间设计正好相反的挑战要素，时间相关挑战对应那些快准狠玩家，完成度相关挑战对应那些细慢精玩家。这个类型的挑战任务倒是不怕多，甚至从某种意义上来说，越多越好，做得越多就能引导玩家看到越多的设计细节——前提是你的游戏有足够的设计细节。击杀一个任务中生成的所有敌人，踹翻所有的生成宝箱，认真看完小电影抓紧时间按掉里面所有QTE，打柴堆一下向下移动三步空挥五刀就能吃到1UP……怎样变态的小知识都可以。暴雪饭们都对WOW“服务器里的树苗会随着版本更新逐渐换成大树”这事情赞不绝口，UO粉们对“因为游戏BUG产生的不同颜色的一般物品”趋之若鹜，玩家们探索设计细节的这个过程本身有时就能构成口碑营销。知道这些没用的小知识也算是炫耀要素之一，是真正爱好者们引以为豪的话题，做点儿东西满足他们的期待也是没错的。完全没有这些小知识的游戏看起来会很粗糙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Storytelling型任务（叙事任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说完了六类主要的设计目的，按以上教程做出来的任务就能好玩，或者令人印象很深刻了么？\n很遗憾，恐怕还是不能。这篇理论文章的目的是把任务做得很舒服，不会有人动辄跳起来骂娘，可不代表这些任务不会无聊。\n设计和艺术是不一样的。因为设计可以很容易地复制，而艺术不能。上面这些并不是什么了不起的东西，只是一篇基础设计常识的实用菜谱。不管怎么无聊的故事线，照着上面这些任务分类去做，至少能把普通的文本转换成看起来不那么单调的任务线，也能保证一般用户都能轻松地接受这些任务。\n但叙事没有这么简单，因为叙事的要求比不无聊要高得多。叙事任务并无其固定的形式。形式并不等于公式，世上有好的食谱和差的食谱，但绝无那种神奇的食谱可以保证你的蛋糕一定美味可口。\n所以，最后一个附加的任务分类就是叙事（Storytelling），探讨一下怎么用讨厌的任务制设计方法来实现电影化或者小说化的叙事。这一部分基本上全是设想了，不像前面六个大类，你们直接去找个“魔兽世界大灾变”来玩就能看到里面很多任务设计思路的具体改进方案。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个问题其实相当为难。大多数时候，任务制就是叙事的天敌。\n任务制天生就适合做短篇小说，它甚至能把很好的长篇故事拆成很多什么都不是的短篇小说和超短篇小说。回想一下你最喜欢的那些电影和小说吧，每个拆成任务制以后似乎都很无聊，连贯的故事变得支离破碎。\n几个还算成功的游戏作品在这些方面的努力看起来也乏善可陈。魔兽世界制作了数以万计的任务和数百万字的任务文本，但能让玩家感到激动地任务怕是连十分之一都没有。侠盗列车手GTA4在单个任务上下的功夫不可谓不深，投入不可谓不多，但大多数任务还是只配被玩家快速地按掉又按掉。辐射新维加斯在任务结构和复杂程度方面的努力创下了角色扮演游戏史上的新高，但这种努力也没有遮掩住主线任务故事的散乱和最终决战的巨大落差。我们手头没什么太成功的例子，只好从那些一闪而过的成功火花里来找灵感。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于游戏来说，叙事三要素的实现顺序和其他媒体是不一样的。我们的叙事三要素按照难度从低往高排，是环境，情节，人物。\n对于一个游戏来说，最容易搞定的就是环境了。环境带来的冲击随时都能看到，而且能够感受到；要塑造一个出色的环境也用不着什么太复杂的技巧：音乐加场景设计就能基本搞定。几乎每个成功的游戏，背后都有一个杰出的世界观。这也是任务设计最容易发挥其威力的地方——所谓世界，原本就是由一个又一个的细节拼成的，任务设计恰恰擅长描述细节。只要隔三差五分配一些任务或目标在世界观塑造上，就能很成功地构造环境。\n情节就相对比较难办了。任务制和情节的抵触看起来十分彻底：谁愿意每次情节发生的时候看到“你的任务已经更新”，然后又要重新跑一大段路？别管设计师或者剧本原来打算搞什么叙事节奏，现在都已经破坏光了。一个恶劣的反面例子就是辐射新维加斯最后的胡佛水坝大战，虽然剧本和线索布置得很充足，但真打到这里的时候就会令人感觉“啊，不过如此……”，一点也没有最终决战应有的节奏。\n我个人的观点，正确的发展方向只能是“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"关键情节连贯化"}]},{"type":"text","value":"”。当情节上需要进行关键高潮的时候，尽一切可能进行连贯化。任务不用回去交，回报直接打进道具栏，跑路部分使用强制传送，小电影部分用即时互动……把所有的精力集中在叙事进程本身上，能跳的部分毫不犹豫地跳，能省的部分毫不犹豫地省。所有的叙事应当一气呵成，就像电影的高潮部分一样。任务执行本身也应当和叙事结合起来，要把游戏时间、难度，甚至是玩家失败的可能性也考虑进整个叙事流程当中。当然，出于成本和周期考虑，不可能所有任务都这么设计；为了达到这个目的，甚至可以牺牲那些不重要的次要任务的质量，明确地在“主线关键剧情任务”和“环境塑造任务”之间拉开差距。至于网络游戏么……你看，网络游戏本来也是要送新手包诱骗用户去升级的，不是么？既然用户肯定有额外资源，索性都用在这里好了。\n人物是最大的难点。就算是小说，要塑造一个人物形象也是难比登天的事情；更别说游戏了。说实话，我实在想不到什么成功塑造了人物形象的普通游戏例子，偶尔有几个成功的例子，又不太具备普适性，比如Bioshock这样的大成功连他们自己的二代都复制不了。日本游戏曾经倒是有很多成就，但那些成就是FC和PS舞台剧时代的成就，沿用的是戏剧形式的夸张演出，并不是当代的成就，当代的日本游戏人物塑造可以说是普遍失败的（美少女游戏Galgame除外啦……以5pb为代表的角色营销干得还不错)。我们只好从叙事常识角度试着来构思如何在任务中塑造人物了。\n先不说人物曲线什么的劳什子，塑造人物的最基本要求就是“信息量”，光这一点大多数任务制的游戏就保证不了。如果一部电影剧本看到第50页的时候还不知道谁是主角，有几个，这电影剧本肯定会被打回去重写；这样的事偏偏在游戏中反复地发生。不管是魔兽世界、GTA还是荒野大镖客里，主要角色塑造很少有超过十个任务的——区区十个任务！通常来说，不算任务进行过程，这十个任务也只够将就交待一下角色的出身性格什么的，距离有血有肉还差得远呢。想用这种分量的信息量塑造一个了不起的角色，你们需要的不是编剧，是莎士比亚了。要真想通过任务塑造人物，第一件事情就是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"把人物角色相关任务的密度和数量提高"}]},{"type":"text","value":"，把所有能拉到目标角色身上的任务都拉过来，聚集成一条事件线，甚至一个巨大的事件团。\n接着就是所谓的“人物曲线”，一个人物角色的背景、动机、内在目标和性格变化。这个要求就更高了，就算在电影里通常也只是极少数主角能享受的高级待遇。对于游戏来说，这个变化更必须是能在游戏过程中让玩家潜移默化地体会出来的……难上加难。舞台剧式的角色直接转职固然省事，但以叙事手段来说未免落了下乘。用好感度之类的数值来处理人物不同阶段的反应和AI比前者略好，但以这种系统作为游戏内容却显得十分生硬，只有最早期那些“恋爱”游戏才会用这种生硬的系统——别看了，近期游戏里Dragon Age我说的就是你，这种上个世纪的Gameplay你不觉得难受么！如果参照日本galgame脚本的发展过程，比较受欢迎的处理方式其实是“同样的关键任务事件中，不同的角色有不同的反应”，但这个在游戏制作成本上的投入又实在太大了……现代游戏不能光掰对话树啊，也需要有不同的演出甚至具体的不同游戏内容。稍微退让一些的做法可能更有实际可操作性：人物的背景、动机、过去等等都是独立的小型任务或任务细节，关键的“性格变化”和“冲突”两步则和游戏内的大型情节任务挂钩处理，并设计对应的任务体验内容。由于大多数游戏都做得很差，在这方面努力一些，再在关键的体验部分想出个好点子就能令玩家留下深刻印象，典型例子如Bioshock的某角色以及最近COD7的某角色。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总之，叙事性任务是所有任务类型中最需要灵活想法的一个部分，它是由其他所有类别任务复合而形成的。怎样巧妙地将任务系统的文本和游戏内容勾连成庞大而美妙的叙事体验，更接近艺术而不是技术，我也只能泛泛而谈了。在接下来的逻辑结构一节里，还会继续探讨不同的任务结构形式和玩家体验之间的关系。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"内容为转载，总篇幅较长。原文地址（自备梯子）："}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/11/14/quest-design-01/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(1)：概念与简史"}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/11/23/quest_design_2/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(2)：MoveTo与Farm任务"}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/12/03/quest_design_03/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(3)：Collect与Hunt任务"}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/12/14/quest_design_04/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(4)：Puzzle、Challenge和任务叙事"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-08-05-game-task-design.md","_source":"content","_file":"game/2021-08-05-game-task-design.md","_extension":"md","date":"2021-08-05"},{"_path":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"unity gameplay ability源代码解析","description":"github仓库 : https://github.com/sjai013/unity-gameplay-ability-system","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"github仓库 : "},{"type":"element","tag":"a","props":{"href":"https://github.com/sjai013/unity-gameplay-ability-system","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/sjai013/unity-gameplay-ability-system"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个开源系统主要包含了以下内容"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Attribute System  属性系统."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Gameplay Tags  tag用来判断技能是否能够释放,以及检查effect是否能够添加"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Gameplay Effects  技能特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ability 技能"}]}]},{"type":"element","tag":"h2","props":{"id":"特效"},"children":[{"type":"text","value":"特效"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GameplayEffectSpec 是特效的runtime"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包含了特效的双方和target"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包含了其他数据等级,持续时间等"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建方法"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AbilitySystemCharacter.MakeOutgoingSpec"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameplayEffectSpec.CreateNew"}]}]}]},{"type":"element","tag":"h3","props":{"id":"添加特效到角色"},"children":[{"type":"text","value":"添加特效到角色"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"检查特效tag是否能够添加到角色身上"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List<GameplayTagScriptableObject>();\nfor (var i = 0; i < AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List<GameplayTagScriptableObject>();\nfor (var i = 0; i < AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n"}]}]},{"type":"element","tag":"h3","props":{"id":"特效gameplayeffectscriptableobject本身"},"children":[{"type":"text","value":"特效"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameplayEffectScriptableObject"}]},{"type":"text","value":"本身"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameplayEffectDefinitionContainer  定义了特效的使用效果与条件"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DurationPolicy和DurationModifier和DurationMultiplier构成了该特效的持续时间,以及是否立即使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DurationModifier.CalculateMagnitude(this).GetValueOrDefault() *.DurationMultiplier"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modifiers 该特效对属性的修改"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ConditionalGameplayEffects  暂时没看到使用的地方??"}]}]}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"   public struct GameplayEffectDefinitionContainer\n    {\n        /// <summary>\n        /// 持续方案,,是立即,还是持续\n        /// </summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// <summary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// </summary>\n        public float DurationMultiplier;\n\n\n        /// <summary>\n        /// 该特效对属性的修改\n        /// </summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// <summary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// </summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   public struct GameplayEffectDefinitionContainer\n    {\n        /// <summary>\n        /// 持续方案,,是立即,还是持续\n        /// </summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// <summary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// </summary>\n        public float DurationMultiplier;\n\n\n        /// <summary>\n        /// 该特效对属性的修改\n        /// </summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// <summary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// </summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameplayEffectTags   定义处理特效之间的关系"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"   public struct GameplayEffectTags\n   {\n        /// <summary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// </summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// <summary>\n        /// effect添加到人身上前,需要检查的条件\n        /// </summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   public struct GameplayEffectTags\n   {\n        /// <summary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// </summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// <summary>\n        /// effect添加到人身上前,需要检查的条件\n        /// </summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"技能"},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AbstractAbilitySpec是技能的runtime,包含了"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ability的scriptobject"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ability的其他数据例如等级,词条等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色字段"}]}]},{"type":"element","tag":"h3","props":{"id":"技能释放流程"},"children":[{"type":"text","value":"技能释放流程"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ability的cost和cooldown都使用了GameplayEffectScriptableObject,这也是这个系统比较蛋疼的地方,就是每个ability都需要建立cost和cooldown的object."}]},{"type":"element","tag":"h3","props":{"id":"检查cost"},"children":[{"type":"text","value":"检查cost"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查cost特效身上的Modifiers字段,并计算最终值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后和角色属性进行对比"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modifiers可以有多条,且有计算公式"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i < geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue < 0) return false;\n\n        }\n        return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i < geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue < 0) return false;\n\n        }\n        return true;\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"检查cooldow"},"children":[{"type":"text","value":"检查cooldow"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"冷却时间特效最终会被添加到人物的身上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"该函数,主要是比对并找到人身上同tag的特效.然后检查该特效的TotalDuration"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i < this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag < grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag < cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i < this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag < grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag < cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"检查abilitytags"},"children":[{"type":"text","value":"检查abilitytags"}]},{"type":"element","tag":"h4","props":{"id":"abilitytags"},"children":[{"type":"text","value":"abilitytags"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义了一些tag用来释放前进行检查是否能释放该技能"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"例如检查自身是否能够匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OwnerTags"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果是指定目标则检查目标身上是否能够匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TargetTags"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SourceTags?暂时没有好的理解"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"[Serializable]\npublic struct AbilityTags\n{\n    /// <summary>\n    /// This tag describes the Gameplay Ability\n    /// </summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// <summary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// <summary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// <summary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Serializable]\npublic struct AbilityTags\n{\n    /// <summary>\n    /// This tag describes the Gameplay Ability\n    /// </summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// <summary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// <summary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// <summary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"checkgameplaytags被定义在每个ability下然后对其重写"},"children":[{"type":"text","value":"CheckGameplayTags()被定义在每个ability下然后对其重写"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AscHasAllTags  用来检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RequireTags"}]},{"type":"text","value":" ,检查人身上特效的tags是否包含这些,如果没有包含则检查失败"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AscHasNoneTags 用来检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IgnoreTags"}]},{"type":"text","value":" ,检查人身上特效的tags是否包含这些,如果包含则检查失败"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"特效","depth":2,"text":"特效","children":[{"id":"添加特效到角色","depth":3,"text":"添加特效到角色"},{"id":"特效gameplayeffectscriptableobject本身","depth":3,"text":"特效GameplayEffectScriptableObject本身"}]},{"id":"技能","depth":2,"text":"技能","children":[{"id":"技能释放流程","depth":3,"text":"技能释放流程"},{"id":"检查cost","depth":3,"text":"检查cost"},{"id":"检查cooldow","depth":3,"text":"检查cooldow"},{"id":"检查abilitytags","depth":3,"text":"检查abilitytags"}]}]}},"_type":"markdown","_id":"content:game:2021-12-14-untiy-gameplay-ablility-sourcecode.md","_source":"content","_file":"game/2021-12-14-untiy-gameplay-ablility-sourcecode.md","_extension":"md","date":"2021-12-14"},{"_path":"/game/2021-12-21-gyj-skill","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"苟与剑游戏技能分析","description":"释放前检查Tag常用tag写死,比如眩晕等自定义tag,通过判断AscHasAllTags 和AscHasNoneTags 技能是否能够执行检查释放消耗检查冷却时间检查其他自定义条件是否装备指定武器是否变身是否隐身释放后激活阶段animalAction(角色动画)waitAction(等待动作)释放阶段触发释放特效前摇执行阶段释放project其他爆炸物的释放完成阶段后摇角色动画攻击动作投射物子弹弹幕攻击特效其他动作角色动作等待时间\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技能说明动作跳跃攻击跳跃离开危险或跳入战斗之中跳跃动画,并且使用抛物线落到指定点的一个特殊动作旋风旋转的死亡之舞","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"释放前"},"children":[{"type":"text","value":"释放前"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查Tag"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"常用tag写死,比如眩晕等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"自定义tag,通过判断"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AscHasAllTags"}]},{"type":"text","value":" 和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AscHasNoneTags"}]},{"type":"text","value":" 技能是否能够执行"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查释放消耗"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查冷却时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查其他自定义条件"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否装备指定武器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否变身"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否隐身"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"释放后"},"children":[{"type":"text","value":"释放后"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"激活阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"animalAction(角色动画)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"waitAction(等待动作)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"释放阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"触发释放特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前摇"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"释放project"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其他爆炸物的释放"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"完成阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"后摇角色动画"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"攻击动作"},"children":[{"type":"text","value":"攻击动作"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"投射物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子弹"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"弹幕攻击"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"特效"}]}]},{"type":"element","tag":"h3","props":{"id":"其他动作"},"children":[{"type":"text","value":"其他动作"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色动作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"等待时间"}]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"动作"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"跳跃攻击"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"跳跃离开危险或跳入战斗之中"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"跳跃动画,并且使用抛物线落到指定点的一个特殊动作"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"旋风"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"旋转的死亡之舞挥砍所有在旋转路径上的敌人"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"旋转动画并且移动的一个特殊动作"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"双手挥击"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"当装备两把武器时可在一次攻击中击中两个敌人或者攻击一个敌人两次"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"检查附近敌人是否多个,是多个则击中两个,不然击中一个两次.特殊动作"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"特效"},"children":[{"type":"text","value":"特效"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"释放特效(不需要碰撞触发的特效)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"全体加血"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤怪物"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"击中特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"击杀特效"}]}]},{"type":"element","tag":"h3","props":{"id":"特效动作"},"children":[{"type":"text","value":"特效动作"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"伤害"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"伤害类型 毒,冰冻,火焰"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"自己附加状态 附加属性(力量,智力),附加伤害,附加伤害百分比,附加暴击等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"敌人附加状态 扣除属性等"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤object"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤物的属性"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"案例"},"children":[{"type":"text","value":"案例"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"特效1"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"特效2"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"重击"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"强力打击增加造成的伤害并震退敌人"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"伤害特效(附加伤害,附加伤害百分比)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"击退特效"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"击晕"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"成功的攻击将使敌人晕眩并提高你的命中率"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"普通伤害"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"击晕特效,有一定的时间"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"狂暴"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"威力强大但不计后果的攻击可以增加伤害和命中率但忽视防御"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"伤害特效(提高属性)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"降低自身防御为0有一定的时间"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"大叫"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"警告队友迫近的危险并提升他们的防御力"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加防御 有一定的时间"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h3","props":{"id":"技能词条skillterm"},"children":[{"type":"text","value":"技能词条(skillterm)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能根据等级分为入门,小成,大成,巅峰,圆满,每个等级可以解锁额外的词条"}]},{"type":"element","tag":"h2","props":{"id":"tag"},"children":[{"type":"text","value":"TAG"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个特效可以授予角色tag"}]},{"type":"element","tag":"h2","props":{"id":"武器技能"},"children":[{"type":"text","value":"武器技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决攻击使用什么技能,且装备的打造问题..武器可有技能\n武器决定了有哪些技能,比如火系弓箭技能..\n武器没有等级概念???"}]},{"type":"element","tag":"h2","props":{"id":"如果不同的职业技能都能升级到20级那就没有职业差异化了儒家也可用20级道家的技能这样是不对的"},"children":[{"type":"text","value":"如果不同的职业技能都能升级到20级.那就没有职业差异化了,儒家,也可用20级道家的技能.这样是不对的"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"方法一,等级提升添加境界限制.."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"方法二, 技能书分为初级,中级,上级,顶级..然后境界限制学习的条件..书的等级限制能炼到的等级  ...略麻烦"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"升级可以解锁"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一条额外属性..."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个招式"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"洗练可以修改额外属性.以及招式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将qe的提示改成左右键,并去除????"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-21-gyj-skill/2021-12-23-19-03-23%E6%89%93%E5%88%86%E6%89%93%E6%9B%B4%E4%BA%BA%E5%93%81%E7%BA%A7.jpg"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"释放前","depth":2,"text":"释放前"},{"id":"释放后","depth":2,"text":"释放后","children":[{"id":"攻击动作","depth":3,"text":"攻击动作"},{"id":"其他动作","depth":3,"text":"其他动作"}]},{"id":"特效","depth":2,"text":"特效","children":[{"id":"特效动作","depth":3,"text":"特效动作"},{"id":"案例","depth":3,"text":"案例"},{"id":"技能词条skillterm","depth":3,"text":"技能词条(skillterm)"}]},{"id":"tag","depth":2,"text":"TAG"},{"id":"武器技能","depth":2,"text":"武器技能"},{"id":"如果不同的职业技能都能升级到20级那就没有职业差异化了儒家也可用20级道家的技能这样是不对的","depth":2,"text":"如果不同的职业技能都能升级到20级.那就没有职业差异化了,儒家,也可用20级道家的技能.这样是不对的"}]}},"_type":"markdown","_id":"content:game:2021-12-21-gyj-skill.md","_source":"content","_file":"game/2021-12-21-gyj-skill.md","_extension":"md","date":"2021-12-21"},{"_path":"/game/2022-02-19-quest-machine","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"quest machine 使用相关","description":"autostart  自动开始信息offer 发放任务时显示的信息states   任务开始时,结束时等各种状态时显示的信息..设置状态时执行其中的actionlist ,nodes  会有各个节点,他也会有各种显示的信息,会同states中的信息一起显示到各个位置Counter  定义计数的方式和存储计数的值,  但是不定义任务的目标值,目标值在节点中定义npc任务指示的显示?进入地图后.拉取该地图所有npc的任务然后实例化任务则进行开始检查是否自动开始?如果条件满足直接触发任务,添加到玩家任务列表,或者发送邮件提示之类的是否有接取条件,如果有的话检查是否变成可接状态QuestIndicat","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"autostart  自动开始信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"offer 发放任务时显示的信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"states   任务开始时,结束时等各种状态时显示的信息..设置状态时执行其中的actionlist ,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"nodes  会有各个节点,他也会有各种显示的信息,会同states中的信息一起显示到各个位置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Counter  定义计数的方式和存储计数的值,  但是不定义任务的目标值,目标值在节点中定义"}]}]},{"type":"element","tag":"h4","props":{"id":"npc任务指示的显示"},"children":[{"type":"text","value":"npc任务指示的显示?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"进入地图后.拉取该地图所有npc的任务"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后实例化任务"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"则进行开始检查"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否自动开始?如果条件满足直接触发任务,添加到玩家任务列表,或者发送邮件提示之类的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否有接取条件,如果有的话检查是否变成可接状态"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"QuestIndicatorManager不是单例相当于控制器.每个npc身上都有,主要是控制npc的指示显示"}]},{"type":"element","tag":"h2","props":{"id":"任务接受流程"},"children":[{"type":"text","value":"任务接受流程"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"组件Targetable中执行Interact(),会触发QuestGiver.StartDialogueWithPlayer"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"打开对话框"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"QuestGiver.GiveQuestToQuester"}]},{"type":"element","tag":"h2","props":{"id":"任务分类"},"children":[{"type":"text","value":"任务分类"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MoveTo型任务（移动）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"触发剧情"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"新功能开放"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Farm型任务（重复）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"杀狼,动物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"搜集特殊物品,怪物掉落或者采集物品的时候偶尔采集到"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"木材采集,钓鱼,制作料理"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地图内找寻物品,地图内传话,送礼物,酒"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"追杀人物(地图内,地图外)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"杀人(地图内,地图外)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"镖局任务,跨地图送货,送信"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Collect型任务（收集）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"收集包(星露谷)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"图书馆(星露谷)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"藏经阁"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt型任务（狩猎）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Boss"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Puzzle型任务（解谜）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Challenge型任务（挑战）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"暗黑3 大秘境 xxx层"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"附加类：Storytelling型任务（叙事）"}]}]}]},{"type":"element","tag":"h2","props":{"id":"显示"},"children":[{"type":"text","value":"显示"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对话"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一条随机话语"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有任务,任务按钮"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有对话,显示对话按钮"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"更多"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"任务接受流程","depth":2,"text":"任务接受流程"},{"id":"任务分类","depth":2,"text":"任务分类"},{"id":"显示","depth":2,"text":"显示"}]}},"_type":"markdown","_id":"content:game:2022-02-19-quest-machine.md","_source":"content","_file":"game/2022-02-19-quest-machine.md","_extension":"md","date":"2022-02-19"},{"_path":"/game/2022-03-16-gyj-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"苟与剑中的单位生成方式","description":"npc生成方式默认的npc会存储必要数据,比如状态,位置等MapNPCSystem中从npcproxy加载数据,位置一般是固定的,从land中读取运行时的npc会存储MapNPCSystem中从npcproxy加载数据,根据land或者house,随机位置怪物不存储加载land后,则会转换SpawnerAuthoring进行转换生成的点,然后进行生成只运行AI的npcNPCProxy初始化的时候加载,影响局势的(君主,帮派)和与角色由关系的npc处理ai事件.如果进入地图.则实例化场景资源会存储SurvivalStorageSystem创建的时候,则会根据地图id从map_id.bin中加载数","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"npc生成方式"},"children":[{"type":"text","value":"npc生成方式"}]},{"type":"element","tag":"h3","props":{"id":"默认的npc"},"children":[{"type":"text","value":"默认的npc"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储必要数据,比如状态,位置等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MapNPCSystem"}]},{"type":"text","value":"中从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npcproxy"}]},{"type":"text","value":"加载数据,位置一般是固定的,从land中读取"}]}]},{"type":"element","tag":"h3","props":{"id":"运行时的npc"},"children":[{"type":"text","value":"运行时的npc"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MapNPCSystem"}]},{"type":"text","value":"中从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npcproxy"}]},{"type":"text","value":"加载数据,根据land或者house,随机位置"}]}]},{"type":"element","tag":"h3","props":{"id":"怪物"},"children":[{"type":"text","value":"怪物"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加载land后,则会转换"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SpawnerAuthoring"}]},{"type":"text","value":"进行转换生成的点,然后进行生成"}]}]},{"type":"element","tag":"h3","props":{"id":"只运行ai的npc"},"children":[{"type":"text","value":"只运行AI的npc"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NPCProxy"}]},{"type":"text","value":"初始化的时候加载,影响局势的(君主,帮派)和与角色由关系的npc"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"处理ai事件.如果进入地图.则实例化"}]}]},{"type":"element","tag":"h2","props":{"id":"场景资源"},"children":[{"type":"text","value":"场景资源"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SurvivalStorageSystem"}]},{"type":"text","value":"创建的时候,则会根据地图id从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"map_id.bin"}]},{"type":"text","value":"中加载数据"}]}]},{"type":"element","tag":"h2","props":{"id":"用户物品"},"children":[{"type":"text","value":"用户物品"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SurvivalStorageSystem"}]},{"type":"text","value":"创建的时候,则会根据地图id从CharacterSpaceProxy中加载用户数据"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"npc生成方式","depth":2,"text":"npc生成方式","children":[{"id":"默认的npc","depth":3,"text":"默认的npc"},{"id":"运行时的npc","depth":3,"text":"运行时的npc"},{"id":"怪物","depth":3,"text":"怪物"},{"id":"只运行ai的npc","depth":3,"text":"只运行AI的npc"}]},{"id":"场景资源","depth":2,"text":"场景资源"},{"id":"用户物品","depth":2,"text":"用户物品"}]}},"_type":"markdown","_id":"content:game:2022-03-16-gyj-map.md","_source":"content","_file":"game/2022-03-16-gyj-map.md","_extension":"md","date":"2022-03-16"},{"_path":"/game/2022-08-03-ecs","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"ecs中实体创建方法","description":"代码中创建实体,然后绑定view在link的时候,创建相关实体SpaceWaterList.cs中,这种注意创建的实体和parent没有关系..如果是在land中,需要在销毁land的时候,同时销毁该实体.则不能使用该方法..public void Link(World world, Entity entity, params object[] list)\n{\n    for (int i = 0; i < this.Spawners.Count; i++)\n    {\n        var waterEntity = world.EntityManager.CreateEntity();\n","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"代码中创建实体然后绑定view"},"children":[{"type":"text","value":"代码中创建实体,然后绑定view"}]},{"type":"element","tag":"h2","props":{"id":"在link的时候创建相关实体"},"children":[{"type":"text","value":"在link的时候,创建相关实体"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SpaceWaterList.cs中,这种注意创建的实体和parent没有关系..如果是在land中,需要在销毁land的时候,同时销毁该实体.则不能使用该方法.."}]}]},{"type":"element","tag":"pre","props":{"code":"public void Link(World world, Entity entity, params object[] list)\n{\n    for (int i = 0; i < this.Spawners.Count; i++)\n    {\n        var waterEntity = world.EntityManager.CreateEntity();\n\n        world.EntityManager.AddComponentObject(waterEntity,this.Spawners[i]); \n\n        this.Spawners[i].gameObject.Link(world, waterEntity, entity);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Link(World world, Entity entity, params object[] list)\n{\n    for (int i = 0; i < this.Spawners.Count; i++)\n    {\n        var waterEntity = world.EntityManager.CreateEntity();\n\n        world.EntityManager.AddComponentObject(waterEntity,this.Spawners[i]); \n\n        this.Spawners[i].gameObject.Link(world, waterEntity, entity);\n    }\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SpaceNPCList.cs中,通过ConverEntitys.ConvertGameObejct对游戏对象进行转换..注意其上的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"组件转换目标设置为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"none"}]},{"type":"text","value":" ,在这里"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SpawnerAuthoring"}]},{"type":"text","value":" 可以继承"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DeclareParentBehaviour"}]},{"type":"text","value":" 就可以设置parent."}]}]},{"type":"element","tag":"pre","props":{"code":"    public List<SpawnerAuthoring> Spawners = new List<SpawnerAuthoring>();\n    \n    public void Link(World world, Entity entity, params object[] list)\n    {\n        foreach (var item in this.Spawners)\n        {\n            ConverEntitys.ConvertGameObejct(world, item.gameObject, entity);\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public List<SpawnerAuthoring> Spawners = new List<SpawnerAuthoring>();\n    \n    public void Link(World world, Entity entity, params object[] list)\n    {\n        foreach (var item in this.Spawners)\n        {\n            ConverEntitys.ConvertGameObejct(world, item.gameObject, entity);\n        }\n    }\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"代码中创建实体然后绑定view","depth":2,"text":"代码中创建实体,然后绑定view"},{"id":"在link的时候创建相关实体","depth":2,"text":"在link的时候,创建相关实体"}]}},"_type":"markdown","_id":"content:game:2022-08-03-ecs.md","_source":"content","_file":"game/2022-08-03-ecs.md","_extension":"md","date":"2022-08-03"},{"_path":"/game/2022-08-05-dia2","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"暗黑2怪物等级和掉落规则","description":"怪物等级在普通难度上，怪物的等级由怪物的种类决定，不受场景等级的制约。在噩梦和地狱的难度中，怪物的等级由场景等级决定。普通怪物的等级为场景等级，场景的蓝色精英怪物等级为场景等级加2，金色怪物等级为场景等级加3.例如:85级的场景中会出现普通怪物85级、boss怪物87级、精英金怪兽88级3种等级的怪物关底boss等级固定，与场景等级无太大关系。怪物的分类要研究暗黑2的物品掉落系统，首先要了解暗黑世界中的怪物。暗黑中怪物分为如下几个种类等级：\n1.（eBoss）：中文中我们一般称之为.【关底BOSS】，如安达里尔、督瑞尔、墨菲斯托等\n2.（Boss）：即【普通BOSS】，这些怪物有且仅有6个：\n","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"怪物等级"},"children":[{"type":"text","value":"怪物等级"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在普通难度上，怪物的等级由怪物的种类决定，不受场景等级的制约。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在噩梦和地狱的难度中，怪物的等级由场景等级决定。普通怪物的等级为场景等级，场景的蓝色精英怪物等级为场景等级加2，金色怪物等级为场景等级加3.例如:85级的场景中会出现普通怪物85级、boss怪物87级、精英金怪兽88级3种等级的怪物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"关底boss等级固定"}]},{"type":"text","value":"，与场景等级无太大关系。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765901000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765913000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765924000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765933000.png"},"children":[]}]}]},{"type":"element","tag":"h3","props":{"id":"怪物的分类"},"children":[{"type":"text","value":"怪物的分类"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要研究暗黑2的物品掉落系统，首先要了解暗黑世界中的怪物。暗黑中怪物分为如下几个种类等级："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n1.（eBoss）：中文中我们一般称之为.【关底BOSS】，如安达里尔、督瑞尔、墨菲斯托等"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n2.（Boss）：即【普通BOSS】，这些怪物有且仅有6个："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n☆血乌 格里斯瓦得 罗达门特 召唤者 衣卒尔 尼拉塞克"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n3.（Unique）：中文中我们一般称之为【精英怪】，游戏中表现为其名字为暗金色。分为固定精英怪（Super Unique）和随机精英怪（Random Unique）。固定精英怪拥有固定的名字和固定的出现地点，拥有固定属性以及可能出现的随机属性。如“毕须博须”、“暴躁外皮”等。随机精英怪则是在游戏中随机出现，名字由词缀“XXX之XXX的”的随机构成，并随机获得一些特殊属性。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n4.（Minion）：中文中我们称之为【随从】，即精英怪身边的与其同类的喽啰怪物。在游戏中外观和普通怪一样，但隐藏有带领它的精英怪的部分特殊属性。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n5.（Champion）：中文中我们称之为【头目】。游戏中表现为其名字为蓝色。有时候它们能从其名字的前缀（如果有的话）中获得特殊属性。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n6.（Normal）：普通小怪。游戏中表现为其名字为白色。"}]},{"type":"element","tag":"h3","props":{"id":"财宝阶层"},"children":[{"type":"text","value":"财宝阶层"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TC是一个包含了众多物品清单的多层目录，一个大TC目录中可能包含有多个子TC目录。 怪物死亡后掉落的物品就是从其TC目录的物品清单中按照一定规则随机取出物品。\n但我们玩家在日常口头交流时，常常只讨论武器和防具的掉落，并将TC目录简化为一个数字等级，简称为怪物的TC。比如我们常说的墨菲斯托的TC=78，暴躁外皮的TC=87等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"☆TC由3到87，按3递增（3、6、9…81、84、87），共有29个递增的TC阶层。"}]},{"type":"element","tag":"h2","props":{"id":"掉落规则"},"children":[{"type":"text","value":"掉落规则"}]},{"type":"element","tag":"h3","props":{"id":"物品等级"},"children":[{"type":"text","value":"物品等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"物品等级常用术语为ilvl，注意这个等级不是使用装备需要的等级，而是一个内在的等级数据，一定程度上决定了装备可能的质量。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"打怪掉落  打怪刷到的装备等级=掉装备怪物的等级"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"翻箱子掉落 开箱子掉落的装备等级=场景等级"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在NPC那里买到 商店买的装备等级=人物等级+5"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在NPC那里通过赌博得到  赌博得的装备等级=人物等级+4或-5"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**物品等级最大99。**物品等级最大的作用有两个："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"决定了该物品的最大出孔数,比如，同样是灰幕寿衣，如果是25级以下怪物掉落的，它的物品等级就是25以下，它最大的打孔数就是3孔；如果是高于25级怪物掉落的，它的物品等级也就高于25，这件衣服最大孔数就是4孔。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物品等级决定了装备的词缀，物品等级越高，可能出现的词缀就越好。"}]}]},{"type":"element","tag":"h3","props":{"id":"词缀等级"},"children":[{"type":"text","value":"词缀等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"物品的属性来源于物品所具有的词缀。游戏中每一种词缀都代表了某一种特定的属性，一旦物品拥有了某个词缀，那么就一定具有这个词缀所代表的属性。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n所有的词缀总共分为2类：前缀和后缀。前缀和后缀又分别按照所代表属性的不同分成组。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767663000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如图中的绿框内是前缀，红框内是后缀，它们对应下面蓝色字体的“属性”，珠宝匠对应4孔，偏向对应格档速度和格档机率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"词缀种类非常多，蓝色装备最多可以从词缀中选择不同的两个，黄色最多选择6个。而不同词缀又是有不同等级的，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"高等级词缀当然只能出现在物品等级和品质等级更高的装备上。"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n前缀共分为三个系26个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第一系是进攻型前缀共计14小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号110组加准确率；编号105组增强伤害；编号111组同时加准确和伤害 或者 按等级加准确；编号123组加对恶魔的准确和伤害；编号142组加对不死的准确和伤害；编号137组加冰伤害；编号138组加火伤害；编号139组加电伤害；编号140组加毒伤害；编号113组吓跑怪物；编号121组杀死敌人加法力；编号107组所受伤害转为法力；编号114组加mf；编号112组加照亮范围"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第二系是防御型前缀共计11小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号117组加抗冰；编号118组加抗火；编号119组加抗电；编号120组加抗毒；编号116组加全抗；编号115组加法力；编号101组加防御；编号108组加耐力；编号109组按百分比加耐力；编号122组增加凹槽；编号141组增加投掷物数量；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第三系是技能前缀有1个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号125小组：加人物技能；加亚马逊单系技能；加野蛮人单系技能；加圣骑士单系技能；加死灵法师单系技能；加法师单系技能；加德鲁伊单系技能；加刺客单系技能；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n后缀共分为四个系35个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第一系是进攻型后缀共计16小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号15组加最小伤害值；编号14组加最大伤害值；编号10组加冰伤害；编号12组加火伤害；编号13组加电伤害；编号16组加毒伤害；编号27组偷取生命；编号28组偷取法力；编号24组；编号20组阻止怪物；编号4组忽略目标防御；编号7组加攻击速度；编号9组加施法速度；编号21组加额外金币；编号22组加mf；编号25组同时加照亮范围和准确；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第二系是防御型后缀共计11小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号1组物理伤害减少；编号2组魔法伤害减少；编号29组减少中毒时间；编号11组冰冻时间减半；编号35组加快速奔跑；编号18组加快速打击恢复；编号8组加格挡；编号6组反弹伤害；编号39组投掷物恢复数量；编号37组装备自动修复；编号39组永不磨损"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第三系是技能后缀有1个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号44组：加亚马逊单个技能(包括聚气)；加野蛮人单个技能(包括聚气)；加德鲁伊单个技能(包括聚气)；加死灵法师单个技能(包括聚气)；加圣骑士单个技能(包括聚气)；加法师单个技能(包括聚气)；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第四系是属性后缀共计7个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号31组加力量；编号17组加敏捷；编号23组加能量；编号41组按等级加法力、按等级加生命或按等级同时加法力和生命(仅限蓝色装备)；编号26组加生命；编号19组自动恢复生命；编号30组减需求；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"当装备从怪物身上掉落时，或是当人物离开城镇导致商店里的商品更新时，或是当人物把物品从商人那里买下来时，或是当你用赫拉迪克方块合成新的物品时，物品的属性就在那一瞬间随机生成了。生成时系统将会随机挑选一些词缀安排给这个物品，于是物品就有了变化莫测的属性"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"取最高 qlvl or ilvl 为X 当｛ X < (99-Q/2) ｝时，则该物品是低等物品,词缀等级（A）按照  { A = X - Q/2 } 计算词缀等级。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767006000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子：我有一件地狱A1冰冷之原掉的装备，由于它是68场景等级（M），所以怪物是68-71级之间，掉落的装备就是68级-71级物等。比如按最低的68白怪掉的一个战帽，他的品质等级（Q）是34级，那么，带入公式 68 < [ (99-34/2) = 82 ]，满足公式一。词缀等级按照 {A= 68 - 34/2 = 51}计算，他的词缀就是51级。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当｛ X > (99-Q/2) ｝时则是高等物品 按照 {A=2*X-99} 计算词缀等级。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767121000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子：超市金怪出了一个君主盾（统盾），85+3，物等（I）88级，大于品质（Q）72级，带入公式 { A=2*88-99 } = 77级词缀等级（A）"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"以上情况之外，还有一种特殊情况，游戏内有7种自带 “魔法等级” （ML）的物品，按照 A= X + ML 计算"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767156000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子：3c瘸子掉了一个头环，他的最低物等（I）至少是82级。他的魔法等级是3，那么公式计算，他的词缀等级应该是 A = 82 + 3，85级。那么问题来了，他会鉴定出+2职业技能么？答案是，不能。 因为+2全技能的词缀是90级的。"}]},{"type":"element","tag":"pre","props":{"code":"var x = math.max(qlvl,ilvl);\nfloat result;\n\nif(mlvl == 0)\n{\n    if( x > 99-(qlvl/2))\n    {\n        result = 2*x - 99; \n    }\n    else\n    {\n        result = x - qlvl/2\n    }\n}\nelse\n{\n    result = x +i.mlvl;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var x = math.max(qlvl,ilvl);\nfloat result;\n\nif(mlvl == 0)\n{\n    if( x > 99-(qlvl/2))\n    {\n        result = 2*x - 99; \n    }\n    else\n    {\n        result = x - qlvl/2\n    }\n}\nelse\n{\n    result = x +i.mlvl;\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"品质等级"},"children":[{"type":"text","value":"品质等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"品质等级（qlvl）："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"每个装备固有的一个品质等级"}]},{"type":"text","value":"，对于非绿色非暗金装备，qlvl和其底材一样，比如一件执政官铠甲，无论是蓝色还是黄色，其qlvl都是84。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"品质等级是玩家无法左右的，但是需要了解。因为它会与财宝等级（TC）一起决定掉落的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"品质等级决定具体是哪件装备（是镰刀还是执政官甲）；"}]}]},{"type":"element","tag":"h3","props":{"id":"财富等级"},"children":[{"type":"text","value":"财富等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"财宝等级决定物品的品质等级"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怪物是否能掉落对应装备必须满足两个条件："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"怪物的“财宝等级”（TC）大于或等于装备所在的“财宝等级”（TC），"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同时怪物自身的等级要大于或等于装备自身的“品质等级”（qlvl）。"}]}]},{"type":"element","tag":"h3","props":{"id":"底材"},"children":[{"type":"text","value":"底材"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我们要提前介绍“底材”这个概念。其实在之前的内容已经提到过很多次“底材”，不过基本上都局限于制作符文之语的白色物品。但严格地说，“底材”实际上是所有魔法装备的衍生基础。你可以简单地理解为，一件白色的“军帽”经过“上色”变成了带有1-2条额外属性的蓝色“军帽”，或者经过另一种“上色”就变成了暗金物品“谐角之冠”，但他们的底材都是“军帽”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而底材也分为了普通级、扩展级和精英级三类，三类底材拥有同样的模型，后一级比前一级的基础属性更高，“军帽”就属于“精英级”底材："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1635230129413.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同一底材的暗金/绿色物品还会有自己的专属qlvl，一般叫做“成品qlvl”，如果我们打到了一个白色“军帽”，那它的qlvl显然就是58，而暗金军帽“谐角之冠”还会有自己专属的成品qlvl：69(见上上图的左下角)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659770992000.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"掉落机制"},"children":[{"type":"text","value":"掉落机制"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"怪物会掉落特定的物品么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不,不过金色怪物和头目会有更高的概率掉落魔法物品,头目会掉落魔法物品或更多的黄金.不过,怪物的种类与掉落的物品没有关系."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"人物的等级与掉落的物品有关么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不,掉落的物品只与怪物等级与场景等级有关."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"锁住的箱子会掉更好的东西么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不,但它会掉出更多的东西,一般来说是没上锁的两倍."}]},{"type":"element","tag":"h4","props":{"id":"掉落过程"},"children":[{"type":"text","value":"掉落过程"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"底材判定过程（TC判定过程）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n怪物的TC值代表了怪物能掉落的物品底材的最高Qlvl。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n☆也就是说，当怪物TC ≥ 物品底材Qlvl时，则怪物能掉落该物品底材。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"成色判定过程（Mlvl判定过程）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n确定了物品的底材后，系统将按照暗金 - 绿色 - 黄色 - 蓝色 - 白色的顺序来判定成色。当判定为暗金或者绿色时，系统会检查怪物等级是否满足物品的成品Qlvl。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n如果物品成色被判定为暗金，而怪物等级Mlvl不足以掉落该物品的暗金形态或者该物品暗金形态不存在，则会掉落该物品的黄色形态并拥有3倍的耐久度；如果物品成色被判定为绿色，而怪物等级Mlvl不足以掉落该物品的绿色形态或者该物品绿色形态不存在，则会掉落该物品的蓝色形态并拥有2倍的耐久度。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"☆ 也就是说，当怪物等级Qlvl≥物品成品Qlvl时，怪物才能掉落该物品的暗金/绿色形态。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n☆ MF值会分别增加暗金、绿色、黄色、蓝色判定的几率，但不影响超强、普通、劣质的判定。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们回过头来看看“谐角之冠”的掉落过程："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、击杀怪物A，假设它的财宝等级(TC)为59，怪物等级(mlvl)为65，那么就可以掉落qlvl为58的底材“军帽”(因为此时TC>底材qlvl)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、MF值开始介入(在这之前TC表还有一系列的pick过程，较为复杂，暂不介绍)，游戏进入“暗金 - 绿色 - 黄色 - 蓝色 - 白色”的掉落判定顺序，假设此时可以掉落该底材的暗金品质装备“谐角之冠”，但是由于怪物等级mlvl 65<“谐角之冠”的成品qlvl 69，则无法掉落，改为掉落黄色品质的“军帽”，且具有3倍耐久度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、如果怪物B的TC为57，那么根本不会掉落底材“军帽”，后续的“上色”流程无从谈起。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、如果怪物C的TC为67，mlvl为70，其余流程与前面一致，那么可以成功掉落“谐角之冠”。(因为TC>底材qlvl，可以进入掉落判定阶段，当判定为“谐角之冠”时，检查怪物mlvl>“谐角之冠”的成品qlvl，符合要求)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前面已经提到过，MF只和“上色”有关，无法影响装备的品质等级qlvl，所以就算是把MF堆到10000，你在普通难度下也无法获得“统治者大盾”。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"怪物等级","depth":2,"text":"怪物等级","children":[{"id":"怪物的分类","depth":3,"text":"怪物的分类"},{"id":"财宝阶层","depth":3,"text":"财宝阶层"}]},{"id":"掉落规则","depth":2,"text":"掉落规则","children":[{"id":"物品等级","depth":3,"text":"物品等级"},{"id":"词缀等级","depth":3,"text":"词缀等级"},{"id":"品质等级","depth":3,"text":"品质等级"},{"id":"财富等级","depth":3,"text":"财富等级"},{"id":"底材","depth":3,"text":"底材"},{"id":"掉落机制","depth":3,"text":"掉落机制"}]}]}},"_type":"markdown","_id":"content:game:2022-08-05-dia2.md","_source":"content","_file":"game/2022-08-05-dia2.md","_extension":"md","date":"2022-08-05"},{"_path":"/game/2022-08-21-behavior-tree-source-code","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"行为树源代码解析","description":"行为树的构建首先行为树会有个根节点TaskRoot ,当构建行为树的时候,会将节点添加到该root下行为树的构建如下://获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"行为树的构建"},"children":[{"type":"text","value":"行为树的构建"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先行为树会有个根节点"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskRoot"}]},{"type":"text","value":" ,当构建行为树的时候,会将节点添加到该root下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"行为树的构建如下:"}]},{"type":"element","tag":"pre","props":{"code":"//获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _tree.AddNode(PointerCurrent, node);\n    return this;\n}\n//增加节点,并将该节点设置为当前父节点\npublic BehaviorTreeBuilder AddNodeWithPointer (ITaskParent task) {\n    AddNode(task);\n    _pointers.Add(task);\n    \n    return this;\n}\n//退出当前父节点\npublic BehaviorTreeBuilder End () {\n    _pointers.RemoveAt(_pointers.Count - 1);\n    \n    return this;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _tree.AddNode(PointerCurrent, node);\n    return this;\n}\n//增加节点,并将该节点设置为当前父节点\npublic BehaviorTreeBuilder AddNodeWithPointer (ITaskParent task) {\n    AddNode(task);\n    _pointers.Add(task);\n    \n    return this;\n}\n//退出当前父节点\npublic BehaviorTreeBuilder End () {\n    _pointers.RemoveAt(_pointers.Count - 1);\n    \n    return this;\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"行为树的运行"},"children":[{"type":"text","value":"行为树的运行"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一帧都执行update(),且如果根节点返回的是成功或者失败,则清空所有任务并"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"End()"}]},{"type":"text","value":",累计tick(所有子节点都会执行Reset())"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果子节点中有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"持续"}]},{"type":"text","value":"的任务时,则该任务会被认为时激活的.添加到行为树中"}]}]},{"type":"element","tag":"pre","props":{"code":"public TaskStatus Tick () {\n    var status = Root.Update();\n    if (status != TaskStatus.Continue) {\n        Reset();\n    }\n\n    return status;\n}\n\npublic void Reset () {\n    foreach (var task in _tasks) {\n        task.End();\n    }\n\n    _tasks.Clear();\n    TickCount++;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public TaskStatus Tick () {\n    var status = Root.Update();\n    if (status != TaskStatus.Continue) {\n        Reset();\n    }\n\n    return status;\n}\n\npublic void Reset () {\n    foreach (var task in _tasks) {\n        task.End();\n    }\n\n    _tasks.Clear();\n    TickCount++;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们看看任务的子类有哪些:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskRoot"}]},{"type":"text","value":" 一般来说只有一个子节点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskParentBase"}]},{"type":"text","value":" ,会在每一次循环中同步tick,如果tick和行为树不一样,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":",如果onUpdate()返回的时成功或者失败,也会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskBase"}]},{"type":"text","value":" 会在每一次循环中同步tick,如果tick和行为树不一样,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":",如果GetUpdate()返回的时成功或者失败,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Exit"}]},{"type":"text","value":" (Exit时会Reset)且如果自己的状态曾经为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Continue"}]},{"type":"text","value":"会从行为树的激活任务中移除,否则会将自身添加到行为树的激活任务中."}]}]},{"type":"element","tag":"h3","props":{"id":"持续的任务是怎么运行的"},"children":[{"type":"text","value":"持续的任务是怎么运行的"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;\nRoot --> Sequence;\nSequence-->TaskA;\nSequence-->TaskB;\nSequence-->TaskC;\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;\nRoot --> Sequence;\nSequence-->TaskA;\nSequence-->TaskB;\nSequence-->TaskC;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sequence会记录自己循环过哪些task. 当taskb持续状态时,则会进入下一个循环,但不会进入下一tick,走到Sequence后,他不会执行已经执行过的任务,所以进入Sequence后会直接执行TaskB;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只有当有任务失败或者成功,才会执行下一个tick,下一个tick所有task都会reset"}]},{"type":"element","tag":"h2","props":{"id":"使用"},"children":[{"type":"text","value":"使用"}]},{"type":"element","tag":"h3","props":{"id":"并行"},"children":[{"type":"text","value":"并行"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用.,注意子节点,要么是持续的,要么是成功的..如果有任何失败了将会reset"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"并行需要等待子节点全部完成,再根据子节点的返回状态判断该并行节点的状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"并不是说并行,就是两个不想干的node不断的执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同时执行下面所有子节点的start(),然后等待所有子节点的反馈是成功还是失败"}]}]},{"type":"element","tag":"h3","props":{"id":"序列"},"children":[{"type":"text","value":"序列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般把Sequence-->Condition  当作if  就可以"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;Sequence --> Condition;Sequence --> AC\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;Sequence --> Condition;Sequence --> AC\n"}]}]},{"type":"element","tag":"h3","props":{"id":"选择"},"children":[{"type":"text","value":"选择"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由下图可以看出..Selector --> Sequence--> Condition  相当于if else"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-21-behavior-tree-source-code/1660118886000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把select,当成 if not来看"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;\nSelect -->Condition; Select-->action\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;\nSelect -->Condition; Select-->action\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"select-->Inverter -->Condition  可以当作if来看.."}]},{"type":"element","tag":"pre","props":{"code":"graph TD;select --> inverter-->conditions;select-->action\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;select --> inverter-->conditions;select-->action\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和Sequence的区别就是,select在执行b前返回的是true."}]},{"type":"element","tag":"h3","props":{"id":"观察者模式"},"children":[{"type":"text","value":"观察者模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"观察者装饰器...就是观察某个变量..然后决定低优先级节点,自身节点,的执行(重启等)方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分为两种状况\n1.在当前节点未激活的时候,观察某个变量 生效的方式:Stops.LOWER_PRIORITY,Stops.BOTH,Stops.LOWER_PRIORITY_IMMEDIATE_RESTART,Stops.IMMEDIATE_RESTART\n2.在当前节点激活的时候,观察某个变量Stops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART\n所以会有三种节点出现"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()永远返回true,子节点永远返回false,保证该装饰器节点是inactive状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()永远返回false,子节点永远返回true,保证该装饰器节点是active状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()根据情况返回true和false,比如如果玩家在附近,则执行该装饰器下代码.如果玩家不在附近则stop,执行低优先级代码"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stops.NONE：装饰器只会在启动时检查一次它的状态，并且永远不会停止任何正在运行的节点。\nStops.SELF：装饰器将在启动时检查一次它的条件状态，如果满足，它将继续观察黑板的变化。一旦不再满足该条件，它将终止自身，并让父组合继续处理它的下一个节点。\nStops.LOWER_PRIORITY：装饰器将在启动时检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止比此结点优先级较低的节点，允许父组合继续处理下一个节点\nStops.BOTH：装饰器将同时停止:self和优先级较低的节点。\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启此装饰器。\nStops.IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启装饰器。正如在这两种情况下，一旦不再满足条件，它也将停止自己。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说人话..就是\n在当前节点未激活的时候,观察某个变量\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART和Stops.IMMEDIATE_RESTART这个会停止低优先级(就是该节点后面的)的节点,然后会立即重新开始当前节点\nStops.LOWER_PRIORITY和Stops.BOTH 会先停止优先级较低的节点,然后再停止父节点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在当前节点激活的时候,观察某个变量\nStops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART 这三个,都会先停止子节点.然后停止自身,最后会影响到停止父节点"}]},{"type":"element","tag":"h3","props":{"id":"条件和装饰器"},"children":[{"type":"text","value":"条件和装饰器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RepeatUntilSuccess --> ConditionBase 可以构成一个新动作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConditionBase 在返回失败的时候被RepeatUntilSuccess 转换为持续"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"行为树的构建","depth":2,"text":"行为树的构建"},{"id":"行为树的运行","depth":2,"text":"行为树的运行","children":[{"id":"持续的任务是怎么运行的","depth":3,"text":"持续的任务是怎么运行的"}]},{"id":"使用","depth":2,"text":"使用","children":[{"id":"并行","depth":3,"text":"并行"},{"id":"序列","depth":3,"text":"序列"},{"id":"选择","depth":3,"text":"选择"},{"id":"观察者模式","depth":3,"text":"观察者模式"},{"id":"条件和装饰器","depth":3,"text":"条件和装饰器"}]}]}},"_type":"markdown","_id":"content:game:2022-08-21-behavior-tree-source-code.md","_source":"content","_file":"game/2022-08-21-behavior-tree-source-code.md","_extension":"md","date":"2022-08-21"},{"_path":"/gyj/2022-06-11-meishuyaoqiu","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"美术要求","description":"稿件主要是游戏场景,游戏类型是横版种田的江湖类游戏.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"稿件主要是游戏场景,游戏类型是横版种田的江湖类游戏."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于本人程序出身.对于美术不太了解,以下要求有不当之处,尽请谅解."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于制作内容非那种单张画稿,具体价格计费,双方可再商议."}]},{"type":"element","tag":"h3","props":{"id":"服装"},"children":[{"type":"text","value":"服装"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看下一套衣服是如何组成的,分为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"上衣"}]},{"type":"text","value":"+"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裤子"}]},{"type":"text","value":"+"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裙子"}]},{"type":"text","value":"."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"上衣"}]},{"type":"text","value":"能盖住"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裙子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裙子"}]},{"type":"text","value":"能盖住"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裤子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裙子"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"裤子"}]},{"type":"text","value":"可以同时存在,也可以单独存在"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/2222.png"},"children":[]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%A1%A3%E6%9C%8D%E5%88%B6%E4%BD%9C%E6%A8%A1%E6%9D%BF%E5%9B%BE.psd"},"children":[{"type":"text","value":"点我下载服装制作模板"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"衣服到时候我们一个一个商讨着画"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"修改"},"children":[{"type":"text","value":"修改"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所画"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"树木"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"大小"}]},{"type":"text","value":"请参考之前所画的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"果树"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"树根"}]},{"type":"text","value":"或者说"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"底部"}]},{"type":"text","value":",需要"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"加粗"}]},{"type":"text","value":".占近似一个格子"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"场景制作说明"},"children":[{"type":"text","value":"场景制作说明"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总结,横版常用背景大概有三种:   [点我下载 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/demo.zip)"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多层组合,每层的图片宽高480*96 或者 480*128 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%83%8C%E6%99%AF%E6%BC%94%E7%A4%BA1.psd)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"单背景   图片宽高 864*192 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%83%8C%E6%99%AF%E6%BC%94%E7%A4%BA3.psd)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多层和单背景混合   [点我下载 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%83%8C%E6%99%AF%E6%BC%94%E7%A4%BA2.psd)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于地形,一般画地形的时候都会像下面几种方式设计,仅供参考,不需要一定向下面这样:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675258902000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675264313000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675264565000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675265268000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/main_lev_build.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675298801000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675298817000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"QQ三国"}]},{"type":"text","value":"和彩虹岛的地图都可以参考....................以下的参考图只是表达概念................下面的图都是西方游戏的设计..............画风都不符合国内游戏的感觉........仅作参考"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"矿洞场景   可能包括的其他物品"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"地面"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"矿车"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"矿井架"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"轨道"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"发光的植物"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"矿洞的灯"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1656415110000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675263527000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675263652000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"树林场景 可能包括的其他物品"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"地面"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"灌木丛"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"普通的石头"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"树叶做的绳索(上下)"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"普通的小花"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1656413417000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675261053000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"海滩场景   有大海,"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675260355000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675268015000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675264871000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"江湖场景 ---- 或者有瀑布,或者底部有水,或者背景有水"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1672466507000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675261783000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1672396153000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"山谷场景  ---背景类似这种崖壁或者之类的东西.."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675259941000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"丛林场景  --- 茂密高大的森林背景"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675261301000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675262911000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675263449000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675264082000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"背景为连绵不觉的山,山林中既有矿石,也有树木,也有草药"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"竹林场景--茂密高大的竹林背景"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675264778000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"家园场景"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675261436000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675266818000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1672396107000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1672396142000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"门派场景 --- 背景浮空岛或者是遥远的建筑..或者可以自己想象..没特别的想法."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675260446000.png"},"children":[]},{"type":"text","value":"背景是一些远的建筑之类的"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675268984000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"城市场景---房屋和树的结合..可以拿之前的房屋和树进行组合"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1672396859000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"村庄背景---有田地,有山,有村庄"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675266050000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675260730000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"遗迹(废墟)    这个有点西式..不知道中式的遗迹啥样的"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675258767000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675266980000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"沙漠场景--- 注意植物可能是仙人掌,之类的"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675263893000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675265178000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675267461000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"冰雪场景  注意背景植物可能是松树或者这种桦树"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675263929000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675265191000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地牢(副本)"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675266629000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675266691000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1675267321000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"旅途(奇遇)场景"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当我从一个城市到另一个城市时,会进入该场景,人物会在该场景移动,然后触发一个个事件. 为了便于理解,参看视频 (直接跳到15:20)  "},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/BV1gA411u7ig?p=1","rel":["nofollow"]},"children":[{"type":"text","value":"归家异途2.  "}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"旅途的场景,地图的两边是各自的城门,然后中间就是道路和风景"}]}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一些道具图标以及工具, 服装  (待定)"},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"内容"}]},{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"工具"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"锄头,水壶,镰刀,斧头,矿锄,鱼竿,剪刀,锤子"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"各个等级的"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"种子(图标)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"袋装的种子"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"果实(图标)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"包含变异品"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面等游戏一测做完再做吧."}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"洞窟"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"地形:暗色的砖石,其他物品.可能包括"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"烛台"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"各种箱子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"武器架"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"打开的宝箱未打开的宝箱"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"散落在地的兵刃"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"必要物品"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"功用"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"绳索"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"上下爬动"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"桥"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"玩家可以从上面跳下去,或者作为连续跳的点"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"门"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"机关"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"突起在地面上玩家可以搬箱子放置触发.或者是一个能左右扳动的开关"}]}]}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1656411611000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1656412167000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不同的城市该如何进行区分,不然移动到另一个城市,感觉没啥变化"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"背景的不同    "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"桂林山水"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"大漠孤烟"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"江南水乡"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"雪山之下"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"长城守望"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"不同建筑的城市背景组合"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地面砖块的不同"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"已画建筑的简单变形?????   比如屋顶瓦片的颜色..."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不同城市的装饰树木不同  ?????"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"还有其他?????"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"总共20个城市,需要8-10套,有难度吗"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n参考图,有看到能用的我再补上:"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/1656809454000.png"},"children":[]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"房屋内部  是否要做??"},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"必要建筑"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"功用"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"药店室内:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"药店柜台"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"药店柜子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"病床"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"以下随意画.画不出也没关系,本来不打算房间能进的,主要是为了丰富游戏多样性"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"酒店室内:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"酒店柜台"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"桌子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"凳子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"其他装饰品"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"客栈室内: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"床"}]},{"type":"text","value":"."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"桌子"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"凳子"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"杂货店内:"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"礼品店"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"养殖店"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"种植店"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"商行"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"镖局"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"铁匠铺"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"书院"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"赌场"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"衙门"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"大牢"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"普通民居"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"随意画点东西吧,画不出也没关系"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"一些室内参考图:"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20001.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20003.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20007.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20006.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20005.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20004.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E5%9B%BE%E5%83%8F%20002.png"},"children":[]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"服装","depth":3,"text":"服装"},{"id":"修改","depth":2,"text":"修改"},{"id":"场景制作说明","depth":2,"text":"场景制作说明"}]}},"_type":"markdown","_id":"content:gyj:2022-06-11-美术要求.md","_source":"content","_file":"gyj/2022-06-11-美术要求.md","_extension":"md","date":"2022-06-11"},{"_path":"/gyj/2022-06-12-jichuzhishi","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"游戏基础知识","description":"1. 游戏名称苟与剑我有一块地存档每天晚上睡觉会自动存档体力的回复体力会随着使用道具和工具等减少,体力为0后不能继续工作\n雨雪天气再室外使用道具:每次使用+1\n下午10:00-12:00使用道具:每次使用+2\n晚上0:00-6:00 使用道具:每次使用+4\n6:00 未入睡,第二天增加buff,每次使用+3主要回复方法:睡觉 回复30点+睡眠事件*每小时7点,睡的越多回复的越多吃东西 回复量因物品而异泡温泉 每分钟回复体力1点再旅馆吃饭装备女神的秘宝 每分钟回复体力1点增加体力总值:体力果实:增加15点耕地有1.2%几率出现一次向女神献上贡品10次.将物品扔进女神之泉即可春季或秋季赛马获胜采矿","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"_1-游戏名称"},"children":[{"type":"text","value":"1. 游戏名称"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"苟与剑"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"我有一块地"}]}]},{"type":"element","tag":"h2","props":{"id":"存档"},"children":[{"type":"text","value":"存档"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每天晚上睡觉会自动存档"}]},{"type":"element","tag":"h2","props":{"id":"体力的回复"},"children":[{"type":"text","value":"体力的回复"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"体力会随着使用道具和工具等减少,体力为0后不能继续工作\n雨雪天气再室外使用道具:每次使用+1\n下午10:00-12:00使用道具:每次使用+2\n晚上0:00-6:00 使用道具:每次使用+4\n6:00 未入睡,第二天增加buff,每次使用+3"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"主要回复方法:"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"睡觉 回复30点+睡眠事件*每小时7点,睡的越多回复的越多"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"吃东西 回复量因物品而异"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"泡温泉 每分钟回复体力1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"再旅馆吃饭"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"装备女神的秘宝 每分钟回复体力1点"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"增加体力总值:"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"体力果实:增加15点"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"耕地有1.2%几率出现一次"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"向女神献上贡品10次.将物品扔进女神之泉即可"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"春季或秋季赛马获胜"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采矿场100层锄地,有19.5%概率出现"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"杂货店花费10000g购买"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"冬天,在海边钓鱼1%概率获取"}]}]},{"type":"element","tag":"h2","props":{"id":"时间与日期"},"children":[{"type":"text","value":"时间与日期"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主角在AM6:00~AM5:59期间可以活动.\n每天6点会触发新的一天的事件"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1-游戏名称","depth":2,"text":"1. 游戏名称"},{"id":"存档","depth":2,"text":"存档"},{"id":"体力的回复","depth":2,"text":"体力的回复"},{"id":"时间与日期","depth":2,"text":"时间与日期"}]}},"_type":"markdown","_id":"content:gyj:2022-06-12-基础知识.md","_source":"content","_file":"gyj/2022-06-12-基础知识.md","_extension":"md","date":"2022-06-12"},{"_path":"/gyj/2022-08-22-detufangjiandezhonglei","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"2022 08 22 地图房间的种类","description":"怪物在地图种的类型地牢有很多种美术不同的地图:地牢的地图种类.决定了这个地图里是生成什么类型的怪物生成什么类型的怪物,和城市地块以及城市等级没有关系...怪物在地图中的等级由游戏难度和地图难度决定地图难度越高..怪物等级越高游戏难度决定..比如普通...四级装备就能过九级地牢...而噩梦..九级装备才能过九级地牢","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"怪物在地图种的类型"},"children":[{"type":"text","value":"怪物在地图种的类型"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地牢有很多种美术不同的地图:"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地牢的地图种类.决定了这个地图里是生成什么类型的怪物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生成什么类型的怪物,和城市地块以及城市等级没有关系..."}]}]},{"type":"element","tag":"h2","props":{"id":"怪物在地图中的等级"},"children":[{"type":"text","value":"怪物在地图中的等级"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"由游戏难度和地图难度决定"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地图难度越高..怪物等级越高"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"游戏难度决定..比如普通...四级装备就能过九级地牢...而噩梦..九级装备才能过九级地牢"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"怪物在地图种的类型","depth":2,"text":"怪物在地图种的类型"},{"id":"怪物在地图中的等级","depth":2,"text":"怪物在地图中的等级"}]}},"_type":"markdown","_id":"content:gyj:2022-08-22-地图房间的种类.md","_source":"content","_file":"gyj/2022-08-22-地图房间的种类.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-08-22-qiyushijian","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"2022 08 22 奇遇事件","description":"关于奖惩100次负面效果会有一次极大的正面效果修仙式人生1、前辈拜访：避而不见-少量道德、传功-修为、打架-大量道德2、灵石矿脉：表面挖增加修为、在深处挖一无所得3、仇敌：教训一番声明大涨、好言相劝-战力4、生死搏斗：帮助获得宠物5、锻造师：同意-体魄+战力6、应邀做客：运功调息躲过一劫、怀疑好友-大量心态7、跛足乞丐：治疗腿溃→给他酒+随机属性8、论道大会：旁听论道+悟性、参加论道+名气9、炼妖塔：放出宠物+宠物战斗力10、道侣：与其同游+修为11、天仙下凡：假扮渔贩施舍得丹药12、灵石市场：平平无奇的石料+修为、古怪的石料看人品±修为(大概率-修为)13、白衣公子：详细解答+悟性、高谈阔论","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"关于奖惩"},"children":[{"type":"text","value":"关于奖惩"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"100次负面效果会有一次极大的正面效果"}]},{"type":"element","tag":"h1","props":{"id":"修仙式人生"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"修仙式人生"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、前辈拜访：避而不见-少量道德、传功-修为、打架-大量道德"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、灵石矿脉：表面挖增加修为、在深处挖一无所得"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、仇敌：教训一番声明大涨、好言相劝-战力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、生死搏斗：帮助获得宠物"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5、锻造师：同意-体魄+战力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"6、应邀做客：运功调息躲过一劫、怀疑好友-大量心态"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"7、跛足乞丐：治疗腿溃→给他酒+随机属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"8、论道大会：旁听论道+悟性、参加论道+名气"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"9、炼妖塔：放出宠物+宠物战斗力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"10、道侣：与其同游+修为"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11、天仙下凡：假扮渔贩施舍得丹药"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"12、灵石市场：平平无奇的石料+修为、古怪的石料看人品±修为(大概率-修为)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"13、白衣公子：详细解答+悟性、高谈阔论-名气"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"14、门派大比：下场比武+名气、场外观战+战力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"15、山下来妖：放入炼妖塔"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"16、遗迹：勇闯遗迹→制造临时分身-修为+战力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"17、追债：帮助书生抵债-修为+随机的物品，继续追债则会扣道德"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"18、落难母子：帮被偷东西、拒绝啥都不扣"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"19、子嗣传功：无视不扣属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"20、仙岛：进入深处被打伤-体魄、"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"21、府库失火：继续盘点大概率啥都没有(小概率被烧几件东西)、"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"救火有可能库存被清空"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"22、碧水寒潭：潜到潭底概率±修为(加的比减得多)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"23、判官雕像：据为己有+修为-道德"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"24、灵宝殿：选半价拍卖得随机的半价东西或者灵兽"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"25、无名仙岛：进入深处看人品+修为或者-体魄"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"26、宝藏：邀请好友→假装不敌-道德+修为、联手反击-名气-修为"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"27、天梯：登上天梯得功法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"28、恶人：前往助拳+名气+道德"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"29、寻仇：选安抚失去一个功法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"30、求丹：给他丹药+道德、不给-道德-修为"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"31、帮助店主：教训流氓得随机物品"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"32、拍卖：选择不要的功法和丹药换修为"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"33、魔修者：寻求救援-心态+名气、袭击魔修者+道德-体魄"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"合体期事件"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、仙树吸引妖兽：用妖兽错过神兽大会、用阵法成长时间加十年"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、仙树叶子枯黄：得浇水"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、仙树叶子发蔫：得施肥"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、蟠桃大会：参加固定+100万修为和20名气"}]},{"type":"element","tag":"h3","props":{"id":"阴阳师"},"children":[{"type":"text","value":"阴阳师"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、路上遇到了形迹可疑的路人，跟上去看看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -像是非常渴，一直在不停喝水的男子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -饮水水过量的男子晕倒了，送男子就医，来到了另一条街道。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -踏过的地面会留下红色印记的女子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -好奇地现祭红色印记，弄脏了鞋子，购买一双新鞋穿着很舒服。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、木偶商人有新的剧目了，椐说根椐真事改编。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -听奇鬼王怒杀恶兽扩疆域。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -剧情精彩老套无聊不小心睡着了，恢复了一些体力。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -听俏人鱼力斩冰海收珍宝。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -剧本新颖，前所未闻，很多观众都打赏了勾玉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、京都热闹非凡，弥助的身影也出现在銜上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -邀他一同游玩京都吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -弥助灵感迸发，当场作画，得到弥助大作太鼓。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -劝他回去安心作画吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -弥助闷闷不乐，回去画画，弥助不知道画了一张什么玩意。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、街边店铺门口出现了一道熟悉的身影。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -是一只壮硕的橘色大猫。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -花费了一个时辰陪猫玩耍，最后猫的主送你了一些礼物。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -是一只灵活的白色小狗。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -迫狗玩耍，不料反被狗追，不小心闯入了其他街区。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5、店铺老板正在向过往行人兜售锦鲤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -更想要红白配色的锦鲤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -获得一只红白配色的锦鲤，但是运气并没有变好。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -更想要紫白配色的锦鲤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -获得一只紫白配色的锦鲤，但是运气并没有变好。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/%E5%A5%87%E9%81%87%E4%BA%8B%E4%BB%B6/0b6c004abfaf7da7007893271fb71e9c.jpg@!18183"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"6、在路边检到了勾玉袋和一盆丸子串，突然罕见地遇到了镰鼬三兄弟之一。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -是任性妄为的一太郎。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A - —太郎抢走了你裝勾玉的钱袋，但丸子真好吃。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -是不想再呆在最下面的三太郎。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -三太郎抡走了你的丸子串，但是留下了勾玉袋。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"7、偶然捡到一只小猫。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -猫掌柜似乎正在找着什么。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -问猫掌柜丟了什么，小猫安全回家了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -小猫贪吃的模样神似伊吹。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B - 习惯性喂了小猫几串小鱼干，居然真的收到了礼物。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"8、街边店铺在卖各或各样的面具。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -买个般若面具戴。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -戴上后变得十分可爱，被神秘男子搭讪了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -买个天狗面具戴。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -戴上后身体变得轻盈了，被当成了大义的追求者。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"9、宫廷周围闪烁着忽明忽暗的蓝绿色灯火，隐约传来不祥的气息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -走近用火暖暖手。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -火焰突然变旺了，不得不修补被烧坏的衣服。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -在附近设下结界。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -结界阻拦了宫廷附近的跃怪，皇室送来了一些珠宝作为谢礼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"10、京都郊外突然盛开了大片的红色曼珠沙华。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -带一株回到庭院里种。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -曼珠沙华水土不服，第二天就枯萎了，伤心了一个早晨，上集市购买了一束纸花。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -不必在意。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结居洛-京都居民结伴赏花，一时间曼珠沙华成为潮流，曼曼珠沙华价格暴涨，为了跟上潮流上集市高价购买了一株。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11、竹林里传来悠杨的笛声，令人十分愉悦。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -跟着笛声在庭院里跳一支舞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -被路过的博雅看见了，顺势邀请博雅喝酒，将他灌醉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -在庭院廊下安静听完。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -和着笛声沉沉睡去，不幸着凉感冒。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"12、突然刮起了狂风，庭院门前被人提前贴了风符，幸亏风符保护才安然无事。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -揭下风符并妥善保管。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -第二天风符消失了，大天狗飞过庭院，吹坏了庭院的大门。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -派小纸人去风神神社回一份小礼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -风神接受了礼物，获得了一张新的风符。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"13、看到一只有灵力的纸鹤在到处飞舞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -击落一只看看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -击落失败，被突然出现的一群纸鹤追着跑了两条銜。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -派出小纸人跟踪它们。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -纸鹤飞到了小纸人看不见的高度，跟丟了纸鹤，什么收获也没有。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"14、退治妖物后收集到了一些金色的鱗片。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -塞进嘴里咬一下，看看是不是真的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -崩坏了门牙，不得不学着使用阴阳术来补牙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -妥善保管。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结居B -鱗片的妖力引来了奇怪的妖怪在附近徘徊，妖怪退治持续了整整一周。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"15、—个柔弱的小女孩扛着一只巨大的蒲公英。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项A -主动帮她一起扛。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局A -完全搬不幼，被小女孩无情嘲笑了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选项B -笑着鼓励她要继续加油。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结局B -小女孩冲你露出一个可爱的笑容，收获了一整天的好心情。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.3dmgame.com/gl/3828383.html","rel":["nofollow"]},"children":[{"type":"text","value":"鬼谷八荒全奇遇任务攻略 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"全奇遇事件选择及奖励"}]},{"type":"text","value":"3DM单机 ("}]},{"type":"element","tag":"a","props":{"href":"http://3dmgame.com","rel":["nofollow"]},"children":[{"type":"text","value":"3dmgame.com"}]},{"type":"element","tag":"a","props":{"href":"https://www.3dmgame.com/gl/3828383.html","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]},{"type":"element","tag":"h3","props":{"id":"外道巢穴"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"外道巢穴"}]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"名称"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"难度"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"转盘检定"},{"type":"element","tag":"a","props":{"href":"https://taiwu.huijiwiki.com/wiki/%E5%A4%96%E9%81%93%E5%B7%A2%E7%A9%B4#cite_note-1","rel":["nofollow"]},"children":[{"type":"text","value":"^[1]^"}]}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"区域"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"恶丐窝"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1-1"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"毒术 杂学（10、20、30、40、50）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"乡村1 废墟2"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"一伙恶丐群聚于此地，他们不仅时常骚扰附近的百姓与旅人，还向周边散播着恶毒与疾病……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"贼人营寨"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1-1"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"巧匠 杂学（10、20、30、40、50）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"营寨1 洞穴2"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"一伙狡猾的贼人隐匿于此地，他们总在夜间行动，专门窃夺无辜百姓的财物……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"悍匪砦"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2-2"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"锻造 杂学（20、40、60、80、100）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"沙漠2 营寨3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"大批气焰嚣张的匪类于此地占路夺桥，拉帮结派，方圆数百里内，受其欺凌者不计其数……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"叛徒结伙"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3-3"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"制木 杂学（30、60、90、120、150）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"乡村2 树林3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"此地聚集了许多来自不同门派的弃徒，他们或为复仇，或为奸恶目的，最终结成一伙，为害江湖……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"恶人谷"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4-4"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"术数 杂学（40、80、120、160、200）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"山岭2 营寨2 峡谷3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"许多同时身负正邪两道数笔血债的亡命之徒盘踞于此地，因为过着刀口舔血、朝不保夕的日子，故而异常的凶恶……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"迷香阵"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4-4"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"织锦 音律（40、80、120、160、200）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"洞穴2 树林2 花海3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"迷香阵笼罩在一片红雾之内，伴随着其中的细细笑语和靡靡乐音，阵阵异香不断地飘送出来……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"乱葬岗"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"5-5"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"医术 毒术（50、100、150、200、250）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"庙宇2 废墟3 古墓3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"弃置着众多枉死者尸身的不祥之地，随着一些江湖上的诡怪术士在此地频繁出入，更为此地蒙上了一层可怖的阴影……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"异士居"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"6-6"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"音律 弈棋 诗书 绘画 品鉴（60、120、180、240、300）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"湖泊2 茅庐3 古迹3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"一些左道异士结庐居于此地，这些异士虽身怀绝技，但性情乖戾，善恶不分，行事只凭一时之兴……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"邪人死地"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"7-7"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"道法（70、140、210、280、350）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"洞穴2 潭泽2 林野3 古迹3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"大批异疆邪教中人群聚于此，他们设坛祭鬼，施烟布瘴，每日杀人取乐，闻者无不色变……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"修罗场"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"7-7"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"医术 杂学（70、140、210、280、350）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"荒野2 沙漠2 营寨3 废墟3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"发生过极多可怕杀戮的凶恶之地，许多曾在杀戮中失却心智的疯子与狂人受到炼心师的操弄，仍不断游荡在此地附近……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"群魔乱舞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"8-8"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"佛学（80、160、240、320、400）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"洞穴3 庙宇3 废墟3 古墓3"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"一支无名魔教的教众占据着此地，他们为了壮大自身的声势，不断以骇人的手段残害着武林正道的人士……"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"弃世绝境"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"9-9"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"术数 佛学 道法（90、180、270、360、450）"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"此地曾是某处世外绝境的屏障，直到无休止的江湖纷争蔓延至此，那些原本隐居于绝境中的人满怀着仇恨被迫重返尘世…"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"关于奖惩","depth":3,"text":"关于奖惩"},{"id":"阴阳师","depth":3,"text":"阴阳师"},{"id":"外道巢穴","depth":3,"text":"外道巢穴"}]}},"_type":"markdown","_id":"content:gyj:2022-08-22-奇遇事件.md","_source":"content","_file":"gyj/2022-08-22-奇遇事件.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-08-22-youxiliucheng","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"游戏流程","description":"我来到了这个世界，发现身上仅有4000块钱，四周转了转，由于和城镇关系不足，很多地方都去不了，而提升关系度的唯一办法就是去城镇接取任务。每天晚上我都得去附近的旅馆进行歇息，这会花费我好多银子，我得第一个目标将变为盖一所不大的房子。我努力的将钱挣够了5000，在官府那里买下了我第一块地。我从杂货商人那里买了个设计卓开始了我的第一个房子的设计。简简单单的一个房子盒子就出来了。选了个绝佳的位置，填充材料，建造。随着房子的建立完成，每天醒来或者晚上回家，偶尔会有邻居来到我家门口拜托我帮一些小忙，随着日子的过去，我和村里人的关系越来越好。能在城镇里去的地方也越来越多，我喜欢去那些没有去过的地方，因为有时可能会发现一些小惊喜，比如一个未打开的宝箱，一些珍贵的资源，和有趣的人。随着房子的建成，需要的家具和武器越来越多，消耗的资源也越来越多，而城镇的资源是有限的，我开始像城镇周围的其他城市开始探索。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我来到了这个世界，发现身上仅有4000块钱，四周转了转，由于和城镇关系不足，很多地方都去不了，而提升关系度的唯一办法就是去城镇接取任务。每天晚上我都得去附近的旅馆进行歇息，这会花费我好多银子，我得第一个目标将变为盖一所不大的房子。我努力的将钱挣够了5000，在官府那里买下了我第一块地。我从杂货商人那里买了个设计卓开始了我的第一个房子的设计。简简单单的一个房子盒子就出来了。选了个绝佳的位置，填充材料，建造。随着房子的建立完成，每天醒来或者晚上回家，偶尔会有邻居来到我家门口拜托我帮一些小忙，随着日子的过去，我和村里人的关系越来越好。能在城镇里去的地方也越来越多，我喜欢去那些没有去过的地方，因为有时可能会发现一些小惊喜，比如一个未打开的宝箱，一些珍贵的资源，和有趣的人。随着房子的建成，需要的家具和武器越来越多，消耗的资源也越来越多，而城镇的资源是有限的，我开始像城镇周围的其他城市开始探索。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"城镇里偶尔会有一些山贼的出现，在我采集资源的时候经常会碰到，他们常常杀人如麻，当然我也不是好惹的，城镇里的人说当杀掉一百个山贼的时候，这个城镇将会有山贼王的降临。山贼王出现的时候，城市里商人不会出现，官府也不会有人，每个人都会躲在家里，连城镇也出不去，直到消灭掉他。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"开始跑商，跑商随着游戏的进行，被门派压榨，越来越难，有一天，我突然想改变这个世界，我开始建立门派。招收人员"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:gyj:2022-08-22-游戏流程.md","_source":"content","_file":"gyj/2022-08-22-游戏流程.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-08-22-wupinchanchubiao","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"物品产出表","description":"物品产出表野外食物产出作物 浆果 甜菜 出现少，加体力少树木掉落 蜂蜜，松果。。水果动物掉落 肉。不掉落皮毛，因为要养殖鱼产出种类树木制作家具和装备作物制作食物,增加体力和非战斗相关的buff卖钱药材制作药品,增加血和蓝,以及战斗相关的buff动物皮毛用来制造衣服肉用来制作食物鱼类用来制作食物矿石可以用来进行武器的制造和升级宝石宝石可以用来制作物品通常是最爱的礼物或喜欢的礼物。偶尔会出现宝石洞固定日期会产出持续三到五天翡翠价格非常昂贵,除了卖钱别无他用翡翠原石鉴定而得城市产出说明一些城市有特殊产出,固定的除特殊产出,其他的都随机分布地块应该有一些标记,标记这个地方是否可以生成矿,是否可以有药材","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"物品产出表"},"children":[{"type":"text","value":"物品产出表"}]},{"type":"element","tag":"h3","props":{"id":"野外食物产出"},"children":[{"type":"text","value":"野外食物产出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作物 浆果 甜菜 出现少，加体力少"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"树木掉落 蜂蜜，松果。。水果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"动物掉落 肉。不掉落皮毛，因为要养殖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"鱼"}]},{"type":"element","tag":"h2","props":{"id":"产出种类"},"children":[{"type":"text","value":"产出种类"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"树木"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"制作家具和装备"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"作物"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"制作食物,增加体力和非战斗相关的buff"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"卖钱"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"药材"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"制作药品,增加血和蓝,以及战斗相关的buff"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"动物"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"皮毛用来制造衣服"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"肉用来制作食物"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"鱼类"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"用来制作食物"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"矿石"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可以用来进行武器的制造和升级"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"宝石"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"宝石可以用来制作物品"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常是最爱的礼物或喜欢的礼物。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"偶尔会出现宝石洞"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"固定日期会产出持续三到五天"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"翡翠"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"价格非常昂贵,除了卖钱别无他用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"翡翠原石鉴定而得"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"城市产出说明"},"children":[{"type":"text","value":"城市产出说明"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一些城市有特殊产出,固定的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"除特殊产出,其他的都随机分布"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地块应该有一些标记,标记这个地方是否可以生成矿,是否可以有药材,是否可以有食材,是否可以有木头"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"玩家出生地的产物,一定是低级的产物,不然没法进行初级制作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物依稀为贵,产量越少,等级越高"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"食物可以补充体力,晚上睡觉可以补充体力"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"晚上十点到早上六点,每小时额外扣除体力,以及心情"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"送礼好感度=====获取的难度,衡量产出时间,以及掉落概率"}]}]},{"type":"element","tag":"h2","props":{"id":"树木"},"children":[{"type":"text","value":"树木"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"售价和稀有度有关,稀有度越高,价格越高"}]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"树木"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"售价"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"砂树"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"松树"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,松木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"冷杉"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,铁力木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"柏树"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,乌木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"杨树"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,黄杨木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"榉树"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,榉木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"5"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"楠树"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,楠木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"6"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"白桦"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"木头,桦木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"7"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"望天树"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"8"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"作物"},"children":[{"type":"text","value":"作物"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据素材决定会有哪些作物"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般的计算公式为 [( 最多收获次数 x 单位售价 ) - 种子购买价格 ] / 生产周期"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生产周期 = 成熟所需天数 +（最多收获次数 - 1）x 重新生长天数"}]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"作物"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"药材"},"children":[{"type":"text","value":"药材"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"药材的素材只有一种,分等级.然后产出"}]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"药材"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"草药"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"草药"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"草药"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"草药"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"草药"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"天麻,藏红花,雪莲花,冬虫夏草,人参,天冬,贝母,肉苁蓉"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"5"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"动物"},"children":[{"type":"text","value":"动物"}]},{"type":"element","tag":"blockquote","props":{},"children":[]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"动物"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"鱼类"},"children":[{"type":"text","value":"鱼类"}]},{"type":"element","tag":"blockquote","props":{},"children":[]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"鱼类"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"矿石"},"children":[{"type":"text","value":"矿石"}]},{"type":"element","tag":"blockquote","props":{},"children":[]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"矿石"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"石头"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"铜矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"锡矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"铁矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"铅矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"银矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"钨矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"金矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"铂金矿"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"宝石"},"children":[{"type":"text","value":"宝石"}]},{"type":"element","tag":"blockquote","props":{},"children":[]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"宝石"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"晶石"},"children":[{"type":"text","value":"晶石"}]},{"type":"element","tag":"blockquote","props":{},"children":[]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"晶石"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"掉落"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"等级"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"环境"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"野外食物产出","depth":3,"text":"野外食物产出"},{"id":"产出种类","depth":2,"text":"产出种类"},{"id":"城市产出说明","depth":2,"text":"城市产出说明"},{"id":"树木","depth":2,"text":"树木"},{"id":"作物","depth":2,"text":"作物"},{"id":"药材","depth":2,"text":"药材"},{"id":"动物","depth":2,"text":"动物"},{"id":"鱼类","depth":2,"text":"鱼类"},{"id":"矿石","depth":2,"text":"矿石"},{"id":"宝石","depth":2,"text":"宝石"},{"id":"晶石","depth":2,"text":"晶石"}]}},"_type":"markdown","_id":"content:gyj:2022-08-22-物品产出表.md","_source":"content","_file":"gyj/2022-08-22-物品产出表.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-08-22-wanfa","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"玩法","description":"玩法收集收集九块令牌收集不同的植物收集不同的矿物收集不同的鱼类收集不同的草药收集古董帮派经济门派副本秘境蛙岛大逃杀Roguelike爬塔节日端午划龙舟比武大会元宵节猜灯谜入侵模式强盗王杀了150个强盗白莲教魔教谋反蛇人入侵僵尸王天人入侵四大圣兽入侵妖族入侵入侵模式.不能售卖东西..不能大地图移动门客护卫跑商种植养殖寻宝探索去不同的城市资源有限,会被采光宝箱利用关系解锁地块人物宝箱故事剧情奖励好看的场景???隐藏地图武学npc互动和小游戏打牌三消24点猜谜切磋","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"玩法"},"children":[{"type":"text","value":"玩法"}]},{"type":"element","tag":"h2","props":{"id":"收集"},"children":[{"type":"text","value":"收集"}]},{"type":"element","tag":"h3","props":{"id":"收集九块令牌"},"children":[{"type":"text","value":"收集九块令牌"}]},{"type":"element","tag":"h3","props":{"id":"收集不同的植物"},"children":[{"type":"text","value":"收集不同的植物"}]},{"type":"element","tag":"h3","props":{"id":"收集不同的矿物"},"children":[{"type":"text","value":"收集不同的矿物"}]},{"type":"element","tag":"h3","props":{"id":"收集不同的鱼类"},"children":[{"type":"text","value":"收集不同的鱼类"}]},{"type":"element","tag":"h3","props":{"id":"收集不同的草药"},"children":[{"type":"text","value":"收集不同的草药"}]},{"type":"element","tag":"h3","props":{"id":"收集古董"},"children":[{"type":"text","value":"收集古董"}]},{"type":"element","tag":"h2","props":{"id":"帮派"},"children":[{"type":"text","value":"帮派"}]},{"type":"element","tag":"h3","props":{"id":"经济"},"children":[{"type":"text","value":"经济"}]},{"type":"element","tag":"h3","props":{"id":"门派"},"children":[{"type":"text","value":"门派"}]},{"type":"element","tag":"h2","props":{"id":"副本"},"children":[{"type":"text","value":"副本"}]},{"type":"element","tag":"h3","props":{"id":"秘境"},"children":[{"type":"text","value":"秘境"}]},{"type":"element","tag":"h3","props":{"id":"蛙岛"},"children":[{"type":"text","value":"蛙岛"}]},{"type":"element","tag":"h3","props":{"id":"大逃杀"},"children":[{"type":"text","value":"大逃杀"}]},{"type":"element","tag":"h3","props":{"id":"roguelike"},"children":[{"type":"text","value":"Roguelike"}]},{"type":"element","tag":"h3","props":{"id":"爬塔"},"children":[{"type":"text","value":"爬塔"}]},{"type":"element","tag":"h2","props":{"id":"节日"},"children":[{"type":"text","value":"节日"}]},{"type":"element","tag":"h3","props":{"id":"端午划龙舟"},"children":[{"type":"text","value":"端午划龙舟"}]},{"type":"element","tag":"h3","props":{"id":"比武大会"},"children":[{"type":"text","value":"比武大会"}]},{"type":"element","tag":"h3","props":{"id":"元宵节"},"children":[{"type":"text","value":"元宵节"}]},{"type":"element","tag":"h4","props":{"id":"猜灯谜"},"children":[{"type":"text","value":"猜灯谜"}]},{"type":"element","tag":"h2","props":{"id":"入侵模式"},"children":[{"type":"text","value":"入侵模式"}]},{"type":"element","tag":"h3","props":{"id":"强盗王"},"children":[{"type":"text","value":"强盗王"}]},{"type":"element","tag":"h4","props":{"id":"杀了150个强盗"},"children":[{"type":"text","value":"杀了150个强盗"}]},{"type":"element","tag":"h3","props":{"id":"白莲教"},"children":[{"type":"text","value":"白莲教"}]},{"type":"element","tag":"h3","props":{"id":"魔教"},"children":[{"type":"text","value":"魔教"}]},{"type":"element","tag":"h3","props":{"id":"谋反"},"children":[{"type":"text","value":"谋反"}]},{"type":"element","tag":"h3","props":{"id":"蛇人入侵"},"children":[{"type":"text","value":"蛇人入侵"}]},{"type":"element","tag":"h3","props":{"id":"僵尸王"},"children":[{"type":"text","value":"僵尸王"}]},{"type":"element","tag":"h3","props":{"id":"天人入侵"},"children":[{"type":"text","value":"天人入侵"}]},{"type":"element","tag":"h3","props":{"id":"四大圣兽入侵"},"children":[{"type":"text","value":"四大圣兽入侵"}]},{"type":"element","tag":"h3","props":{"id":"妖族入侵"},"children":[{"type":"text","value":"妖族入侵"}]},{"type":"element","tag":"h3","props":{"id":"入侵模式不能售卖东西不能大地图移动"},"children":[{"type":"text","value":"入侵模式.不能售卖东西..不能大地图移动"}]},{"type":"element","tag":"h2","props":{"id":"门客"},"children":[{"type":"text","value":"门客"}]},{"type":"element","tag":"h3","props":{"id":"护卫"},"children":[{"type":"text","value":"护卫"}]},{"type":"element","tag":"h3","props":{"id":"跑商"},"children":[{"type":"text","value":"跑商"}]},{"type":"element","tag":"h3","props":{"id":"种植"},"children":[{"type":"text","value":"种植"}]},{"type":"element","tag":"h3","props":{"id":"养殖"},"children":[{"type":"text","value":"养殖"}]},{"type":"element","tag":"h3","props":{"id":"寻宝"},"children":[{"type":"text","value":"寻宝"}]},{"type":"element","tag":"h2","props":{"id":"探索"},"children":[{"type":"text","value":"探索"}]},{"type":"element","tag":"h3","props":{"id":"去不同的城市"},"children":[{"type":"text","value":"去不同的城市"}]},{"type":"element","tag":"h4","props":{"id":"资源有限会被采光"},"children":[{"type":"text","value":"资源有限,会被采光"}]},{"type":"element","tag":"h4","props":{"id":"宝箱"},"children":[{"type":"text","value":"宝箱"}]},{"type":"element","tag":"h3","props":{"id":"利用关系解锁地块"},"children":[{"type":"text","value":"利用关系解锁地块"}]},{"type":"element","tag":"h4","props":{"id":"人物"},"children":[{"type":"text","value":"人物"}]},{"type":"element","tag":"h4","props":{"id":"宝箱-1"},"children":[{"type":"text","value":"宝箱"}]},{"type":"element","tag":"h3","props":{"id":"故事剧情"},"children":[{"type":"text","value":"故事剧情"}]},{"type":"element","tag":"h4","props":{"id":"奖励"},"children":[{"type":"text","value":"奖励"}]},{"type":"element","tag":"h3","props":{"id":"好看的场景"},"children":[{"type":"text","value":"好看的场景???"}]},{"type":"element","tag":"h3","props":{"id":"隐藏地图"},"children":[{"type":"text","value":"隐藏地图"}]},{"type":"element","tag":"h2","props":{"id":"武学"},"children":[{"type":"text","value":"武学"}]},{"type":"element","tag":"h2","props":{"id":"npc互动和小游戏"},"children":[{"type":"text","value":"npc互动和小游戏"}]},{"type":"element","tag":"h3","props":{"id":"打牌"},"children":[{"type":"text","value":"打牌"}]},{"type":"element","tag":"h3","props":{"id":"三消"},"children":[{"type":"text","value":"三消"}]},{"type":"element","tag":"h3","props":{"id":"_24点"},"children":[{"type":"text","value":"24点"}]},{"type":"element","tag":"h3","props":{"id":"猜谜"},"children":[{"type":"text","value":"猜谜"}]},{"type":"element","tag":"h3","props":{"id":"切磋"},"children":[{"type":"text","value":"切磋"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"收集","depth":2,"text":"收集","children":[{"id":"收集九块令牌","depth":3,"text":"收集九块令牌"},{"id":"收集不同的植物","depth":3,"text":"收集不同的植物"},{"id":"收集不同的矿物","depth":3,"text":"收集不同的矿物"},{"id":"收集不同的鱼类","depth":3,"text":"收集不同的鱼类"},{"id":"收集不同的草药","depth":3,"text":"收集不同的草药"},{"id":"收集古董","depth":3,"text":"收集古董"}]},{"id":"帮派","depth":2,"text":"帮派","children":[{"id":"经济","depth":3,"text":"经济"},{"id":"门派","depth":3,"text":"门派"}]},{"id":"副本","depth":2,"text":"副本","children":[{"id":"秘境","depth":3,"text":"秘境"},{"id":"蛙岛","depth":3,"text":"蛙岛"},{"id":"大逃杀","depth":3,"text":"大逃杀"},{"id":"roguelike","depth":3,"text":"Roguelike"},{"id":"爬塔","depth":3,"text":"爬塔"}]},{"id":"节日","depth":2,"text":"节日","children":[{"id":"端午划龙舟","depth":3,"text":"端午划龙舟"},{"id":"比武大会","depth":3,"text":"比武大会"},{"id":"元宵节","depth":3,"text":"元宵节"}]},{"id":"入侵模式","depth":2,"text":"入侵模式","children":[{"id":"强盗王","depth":3,"text":"强盗王"},{"id":"白莲教","depth":3,"text":"白莲教"},{"id":"魔教","depth":3,"text":"魔教"},{"id":"谋反","depth":3,"text":"谋反"},{"id":"蛇人入侵","depth":3,"text":"蛇人入侵"},{"id":"僵尸王","depth":3,"text":"僵尸王"},{"id":"天人入侵","depth":3,"text":"天人入侵"},{"id":"四大圣兽入侵","depth":3,"text":"四大圣兽入侵"},{"id":"妖族入侵","depth":3,"text":"妖族入侵"},{"id":"入侵模式不能售卖东西不能大地图移动","depth":3,"text":"入侵模式.不能售卖东西..不能大地图移动"}]},{"id":"门客","depth":2,"text":"门客","children":[{"id":"护卫","depth":3,"text":"护卫"},{"id":"跑商","depth":3,"text":"跑商"},{"id":"种植","depth":3,"text":"种植"},{"id":"养殖","depth":3,"text":"养殖"},{"id":"寻宝","depth":3,"text":"寻宝"}]},{"id":"探索","depth":2,"text":"探索","children":[{"id":"去不同的城市","depth":3,"text":"去不同的城市"},{"id":"利用关系解锁地块","depth":3,"text":"利用关系解锁地块"},{"id":"故事剧情","depth":3,"text":"故事剧情"},{"id":"好看的场景","depth":3,"text":"好看的场景???"},{"id":"隐藏地图","depth":3,"text":"隐藏地图"}]},{"id":"武学","depth":2,"text":"武学"},{"id":"npc互动和小游戏","depth":2,"text":"npc互动和小游戏","children":[{"id":"打牌","depth":3,"text":"打牌"},{"id":"三消","depth":3,"text":"三消"},{"id":"_24点","depth":3,"text":"24点"},{"id":"猜谜","depth":3,"text":"猜谜"},{"id":"切磋","depth":3,"text":"切磋"}]}]}},"_type":"markdown","_id":"content:gyj:2022-08-22-玩法.md","_source":"content","_file":"gyj/2022-08-22-玩法.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-08-22-diyizhang","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"初入江湖","description":"你正在路上疯狂的逃跑,后面跟着几个追赶你的匪徒","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你正在路上疯狂的逃跑,后面跟着几个追赶你的匪徒"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时你暗骂一声,他娘的,这回真的跑不了了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只见这时一人闪出挡在你的身前,喊道肖小毛贼,赶快住手."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你心中一喜,难道自己这就是传说中的主角命,性命攸关之时,必有大侠相救"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只听那人再次说道:光天化日之下,竟敢强抢民男,不知廉耻,只要你们退去,我今日可饶过你们."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"什么强抢名男,这个大侠似乎有点不靠谱(ps:如果玩家选的是女角色,这个段落需要去除)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"匪徒们见你们只有两人,也没多说废话,直接动手."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"无奈你们只好迎战,费了九牛二虎之力,总算击杀了二人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"战后,你面向那位大侠说到"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"多谢兄弟出手搭救,在下xxx,不知兄弟姓名,日后必定报答\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"客气,我叫李二,路见不平拔刀相助,是我等江湖儿女应做之事.兄弟为何会被这窝歹徒追赶啊\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"家乡遭难,我是来逃荒至此,没想到路经此地却被这伙匪徒盯上,哎,落难至此,也实在没地方可去.\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"这样啊,兄弟,我家住旁边的龙隐村,吾今日离家去外地闯荡,家中无人,不嫌弃的话,可以去我家先住一段时间,以后再做打算\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你思考片刻,决定是否要感谢对方,将身上的银两进行相赠,"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"赠送纹银200两,以示感谢"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不赠送,口头表示感谢"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"多谢兄弟,我既遇兄弟相救,又得你收留,为表心意,这点银两请务必收下\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"兄弟客气,你沿着这条路往前走,会看到一个路牌,前往东山小路,然后就能找到我家了,\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"青山不改,绿水长流,兄弟,他日我们江湖再见\""}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你往前走前往到了李二的家,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"这该时李二的家了吧,天已渐黑,还是早些休息,明日再想着日后打算\""}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"点击床进行睡觉,"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"出门遇到村长"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"村长:\"你是何人,怎么住在李二的房子\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你:\"昨日在山间落难,幸得李兄搭救,他说出去闯荡,所以房子就先给我暂住\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"村长:\"哎,如今征战连年,四处都有匪盗,既然如此就就先在此住着\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"村长:\"生活不易,正逢春季,我这有些种子送给你,你快些播下,能够有些好的收成,维持口粮\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你:\"多谢村长\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"村长:\"种地需要些工具,在西山小路的杂货商中会卖些基本的工具你可以买些回来\""}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:gyj:2022-08-22-第一章.md","_source":"content","_file":"gyj/2022-08-22-第一章.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-08-22-zhiyeyugongzuo","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"2022 08 22 职业与工作","description":"职业采集采集的时候增加经验扶农.每提升一点则减少消耗体力0.1点农夫砍伐砍树增加经验斫(zhuo)木每提升一点则减少消耗体力0.1点樵夫养殖收获农产品增加经验庖丁,.每提升一点则减少消耗体力0.1点屠夫采矿采矿增加经验开山 每提升一点则减少消耗体力0.1点矿工钓鱼钓鱼增加经验渔获每提升一点则减少消耗体力0.1点渔夫制作制作家具和武器增加经验机巧减少制作时间,制作时消耗的燃料???铁匠----制作订单牌..接受订单医术制药和行医的时候增加经验悬壶--每提升一点则减少消耗体力0.1点药师烹饪做饭和招呼客人的时候增加经验食肆--每提升一点则减少消耗体力0.1点掌柜经商???购买物品的时候生财--交易","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"职业"},"children":[{"type":"text","value":"职业"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采集"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采集的时候增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"扶农.每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"农夫"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"砍伐"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"砍树增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"斫(zhuo)木每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"樵夫"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"养殖"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"收获农产品增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"庖丁,.每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"屠夫"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采矿"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"采矿增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开山 每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"矿工"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"钓鱼"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"钓鱼增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"渔获每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"渔夫"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"制作"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"制作家具和武器增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"机巧减少制作时间,制作时消耗的燃料???"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"铁匠----制作订单牌..接受订单"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"医术"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"制药和行医的时候增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"悬壶--每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"药师"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"烹饪"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"做饭和招呼客人的时候增加经验"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"食肆--每提升一点则减少消耗体力0.1点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"掌柜"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"经商???"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"购买物品的时候"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生财--交易时获得的金钱???"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"商人"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"如何开酒楼和医院"},"children":[{"type":"text","value":"如何开酒楼和医院"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"购买许可证"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"悬挂在屋内,(只准悬挂一种许可证)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"许可证有个按钮..营业或者行医,,点击提示消耗一天"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"经营"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"酒馆   需要柜台,和桌子,柜台可以让npc有个等候区,如果等候区满了...npc没有在固定时间接待,则会走出房屋"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"医院  需要床,如果没有床npc固定时间没有接待则走人.诊断失败扣除经验"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"npc的AI"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每隔一段时间生成客人"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客人走进屋子内,检查是否有等候区..如果等候时间到了,则离开.."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"npc会说话"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"职业","depth":2,"text":"职业"},{"id":"如何开酒楼和医院","depth":2,"text":"如何开酒楼和医院"}]}},"_type":"markdown","_id":"content:gyj:2022-08-22-职业与工作.md","_source":"content","_file":"gyj/2022-08-22-职业与工作.md","_extension":"md","date":"2022-08-22"},{"_path":"/gyj/2022-11-01-tianxiabatu","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"天下霸图研究","description":"天下霸图2时间观念一个月分4天，1日、10日、20日、30日，并不是天30，一个月份结算薪资4次，例如你的门派介面设定支薪10，总支薪是310元的 话，一个月的支出就是支薪1240元，也就是你必须在48个时辰内凑到1240元来维持支出。薪资门派的薪资调整其实是在设定弟子心情的基准底限，建议以原本设定支薪10就好，因为移动到别的地方的时候各定的基本设定都 是10，也不用调来调去，以5张脸来说，10只是中间普通的而已，这关系到什麼呢？关系到练武经验的最大上限，基准调越高，弟子能在武场练 的经验值能撑越高，但是投资比率太不敷出，所以还是建议10就好，学习力（後面会解说）3支蜡烛大约最高经验值上限可以","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"天下霸图2"},"children":[{"type":"text","value":"天下霸图2"}]},{"type":"element","tag":"h4","props":{"id":"时间观念"},"children":[{"type":"text","value":"时间观念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个月分4天，1日、10日、20日、30日，并不是天30，一个月份结算薪资4次，例如你的门派介面设定支薪10，总支薪是310元的 话，一个月的支出就是支薪1240元，也就是你必须在48个时辰内凑到1240元来维持支出。"}]},{"type":"element","tag":"h4","props":{"id":"薪资"},"children":[{"type":"text","value":"薪资"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门派的薪资调整其实是在设定弟子心情的基准底限，建议以原本设定支薪10就好，因为移动到别的地方的时候各定的基本设定都 是10，也不用调来调去，以5张脸来说，10只是中间普通的而已，这关系到什麼呢？关系到练武经验的最大上限，基准调越高，弟子能在武场练 的经验值能撑越高，但是投资比率太不敷出，所以还是建议10就好，学习力（後面会解说）3支蜡烛大约最高经验值上限可以学到7000才会喊不 爽，但是6000就开始变脸了，如果收学费制的话，这适用在快攻，因为没打算让原本的弟子打通关，後面新加入的弟子资质几乎都比原本的人 好，六力很快就能超过原本的人物，因为他们一出来只有长拳1XX多经验，等到他长拳练到3XXX经验值时臂力应该破400其他都破200，轻功要另 外练，收学费2块钱的话大约最高练武上限能到4000而已，想当然必须比较快换下一招练，六力提升比较正常，但是会有弟子一喊不爽就马上跑 掉的问题，比较之下，支薪10块钱一开始即使你没排练武行程给他他都不会不高兴，你调再高的薪资给他也都只是普通心情，心情在於练武成 效，最高效率就是领悟，只要给他领悟後，经验值从0到最高上限都是普通心情，超过最高上限他就会不爽，而你绝对有时间帮他换秘笈；好处 在於不怕讨伐受伤休息太久而不高兴，不怕没练到武不高兴，不怕有分舵後忘记调薪资而管理不方便，支薪10元练武所需成效最低底限50。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重点：10元起手，再借不难；先学会支薪10元，玩熟了之後再去研究调整薪资。"}]},{"type":"element","tag":"h4","props":{"id":"弟子心情"},"children":[{"type":"text","value":"弟子心情"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门派介面的脸和弟子个别人物情报的脸是不一样的，门派介面的脸是代表弟子基准心情底限及平均变化量（以月份为单位），弟 子心情代表其个人的该日心情（已日为单位），算是较细部的观察；主要是门派介面的基准底限不要太低的话，弟子不爽的缓冲时间就比较充 足，如果很在意想让弟子每天绿脸的话，不是加高他的练武成效（效果不好），而是加多他的领悟时间，在领悟室里所得练武经验值非常高， 但是领悟期间所得经验值没加六力，所以不要让他领悟出来，他快领悟出来的时候就帮他换掉，不要小看拿秘笈领悟，时间很短，可是那短短 几个时辰加的六力是最高的；弟子最快乐的绿脸时期大多是在刚拿到秘笈至领悟出来这短短的期间，因为很容易让该日练武成效破千，之後就 很难了，如果用收学费的，要让每日练武成效破2千甚至3千以上，就几乎都浸在练舞场和领悟室了，收入就要靠其他弟子来分担，所以就要另 外开个分舵了。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重点：心情不是看脸色的；常利用门派的情报介面看各人物的工作成效，是否保持练武成效50以上，如果没有，看蓝色条，如果都是蓝的就表 示他练武有成，想换别的秘笈了（10元很好起手，这之前他就会开始提示了）。"}]},{"type":"element","tag":"h4","props":{"id":"学习力"},"children":[{"type":"text","value":"学习力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"收人的时候除了看属性和特技，还要看他的学习力，他这是以六力为表示，臂力和腰力高的就表示拳法学习力高，不过这只是大 概，最准确的就是看他写秘笈有几根蜡烛（不是真的叫他去写秘笈），越少根表示所花时间越少，该项学习力越高，同理也可用领悟的方式查 看；其实这关系到基础武学和六力，基础武学越扎稳该项六力（如拳法要臂力和腰力）越高他的学习力就会越高，所以此代的学习力是可以成 长的。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重点：基础武学要扎稳啊；扎稳了自然该项所需六力就会相对提高，就方便练下一阶武功，也可提高下一阶武功的最高上限经验值；腿法最重 要，没铁矿产的第2要先著手掌法，因为没铁矿或许也没卖武器的民房，所以都只练腿掌法，等到有分舵才在分舵主攻兵器场，徒手武功在兵器场和兵器武功在徒手武场，所得练武经验值及练武意愿（最高练武经验上限）都会只剩1/4。"}]},{"type":"element","tag":"h4","props":{"id":"工作时辰编排"},"children":[{"type":"text","value":"工作时辰编排"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"起初都是每个人各项设施一点，大约武场有3个的时候（只有6个人的话）才特别编排武场2点，等到有5个武场的时候才4练武3种 田3工作补强六力，或是练武3领悟2种田3工作2，尽量不要让弟子发呆就是了，先看哪些设施会卡人先补足；其实我觉得这地方最有学问，要靠 自己慢慢摸索才能领悟...... "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重点：每日情报资料更新後都要看弟子工作效率，白色色条表示发呆，空白色条表示行走，腿力过低的就增加他的行程点数比例以减少他的行走时间或是只让他在主殿附近工作。 \\"}]},{"type":"element","tag":"h4","props":{"id":"设施"},"children":[{"type":"text","value":"设施"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一开场绝对要各项生产设施都建设（农田至少2，其他牧场、药园都要有，然後原料店要盖出来），不要急著建设武场，这边的重点 主要在原料店，每个产物每样工作都1点的话会比较平均，原料店要设定下一个预见设施的储存量，例如我下一个设施想盖武场需要500肉和200 药，那就要设定卖的储存量肉3000药3000,这样他会保留1000肉和1000药，如果是分舵主殿要12000肉8000木，那就设定肉15000木11000，其实 到了要开分舵的时候不只要这些啦，最少要4万现金和各2万资源再过去比较好；只有自己产地没有生产的才不打开设定，其他都要打开并且设 定好，我当初就是没看中这个，才都玩不起来，对了，一次交易量是1000，物资尽量平均卖，自己特产什麼该样物资就可以减少人手去挖，主 要是卖米肉药，其他贵重材料慢慢卖或是不卖，有需要再去开采，不过最好还是慢慢卖。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重点：原料店很重要，一定要尽早盖起来并且设定好，装备生产设施（冶锻场、织造房）等稳定後才开始盖并且才派人员工作。"}]},{"type":"element","tag":"h4","props":{"id":"战斗"},"children":[{"type":"text","value":"战斗"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基础腿法长拳掌招防御（要练防3盘并且闪躲率高的）轻功都要练完才出战，掌门的左右护法要一个专练呐喊和防守自补血方针开 保护，一个帮补专掌法腿法消耗对方敏捷的方针开补血，掌门就让他变态攻击型吧，因为掌门大多是专武的特技，保护的那个要全身封印装 备......，不然即使是胖子一样备摸两下就趴，如果有练防3盘防守招（主要减免3盘伤害，只有两盘的话封印会有一盘没效用，就是致命破绽 了），全身穿封印，即使是瘦子也可挡，甚至不会失血......不知道是不是BUG，胖子跟瘦子好像是看损血比率，被打到一样都只剩两成血；为 什麼要基础武功都会了才出战？因为一开始低等盗匪不值得花时间去打，那等於偶而救济一下浪费时间（采集时间）毫无作用，等到都练好了 再开打声望要一下子满很简单，不管怎样最後还是会武功迟滞，回来练功导致声望降回还要重新打声望的。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重点：等到可以开打的时候，等累积3个同样任务（运标、救济、劫标那些都不用看，只看红剑图示），然後在白天看一下任务内容，等到晚上 再一次连续接，最後一场战斗如果有人失血过多的话要退一下补血，保持完好状态收场才不用花费休息时间。"}]},{"type":"element","tag":"h4","props":{"id":"职位"},"children":[{"type":"text","value":"职位"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"舵主的忠诚度和智慧影响该分舵(以下⼀样)弟⼦的忠诚度,健康和智慧影响⽣产,智慧和四⼤武功属性(攻击,防御,青⼯,暗器)影响练功,智慧和四⼒(内,臂,腰,腿)影响采集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"左堂主的智慧和四⼤武功属性(攻击,防御,青⼯,暗器)影响练功"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"右堂主的智慧和四⼒(内,臂,腰,腿)影响采集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"被选为舵主忠诚+20左右堂主+10,取消则减之."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"|                       天下霸图2弟子特性一览表|\n|生产类特性|\n|深耕|产粮食腿力计算*3|\n|肥田|农田跟药铺等级+1(计算时)|\n|剥皮|皮革产能*2|\n|耐力|精力减少除以2|\n|工艺|铸造时内力计算*3|\n|快逢|织造时指力属性*3|\n|炼金|丹药产量*2|\n|辩矿|金矿、铁矿、木材产量*2|\n|探勘|金矿、铁矿、木材资源等级+1|\n|铁臂|挖金矿铁矿时计算臂力属性*3|\n|铁人|在厢房精力回覆加倍|\n|识药|计算药草时腰力属性*3|\n|活力|每天早上所有精力回复|\n|神笔|悟招跟写秘籍速度*200%|\n|聚财|有他在该分舵所有物品买价-20%卖价+50%|\n|战斗类特性|\n|狂奔|轻功受地形影响减少|延命|生命低于5%时恢复到最大生命的60%|\n|慧根|练武经验增加*2|色诱|都受到异性攻击时伤害力减少25%|\n|寻路|队伍移动+100|惩戒|当重击对手时下一招伤害*2|\n|养生|战斗中将康回复率*4|热血|受到伤害可以累加增加出招速度|\n|体健|战斗中六力回复率*2|金身|对所有负面状态免疫|\n|开窍|战斗的道的经验成以1.5|虐杀|击中对手时有30%机会瞬间减少对手25%健康|\n|刀敏|以更快的速度施展刀法|焚身|击中对手时有20%机会烧掉对手的6力|\n|剑灵|以更快的速度施展剑法|忍术|施展轻功无视高度影响|\n|棍通|以更快的速度施展棍法|羽化|施展轻功无须任何消耗|\n|快腿|以更快速度施展腿法|毒胆|对所有中毒免疫|\n|速拳|以更快的速度施展拳法|毒杀|当对手楚于异常状态时武功攻击力*1.5|\n|劲掌|以更快的速度施展掌法|自暴|当生命低于150时销号生命100点事下一招攻击+300|\n|武痴|所有武功重击率*2|魔身|除非发生重击否则不会受到任何伤害|\n|坚毅|对所有恐惧免疫|神打|除非受到大于最大健康10%的伤害否则不会受到任何伤害|\n|意志|对昏迷效果免疫| | |\n|反击|当被对手重击石会快速发出下一招武功| | |\n|求生|当生命低于20%时生命会以最大生命的5%回复持续6秒| | |\n|复仇|当生命小于30%时武功招是攻击力*3| | |\n|备注：红字为稀有特性或特有特性，游戏前期一般情况下很难招收到，特有特性是特殊人物才有的特性，比如聚财是特殊人物钱广进的特性，其他人还没发现有过，特殊人物的特性有些是鸡肋但是特殊人物学习力也是一般弟子望尘莫及的。|"}]},{"type":"element","tag":"h3","props":{"id":"天下霸图"},"children":[{"type":"text","value":"天下霸图"}]},{"type":"element","tag":"h4","props":{"id":"设施建造"},"children":[{"type":"text","value":"设施建造"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在江湖上开帮立派，少不了规划一番，这可不是随随便便找几个人胡乱演练一下就能成功。趁着现下各大门派防守松懈之机，还是让我们一同来偷师一下，看看成立一个门派需要配置些怎样的家什。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总舵（开帮立派）：总舵是门派中的门主所在地，一旦总舵被人攻占，而门主恰恰在总舵中，那么整个门派都将随着门主的死去而马上灭亡。因此挑选总舵时最好找那些地图够大，建造面积够宽、资源丰富的地点，这样不仅发展潜力很大，而且在早期就可迅速完成门派核心设施的建设。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分舵（控制当地）：当攻下对手门派的地盘或到了一个尚未被人控制的地点，都可将它变为自己的分舵。分舵可在当地招收门徒并进行与主舵内容完全一致的各类练习和工作。分舵被人占领，不会影响门派的存亡，唯一要提醒各位的是，和总舵一样，每个分舵都必须最少任命一位舵主，假如需要还可以任命左右堂主。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正殿（门派标志）：正殿是门派内一切设施建造的前提，其代表了门派的存在，在这里可进行人事方面的任免，同时安排门徒在此听训，可以增加他们对门派的忠诚度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看板（招募弟子）：只要找好地点，开帮立派建好正殿之后，看板就会自动开始使用，天天看板上都会登出本门本派拉人入伙的公告。假如你的门派声望够高，就会有应征者前来此处报道。点选看板之后就可查看到应征者的资料，假如感觉满足，即可批准入门，让应征者正式成为门派一员，门派的声望越高，前来应征的人属性也就越强。但要提醒一下的是，天天最多只会有一名应征者前来应征，因此当需要很多弟子加入时，不妨多设一些分舵来扩大招人数量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"厢房（提供门徒弟子休息）：每一位门徒弟子感到疲惫时，都需要到厢房进行休息，否则将无法恢复体力和精神，并会因过度劳累而病到。由于一间厢房只能让一位门徒弟子休息，所以要想在总舵或分舵中招收更多的门徒弟子，就必须建造相应数量的厢房供他们休息。需要注重的是，在有空厢房时，招收进入的弟子会自动获得房间分配，但假如你进行过厢房拆除或房主指定等改变，那就必须手动为门徒弟子安排房间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"徒手武场（练习各种拳脚功夫）：当门徒弟子安排有徒手方面的武功练习时，将会前往徒手武场进行练习。同一徒手武场在同一时刻只能安排一位门徒弟子进行练习，因此假如想同时练习很多徒手武功的弟子，就必须建造多个徒手武场才能满足需要。徒手武场是门派中最基本的练武之地，必不可缺，一般以5个为宜。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"兵器武场（练习各类兵器刀棍暗器）：和徒手武场一样，同一兵器武场在同一时刻只能安排一位门徒弟子进行练习，因此假如需要练习的门徒弟子很多，就必须建造多个兵器武场才能满足需要。兵器武场也是门派中最基本的练武之地，一般以3个为宜。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"修炼室（闭关修炼武功）：武功是靠悟出来的，当门徒弟子的某项武功经验值较高时，安排他到修炼室闭关修炼将有可能悟出更加厉害的新武功来，或是撰写出武功秘籍。前者可让门徒弟子学会新的武功，并以此为下一次悟出更强的武功作为基础；后者则是可将武功秘籍交由其他同门师兄弟阅读，以迅速提升阅读者该武功的经验值。修炼室也是门派中最基本的练武之地，一般建2座就够了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"药圃（采集药材之地）：当总舵或分舵建造在有药材资源的地点时，就可以建造药圃进行采药。当地土壤的好坏会影响到药材的数量与品质，可依据炼丹所需药材进行建造。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"铸造房（打造武器暗器之地）：游戏中的大部分武器、暗器都需要自己生产才能获得，而铸造房正是为此而设，根据采集资源的不同生产出来的武器、暗器种类也不尽相同。铸造房有等级的设定，一共7级，每升1级，能够生产的物品等级也就越高，产品的价值也越高。所以要想获得强力的高等级武器，就需要不断进行铸造，以提高铸造房的等级。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"织造房（生产服饰之地）：可以生产衣服、鞋子、饰品等物品，但必须有足够的原料资源。和铸造房一样，织造房也有7个等级的设定，随着等级的提高，能够生产的物品等级也会越来越高，产品价值也就越高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"炼丹房（炼丹制药之地）：负责进行丹药的生产炼制。同样有着7个等级的设定，等级越高，所能炼制的丹药效果越好，因此也是游戏中必须建造的设施之一。"}]},{"type":"element","tag":"h4","props":{"id":"座次排定"},"children":[{"type":"text","value":"座次排定"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"江湖有江湖自己的规则，而这个规则之一就是座次的排定。虽说职位的选择相对少了很多，但不同的职位对门派的发展却有着不小的影响，因此绝对不能轻视。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门派掌门人就是总舵的舵主，而分舵的就需要自己来指定了。舵主的忠诚、聪明、健康会影响分舵弟子的生产效率，聪明和四大武功属性（攻击、防御、轻功、暗器）将影响弟子的练功效率，聪明和四力会影响弟子的采集效率；左堂主的聪明和四大武功属性会影响弟子的练功效率；右堂主的聪明和四大武功属性影响弟子的采集效率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在3种职位中，舵主必须指定，左、右堂主则可根据需要选择是否指定。但要提醒大家的是，职位的变更会影响到弟子的忠诚，被选为舵主的弟子可以增加20的忠诚度，选为左、右堂主的弟子则可增加10的忠诚度。"}]},{"type":"element","tag":"h4","props":{"id":"行程安排"},"children":[{"type":"text","value":"行程安排"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"身为门派掌门人，在风光的背后天天进行着怎样的工作呢？原来每位门人弟子都有12个小铜人，每个小铜人代表1个时辰，在进行行程安排时，在不同的任务栏内放入对应数量的小铜人，就代表这位门人弟子所需要进行这项工作的时间要求。和现实中的人一样，门人弟子在工作之后精力会下降，为了保证他们的状态，必须先留出4个小铜人（4个时辰）作为休息睡眠之用。这样可进行分配的小铜人还有8个，8个小铜人可根据苦力弟子、练功弟子等不同的修行需要放入对应栏目。但非凡要注重，受到任务场地空间的限制（门派设施同一时间内只答应一位弟子进入工作或练习），因而当弟子被安排了某项任务，却因场地没有空间而无法进入时，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"门人弟子就会在一旁发呆"}]},{"type":"text","value":"（头上有问号），"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"发呆同样会损耗精力，但对忠诚没有影响"}]},{"type":"text","value":"。但考虑到生产或练功的需要，当可以进行分舵扩张时，应根据功用的不同，把不同的分舵分为练功分舵、制造分舵或是采集分舵，这样才能在方便治理的同时，最大限度提高门派发展的效率。"}]},{"type":"element","tag":"h4","props":{"id":"对外交涉"},"children":[{"type":"text","value":"对外交涉"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与人为善本是处事之道，面对不同势力把持形成的江湖，怎样在发展中求生存？除去刀劈剑砍之外，广结善缘也不失为一种求存之道。在大多数时间里（第7式除外），江湖上其他门派的发展速度都要远超我们。面对来势汹汹的对手，假如你没有完全把握应对，那么不妨找一名聪明较高的门人弟子，带着金钱或原料资源前去交涉疏通，只要能让双方的友好度保持在40以上，那么得了好处的他也就不会再时刻想着前来对你展开武力行动了。虽然江湖中的十二大门派可分为正邪两道，但实际上无论是正是邪，彼此之间都不存在任何友谊，少林寺同样可能在一夜之间发动对武当山的偷袭，魔教也说不准转眼就杀进了洞庭帮的总舵。正是因此，不要幻想名门正派就一定会光明正大，广撒银钱，自求多福方是活命之选。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"天下霸图2","depth":3,"text":"天下霸图2"},{"id":"天下霸图","depth":3,"text":"天下霸图"}]}},"_type":"markdown","_id":"content:gyj:2022-11-01-天下霸图.md","_source":"content","_file":"gyj/2022-11-01-天下霸图.md","_extension":"md","date":"2022-11-01"},{"_path":"/gyj/2022-11-17-liufangzhilu","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"流放之路关于伤害公式和技能的分析","description":"属性流放之路中，升级你能得到什么？所有人物升级所获得的都是一样的A每级+12最大生命B每级+2命中值C每级+3闪避值D每级+6最大魔力E每级+1天赋点人物有三大基础属性：力量，敏捷，智慧每10力量=5生命每5力量=1%近战攻击伤害每10敏捷=1%闪避值每1敏捷=2命中值每5智力=1%增加最大能量护盾每2智力=1魔力a)基本属性i.每秒1.75%最大魔力上限回复速度ii.每秒20%最大能量护盾的充能速度iii.拥有基础的53闪避值iv.基础爆击伤害：150%b)双持（双持的定义在于同时持有2把单手武器，仅限于单手剑，细剑，单手锤，单手斧，匕首，爪，魔杖。其中魔杖属于远程武器，无法跟其他武器同时持","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"属性"},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"流放之路中，升级你能得到什么？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有人物升级所获得的都是一样的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A每级+12最大生命"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"B每级+2命中值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C每级+3闪避值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"D每级+6最大魔力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"E每级+1天赋点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"人物有三大基础属性：力量，敏捷，智慧"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每10力量=5生命"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每5力量=1%近战攻击伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每10敏捷=1%闪避值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每1敏捷=2命中值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每5智力=1%增加最大能量护盾"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每2智力=1魔力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a)基本属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"i.每秒1.75%最大魔力上限回复速度"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ii.每秒20%最大能量护盾的充能速度"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iii.拥有基础的53闪避值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iv.基础爆击伤害：150%"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"b)双持（双持的定义在于同时持有2把单手武器，仅限于单手剑，细剑，单手锤，单手斧，匕首，爪，魔杖。其中魔杖属于远程武器，无法跟其他武器同时持有）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"i.10%更多攻击速度"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ii.15%格挡"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iii.20%更多物理攻击伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c)能量球（看图）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-17-liufangzhilu/image002_S.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"d)基础最大值（以下数值都可能被一些暗金装备，天赋，进阶所改变）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"i.每秒20%最大生命偷取速率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ii.每秒20%最大魔力偷取速率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iii.75%最大格挡值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iv.75%最大混沌抗性上限"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"v.75%最大冰霜抗性上限"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"vi.75%最大火焰抗性上限"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"vii.75%最大闪电抗性上限"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"viii.最多叠加20层腐化之血状态"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ix.最多5层爆炸箭矢"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"x.最多75%攻击躲避几率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"xi.最多75%法术躲避几率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"xii.闪避几率不会低于5%，也不会高于95%（闪避不同于躲避）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"xiii.最大90%物理伤害减免"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"xiv.可拥有3个陷阱"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"xv.可拥有5个地雷"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"xvi.可召唤1个图腾"}]},{"type":"element","tag":"h3","props":{"id":"伤害公式"},"children":[{"type":"text","value":"伤害公式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"闪避是角色在受到攻击前的第一层防御形式，闪避会增加角色完全避免受到攻击的几率。与护甲和能量护盾一样，闪避是流放之路的三大基本防御形式之一。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有人物的基础闪避将以53点为开始，每级额外获得3点闪避。人物在一级时，将具有56点闪避，在100级时有353点闪避的基础值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"敏捷也能够提供闪避奖励。每增加5点敏捷，闪避将提高1%。5的非整数将四舍五入到最接近的5的整数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"闪避除了可以规避伤害，也可以规避其他有害影响，比如异常状态和眩晕。但是只能闪避近战和远程攻击，而法术则会自动命中。而闪避攻击的几率是根据防御者的闪避与攻击者的命中相比得出的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-17-liufangzhilu/1668611975000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"机制公式：命中率的范围：5%—95%。法术没有命中的机制，不受命中的影响，因为闪避不是对应法术对应的防御措施，也因为不会对法术产生影响，所以法术是默认必中的。（但也有办法: 躲避法术。请注意躲避和闪避的区别！）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"公式一："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-17-liufangzhilu/c041a4e6555bb73579e6ba5db93b72d8.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"公式二："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际命中率 = min{ max( 理论命中率 , 0.05) , 1 }。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.thisisdb.com/wd/172751.html","rel":["nofollow"]},"children":[{"type":"text","value":"流放之路伤害机制介绍 伤害怎么计算-《流放之路》s13新的诅咒机制有什么 s13新诅咒机制介绍 - DB游戏网 ("}]},{"type":"element","tag":"a","props":{"href":"http://thisisdb.com","rel":["nofollow"]},"children":[{"type":"text","value":"thisisdb.com"}]},{"type":"element","tag":"a","props":{"href":"https://www.thisisdb.com/wd/172751.html","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gl.ali213.net/html/2017-8/187449.html","rel":["nofollow"]},"children":[{"type":"text","value":"流放之路技能伤害计算公式一览 流放之路技能伤害怎么计算 法术类-游侠网 ("}]},{"type":"element","tag":"a","props":{"href":"http://ali213.net","rel":["nofollow"]},"children":[{"type":"text","value":"ali213.net"}]},{"type":"element","tag":"a","props":{"href":"https://gl.ali213.net/html/2017-8/187449.html","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/read/cv14058447/","rel":["nofollow"]},"children":[{"type":"text","value":"《流放之路》暴击和暴击伤害解析 - 哔哩哔哩 ("}]},{"type":"element","tag":"a","props":{"href":"http://bilibili.com","rel":["nofollow"]},"children":[{"type":"text","value":"bilibili.com"}]},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/read/cv14058447/","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://view.inews.qq.com/a/20220104A064SX00","rel":["nofollow"]},"children":[{"type":"text","value":"流放之路POE丨各类防御机制，浅谈各类防御机制的作用 ("}]},{"type":"element","tag":"a","props":{"href":"http://qq.com","rel":["nofollow"]},"children":[{"type":"text","value":"qq.com"}]},{"type":"element","tag":"a","props":{"href":"https://view.inews.qq.com/a/20220104A064SX00","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.18183.com/zqnews/201909/2391993.html","rel":["nofollow"]},"children":[{"type":"text","value":"流放之路伤害机制介绍_18183.com"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.ahjmgzs.com/yxgl/692583.html","rel":["nofollow"]},"children":[{"type":"text","value":"流放之路攻击伤害和物理伤害(流放之路伤害类型)-金芒果软件网 ("}]},{"type":"element","tag":"a","props":{"href":"http://ahjmgzs.com","rel":["nofollow"]},"children":[{"type":"text","value":"ahjmgzs.com"}]},{"type":"element","tag":"a","props":{"href":"https://www.ahjmgzs.com/yxgl/692583.html","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"属性","depth":3,"text":"属性"},{"id":"伤害公式","depth":3,"text":"伤害公式"}]}},"_type":"markdown","_id":"content:gyj:2022-11-17-liufangzhilu.md","_source":"content","_file":"gyj/2022-11-17-liufangzhilu.md","_extension":"md","date":"2022-11-17"},{"_path":"/gyj/2022-11-17-sect","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"门派内容相关","description":"正派门派声望很高,可以顶替门派掌门..反派门派可以欺师灭祖,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n必要建筑功用说明任务大厅接取任务,如果是帮主,可以查看委托委托(),接取修炼室修炼心法的地方门派商店就是门派卖东西的地方策略府研究门派策略的地方,代替建筑升级加成研究藏经阁玩家可以写秘籍,和学习秘籍演武场升级技能等级的地方角色属性\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n任务\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n任务类型内容效果押镖送货增加声望,增加金钱战斗增加声望,装备材料求助索要物资增加声望弟子培养差事\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正派门派声望很高,可以顶替门派掌门.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"反派门派可以欺师灭祖,"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"必要建筑"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"功用"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"任务大厅"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"接取任务,如果是帮主,可以查看委托"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"委托(),接取"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"修炼室"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"修炼心法的地方"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"门派商店"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"就是门派卖东西的地方"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"策略府"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"研究门派策略的地方,代替建筑升级加成"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"研究"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"藏经阁"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"玩家可以写秘籍,和学习秘籍"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"演武场"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"升级技能等级的地方"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h4","props":{"id":"角色属性"},"children":[{"type":"text","value":"角色属性"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h4","props":{"id":"任务"},"children":[{"type":"text","value":"任务"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"任务类型"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"内容"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"效果"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"押镖送货"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加声望,增加金钱"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"战斗"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加声望,装备材料"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"求助"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"索要物资"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加声望"}]}]}]}]},{"type":"element","tag":"h4","props":{"id":"弟子培养差事"},"children":[{"type":"text","value":"弟子培养差事"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"任务名称"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"花费时间"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"效果"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"促进思辨"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"人物经验+5%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"学习新技能"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"技能经验+5%"}]}]}]}]},{"type":"element","tag":"h4","props":{"id":"门派内差事"},"children":[{"type":"text","value":"门派内差事"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"任务名称"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"花费时间"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"效果"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"招募"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"助工"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"工坊产值+30%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"助医"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"炼丹产值+30%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"助农"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"粮食产值+30%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"采集药材+10%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"采集木材+10%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"采集矿产+10%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"开发黑市"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"贸易影响+50%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"街市繁荣"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"售卖收入+50%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"举孝廉"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满意度+10"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"运权"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"公共秩序+8"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:gyj:2022-11-17-sect.md","_source":"content","_file":"gyj/2022-11-17-sect.md","_extension":"md","date":"2022-11-17"},{"_path":"/gyj/2022-12-01-yangzhi","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"2022 12 01 养殖","description":"养殖动物\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n动物名称副产品猪猪尾巴牛牛奶鸡鸡蛋羊羊毛兔子兔脚鸭子鸭蛋建筑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n建筑名称低级食槽中级食槽高级食槽","body":{"type":"root","children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"养殖动物"},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"动物名称"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"副产品"}]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"猪"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"猪尾巴"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"牛"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"牛奶"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"鸡"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"鸡蛋"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"羊"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"羊毛"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"兔子"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"兔脚"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"鸭子"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"鸭蛋"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"建筑"},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"建筑名称"}]},{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"低级食槽"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"中级食槽"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"高级食槽"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:gyj:2022-12-01-养殖.md","_source":"content","_file":"gyj/2022-12-01-养殖.md","_extension":"md","date":"2022-12-01"},{"_path":"/gyj/2022-12-01-zhongzhi","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"种植","description":"","body":{"type":"root","children":[],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:gyj:2022-12-01-种植.md","_source":"content","_file":"gyj/2022-12-01-种植.md","_extension":"md","date":"2022-12-01"},{"_path":"/gyj/2022-12-15-renwushuxing","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"人物属性设计","description":"初始属性\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n属性说明元气,身法,力道初始自由分配点60最大生命值64内力值32体力100心情100命中值2暴击几率5%爆击伤害50%魔力回复速度每秒1.75%格挡率15%气质才情\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n属性说明悟性习武的时候提高的领悟力用来升级技能魅力影响他人的好感，在游戏中需要魅力高的内门弟子去各大门派攻破长老心防；需要魅力高的外门去代理点当主持机缘影响角色幸运。同时很多地图事件对机缘有要求，历练时获得物品的","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"初始属性"},"children":[{"type":"text","value":"初始属性"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"元气,身法,力道"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"初始自由分配点60"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"最大生命值"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"64"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"内力值"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"32"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"体力"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"100"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"心情"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"100"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"命中值"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"暴击几率"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"5%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"爆击伤害"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"50%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"魔力回复速度"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每秒1.75%"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"格挡率"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"15%"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"气质才情"},"children":[{"type":"text","value":"气质才情"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"悟性"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"习武的时候提高的领悟力"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用来升级技能"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"魅力"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"影响他人的好感，在游戏中需要魅力高的内门弟子去各大门派攻破长老心防；需要魅力高的外门去代理点当主持"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"机缘"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"影响角色幸运。同时很多地图事件对机缘有要求，历练时获得物品的概率也和机缘有关。"}]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"童趣"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"当角色"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"情绪过低"}]},{"type":"text","value":"，会引发一系列的问题：①外门怠工，外门弟子心情低于50，会导致怠工，自动不受控制的闲逛，得到休息后可恢复。②内门心魔，内门弟子长期心情过差（低于100），会导致修炼严重受挫，产生心魔，难以寸进。③弟子叛逃，长期遭受虐待而得不到改善时，弟子会选择叛逃。"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"角色的情绪稳定标准：最低限度为50，上限为200"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"正义"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"邪恶"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h2","props":{"id":"境界属性"},"children":[{"type":"text","value":"境界属性"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"武道"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用来提高武道境界"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每次升级力道+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"佛法"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用来提高佛法境界"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每次升级力道身法+5,力道+5,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"道法"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每次升级元气+5,身法+5,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"儒学"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每次升级元气+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"巫术"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每次升级元气+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"墨家"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"每次升级身法+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"生活属性"},"children":[{"type":"text","value":"生活属性"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"最大值"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"开山"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"采集矿物"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"扶农"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"收集粮食"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"本草"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"采集药品"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"斫木"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"砍伐木材"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"悬壶"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"炼制丹药"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"生财"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"贩卖商品"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"铸造"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"锻造装备"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"巧匠"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"制作工艺品"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"威望"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"可以当门派帮主之类的有额外加成"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"谋略"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"策略府"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"处世"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"处理任务"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"学识"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"书写秘籍"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"20"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"战斗属性"},"children":[{"type":"text","value":"战斗属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能标签 :"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"力道 身法 元气  (力量 敏捷 智力)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"火焰 冰冷 闪电 混沌  物理  (伤害类型)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"攻击加成  近战加成    元素加成   投射物加成 范围效果"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"光环   诅咒"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"持续时间"}]}]},{"type":"element","tag":"h3","props":{"id":"一级属性"},"children":[{"type":"text","value":"一级属性"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"元气"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加元气伤害的1%   增加1点护甲"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"力道"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加力道伤害的1%   增加1点护甲"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"身法"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加身法伤害的1%   增加0.1全抗"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"体质"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"10点气血值"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"根骨"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"5点内力值"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"二级属性"},"children":[{"type":"text","value":"二级属性"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"初始属性","depth":2,"text":"初始属性"},{"id":"气质才情","depth":2,"text":"气质才情"},{"id":"境界属性","depth":2,"text":"境界属性"},{"id":"生活属性","depth":2,"text":"生活属性"},{"id":"战斗属性","depth":2,"text":"战斗属性","children":[{"id":"一级属性","depth":3,"text":"一级属性"},{"id":"二级属性","depth":3,"text":"二级属性"}]}]}},"_type":"markdown","_id":"content:gyj:2022-12-15-人物属性.md","_source":"content","_file":"gyj/2022-12-15-人物属性.md","_extension":"md","date":"2022-12-15"},{"_path":"/gyj/2023-11-01-paoshang","_dir":"gyj","_draft":false,"_partial":false,"_locale":"","title":"跑商","description":"物品有最低价,平均价,标准价,每个城市有盛产,盛产的物品购买价格低每个城市有需求,玩家种植或者生成的物品,每个城市售卖4-5种,盛产的物品不一定会存在..但是存在的话一定是低价格..所以玩家,只要看到这个城市的盛产物品就买就可以了普通商品的差价应小于,玩家种植,砍伐挖掘,和生成的物品,每天各地的商品定价会在基础价格上下浮动10%左右。每周更换商品..行走消耗日程,ps:解锁功能,赶路也能修行心法每周先随机该城市所有商品的价格(上下浮动10%)和数量,以及是否需求.然后如果是盛产商品.则降低商品价格.如果周围的城市盛产该商品,也降低价格,然后随机需求的物品,然后提高收购价格","body":{"type":"root","children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物品有最低价,平均价,标准价,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个城市有盛产,盛产的物品购买价格低"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个城市有需求,玩家种植或者生成的物品,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个城市售卖4-5种,盛产的物品不一定会存在..但是存在的话一定是低价格..所以玩家,只要看到这个城市的盛产物品就买就可以了"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"普通商品的差价应小于,玩家种植,砍伐挖掘,和生成的物品,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每天各地的商品定价会在基础价格上下浮动10%左右。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每周更换商品..行走消耗日程,ps:解锁功能,赶路也能修行心法"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每周先随机该城市所有商品的价格(上下浮动10%)和数量,以及是否需求.然后如果是盛产商品.则降低商品价格.如果周围的城市盛产该商品,也降低价格,然后随机需求的物品,然后提高收购价格"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:gyj:2023-11-01-跑商.md","_source":"content","_file":"gyj/2023-11-01-跑商.md","_extension":"md","date":"2023-11-01"},{"_path":"/js/2022-02-12-typescript-use-js","_dir":"js","_draft":false,"_partial":false,"_locale":"","title":"如何在TypeScript中使用JS类库","description":"使用流程首先要清楚类库是什么类型，不同的类库有不同的使用方式寻找声明文件JS类库一般有三类：全局类库、模块类库、UMD库。例如，jQuery是一种UMD库，既可以通过全局方式来引用，也可以模块化引用。声明文件当我们要使用一个类库时，需要ts声明文件，对外暴露API，有时候声明文件在源码中，大部分是单独提供额外安装。比如jQuery需要额外安装类型声明包。幸运的是，大部分的类库，TS社区都有声明文件。名称为@types/类库名，需要去这个网站搜一下http://microsoft.github.io/TypeSearch/如果没有，需要自己去写一个，这也是为社区贡献的好机会。http://def","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"使用流程"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"使用流程"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"首先要清楚类库是什么类型，不同的类库有不同的使用方式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"寻找声明文件"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JS类库一般有三类：全局类库、模块类库、UMD库。例如，jQuery是一种UMD库，既可以通过全局方式来引用，也可以模块化引用。"}]},{"type":"element","tag":"h3","props":{"id":"声明文件"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"声明文件"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们要使用一个类库时，需要ts声明文件，对外暴露API，有时候声明文件在源码中，大部分是单独提供额外安装。比如jQuery需要额外安装类型声明包。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"幸运的是，大部分的类库，TS社区都有声明文件。名称为@types/类库名，需要去这个网站搜一下"},{"type":"element","tag":"a","props":{"href":"https://microsoft.github.io/TypeSearch/","rel":["nofollow"]},"children":[{"type":"text","value":"http://"}]},{"type":"element","tag":"a","props":{"href":"http://microsoft.github.io/TypeSearch/","rel":["nofollow"]},"children":[{"type":"text","value":"microsoft.github.io/TypeSearch/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果没有，需要自己去写一个，这也是为社区贡献的好机会。"},{"type":"element","tag":"a","props":{"href":"http://definitelytyped.org/guides/contributing.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://definitelytyped.org/guides/contributing.html"}]},{"type":"text","value":"这里提供了一些写声明文件的方法。在写ts声明文件的时候，暂时用不到的API可以可以不写。>"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面我将演示，如何在ts文件中使用三种类库。首先准备三个js文件，分别表示全局类库、模块类库、UMD库。"}]},{"type":"element","tag":"pre","props":{"code":"// 全局类库  global-lib.js\nfunction globalLib(options) {\n   console.log(options);\n}\nglobalLib.version = \"1.0.0\";\nglobalLib.doSomething = function () {\n   console.log('globalLib do something');\n};\n\n// 模块类库  module-lib.js\nconst version = \"1.0.0\";\nfunction doSomething() {\n   console.log('moduleLib do something');\n}\nfunction moduleLib(options) {\n   console.log(options);\n}\nmoduleLib.version = version;\nmoduleLib.doSomething = doSomething;\nmodule.exports = moduleLib;\n\n// UMD库  umd-lib.js\n(function (root, factory) {\n   if(typeof define === \"function\" && define.amd)\n   {\n      define(factory);\n   }else if(typeof module === \"object\" && module.exports)\n   {\n      module.exports = factory();\n   }else\n   {\n      root.umdLib = factory();\n   }\n})(this, function () {\n   return {\n      version: \"1.0.2\",\n      doSomething() {\n         console.log('umdLib do something');\n      }\n   }\n});\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 全局类库  global-lib.js\nfunction globalLib(options) {\n   console.log(options);\n}\nglobalLib.version = \"1.0.0\";\nglobalLib.doSomething = function () {\n   console.log('globalLib do something');\n};\n\n// 模块类库  module-lib.js\nconst version = \"1.0.0\";\nfunction doSomething() {\n   console.log('moduleLib do something');\n}\nfunction moduleLib(options) {\n   console.log(options);\n}\nmoduleLib.version = version;\nmoduleLib.doSomething = doSomething;\nmodule.exports = moduleLib;\n\n// UMD库  umd-lib.js\n(function (root, factory) {\n   if(typeof define === \"function\" && define.amd)\n   {\n      define(factory);\n   }else if(typeof module === \"object\" && module.exports)\n   {\n      module.exports = factory();\n   }else\n   {\n      root.umdLib = factory();\n   }\n})(this, function () {\n   return {\n      version: \"1.0.2\",\n      doSomething() {\n         console.log('umdLib do something');\n      }\n   }\n});\n"}]}]},{"type":"element","tag":"h2","props":{"id":"全局类库"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"全局类库"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在HTML文件标签中引入该库"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将写好的声明文件与js库放在同一文件夹下，命名相同，后缀名为.d.ts"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"此时可以在ts文件中使用全局API"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果此时编译器未报错，而浏览器报错not defined，可能是html中引入的路径是相对路径，改成绝对路径即可（以项目目录为根目录）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"声明文件global-lib.d.ts"}]},{"type":"element","tag":"pre","props":{"code":"declare function globalLib(options: globalLib.Options): void;\ndeclare namespace globalLib{\n   const version: string;\n   function doSomething(): void;\n   interface Options {\n      [key: string]: any,\n   }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"declare function globalLib(options: globalLib.Options): void;\ndeclare namespace globalLib{\n   const version: string;\n   function doSomething(): void;\n   interface Options {\n      [key: string]: any,\n   }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在ts文件中使用该库："}]},{"type":"element","tag":"pre","props":{"code":"globalLib({x:1});\nglobalLib.doSomething();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"globalLib({x:1});\nglobalLib.doSomething();\n"}]}]},{"type":"element","tag":"h2","props":{"id":"模块类库"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"模块类库"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将声明文件放在相同的目录下"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在ts中引入"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"声明文件 module-lib.d.ts"}]},{"type":"element","tag":"pre","props":{"code":"declare function moduleLib(options: Options): void;\ninterface Options {\n   [key: string]: any,\n}\ndeclare namespace moduleLib{\n   const version: string;\n   function doSomething(): void;\n}\nexport = moduleLib; // 这样写兼容性更好\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"declare function moduleLib(options: Options): void;\ninterface Options {\n   [key: string]: any,\n}\ndeclare namespace moduleLib{\n   const version: string;\n   function doSomething(): void;\n}\nexport = moduleLib; // 这样写兼容性更好\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ts中使用类库"}]},{"type":"element","tag":"pre","props":{"code":"import moduleLib from './Libs/module-lib.js';\nmoduleLib.doSomething();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import moduleLib from './Libs/module-lib.js';\nmoduleLib.doSomething();\n"}]}]},{"type":"element","tag":"h2","props":{"id":"umd类库"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UMD类库"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UMD库有两种使用方式："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"引入全局类库的方式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"模块类库引入的方式"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中，在使用全局类库的引入方式时，编译器会提示，不建议这样做，需要在tsconfig.json中打开allUmdGlobalAccess配置项可以消除提示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"声明文件 umd-lib.d.ts"}]},{"type":"element","tag":"pre","props":{"code":"declare namespace umdLib {\n   const version: string;\n   function doSomething(): void;\n}\nexport as namespace umdLib // 专门为umd库准备的语句，不可缺少\nexport = umdLib\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"declare namespace umdLib {\n   const version: string;\n   function doSomething(): void;\n}\nexport as namespace umdLib // 专门为umd库准备的语句，不可缺少\nexport = umdLib\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ts中使用UMD库（不再演示全局使用方式）"}]},{"type":"element","tag":"pre","props":{"code":"import umdLib from './Libs/umd-lib'\numdLib.doSomething();\nconsole.log(umdLib.version);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import umdLib from './Libs/umd-lib'\numdLib.doSomething();\nconsole.log(umdLib.version);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例：在ts中使用jQuery（不演示全局引入方式）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先安装jquery及其声明文件"}]},{"type":"element","tag":"pre","props":{"code":"npm install -D jquery @types/jquery\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"npm install -D jquery @types/jquery\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用："}]},{"type":"element","tag":"pre","props":{"code":"import $ from 'jquery';\n$(\".app\").css(\"color\",\"red\");\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import $ from 'jquery';\n$(\".app\").css(\"color\",\"red\");\n"}]}]},{"type":"element","tag":"h2","props":{"id":"为类库添加插件"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"为类库添加插件"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"即为类库添加自定义的方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中UMD库和模块类库的添加插件方法一致。"}]},{"type":"element","tag":"pre","props":{"code":"// 为全局类库增添自定义方法\ndeclare global {\n   namespace globalLib {\n      function myFunction(): void\n   }\n}\nglobalLib.myFunction = () =>{console.log(\"global插件\")};\n\n// 为模块类库添加自定义方法\ndeclare module \"./Libs/module-lib.js\"{\n   export function myFunction(): void;\n} // 为module-lib类库声明myFunction方法\nmoduleLib.myFunction = () => {console.log(\"module插件\")}; // 定义自定义方法\n\n// 为UMD库添加自定义方法\ndeclare module \"./Libs/umd-lib.js\"{\n   export function myFunction(): void;\n} // 为umd-lib类库声明myFunction方法\numdLib.myFunction = () => {console.log(\"umd插件\")}; // 定义自定义方法\n\nglobalLib.myFunction();\nmoduleLib.myFunction();\numdLib.myFunction();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 为全局类库增添自定义方法\ndeclare global {\n   namespace globalLib {\n      function myFunction(): void\n   }\n}\nglobalLib.myFunction = () =>{console.log(\"global插件\")};\n\n// 为模块类库添加自定义方法\ndeclare module \"./Libs/module-lib.js\"{\n   export function myFunction(): void;\n} // 为module-lib类库声明myFunction方法\nmoduleLib.myFunction = () => {console.log(\"module插件\")}; // 定义自定义方法\n\n// 为UMD库添加自定义方法\ndeclare module \"./Libs/umd-lib.js\"{\n   export function myFunction(): void;\n} // 为umd-lib类库声明myFunction方法\numdLib.myFunction = () => {console.log(\"umd插件\")}; // 定义自定义方法\n\nglobalLib.myFunction();\nmoduleLib.myFunction();\numdLib.myFunction();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，为类库moment增添自定义方法（jQuery不可以，需要使用官方提供的API）"}]},{"type":"element","tag":"pre","props":{"code":"npm install -D moment @types/moment\n\nimport m from 'moment';\ndeclare module 'moment'{\n   export function myFunction(): void;\n}\nm.myFunction = () => {console.log(\"moment插件\")};\n\nm.myFunction();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"npm install -D moment @types/moment\n\nimport m from 'moment';\ndeclare module 'moment'{\n   export function myFunction(): void;\n}\nm.myFunction = () => {console.log(\"moment插件\")};\n\nm.myFunction();\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"使用流程","depth":2,"text":"使用流程","children":[{"id":"声明文件","depth":3,"text":"声明文件"}]},{"id":"全局类库","depth":2,"text":"全局类库"},{"id":"模块类库","depth":2,"text":"模块类库"},{"id":"umd类库","depth":2,"text":"UMD类库"},{"id":"为类库添加插件","depth":2,"text":"为类库添加插件"}]}},"_type":"markdown","_id":"content:js:2022-02-12-TypeScript-use-Js.md","_source":"content","_file":"js/2022-02-12-TypeScript-use-Js.md","_extension":"md","date":"2022-02-12"},{"_path":"/js/2023-05-16-nuxt3-init-fail","_dir":"js","_draft":false,"_partial":false,"_locale":"","title":"nuxt3项目初始化失败","description":"执行npx nuxi init nuxt-app报错","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"问题"},"children":[{"type":"text","value":"问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npx nuxi init nuxt-app"}]},{"type":"text","value":"报错"}]},{"type":"element","tag":"h1","props":{"id":"解决方案"},"children":[{"type":"text","value":"解决方案"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"官方初始化链接："},{"type":"element","tag":"a","props":{"href":"https://link.juejin.cn/?target=https%3A%2F%2Fv3.nuxtjs.org%2Fgetting-started%2Finstallation","rel":["nofollow"]},"children":[{"type":"text","value":"v3.nuxtjs.org/getting-sta…"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npx nuxi init nuxt-app"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行后报错"}]},{"type":"element","tag":"pre","props":{"code":"Failed to download template from registry: request to https://raw.githubusercontent.com/nuxt/starter/templates/templates/v3.json failed, reason: connect ECONNREFUSED 0.0.0.0:443\n\n  at /Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/chunks/init.mjs:13269:11\n  at processTicksAndRejections (node:internal/process/task_queues:96:5)\n  at async downloadTemplate (/Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/chunks/init.mjs:13268:20)\n  at async Object.invoke (/Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/chunks/init.mjs:13336:15)\n  at async _main (/Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/cli.mjs:50:20)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Failed to download template from registry: request to https://raw.githubusercontent.com/nuxt/starter/templates/templates/v3.json failed, reason: connect ECONNREFUSED 0.0.0.0:443\n\n  at /Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/chunks/init.mjs:13269:11\n  at processTicksAndRejections (node:internal/process/task_queues:96:5)\n  at async downloadTemplate (/Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/chunks/init.mjs:13268:20)\n  at async Object.invoke (/Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/chunks/init.mjs:13336:15)\n  at async _main (/Users/ming/.npm/_npx/a95e0f536cf9a537/node_modules/nuxi/dist/cli.mjs:50:20)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ping raw.githubusercontent.com"}]},{"type":"text","value":"是否连通"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果不通，访问"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"https://ipaddress.com/website/raw.githubusercontent.com"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-05-16-nuxt3-init-fail/1684405553000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后添加host，mac下host配置路径："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/etc/hosts"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"新增一行， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"185.199.108.133 raw.githubusercontent.com"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"添加完host后，再ping一下 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ping raw.githubusercontent.com"}]},{"type":"text","value":" 是否连通"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ping通后，再重新执行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npx nuxi init nuxt-app"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"成功显示："}]},{"type":"element","tag":"pre","props":{"code":" Nuxt project is created with v3 template. Next steps:                                     12:07:07\n › cd nuxt-app                                                                               12:07:07\n › Install dependencies with npm install or yarn install or pnpm install --shamefully-hoist  12:07:07\n › Start development server with npm run dev or yarn dev or pnpm run dev\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" Nuxt project is created with v3 template. Next steps:                                     12:07:07\n › cd nuxt-app                                                                               12:07:07\n › Install dependencies with npm install or yarn install or pnpm install --shamefully-hoist  12:07:07\n › Start development server with npm run dev or yarn dev or pnpm run dev\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:js:2023-05-16-nuxt3-init-fail.md","_source":"content","_file":"js/2023-05-16-nuxt3-init-fail.md","_extension":"md","date":"2023-05-16"},{"_path":"/js/2024-03-17-flex-use","_dir":"js","_draft":false,"_partial":false,"_locale":"","title":"Flex 布局使用","description":"一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。\n.box{\n display: flex;\n}\n\n行内元素也可以使用 Flex 布局。\n.box{\n display: inline-flex;\n}\n\nWebkit 内核的浏览器，必须加上-webkit前缀。\n.box{\n display: -webkit-flex; /* Safari */\n display: flex;\n}\n\n注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"一flex-布局是什么"},"children":[{"type":"text","value":"一、Flex 布局是什么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任何一个容器都可以指定为 Flex 布局。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"pre","props":{"className":["language-css"],"code":"\n.box{\n display: flex;\n}\n\n","language":"css","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n.box{\n display: flex;\n}\n\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"行内元素也可以使用 Flex 布局。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"pre","props":{"className":["language-css"],"code":"\n.box{\n display: inline-flex;\n}\n\n","language":"css","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n.box{\n display: inline-flex;\n}\n\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Webkit 内核的浏览器，必须加上"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"-webkit"}]},{"type":"text","value":"前缀。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"pre","props":{"className":["language-css"],"code":"\n.box{\n display: -webkit-flex; /* Safari */\n display: flex;\n}\n\n","language":"css","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n.box{\n display: -webkit-flex; /* Safari */\n display: flex;\n}\n\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意，设为 Flex 布局以后，子元素的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"float"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"clear"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vertical-align"}]},{"type":"text","value":"属性将失效。"}]},{"type":"element","tag":"h2","props":{"id":"二基本概念"},"children":[{"type":"text","value":"二、基本概念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2024-03-17-flex-use/51PtxZl.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"main start"}]},{"type":"text","value":"，结束位置叫做"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"main end"}]},{"type":"text","value":"；交叉轴的开始位置叫做"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cross start"}]},{"type":"text","value":"，结束位置叫做"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cross end"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"项目默认沿主轴排列。单个项目占据的主轴空间叫做"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"main size"}]},{"type":"text","value":"，占据的交叉轴空间叫做"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cross size"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2024-03-17-flex-use/VFpkfNe.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一flex-布局是什么","depth":2,"text":"一、Flex 布局是什么？"},{"id":"二基本概念","depth":2,"text":"二、基本概念"}]}},"_type":"markdown","_id":"content:js:2024-03-17-flex-use.md","_source":"content","_file":"js/2024-03-17-flex-use.md","_extension":"md","date":"2024-03-17"},{"_path":"/tool/2019-06-20-windows-send-to-ftp","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"windows发送到手机Ftp","description":"右键发送到菜单位置右键点击系统桌面左下角的【开始】，在开始菜单中点击【运行】，在运行对话框中输入：shell:sendto命令,点击确定或者回车，打开SendTo（发送到）窗口；或者直接打开 目录\ninvoke-item \"C:\\Users\\zhepama\\AppData\\Roaming\\Microsoft\\Windows\\SendTo\"\n\n","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"右键发送到菜单位置"},"children":[{"type":"text","value":"右键发送到菜单位置"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"右键点击系统桌面左下角的【开始】，在开始菜单中点击【运行】，"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在运行对话框中输入："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"shell:sendto"}]},{"type":"text","value":"命令,点击确定或者回车，打开SendTo（发送到）窗口；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"或者直接打开 目录"},{"type":"element","tag":"pre","props":{"className":["language-powershell"],"code":"\ninvoke-item \"C:\\Users\\zhepama\\AppData\\Roaming\\Microsoft\\Windows\\SendTo\"\n\n","language":"powershell","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\ninvoke-item \"C:\\Users\\zhepama\\AppData\\Roaming\\Microsoft\\Windows\\SendTo\"\n\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-06-20-windows-send-to-ftp/2019-06-21-18-29-28.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"右键发送到菜单位置","depth":2,"text":"右键发送到菜单位置"}]}},"_type":"markdown","_id":"content:tool:2019-06-20-windows-send-to-ftp.md","_source":"content","_file":"tool/2019-06-20-windows-send-to-ftp.md","_extension":"md","date":"2019-06-20"},{"_path":"/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"windows特殊目录修复","description":"Desktop.ini Contents for Various Shell FoldersFor Windows 7Contacts[.ShellClassInfo]\nLocalizedResourceName=@%CommonProgramFiles%\\system\\wab32res.dll,-10100\nInfoTip=@%CommonProgramFiles%\\system\\wab32res.dll,-10200\nIconResource=%SystemRoot%\\system32\\imageres.dll,-181\nDocuments[.ShellClassInfo]\nLocaliz","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"desktopini-contents-for-various-shell-folders"},"children":[{"type":"text","value":"Desktop.ini Contents for Various Shell Folders"}]},{"type":"element","tag":"h3","props":{"id":"for-windows-7"},"children":[{"type":"text","value":"For Windows 7"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Contacts"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%CommonProgramFiles%\\system\\wab32res.dll,-10100\nInfoTip=@%CommonProgramFiles%\\system\\wab32res.dll,-10200\nIconResource=%SystemRoot%\\system32\\imageres.dll,-181\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%CommonProgramFiles%\\system\\wab32res.dll,-10100\nInfoTip=@%CommonProgramFiles%\\system\\wab32res.dll,-10200\nIconResource=%SystemRoot%\\system32\\imageres.dll,-181\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Documents"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21770\nIconResource=%SystemRoot%\\system32\\imageres.dll,-112\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-235\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21770\nIconResource=%SystemRoot%\\system32\\imageres.dll,-112\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-235\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Desktop"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21769\nIconResource=%SystemRoot%\\system32\\imageres.dll,-183\n[LocalizedFileNames]\nGameExplorer.lnk=@%SystemRoot%\\system32\\gameux.dll,-10082\nWindows Media Player.lnk=@%SystemRoot%\\system32\\unregmp2.exe,-4\nChess.lnk=@%SystemRoot%\\system32\\gameux.dll,-10054\nFreeCell.lnk=@%SystemRoot%\\system32\\gameux.dll,-10055\nHearts.lnk=@%SystemRoot%\\system32\\gameux.dll,-10056\nInternet Checkers.lnk=@%SystemRoot%\\system32\\gameux.dll,-10101\nMinesweeper.lnk=@%SystemRoot%\\system32\\gameux.dll,-10057\nSpider Solitaire.lnk=@%SystemRoot%\\system32\\gameux.dll,-10061\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21769\nIconResource=%SystemRoot%\\system32\\imageres.dll,-183\n[LocalizedFileNames]\nGameExplorer.lnk=@%SystemRoot%\\system32\\gameux.dll,-10082\nWindows Media Player.lnk=@%SystemRoot%\\system32\\unregmp2.exe,-4\nChess.lnk=@%SystemRoot%\\system32\\gameux.dll,-10054\nFreeCell.lnk=@%SystemRoot%\\system32\\gameux.dll,-10055\nHearts.lnk=@%SystemRoot%\\system32\\gameux.dll,-10056\nInternet Checkers.lnk=@%SystemRoot%\\system32\\gameux.dll,-10101\nMinesweeper.lnk=@%SystemRoot%\\system32\\gameux.dll,-10057\nSpider Solitaire.lnk=@%SystemRoot%\\system32\\gameux.dll,-10061\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Downloads"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21798\nIconResource=%SystemRoot%\\system32\\imageres.dll,-184\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21798\nIconResource=%SystemRoot%\\system32\\imageres.dll,-184\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Favorites"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21796\nIconResource=%SystemRoot%\\system32\\imageres.dll,-115\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-173\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21796\nIconResource=%SystemRoot%\\system32\\imageres.dll,-115\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-173\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Links"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21810\nIconResource=%SystemRoot%\\system32\\imageres.dll,-185\nDefaultDropEffect=4\n[LocalizedFileNames]\nRecentPlaces.lnk=@shell32.dll,-37217\nDesktop.lnk=@shell32.dll,-21769\nDownloads.lnk=@shell32.dll,-21798\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21810\nIconResource=%SystemRoot%\\system32\\imageres.dll,-185\nDefaultDropEffect=4\n[LocalizedFileNames]\nRecentPlaces.lnk=@shell32.dll,-37217\nDesktop.lnk=@shell32.dll,-21769\nDownloads.lnk=@shell32.dll,-21798\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Music"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21790\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12689\nIconResource=%SystemRoot%\\system32\\imageres.dll,-108\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-237\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21790\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12689\nIconResource=%SystemRoot%\\system32\\imageres.dll,-108\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-237\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Pictures"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21779\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12688\nIconResource=%SystemRoot%\\system32\\imageres.dll,-113\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-236\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21779\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12688\nIconResource=%SystemRoot%\\system32\\imageres.dll,-113\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-236\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Recent"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21797\nInfoTip=@shell32,dll,-12692\nIconResource=%SystemRoot%\\system32\\imageres.dll,-117\nCLSID={0C39A5CF-1A7A-40C8-BA74-8900E6DF5FCD}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21797\nInfoTip=@shell32,dll,-12692\nIconResource=%SystemRoot%\\system32\\imageres.dll,-117\nCLSID={0C39A5CF-1A7A-40C8-BA74-8900E6DF5FCD}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Saved Games"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21814\nIconResource=%SystemRoot%\\system32\\imageres.dll,-186\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21814\nIconResource=%SystemRoot%\\system32\\imageres.dll,-186\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Searches"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-9031\nIconResource=%SystemRoot%\\system32\\imageres.dll,-18\n[LocalizedFileNames]\nIndexed Locations.search-ms=@searchfolder.dll,-32820\nEverywhere.search-ms=@searchfolder.dll,-32822\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-9031\nIconResource=%SystemRoot%\\system32\\imageres.dll,-18\n[LocalizedFileNames]\nIndexed Locations.search-ms=@searchfolder.dll,-32820\nEverywhere.search-ms=@searchfolder.dll,-32822\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h3","props":{"id":"for-windows-vista"},"children":[{"type":"text","value":"For Windows Vista"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Documents"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21770\nIconResource=%SystemRoot%\\system32\\imageres.dll,-112\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-235\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21770\nIconResource=%SystemRoot%\\system32\\imageres.dll,-112\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-235\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Pictures"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21779\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12688\nIconResource=%SystemRoot%\\system32\\imageres.dll,-113\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-236\n[LocalizedFileNames]\nSample Pictures.lnk=@%SystemRoot%\\system32\\shell32.dll,-21805\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21779\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12688\nIconResource=%SystemRoot%\\system32\\imageres.dll,-113\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-236\n[LocalizedFileNames]\nSample Pictures.lnk=@%SystemRoot%\\system32\\shell32.dll,-21805\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Music"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21790\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12689\nIconResource=%SystemRoot%\\system32\\imageres.dll,-108\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-237\n[LocalizedFileNames]\nSample Music.lnk=@%SystemRoot%\\system32\\shell32.dll,-21806\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21790\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12689\nIconResource=%SystemRoot%\\system32\\imageres.dll,-108\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-237\n[LocalizedFileNames]\nSample Music.lnk=@%SystemRoot%\\system32\\shell32.dll,-21806\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Videos"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21791\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12690\nIconResource=%SystemRoot%\\system32\\imageres.dll,-189\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-238\n[LocalizedFileNames]\nSample Videos.lnk=@%SystemRoot%\\system32\\shell32.dll,-21807\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21791\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12690\nIconResource=%SystemRoot%\\system32\\imageres.dll,-189\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-238\n[LocalizedFileNames]\nSample Videos.lnk=@%SystemRoot%\\system32\\shell32.dll,-21807\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Searches"}]},{"type":"text","value":"report this ad"}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-9031\nIconResource=%SystemRoot%\\system32\\imageres.dll,-18\n[LocalizedFileNames]\nIndexed Locations.search-ms=@shell32.dll,-32811\nEverywhere.search-ms=@shell32.dll,-32814\nShared By Me.search-ms=@shell32.dll,-32802\nRecent Music.search-ms=@shell32.dll,-32803\nRecent Documents.search-ms=@shell32.dll,-32804\nRecent Pictures and Videos.search-ms=@shell32.dll,-32806\nRecent E-mail.search-ms=@shell32.dll,-32807\nRecently Changed.search-ms=@shell32.dll,-32813\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-9031\nIconResource=%SystemRoot%\\system32\\imageres.dll,-18\n[LocalizedFileNames]\nIndexed Locations.search-ms=@shell32.dll,-32811\nEverywhere.search-ms=@shell32.dll,-32814\nShared By Me.search-ms=@shell32.dll,-32802\nRecent Music.search-ms=@shell32.dll,-32803\nRecent Documents.search-ms=@shell32.dll,-32804\nRecent Pictures and Videos.search-ms=@shell32.dll,-32806\nRecent E-mail.search-ms=@shell32.dll,-32807\nRecently Changed.search-ms=@shell32.dll,-32813\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Downloads"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21798\nIconResource=%SystemRoot%\\system32\\imageres.dll,-184\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21798\nIconResource=%SystemRoot%\\system32\\imageres.dll,-184\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Favorites"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21796\nIconResource=%SystemRoot%\\system32\\imageres.dll,-115\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-173\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21796\nIconResource=%SystemRoot%\\system32\\imageres.dll,-115\nIconFile=%SystemRoot%\\system32\\shell32.dll\nIconIndex=-173\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Contacts"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%CommonProgramFiles%\\system\\wab32res.dll,-10100\nInfoTip=@%CommonProgramFiles%\\system\\wab32res.dll,-10200\nIconResource=%SystemRoot%\\system32\\imageres.dll,-181\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%CommonProgramFiles%\\system\\wab32res.dll,-10100\nInfoTip=@%CommonProgramFiles%\\system\\wab32res.dll,-10200\nIconResource=%SystemRoot%\\system32\\imageres.dll,-181\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Desktop"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21769\nIconResource=%SystemRoot%\\system32\\imageres.dll,-183\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21769\nIconResource=%SystemRoot%\\system32\\imageres.dll,-183\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Links"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21810\nIconResource=%SystemRoot%\\system32\\imageres.dll,-185\nDefaultDropEffect=4\n[LocalizedFileNames]\nPublic.lnk=@shell32.dll,-21816\nSearches.lnk=@shell32.dll,-9031\nRecently Changed.lnk=@shell32.dll,-32813\nMusic.lnk=@shell32.dll,-21790\nPictures.lnk=@shell32.dll,-21779\nDocuments.lnk=@shell32.dll,-21770\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21810\nIconResource=%SystemRoot%\\system32\\imageres.dll,-185\nDefaultDropEffect=4\n[LocalizedFileNames]\nPublic.lnk=@shell32.dll,-21816\nSearches.lnk=@shell32.dll,-9031\nRecently Changed.lnk=@shell32.dll,-32813\nMusic.lnk=@shell32.dll,-21790\nPictures.lnk=@shell32.dll,-21779\nDocuments.lnk=@shell32.dll,-21770\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Saved Games"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21814\nIconResource=%SystemRoot%\\system32\\imageres.dll,-186\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21814\nIconResource=%SystemRoot%\\system32\\imageres.dll,-186\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Public Desktop"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21799\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21799\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Public Documents"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21801\nIconResource=%SystemRoot%\\system32\\shell32.dll,-235\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21801\nIconResource=%SystemRoot%\\system32\\shell32.dll,-235\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Public Music"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21803\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12689\nIconResource=%SystemRoot%\\system32\\shell32.dll,-237\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21803\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12689\nIconResource=%SystemRoot%\\system32\\shell32.dll,-237\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Public Pictures"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21802\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12688\nIconResource=%SystemRoot%\\system32\\shell32.dll,-236\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21802\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12688\nIconResource=%SystemRoot%\\system32\\shell32.dll,-236\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Public Videos"}]}]},{"type":"element","tag":"pre","props":{"code":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21804\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12690\nIconResource=%SystemRoot%\\system32\\shell32.dll,-238\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[.ShellClassInfo]\nLocalizedResourceName=@%SystemRoot%\\system32\\shell32.dll,-21804\nInfoTip=@%SystemRoot%\\system32\\shell32.dll,-12690\nIconResource=%SystemRoot%\\system32\\shell32.dll,-238\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"desktopini-contents-for-various-shell-folders","depth":2,"text":"Desktop.ini Contents for Various Shell Folders","children":[{"id":"for-windows-7","depth":3,"text":"For Windows 7"},{"id":"for-windows-vista","depth":3,"text":"For Windows Vista"}]}]}},"_type":"markdown","_id":"content:tool:2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows.md","_source":"content","_file":"tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows.md","_extension":"md","date":"2019-06-24"},{"_path":"/tool/2019-08-07-sourcetree-git-password","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"scourcetree  总是需要输入密码","description":"Git密钥存储相关幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：默认所有都不缓存。 每一次连接都会询问你的用户名和密码。“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"git密钥存储相关"},"children":[{"type":"text","value":"Git密钥存储相关"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"默认所有都不缓存。 每一次连接都会询问你的用户名和密码。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果你使用的是 Windows，你可以安装一个叫做 “winstore” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。 可以在 "},{"type":"element","tag":"a","props":{"href":"https://gitcredentialstore.codeplex.com/","rel":["nofollow"]},"children":[{"type":"text","value":"https://gitcredentialstore.codeplex.com"}]},{"type":"text","value":" 下载。"}]}]},{"type":"element","tag":"h2","props":{"id":"推荐使用凭证存储模式-manager"},"children":[{"type":"text","value":"推荐使用凭证存储模式 \"manager\""}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在这里对比 \"wincred\" 和 \"manager\"的区别"}]},{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"-   **相同点：**\n\n-\n\n    -   都会将用户信息存储到Windows凭据管理器中\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-   **相同点：**\n\n-\n\n    -   都会将用户信息存储到Windows凭据管理器中\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"-   **不同点：**\n\n-\n\n    -   Windows凭据管理器中**用户信息是否加密**\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-   **不同点：**\n\n-\n\n    -   Windows凭据管理器中**用户信息是否加密**\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"-\n\n    -   \"wincred\" 模式下的用户信息展示如下\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-\n\n    -   \"wincred\" 模式下的用户信息展示如下\n"}]}]},{"type":"element","tag":"pre","props":{"code":"Internet 地址或网络地址：git:https://用户名@github.com； \n用户名：真实用户名 \n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Internet 地址或网络地址：git:https://用户名@github.com； \n用户名：真实用户名 \n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"-\n\n    -   \"manager\" 模式下的用户信息展示如下\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-\n\n    -   \"manager\" 模式下的用户信息展示如下\n"}]}]},{"type":"element","tag":"pre","props":{"code":"Internet 地址或网络地址：git:https://github.com； \n用户名：PersonalAccessToken\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Internet 地址或网络地址：git:https://github.com； \n用户名：PersonalAccessToken\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"很明显，在"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"用户信息暴露"}]},{"type":"text","value":"的情况下，其他人很容易通过 "},{"type":"element","tag":"a","props":{"href":"https://%E7%94%A8%E6%88%B7%E5%90%8D@%5Bhttp://github.com%5D(https://link.zhihu.com/?target=http%3A//github.com)","rel":["nofollow"]},"children":[{"type":"text","value":"https://用户名@[http://github.com](https://link.zhihu.com/?target=http%3A//github.com)"}]},{"type":"text","value":" 访问到路径对应的项目，为了避免这种"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"风险"}]},{"type":"text","value":"的存在，我们可以安装 “Git Credential Manager for Windows” 的辅助工具。"}]}]},{"type":"element","tag":"h3","props":{"id":"store的使用"},"children":[{"type":"text","value":"store的使用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"git config --global credential.helper store "}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“store” 模式可以接受一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"--file <path>"}]},{"type":"text","value":" 参数，可以自定义存放密码的文件路径（默认是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"~/.git-credentials"}]},{"type":"text","value":" ）"}]},{"type":"element","tag":"h3","props":{"id":"微软特有的git-credential-manager"},"children":[{"type":"text","value":"微软特有的Git Credential Manager"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WINDOS部分版本的GIT会提示"}]},{"type":"element","tag":"pre","props":{"code":"git: 'credential-cache' is not a git command. See 'get --help'.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git: 'credential-cache' is not a git command. See 'get --help'.\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上是缺少微软的 Git Credential Manager"}]},{"type":"element","tag":"h4","props":{"id":"安裝-git-credential-manager-for-windows解决"},"children":[{"type":"text","value":"安裝 Git Credential Manager for Windows解决"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最新的下载地址为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下载安装完后可以通过命令进行查看是否生效"}]},{"type":"element","tag":"pre","props":{"code":"git config --global credential.helper manager\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git config --global credential.helper manager\n"}]}]},{"type":"element","tag":"h4","props":{"id":"安裝-git-credential-manager-core解决"},"children":[{"type":"text","value":"安裝 Git-Credential-Manager-Core解决"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最新的下载地址为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/microsoft/Git-Credential-Manager-Core","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/microsoft/Git-Credential-Manager-Core"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下载安装完后可以通过命令进行查看是否生效"}]},{"type":"element","tag":"pre","props":{"code":"git config --global credential.helper manager-core\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git config --global credential.helper manager-core\n"}]}]},{"type":"element","tag":"h4","props":{"id":"检查验证工具是否在path中"},"children":[{"type":"text","value":"检查验证工具是否在path中"}]},{"type":"element","tag":"pre","props":{"code":"git config --system --list\n\ncore.symlinks=false\ncore.autocrlf=true\ncore.fscache=true\ncolor.diff=auto\ncolor.status=auto\ncolor.branch=auto\ncolor.interactive=true\nhelp.format=html\ndiff.astextplain.textconv=astextplain\nrebase.autosquash=true\nfilter.lfs.clean=git-lfs clean -- %f\nfilter.lfs.smudge=git-lfs smudge -- %f\nfilter.lfs.process=git-lfs filter-process\nfilter.lfs.required=true\ncredential.helper=!\"D:/Application/Scoop/apps/git/2.32.0.windows.1/mingw64/libexec/git-core/git-credential-manager-core.exe\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git config --system --list\n\ncore.symlinks=false\ncore.autocrlf=true\ncore.fscache=true\ncolor.diff=auto\ncolor.status=auto\ncolor.branch=auto\ncolor.interactive=true\nhelp.format=html\ndiff.astextplain.textconv=astextplain\nrebase.autosquash=true\nfilter.lfs.clean=git-lfs clean -- %f\nfilter.lfs.smudge=git-lfs smudge -- %f\nfilter.lfs.process=git-lfs filter-process\nfilter.lfs.required=true\ncredential.helper=!\"D:/Application/Scoop/apps/git/2.32.0.windows.1/mingw64/libexec/git-core/git-credential-manager-core.exe\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果提交的时候仍有问题,提示xxxxcommad不可用.查看下你现在使用的credential.helper是否在path中.如果不在则进行手动添加"}]},{"type":"element","tag":"pre","props":{"code":"D:\\Application\\Scoop\\apps\\git\\2.32.0.windows.1\\mingw64\\libexec\\git-core\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"D:\\Application\\Scoop\\apps\\git\\2.32.0.windows.1\\mingw64\\libexec\\git-core\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用的是sourcetree 还得查看,他默认使用的git是不是全局的"}]},{"type":"element","tag":"h1","props":{"id":"sourcetree删除git密码"},"children":[{"type":"text","value":"SourceTree删除GIT密码"}]},{"type":"element","tag":"h2","props":{"id":"store"},"children":[{"type":"text","value":"store"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"删除~/.git-credentials"}]},{"type":"element","tag":"h2","props":{"id":"manager"},"children":[{"type":"text","value":"manager"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"windows存储的初始密码账号不对，导致每次请求远程url都会报错，我们要到控制面板\\用户帐户\\凭据管理器中手动更改我们的credential凭证;如下，是我的凭证配置；只需要编辑下即可，当然你也可以删除你要请求的远程的凭证,我没试过，当你git pull，GIT会让你输入一次用户明和密码，以后每次请求，GIT会从windows凭证中查找；"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2019-08-07-sourcetree-git-password/20190404111514753.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"其他"},"children":[{"type":"text","value":"其他"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当GIT服务器修改密码后，sourcetree本地记住的密码，会导致提交代码失败。\n本地删除当前用户目录下保存密码的文件，文件路径：\nC:\\Users\\wuxiaoyuan\\AppData\\Local\\Atlassian\\SourceTree\\passwd\n清空文件内容即可"}]},{"type":"element","tag":"h1","props":{"id":"同网站多账号的问题"},"children":[{"type":"text","value":"同网站多账号的问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果同一个网站有多个账号..查看->选项->验证"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"编辑那个网站的账号,就会新建一个用户名@xxx.com的账号"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后把那个公用的删除"}]}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8","rel":["nofollow"]},"children":[{"type":"text","value":"https://git-scm.com/book/zh/v2/Git-工具-凭证存储"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"git密钥存储相关","depth":2,"text":"Git密钥存储相关"},{"id":"推荐使用凭证存储模式-manager","depth":2,"text":"推荐使用凭证存储模式 \"manager\"","children":[{"id":"store的使用","depth":3,"text":"store的使用"},{"id":"微软特有的git-credential-manager","depth":3,"text":"微软特有的Git Credential Manager"}]},{"id":"store","depth":2,"text":"store"},{"id":"manager","depth":2,"text":"manager"},{"id":"其他","depth":2,"text":"其他"},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:tool:2019-08-07-sourcetree-git-password.md","_source":"content","_file":"tool/2019-08-07-sourcetree-git-password.md","_extension":"md","date":"2019-08-07"},{"_path":"/tool/2019-08-10-powershell-command","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"powershell 常用命令","description":"常用命令Get-PSDrive  Windows PowerShell 驱动器是一个数据存储位置，你可以像访问 Windows PowerShell 中的文件系统驱动器那样访问它。Get-Alias 和   ls Alias:(驱动器)     列出所有aliasls Env:(驱动器)    列出所有的环境变量ls Variable:(驱动器) 和 Get-Variable 列出所有的变量ls Function:(驱动器)  列出所有的函数get-command   查看命令信息 可以查看某个命令的path  get-command mysqldumpinvoke-item  向window","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"常用命令"},"children":[{"type":"text","value":"常用命令"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get-PSDrive  Windows PowerShell 驱动器是一个数据存储位置，你可以像访问 Windows PowerShell 中的文件系统驱动器那样访问它。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get-Alias 和   ls Alias:(驱动器)     列出所有alias"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ls Env:(驱动器)    列出所有的环境变量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ls Variable:(驱动器) 和 Get-Variable 列出所有的变量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ls Function:(驱动器)  列出所有的函数"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"get-command   查看命令信息 可以查看某个命令的path  get-command mysqldump"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"invoke-item  向windows桌面双击操作一样打开某个文件或者目录"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"$env -split \";\"  以列表形式列出所有path"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ls env:    列出env驱动器中的内容"}]},{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"```powershell\n $path = [environment]::GetEnvironmentvariable(\"path\",\"user\")\n [environment]::SetEnvironmentvariable(\"Path\", $path+\";c:\\powershellscript\", \"User\")\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"```powershell\n $path = [environment]::GetEnvironmentvariable(\"path\",\"user\")\n [environment]::SetEnvironmentvariable(\"Path\", $path+\";c:\\powershellscript\", \"User\")\n"}]}]},{"type":"element","tag":"pre","props":{"code":"\n# Running PowerShell Scripts From C#\n\n使用`-Command`参数，传递简单的字符串。 可以使用`-File`参数,传递一个ps脚本。 如果需要传递复杂（或者可能是换行符）的脚本文本，可以使用`-EncodedCommand`参数，它接受Base64编码的内容。\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n# Running PowerShell Scripts From C#\n\n使用`-Command`参数，传递简单的字符串。 可以使用`-File`参数,传递一个ps脚本。 如果需要传递复杂（或者可能是换行符）的脚本文本，可以使用`-EncodedCommand`参数，它接受Base64编码的内容。\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"void NoError()\n{\nvar command = @\"pwd\";\nvar startInfo = new ProcessStartInfo()\n{\nFileName = \"powershell.exe\",\nArguments = $\"-NoProfile -ExecutionPolicy unrestricted -Command \"{command}\"\",\nUseShellExecute = false\n};\nProcess.Start(startInfo);\n}"}]},{"type":"element","tag":"pre","props":{"code":"\n执行一个ps文件:\n\n```csharp\nvoid NoError()\n{\n    var ps1File = @\"C:\\my script folder\\script.ps1\";\n    var startInfo = new ProcessStartInfo()\n    {\n        FileName = \"powershell.exe\",\n        Arguments = $\"-NoProfile -ExecutionPolicy unrestricted -file \\\"{ps1File}\\\"\",\n        UseShellExecute = false\n    };\n    Process.Start(startInfo);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n执行一个ps文件:\n\n```csharp\nvoid NoError()\n{\n    var ps1File = @\"C:\\my script folder\\script.ps1\";\n    var startInfo = new ProcessStartInfo()\n    {\n        FileName = \"powershell.exe\",\n        Arguments = $\"-NoProfile -ExecutionPolicy unrestricted -file \\\"{ps1File}\\\"\",\n        UseShellExecute = false\n    };\n    Process.Start(startInfo);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先编码执行一个复杂的命令:"}]},{"type":"element","tag":"pre","props":{"code":"void Base64EncodedCommand()\n{\n    var psCommmand = @\"echo \"\"quoted value\"\" \n    echo \"\"Second Line\"\"\n    pause\";\n    var psCommandBytes = System.Text.Encoding.Unicode.GetBytes(psCommmand);\n    var psCommandBase64 = Convert.ToBase64String(psCommandBytes);\n\n    var startInfo = new ProcessStartInfo()\n    {\n        FileName = \"powershell.exe\",\n        Arguments = $\"-NoProfile -ExecutionPolicy unrestricted -EncodedCommand {psCommandBase64}\",\n        UseShellExecute = false\n    };\n    Process.Start(startInfo);\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void Base64EncodedCommand()\n{\n    var psCommmand = @\"echo \"\"quoted value\"\" \n    echo \"\"Second Line\"\"\n    pause\";\n    var psCommandBytes = System.Text.Encoding.Unicode.GetBytes(psCommmand);\n    var psCommandBase64 = Convert.ToBase64String(psCommandBytes);\n\n    var startInfo = new ProcessStartInfo()\n    {\n        FileName = \"powershell.exe\",\n        Arguments = $\"-NoProfile -ExecutionPolicy unrestricted -EncodedCommand {psCommandBase64}\",\n        UseShellExecute = false\n    };\n    Process.Start(startInfo);\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"使用c类调用powershell-命令"},"children":[{"type":"text","value":"使用c#类调用powershell 命令"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-powershell-command/image.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接著我們在 Program.cs 檔案引用兩個命名空間如下："}]},{"type":"element","tag":"pre","props":{"code":"using System.Management.Automation;\nusing System.Management.Automation.Runspaces;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Management.Automation;\nusing System.Management.Automation.Runspaces;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大功告成，現在你可以將 PowerShell 指令整合到你的 C# 應用程式中了！"}]},{"type":"element","tag":"pre","props":{"code":"using (PowerShell powershell = PowerShell.Create())\n{\n    powershell.AddScript(\"Get-Service | Where-Object { $_.Status -eq 'Stopped' }\");\n\n    foreach (PSObject result in powershell.Invoke())\n    {\n        Console.WriteLine(result.Members[\"Name\"].Value);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (PowerShell powershell = PowerShell.Create())\n{\n    powershell.AddScript(\"Get-Service | Where-Object { $_.Status -eq 'Stopped' }\");\n\n    foreach (PSObject result in powershell.Invoke())\n    {\n        Console.WriteLine(result.Members[\"Name\"].Value);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"返回字符窜:"}]},{"type":"element","tag":"pre","props":{"code":"using (PowerShell powershell = PowerShell.Create())\n{\n    powershell.AddScript(\"Get-Service | Out-String\");\n\n    foreach (string str in powershell.Invoke<string>())\n    {\n        Console.WriteLine(str);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (PowerShell powershell = PowerShell.Create())\n{\n    powershell.AddScript(\"Get-Service | Out-String\");\n\n    foreach (string str in powershell.Invoke<string>())\n    {\n        Console.WriteLine(str);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"捕捉错误:"}]},{"type":"element","tag":"pre","props":{"code":"using (PowerShell powershell = PowerShell.Create())\n{\n    powershell.AddScript(\"Get-Service99\");\n\n    foreach (PSObject result in powershell.Invoke())\n    {\n        Console.WriteLine(result.Members[\"Name\"].Value);\n    }\n\n    Console.WriteLine(\"執行過程中發生錯誤\\n\");\n    PSDataCollection<ErrorRecord> errors = powershell.Streams.Error;\n    if (errors != null && errors.Count > 0)\n    {\n        foreach (ErrorRecord err in errors)\n        {\n            System.Console.WriteLine(\"錯誤: {0}\", err.ToString());\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (PowerShell powershell = PowerShell.Create())\n{\n    powershell.AddScript(\"Get-Service99\");\n\n    foreach (PSObject result in powershell.Invoke())\n    {\n        Console.WriteLine(result.Members[\"Name\"].Value);\n    }\n\n    Console.WriteLine(\"執行過程中發生錯誤\\n\");\n    PSDataCollection<ErrorRecord> errors = powershell.Streams.Error;\n    if (errors != null && errors.Count > 0)\n    {\n        foreach (ErrorRecord err in errors)\n        {\n            System.Console.WriteLine(\"錯誤: {0}\", err.ToString());\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"常用命令","depth":3,"text":"常用命令"},{"id":"使用c类调用powershell-命令","depth":3,"text":"使用c#类调用powershell 命令"}]}},"_type":"markdown","_id":"content:tool:2019-08-10-powershell-command.md","_source":"content","_file":"tool/2019-08-10-powershell-command.md","_extension":"md","date":"2019-08-10"},{"_path":"/tool/2019-08-20-scoop-use","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"scoop的使用","description":"安装scoop前提版本大于等于3的powershell> $psversiontable.psversion.major\n确保您已允许PowerShell执行本地脚本> set-executionpolicy remotesigned -scope currentuser\n常用命令#打开powershell,win+r,然后输入powershell\n#更改策略\nSet-ExecutionPolicy RemoteSigned -scope CurrentUser\n\n#安装\niex (new-object net.webclient).downloadstring('https://get.sc","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"安装scoop前提"},"children":[{"type":"text","value":"安装scoop前提"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"版本大于等于3的powershell"}]},{"type":"element","tag":"pre","props":{"code":"> $psversiontable.psversion.major\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"> $psversiontable.psversion.major\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"确保您已允许PowerShell执行本地脚本"}]},{"type":"element","tag":"pre","props":{"code":"> set-executionpolicy remotesigned -scope currentuser\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"> set-executionpolicy remotesigned -scope currentuser\n"}]}]},{"type":"element","tag":"h1","props":{"id":"常用命令"},"children":[{"type":"text","value":"常用命令"}]},{"type":"element","tag":"pre","props":{"code":"#打开powershell,win+r,然后输入powershell\n#更改策略\nSet-ExecutionPolicy RemoteSigned -scope CurrentUser\n\n#安装\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n\n#安装git或者特定版本\nscoop install git\nscoop install shotcut@21.09.13 \n\n#开启extras库\nscoop bucket add extras\n\n#开启java库\nscoop bucket add java\n\n#更新\nscoop update\n\n#查看安装软件列表\nscoop list\n\n#搜索某软件\nscoop search xxx\n\n#打开某软件官网\nscoop home xxx\n\n#查看某软件安装信息\nscoop info xxx\n\n#查看某软件执行命令位置\nscoop which xxx\n\n#查看某软件当前状态，是否有更新等信息\nscoop status xxx\n\n#更新某软件\nscoop update xxx\n\n#卸载某软件,以xxx为例\nscoop uninstall xxx\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#打开powershell,win+r,然后输入powershell\n#更改策略\nSet-ExecutionPolicy RemoteSigned -scope CurrentUser\n\n#安装\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n\n#安装git或者特定版本\nscoop install git\nscoop install shotcut@21.09.13 \n\n#开启extras库\nscoop bucket add extras\n\n#开启java库\nscoop bucket add java\n\n#更新\nscoop update\n\n#查看安装软件列表\nscoop list\n\n#搜索某软件\nscoop search xxx\n\n#打开某软件官网\nscoop home xxx\n\n#查看某软件安装信息\nscoop info xxx\n\n#查看某软件执行命令位置\nscoop which xxx\n\n#查看某软件当前状态，是否有更新等信息\nscoop status xxx\n\n#更新某软件\nscoop update xxx\n\n#卸载某软件,以xxx为例\nscoop uninstall xxx\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里是一个按照 Github score（由 Star 数量、Fork 数量和 App 数量综合决定的 Github score）排列的 bucket 列表："},{"type":"element","tag":"a","props":{"href":"https://github.com/rasa/scoop-directory/blob/master/by-score.md","rel":["nofollow"]},"children":[{"type":"text","value":"Scoop buckets by Github score"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h1","props":{"id":"安装scoop到自定义目录"},"children":[{"type":"text","value":"安装scoop到自定义目录"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果重新安装系统.只需要将shime路径添加到环境变量path中"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"D:\\Applications\\Scoop\\shims"}]}]},{"type":"element","tag":"pre","props":{"code":"set-executionpolicy remotesigned -scope currentuser\n\n[environment]::setEnvironmentVariable('SCOOP','D:\\Applications\\Scoop','User')\n\n[environment]::setEnvironmentVariable('Path',[System.Environment]::GetEnvironmentVariable('Path',[System.EnvironmentVariableTarget]::User)+\";D:\\Applications\\Scoop\\shims\",'User')\n\n$env:SCOOP='D:\\Applications\\Scoop'\n\n[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\Applications\\ScoopGlobal','Machine')\n\n[environment]::setEnvironmentVariable('Path',[System.Environment]::GetEnvironmentVariable('Path',[System.EnvironmentVariableTarget]::Machine)+\";D:\\Applications\\ScoopGlobal\\shims\",'Machine')\n\n$env:SCOOP_GLOBAL='D:\\Applications\\ScoopGlobal'\n","language":"powershell","meta":"","className":["language-powershell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"set-executionpolicy remotesigned -scope currentuser\n\n[environment]::setEnvironmentVariable('SCOOP','D:\\Applications\\Scoop','User')\n\n[environment]::setEnvironmentVariable('Path',[System.Environment]::GetEnvironmentVariable('Path',[System.EnvironmentVariableTarget]::User)+\";D:\\Applications\\Scoop\\shims\",'User')\n\n$env:SCOOP='D:\\Applications\\Scoop'\n\n[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\Applications\\ScoopGlobal','Machine')\n\n[environment]::setEnvironmentVariable('Path',[System.Environment]::GetEnvironmentVariable('Path',[System.EnvironmentVariableTarget]::Machine)+\";D:\\Applications\\ScoopGlobal\\shims\",'Machine')\n\n$env:SCOOP_GLOBAL='D:\\Applications\\ScoopGlobal'\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用第二种方法:"}]},{"type":"element","tag":"pre","props":{"code":"\n[environment]::setEnvironmentVariable('Path',[System.Environment]::GetEnvironmentVariable('Path',[System.EnvironmentVariableTarget]::User)+\";D:\\Applications\\Scoop\\shims\",'User')\n# 然后关闭powershell 重新打开\nscoop config root_path D:\\Applications\\Scoop\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n[environment]::setEnvironmentVariable('Path',[System.Environment]::GetEnvironmentVariable('Path',[System.EnvironmentVariableTarget]::User)+\";D:\\Applications\\Scoop\\shims\",'User')\n# 然后关闭powershell 重新打开\nscoop config root_path D:\\Applications\\Scoop\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个脚本"}]},{"type":"element","tag":"pre","props":{"code":"# 获取当前用户环境变量的\"Path\"\n$currentPath = [Environment]::GetEnvironmentVariable('Path', 'User')\n\n# 检查是否包含指定路径\n$targetPath = 'D:\\Applications\\Scoop\\shims'\n$containsTargetPath = $currentPath -split ';' -contains $targetPath\n\nif (-not $containsTargetPath) {\n    # 如果不包含指定路径，则添加\n    $newPath = $currentPath + ';' + $targetPath\n    [Environment]::SetEnvironmentVariable('Path', $newPath, 'User')\n    Write-Host \"已成功添加路径: $targetPath\"\n\n    # 刷新环境变量（仅适用于当前会话）\n    $env:Path = [Environment]::GetEnvironmentVariable('Path', 'User')\n\n} else {\n    Write-Host \"路径已存在: $targetPath\"\n}\n\n# 打印出所有的\"Path\"\n$newPathList = [Environment]::GetEnvironmentVariable('Path', 'User') -split ';'\nWrite-Host \"所有的Path:\"\n$newPathList\n\n\n# 设置SCOOP的ROOT PATH\nscoop config root_path D:\\Applications\\Scoop\n\n# 打印所有配置\nscoop config\n\n# 添加git仓库都为 安全\ngit config --global --add safe.directory \"*\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 获取当前用户环境变量的\"Path\"\n$currentPath = [Environment]::GetEnvironmentVariable('Path', 'User')\n\n# 检查是否包含指定路径\n$targetPath = 'D:\\Applications\\Scoop\\shims'\n$containsTargetPath = $currentPath -split ';' -contains $targetPath\n\nif (-not $containsTargetPath) {\n    # 如果不包含指定路径，则添加\n    $newPath = $currentPath + ';' + $targetPath\n    [Environment]::SetEnvironmentVariable('Path', $newPath, 'User')\n    Write-Host \"已成功添加路径: $targetPath\"\n\n    # 刷新环境变量（仅适用于当前会话）\n    $env:Path = [Environment]::GetEnvironmentVariable('Path', 'User')\n\n} else {\n    Write-Host \"路径已存在: $targetPath\"\n}\n\n# 打印出所有的\"Path\"\n$newPathList = [Environment]::GetEnvironmentVariable('Path', 'User') -split ';'\nWrite-Host \"所有的Path:\"\n$newPathList\n\n\n# 设置SCOOP的ROOT PATH\nscoop config root_path D:\\Applications\\Scoop\n\n# 打印所有配置\nscoop config\n\n# 添加git仓库都为 安全\ngit config --global --add safe.directory \"*\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"重置应用以解决冲突,会重置环境变量,快捷方式等.."}]},{"type":"element","tag":"pre","props":{"code":"scoop reset *\n#检查潜在的问题..执行下看看使用scoop会有什么问题\nscoop checkup\n#如果使用了aria2感觉慢的话可以修改下参数或者关闭\nscoop config aria2-max-connection-per-server 16\nscoop config aria2-split 16\nscoop config aria2-min-split-size 1M\nscoop config aria2-enabled false  \n#下面是日常更新软件命令\nsudo scoop update * -g ; scoop update * ; sudo scoop cleanup * -g ; scoop cleanup *\n# 查看 Scoop 还能直接识别哪些 bucket\nscoop bucket known\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"scoop reset *\n#检查潜在的问题..执行下看看使用scoop会有什么问题\nscoop checkup\n#如果使用了aria2感觉慢的话可以修改下参数或者关闭\nscoop config aria2-max-connection-per-server 16\nscoop config aria2-split 16\nscoop config aria2-min-split-size 1M\nscoop config aria2-enabled false  \n#下面是日常更新软件命令\nsudo scoop update * -g ; scoop update * ; sudo scoop cleanup * -g ; scoop cleanup *\n# 查看 Scoop 还能直接识别哪些 bucket\nscoop bucket known\n"}]}]},{"type":"element","tag":"h3","props":{"id":"快捷方式"},"children":[{"type":"text","value":"快捷方式"}]},{"type":"element","tag":"pre","props":{"code":"Invoke-Item \"~\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Scoop Apps\"\n","language":"powershell","meta":"","className":["language-powershell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Invoke-Item \"~\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Scoop Apps\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"将Scoop安装到自定义目录"}]},{"type":"text","value":"\n假设目标目录是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"D:\\Applications\\Scoop"}]},{"type":"text","value":",在PowerShell命令控制台中运行："}]},{"type":"element","tag":"pre","props":{"code":"[environment]::setEnvironmentVariable('SCOOP','D:\\Applications\\Scoop','User')\n$env:SCOOP='D:\\Applications\\Scoop'\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n","language":"powershell","meta":"","className":["language-powershell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[environment]::setEnvironmentVariable('SCOOP','D:\\Applications\\Scoop','User')\n$env:SCOOP='D:\\Applications\\Scoop'\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将全局应用安装到自定义目录,假设目标目录是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"D:\\Applications\\ScoopGlobal"}]},{"type":"text","value":",在PowerShell命令控制台中运行："}]},{"type":"element","tag":"pre","props":{"code":"[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\Applications\\ScoopGlobal','Machine')\n$env:SCOOP_GLOBAL='D:\\Applications\\ScoopGlobal'\n","language":"powershell","meta":"","className":["language-powershell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\Applications\\ScoopGlobal','Machine')\n$env:SCOOP_GLOBAL='D:\\Applications\\ScoopGlobal'\n"}]}]},{"type":"element","tag":"h3","props":{"id":"安装应用"},"children":[{"type":"text","value":"安装应用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以我常用应用为例(可作为脚本文件,后缀ps1)"}]},{"type":"element","tag":"pre","props":{"code":"###安装scoop并自定义安装路径\n[environment]::setEnvironmentVariable('SCOOP','D:\\Applications\\Scoop','User')\n$env:SCOOP='D:\\Applications\\Scoop'\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\Applications\\ScoopGlobal','Machine')\n$env:SCOOP_GLOBAL='D:\\Applications\\ScoopGlobal'\n\n#git,程序员必备,只有安装了git才能添加其他桶\nscoop install git;\n#arias2 scoop 下载会用到\nscoop install aria2;\n#7zip 一些app会用到\nscoop install 7zip\n#scoop checkup提示装的软件\nscoop install wixtoolset\n\n###添加桶\n#scoop内置的桶\n#scoop bucket known;\n\n### D:\\Applications\\Scoop\\buckets,如果发现bucket中有错误可以检查并删除\nscoop bucket add extras;\nscoop bucket add Java;\nscoop bucket add versions;\n \n# 自用的一个bucket\nscoop bucket add Hass https://github.com/zhemima/Scoop-Hass\n\n\n\n#一个还不错的\nshovel bucket add 'ash258.ash258' 'https://github.com/Ash258/Shovel-Ash258.git'\n#因为ash258的bucket对scoop做了改变,想要安装ash258,需要配置和安装以下\nscoop install 7zip git\nscoop config SCOOP_REPO 'https://github.com/Ash258/Scoop-Core'\nscoop update\nscoop status\nscoop checkup\n\n\n\n\n\n### 添加代理\nscoop config proxy 127.0.0.1:1080\n# 删除代理\nscoop config rm proxy\n\n\n###安装全局应用\nscoop install apache -g;\nscoop install redis -g;\nscoop install mysql -g;\n# jdk最好使用8,否则android-sdk会有问题\nscoop install ojdkbuild8 -g; \nscoop install php -g;\n#整合apache php\niex (new-object net.webclient).downloadstring('https://gist.githubusercontent.com/nilkesede/c98a275b80b6d373131df82eaba96c63/raw/apache-php-init.ps1')\n# 或者手动修改apache配置\n#LoadModule php7_module 'C:/Users/xxxxx/scoop/apps/php71/current/php7apache2_4.dll'\n#AddHandler application/x-httpd-php .php\n#PHPIniDir \"C:\\Users\\xxxxx\\scoop\\apps\\php71\\current\"\n\n###安装APP\n#使用nvm安装nodejs  https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/\nscoop install nvm\nnvm list available\nnvm install 12.18.2\n#效率启动神器\nscoop install wox;\n#文件检索\nscoop install everything;\n#解压\nscoop install bandizip;\n#远程终端\nscoop install MobaXterm;\nscoop install electerm;\n#桌面控制\nscoop install teamviewer;\n#markdown编写\nscoop install typora;\n#编辑器 注意使用vscode-portable,这样data文件夹就会持久化在scoop,而不是c盘用户目录\n#From \"$env:USERPROFILE\\.vscode\\extensions\" to \"$env:USERPROFILE\\scoop\\persist\\vscode-portable\\data\\extensions\"\n#From \"$env:APPDATA\\Code\" to \"$env:USERPROFILE\\scoop\\persist\\vscode-portable\\data\\user-data\"\n#如果想添加右键菜单.执行下current文件夹下的vscode-install-context.reg\nscoop install vscode-portable;\n#ditto 剪贴板\nscoop install ditto\n#postman\nscoop install postman\n#heidisql\nscoop install heidisql\n#imageglass 图片浏览器\nscoop install imageglass\n#quick look\nscoop install quicklook\n#obs  录制视频或者直播\nscoop install obs-studio\n# 录像软件\nscoop install captura\n#switchhosts\nscoop install switchhosts\n# gradle\nscoop install gradle\n# android-sdk\nscoop install android-sdk\n# 安装ndk 老版本下载https://developer.android.com/ndk/downloads/older_releases.html\n# sdkmanager ndk-bundle\n# shadowsocksr-csharp\nscoop install shadowsocksr-csharp\n# 截图软件\nscoop install picpick\nscoop install snipaste\nscoop install sharex \nscoop install lightshot\n#xmind8\nscoop install XMind2020\n# android-studio\nscoop install android-studio\n#记住sourcetree的git最好使用内嵌版本\nscoop install sourcetree\n# php的包工具\nscoop intstall composer\n# 反向代理\nscoop install frp\n#网易云音乐\nscoop install neteasemusic\n# ftp工具\nscoop install filezilla \n# pdf阅读工具\n scoop install foxit-reader\n# 播放器\nscoop install potplayer \n# draw工程图,uml工具\nscoop install draw.io\n# 定时提醒休息工具\nscoop install wnr\n# 投屏工具\nscoop install scrcpy \n# 卸载工具\nscoop install geekuninstaller\n#浏览器\nscoop install  firefox-developer-zh-cn\nscoop install  googlechrome\n#wechat\nscoop install wechat\n#steam\nscoop install steam\n# pwsh\nscoop install pwsh\n#windows teraminal\nscoop install windows-terminal\n# 反编译 ilspy  https://github.com/sailro/Reflexil下载Reflexil将Reflexil.ILSpy.Plugin.dll直接扔到ilspy目录下即行\nscoop install ilspy\nscoop install dnspy\n#win+x菜单编辑\nscoop install WinXMenuEditor   \n#发送到菜单编辑\nscoop install SendToMenuEditor\n# 上下文菜单\nscoop install EasyContextMenu\n# 备份开始屏幕\nscoop install BackupStartMenuLayout\n#定时关机\nscoop install kshutdown\n# 创建可启动U盘的工具  https://www.ventoy.net/cn/index.html\nscoop install ventoy\n# 修改dns工具\nscoop install dnsjumper\n#space sniffer 查看硬盘被哪些大文件占用\nscoop install spacesniffer\n#shotcut 视频剪辑工具\nscoop install shotcut\n","language":"powershell","meta":"","className":["language-powershell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"###安装scoop并自定义安装路径\n[environment]::setEnvironmentVariable('SCOOP','D:\\Applications\\Scoop','User')\n$env:SCOOP='D:\\Applications\\Scoop'\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\Applications\\ScoopGlobal','Machine')\n$env:SCOOP_GLOBAL='D:\\Applications\\ScoopGlobal'\n\n#git,程序员必备,只有安装了git才能添加其他桶\nscoop install git;\n#arias2 scoop 下载会用到\nscoop install aria2;\n#7zip 一些app会用到\nscoop install 7zip\n#scoop checkup提示装的软件\nscoop install wixtoolset\n\n###添加桶\n#scoop内置的桶\n#scoop bucket known;\n\n### D:\\Applications\\Scoop\\buckets,如果发现bucket中有错误可以检查并删除\nscoop bucket add extras;\nscoop bucket add Java;\nscoop bucket add versions;\n \n# 自用的一个bucket\nscoop bucket add Hass https://github.com/zhemima/Scoop-Hass\n\n\n\n#一个还不错的\nshovel bucket add 'ash258.ash258' 'https://github.com/Ash258/Shovel-Ash258.git'\n#因为ash258的bucket对scoop做了改变,想要安装ash258,需要配置和安装以下\nscoop install 7zip git\nscoop config SCOOP_REPO 'https://github.com/Ash258/Scoop-Core'\nscoop update\nscoop status\nscoop checkup\n\n\n\n\n\n### 添加代理\nscoop config proxy 127.0.0.1:1080\n# 删除代理\nscoop config rm proxy\n\n\n###安装全局应用\nscoop install apache -g;\nscoop install redis -g;\nscoop install mysql -g;\n# jdk最好使用8,否则android-sdk会有问题\nscoop install ojdkbuild8 -g; \nscoop install php -g;\n#整合apache php\niex (new-object net.webclient).downloadstring('https://gist.githubusercontent.com/nilkesede/c98a275b80b6d373131df82eaba96c63/raw/apache-php-init.ps1')\n# 或者手动修改apache配置\n#LoadModule php7_module 'C:/Users/xxxxx/scoop/apps/php71/current/php7apache2_4.dll'\n#AddHandler application/x-httpd-php .php\n#PHPIniDir \"C:\\Users\\xxxxx\\scoop\\apps\\php71\\current\"\n\n###安装APP\n#使用nvm安装nodejs  https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/\nscoop install nvm\nnvm list available\nnvm install 12.18.2\n#效率启动神器\nscoop install wox;\n#文件检索\nscoop install everything;\n#解压\nscoop install bandizip;\n#远程终端\nscoop install MobaXterm;\nscoop install electerm;\n#桌面控制\nscoop install teamviewer;\n#markdown编写\nscoop install typora;\n#编辑器 注意使用vscode-portable,这样data文件夹就会持久化在scoop,而不是c盘用户目录\n#From \"$env:USERPROFILE\\.vscode\\extensions\" to \"$env:USERPROFILE\\scoop\\persist\\vscode-portable\\data\\extensions\"\n#From \"$env:APPDATA\\Code\" to \"$env:USERPROFILE\\scoop\\persist\\vscode-portable\\data\\user-data\"\n#如果想添加右键菜单.执行下current文件夹下的vscode-install-context.reg\nscoop install vscode-portable;\n#ditto 剪贴板\nscoop install ditto\n#postman\nscoop install postman\n#heidisql\nscoop install heidisql\n#imageglass 图片浏览器\nscoop install imageglass\n#quick look\nscoop install quicklook\n#obs  录制视频或者直播\nscoop install obs-studio\n# 录像软件\nscoop install captura\n#switchhosts\nscoop install switchhosts\n# gradle\nscoop install gradle\n# android-sdk\nscoop install android-sdk\n# 安装ndk 老版本下载https://developer.android.com/ndk/downloads/older_releases.html\n# sdkmanager ndk-bundle\n# shadowsocksr-csharp\nscoop install shadowsocksr-csharp\n# 截图软件\nscoop install picpick\nscoop install snipaste\nscoop install sharex \nscoop install lightshot\n#xmind8\nscoop install XMind2020\n# android-studio\nscoop install android-studio\n#记住sourcetree的git最好使用内嵌版本\nscoop install sourcetree\n# php的包工具\nscoop intstall composer\n# 反向代理\nscoop install frp\n#网易云音乐\nscoop install neteasemusic\n# ftp工具\nscoop install filezilla \n# pdf阅读工具\n scoop install foxit-reader\n# 播放器\nscoop install potplayer \n# draw工程图,uml工具\nscoop install draw.io\n# 定时提醒休息工具\nscoop install wnr\n# 投屏工具\nscoop install scrcpy \n# 卸载工具\nscoop install geekuninstaller\n#浏览器\nscoop install  firefox-developer-zh-cn\nscoop install  googlechrome\n#wechat\nscoop install wechat\n#steam\nscoop install steam\n# pwsh\nscoop install pwsh\n#windows teraminal\nscoop install windows-terminal\n# 反编译 ilspy  https://github.com/sailro/Reflexil下载Reflexil将Reflexil.ILSpy.Plugin.dll直接扔到ilspy目录下即行\nscoop install ilspy\nscoop install dnspy\n#win+x菜单编辑\nscoop install WinXMenuEditor   \n#发送到菜单编辑\nscoop install SendToMenuEditor\n# 上下文菜单\nscoop install EasyContextMenu\n# 备份开始屏幕\nscoop install BackupStartMenuLayout\n#定时关机\nscoop install kshutdown\n# 创建可启动U盘的工具  https://www.ventoy.net/cn/index.html\nscoop install ventoy\n# 修改dns工具\nscoop install dnsjumper\n#space sniffer 查看硬盘被哪些大文件占用\nscoop install spacesniffer\n#shotcut 视频剪辑工具\nscoop install shotcut\n"}]}]},{"type":"element","tag":"h1","props":{"id":"apache"},"children":[{"type":"text","value":"apache"}]},{"type":"element","tag":"pre","props":{"code":"sudo httpd -k install -n apache  \nstart-service apache\nremove-service apache\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo httpd -k install -n apache  \nstart-service apache\nremove-service apache\n"}]}]},{"type":"element","tag":"h2","props":{"id":"修改配置"},"children":[{"type":"text","value":"修改配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文件路径"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"D:\\Applications\\ScoopGlobal\\apps\\apache\\current\\conf\\httpd.conf"}]}]},{"type":"element","tag":"pre","props":{"code":"Define SRVROOT \"D:\\Applications\\ScoopGlobal\\apps\\apache\\current\"\nServerName localhost\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Define SRVROOT \"D:\\Applications\\ScoopGlobal\\apps\\apache\\current\"\nServerName localhost\n"}]}]},{"type":"element","tag":"h1","props":{"id":"redis"},"children":[{"type":"text","value":"Redis"}]},{"type":"element","tag":"pre","props":{"code":"redis-server --service-install D:\\Applications\\ScoopGlobal\\apps\\redis\\current\\redis.windows-service.conf --loglevel verbose\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"redis-server --service-install D:\\Applications\\ScoopGlobal\\apps\\redis\\current\\redis.windows-service.conf --loglevel verbose\n"}]}]},{"type":"element","tag":"h1","props":{"id":"mysql"},"children":[{"type":"text","value":"MySQL"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注册MySQL服务,(因为scoop是低污染的,所以要自己做):"}]},{"type":"element","tag":"pre","props":{"code":"mysqld --install MySQL --defaults-file=\"D:\\Applications\\ScoopGlobal\\apps\\mysql\\current\\my.ini\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"mysqld --install MySQL --defaults-file=\"D:\\Applications\\ScoopGlobal\\apps\\mysql\\current\\my.ini\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意mysql8密码可能认证有错误my.ini中需要设置"}]},{"type":"element","tag":"pre","props":{"code":"default_authentication_plugin=mysql_native_password \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"default_authentication_plugin=mysql_native_password \n"}]}]},{"type":"element","tag":"h1","props":{"id":"pwsh"},"children":[{"type":"text","value":"pwsh"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将pwsh添加到terminal中,配置默认路径:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"C:\\Users\\zhepama\\AppData\\Local\\Microsoft\\Windows Terminal\\settings.json"}]}]},{"type":"element","tag":"pre","props":{"code":"// This file was initially generated by Windows 终端(未打包) 1.0.200517002-release1.0\n// It should still be usable in newer versions, but newer versions might have additional\n// settings, help text, or changes that you will not see unless you clear this file\n// and let us generate a new one for you.\n\n// To view the default settings, hold \"alt\" while clicking on the \"Settings\" button.\n// For documentation on these settings, see: https://aka.ms/terminal-documentation\n{\n  \"$schema\": \"https://aka.ms/terminal-profiles-schema\",\n\n  \"defaultProfile\": \"{90cbdc15-f4fe-49d2-a245-ec066b70845f}\",\n\n  // You can add more global application settings here.\n  // To learn more about global settings, visit https://aka.ms/terminal-global-settings\n\n  // If enabled, selections are automatically copied to your clipboard.\n  \"copyOnSelect\": false,\n\n  // If enabled, formatted data is also copied to your clipboard\n  \"copyFormatting\": false,\n\n  // A profile specifies a command to execute paired with information about how it should look and feel.\n  // Each one of them will appear in the 'New Tab' dropdown,\n  //   and can be invoked from the commandline with `wt.exe -p xxx`\n  // To learn more about profiles, visit https://aka.ms/terminal-profile-settings\n  \"profiles\": {\n    \"defaults\": {\n      // Put settings here that you want to apply to all profiles.\n    },\n    \"list\": [\n      {\n        // Make changes here to the powershell.exe profile.\n        \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\n        \"name\": \"Windows PowerShell\",\n        \"commandline\": \"powershell.exe\",\n        \"hidden\": false\n      },\n      {\n        // Make changes here to the cmd.exe profile.\n        \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\",\n        \"name\": \"命令提示符\",\n        \"commandline\": \"cmd.exe\",\n        \"hidden\": false\n      },\n      {\n        \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\",\n        \"hidden\": false,\n        \"name\": \"Azure Cloud Shell\",\n        \"source\": \"Windows.Terminal.Azure\"\n      },\n      {\n        \"guid\": \"{90cbdc15-f4fe-49d2-a245-ec066b70845f}\",\n        \"name\": \"pwsh\",\n        \"commandline\": \"D:\\\\Application\\\\Scoop\\\\apps\\\\pwsh\\\\current\\\\pwsh.exe\",\n        \"hidden\": false,\n        \"startingDirectory\": \"%USERPROFILE%\"\n      }\n    ]\n  },\n\n  // Add custom color schemes to this array.\n  // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes\n  \"schemes\": [],\n\n  // Add custom keybindings to this array.\n  // To unbind a key combination from your defaults.json, set the command to \"unbound\".\n  // To learn more about keybindings, visit https://aka.ms/terminal-keybindings\n  \"keybindings\": [\n    // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.\n    // These two lines additionally bind them to Ctrl+C and Ctrl+V.\n    // To learn more about selection, visit https://aka.ms/terminal-selection\n    {\n      \"command\": {\n        \"action\": \"copy\",\n        \"singleLine\": false\n      },\n      \"keys\": \"ctrl+c\"\n    },\n    {\n      \"command\": \"paste\",\n      \"keys\": \"ctrl+v\"\n    },\n\n    // Press Ctrl+Shift+F to open the search box\n    {\n      \"command\": \"find\",\n      \"keys\": \"ctrl+shift+f\"\n    },\n\n    // Press Alt+Shift+D to open a new pane.\n    // - \"split\": \"auto\" makes this pane open in the direction that provides the most surface area.\n    // - \"splitMode\": \"duplicate\" makes the new pane use the focused pane's profile.\n    // To learn more about panes, visit https://aka.ms/terminal-panes\n    {\n      \"command\": {\n        \"action\": \"splitPane\",\n        \"split\": \"auto\",\n        \"splitMode\": \"duplicate\"\n      },\n      \"keys\": \"alt+shift+d\"\n    }\n  ]\n}\n","language":"json","meta":"","className":["language-json"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// This file was initially generated by Windows 终端(未打包) 1.0.200517002-release1.0\n// It should still be usable in newer versions, but newer versions might have additional\n// settings, help text, or changes that you will not see unless you clear this file\n// and let us generate a new one for you.\n\n// To view the default settings, hold \"alt\" while clicking on the \"Settings\" button.\n// For documentation on these settings, see: https://aka.ms/terminal-documentation\n{\n  \"$schema\": \"https://aka.ms/terminal-profiles-schema\",\n\n  \"defaultProfile\": \"{90cbdc15-f4fe-49d2-a245-ec066b70845f}\",\n\n  // You can add more global application settings here.\n  // To learn more about global settings, visit https://aka.ms/terminal-global-settings\n\n  // If enabled, selections are automatically copied to your clipboard.\n  \"copyOnSelect\": false,\n\n  // If enabled, formatted data is also copied to your clipboard\n  \"copyFormatting\": false,\n\n  // A profile specifies a command to execute paired with information about how it should look and feel.\n  // Each one of them will appear in the 'New Tab' dropdown,\n  //   and can be invoked from the commandline with `wt.exe -p xxx`\n  // To learn more about profiles, visit https://aka.ms/terminal-profile-settings\n  \"profiles\": {\n    \"defaults\": {\n      // Put settings here that you want to apply to all profiles.\n    },\n    \"list\": [\n      {\n        // Make changes here to the powershell.exe profile.\n        \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\n        \"name\": \"Windows PowerShell\",\n        \"commandline\": \"powershell.exe\",\n        \"hidden\": false\n      },\n      {\n        // Make changes here to the cmd.exe profile.\n        \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\",\n        \"name\": \"命令提示符\",\n        \"commandline\": \"cmd.exe\",\n        \"hidden\": false\n      },\n      {\n        \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\",\n        \"hidden\": false,\n        \"name\": \"Azure Cloud Shell\",\n        \"source\": \"Windows.Terminal.Azure\"\n      },\n      {\n        \"guid\": \"{90cbdc15-f4fe-49d2-a245-ec066b70845f}\",\n        \"name\": \"pwsh\",\n        \"commandline\": \"D:\\\\Application\\\\Scoop\\\\apps\\\\pwsh\\\\current\\\\pwsh.exe\",\n        \"hidden\": false,\n        \"startingDirectory\": \"%USERPROFILE%\"\n      }\n    ]\n  },\n\n  // Add custom color schemes to this array.\n  // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes\n  \"schemes\": [],\n\n  // Add custom keybindings to this array.\n  // To unbind a key combination from your defaults.json, set the command to \"unbound\".\n  // To learn more about keybindings, visit https://aka.ms/terminal-keybindings\n  \"keybindings\": [\n    // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.\n    // These two lines additionally bind them to Ctrl+C and Ctrl+V.\n    // To learn more about selection, visit https://aka.ms/terminal-selection\n    {\n      \"command\": {\n        \"action\": \"copy\",\n        \"singleLine\": false\n      },\n      \"keys\": \"ctrl+c\"\n    },\n    {\n      \"command\": \"paste\",\n      \"keys\": \"ctrl+v\"\n    },\n\n    // Press Ctrl+Shift+F to open the search box\n    {\n      \"command\": \"find\",\n      \"keys\": \"ctrl+shift+f\"\n    },\n\n    // Press Alt+Shift+D to open a new pane.\n    // - \"split\": \"auto\" makes this pane open in the direction that provides the most surface area.\n    // - \"splitMode\": \"duplicate\" makes the new pane use the focused pane's profile.\n    // To learn more about panes, visit https://aka.ms/terminal-panes\n    {\n      \"command\": {\n        \"action\": \"splitPane\",\n        \"split\": \"auto\",\n        \"splitMode\": \"duplicate\"\n      },\n      \"keys\": \"alt+shift+d\"\n    }\n  ]\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"自制bucket"},"children":[{"type":"text","value":"自制bucket"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最佳方式是使用模板 "},{"type":"element","tag":"a","props":{"href":"https://github.com/Ash258/GenericBucket","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/Ash258/GenericBucket"}]}]},{"type":"element","tag":"h3","props":{"id":"如何解压exe的程序"},"children":[{"type":"text","value":"如何解压exe的程序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先下载的时候后面加上#/dl.7z类似的后缀..然后scoop保存的时候.会把他存在7z格式的文件夹"}]},{"type":"element","tag":"pre","props":{"code":"    \"architecture\": {\n        \"64bit\": {\n            \"url\": \"https://github.com/RoderickQiu/wnr/releases/download/v1.17.1/wnr-1.17.1-Setup-64.exe#/dl.7z\",\n            \"hash\": \"BE14DE68FDBFB3663F57B6B28E8B0CC90AE876DD06CA899839BEB9377FE21436\"\n        },\n        \"32bit\": {\n            \"url\": \"https://github.com/RoderickQiu/wnr/releases/download/v1.17.1/wnr-1.17.1-Setup-32.exe#/dl.7z\",\n            \"hash\": \"9C437170019E8AFC82B64A5475E349602E03A9493DD6AC6CACF58FDFD75762DD\"\n        }\n    },\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \"architecture\": {\n        \"64bit\": {\n            \"url\": \"https://github.com/RoderickQiu/wnr/releases/download/v1.17.1/wnr-1.17.1-Setup-64.exe#/dl.7z\",\n            \"hash\": \"BE14DE68FDBFB3663F57B6B28E8B0CC90AE876DD06CA899839BEB9377FE21436\"\n        },\n        \"32bit\": {\n            \"url\": \"https://github.com/RoderickQiu/wnr/releases/download/v1.17.1/wnr-1.17.1-Setup-32.exe#/dl.7z\",\n            \"hash\": \"9C437170019E8AFC82B64A5475E349602E03A9493DD6AC6CACF58FDFD75762DD\"\n        }\n    },\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如上面旧会被存在scoop/cache/wnr#1.17.1#https_github.com_RoderickQiu_wnr_releases_download_v1.17.1_wnr-1.17.1-Setup-64.exe_dl.7z"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后旧可以解压了"}]},{"type":"element","tag":"pre","props":{"code":"    \"installer\": {\n        \"script\": [\n            \"Expand-7zipArchive -Path (Join-Path $dir '$PLUGINSDIR\\\\*.7z') -DestinationPath $dir\",\n            \"Remove-Item -Path (Join-Path $dir '$PLUGINSDIR') -Recurse\",\n            \"Remove-Item \\\"$dir\\\\Uninstall wnr.exe\\\"\"\n        ]\n    },\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \"installer\": {\n        \"script\": [\n            \"Expand-7zipArchive -Path (Join-Path $dir '$PLUGINSDIR\\\\*.7z') -DestinationPath $dir\",\n            \"Remove-Item -Path (Join-Path $dir '$PLUGINSDIR') -Recurse\",\n            \"Remove-Item \\\"$dir\\\\Uninstall wnr.exe\\\"\"\n        ]\n    },\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安装脚本都是执行在Scoop\\apps\\wnr\\11.XXX\\下面"}]},{"type":"element","tag":"h3","props":{"id":"导出-scoop-软件列表"},"children":[{"type":"text","value":"导出 Scoop 软件列表"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"备份 Scoop 的方式为："}]},{"type":"element","tag":"pre","props":{"code":"scoop export > scoop.txt\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"scoop export > scoop.txt\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以对 Scoop 的导出列表进行额外处理，以方便后续安装。使用 VSCode 打开 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"scoop.txt"}]},{"type":"text","value":" 文件，以正则表达式搜索："}]},{"type":"element","tag":"pre","props":{"code":"(.*?) .*\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"(.*?) .*\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"并全部替换成："}]},{"type":"element","tag":"pre","props":{"code":"$1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意正则式中包含空格，请完整复制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"VSCode 中的正则式替换","src":"/images/2019-08-20-scoop-use/03.jpg"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"快捷方式","depth":3,"text":"快捷方式"},{"id":"安装应用","depth":3,"text":"安装应用"},{"id":"修改配置","depth":2,"text":"修改配置","children":[{"id":"如何解压exe的程序","depth":3,"text":"如何解压exe的程序"},{"id":"导出-scoop-软件列表","depth":3,"text":"导出 Scoop 软件列表"}]}]}},"_type":"markdown","_id":"content:tool:2019-08-20-scoop-use.md","_source":"content","_file":"tool/2019-08-20-scoop-use.md","_extension":"md","date":"2019-08-20"},{"_path":"/tool/2019-09-02-nuget-manager","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"使用配置文件来管理NuGet包版本F","description":"先创建一个文件Directory.Build.props","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先创建一个文件"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Directory.Build.props"}]}]},{"type":"element","tag":"pre","props":{"code":"<Project>\n    <PropertyGroup>\n        <NuGet-Kritner-SolarProjection>1.0.2</NuGet-Kritner-SolarProjection>\n    </PropertyGroup>\n</Project>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<Project>\n    <PropertyGroup>\n        <NuGet-Kritner-SolarProjection>1.0.2</NuGet-Kritner-SolarProjection>\n    </PropertyGroup>\n</Project>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后修改你的项目文件"}]},{"type":"element","tag":"pre","props":{"code":"<ItemGroup>\n  <PackageReference Include=\"Kritner.SolarProjection\" Version=\"$(NuGet-Kritner-SolarProjection)\" />\n</ItemGroup>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<ItemGroup>\n  <PackageReference Include=\"Kritner.SolarProjection\" Version=\"$(NuGet-Kritner-SolarProjection)\" />\n</ItemGroup>\n"}]}]},{"type":"element","tag":"h3","props":{"id":"相关连接"},"children":[{"type":"text","value":"相关连接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/nuget/consume-packages/package-references-in-project-files","rel":["nofollow"]},"children":[{"type":"text","value":"包的版本号"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/msbuild/customize-your-build?view=vs-2019","rel":["nofollow"]},"children":[{"type":"text","value":"Directory.Build.props的说明"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"相关连接","depth":3,"text":"相关连接"}]}},"_type":"markdown","_id":"content:tool:2019-09-02-nuget-manager.md","_source":"content","_file":"tool/2019-09-02-nuget-manager.md","_extension":"md","date":"2019-09-02"},{"_path":"/tool/2019-09-02-redis-aof-rdb","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"Redis的两种持久化RDB和AOF","description":"Redis 分别提供了 RDB 和 AOF 两种持久化机制：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 分别提供了 RDB 和 AOF 两种持久化机制："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-a7c5f2bb064f2c0307d15dca06d7d31d3adfc032.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本章首先介绍 AOF 功能的运作机制， 了解命令是如何被保存到 AOF 文件里的， 观察不同的 AOF 保存模式对数据的安全性、以及 Redis 性能的影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之后会介绍从 AOF 文件中恢复数据库状态的方法，以及该方法背后的实现机制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后还会介绍对 AOF 进行重写以调整文件体积的方法， 并研究这种方法是如何在不改变数据库状态的前提下进行的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为本章涉及 AOF 运行的相关机制， 如果还没了解过 AOF 功能的话， 请先阅读 "},{"type":"element","tag":"a","props":{"href":"http://redis.io/topics/persistence","rel":["nofollow"]},"children":[{"type":"text","value":"Redis 持久化手册中关于 AOF 的部分"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"无论是rdb还是aof都是把存储的文件恢复到内存中"}]}]},{"type":"element","tag":"h1","props":{"id":"rdb优点与缺点"},"children":[{"type":"text","value":"RDB优点与缺点"}]},{"type":"element","tag":"h3","props":{"id":"优点"},"children":[{"type":"text","value":"优点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。"}]}]},{"type":"element","tag":"h3","props":{"id":"缺点"},"children":[{"type":"text","value":"缺点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。\n"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-redis-aof-rdb/20181004174024768.png"},"children":[]}]}]},{"type":"element","tag":"h2","props":{"id":"aof-命令同步"},"children":[{"type":"text","value":"AOF 命令同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的， 为了方便起见， 我们称呼这种记录过程为同步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子， 如果执行以下命令："}]},{"type":"element","tag":"pre","props":{"code":"redis> RPUSH list 1 2 3 4\n(integer) 4\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n\nredis> KEYS *\n1) \"list\"\n\nredis> RPOP list\n\"4\"\n\nredis> LPOP list\n\"1\"\n\nredis> LPUSH list 1\n(integer) 3\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"redis> RPUSH list 1 2 3 4\n(integer) 4\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n\nredis> KEYS *\n1) \"list\"\n\nredis> RPOP list\n\"4\"\n\nredis> LPOP list\n\"1\"\n\nredis> LPUSH list 1\n(integer) 3\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么其中四条对数据库有修改的写入命令就会被同步到 AOF 文件中："}]},{"type":"element","tag":"pre","props":{"code":"RPUSH list 1 2 3 4\n\nRPOP list\n\nLPOP list\n\nLPUSH list 1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"RPUSH list 1 2 3 4\n\nRPOP list\n\nLPOP list\n\nLPUSH list 1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了处理的方便， AOF 文件使用网络通讯协议的格式来保存这些命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 上面列举的四个命令在 AOF 文件中就实际保存如下："}]},{"type":"element","tag":"pre","props":{"code":"*2\n$6\nSELECT\n$1\n0\n*6\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n*2\n$4\nRPOP\n$4\nlist\n*2\n$4\nLPOP\n$4\nlist\n*3\n$5\nLPUSH\n$4\nlist\n$1\n1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"*2\n$6\nSELECT\n$1\n0\n*6\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n*2\n$4\nRPOP\n$4\nlist\n*2\n$4\nLPOP\n$4\nlist\n*3\n$5\nLPUSH\n$4\nlist\n$1\n1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/connection/select.html#select","rel":["nofollow"]},"children":[{"type":"text","value":"SELECT"}]},{"type":"text","value":" 命令是 AOF 程序自己加上去的之外， 其他命令都是之前我们在终端里执行的命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同步命令到 AOF 文件的整个过程可以分为三个阶段："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fsync"}]},{"type":"text","value":" 函数或者 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fdatasync"}]},{"type":"text","value":" 函数会被调用，将写入的内容真正地保存到磁盘中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下几个小节将详细地介绍这三个步骤。"}]},{"type":"element","tag":"h2","props":{"id":"命令传播"},"children":[{"type":"text","value":"命令传播"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当一个 Redis 客户端需要执行命令时， 它通过网络连接， 将协议文本发送给 Redis 服务器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 要执行命令 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET KEY VALUE"}]},{"type":"text","value":" ， 客户端将向服务器发送文本 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n\""}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器在接到客户端的请求之后， 它会根据协议文本的内容， 选择适当的命令函数， 并将各个参数从字符串文本转换为 Redis 字符串对象（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StringObject"}]},{"type":"text","value":"）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 针对上面的 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/string/set.html#set","rel":["nofollow"]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 命令例子， Redis 将客户端的命令指针指向实现 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/string/set.html#set","rel":["nofollow"]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 命令的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setCommand"}]},{"type":"text","value":" 函数， 并创建三个 Redis 字符串对象， 分别保存 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 、 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KEY"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VALUE"}]},{"type":"text","value":" 三个参数（命令也算作参数）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当命令函数成功执行之后， 命令参数都会被传播到 AOF 程序， 以及 REPLICATION 程序（本节不讨论这个，列在这里只是为了完整性的考虑）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个执行并传播命令的过程可以用以下伪代码表示："}]},{"type":"element","tag":"pre","props":{"code":"if (execRedisCommand(cmd, argv, argc) == EXEC_SUCCESS):\n\n    if aof_is_turn_on():\n        # 传播命令到 AOF 程序\n        propagate_aof(cmd, argv, argc)\n\n    if replication_is_turn_on():\n        # 传播命令到 REPLICATION 程序\n        propagate_replication(cmd, argv, argc)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (execRedisCommand(cmd, argv, argc) == EXEC_SUCCESS):\n\n    if aof_is_turn_on():\n        # 传播命令到 AOF 程序\n        propagate_aof(cmd, argv, argc)\n\n    if replication_is_turn_on():\n        # 传播命令到 REPLICATION 程序\n        propagate_replication(cmd, argv, argc)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是该过程的流程图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-a5c804211267a10a5c3ffa47c5b600727191a3be.svg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"缓存追加"},"children":[{"type":"text","value":"缓存追加"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当命令被传播到 AOF 程序之后， 程序会根据命令以及命令的参数， 将命令从字符串对象转换回原来的协议文本。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 如果 AOF 程序接受到的三个参数分别保存着 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 、 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KEY"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VALUE"}]},{"type":"text","value":" 三个字符串， 那么它将生成协议文本 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n\""}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"协议文本生成之后， 它会被追加到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"redis.h/redisServer"}]},{"type":"text","value":" 结构的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 末尾。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"redisServer"}]},{"type":"text","value":" 结构维持着 Redis 服务器的状态， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 域则保存着所有等待写入到 AOF 文件的协议文本："}]},{"type":"element","tag":"pre","props":{"code":"struct redisServer {\n\n    // 其他域...\n\n    sds aof_buf;\n\n    // 其他域...\n};\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct redisServer {\n\n    // 其他域...\n\n    sds aof_buf;\n\n    // 其他域...\n};\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至此， 追加命令到缓存的步骤执行完毕。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综合起来，整个缓存追加过程可以分为以下三步："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"接受命令、命令的参数、以及参数的个数、所使用的数据库等信息。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将命令还原成 Redis 网络通讯协议。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将协议文本追加到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 末尾。"}]}]},{"type":"element","tag":"h2","props":{"id":"文件写入和保存"},"children":[{"type":"text","value":"文件写入和保存"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当服务器常规任务函数被执行、 或者事件处理器被执行时， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof.c/flushAppendOnlyFile"}]},{"type":"text","value":" 函数都会被调用， 这个函数执行以下两个工作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WRITE：根据条件，将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 中的缓存写入到 AOF 文件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SAVE：根据条件，调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fsync"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fdatasync"}]},{"type":"text","value":" 函数，将 AOF 文件保存到磁盘中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。"}]},{"type":"element","tag":"h2","props":{"id":"aof-保存模式"},"children":[{"type":"text","value":"AOF 保存模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 目前支持三种 AOF 保存模式，它们分别是："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_NO"}]},{"type":"text","value":" ：不保存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_EVERYSEC"}]},{"type":"text","value":" ：每一秒钟保存一次。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_ALWAYS"}]},{"type":"text","value":" ：每执行一个命令保存一次。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下三个小节将分别讨论这三种保存模式。"}]},{"type":"element","tag":"h3","props":{"id":"不保存"},"children":[{"type":"text","value":"不保存"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式下， 每次调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"flushAppendOnlyFile"}]},{"type":"text","value":" 函数， WRITE 都会被执行， 但 SAVE 会被略过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式下， SAVE 只会在以下任意一种情况中被执行："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Redis 被关闭"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 功能被关闭"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。"}]},{"type":"element","tag":"h3","props":{"id":"每一秒钟保存一次"},"children":[{"type":"text","value":"每一秒钟保存一次"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fsync"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fdatasync"}]},{"type":"text","value":" 的调用并不是每秒一次， 它和调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"flushAppendOnlyFile"}]},{"type":"text","value":" 函数时 Redis 所处的状态有关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"flushAppendOnlyFile"}]},{"type":"text","value":" 函数被调用时， 可能会出现以下四种情况："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子线程正在执行 SAVE ，并且："},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。"}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子线程没有在执行 SAVE ，并且："},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以用流程图表示这四种情况："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-1b226a6d0f09ed1b61a30d899372834634b96504.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。"}]},{"type":"element","tag":"h3","props":{"id":"每执行一个命令保存一次"},"children":[{"type":"text","value":"每执行一个命令保存一次"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。"}]},{"type":"element","tag":"h2","props":{"id":"aof-保存模式对性能和安全性的影响"},"children":[{"type":"text","value":"AOF 保存模式对性能和安全性的影响"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在上一个小节， 我们简短地描述了三种 AOF 保存模式的工作方式， 现在， 是时候研究一下这三个模式在安全性和性能方面的区别了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不保存（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_NO"}]},{"type":"text","value":"）：写入和保存都由主进程执行，两个操作都会阻塞主进程。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一秒钟保存一次（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_EVERYSEC"}]},{"type":"text","value":"）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每执行一个命令保存一次（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_ALWAYS"}]},{"type":"text","value":"）：和模式 1 一样。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综合起来，三种 AOF 模式的操作特性可以总结如下："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"模式"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"WRITE 是否阻塞？"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"SAVE 是否阻塞？"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"停机时丢失的数据量"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_NO"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_EVERYSEC"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"不阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"一般情况下不超过 2 秒钟的数据。"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_ALWAYS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"最多只丢失一个命令的数据。"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"aof-文件的读取和数据还原"},"children":[{"type":"text","value":"AOF 文件的读取和数据还原"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这也就是说， 只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 读取 AOF 文件并还原数据库的详细步骤如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建一个不带网络连接的伪客户端（fake client）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"完成第 4 步之后， AOF 文件所保存的数据库就会被完整地还原出来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意， 因为 Redis 的命令只能在客户端的上下文中被执行， 而 AOF 还原时所使用的命令来自于 AOF 文件， 而不是网络， 所以程序使用了一个没有网络连接的伪客户端来执行命令。 伪客户端执行命令的效果， 和带网络连接的客户端执行命令的效果， 完全一样。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"整个读取和还原过程可以用以下伪代码表示："}]},{"type":"element","tag":"pre","props":{"code":"def READ_AND_LOAD_AOF():\n\n    # 打开并读取 AOF 文件\n    file = open(aof_file_name)\n    while file.is_not_reach_eof():\n\n        # 读入一条协议文本格式的 Redis 命令\n        cmd_in_text = file.read_next_command_in_protocol_format()\n\n        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象\n        cmd, argv, argc = text_to_command(cmd_in_text)\n\n        # 执行命令\n        execRedisCommand(cmd, argv, argc)\n\n    # 关闭文件\n    file.close()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def READ_AND_LOAD_AOF():\n\n    # 打开并读取 AOF 文件\n    file = open(aof_file_name)\n    while file.is_not_reach_eof():\n\n        # 读入一条协议文本格式的 Redis 命令\n        cmd_in_text = file.read_next_command_in_protocol_format()\n\n        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象\n        cmd, argv, argc = text_to_command(cmd_in_text)\n\n        # 执行命令\n        execRedisCommand(cmd, argv, argc)\n\n    # 关闭文件\n    file.close()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作为例子， 以下是一个简短的 AOF 文件的内容："}]},{"type":"element","tag":"pre","props":{"code":"*2\n$6\nSELECT\n$1\n0\n*3\n$3\nSET\n$3\nkey\n$5\nvalue\n*8\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n$1\n5\n$1\n6\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"*2\n$6\nSELECT\n$1\n0\n*3\n$3\nSET\n$3\nkey\n$5\nvalue\n*8\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n$1\n5\n$1\n6\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当程序读入这个 AOF 文件时， 它首先执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SELECT 0"}]},{"type":"text","value":" 命令 —— 这个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SELECT"}]},{"type":"text","value":" 命令是由 AOF 写入程序自动生成的， 它确保程序可以将数据还原到正确的数据库上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后执行后面的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET key value"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RPUSH 1 2 3 4"}]},{"type":"text","value":" 命令， 还原 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"key"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 两个键的数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。"}]},{"type":"element","tag":"h2","props":{"id":"aof-重写"},"children":[{"type":"text","value":"AOF 重写"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOF 文件通过同步 Redis 服务器所执行的命令， 从而实现了数据库状态的记录， 但是， 这种同步方式会造成一个问题： 随着运行时间的流逝， AOF 文件会变得越来越大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子， 如果服务器执行了以下命令："}]},{"type":"element","tag":"pre","props":{"code":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么光是记录 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 键的状态， AOF 文件就需要保存四条命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一方面， 有些被频繁操作的键， 对它们所调用的命令可能有成百上千、甚至上万条， 如果这样被频繁操作的键有很多的话， AOF 文件的体积就会急速膨胀， 对 Redis 、甚至整个系统的造成影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决以上的问题， Redis 需要对 AOF 文件进行重写（rewrite）： 创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下就来介绍 AOF 重写的实现方式。"}]},{"type":"element","tag":"h2","props":{"id":"aof-重写的实现"},"children":[{"type":"text","value":"AOF 重写的实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"考虑这样一个情况， 如果服务器对键 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 执行了以下四条命令："}]},{"type":"element","tag":"pre","props":{"code":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么当前列表键 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 在数据库中的值就为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[1, 2, 3]"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们要保存这个列表的当前状态， 并且尽量减少所使用的命令数， 那么最简单的方式不是去 AOF 文件上分析前面执行的四条命令， 而是直接读取 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 键在数据库的当前值， 然后用一条 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RPUSH 1 2 3"}]},{"type":"text","value":" 命令来代替前面的四条命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再考虑这样一个例子， 如果服务器对集合键 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"animal"}]},{"type":"text","value":" 执行了以下命令："}]},{"type":"element","tag":"pre","props":{"code":"SADD animal cat                 // {cat}\n\nSADD animal dog panda tiger     // {cat, dog, panda, tiger}\n\nSREM animal cat                 // {dog, panda, tiger}\n\nSADD animal cat lion            // {cat, lion, dog, panda, tiger}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"SADD animal cat                 // {cat}\n\nSADD animal dog panda tiger     // {cat, dog, panda, tiger}\n\nSREM animal cat                 // {dog, panda, tiger}\n\nSADD animal cat lion            // {cat, lion, dog, panda, tiger}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么使用一条 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SADD animal cat lion dog panda tiger"}]},{"type":"text","value":" 命令， 就可以还原 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"animal"}]},{"type":"text","value":" 集合的状态， 这比之前的四条命令调用要大大减少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。 整个重写过程可以用伪代码表示如下："}]},{"type":"element","tag":"pre","props":{"code":"def AOF_REWRITE(tmp_tile_name):\n\n  f = create(tmp_tile_name)\n\n  # 遍历所有数据库\n  for db in redisServer.db:\n\n    # 如果数据库为空，那么跳过这个数据库\n    if db.is_empty(): continue\n\n    # 写入 SELECT 命令，用于切换数据库\n    f.write_command(\"SELECT \" + db.number)\n\n    # 遍历所有键\n    for key in db:\n\n      # 如果键带有过期时间，并且已经过期，那么跳过这个键\n      if key.have_expire_time() and key.is_expired(): continue\n\n      if key.type == String:\n\n        # 用 SET key value 命令来保存字符串键\n\n        value = get_value_from_string(key)\n\n        f.write_command(\"SET \" + key + value)\n\n      elif key.type == List:\n\n        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键\n\n        item1, item2, ..., itemN = get_item_from_list(key)\n\n        f.write_command(\"RPUSH \" + key + item1 + item2 + ... + itemN)\n\n      elif key.type == Set:\n\n        # 用 SADD key member1 member2 ... memberN 命令来保存集合键\n\n        member1, member2, ..., memberN = get_member_from_set(key)\n\n        f.write_command(\"SADD \" + key + member1 + member2 + ... + memberN)\n\n      elif key.type == Hash:\n\n        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键\n\n        field1, value1, field2, value2, ..., fieldN, valueN =\\\n        get_field_and_value_from_hash(key)\n\n        f.write_command(\"HMSET \" + key + field1 + value1 + field2 + value2 +\\\n                        ... + fieldN + valueN)\n\n      elif key.type == SortedSet:\n\n        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN\n        # 命令来保存有序集键\n\n        score1, member1, score2, member2, ..., scoreN, memberN = \\\n        get_score_and_member_from_sorted_set(key)\n\n        f.write_command(\"ZADD \" + key + score1 + member1 + score2 + member2 +\\\n                        ... + scoreN + memberN)\n\n      else:\n\n        raise_type_error()\n\n      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间\n      if key.have_expire_time():\n        f.write_command(\"EXPIREAT \" + key + key.expire_time_in_unix_timestamp())\n\n    # 关闭文件\n    f.close()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def AOF_REWRITE(tmp_tile_name):\n\n  f = create(tmp_tile_name)\n\n  # 遍历所有数据库\n  for db in redisServer.db:\n\n    # 如果数据库为空，那么跳过这个数据库\n    if db.is_empty(): continue\n\n    # 写入 SELECT 命令，用于切换数据库\n    f.write_command(\"SELECT \" + db.number)\n\n    # 遍历所有键\n    for key in db:\n\n      # 如果键带有过期时间，并且已经过期，那么跳过这个键\n      if key.have_expire_time() and key.is_expired(): continue\n\n      if key.type == String:\n\n        # 用 SET key value 命令来保存字符串键\n\n        value = get_value_from_string(key)\n\n        f.write_command(\"SET \" + key + value)\n\n      elif key.type == List:\n\n        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键\n\n        item1, item2, ..., itemN = get_item_from_list(key)\n\n        f.write_command(\"RPUSH \" + key + item1 + item2 + ... + itemN)\n\n      elif key.type == Set:\n\n        # 用 SADD key member1 member2 ... memberN 命令来保存集合键\n\n        member1, member2, ..., memberN = get_member_from_set(key)\n\n        f.write_command(\"SADD \" + key + member1 + member2 + ... + memberN)\n\n      elif key.type == Hash:\n\n        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键\n\n        field1, value1, field2, value2, ..., fieldN, valueN =\\\n        get_field_and_value_from_hash(key)\n\n        f.write_command(\"HMSET \" + key + field1 + value1 + field2 + value2 +\\\n                        ... + fieldN + valueN)\n\n      elif key.type == SortedSet:\n\n        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN\n        # 命令来保存有序集键\n\n        score1, member1, score2, member2, ..., scoreN, memberN = \\\n        get_score_and_member_from_sorted_set(key)\n\n        f.write_command(\"ZADD \" + key + score1 + member1 + score2 + member2 +\\\n                        ... + scoreN + memberN)\n\n      else:\n\n        raise_type_error()\n\n      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间\n      if key.have_expire_time():\n        f.write_command(\"EXPIREAT \" + key + key.expire_time_in_unix_timestamp())\n\n    # 关闭文件\n    f.close()\n"}]}]},{"type":"element","tag":"h2","props":{"id":"aof-后台重写"},"children":[{"type":"text","value":"AOF 后台重写"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上一节展示的 AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子进程进行 AOF 重写期间，主进程可以继续处理命令请求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-982033b83f571a133367a8830ee5cca84f6a08e5.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"处理命令请求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将写命令追加到现有的 AOF 文件中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将写命令追加到 AOF 重写缓存中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样一来可以保证："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当步骤 1 执行完毕之后， 现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当步骤 2 执行完毕之后， 程序就完成了新旧两个 AOF 文件的交替。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上就是 AOF 后台重写， 也即是 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof","rel":["nofollow"]},"children":[{"type":"text","value":"BGREWRITEAOF"}]},{"type":"text","value":" 命令的工作原理。"}]},{"type":"element","tag":"h2","props":{"id":"aof-后台重写的触发条件"},"children":[{"type":"text","value":"AOF 后台重写的触发条件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOF 重写可以由用户通过调用 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof","rel":["nofollow"]},"children":[{"type":"text","value":"BGREWRITEAOF"}]},{"type":"text","value":" 手动触发。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外， 服务器在 AOF 功能开启的情况下， 会维持以下三个变量："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"记录当前 AOF 文件大小的变量 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_current_size"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"记录最后一次 AOF 重写之后， AOF 文件大小的变量 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_rewrite_base_size"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"增长百分比变量 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_rewrite_perc"}]},{"type":"text","value":" 。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每次当 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"serverCron"}]},{"type":"text","value":" 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"没有 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgsave.html#bgsave","rel":["nofollow"]},"children":[{"type":"text","value":"BGSAVE"}]},{"type":"text","value":" 命令在进行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"没有 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof","rel":["nofollow"]},"children":[{"type":"text","value":"BGREWRITEAOF"}]},{"type":"text","value":" 在进行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当前 AOF 文件大小大于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"server.aof_rewrite_min_size"}]},{"type":"text","value":" （默认值为 1 MB）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下， 增长百分比为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"100%"}]},{"type":"text","value":" ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。"}]},{"type":"element","tag":"h2","props":{"id":"小结"},"children":[{"type":"text","value":"小结"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 重写的目的是用更小的体积来保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 重写是一个有歧义的名字，实际的重写工作是针对数据库的当前值来进行的，程序既不读写、也不使用原有的 AOF 文件。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 可以由用户手动触发，也可以由服务器自动触发。"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"优点","depth":3,"text":"优点"},{"id":"缺点","depth":3,"text":"缺点"},{"id":"aof-命令同步","depth":2,"text":"AOF 命令同步"},{"id":"命令传播","depth":2,"text":"命令传播"},{"id":"缓存追加","depth":2,"text":"缓存追加"},{"id":"文件写入和保存","depth":2,"text":"文件写入和保存"},{"id":"aof-保存模式","depth":2,"text":"AOF 保存模式","children":[{"id":"不保存","depth":3,"text":"不保存"},{"id":"每一秒钟保存一次","depth":3,"text":"每一秒钟保存一次"},{"id":"每执行一个命令保存一次","depth":3,"text":"每执行一个命令保存一次"}]},{"id":"aof-保存模式对性能和安全性的影响","depth":2,"text":"AOF 保存模式对性能和安全性的影响"},{"id":"aof-文件的读取和数据还原","depth":2,"text":"AOF 文件的读取和数据还原"},{"id":"aof-重写","depth":2,"text":"AOF 重写"},{"id":"aof-重写的实现","depth":2,"text":"AOF 重写的实现"},{"id":"aof-后台重写","depth":2,"text":"AOF 后台重写"},{"id":"aof-后台重写的触发条件","depth":2,"text":"AOF 后台重写的触发条件"},{"id":"小结","depth":2,"text":"小结"}]}},"_type":"markdown","_id":"content:tool:2019-09-02-redis-aof-rdb.md","_source":"content","_file":"tool/2019-09-02-redis-aof-rdb.md","_extension":"md","date":"2019-09-02"},{"_path":"/tool/2020-01-02-google-clound-local-login","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","description":"使用普通用户登陆生成私钥生成后可以把 Key comment 改为你想要的名称, 这样下面你在连接的时候可以使用比较熟悉的Username 作为登录名, 然后使用 Ctrl + C 把上面显示的那串 ssh-rsa.. 开头的公钥复制下来. 待会要用到这个.然后保存好你的私钥和公钥到本地目录中..私钥是本地用的,公钥是远程服务器用的添加公钥到谷歌云的实例中点击实例的名称进入实例的详情后. 进入页面后点击上方的修改, 然后拉到下方找到如下图的地方点击添加一项, 把刚刚复制的公钥粘贴进去, 记得, 正确的公钥是在结尾会有一个空格加上你的 Username , 例如: “…== qian”使用SSH","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"使用普通用户登陆"},"children":[{"type":"text","value":"使用普通用户登陆"}]},{"type":"element","tag":"h3","props":{"id":"生成私钥"},"children":[{"type":"text","value":"生成私钥"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200112043711450","src":"/images/2020-01-02-google-clound-local-login/image-20200112043711450.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生成后可以把 Key comment 改为你想要的名称, 这样下面你在连接的时候可以使用比较熟悉的Username 作为登录名, 然后使用 Ctrl + C 把上面显示的那串 ssh-rsa.. 开头的公钥复制下来. 待会要用到这个."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200112043833424","src":"/images/2020-01-02-google-clound-local-login/image-20200112043833424.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后保存好你的私钥和公钥到本地目录中..私钥是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"本地"}]},{"type":"text","value":"用的,公钥是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"远程服务器"}]},{"type":"text","value":"用的"}]},{"type":"element","tag":"h1","props":{"id":"添加公钥到谷歌云的实例中"},"children":[{"type":"text","value":"添加公钥到谷歌云的实例中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200112044032323","src":"/images/2020-01-02-google-clound-local-login/image-20200112044032323.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"点击实例的名称进入实例的详情后. 进入页面后点击上方的修改, 然后拉到下方找到如下图的地方点击添加一项, 把刚刚复制的公钥粘贴进去, 记得, 正确的公钥是在结尾会有一个空格加上你的 Username , 例如: “…== qian”"}]},{"type":"element","tag":"h1","props":{"id":"使用ssh工具连接到实例"},"children":[{"type":"text","value":"使用SSH工具连接到实例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200112044256601","src":"/images/2020-01-02-google-clound-local-login/image-20200112044256601.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"使用-root-账户登陆和修改root密码"},"children":[{"type":"text","value":"使用 root 账户登陆和修改root密码"}]},{"type":"element","tag":"h3","props":{"id":"先选择从浏览器打开ssh连接服务器"},"children":[{"type":"text","value":"先选择从浏览器打开ssh连接服务器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://ycb.hk/usr/uploads/2018/03/2557178057.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-02-google-clound-local-login/2557178057.png"},"children":[]}]},{"type":"text","value":"\n连接登录成功后，输入以下命令"}]},{"type":"element","tag":"pre","props":{"code":"sudo -i  #切换到root\npasswd   #修改密码\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo -i  #切换到root\npasswd   #修改密码\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://ycb.hk/usr/uploads/2018/03/2932129962.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-02-google-clound-local-login/2932129962.png"},"children":[]}]},{"type":"text","value":"\n然后会要求输入新密码，然后再重复一次密码，输入密码的时候不会显示出来，所以直接输入密码，然后回车，再然后重复输入密码回车。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"修改root密码完成"}]},{"type":"element","tag":"h3","props":{"id":"接着修改ssh配置文件etcsshsshd_config"},"children":[{"type":"text","value":"接着修改SSH配置文件/etc/ssh/sshd_config"}]},{"type":"element","tag":"pre","props":{"code":"vi /etc/ssh/sshd_config #编辑文件\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"vi /etc/ssh/sshd_config #编辑文件\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后再输"}]},{"type":"element","tag":"pre","props":{"code":"i   #进入编辑模式\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"i   #进入编辑模式\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"找到以下内容并修改"}]},{"type":"element","tag":"pre","props":{"code":"PermitRootLogin yes //默认为no，需要开启root用户访问改为yes\nPasswordAuthentication yes //默认为no，改为yes开启密码登陆\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"PermitRootLogin yes //默认为no，需要开启root用户访问改为yes\nPasswordAuthentication yes //默认为no，改为yes开启密码登陆\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://ycb.hk/usr/uploads/2018/03/3324977715.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-02-google-clound-local-login/3324977715.png"},"children":[]}]},{"type":"text","value":"\n修改完成后，再下按 esc 键，然后再输入"}]},{"type":"element","tag":"pre","props":{"code":":wq   #保存并退出\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":":wq   #保存并退出\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://ycb.hk/usr/uploads/2018/03/1145294211.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-02-google-clound-local-login/1145294211.png"},"children":[]}]},{"type":"text","value":"\n最后重启下服务器即可"}]},{"type":"element","tag":"pre","props":{"code":"reboot    #重启服务器\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"reboot    #重启服务器\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"生成私钥","depth":3,"text":"生成私钥"},{"id":"先选择从浏览器打开ssh连接服务器","depth":3,"text":"先选择从浏览器打开ssh连接服务器"},{"id":"接着修改ssh配置文件etcsshsshd_config","depth":3,"text":"接着修改SSH配置文件/etc/ssh/sshd_config"}]}},"_type":"markdown","_id":"content:tool:2020-01-02-google-clound-local-login.md","_source":"content","_file":"tool/2020-01-02-google-clound-local-login.md","_extension":"md","date":"2020-01-02"},{"_path":"/tool/2020-01-12-centosn-ss-install","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"CentOS 下安装Shadowsocks 搭建ss","description":"CentOS 7 开始默认使用Systemd作为开启启动脚本的管理工具，Shadowsocks则是当前比较受欢迎的科学上网工具，本文将介绍如何在 CentOS 下安装和配置 Shadowsocks 服务。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CentOS 7 开始默认使用"},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Systemd","rel":["nofollow"]},"children":[{"type":"text","value":"Systemd"}]},{"type":"text","value":"作为开启启动脚本的管理工具，"},{"type":"element","tag":"a","props":{"href":"https://github.com/shadowsocks/","rel":["nofollow"]},"children":[{"type":"text","value":"Shadowsocks"}]},{"type":"text","value":"则是当前比较受欢迎的科学上网工具，本文将介绍如何在 CentOS 下安装和配置 Shadowsocks 服务。"}]},{"type":"element","tag":"h2","props":{"id":"安装-pip"},"children":[{"type":"text","value":"安装 pip"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://pip.pypa.io/en/stable/installing/","rel":["nofollow"]},"children":[{"type":"text","value":"pip"}]},{"type":"text","value":"是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在控制台执行以下命令安装 pip："}]},{"type":"element","tag":"pre","props":{"code":"curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\"\npython3 get-pip.py\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\"\npython3 get-pip.py\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者"}]},{"type":"element","tag":"pre","props":{"code":"sudo yum -y install epel-release\nsudo yum -y install python-pip\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo yum -y install epel-release\nsudo yum -y install python-pip\n"}]}]},{"type":"element","tag":"h2","props":{"id":"安装配置-shadowsocks"},"children":[{"type":"text","value":"安装配置 shadowsocks"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在控制台执行以下命令安装 shadowsocks："}]},{"type":"element","tag":"pre","props":{"code":"pip install --upgrade pip\npip install shadowsocks\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"pip install --upgrade pip\npip install shadowsocks\n"}]}]},{"type":"element","tag":"h2","props":{"id":"客户端"},"children":[{"type":"text","value":"客户端"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要创建配置文件"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/etc/shadowsocks.json"}]},{"type":"text","value":"，内容如下："}]},{"type":"element","tag":"pre","props":{"code":"{\n    \"server\":\"1.1.1.1\",\n    \"server_port\":1035,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"password\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false,\n    \"workers\": 1\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n    \"server\":\"1.1.1.1\",\n    \"server_port\":1035,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"password\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false,\n    \"workers\": 1\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置说明："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"server：Shadowsocks服务器地址"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"server_port：Shadowsocks服务器端口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"local_address：本地IP，本地使用的 sock5 代理 ip"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"local_port：本地端口，本地使用的 sock5 代理端口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"password：Shadowsocks连接密码"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"timeout：等待超时时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"method：加密方式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"workers:工作线程数"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"fast_open：true或false。开启fast_open以降低延迟，但要求Linux内核在3.7+。开启方法 echo 3 > /proc/sys/net/ipv4/tcp_fastopen"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述配置需要根据情况进行修改，接下来需要启动服务，就可以通过 local_address 和 local_port 来使用 sock5 代理，流量就可以走 ss 了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置启动脚本文件 /etc/systemd/system/shadowsocks.service"}]},{"type":"element","tag":"pre","props":{"code":"[Unit]\nDescription=Shadowsocks\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/sslocal -c /etc/shadowsocks/shadowsocks.json\n\n[Install]\nWantedBy=multi-user.target\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Unit]\nDescription=Shadowsocks\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/sslocal -c /etc/shadowsocks/shadowsocks.json\n\n[Install]\nWantedBy=multi-user.target\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"启用启动脚本，启动 ss 服务"}]},{"type":"element","tag":"pre","props":{"code":"# 配置服务开机启动\nsudo systemctl enable shadowsocks.service\n# 启动服务\nsudo systemctl start shadowsocks.service\n# 查看服务状态\nsudo systemctl status shadowsocks.service\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 配置服务开机启动\nsudo systemctl enable shadowsocks.service\n# 启动服务\nsudo systemctl start shadowsocks.service\n# 查看服务状态\nsudo systemctl status shadowsocks.service\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"验证安装"}]},{"type":"element","tag":"pre","props":{"code":"$ curl --socks5 127.0.0.1:1080 http://httpbin.org/ip\n{\"origin\":\"x.x.x.x\"}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$ curl --socks5 127.0.0.1:1080 http://httpbin.org/ip\n{\"origin\":\"x.x.x.x\"}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至此就完成了 ss 客户端的安装配置。"}]},{"type":"element","tag":"h3","props":{"id":"前台运行"},"children":[{"type":"text","value":"前台运行"}]},{"type":"element","tag":"pre","props":{"code":"sslocal -c /etc/shadowsocks.json\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sslocal -c /etc/shadowsocks.json\n"}]}]},{"type":"element","tag":"h3","props":{"id":"后台运行"},"children":[{"type":"text","value":"后台运行"}]},{"type":"element","tag":"pre","props":{"code":"sslocal -c /etc/shadowsocks.json -d start\nsslocal -c /etc/shadowsocks.json -d stop\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sslocal -c /etc/shadowsocks.json -d start\nsslocal -c /etc/shadowsocks.json -d stop\n"}]}]},{"type":"element","tag":"h2","props":{"id":"method-aes-256-gcm-not-supported方法"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"method aes-256-gcm not supported"}]},{"type":"text","value":"方法"}]},{"type":"element","tag":"pre","props":{"code":"pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U\napt-get install build-essential\nwget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz\ntar xf LATEST.tar.gz && cd libsodium-*.*.*\n./configure && make -j4 && make install\nldconfig\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U\napt-get install build-essential\nwget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz\ntar xf LATEST.tar.gz && cd libsodium-*.*.*\n./configure && make -j4 && make install\nldconfig\n"}]}]},{"type":"element","tag":"h1","props":{"id":"proxychains"},"children":[{"type":"text","value":"proxychains"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"proxychains 的官方介绍："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"proxychains 是一种访问代理的方式，用法如下："}]},{"type":"element","tag":"pre","props":{"code":"proxychains4 curl http://httpbin.org/ip\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"proxychains4 curl http://httpbin.org/ip\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样可以使得 curl 走代理来访问网络。"}]},{"type":"element","tag":"h2","props":{"id":"安装"},"children":[{"type":"text","value":"安装"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先去 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rofl0r/proxychains-ng","rel":["nofollow"]},"children":[{"type":"text","value":"proxychains 官网"}]},{"type":"text","value":" 下载代码进行编译安装，常规的 configure && make 方式，没啥特别之处。"}]},{"type":"element","tag":"pre","props":{"code":"./configure\n\nmake -j\n\nsudo make install\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"./configure\n\nmake -j\n\nsudo make install\n"}]}]},{"type":"element","tag":"h2","props":{"id":"配置"},"children":[{"type":"text","value":"配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建配置文件"}]},{"type":"element","tag":"pre","props":{"code":"mkdir -p ~/.proxychains\nvi ~/.proxychains/proxychains.conf\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"mkdir -p ~/.proxychains\nvi ~/.proxychains/proxychains.conf\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"proxychains.conf 配置如下："}]},{"type":"element","tag":"pre","props":{"code":"strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\nlocalnet 127.0.0.0/255.0.0.0\nquiet_mode\n\n[ProxyList]\nsocks5  127.0.0.1 1080\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\nlocalnet 127.0.0.0/255.0.0.0\nquiet_mode\n\n[ProxyList]\nsocks5  127.0.0.1 1080\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ProxyList 的配置要与上面的 ss 配置一致，即可通过代理访问网络，使用起来还是很方便的。"}]},{"type":"element","tag":"h2","props":{"id":"用法"},"children":[{"type":"text","value":"用法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"proxychains 可以通过启动一个 bash 来使得当前终端全局走代理"}]},{"type":"element","tag":"pre","props":{"code":"proxychains4 bash\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"proxychains4 bash\n"}]}]},{"type":"element","tag":"h2","props":{"id":"服务端"},"children":[{"type":"text","value":"服务端"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要创建配置文件"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/etc/shadowsocks.json"}]},{"type":"text","value":"，内容如下："}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"server\": \"0.0.0.0\",\n  \"server_port\": 8388,\n  \"password\": \"uzon57jd0v869t7w\",\n  \"method\": \"aes-256-cfb\"\n}\n","language":"json","meta":"","className":["language-json"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"server\": \"0.0.0.0\",\n  \"server_port\": 8388,\n  \"password\": \"uzon57jd0v869t7w\",\n  \"method\": \"aes-256-cfb\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说明："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"method"}]},{"type":"text","value":"为加密方法，可选"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"server_port"}]},{"type":"text","value":"为服务监听端口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"password"}]},{"type":"text","value":"为密码，可使用"},{"type":"element","tag":"a","props":{"href":"http://ucdok.com/project/generate_password.html","rel":["nofollow"]},"children":[{"type":"text","value":"密码生成工具"}]},{"type":"text","value":"生成一个随机密码"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"新建启动脚本文件"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/etc/systemd/system/shadowsocks.service"}]},{"type":"text","value":"，内容如下："}]},{"type":"element","tag":"pre","props":{"code":"[Unit]\nDescription=Shadowsocks\nAfter=network.target auditd.service\n\n[Service]\nType=forking\nTimeoutStartSec=0\nExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks.json --pid-file /var/run/shadowsocks.pid -d start\nExecStop=/usr/local/bin/ssserver -c /etc/shadowsocks.json  --pid-file /var/run/shadowsocks.pid -d stop\nPIDFile=/var/run/shadowsocks.pid\nRestart=always\nRestartSec=4\n\n\n[Install]\nWantedBy=multi-user.target\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Unit]\nDescription=Shadowsocks\nAfter=network.target auditd.service\n\n[Service]\nType=forking\nTimeoutStartSec=0\nExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks.json --pid-file /var/run/shadowsocks.pid -d start\nExecStop=/usr/local/bin/ssserver -c /etc/shadowsocks.json  --pid-file /var/run/shadowsocks.pid -d stop\nPIDFile=/var/run/shadowsocks.pid\nRestart=always\nRestartSec=4\n\n\n[Install]\nWantedBy=multi-user.target\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行以下命令启动 shadowsocks 服务："}]},{"type":"element","tag":"pre","props":{"code":"systemctl enable shadowsocks\nsystemctl start shadowsocks\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"systemctl enable shadowsocks\nsystemctl start shadowsocks\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态："}]},{"type":"element","tag":"pre","props":{"code":"systemctl status shadowsocks -l\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"systemctl status shadowsocks -l\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果服务启动成功，则控制台显示的信息可能类似这样："}]},{"type":"element","tag":"pre","props":{"code":"● shadowsocks.service - Shadowsocks\n   Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)\n   Active: active (running) since Mon 2015-12-21 23:51:48 CST; 11min ago\n Main PID: 19334 (ssserver)\n   CGroup: /system.slice/shadowsocks.service\n           └─19334 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.json\n\nDec 21 23:51:48 morning.work systemd[1]: Started Shadowsocks.\nDec 21 23:51:48 morning.work systemd[1]: Starting Shadowsocks...\nDec 21 23:51:48 morning.work ssserver[19334]: INFO: loading config from /etc/shadowsocks.json\nDec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     loading libcrypto from libcrypto.so.10\nDec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     starting server at 0.0.0.0:8388\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"● shadowsocks.service - Shadowsocks\n   Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)\n   Active: active (running) since Mon 2015-12-21 23:51:48 CST; 11min ago\n Main PID: 19334 (ssserver)\n   CGroup: /system.slice/shadowsocks.service\n           └─19334 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.json\n\nDec 21 23:51:48 morning.work systemd[1]: Started Shadowsocks.\nDec 21 23:51:48 morning.work systemd[1]: Starting Shadowsocks...\nDec 21 23:51:48 morning.work ssserver[19334]: INFO: loading config from /etc/shadowsocks.json\nDec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     loading libcrypto from libcrypto.so.10\nDec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     starting server at 0.0.0.0:8388\n"}]}]},{"type":"element","tag":"h1","props":{"id":"错误"},"children":[{"type":"text","value":"错误"}]},{"type":"element","tag":"pre","props":{"code":"AttributeError: /lib64/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AttributeError: /lib64/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以前在openssl，有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EVP_CIPHER_CTX_cleanup"}]},{"type":"text","value":"函数.1.1.0版本中替换成为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EVP_CIPHER_CTX_reset"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决办法：找到报错的文件(注意:根据你的python版本修改,看报错信息中使用的openssl文件)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"全文搜索cleanup将所有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EVP_CIPHER_CTX_cleanup"}]},{"type":"text","value":"替换成为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EVP_CIPHER_CTX_reset"}]}]},{"type":"element","tag":"pre","props":{"code":":%s/cleanup/reset/\n\n:x\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":":%s/cleanup/reset/\n\n:x\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"安装-pip","depth":2,"text":"安装 pip"},{"id":"安装配置-shadowsocks","depth":2,"text":"安装配置 shadowsocks"},{"id":"客户端","depth":2,"text":"客户端","children":[{"id":"前台运行","depth":3,"text":"前台运行"},{"id":"后台运行","depth":3,"text":"后台运行"}]},{"id":"method-aes-256-gcm-not-supported方法","depth":2,"text":"method aes-256-gcm not supported方法"},{"id":"安装","depth":2,"text":"安装"},{"id":"配置","depth":2,"text":"配置"},{"id":"用法","depth":2,"text":"用法"},{"id":"服务端","depth":2,"text":"服务端"}]}},"_type":"markdown","_id":"content:tool:2020-01-12-centosn-ss-install.md","_source":"content","_file":"tool/2020-01-12-centosn-ss-install.md","_extension":"md","date":"2020-01-12"},{"_path":"/tool/2020-01-13-brew","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"mac下brew 使用","description":"将brew装在非系统盘Command-R 重新安装您在 Mac 上安装过的最新 macOS，但不会升级到更高的版本。Option-Command-R 升级到与您的 Mac 兼容的最新 macOS。Shift-Option-Command-R 需要安装 macOS Sierra 10.12.4 或更高版本重新安装 Mac 随附的 macOS 或仍有提供的最接近版本。#禁用安全工具,使/usr/local可以挂载到非系统盘,需要进入安全模式执行\ncsrutil disable\n\n# 挂载非系统盘到/usr/local\nvi /etc/fstab\nUUID=BA245166-9FB3-4D88-98","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"将brew装在非系统盘"},"children":[{"type":"text","value":"将brew装在非系统盘"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Command-R"}]},{"type":"text","value":" 重新安装您在 Mac 上安装过的最新 macOS，但不会升级到更高的版本。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Option-Command-R"}]},{"type":"text","value":" 升级到与您的 Mac 兼容的最新 macOS。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Shift-Option-Command-R"}]},{"type":"text","value":" 需要安装 "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//support.apple.com/zh-cn/HT201260","rel":["nofollow"]},"children":[{"type":"text","value":"macOS Sierra 10.12.4"}]},{"type":"text","value":" 或更高版本重新安装 Mac 随附的 macOS 或仍有提供的最接近版本。"}]}]},{"type":"element","tag":"pre","props":{"code":"#禁用安全工具,使/usr/local可以挂载到非系统盘,需要进入安全模式执行\ncsrutil disable\n\n# 挂载非系统盘到/usr/local\nvi /etc/fstab\nUUID=BA245166-9FB3-4D88-98E3-147559D0B531 /usr/local apfs rw,auto,nobrowse\n\n#设置环境变量HOMEBREW_TEMP需要和brew在同一个硬盘\nvi ~/.bash_profile\nexport PATH=\"/usr/local/bin:$PATH\"\nexport HOMEBREW_TEMP=/usr/local/temp\n","language":"shell","meta":"","className":["language-shell"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#禁用安全工具,使/usr/local可以挂载到非系统盘,需要进入安全模式执行\ncsrutil disable\n\n# 挂载非系统盘到/usr/local\nvi /etc/fstab\nUUID=BA245166-9FB3-4D88-98E3-147559D0B531 /usr/local apfs rw,auto,nobrowse\n\n#设置环境变量HOMEBREW_TEMP需要和brew在同一个硬盘\nvi ~/.bash_profile\nexport PATH=\"/usr/local/bin:$PATH\"\nexport HOMEBREW_TEMP=/usr/local/temp\n"}]}]},{"type":"element","tag":"h3","props":{"id":"切换国内的镜像源"},"children":[{"type":"text","value":"切换国内的镜像源"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Homebrew 默认使用的是国外的源，在下载时速度可能会比较慢。好在国内的清华大学和中科大提供了 Homebrew 的镜像源，我们可以很轻松的切换源，从而提升我们的下载速度。"}]},{"type":"element","tag":"h4","props":{"id":"使用中科大的镜像"},"children":[{"type":"text","value":"使用中科大的镜像"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行如下命令，即可切换为中科大的镜像"}]},{"type":"element","tag":"pre","props":{"code":"cd \"$(brew --repo)\"\ngit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\ncd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"\ngit remote set-url origin git://mirrors.ustc.edu.cn/homebrew-core.git\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"cd \"$(brew --repo)\"\ngit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\ncd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"\ngit remote set-url origin git://mirrors.ustc.edu.cn/homebrew-core.git\n"}]}]},{"type":"element","tag":"h4","props":{"id":"使用清华大学的镜像"},"children":[{"type":"text","value":"使用清华大学的镜像"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行如下命令，即可切换为清华大学的镜像"}]},{"type":"element","tag":"pre","props":{"code":"git -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git\n"}]}]},{"type":"element","tag":"h3","props":{"id":"使用-brewfile-完成环境迁移"},"children":[{"type":"text","value":"使用 Brewfile 完成环境迁移"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设备永久了，我们的电脑中会有大量的软件，如果你需要迁移环境，重新安装会是一个大麻烦，好在 Homebrew 本身为我们提供了一个非常好用的环境迁移的工具 —— Homebrew Bundle"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你首先需要在之前的电脑中执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"brew bundle dump"}]},{"type":"text","value":" 来完成当前环境的导出,导出完成后，你会得到一个 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Brewfile"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-13-brew/1.jpeg"},"children":[]},{"type":"text","value":"然后将 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Brewfile"}]},{"type":"text","value":" 复制到新的电脑中，并执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"brew bundle"}]},{"type":"text","value":" 来开始安装的过程。"}]},{"type":"element","tag":"h3","props":{"id":"常用软件"},"children":[{"type":"text","value":"常用软件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"截屏2020-02-05上午4.33.45","src":"/images/2020-01-13-brew/%E6%88%AA%E5%B1%8F2020-02-05%E4%B8%8A%E5%8D%884.33.45.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"brew cask install launchrocket\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"brew cask install launchrocket\n"}]}]},{"type":"element","tag":"h3","props":{"id":"常用链接"},"children":[{"type":"text","value":"常用链接"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/Homebrew/homebrew-services","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/Homebrew/homebrew-services"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://sspai.com/post/56009","rel":["nofollow"]},"children":[{"type":"text","value":"https://sspai.com/post/56009"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"将brew装在非系统盘","depth":3,"text":"将brew装在非系统盘"},{"id":"切换国内的镜像源","depth":3,"text":"切换国内的镜像源"},{"id":"使用-brewfile-完成环境迁移","depth":3,"text":"使用 Brewfile 完成环境迁移"},{"id":"常用软件","depth":3,"text":"常用软件"},{"id":"常用链接","depth":3,"text":"常用链接"}]}},"_type":"markdown","_id":"content:tool:2020-01-13-brew.md","_source":"content","_file":"tool/2020-01-13-brew.md","_extension":"md","date":"2020-01-13"},{"_path":"/tool/2020-02-05-game_en_zh","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"术语中英文对照","description":"中英对照的网络游戏术语AC – Armor Class，盔甲等级、级别Account – 账号，与密码Password相对Add – 一只玩家加入到组队中，如果请求别人组队，可说Add me pls.AOE – Area Effect Damage，区域作用魔法，指的是一个可以伤害一个区域中的一群怪物的魔法，即所谓的群攻，现并非魔攻专用AE – Area Effect，区域作用伤害AFK – Away from Keyboard，暂时离开(键盘)，意味着玩家暂时不再操控游戏角色，通知其他玩家注意Aggro – 指一些敌对、主动攻击的怪物，当角色接近它时，它会试图攻击角色，这种行为成为Aggro","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"中英对照的网络游戏术语"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AC – Armor Class，盔甲等级、级别"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Account – 账号，与密码Password相对"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Add – 一只玩家加入到组队中，如果请求别人组队，可说Add me pls."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOE – Area Effect Damage，区域作用魔法，指的是一个可以伤害一个区域中的一群怪物的魔法，即所谓的群攻，现并非魔攻专用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AE – Area Effect，区域作用伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AFK – Away from Keyboard，暂时离开(键盘)，意味着玩家暂时不再操控游戏角色，通知其他玩家注意"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Aggro – 指一些敌对、主动攻击的怪物，当角色接近它时，它会试图攻击角色，这种行为成为Aggro"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Aggro Radius – 怪物周围的区域，进入它意味着怪物会“苏醒”并主动攻击你"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Agi – Agility的缩写，意为敏捷，多指代游戏中角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Avatar – 你的角色，互联网中常用来指头像，如论坛中的会员头像等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Beta – 游戏的测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Bind(Bound) – 重生复活点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Boss – 游戏中的终极怪物，通常各个级别段都有不同的Boss，中文里可以称为大王，老头儿等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Buff – 主要指辅助类角色为别人施加的有益状态，通俗的说法就是“加状态”，典型的如增加防御、回血速度、躲避率等等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Bug – 游戏中的漏洞"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Carebear – 喜欢帮助别人攻击怪物的玩家"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Caster – 不能抗怪的角色，如法师"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CBT – Closed Beta Test 游戏封闭测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CD – Cool Down, 多指技能的冷却时间"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Character – 游戏中的角色"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cheat – 游戏中的作弊，也只游戏秘笈"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cheese – 利用游戏的不平衡之处牟利"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Combat Pets – 被玩家控制的NPC，在战斗中帮助玩家及其队友，直译也有宠物的意思"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CR – Corpse Retrevial的缩写，指取回尸体，这要看具体游戏的设置而论，很多游戏没有这个设置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Creep – 怪物"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Creep Jacking – 当其他玩家与怪物战斗的时候趁机攻击该玩家"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Critters – 面对玩家攻击不会反击的怪物"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DD – Direct Damage，直接伤害，非持续性伤害作用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DBUFF – De-Buff的简写，对怪物或敌对玩家施放的具有负面状态，如是对方减速、降低防御、降低准确率等等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Defense – 防御，这是通俗的叫法，具体还有物防、魔防等分类"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DKP – Dragon Kill Point的缩写，直译是屠龙点数，一种对玩家贡献的衡量标准"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DMG – Damage的缩写，指伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DOT – Damage over time，在一段时间内持续对目标造成伤害，持续伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DPS – Damage per second的缩写，每秒伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dungeon – 指地宫、地下城等，多指游戏中难度很大的地形，也是Boss的栖居地"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FH – Full Health的简写，指生命值全满"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FM – Full Mana的简写，指法力全满"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Forge – 要塞，可以是游戏中的场景、地图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FS – Full Sport的缩写，指完全负责辅助的角色；汉语里可以做为法师的简称，注意区别"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Gank – PvP：当其他玩家与怪物战斗时趁机攻击该玩家，与Creep Jacking 类似"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Gate(gateway) – 游戏中的传送，与Portal相似"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GM – Game Master的简写，指游戏管理员，服务玩家，维护游戏内正常运行的人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Griefer – 试图骚扰或激怒其他玩家的人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Grinding – 长时间在一地点猎怪，多是为了升级或取得特殊游戏道具"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Guild – 公会、团体"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Heart – 心脉、血脉，多指游戏角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HOT – Health Over Time的缩写，指持续性治疗效果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HP – 作为Health point的简写时，指生命值；做为Hit points的简写时指伤害值，其中前者较常用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ID – Identification的简写，网络中表示各种账号，表示账号时，与account意义相同；通常指身份证、证件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"INC – Incoming的简写，指引怪的人对其他玩家的警示"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Instancing – 游戏中的副本，现在很多网游都引入了这一玩法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"INT – Intelligence的简写，指智力，多指代游戏中角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Item – 泛指游戏内的道具"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Kiting – 玩家保持在敌人战斗范围以外的一种战术，从敌人身边跑开，同时对其造成伤害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"KO – Knock Out的简写，与人挑战时击败对方"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"KOS – Killed on Sight的简写，多指游戏中的设置，游戏NPC对敌对阵营玩家的攻击行为"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"KS – Kill Steal的简写，直译是偷杀，试图杀死另一个人正在对付的怪物，以获取经验(主要目的)、道具(这种情况不多)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lag – 延时，就是我们平常说的卡，当你卡了，你可以说Laaaaaaaaaag"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LFG – Looking for a group的简写，寻找队伍以求加入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LFM – Looking for more的简写，找寻更多的人组队"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LOL – Lots of Laugh/Laughing Out Loud的简写，指大笑，很常用的聊天词汇，相当于汉语中的”呵呵”、”哈哈”等，ROFL(笑到打滚)此不常用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LOM – Low on Mana的简写，法力不足"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Login – 与Logon, Log-in意义相同，表示登入账号的意思"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LOS – Line of Sight的简写，视线"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LOOT – 从被杀死的怪物或宝箱里拿取游戏道具、战利品等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lure – 指引怪，3D游戏中常用，组队杀怪时，有玩家负责将怪引向团队，然后用群攻技能集体杀怪"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LVL – Level的简写，游戏角色等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Maintenance – 维护，一般指游戏停机维护"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mana – 魔法，通俗的称呼是蓝"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Map – 地图，游戏内的场景，也可用 Zone 表示地图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mental – 意念，多指代游戏角色的属性，与下面的Spirit有些类似"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mez – Mesmerize的缩写，指催眠等状态是玩家暂时失去对角色的控制"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MMO – Massively Multiplayer Online，大型多人在线"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MMOG – Massively Multiplayer Online Game，大型多人在线游戏"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MMORPG – Massive Multiplayer Online Role Playing Game，大型多人在线角色扮演游戏"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MOB – 指游戏中的怪物，任何怪物都可叫MOB，或游戏中所有由电脑控制的角色，第二种用法不常见"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MP – Magic Point魔法值，是对魔法的通俗称呼，正式的叫法应该是Mana"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MT – Main Tank的缩写，WOW中的主力抗怪角色，其它游戏中可以没有这样的描述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Muscle – 肌肉，多指游戏角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Nerf – 消弱"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Nerve – 神经，多指游戏角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Newbie – 菜鸟，形容新玩家，有时也指那些操作不熟练、技术不太好的玩家"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Newb – 新人的简称，同上"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ninja – 没有经过相关玩家允许或趁别人没注意而拿走战利品"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"N00b – 一种用来称呼新人的不礼貌的说法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NPC – Non-Player-Controlled Character，非玩家控制的角色，纯粹的电脑角色，由游戏控制"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OBT – Open Beta Test 游戏公开测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OOM – Out of Mana的简写，法力耗尽，多在组队中提醒队员注意"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ORZ – 一个人跪地的无语姿势，象形，表示钦佩的感叹"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OT – Over Taunt的缩写，别人的翻译是仇恨失控，怪物对玩家角色的仇恨，多用于WOW中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Party – 组队，与Team相近"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Password – 泛指密码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Patch – 补丁"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PC – Player controlled character，玩家控制的角色，与上面的NPC是相对的；网络中PC也很常见，指个人电脑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pet – 被玩家控制的非玩家生物，如宠物、召唤物等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PK – Player Kill或Player Killer，玩家在未经另一个玩家同意的情况下攻击并试图杀死他"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Player – 玩家，操作游戏中角色的人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PM – Personal Message的缩写，指一个玩家对另一玩家的私人会话"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"POP – Repopulation的缩写，指怪物刷新"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Portal – 泛指游戏内的传送"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Proc – 激活，多指一些武器、装备附加效果、属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PST – Please Send Tell的简写，指说话的人想通过 /t(ell) 或 /w(hisper) 命令交流"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Puller – 负责吸引怪物的玩家，常说引怪，与上面的Lure相近"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pulling – 队伍中的玩家负责吸引一只或几只怪物，并将他们带到队伍所在地，集体杀怪，这多指高级怪物的情况下，与上面的Lure不完全一样"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PvE – Player vs. Environment的简写， 玩家与电脑控制的角色战斗"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PVP – Player vs. Player的简写，玩家对玩家的战斗"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raid – 可译为突袭，由一群玩家在某一地区进行的大规模作战，有时也指团队副本、大副本"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Quest – 游戏中的任务"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Re-buff – 重新加有益状态"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Res – Resurrect / Rescure的缩写，指复活暂时死亡的角色"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Re-Spawn – 一只被杀死的怪物重新刷出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rest (state) – 角色疲劳状态，一般杀怪经验、物品掉率效率都受影响，是为了玩家健康而强制执行的一项措施"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Resistance – 对属性攻击的抵御(如，冰ice, 火fire, 点lighting, 毒poison等)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Respawn – 重生点复活"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Roll – 指掷随机数字来决定物品的归属"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Root – 给敌人施加的类似定身的状态"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Schedule – 泛指游戏内活动的日程表"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sever – 服务器，与游戏客户端相对"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Small Pets – 跟随玩家的小动物，可以称为宠物，是否直接影响玩家或怪物，要看具体的游戏设置了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SOLO – 单独杀怪、做任务等，不与别人组队的游戏玩法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Spawns – 在游戏世界中，怪物被刷出时所位于的地点或出现的过程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SPI – Spirit的简写，直译是灵魂，多指代游戏角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"STA – Stamina的缩写，耐力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stack – 堆放在同一个道具栏中的同类物品的数量，通俗讲就是叠加数量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"STR – Strength的缩写，力量，多指代游戏角色的属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stun – 击晕(状态)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tank – 能够承受很多伤害的近战角色，如一名战士，是抗怪的角色"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tap – 对怪物造成伤害，标为你的猎物，一旦你对怪物造成了伤害，只有你才能得到经验值和掠夺战利品"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Taunt – 直译是嘲弄的意思，指从其它玩家那里吸引怪物"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Team – 游戏内指组队，与Party相近；当用于游戏公司时指(游戏研发、运营)团队"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Threat – 直译是威吓的意思，有可能是指将怪物暂时镇住、吓走等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TPP – Third Party Programme，直译为第三方程序，就是平常的外挂"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Train – 把一群怪物引向另一名玩家，通俗讲就是陷害"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Twink – 高等级带练低等级玩家"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Über – super的德语说法，原意指over power, 极其强力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UC – Undercity 地下城"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Update – 与Upgrade意义相近，泛指游戏内的更新，如服务器更新、地图更新、道具更新等等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vendor Trash – 只有商人NPC才愿意购买的物品"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"VS – Ver Sus的简写，对决、挑战、单挑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WTB – Wanting to buy的缩写，想要购买"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WTS – Wanting to sell的缩写，想要出售"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"XP or Exp – Experience的简写，经验值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3D Accelerator：3D加速器。一种专门提升PC的3D运算功能硬件，但其不能提升计算"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"机整体的显示效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ACT（Action Game）：动作类游戏。这类游戏提供玩者一个训练手眼协调及反应力的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"环境及功能，通常要求玩者所控制的主角（人或物）根据周遭情况变化做出一定的动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作，如移动、跳跃、攻击、躲避、防守等，来达到游戏所要求的目标。此类游戏讲究逼"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"真的形体动作、火爆的打斗效果、良好的*作手感及复杂的攻击组合等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AI（Artificial Intelligence）：人工智能。就是指计算机模仿真实世界的行为方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与人类思维与游戏的方式的运算能力。那是一整套极为复杂的运算系统与运算规则。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Alpha：Alpha测试。就是指在游戏制作者控制的环境下进行的游戏测试工作，所以一"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"般来说a测试是在公司内部进行的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AVG（Adventure Game）：冒险类游戏。这类游戏在一固定的剧情或故事下，提供玩者"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个可解谜的环境及场景，玩者必须随着故事的安排进行解谜。游戏的目的是借游戏主"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"角在故事中所冒险积累的经验来解开制作者所设定的谜题或疑点。通常这类游戏常被用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"来设计成侦探类型的解谜游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"B"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Beta：Beta测试。就是指不在制作者控制的环境下进行的游戏测试工作，所以一般来"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说Beta测试则是交由选定的测试者单独来进行测试。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Boss：大头目，也称“老板”。在游戏中出现的较为巨大有力与难缠的敌方对手。一"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"般这类敌人在整个游戏过程中只会出现一次，而常出现在关底，而不像小怪物在游戏中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以重复登场。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Bug：程序漏洞，俗称“臭虫”。指那些因游戏设计者与测试者的疏漏而剩留在游戏中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"的程序错误，严重的话将影响整个作品的质量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cheat：游戏秘技。游戏设计者暗藏在作品中的特殊技巧，使用后可带给玩者特殊的能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"力与效果。最先是程序者为快速测试作品而设计的内部秘技，现在几乎已是每个游戏均"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有秘技。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clock Speed： 游戏执行速度。即游戏在计算机中被运行的速度，常以Megahertz"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（MHz）计量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Code：密码。1）同Cheat条；2）同Source Code条。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"D"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Doom-like： 三维射击类游戏。即第一人称射击类游戏。游戏画面即为玩者的视野范"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"围。现在此类游戏多称作Quake-like。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"E"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"E3（Electronic Entertainment Expo）：美国E3大展。 当前世界上最为盛大的电脑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏与电视游戏的商贸展示会，基本于每年五月举行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Easter Egg：复活节彩蛋。 程序中隐藏着的一段意外的内容，常为制作者设计的搞笑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内容，经常是关于制作者自己的介绍与调侃。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECTS（European Computer Trade Show）：欧洲计算机商贸展示会。被称为欧洲的E3"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大展，每年三月和九月于伦敦举行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Electronic Game：电子游戏。即电脑游戏、电视游戏以及街机和手掌型游戏机的总"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"称。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Engine：游戏引擎。 即一套游戏的主程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Experience Point：经验点数。常出现在角色扮演游戏中，以数值计量人物的成长，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"经验点数达到一定数值后常常会升级，这时人物就会变得更强大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"F"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FTG（Fighting Game）：格斗类游戏。从动作类游戏脱胎分化出来，就是指两个角色"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一对一决斗的游戏形式。现在此类游戏又分化出2D格斗类游戏与3D格斗类游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"First Person：第一人称视角。就是指屏幕上不直接出现主角，而是表现为主角的视"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"野范围。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Flight Sim：飞行模拟类游戏。是模拟类游戏下的一个门类，让玩家感受到*纵飞机以"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"及飞翔于蓝天上的乐趣。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FMV （Full-motion Video）：全动态影像。即游戏的片头、过场和片尾的动态画面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Forward Scrolling：向前卷轴。即背景不断向玩者趋近的卷轴模式，常出现在第一人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"称射击或模拟类游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Frame：帧，镜头。即显示画面的动态计量单位。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FPS（Frames Per Second）：每秒显示帧数。美国的标准NTSC的电视节目的每秒显示"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"帧数为30。不少电脑游戏的显示帧数都超过了这个数字。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Free Guy：额外的命。在游戏中，你有可能会获得的额外的命，比如收集一定数量的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"某种宝物。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"G"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Game Over：游戏结束。这是游戏中最常见的话语，通常是表示游戏者失败，而不是通"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关爆机。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Gameplay：游戏可玩性。即游戏的玩法，是决定一个游戏有多好玩的重要因素。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Genre：游戏类型。即为不同游戏玩法的游戏作一归类，比如角色扮演类、冒险类、动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作类、模拟类等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GPU （Graphics Processing Unit）： 图形处理器。辅助CPU处理图形运算。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Graphics Accelerator：图形加速器。专门的提升显示速度和效果的硬件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Graphic Adventure：图形冒险类游戏。是冒险类游戏下的一个门类， 相对与文字冒"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"险类游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GUI（Graphical User Interface）：图形用户界面。 即计算机与用户的交互界面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"H"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hidden Level：隐藏关卡。指游戏中隐藏的部分，自行发现。即不玩到这部分也能够"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通关，但玩到后可能会使清洁起变化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"High-Res：高解析度。 即精细的画面显示模式，但游戏的运行速度可能会因此有所下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"降。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hint：攻略提示。简单的攻关提示，帮助玩家解决游戏中出现的特别棘手的难题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HP（Hit Point）：生命力。即人物或作战单位的生命数值。一般HP为0即表示死亡，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"甚至Game Over。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HUD（Heads Up Display）：飞行仪表盘。飞行模拟游戏中的常见词，常提供玩家诸如"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"弹药状况、速度、目标跟踪等作战信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Interactive Movie：交互式电影。即结合游戏要素与电影要素的一类计算机互动作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"品，常常包含大量的FMV（全动态影像）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Interface：游戏界面。即玩者*作游戏的方式。它决定游戏的上手难度与可玩性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"J"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Joypad：游戏手柄。模拟电视游戏的手柄，通常外接在声卡上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Joystick：游戏"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"纵杆。常用来玩飞行、赛车等模拟类游戏的外接"}]},{"type":"text","value":"纵杆。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"K"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"L"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Level：关卡。即游戏一个连续的完整的舞台、场景。有时也称作Stage。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Low-Res：低解析度。即粗糙的画面显示模式，但运行速度可稍微提高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"M"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Motion Capture：动态捕捉。将物体在3D环境中运动的过程数字化的过程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Motion Tracker：动作跟踪器。动态捕捉时使用到的设备。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Moves：出招。即格斗游戏中人物的出招技巧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MP（Magic Point）：魔法力。即人物的魔法数值，一旦使用完即不能再使用魔法招"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MUD（Multi-user Dungeon）：多用户地牢，俗称“泥巴”。在互联网络上的一种允许"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多人参与的实时游戏，一般类似RPG的玩法，但目前多为文字模式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Multimedia：多媒体。主要指融合多种表现手法的电脑作品。比如FMV（全动态影"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"像），电脑游戏、交互作品等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"N"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Network Games：网络游戏。指容许多人通过某种网络协议连线后便能进行集体游戏的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏种类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NPC（Non Player Character）：非玩者人物。在角色扮演游戏中，玩者会在游戏过程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"中遭逢到的所有不受控制的人物。这些人物或会提示重要情报线索，或是无关紧要的人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"物。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"O"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"P"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Password：过关密码。在游戏一开始处输入后便能直接进入后面的关卡。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pirate：盗版游戏。即国内到处泛滥令游戏制作公司头痛不已的盗版游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pixel：像素。屏幕显示的最小基本单位。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Platformer：游戏平台。游戏运行的平台，包括Win95、DOS或者UNIX等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Player Killing：玩者杀手。指在MUD中，专以攻击玩者人物，而不是非玩者人物的一"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Polygon：多角形。运用在2D屏幕中表现3D环境的多角形单位。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Prototype：原型制作。游戏作品的原型制作也就是指以最快的速度制作出游戏的原"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"型，一个可以执行的程序原型。从这些基础程序与基础图形，制作者可以看到从电脑中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"表现出来的与原来设想的有多大差距，经过调整磨合后就进入了正式动工了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Puzzle：谜题。在冒险类游戏中，考验玩者智力的谜题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PZL（Puzzle Game）：解谜类游戏。一类专以不断解谜为主要内容的游戏种类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Q"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Quake-like：三维射击类游戏。即第一人称射击类游戏。见Doom-like条。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"R"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Round：回合。格斗类游戏中的一个较量的回合。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RPG（Role Playing Game）：角色扮演类游戏。这类游戏提供玩者一个可供冒险的世"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"界（Fantasy World）或者一个反映真实的世界（Real World），这世界包含了各种角"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"色、建筑、商店、迷宫及各种险峻的地形。玩者所扮演的主角便在这世界中通过旅行、"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"交谈、交易、打斗、成长、探险及解谜来揭开一系列的故事情节线索，最终走向胜利的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"彼岸。玩者依靠自身的胆识、智慧和机敏获得一次又一次的成功，使自己扮演的主角不"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"断发展壮大，从而得到巨大的精神满足。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RTS（Realtime Strategy Game）： 即时战略类游戏。对应回合制战略游戏，一切都"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是实时发生，要求玩者具备较好的敏捷与宏观指挥能力。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"S"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Scaling：缩放比例。有些游戏提供画面的缩放比例的调整。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Second Person：第二人称视角。即追尾视角，紧随游戏主角的背影。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Shareware Software：共享软件作品。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Side-Scrolling：横向卷轴。即游戏画面的前景与背景从左向右移动的卷轴模式，常"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用于2D射击游戏中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SLG（Simulation Game）：模拟类游戏。这类游戏提供玩者一个可以做逻辑思考及策"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"略、战略运用的环境，且让玩者有自由支配、管理或统御游戏中的人、事或物的权力，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"并通过这种权力及谋略的运用达成游戏所要求的目标。玩者在条件真实、气氛宏大的游"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"戏环境中充分施展智慧，克敌制胜，达到高层次的成功享受。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Source Code：原代码。用计算机语言直接编成的程序原码，比如C语言、Pascal。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SPT（Sport）：运动类游戏。这类游戏提供一个反映现实（指正常的运动方式及运动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"精神）中的运动项目，并让玩者借助控制或管理游戏中的运动员或队伍，来进行运动项"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目的比赛。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage：关卡。见Level条。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"STG（Shooting Game）：射击类游戏。有平面射击类与三维射击类（即第一人称射击"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类）。平面射击类还包括横向卷轴与纵向卷轴两种。射击类游戏是早期电脑游戏最常见"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"的种类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Storyline：剧情。即游戏的故事大纲，分为直线型、多线型以及开放型等三种。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Strategy Guide：战略指南手册。即游戏包装盒内附有的基本战略指导手册。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sub-boss：隐藏头目。有些游戏中会隐藏有更厉害的大头目，通常是在通关后。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"T"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TAB（Table）：桌面类游戏。这类游戏提供一个训练逻辑思考或解谜的环境，并且有"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一定的规则及逻辑。玩者必须遵循游戏所设定的规则来解开谜题，达成游戏目标。此类"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏讲究高超的人工智能、新奇的玩法和舒适的*作环境。玩者在游戏中自得其乐、逍"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"遥自在，也是一番享受。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TBS（Turn-based Strategy Game）：回合制战略游戏。对应即时战略类游戏。参加战"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"斗的几方，可以包括计算机在内，依一定顺序分别部署战略。一次部署便称作一个回"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"合。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tester：游戏测试者。游戏制作公司专门花钱聘请的测试作品的资深玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Text Adventure：文字冒险类游戏。是冒险类游戏下的一个门类， 相对与图形冒险类"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏，多是日本制作的小成本卡通游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Third Person：第三人称视角。电脑游戏中最常见的视角，尤其是2D游戏。玩者是以"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第三者的角度观察场景与主角的动作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"U"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"V"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vertically Scrolling：垂直卷轴。即游戏画面的前景与背景从向下向上移动的卷轴"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式，常用于2D射击游戏中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"View：视角。目前许多3D游戏均提供多视角调整功能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"VR （Virtual Reality）：虚拟实境。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"W"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Walkthrough：游戏攻略。是指完整的游戏攻关指导。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"X"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Y"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Z"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Z-line/Z-axis：Z轴。在3D环境中，Z轴一般表示深度，X轴表示高度，Y轴表示宽度，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而具备了Z轴就构成了3D环境。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WOW九大职业：\n法师mage 战士warriop 德鲁依 drvid 撒满shamam 圣骑士 paladin 术士warlock 盗贼rogue 牧师prisst 猎人 hunter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"角色基本术语："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　AR——AttackRating攻击准确率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Blocking——ChanceOfBlocking搁挡机率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　bloodrun——就是杀怪物，吸取经验值了。一般特指在act5出门之后第一个砍人的地方，叫BloodyFoothills。HC玩家经常在那里升级，比牛关更安全。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CB——CrushingBlow压碎性打击"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CE——coldenhanched冰冷强化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Char——Character角色"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CR——coldresist冰冷抵抗力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　dam——Damage伤害值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Def/DR——Defencerating防御度"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DEX——dexterity敏捷度"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Dr——damagereduce物理伤害减少(物免)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DS——DeadlyStrike致命攻击"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Dualleech——(life，mana)双吸"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ED——EnhanchedDamage/EnhanceDefense增强伤害/增强防御(多指前者)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Eng/Erg/Nrg——energy能量/精力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Eth——Ethereal/ethrune无形的(物品)/第五号符文，有将目标Defense防御力降至负值的Bug效果，常镶在武器上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Exp/XP——Experiencepoint经验值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FBR——fastblockingrate快速格挡机率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FCR——Fastcastrate快速施法率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fr/w——Fastrun/walk快速奔跑/行走"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FHR——Fasthitrecover快速打击恢复"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FR——fireresist火焰抵抗力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FE——fireenhanched火焰强化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　HP——HitPoints生命值(life)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　IAS——IncreasedAttackSpeed提升攻击速度。繁体中文版误译成提升xx%的准确率，繁体中文版的改良补丁有修正。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ITD——IgnoresTarget‘sDefense忽视目标防御"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　KB——Knockback击退"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LE——lightningenhanched闪电强化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Leecher吸血鬼，就是汲取他人的XP来达到足够的clvl，相信大家都做过Leecher吧"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　life生命值又称：HitPoints(HP)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　lightningenhanchedmultishot闪电强化兼多重射击(祈祷你别碰上吧@-@)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LR——lightningresist闪电抵抗力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　mana法力值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　mod——itemmodifier(prefixesandsuffixes)物品属性(前缀及后缀)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MF——MagicFind魔法物品找寻"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Newbie——就是你了(新手)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　NPC——Nonplayercharacter非玩家角色"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PD——poisondamage毒素伤害(骗点？@_@)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PI——Physicalimmune物理免疫"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PR——poisonresist毒素抵抗力"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Req——Required/Requirement需求"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　res——Resistance元素抵抗(四防)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　slvl——Skilllevel技能等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　stamina耐力值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　STR——strength强壮度/力量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　TP——TownPortal/Teleport城镇传送之门/傳送(女巫技能)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　UnID——Unidentify未鉴定"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　VIT——vitality活力/体力值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　WP——Waypoint传送小站"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　XP/Exp——Experiencepoint经验值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　增补术语："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BOT——英文Robot的简写，通指各种自动机器人的游戏外挂，譬如KPBOT(自动KP机器人)，SHOPBOT(自动购物机器人)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Dupe——英文duplicate的简写，指复制的装备"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Legit——合法物品，指从游戏中真真生成的非Dupe物品(包括BOT打出的物品)，交易用语"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Ith——某种利用hack工具制造的Bug物品,多为武器，具有极为变态的伤害值及属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　cg——ChippedGem碎裂的宝石"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　pg——PerfectGem完美的宝石"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PT——PerfectTopaz完美的黄宝石"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Jewels——珠宝"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Rune——符文"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SC——smallcharm小护身符，一般特指7%MF的smallcharm"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LC——LargeCharms大型护身符"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　GC——GrandCharms超大型护身符"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　cube——TheHoradriccube赫拉迪克方块，常做动词用，指用Cube转化或合成物品的行为"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Craft——指物品的手工合成，即其英文原意"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MBow——MatriarchalBow女族長之弓，用做DIY合成Curel蓝色Bow的材料，要求其Ilvl物品等级>87。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　N‘sc或B‘sc——通指Hell的Baal巴爾(怪物等级Mlvl=95)、Nihlathaks尼塞拉克(怪物等级Mlvl=98)掉出的SC。整个游戏中只有这二位老大出产的SC才可能合出那几种高元素或毒伤害前缀的SC(其Ilvl≥95)。Baal巴爾、Nihlathaks尼塞拉克掉出的GC没什么特别用处。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Diadem權冠——6PerfectSkulls合成RareCirclets稀有头缳用的材料，因为Diadems总能保持Alvl99，能够合出任何可能的词缀。亮黄的RareDiadem或白色的Diadem(可以利用Imbue任务将之造成亮黄的)都可以用做材料。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Clvl—Characterlevel角色等级，很简单的概念，就是指玩家自己角色的级别"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Mlvl——MonsterLevel怪物等级，游戏代码中对三个难度的每一个怪物都有固定的等级设定。普通怪物从1-90级，champions，bosses，SuperUniques相对其同类型的普通怪物会加几个等级。譬如Hell的Baal巴爾其怪物等级Mlvl=95、Nihlathaks尼塞拉克其怪物等级Mlvl=98，它们能够出产Cube用的N‘sc。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Ilvl——ItemLevel物品等级，也就是不少玩家俗称的物品内部等级；它是一个变动的数字，其数值就等于各游戏难度掉落该物品的怪物(或者箱子)等级(Mlvl-MonsterLevel)；目前的新版地图都具有了显示怪物等级的功能，省了大家再去翻看资料了。唯一要注意的是不要把怪物等级(Mlvl-MonsterLevel)和怪物所属的的TC-TreasureClass(财宝阶层)混淆"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　TC——TreasureClass财宝阶层，游戏中划分一组相近物品的游戏代码术语，用于决定物品的生成。玩家们谈论TC时通常会涉及到武器和防具其中之一。武器和防具各自有30个TCs相对应，从3-90，每隔3升一级。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Alvl——AffixLevel词缀等级，游戏中对每一个魔法前缀和后缀有相应的等级设定，这将决定什么样的Ilvl物品等级才能出现它们"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ama:\nBowazon使用Bow或Crossbow类武器为主要攻击手段的Amazon；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Jabazon使用Spears类武器，并以Jab为主要攻击手段的Amazon；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Javazon使用投掷类(主要是Javelins标枪)武器，并以Lightningfury或PlagueJavelin为主要攻击手段的Amazon；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BowandCrossbow——弓箭和弩箭技能树——弓和十字弓技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MagicArrow——魔法箭——魔法箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FireArrow——火之箭——火焰箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ColdArrow——冷之箭——冰箭；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MultipleShot——多重打击——多重箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ExplodingArrow——爆破箭——爆裂箭；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　IceArrow——冰之箭——急凍箭；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　GuidedArrow——向导之箭——導引箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Strafe——惩罚——砲轟；俗称:扫射"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ImmolatingArrow——火墙箭——犧牲之箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FreezingArrow——冷冻箭——凍結之箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PassiveandMagic——被动与魔法技能——被動和魔法技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　InnerSight——心灵视觉——内視；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CriticalShot——临界一击——致命攻擊；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Dodge——躲避——閃避；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SlowMissiles——缓慢攻击——慢速箭；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Avoid——消除——躲避；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Penetrate——渗透——刺入；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Decoy——诱骗——誘餌；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Evade——规避——迴避；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Valkyrie——瓦尔基里——女武神；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Pierce——刺穿——穿刺；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　JavelinandSpear——标枪和魔法技能树——標槍和長矛技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Jab——猛刺——戳刺；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PowerStrike——能量穿透——威力一擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PoisonJavelin——毒之枪——毒槍；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Impale——穿刺——刺爆；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LightningBolt——闪电——閃電球；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ChargedStrike——冲刺打击——充能一擊"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PlagueJavelin——瘟疫之枪——瘟疫標槍；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fend——保护——擊退；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LightningStrike——闪电打击——閃電攻擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lightningfury——狂暴闪电——閃電之怒；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　亚马逊常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Buriza-DoKyanon布理撒多凱南俗称：玻璃渣/大炮；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelMatriarchalBow残忍的女族長之弓。最常见的DIYBow；简称：CMBow"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DIYBow就是玩家自己cube或shopping来再镶以40ED/15IASJewel的Bow。以其无可比拟的高速Frame为部分玩家所喜好；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Eaglehorn鷹號角简称；或称EBow"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　GoldstrikeArch金色的曲线；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lycander‘sAim雷山得的指標；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lycander‘sFlank雷山得的側腹；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　M‘avina‘sCaster马维娜的施展------马维娜之战斗诗歌；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Titan‘sRevenge泰坦的復仇简称；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Windforce風之力简称；\nasn:\nTrapper以Traps陷阱系技能为主要攻击方式的Assassin；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MAAsn以MartialArt武术系技能为主要攻击方式的Assassin；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　c/cAsn使用claw+claw双爪作战的Assassin;又称：DualclawAsn；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　c/sAsn使用claw+shield爪盾组合方式作战的Assassin；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DualclawAsn即c/cAsn；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MartialArt——武术技能树——武學藝朮简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　TigerStrike——虎击——虎擊；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DragonTalon——龙足——龍爪；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DragonClaw——龙爪——雙龍爪；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FistsofFire——火拳——焰拳；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CobraStrike——眼镜蛇之击——眼鏡蛇攻擊；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DragonTail——龙尾——神龍擺尾；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ClawsofThunder——雷鸣爪——雷電爪；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BladesofIce——冰之刃——寒冰刃；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DragonFlight——龙翔——飛龍在天；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PhoenixStrike——凤舞——鳳凰攻擊；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShadowDisciplines——幻影技能树——影子訓練"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ClawMastery——钢爪精通——支配利爪；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PsychicHammer——通灵之锤——心靈戰槌；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BurstofSpeed——爆发速度——加速；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CloakofShadows——幻影披风——魔影斗篷；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　WeaponBlock——武器格挡——武器格擋；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fade——消退——能量消解；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShadowWarrior——幻影战士——影子戰士；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MindBlast——意识攻击波——精神爆震；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Venom——毒液——毒牙；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShadowMaster——幻影精通——支配影子；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Traps——陷阱技能树——陷阱"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FireBlast——火焰冲击波——火焰爆震；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShockWeb——电击网——閃電網；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BladeSentinel——刀刃哨兵——刃之守衛；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ChargedBoltSentry——闪电岗哨——電能守衛；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　WakeOfFire——火之复苏——火焰復甦；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BladeFury——狂暴之刃——刃之怒；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LightningSentry——闪电陷阱——雷光守衛；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　WakeOfInferno——地狱火之复苏——復甦獄火；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DeathSentry——死亡陷阱——亡者守衛；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BladeShield——刀盾——刀刃之盾；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　刺客常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Bartuc‘sCut-Throat巴特克的猛擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Natalya‘sMark娜塔垭的标记------娜塔亚的非难俗称：绿爪，AsnSetClaws"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　还有部分Cruel前缀的Elite蓝色爪(有些是Ethereal无形的)；比如常见的CruelScissorsSuwayyah残忍的近身剪；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelScissorsSuwayyahofQuickness残忍之快速的近身剪；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"bar:\nSsbar以Sword+Shield剑盾组合方式作战的Barbarian，目前的主流Bar玩法，多以WW为主要攻击技能；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Throwingbar使用投掷类(Javelins标枪较好)武器，以Doublethrow为主要攻击技能的Barbarian；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Frenzybar使用双手武器，以Frenzy为主要攻击技能的Barbarian；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Spearian以Spears类武器为主要攻击手段的Barbarian；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　WarCries——战斗呼声技能树——呐喊"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Howl——怒吼——狂嚎；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Findpotion——寻找药剂——找尋藥劑；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Taunt——辱骂——嘲弄；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Shout——咆哮——大叫；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Finditem——寻找物品——找尋物品；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Battlecry——战斗口号——戰嚎；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Battleorders——战斗号令——戰鬥體制；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　GrimWard——严密防护——殘酷嚇阻；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Warcry——战争呼声——戰鬥狂嚎；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Battlecommand——战斗命令——戰鬥指揮；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CombatMasteries——战斗动作掌握技能树——戰鬥專家"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Swordmastery——剑术掌握——支配長劍；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Axemastery——战斧掌握——支配斧頭；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Macemastery——钉头槌掌握——支配釘頭槌；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Polearmmastery——长杆武器掌握——支配長棍；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Throwingmastery——投掷武器掌握——支配飛擲；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Spearmastery——枪矛掌握——支配長矛；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Increasedstamina——增强持久力——增加耐力；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Ironskin——钢铁皮肤——鉄布杉；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Increasedspeed——增强移动力——加速；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Naturalresistance——自然抗力——自然抵抗；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Combat——战斗技能树——戰鬥技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Bash——怒殴——重擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Leap——飞跃——跳躍；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Doubleswing——双重挥舞——雙手揮擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Stun——晕眩——擊昏；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Doublethrow——双重投掷——雙手投擲；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Leapattack——跳跃攻击——跳躍攻擊；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Concentrate——集中——專心；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Frenzy——狂怒——狂亂；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Whirlwind——旋风——旋風；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Berserk——狂暴——狂戰士；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　野蛮人常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BulKathosSacredCharge布爾凱索的神聖代價------布爾凱索的孩子俗称：Set大剑；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BulKathosTribalGuardian布爾凱索的部族守护------布爾凱索的孩子俗称：Set小剑；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelColossusBlade残忍的巨神之刃简称：CCB；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelColossussword残忍的巨神之剑简称：CCS；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelColossusBladeofQuickness残忍之快速的巨神之刃简称：就是著名的CCBQ了；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelColossusBladeofSwiftness残忍之敏捷的巨神之刃简称：CCBS；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelHyperionJavelin残忍之亥伯龍之槍(throwingbar推荐选用)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelWingedHarpoon残忍之翼魚叉(throwingbar推荐选用)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Doombringer末日毀滅者；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　TheGrandfather祖父;简称：GF(女朋友？@_@:$)；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lightsabre光之軍刀；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　fury神符之语剑狂暴，常用BalrogBlade制作；\ndru:\nElementalistDruid以Elemental元素系技能为主要攻击方式的Druid；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Grizzlygeddon使用Armageddon+SummonGrizzly为主要攻击技能的Druid；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　WWdruid即werewolfdruid，就是变狼的Druid；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Elemental——自然力技能树——元素"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Firestorm——暴火——火風爆；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　MoltenBoulder——熔石——熔漿巨岩；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ArcticBlast——北极冰风——極地風暴；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fissure——裂缝——火山爆；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CycloneArmor——暴风盔甲——颶風裝甲；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Twister——缠绕——縑鼬風；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Volcano——火山——火山；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Tornado——龙卷风——龍捲風；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Hurricane——飓风——暴風；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Armageddon——末日战唱—毀天滅地；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShapeShifting——形态转变技能树——外型變形"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Werewolf——人狼——狼人變化；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lycanthropy——变狼狂——變形朮；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Werebear——人熊——熊人變化；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Maul——大槌——撞槌；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FeralRage——野兽的愤怒——野性狂暴；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FireClaws——火爪——焰爪；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Rabies——狂犬——狂犬病；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShockWave——冲击波——震波；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Hunger——饥饿——飢餓；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fury——狂怒——狂怒；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Summoning——召唤技能树——召喚"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Raven——乌鸦——烏鴉；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PoisonCreeper——毒藤——猛毒花藤；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　OakSage——橡树贤者——橡木智者；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SummonSpiritWolf——召唤精灵狼——召喚鬼狼；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CarrionVine——死腐藤——食尸藤；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　HeartofWolverine——狼之心——狼獾之心；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SummonDireWolf——召唤恶狼——召喚狂狼；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SolarCreeper——太阳藤蔓)(太陽藤；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SpiritofBarbs——精神倒刺——棘靈；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SummonGrizzly——召唤灰熊——召喚灰熊；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　德鲁依常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Baranar‘sStar巴拉那之星；有时可简称为DS;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Buriza-DoKyanon布理撒多凱南俗称：玻璃渣/大炮；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelColossusBladeofQuickness残忍之快速的巨神之刃;简称：就是著名的CCBQ了；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Hellslayer地獄毀滅者；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ImmortalKing‘sStoneCrusher不朽之王的石头压碎者；简称；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Messerschmidt‘sReaver希梅斯特的掠奪；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Schaefer‘sHammer史恰佛之鎚；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　TheCraniumBasher碎腦槌；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"nec:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Zookeeper以Summoning为主要技能，辅以各种Curses的Necromancer；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Meleemancer以近身格斗为主要攻击手段，而不依赖召唤大批奴仆的肉搏型Necromancer；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Poisonmancer以毒系技能为主要攻击方式，有些以骨系技能辅助的Necromancer；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Venomancer用PoisonDagger攻击的Necromancer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Summoning——召唤系技能树——召喚法術"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Skeletonmastery——骷髅掌握——支配骷髏；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Raiseskeleton——复活骷髅——骷髏復甦；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ClayGolem——土之巨人——黏土石魔；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　GolemMastery——傀儡掌握——支配石魔；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Raiseskeletalmage——复活骷髅魔法师——復甦骷髏法師；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BloodGolem——血之巨人——鮮血石魔；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Summonedresistance——召唤反抗——召喚抵抗；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　IronGolem——钢铁巨人——鋼鐵石魔；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FireGolem——火之巨人——火焰石魔；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Revive——复兴——重生；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Poisonandbone——毒系骨系技能树——毒素和白骨法術"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Teech——牙齿术——牙；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BoneArmor——骨之护甲——白骨裝甲；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PoisonDagger——毒之匕首——淬毒匕首；简称(骗点？)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CorpseExplosion+——尸体爆炸术——屍體爆炸；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BoneWall——骨墙术——骨墻；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PoisonExplosion——毒气爆炸术——毒爆；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BoneSpear——骨之长矛——骨矛；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BonePrison——骸骨监狱——骨牢；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　PoisonNova——毒之雷星——劇毒新星；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Bonespirit——骨之灵魂——白骨之魂；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Curses——诅咒系技能树——詛咒"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　AmplifyDamage——加大伤害——傷害加深；简称/Ad"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DimVision——视力模糊——微暗靈視；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Weaken——弱化——削弱；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Ironmaiden——钢铁处女——攻擊反噬；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Terror——恐怖——恐懼；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Confuse——混乱——迷亂；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LifeTap——生命源泉——偷取生命；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Attracc——吸引——吸引；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Decrepify——衰老——衰老；简称/Dec"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LowerResist——降低抵抗力——降低抵抗；简称(烂人@_@)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　巫师常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　SuicideBranch自殺支系；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BlackhandKey黑手之鑰；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Wizardspike巫師之刺；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pal:\nAvenger以Vengeance+Conviction为主要攻击技能的Paladin；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Charger/Chargedin以Charge为主要攻击技能的Paladin；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Hammerdin以Concentration+Blessedhammer为主要攻击技能的Paladin；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Zealot使用Zeal为为主要攻击技能的Paladin；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　DefensiveAuras——防御技能树——防禦性靈氣"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Prayer——祈祷——祈禱；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ResistFire——火之光环——抗火；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Defiance——藐视光环——反抗；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ResistCold——冰之光环——抗冰冷；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Cleansing——洁净光环——淨化；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ResistLightning——闪电光环——抵抗閃電；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Vigor——活力光环——精力；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Meditation——冥想光环——冥想；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Redemption——补偿光环——救贖；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Salvation——拯救光环——救助；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　OffensiveAuras——攻击技能树——攻擊靈氣"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Might——力量光环——力量；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Holy-Fire——神圣之火——聖火；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Thorns——荆棘光环——刺針；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BlessedAim——祝福光环——祝福瞄準；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Concentration——集中——專注；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　HolyFreeze——圣洁寒冰——神聖冰凍；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　HolyShock——神圣打击——聖光衝擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Sanctuary——避难所——庇護所；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fanaticism——狂热——狂熱；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Conviction——审判——信念；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Combat——战斗技能树——作戰技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Sacrifice——牺牲——犧牲；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Smite——重击——重擊；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Holybolt——圣光术——聖光彈；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Zeal——热诚——白熱；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Charge——冲锋——突擊"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Vengeance——复仇——復仇；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Blessedhammer——神圣之槌——祝福之錘；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Conversion——转化——轉換；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Holyshield——神圣之盾——神聖之盾；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fistoftheheavens——天神之手——天堂之拳；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　圣骑士常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Baranar‘sStar巴拉那之星；有时可简称为DS;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Griswold‘sRedemption格瑞斯华尔德的救赎------格瑞斯华尔德的的传奇；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lightsabre光之軍刀；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Sazabi‘sCobaltRedeemer沙撒壁的忏悔之钴------沙撒壁的雄伟贡品；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Schaefer‘sHammer史恰佛之鎚；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　还有部分Cruel前缀或做成fury的Elite武器比如：PhaseBlade，ConquestSword，CrypticSword,MythicalSword，BerserkerAxe,其中PhaseBlade不能通过Cube合成获得Cruel的前缀；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sor:\nBoltress以ChargedBolt为主要攻击技能的Sorceress；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Tweaker指一部分将FCR(FasterCastRate快速施法率)增强到max的Sorceress；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Cold——冰系技能树——冰凍法術"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Icebolt——冰箭——冰彈；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FrozenArmor——寒冰护甲——冰封裝甲；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FrostNova——霜之星——霜之新星；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　IceBlast——寒冰冲击波——冰風暴；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ShiverArmor——战栗护盾——碎冰甲；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　GlacialSpike——冰之长钉——冰尖柱；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Blizzard——暴风雪——暴風雪；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ChillingArmor——寒冷装甲——寒冰裝甲；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FrozenOrb——冰冻球——冰封球；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ColdMatery——寒冰掌握——支配冰冷；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lighting——闪电系技能树——閃電法術"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ChargedBolt——闪电弹——充能彈；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　StaticField——静力唱—靜態力場；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Telekinesis——心灵念力术——心靈傳動；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Nova——雷星术——新星；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Lightning——闪电——閃電；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ChainLightning——连环闪电——連鎖閃電；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Teleport——心灵传送术——傳送；简称/TP"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　ThunderStorm——雷暴术——雷云風暴；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　EnergyShield——能量盾——能量護盾；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　LightningMastery——闪电掌握——支配閃電；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fire——火系技能树——火焰法術"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Firebolt——小火球——火彈；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Warmth——热情——暖氣；简称:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Inferno——地狱火——地獄之火；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Blaze——火焰道标——熾烈之焰；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Fireball——大火球——火球；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Firewall——火墙术——火墻；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Enchant——施魔——強化；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Meteor——流星——隕石；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Hydra——守护神——九頭海蛇；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　FireMastery——火系掌握——支配之焰；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　女巫常用武器装备中英文名称对照："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　BladeOfAliBaba阿里巴巴之刃；简称"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Gull海鷗;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　KelpieSnare水魔陷阱，这个当然不是给女巫MM用的啦，是给我们的\"小强\"用的；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　TheOculus眼球简称；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　Wizardspike巫師之刺；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"　　有时一些属性JP的RareOrb也常常会被部分pvp女巫使用；"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-02-05-game_en_zh.md","_source":"content","_file":"tool/2020-02-05-game_en_zh.md","_extension":"md","date":"2020-02-05"},{"_path":"/tool/2020-02-06-excel-text-number","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"Excel中以文本形式存储的数字","description":"在一些特定情况下，单元格中会出现文本形式存储的数字，例如从其他地方复制粘贴过来，或者是较长的数字想要完全显示，设置为文本格式。如果是这样的单元格，在左上角就会有一个绿色小标记。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在一些特定情况下，单元格中会出现文本形式存储的数字，例如从其他地方复制粘贴过来，或者是较长的数字想要完全显示，设置为文本格式。如果是这样的单元格，在左上角就会有一个绿色小标记。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-06-excel/v2-7f8eb44c9239a43b4835c12ba326c2d9_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"针对不同需求的单元格，进行数据处理的方式也不同。例如有些数字，在后面是需要进行公式计算的，就可以将单元格从文本转化为普通的数字形式。选中需要修改的单元格，如果在一个区域的话可以选中全部的，然后点击右上角浮动的感叹号，在菜单里面选择“转换为数字”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-06-excel/v2-b825acebee4b0d575dafcbbb9d85079e_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样一来，单元格格式就会变回常规，绿色小三角也会自动消失。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-06-excel/v2-6be2034cecf7128cfdd94adfe2b89d21_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有时候数字较长，例如手机号，也不需要进行公式运算。但是有一个绿色标志，希望去掉，也是可以进行操作的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-06-excel/v2-2b7e7de81faec0a733820a239dbff044_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在菜单中选择“忽略错误”即可，这个绿色小三角就会消失了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-06-excel/v2-2d84b687d6c420607a09f8dd93146b62_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但要注意的是，双击编辑过这个单元格以后，还是会出现绿色小三角标记的错误提示的。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-02-06-excel-text-number.md","_source":"content","_file":"tool/2020-02-06-excel-text-number.md","_extension":"md","date":"2020-02-06"},{"_path":"/tool/2020-03-25-protobuf-empty-collections","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"protobuf序列化的一些问题","description":"Each derived class must have its base class marked with [ProtoInclude(, typeof(ProtoBuff-Derived-Class))]. If not, all values will be NULL.","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"base-derived-classes"},"children":[{"type":"text","value":"Base / Derived Classes"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Each derived class must have its base class marked with [ProtoInclude(, typeof(ProtoBuff-Derived-Class))]. If not, all values will be NULL."}]},{"type":"element","tag":"pre","props":{"code":"[ProtoContract]\n[ProtoInclude(100, typeof(HomeFolders))]\n[ProtoInclude(200, typeof(PublicFolders))]\npublic class Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember1 { get; set; }\n\n  [ProtoMember(2)]\n  public int ProtoMember2 { get; set; }\n}\n\n[ProtoContract]\npublic class HomeFolders : Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember4 { get; set; }\n}\n\n[ProtoContract]\npublic class PublicFolders : Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember5 { get; set; }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[ProtoContract]\n[ProtoInclude(100, typeof(HomeFolders))]\n[ProtoInclude(200, typeof(PublicFolders))]\npublic class Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember1 { get; set; }\n\n  [ProtoMember(2)]\n  public int ProtoMember2 { get; set; }\n}\n\n[ProtoContract]\npublic class HomeFolders : Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember4 { get; set; }\n}\n\n[ProtoContract]\npublic class PublicFolders : Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember5 { get; set; }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"avoid-duplicate-property-tags"},"children":[{"type":"text","value":"Avoid duplicate property tags"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using the same number for ProtoInclude and ProtoMember will generate an error about duplicate property tags. The example below is "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"NOT"}]},{"type":"text","value":" correct."}]},{"type":"element","tag":"pre","props":{"code":"[ProtoContract]\n[ProtoInclude(1, typeof(PublicFolders))]\npublic class Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember1 { get; set; }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[ProtoContract]\n[ProtoInclude(1, typeof(PublicFolders))]\npublic class Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember1 { get; set; }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So you need to use a different number for ProtoInclude. Corrected example:"}]},{"type":"element","tag":"pre","props":{"code":"[ProtoContract]\n[ProtoInclude(100, typeof(PublicFolders))]\npublic class Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember1 { get; set; }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[ProtoContract]\n[ProtoInclude(100, typeof(PublicFolders))]\npublic class Folders\n{\n  [ProtoMember(1)]\n  public int ProtoMember1 { get; set; }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"null-vs-empty-collections"},"children":[{"type":"text","value":"Null vs. Empty Collections"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ProtoBuf does not understand the difference between a collection (List, IEnumerable etc) being null versus empty (zero count). For example, if you put these objects into the cache,"}]},{"type":"element","tag":"pre","props":{"code":"List<int> list1 = new List<int>();\nList<int> list2 = null;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"List<int> list1 = new List<int>();\nList<int> list2 = null;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"after deserialization, both the lists will have the same value—that is NULL. There are two ways to solve this:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Using a private field (we are using this):"},{"type":"element","tag":"pre","props":{"code":"[ProtoMember(12, OverwriteList = true)]\nprivate List _publicFolders;\npublic List publicFolders\n{\n  get\n  {\n    if (_publicFolders == null)\n    {\n      _publicFolders = new List();\n    }\n    return _publicFolders;\n  }\n  set\n  {\n    _publicFolders = value;\n  }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[ProtoMember(12, OverwriteList = true)]\nprivate List _publicFolders;\npublic List publicFolders\n{\n  get\n  {\n    if (_publicFolders == null)\n    {\n      _publicFolders = new List();\n    }\n    return _publicFolders;\n  }\n  set\n  {\n    _publicFolders = value;\n  }\n}\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Using the OnDeserialized attribute:"},{"type":"element","tag":"pre","props":{"code":"[ProtoMember(2, OverwriteList = true)]\nprivate PublicFolder[] publicFolders;\n[ProtoMember(3, OverwriteList = true)]\nprivate PrivateFolder[] privateFolder;\n[ProtoMember(4, OverwriteList = true)]\nprivate SecureFolder[] secureFolder;\n\n[OnDeserialized]\nprivate void HandleSerializationMismatch(StreamingContext context)\n{\n  publicFolders = publicFolders ?? new PublicFolders[0];\n  privateFolder = privateFolder ?? new PrivateFolder[0];\n  secureFolder = secureFolder ?? new SecureFolder[0];\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[ProtoMember(2, OverwriteList = true)]\nprivate PublicFolder[] publicFolders;\n[ProtoMember(3, OverwriteList = true)]\nprivate PrivateFolder[] privateFolder;\n[ProtoMember(4, OverwriteList = true)]\nprivate SecureFolder[] secureFolder;\n\n[OnDeserialized]\nprivate void HandleSerializationMismatch(StreamingContext context)\n{\n  publicFolders = publicFolders ?? new PublicFolders[0];\n  privateFolder = privateFolder ?? new PrivateFolder[0];\n  secureFolder = secureFolder ?? new SecureFolder[0];\n}\n"}]}]}]}]},{"type":"element","tag":"h1","props":{"id":"things-to-remember"},"children":[{"type":"text","value":"Things to Remember"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ProtoBuf ignores properties if the class inherits from a collection and the Items property for that collection is null. Example:"}]},{"type":"element","tag":"pre","props":{"code":"public class Folders : List\n{\n  public int value1 { get; set; }\n\n  public int value2 { get; set; }\n}\n\nFolders folders = new Folders() { value1 = 5; value2 = 6; };\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Folders : List\n{\n  public int value1 { get; set; }\n\n  public int value2 { get; set; }\n}\n\nFolders folders = new Folders() { value1 = 5; value2 = 6; };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After deserialization, the value of the Folders object will be NULL, because the count of items on is 0."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Classes that inherit from special collections are also not supported."}]},{"type":"element","tag":"pre","props":{"code":"public class Folders : ReadOnlyCollection\n{\n  public int value1 { get; set; }\n\n  public int value2 { get; set; }\n}\n\nFolders folders = new Folders() { value1 = 5; value2 = 6; };\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Folders : ReadOnlyCollection\n{\n  public int value1 { get; set; }\n\n  public int value2 { get; set; }\n}\n\nFolders folders = new Folders() { value1 = 5; value2 = 6; };\n"}]}]},{"type":"element","tag":"h1","props":{"id":"allowparseabletypes"},"children":[{"type":"text","value":"AllowParseableTypes"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AllowParseableTypes is a global switch that determines whether types with “.ToString()” and “Parse(string)” methods should be serialized as strings. We can use this setting for types that can’t be marked in the ProtoContract but can be parseable."}]},{"type":"element","tag":"pre","props":{"code":"static ProtoBufClient()\n{\n  RuntimeTypeModel.Default.AllowParseableTypes = true;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static ProtoBufClient()\n{\n  RuntimeTypeModel.Default.AllowParseableTypes = true;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For example, to solve the serialization problem with the Version type:"}]},{"type":"element","tag":"pre","props":{"code":"[Serializable]\n[ProtoContract(SkipConstructor = true)]\n[ProtoInclude(100, typeof(PrivateFolder))]\n[ProtoInclude(200, typeof(PublicFolder))]\n[ProtoInclude(300, typeof(SecureFolder))]\npublic abstract class FolderBase : Folder\n{\n  ...\n\n  [ProtoMember(3)]\n  private string name;\n  [ProtoMember(4)]\n  private Owner owner;\n\n  ...\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Serializable]\n[ProtoContract(SkipConstructor = true)]\n[ProtoInclude(100, typeof(PrivateFolder))]\n[ProtoInclude(200, typeof(PublicFolder))]\n[ProtoInclude(300, typeof(SecureFolder))]\npublic abstract class FolderBase : Folder\n{\n  ...\n\n  [ProtoMember(3)]\n  private string name;\n  [ProtoMember(4)]\n  private Owner owner;\n\n  ...\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"protobuf-net-generics-on-unity3d-il2cpp"},"children":[{"type":"text","value":"Protobuf-net Generics on Unity3D IL2CPP."}]},{"type":"element","tag":"pre","props":{"code":"public class CustomCollectionBase<TCollection, TElement, TKey>\n{\n    protected TCollection _collection;\n\n    protected SortedDictionary<TKey, bool> _removed;\n\n    public CustomCollectionBase(TCollection collection)\n    {\n        _collection = collection;\n    }\n\n    protected byte[] _cBytes;\n\n    protected byte[] _rBytes;\n\n    protected void __PreSerialize()\n    {\n        using (MemoryStream stream = new MemoryStream())\n        {\n            Serializer.Serialize(stream, this._collection);\n            this._cBytes = stream.ToArray();\n        }\n\n        using (MemoryStream stream = new MemoryStream())\n        {\n            Serializer.Serialize(stream, this._removed);\n            this._rBytes = stream.ToArray();\n        }\n    }\n\n    protected void __PostDeserialize()\n    {\n        using (MemoryStream stream = new MemoryStream(this._cBytes))\n        {\n            this._collection = Serializer.Deserialize<TCollection>(stream);\n        }\n\n        using (MemoryStream stream = new MemoryStream(this._rBytes))\n        {\n            this._removed = Serializer.Deserialize<SortedDictionary<TKey, bool>>(stream);\n        }\n    }\n}\n\n[ProtoContract]\npublic class CustomList<TElement> : CustomCollectionBase<List<TElement>, TElement, int>\n{\n    public CustomList() : base( new List<TElement>())\n    {\n    }\n\n    [ProtoMember(1)]\n    private byte[] _cProto\n    {\n        get { return base._cBytes; }\n        set { base._cBytes = value; }\n    }\n\n    [ProtoMember(2)]\n    private byte[] _rProto\n    {\n        get { return base._rBytes; }\n        set { base._rBytes = value; }\n    }\n\n    [ProtoBeforeSerialization]\n    private void __PreSerialize()\n    {\n        base.__PreSerialize();\n    }\n\n    [ProtoAfterDeserialization]\n    private void __PostDeserialize()\n    {\n        base.__PostDeserialize();\n    }\n}\n\n[ProtoContract]\npublic class CustomIntDictionary<TElement> : CustomCollectionBase<Dictionary<int, TElement>, TElement, int>\n{\n    public CustomIntDictionary() : base(new Dictionary<int, TElement>())\n    {\n    }\n\n    [ProtoMember(1)]\n    private byte[] _cProto\n    {\n        get { return base._cBytes; }\n        set { base._cBytes = value; }\n    }\n\n    [ProtoMember(2)]\n    private byte[] _rProto\n    {\n        get { return base._rBytes; }\n        set { base._rBytes = value; }\n    }\n\n    [ProtoBeforeSerialization]\n    private void __PreSerialize()\n    {\n        base.__PreSerialize();\n    }\n\n    [ProtoAfterDeserialization]\n    private void __PostDeserialize()\n    {\n        base.__PostDeserialize();\n    }\n}\n\n[ProtoContract]\npublic class CustomStringDictionary<TElement> : CustomCollectionBase<Dictionary<string, TElement>, TElement, string>\n{\n    public CustomStringDictionary() : base(new Dictionary<string, TElement>())\n    {\n    }\n\n    [ProtoMember(1)]\n    private byte[] _cProto\n    {\n        get { return base._cBytes; }\n        set { base._cBytes = value; }\n    }\n\n    [ProtoMember(2)]\n    private byte[] _rProto\n    {\n        get { return base._rBytes; }\n        set { base._rBytes = value; }\n    }\n\n    [ProtoBeforeSerialization]\n    private void __PreSerialize()\n    {\n        base.__PreSerialize();\n    }\n\n    [ProtoAfterDeserialization]\n    private void __PostDeserialize()\n    {\n        base.__PostDeserialize();\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class CustomCollectionBase<TCollection, TElement, TKey>\n{\n    protected TCollection _collection;\n\n    protected SortedDictionary<TKey, bool> _removed;\n\n    public CustomCollectionBase(TCollection collection)\n    {\n        _collection = collection;\n    }\n\n    protected byte[] _cBytes;\n\n    protected byte[] _rBytes;\n\n    protected void __PreSerialize()\n    {\n        using (MemoryStream stream = new MemoryStream())\n        {\n            Serializer.Serialize(stream, this._collection);\n            this._cBytes = stream.ToArray();\n        }\n\n        using (MemoryStream stream = new MemoryStream())\n        {\n            Serializer.Serialize(stream, this._removed);\n            this._rBytes = stream.ToArray();\n        }\n    }\n\n    protected void __PostDeserialize()\n    {\n        using (MemoryStream stream = new MemoryStream(this._cBytes))\n        {\n            this._collection = Serializer.Deserialize<TCollection>(stream);\n        }\n\n        using (MemoryStream stream = new MemoryStream(this._rBytes))\n        {\n            this._removed = Serializer.Deserialize<SortedDictionary<TKey, bool>>(stream);\n        }\n    }\n}\n\n[ProtoContract]\npublic class CustomList<TElement> : CustomCollectionBase<List<TElement>, TElement, int>\n{\n    public CustomList() : base( new List<TElement>())\n    {\n    }\n\n    [ProtoMember(1)]\n    private byte[] _cProto\n    {\n        get { return base._cBytes; }\n        set { base._cBytes = value; }\n    }\n\n    [ProtoMember(2)]\n    private byte[] _rProto\n    {\n        get { return base._rBytes; }\n        set { base._rBytes = value; }\n    }\n\n    [ProtoBeforeSerialization]\n    private void __PreSerialize()\n    {\n        base.__PreSerialize();\n    }\n\n    [ProtoAfterDeserialization]\n    private void __PostDeserialize()\n    {\n        base.__PostDeserialize();\n    }\n}\n\n[ProtoContract]\npublic class CustomIntDictionary<TElement> : CustomCollectionBase<Dictionary<int, TElement>, TElement, int>\n{\n    public CustomIntDictionary() : base(new Dictionary<int, TElement>())\n    {\n    }\n\n    [ProtoMember(1)]\n    private byte[] _cProto\n    {\n        get { return base._cBytes; }\n        set { base._cBytes = value; }\n    }\n\n    [ProtoMember(2)]\n    private byte[] _rProto\n    {\n        get { return base._rBytes; }\n        set { base._rBytes = value; }\n    }\n\n    [ProtoBeforeSerialization]\n    private void __PreSerialize()\n    {\n        base.__PreSerialize();\n    }\n\n    [ProtoAfterDeserialization]\n    private void __PostDeserialize()\n    {\n        base.__PostDeserialize();\n    }\n}\n\n[ProtoContract]\npublic class CustomStringDictionary<TElement> : CustomCollectionBase<Dictionary<string, TElement>, TElement, string>\n{\n    public CustomStringDictionary() : base(new Dictionary<string, TElement>())\n    {\n    }\n\n    [ProtoMember(1)]\n    private byte[] _cProto\n    {\n        get { return base._cBytes; }\n        set { base._cBytes = value; }\n    }\n\n    [ProtoMember(2)]\n    private byte[] _rProto\n    {\n        get { return base._rBytes; }\n        set { base._rBytes = value; }\n    }\n\n    [ProtoBeforeSerialization]\n    private void __PreSerialize()\n    {\n        base.__PreSerialize();\n    }\n\n    [ProtoAfterDeserialization]\n    private void __PostDeserialize()\n    {\n        base.__PostDeserialize();\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So basically there are two methods that are defined."}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"__PreSerialize – Converts the collection in to a byte array which becomes the proto member."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"__PostDeserialize – Converts the byte array back to the collection."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We can completely avoid defining run time types for this generic type. Instead of protobuf-net being responsible of creating the type, we create the type by ourselves using the same protobuf Serializer."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This kind of technique can be used for other generic types as well. Please comment your ideas about this approach."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-03-25-protobuf-Empty-Collections.md","_source":"content","_file":"tool/2020-03-25-protobuf-Empty-Collections.md","_extension":"md","date":"2020-03-25"},{"_path":"/tool/2020-06-26-blog-mail-sub","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"为博客将 RSS 转为邮件订阅","description":"RSSMailer | https://rssmailer.app/","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RSSMailer | "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//rssmailer.app/","rel":["nofollow"]},"children":[{"type":"text","value":"https://rssmailer.app/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tinyletter | "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//tinyletter.com/","rel":["nofollow"]},"children":[{"type":"text","value":"tinyletter"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mailchimp| "},{"type":"element","tag":"a","props":{"href":"https://mailchimp.com/","rel":["nofollow"]},"children":[{"type":"text","value":"https://mailchimp.com/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相关推荐:"}]},{"type":"element","tag":"pre","props":{"code":" - https://zhuanlan.zhihu.com/p/111978933\n - https://zhuanlan.zhihu.com/p/119325491\n - https://sspai.com/post/60025\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" - https://zhuanlan.zhihu.com/p/111978933\n - https://zhuanlan.zhihu.com/p/119325491\n - https://sspai.com/post/60025\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-06-26-blog-mail-sub.md","_source":"content","_file":"tool/2020-06-26-blog-mail-sub.md","_extension":"md","date":"2020-06-26"},{"_path":"/tool/2020-06-27-linux-github-slow","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"github下载代码的速度太慢","description":"作为程序员，最大的同性交友网站估计是大家的标配了，常常会苦恼于git clone某个项目的时候速度太慢，看着控制台那几K十一二K的速度，吐血！！","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作为程序员，最大的同性交友网站估计是大家的标配了，常常会苦恼于git clone某个项目的时候速度太慢，看着控制台那几K十一二K的速度，吐血！！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原因很简单：github的"},{"type":"element","tag":"a","props":{"href":"https://cloud.tencent.com/product/cdn?from=10680","rel":["nofollow"]},"children":[{"type":"text","value":"CDN"}]},{"type":"text","value":"被高高的墙屏蔽所致了。 所以解决方案也很简单，就是手动把 cdn 和IP地址绑定一下。"}]},{"type":"element","tag":"h2","props":{"id":"_1获取github地址"},"children":[{"type":"text","value":"1、获取github地址"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"访问 "},{"type":"element","tag":"a","props":{"href":"http://github.com.ipaddress.com/","rel":["nofollow"]},"children":[{"type":"text","value":"http://github.com.ipaddress.com/"}]},{"type":"text","value":" 获取cdn域名以及ip地址..或者打开 "},{"type":"element","tag":"a","props":{"href":"http://tool.chinaz.com/dns","rel":["nofollow"]},"children":[{"type":"text","value":"http://tool.chinaz.com/dns"}]},{"type":"text","value":" ,这是一个查询域名映射关系的工具"}]},{"type":"element","tag":"h2","props":{"id":"_2获取-globalsslfastly地址"},"children":[{"type":"text","value":"2、获取 global.ssl.fastly地址"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://github.global.ssl.fastly.net.ipaddress.com/","rel":["nofollow"]},"children":[{"type":"text","value":"http://github.global.ssl.fastly.net.ipaddress.com/"}]},{"type":"text","value":" 获取cdn域名以及ip地址"}]},{"type":"element","tag":"h2","props":{"id":"_3打开hosts映射"},"children":[{"type":"text","value":"3、打开hosts映射"}]},{"type":"element","tag":"h3","props":{"id":"windows环境"},"children":[{"type":"text","value":"Windows环境"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"C:\\Windows\\System32\\drivers\\etc\\hosts\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"C:\\Windows\\System32\\drivers\\etc\\hosts\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最末尾添加两句话保存:"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"151.101.185.194 http://github.global.ssl.fastly.net \n192.30.253.112 http://github.com\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"151.101.185.194 http://github.global.ssl.fastly.net \n192.30.253.112 http://github.com\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"打开CMD刷新一下DNS就好了。"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"ipconfig /flushdns\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ipconfig /flushdns\n"}]}]},{"type":"element","tag":"h3","props":{"id":"linux环境"},"children":[{"type":"text","value":"Linux环境"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"sudo vi /etc/hosts\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo vi /etc/hosts\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"添加"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"192.30.253.112 https://github.com\n151.101.185.194 https://github.global.ssl.fastly.net \n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"192.30.253.112 https://github.com\n151.101.185.194 https://github.global.ssl.fastly.net \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"保存,退出,并重启网络"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"systemctl restart network\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"systemctl restart network\n"}]}]},{"type":"element","tag":"h2","props":{"id":"速度对比"},"children":[{"type":"text","value":"速度对比:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置前"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"Receiving objects:  17% (151/883), 348.00 KiB | 18.00 KiB/s\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Receiving objects:  17% (151/883), 348.00 KiB | 18.00 KiB/s\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置后"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"Receiving objects:  81% (86141/104384), 81.31Mib | 562.00 KiB/s\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Receiving objects:  81% (86141/104384), 81.31Mib | 562.00 KiB/s\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1获取github地址","depth":2,"text":"1、获取github地址"},{"id":"_2获取-globalsslfastly地址","depth":2,"text":"2、获取 global.ssl.fastly地址"},{"id":"_3打开hosts映射","depth":2,"text":"3、打开hosts映射","children":[{"id":"windows环境","depth":3,"text":"Windows环境"},{"id":"linux环境","depth":3,"text":"Linux环境"}]},{"id":"速度对比","depth":2,"text":"速度对比:"}]}},"_type":"markdown","_id":"content:tool:2020-06-27-linux-github-slow.md","_source":"content","_file":"tool/2020-06-27-linux-github-slow.md","_extension":"md","date":"2020-06-27"},{"_path":"/tool/2020-07-02-win10-start-menu","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"win10开始菜单添加软件以及备份和恢复","description":"添加应用到开始屏幕右键默认就有添加到开始屏幕备份与恢复默认布局位于 C:\\Users\\username\\AppData\\Local\\Microsoft\\Windows\\Shell\\ ..注意这是默认布局真实的布局是存在与注册表中Export-StartLayout –path c:\\start\\start.xml\nImport-StartLayout -layoutpath c:\\start\\start.xml -mountpath \"C:\\\"\n其他路径C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\ProgramsC:\\Users\\zhepama\\Ap","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"添加应用到开始屏幕"},"children":[{"type":"text","value":"添加应用到开始屏幕"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"右键默认就有添加到开始屏幕"}]},{"type":"element","tag":"h1","props":{"id":"备份与恢复"},"children":[{"type":"text","value":"备份与恢复"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认布局位于 C:\\Users\\username\\AppData\\Local\\Microsoft\\Windows\\Shell\\ ..注意这是默认布局"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"真实的布局是存在与注册表中"}]},{"type":"element","tag":"pre","props":{"code":"Export-StartLayout –path c:\\start\\start.xml\nImport-StartLayout -layoutpath c:\\start\\start.xml -mountpath \"C:\\\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Export-StartLayout –path c:\\start\\start.xml\nImport-StartLayout -layoutpath c:\\start\\start.xml -mountpath \"C:\\\"\n"}]}]},{"type":"element","tag":"h2","props":{"id":"其他路径"},"children":[{"type":"text","value":"其他路径"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C:\\Users\\zhepama\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs"}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/windows/configuration/customize-and-export-start-layout#export-the-start-layout","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-cn/windows/configuration/customize-and-export-start-layout#export-the-start-layout"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/powershell/module/startlayout/import-startlayout?view=win10-ps","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/en-us/powershell/module/startlayout/import-startlayout?view=win10-ps"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"其他路径","depth":2,"text":"其他路径"},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:tool:2020-07-02-win10-start-menu.md","_source":"content","_file":"tool/2020-07-02-win10-start-menu.md","_extension":"md","date":"2020-07-02"},{"_path":"/tool/2020-07-06-gitbook-use","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"gitbook的使用","description":"使用npm安装gitbook现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm，打开命令行，执行以下命令安装 GitBook：npm install -g gitbook-cli\n使用Git Bash操作如下图：好了，准备好了三件套工具之后，就是来看看怎么编写GitBook了。编写GitBook创建电子书的文件夹目录想象一下，现在你准备构建一本书籍，你在硬盘上新建了一个叫 mybook 的文件夹，按照以前的做法，你会新建一个 Word 文档，写上标题，然后开始巴滋巴滋地笔耕。初始化Gitbook但是现在有了 GitBook，你首先要做的是在 m","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"使用npm安装gitbook"},"children":[{"type":"text","value":"使用npm安装gitbook"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm，打开命令行，执行以下命令安装 GitBook："}]},{"type":"element","tag":"pre","props":{"className":["language-undefined"],"code":"npm install -g gitbook-cli\n","language":"undefined","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"npm install -g gitbook-cli\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Git Bash"}]},{"type":"text","value":"操作如下图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-3ef32e72168040b1.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，准备好了三件套工具之后，就是来看看怎么编写"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GitBook"}]},{"type":"text","value":"了。"}]},{"type":"element","tag":"h2","props":{"id":"编写gitbook"},"children":[{"type":"text","value":"编写GitBook"}]},{"type":"element","tag":"h3","props":{"id":"创建电子书的文件夹目录"},"children":[{"type":"text","value":"创建电子书的文件夹目录"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"想象一下，现在你准备构建一本书籍，你在硬盘上新建了一个叫 mybook 的文件夹，按照以前的做法，你会新建一个 Word 文档，写上标题，然后开始巴滋巴滋地笔耕。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-4c42d4ea26ffe4d4.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"初始化gitbook"},"children":[{"type":"text","value":"初始化Gitbook"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是现在有了 GitBook，你首先要做的是在 mybook 文件夹下执行以下命令："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"gitbook init"}]},{"type":"text","value":"初始化gitbook，操作如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-325fdbbe1bad6026.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行完后，你会看到多了两个文件 —— README.md 和 SUMMARY.md，它们的作用如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"README.md —— 书籍的介绍写在这个文件里"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SUMMARY.md —— 书籍的目录结构在这里配置"}]}]},{"type":"element","tag":"h3","props":{"id":"使用typora来编写框架内容"},"children":[{"type":"text","value":"使用Typora来编写框架内容"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时候，我们启动恭候多时的 Typora 来编辑这两个文件了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-637f36f709e63f81.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"编辑 SUMMARY.md 文件，内容修改为："}]},{"type":"element","tag":"pre","props":{"className":["language-bash"],"code":"# 目录\n\n* [前言](README.md)\n* [第一章](Chapter1/README.md)\n  * [第1节：衣](Chapter1/衣.md)\n  * [第2节：食](Chapter1/食.md)\n  * [第3节：住](Chapter1/住.md)\n  * [第4节：行](Chapter1/行.md)\n* [第二章](Chapter2/README.md)\n* [第三章](Chapter3/README.md)\n* [第四章](Chapter4/README.md)\n","language":"bash","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 目录\n\n* [前言](README.md)\n* [第一章](Chapter1/README.md)\n  * [第1节：衣](Chapter1/衣.md)\n  * [第2节：食](Chapter1/食.md)\n  * [第3节：住](Chapter1/住.md)\n  * [第4节：行](Chapter1/行.md)\n* [第二章](Chapter2/README.md)\n* [第三章](Chapter3/README.md)\n* [第四章](Chapter4/README.md)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显示如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-a0e40da1d8ae2f1a.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"重新使用gitbook根据目录初始化篇章"},"children":[{"type":"text","value":"重新使用gitbook根据目录，初始化篇章"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后我们回到命令行，在 mybook 文件夹中再次执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"gitbook init"}]},{"type":"text","value":" 命令。GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-92aaec1127fbe9c8.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Typora 是所见即所得（实时渲染）的 Markdown 编辑器，这时候它是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-e1fb9ef8f3b32226.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"启动服务预览书籍"},"children":[{"type":"text","value":"启动服务，预览书籍"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着我们执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"gitbook serve"}]},{"type":"text","value":" 来预览这本书籍，执行命令后会对 Markdown 格式的文档进行转换，默认转换为 html 格式，最后提示 “Serving book on "},{"type":"element","tag":"a","props":{"href":"https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A4000%2F","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:4000"}]},{"type":"text","value":"”。嗯，打开浏览器看一下吧："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-a49ea1d4e0bdeb98.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/13423234-ca03c52cfdc1ac64.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"结合-github-pages"},"children":[{"type":"text","value":"结合 GitHub Pages"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GitHub Pages 是 GitHub 提供的静态网站托管服务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GitHub 上的每个仓库都可以拥有一个 GitHub Pages，对应的 URL 如下："}]},{"type":"element","tag":"pre","props":{"className":["language-xml"],"code":"https://<username>.github.io/<repository>/\n","language":"xml","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"https://<username>.github.io/<repository>/\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GitHub Pages 的静态资源支持下面 3 个来源："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" 分支"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" 分支的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/docs"}]},{"type":"text","value":" 目录"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"gh-pages"}]},{"type":"text","value":" 分支"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-06-gitbook-use/1624919-00837dbbb587799c.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行下面命令，将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"_book"}]},{"type":"text","value":" 目录推送到 GitHub 仓库的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"gh-pages"}]},{"type":"text","value":" 分支。"}]},{"type":"element","tag":"pre","props":{"className":["language-shell"],"code":"$ git checkout --orphan gh-pages\n$ code .nojekyll\n","language":"shell","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$ git checkout --orphan gh-pages\n$ code .nojekyll\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者在生成静态网页时，将保存的目录指定为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"./docs"}]}]},{"type":"element","tag":"pre","props":{"className":["language-shell"],"code":"$ gitbook build ./ ./docs\n","language":"shell","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$ gitbook build ./ ./docs\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后直接推送到 GitHub 仓库的。"}]},{"type":"element","tag":"pre","props":{"className":["language-shell"],"code":"$ git push origin master\n","language":"shell","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$ git push origin master\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"使用npm安装gitbook","depth":3,"text":"使用npm安装gitbook"},{"id":"编写gitbook","depth":2,"text":"编写GitBook","children":[{"id":"创建电子书的文件夹目录","depth":3,"text":"创建电子书的文件夹目录"},{"id":"初始化gitbook","depth":3,"text":"初始化Gitbook"},{"id":"使用typora来编写框架内容","depth":3,"text":"使用Typora来编写框架内容"},{"id":"重新使用gitbook根据目录初始化篇章","depth":3,"text":"重新使用gitbook根据目录，初始化篇章"},{"id":"启动服务预览书籍","depth":3,"text":"启动服务，预览书籍"}]},{"id":"结合-github-pages","depth":2,"text":"结合 GitHub Pages"}]}},"_type":"markdown","_id":"content:tool:2020-07-06-gitbook-use.md","_source":"content","_file":"tool/2020-07-06-gitbook-use.md","_extension":"md","date":"2020-07-06"},{"_path":"/tool/2020-07-11-github-actions","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"github actions 简单使用","description":"如果你是一个前端项目，可以使用 Node.js 的模板，点击 Set up this workflow","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"快速开始"},"children":[{"type":"text","value":"快速开始"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你是一个前端项目，可以使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Node.js"}]},{"type":"text","value":" 的模板，点击 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Set up this workflow"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"v2-93f521330d963d903561c0575d2d8fac_720w","src":"/images/2020-07-11-github-actions/v2-93f521330d963d903561c0575d2d8fac_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此时生成了一个文件 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".github/workflows/nodejs.yaml"}]},{"type":"text","value":"，修改内容如下"}]},{"type":"element","tag":"pre","props":{"code":"name: Git Action Test\n# on: 用来指定启动触发的事件，push 则表示在监听到 git push 到指定分支时触发。如此之外还可以是 pull_request。\non: [push]   \n\n#jobs:一个 CI/CD 的工作流有许多 jobs 组成，比如最典型的 job 是 lint，test，build 或者 deploy。\n#所有的 job 都是并行的,如果想顺序执行，可以这样 build-job: needs: test-job。\njobs:         \n  build:\n    #runs-on用来指定执行系统环境，不仅有常用的 Linux 发行版，还可以是 macOS 或 Windows。\n    runs-on: ubuntu-latest  \n    # steps 表示每个 job 需要执行的步骤，比如这里我分成了四步：拉取分支 → 安装 Node 环境 → 构建项目 → 上传 COS。\n    steps:  \n    #Action 是组成工作流最核心最基础的元素。每个 Action 可以看作封装的独立脚本，有自己的操作逻辑，我们只需要 uses 并通过 with 传入参数即可。\n    - uses: actions/checkout@v1 \n    - name: Use Node.js 10.x\n      uses: actions/setup-node@v1\n      with:\n        node-version: 10.x\n    - name: npm install, build\n      run: |\n        npm install\n        npm run build --if-present\n      env:\n        CI: true\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"name: Git Action Test\n# on: 用来指定启动触发的事件，push 则表示在监听到 git push 到指定分支时触发。如此之外还可以是 pull_request。\non: [push]   \n\n#jobs:一个 CI/CD 的工作流有许多 jobs 组成，比如最典型的 job 是 lint，test，build 或者 deploy。\n#所有的 job 都是并行的,如果想顺序执行，可以这样 build-job: needs: test-job。\njobs:         \n  build:\n    #runs-on用来指定执行系统环境，不仅有常用的 Linux 发行版，还可以是 macOS 或 Windows。\n    runs-on: ubuntu-latest  \n    # steps 表示每个 job 需要执行的步骤，比如这里我分成了四步：拉取分支 → 安装 Node 环境 → 构建项目 → 上传 COS。\n    steps:  \n    #Action 是组成工作流最核心最基础的元素。每个 Action 可以看作封装的独立脚本，有自己的操作逻辑，我们只需要 uses 并通过 with 传入参数即可。\n    - uses: actions/checkout@v1 \n    - name: Use Node.js 10.x\n      uses: actions/setup-node@v1\n      with:\n        node-version: 10.x\n    - name: npm install, build\n      run: |\n        npm install\n        npm run build --if-present\n      env:\n        CI: true\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"git push"}]},{"type":"text","value":" 操作，此时可以在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"github"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Actions"}]},{"type":"text","value":" 标签页看到执行结果"}]},{"type":"element","tag":"h1","props":{"id":"安全相关"},"children":[{"type":"text","value":"安全相关"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"github action"}]},{"type":"text","value":" 上访问敏感数据？如使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ssh"}]},{"type":"text","value":" 登录时如何维护密码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以在 github repo 上依次点击 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Settings"}]},{"type":"text","value":" -> "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Secrets"}]},{"type":"text","value":" 设置 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"secret"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"v2-51c0ee11b4bc61312d8e1af14d906432_720w","src":"/images/2020-07-11-github-actions/v2-51c0ee11b4bc61312d8e1af14d906432_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"- name: setup aliyun oss\n  uses: manyuanrong/setup-ossutil@master\n  with:\n    endpoint: oss-cn-beijing.aliyuncs.com\n    access-key-id: ${{ secrets.OSS_KEY_ID }}\n    access-key-secret: ${{ secrets.OSS_KEY_SECRET }}\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"- name: setup aliyun oss\n  uses: manyuanrong/setup-ossutil@master\n  with:\n    endpoint: oss-cn-beijing.aliyuncs.com\n    access-key-id: ${{ secrets.OSS_KEY_ID }}\n    access-key-secret: ${{ secrets.OSS_KEY_SECRET }}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"secret"}]},{"type":"text","value":" 就是一种 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"context"}]},{"type":"text","value":"，描述 CI/CD 一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"workflow"}]},{"type":"text","value":" 中的上下文信息，使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"${{ expression }}"}]},{"type":"text","value":" 语法表示。除了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"secret"}]},{"type":"text","value":"，还有"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"github"}]},{"type":"text","value":": "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"workflow"}]},{"type":"text","value":" 的信息，如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"github.sha"}]},{"type":"text","value":" 可以获取当前的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"commit SHA"}]},{"type":"text","value":"，我们可以利用它为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sentry"}]},{"type":"text","value":" 或者 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"docker image"}]},{"type":"text","value":" 打入版本号"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"env"}]},{"type":"text","value":": 环境变量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"job"}]},{"type":"text","value":": 当前执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"job"}]},{"type":"text","value":" 的信息，如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"job.status"}]},{"type":"text","value":" 表示当前 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"job"}]},{"type":"text","value":" 的执行状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"matrix"}]},{"type":"text","value":": 描述一些构建信息，如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"node"}]},{"type":"text","value":" 以及 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"os"}]},{"type":"text","value":" 版本号"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更多 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"context"}]},{"type":"text","value":" 信息可以参考官方文档 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Contexts and expression syntax for GitHub Actions[4]"}]}]},{"type":"element","tag":"h1","props":{"id":"自动创建项目release"},"children":[{"type":"text","value":"自动创建项目Release"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有些项目在发布新版本时，一般都会创建一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github Release"}]},{"type":"text","value":"，并且把对应编译好之后的文件上传到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Release"}]},{"type":"text","value":"的资源列表中，例如：\n"},{"type":"element","tag":"img","props":{"alt":"2659679572-62492fa02f19b6f9","src":"/images/2020-07-11-github-actions/2659679572-62492fa02f19b6f9.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果这个使用手动操作的话，不仅步骤重复又繁琐(每次都要编译出各个操作系统对应的发行包再进行上传)，而且最蛋疼的是对于国内的网络环境来说，上传文件速度简直不能忍，好不容易上传了一大半搞不好就因为网络原因又要重新上传，相信用过的人都深有体会。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我就在想如果能用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github Actions"}]},{"type":"text","value":"来创建"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Release"}]},{"type":"text","value":",并且做对应的编译和上传，那上面的问题都可以迎刃而解了，于是在官方市场搜索了一下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Release"}]},{"type":"text","value":"关键字，果然已经有提供对应的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"actions"}]},{"type":"text","value":"了："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/actions/create-release","rel":["nofollow"]},"children":[{"type":"text","value":"create-release"}]},{"type":"text","value":": 用于创建 release"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/actions/upload-release-asset","rel":["nofollow"]},"children":[{"type":"text","value":"upload-release-asset"}]},{"type":"text","value":": 用于上传资源到对应的 release 中"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着创建一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github仓库"}]},{"type":"text","value":"，我测试的仓库地址是"},{"type":"element","tag":"a","props":{"href":"https://github.com/monkeyWie/github-actions-demo","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/monkeyWie/github-actions-demo"}]},{"type":"text","value":"，项目用 go 语言写的，代码非常简单就是两个 hello world 级别的代码，里面包含了普通的 go 程序和 cgo 程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"项目的构建流程是在项目"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"git push --tags"}]},{"type":"text","value":"的时候，触发 workflow，通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github Actions"}]},{"type":"text","value":"编译出来"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Windows、Linux、macOS"}]},{"type":"text","value":"三个操作系统对应的 64 位可执行文件，再根据"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"tag name"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"tag message"}]},{"type":"text","value":"来创建对应的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github Release"}]},{"type":"text","value":"，并将编译好的文件上传。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样的创建一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".github/workflows/main.yml"}]},{"type":"text","value":"文件，内容如下："}]},{"type":"element","tag":"pre","props":{"code":"name: CI\n\non:\n  push:\n    # Sequence of patterns matched against refs/tags\n    tags:\n      - \"v*\" # Push events to matching v*, i.e. v1.0, v20.15.10\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v1\n      - name: Use Golang\n        uses: actions/setup-go@v1\n        with:\n          go-version: \"1.13.x\"\n      - name: Build normal\n        run: |\n          CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o normal-windows-x64.exe cmd/normal/main.go\n          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o normal-linux-x64 cmd/normal/main.go\n          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -o normal-darwin-x64 cmd/normal/main.go\n          zip normal-windows-x64.zip normal-windows-x64.exe\n          zip normal-linux-x64.zip normal-linux-x64\n          zip normal-darwin-x64.zip normal-darwin-x64\n      - name: Build cgo\n        run: |\n          go get github.com/monkeyWie/xgo\n          ~/go/bin/xgo -targets=windows/amd64,linux/amd64,darwin/amd64 -ldflags=\"-w -s\" -pkg=cmd/cgo/main.go -out=cgo .\n          mv cgo-windows-* cgo-windows-x64.exe\n          mv cgo-linux-* cgo-linux-x64\n          mv cgo-darwin-* cgo-darwin-x64\n          zip cgo-windows-x64.zip cgo-windows-x64.exe\n          zip cgo-linux-x64.zip cgo-linux-x64\n          zip cgo-darwin-x64.zip cgo-darwin-x64\n      - name: Create Release\n        id: create_release\n        uses: monkeyWie/create-release@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          draft: false\n          prerelease: false\n\n      - name: Upload Release normal windows\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./normal-windows-x64.zip\n          asset_name: normal-${{ steps.create_release.outputs.tag }}-windows-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release normal linux\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./normal-linux-x64.zip\n          asset_name: normal-${{ steps.create_release.outputs.tag }}-linux-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release normal darwin\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./normal-darwin-x64.zip\n          asset_name: normal-${{ steps.create_release.outputs.tag }}-darwin-x64.zip\n          asset_content_type: application/zip\n\n      - name: Upload Release cgo windows\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./cgo-windows-x64.zip\n          asset_name: cgo-${{ steps.create_release.outputs.tag }}-windows-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release cgo linux\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./cgo-linux-x64.zip\n          asset_name: cgo-${{ steps.create_release.outputs.tag }}-linux-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release cgo darwin\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./cgo-darwin-x64.zip\n          asset_name: cgo-${{ steps.create_release.outputs.tag }}-darwin-x64.zip\n          asset_content_type: application/zip\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"name: CI\n\non:\n  push:\n    # Sequence of patterns matched against refs/tags\n    tags:\n      - \"v*\" # Push events to matching v*, i.e. v1.0, v20.15.10\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v1\n      - name: Use Golang\n        uses: actions/setup-go@v1\n        with:\n          go-version: \"1.13.x\"\n      - name: Build normal\n        run: |\n          CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o normal-windows-x64.exe cmd/normal/main.go\n          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o normal-linux-x64 cmd/normal/main.go\n          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -o normal-darwin-x64 cmd/normal/main.go\n          zip normal-windows-x64.zip normal-windows-x64.exe\n          zip normal-linux-x64.zip normal-linux-x64\n          zip normal-darwin-x64.zip normal-darwin-x64\n      - name: Build cgo\n        run: |\n          go get github.com/monkeyWie/xgo\n          ~/go/bin/xgo -targets=windows/amd64,linux/amd64,darwin/amd64 -ldflags=\"-w -s\" -pkg=cmd/cgo/main.go -out=cgo .\n          mv cgo-windows-* cgo-windows-x64.exe\n          mv cgo-linux-* cgo-linux-x64\n          mv cgo-darwin-* cgo-darwin-x64\n          zip cgo-windows-x64.zip cgo-windows-x64.exe\n          zip cgo-linux-x64.zip cgo-linux-x64\n          zip cgo-darwin-x64.zip cgo-darwin-x64\n      - name: Create Release\n        id: create_release\n        uses: monkeyWie/create-release@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          draft: false\n          prerelease: false\n\n      - name: Upload Release normal windows\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./normal-windows-x64.zip\n          asset_name: normal-${{ steps.create_release.outputs.tag }}-windows-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release normal linux\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./normal-linux-x64.zip\n          asset_name: normal-${{ steps.create_release.outputs.tag }}-linux-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release normal darwin\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./normal-darwin-x64.zip\n          asset_name: normal-${{ steps.create_release.outputs.tag }}-darwin-x64.zip\n          asset_content_type: application/zip\n\n      - name: Upload Release cgo windows\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./cgo-windows-x64.zip\n          asset_name: cgo-${{ steps.create_release.outputs.tag }}-windows-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release cgo linux\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./cgo-linux-x64.zip\n          asset_name: cgo-${{ steps.create_release.outputs.tag }}-linux-x64.zip\n          asset_content_type: application/zip\n      - name: Upload Release cgo darwin\n        uses: actions/upload-release-asset@v1.0.1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps\n          asset_path: ./cgo-darwin-x64.zip\n          asset_name: cgo-${{ steps.create_release.outputs.tag }}-darwin-x64.zip\n          asset_content_type: application/zip\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"构建流程如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"监听 tag name 为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"v"}]},{"type":"text","value":"开头的 push"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"运行一个 job，在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ubuntu"}]},{"type":"text","value":"虚拟机环境下"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"拉取源码，安装"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"golang 1.13.x"}]},{"type":"text","value":"环境"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"go build"}]},{"type":"text","value":"交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"xgo"}]},{"type":"text","value":"交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"monkeyWie/create-release@master"}]},{"type":"text","value":"创建 Release，其中会用到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"${{ secrets.GITHUB_TOKEN }}"}]},{"type":"text","value":"，这是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github Actions"}]},{"type":"text","value":"内置的一个"},{"type":"element","tag":"a","props":{"href":"https://help.github.com/en/github/automating-your-workflow-with-github-actions/virtual-environments-for-github-actions#github_token-secret","rel":["nofollow"]},"children":[{"type":"text","value":"秘钥"}]},{"type":"text","value":"，用于授权访问你自己的 github 存储库，原理就是使用这个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TOKEN"}]},{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github API"}]},{"type":"text","value":"来进行创建 release，还有一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"${{ github.ref }}"}]},{"type":"text","value":"也是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Github Actions"}]},{"type":"text","value":"内置的一个"},{"type":"element","tag":"a","props":{"href":"https://help.github.com/en/github/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context","rel":["nofollow"]},"children":[{"type":"text","value":"变量"}]},{"type":"text","value":"，然后通过 action 的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"with"}]},{"type":"text","value":"进行参数传递。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"actions/upload-release-asset@v1.0.1"}]},{"type":"text","value":"上传文件，这里使用了两个表达式"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"${{ steps.create_release.outputs.upload_url }}"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"${{ steps.create_release.outputs.tag }}"}]},{"type":"text","value":"，可以获取到指定"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"action"}]},{"type":"text","value":"的输出，第一个是获取创建好的 release 对应的上传地址，第二个是获取对应的 tag(例如：v1.0.0)，这样就可以在把上传的文件带上版本号。因为这个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"action"}]},{"type":"text","value":"不支持多个文件上传，所以就写了多个 action 进行上传。"}]}]},{"type":"element","tag":"h1","props":{"id":"ssh命令"},"children":[{"type":"text","value":"ssh命令"}]},{"type":"element","tag":"pre","props":{"code":"name: Publish\non: [push]\njobs:\n  build:\n    name: SSH command\n    runs-on: ubuntu-latest\n    steps:\n    - name: git fetch\n      uses: appleboy/ssh-action@master\n      with:\n        host: ${{ secrets.SERVER_HOST }}\n        username: ${{ secrets.SERVER_USERNAME }}\n        password: ${{ secrets.SERVER_PASSWORD }}\n        command_timeout: 10m\n        script: |\n          git fetch --all\n          git reset --hard origin/master\n  build:\n    name: ...\n    runs-on: ...\n    ...\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"name: Publish\non: [push]\njobs:\n  build:\n    name: SSH command\n    runs-on: ubuntu-latest\n    steps:\n    - name: git fetch\n      uses: appleboy/ssh-action@master\n      with:\n        host: ${{ secrets.SERVER_HOST }}\n        username: ${{ secrets.SERVER_USERNAME }}\n        password: ${{ secrets.SERVER_PASSWORD }}\n        command_timeout: 10m\n        script: |\n          git fetch --all\n          git reset --hard origin/master\n  build:\n    name: ...\n    runs-on: ...\n    ...\n"}]}]},{"type":"element","tag":"h1","props":{"id":"dotfx"},"children":[{"type":"text","value":"dotFx"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://dotnet.github.io/docfx/tutorial/docfx_getting_started.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://dotnet.github.io/docfx/tutorial/docfx_getting_started.html"}]}]},{"type":"element","tag":"pre","props":{"code":"name: docfx build\non:\n  push:\n    branches:\n      - dev\njobs:\n  build:\n    name: Build\n    runs-on: windows-latest\n    steps:\n      # Check out the branch that triggered this workflow to the 'source' subdirectory\n      - name: Checkout Code\n        uses: actions/checkout@v2\n        with:\n          ref: dev\n          path: source\n      - name: install DocFX\n        run: \"& choco install docfx -y\"\n      # Run a build\n      - name: Build docs\n        run: \"& docfx ./docfx.json\"\n        working-directory: ./source\n      # Check out gh-pages branch to the 'docs' subdirectory\n      - name: Checkout docs\n        uses: actions/checkout@v2\n        with:\n          ref: gh-pages\n          path: docs\n      # Sync the site\n      - name: Clear docs repo\n        run: Get-ChildItem -Force -Exclude .git | ForEach-Object { Remove-Item -Recurse -Verbose -Force $_ }\n        working-directory: ./docs\n      - name: Sync new content\n        run: Copy-Item -Recurse -Verbose -Force \"$env:GITHUB_WORKSPACE/source/_site/*\" \"$env:GITHUB_WORKSPACE/docs\"\n        working-directory: ./docs\n        # update docs\n      - name: Commit to gh-pages and push\n        run: |\n          $ErrorActionPreference = \"Continue\"\n          git add -A\n          git diff HEAD --exit-code\n          if ($LASTEXITCODE -eq 0) {\n            Write-Host \"No changes to commit!\"\n          } else {\n            git config --global user.name \"github-actions-docfx[bot]\"\n            git config --global user.email \"weihanli@outlook.com\"\n            git commit -m \"Updated docs from commit $env:GITHUB_SHA on $env:GITHUB_REF\"\n            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}\n            git push origin gh-pages\n          }\n        working-directory: ./docs\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"name: docfx build\non:\n  push:\n    branches:\n      - dev\njobs:\n  build:\n    name: Build\n    runs-on: windows-latest\n    steps:\n      # Check out the branch that triggered this workflow to the 'source' subdirectory\n      - name: Checkout Code\n        uses: actions/checkout@v2\n        with:\n          ref: dev\n          path: source\n      - name: install DocFX\n        run: \"& choco install docfx -y\"\n      # Run a build\n      - name: Build docs\n        run: \"& docfx ./docfx.json\"\n        working-directory: ./source\n      # Check out gh-pages branch to the 'docs' subdirectory\n      - name: Checkout docs\n        uses: actions/checkout@v2\n        with:\n          ref: gh-pages\n          path: docs\n      # Sync the site\n      - name: Clear docs repo\n        run: Get-ChildItem -Force -Exclude .git | ForEach-Object { Remove-Item -Recurse -Verbose -Force $_ }\n        working-directory: ./docs\n      - name: Sync new content\n        run: Copy-Item -Recurse -Verbose -Force \"$env:GITHUB_WORKSPACE/source/_site/*\" \"$env:GITHUB_WORKSPACE/docs\"\n        working-directory: ./docs\n        # update docs\n      - name: Commit to gh-pages and push\n        run: |\n          $ErrorActionPreference = \"Continue\"\n          git add -A\n          git diff HEAD --exit-code\n          if ($LASTEXITCODE -eq 0) {\n            Write-Host \"No changes to commit!\"\n          } else {\n            git config --global user.name \"github-actions-docfx[bot]\"\n            git config --global user.email \"weihanli@outlook.com\"\n            git commit -m \"Updated docs from commit $env:GITHUB_SHA on $env:GITHUB_REF\"\n            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}\n            git push origin gh-pages\n          }\n        working-directory: ./docs\n"}]}]},{"type":"element","tag":"h1","props":{"id":"hexo"},"children":[{"type":"text","value":"Hexo"}]},{"type":"element","tag":"pre","props":{"code":"# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Hexo \n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps:\n    - name: 迁出main\n      uses: actions/checkout@v2\n      with: \n        path: main\n        submodules: 'recursive'\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    \n    - name: 安装hexo\n      run : |\n        npm install -g hexo-cli\n  \n    - name: 生成博客\n      run : |\n        cd main\n        npm install\n        hexo clean\n        hexo generate\n      \n    - name: 迁出gh-pages\n      uses: actions/checkout@v2\n      with:\n        path: gh-pages\n        ref: gh-pages\n        \n    - name: 部署到gh-pages\n      env:\n        TZ: Asia/Shanghai\n      run: |\n        cp -rf main/public/* gh-pages\n        cd gh-pages\n        git config --global user.name \"zhepama\"\n        git config --global user.email \"zhepama@gmail.com\"\n        git add .\n        git commit -m \"Auto Delopy at `date +\"%Y-%m-%d %H:%M\"`\"\n        git push origin gh-pages\n        \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Hexo \n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps:\n    - name: 迁出main\n      uses: actions/checkout@v2\n      with: \n        path: main\n        submodules: 'recursive'\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    \n    - name: 安装hexo\n      run : |\n        npm install -g hexo-cli\n  \n    - name: 生成博客\n      run : |\n        cd main\n        npm install\n        hexo clean\n        hexo generate\n      \n    - name: 迁出gh-pages\n      uses: actions/checkout@v2\n      with:\n        path: gh-pages\n        ref: gh-pages\n        \n    - name: 部署到gh-pages\n      env:\n        TZ: Asia/Shanghai\n      run: |\n        cp -rf main/public/* gh-pages\n        cd gh-pages\n        git config --global user.name \"zhepama\"\n        git config --global user.email \"zhepama@gmail.com\"\n        git add .\n        git commit -m \"Auto Delopy at `date +\"%Y-%m-%d %H:%M\"`\"\n        git push origin gh-pages\n        \n"}]}]},{"type":"element","tag":"h1","props":{"id":"gitbook"},"children":[{"type":"text","value":"gitbook"}]},{"type":"element","tag":"pre","props":{"code":"# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: GitBook\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [12.18.2]\n\n    steps:\n    - name: 迁出main\n      uses: actions/checkout@v2\n      with: \n        path: main\n        submodules: 'recursive'\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    \n    - name: 安装gitbook\n      run : |\n        npm install -g gitbook-cli\n  \n    - name: 生成书籍\n      run : |\n        cd main/Docs\n        gitbook install\n        gitbook build\n      \n    - name: 迁出gh-pages\n      uses: actions/checkout@v2\n      with:\n        path: gh-pages\n        ref: gh-pages\n        \n    - name: 部署到gh-pages\n      env:\n        TZ: Asia/Shanghai\n      run: |\n        cp -rf main/Docs/_book/* gh-pages\n        cd gh-pages\n        git config --global user.name \"zhepama\"\n        git config --global user.email \"zhepama@gmail.com\"\n        git add .\n        git commit -m \"Auto Delopy at `date +\"%Y-%m-%d %H:%M\"`\"\n        git push origin gh-pages\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: GitBook\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [12.18.2]\n\n    steps:\n    - name: 迁出main\n      uses: actions/checkout@v2\n      with: \n        path: main\n        submodules: 'recursive'\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    \n    - name: 安装gitbook\n      run : |\n        npm install -g gitbook-cli\n  \n    - name: 生成书籍\n      run : |\n        cd main/Docs\n        gitbook install\n        gitbook build\n      \n    - name: 迁出gh-pages\n      uses: actions/checkout@v2\n      with:\n        path: gh-pages\n        ref: gh-pages\n        \n    - name: 部署到gh-pages\n      env:\n        TZ: Asia/Shanghai\n      run: |\n        cp -rf main/Docs/_book/* gh-pages\n        cd gh-pages\n        git config --global user.name \"zhepama\"\n        git config --global user.email \"zhepama@gmail.com\"\n        git add .\n        git commit -m \"Auto Delopy at `date +\"%Y-%m-%d %H:%M\"`\"\n        git push origin gh-pages\n"}]}]},{"type":"element","tag":"h1","props":{"id":"市场"},"children":[{"type":"text","value":"市场"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/marketplace","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/marketplace"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.github.com/cn/actions/configuring-and-managing-workflows/using-environment-variables","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.github.com/cn/actions/configuring-and-managing-workflows/using-environment-variables"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-07-11-github-actions.md","_source":"content","_file":"tool/2020-07-11-github-actions.md","_extension":"md","date":"2020-07-11"},{"_path":"/tool/2020-07-12-hexo-github","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"使用hexo建立博客并部署到github","description":"使用hexo#安装hexo\nnpm install -g hexo-cli\nhexo -v\n\n# 初始化一个博客\ncd igiven.github.io\nhexo init\n\n#添加主题\ngit submodule add https://github.com/theme-next/hexo-theme-next themes/next\ngit submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus\n\n#添加插件https://github.com/sisyphsu/hexo-enhancer#","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"使用hexo"},"children":[{"type":"text","value":"使用hexo"}]},{"type":"element","tag":"pre","props":{"code":"#安装hexo\nnpm install -g hexo-cli\nhexo -v\n\n# 初始化一个博客\ncd igiven.github.io\nhexo init\n\n#添加主题\ngit submodule add https://github.com/theme-next/hexo-theme-next themes/next\ngit submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus\n\n#添加插件https://github.com/sisyphsu/hexo-enhancer#readme\n#如果不能生成,则删除db.json  ..或者hexo clean\nyarn add hexo-enhancer\nyarn add hexo-excerpt\n#本地服务器\nhexo s  \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#安装hexo\nnpm install -g hexo-cli\nhexo -v\n\n# 初始化一个博客\ncd igiven.github.io\nhexo init\n\n#添加主题\ngit submodule add https://github.com/theme-next/hexo-theme-next themes/next\ngit submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus\n\n#添加插件https://github.com/sisyphsu/hexo-enhancer#readme\n#如果不能生成,则删除db.json  ..或者hexo clean\nyarn add hexo-enhancer\nyarn add hexo-excerpt\n#本地服务器\nhexo s  \n"}]}]},{"type":"element","tag":"h2","props":{"id":"github-actions"},"children":[{"type":"text","value":"GITHUB ACTIONS"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"添加此action前记得先添加分支gh-pages,并设置github的pages为该分支"}]},{"type":"element","tag":"pre","props":{"code":"git checkout --orphan gh-pages\n# .nojekyll 的空文件来禁用 Jekyll 构建过程，然后按照静态站点生成器的说明在 本地构建站点。\ntouch .nojekyll\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git checkout --orphan gh-pages\n# .nojekyll 的空文件来禁用 Jekyll 构建过程，然后按照静态站点生成器的说明在 本地构建站点。\ntouch .nojekyll\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200715164950805","src":"/images/2020-07-12-hexo-github/image-20200715164950805.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps:\n    - name: 迁出main\n      uses: actions/checkout@v2\n      with: \n        path: main\n        submodules: 'recursive'\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    \n    - name: 安装hexo\n      run : |\n        npm install -g hexo\n  \n    - name: 生成博客\n      run : |\n        cd main\n        npm install\n        hexo clean\n        hexo generate\n        ls\n      \n    - name: 迁出gh-pages\n      uses: actions/checkout@v2\n      with:\n        path: gh-pages\n        ref: gh-pages\n        \n    - name: 部署到gh-pages\n      env:\n        TZ: Asia/Shanghai\n      run: |\n        cp -rf main/public/* gh-pages\n        cd gh-pages\n        git config --global user.name \"zhepama\"\n        git config --global user.email \"zhepama@gmail.com\"\n        git add .\n        git commit -m \"Auto Delopy at `date +\"%Y-%m-%d %H:%M\"`\"\n        git push origin gh-pages\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps:\n    - name: 迁出main\n      uses: actions/checkout@v2\n      with: \n        path: main\n        submodules: 'recursive'\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    \n    - name: 安装hexo\n      run : |\n        npm install -g hexo\n  \n    - name: 生成博客\n      run : |\n        cd main\n        npm install\n        hexo clean\n        hexo generate\n        ls\n      \n    - name: 迁出gh-pages\n      uses: actions/checkout@v2\n      with:\n        path: gh-pages\n        ref: gh-pages\n        \n    - name: 部署到gh-pages\n      env:\n        TZ: Asia/Shanghai\n      run: |\n        cp -rf main/public/* gh-pages\n        cd gh-pages\n        git config --global user.name \"zhepama\"\n        git config --global user.email \"zhepama@gmail.com\"\n        git add .\n        git commit -m \"Auto Delopy at `date +\"%Y-%m-%d %H:%M\"`\"\n        git push origin gh-pages\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"github-actions","depth":2,"text":"GITHUB ACTIONS"}]}},"_type":"markdown","_id":"content:tool:2020-07-12-hexo-github.md","_source":"content","_file":"tool/2020-07-12-hexo-github.md","_extension":"md","date":"2020-07-12"},{"_path":"/tool/2020-07-13-terminal-proxy","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"终端下设置代理","description":"cmdcmd命令行:(不用socks5)(临时设置)(也可放置环境变量)\nset http_proxy=http://127.0.0.1:1080\nset https_proxy=http://127.0.0.1:1080\npowershell$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ncurl -vv http://www.google.com\nlinuxexport http_proxy=127.0.0.1:1080\nexport ftp_proxy=127.0.0.1:1","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"cmd"},"children":[{"type":"text","value":"cmd"}]},{"type":"element","tag":"pre","props":{"code":"cmd命令行:(不用socks5)(临时设置)(也可放置环境变量)\nset http_proxy=http://127.0.0.1:1080\nset https_proxy=http://127.0.0.1:1080\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"cmd命令行:(不用socks5)(临时设置)(也可放置环境变量)\nset http_proxy=http://127.0.0.1:1080\nset https_proxy=http://127.0.0.1:1080\n"}]}]},{"type":"element","tag":"h1","props":{"id":"powershell"},"children":[{"type":"text","value":"powershell"}]},{"type":"element","tag":"pre","props":{"code":"$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ncurl -vv http://www.google.com\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ncurl -vv http://www.google.com\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200716004313442","src":"/images/2020-07-13-cons/image-20200716004313442.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"linux"},"children":[{"type":"text","value":"linux"}]},{"type":"element","tag":"pre","props":{"code":"export http_proxy=127.0.0.1:1080\nexport ftp_proxy=127.0.0.1:1080\nexport https_proxy=127.0.0.1:1080\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"export http_proxy=127.0.0.1:1080\nexport ftp_proxy=127.0.0.1:1080\nexport https_proxy=127.0.0.1:1080\n"}]}]},{"type":"element","tag":"h1","props":{"id":"git"},"children":[{"type":"text","value":"GIT"}]},{"type":"element","tag":"pre","props":{"code":"git config --global https.proxy http://127.0.0.1:1080\ngit config --global https.proxy http://127.0.0.1:1080\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git config --global https.proxy http://127.0.0.1:1080\ngit config --global https.proxy http://127.0.0.1:1080\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-07-13-terminal-proxy.md","_source":"content","_file":"tool/2020-07-13-terminal-proxy.md","_extension":"md","date":"2020-07-13"},{"_path":"/tool/2020-08-30-nuget-is-big","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"发现nuget包太占用C盘，怎么办？","description":"如何发现的？查看C盘存储打开所有设置->系统->存储->选择C盘\n查看C盘使用情况，可以查看“其他”中情况\n发现.nuget文件夹占用的空间很大，这是由于VS的默认nuget包路径：C:\\Users{UserName}.nuget\\packages如何解决？NuGet 的行为由一个或多个 NuGet.Config (XML) 文件（可存在于项目范围、用户范围和计算机范围的级别）中的累积设置驱动。在解决方案文件夹中，设置应用于子文件夹中的所有项目。 请注意，如果配置文件位于项目文件夹中，则对该项目没有任何影响设置应用于所有操作，但可被任何项目级的设置替代。\nWindows：%appdata%\\N","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"如何发现的"},"children":[{"type":"text","value":"如何发现的？"}]},{"type":"element","tag":"h4","props":{"id":"查看c盘存储"},"children":[{"type":"text","value":"查看C盘存储"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"打开所有设置->系统->存储->选择C盘\n"},{"type":"element","tag":"img","props":{"alt":"image.png","src":"/images/2020-08-30-nuget-is-big/7777310-8ce825574a3c0e8b.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"查看C盘使用情况，可以查看“其他”中情况\n"},{"type":"element","tag":"img","props":{"alt":"image.png","src":"/images/2020-08-30-nuget-is-big/7777310-b854451afc8d311b.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"发现.nuget文件夹占用的空间很大，这是由于VS的默认nuget包路径：C:\\Users{UserName}.nuget\\packages"}]}]},{"type":"element","tag":"h1","props":{"id":"如何解决"},"children":[{"type":"text","value":"如何解决？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NuGet 的行为由一个或多个 NuGet.Config (XML) 文件（可存在于项目范围、用户范围和计算机范围的级别）中的累积设置驱动。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在解决方案文件夹中，设置应用于子文件夹中的所有项目。 请注意，如果配置文件位于项目文件夹中，则对该项目没有任何影响"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设置应用于所有操作，但可被任何项目级的设置替代。\nWindows："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"%appdata%\\NuGet\\NuGet.Config"}]},{"type":"text","value":"\nMac/Linux："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"~/.config/NuGet/NuGet.Config"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"~/.nuget/NuGet/NuGet.Config"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设置虽然适用于计算机上的所有操作，但会被任何用户级或项目级设置覆盖。\nWindows："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"%ProgramFiles(x86)%\\NuGet\\Config"}]},{"type":"text","value":"\nMac/Linux："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"$XDG_DATA_HOME"}]},{"type":"text","value":"。 Mac/Linux: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"$XDG_DATA_HOME"}]},{"type":"text","value":". 如果 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"$XDG_DATA_HOME"}]},{"type":"text","value":" 的值是 null 或为空，将使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"~/.local/share"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/usr/local/share"}]},{"type":"text","value":"（因 OS 版本而异）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"发现占用空间资源比较大的时用户级别的nuget包..我们只要把这个文件夹移动到其他驱动器就可以."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下两种方法都行,建议第二种.因为nuget.exe还需要安装"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.可以直接使用命令行"}]},{"type":"element","tag":"pre","props":{"code":"nuget config -set repositoryPath=D:\\Users\\zhepama\\.nuget\\packages\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"nuget config -set repositoryPath=D:\\Users\\zhepama\\.nuget\\packages\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.直接修改配置文件"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"C:\\Users\\{user}\\AppData\\Roaming\\NuGet\\NuGet.Config"}]},{"type":"text","value":"添加globalPackagesFolder节点"}]},{"type":"element","tag":"pre","props":{"code":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <packageSources>\n      <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" />\n  </packageSources>\n  <config> \n      <add key=\"globalPackagesFolder\" value=\"D:\\Users\\zhepama\\.nuget\\packages\" />\n  </config>\n</configuration>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <packageSources>\n      <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" />\n  </packageSources>\n  <config> \n      <add key=\"globalPackagesFolder\" value=\"D:\\Users\\zhepama\\.nuget\\packages\" />\n  </config>\n</configuration>\n"}]}]},{"type":"element","tag":"h1","props":{"id":"参考连接"},"children":[{"type":"text","value":"参考连接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/nuget/consume-packages/configuring-nuget-behavior","rel":["nofollow"]},"children":[{"type":"text","value":"常见的 NuGet 配置 | Microsoft Docs"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/nuget/reference/nuget-config-file","rel":["nofollow"]},"children":[{"type":"text","value":"nuget.config 文件引用 | Microsoft Docs"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-08-30-nuget-is-big.md","_source":"content","_file":"tool/2020-08-30-nuget-is-big.md","_extension":"md","date":"2020-08-30"},{"_path":"/tool/2020-11-15-unity-is-big","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"unity商店下载资源迁移","description":"包缓存太大每次运行Unity都会发现自己的C盘空间在急剧缩小，查了一下发现是C:\\Users\\Username\\AppData\\Local\\Unity\\cache这个文件夹特别大，它主要是存储一些Unity常用的packages，默认都是存在C盘下。\n为了拯救C盘空间，可以通过设置环境变量的方式解决，具体请参考Global Cache，或Configure Unity Package Manager global cache location。添加环境变量[environment]::setEnvironmentVariable('UPM_CACHE_ROOT','D:\\Users\\zhepa","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"包缓存太大"},"children":[{"type":"text","value":"包缓存太大"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每次运行Unity都会发现自己的C盘空间在急剧缩小，查了一下发现是C:\\Users\\Username\\AppData\\Local\\Unity\\cache这个文件夹特别大，它主要是存储一些Unity常用的packages，默认都是存在C盘下。\n为了拯救C盘空间，可以通过设置环境变量的方式解决，具体请参考"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/upm-cache.html?_ga=2.102441737.940588655.1611571898-92384475.1591107641","rel":["nofollow"]},"children":[{"type":"text","value":"Global Cache"}]},{"type":"text","value":"，或"},{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/configure-unity-package-manager-global-cache-location.650245/","rel":["nofollow"]},"children":[{"type":"text","value":"Configure Unity Package Manager global cache location"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"添加环境变量"}]},{"type":"element","tag":"pre","props":{"code":"[environment]::setEnvironmentVariable('UPM_CACHE_ROOT','D:\\Users\\zhepama\\AppData\\Unity\\Caches','User')\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[environment]::setEnvironmentVariable('UPM_CACHE_ROOT','D:\\Users\\zhepama\\AppData\\Unity\\Caches','User')\n"}]}]},{"type":"element","tag":"h2","props":{"id":"商店资源太大"},"children":[{"type":"text","value":"商店资源太大"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用cmd,注意powershell是不支持mklink的"}]},{"type":"element","tag":"pre","props":{"code":" mklink /J \"C:\\Users\\zhepama\\AppData\\Roaming\\Unity\\Asset Store-5.x\" \"E:\\Asset\\Asset Store-5.x\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" mklink /J \"C:\\Users\\zhepama\\AppData\\Roaming\\Unity\\Asset Store-5.x\" \"E:\\Asset\\Asset Store-5.x\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/asset-store-download-folder.83620/page-2","rel":["nofollow"]},"children":[{"type":"text","value":"https://forum.unity.com/threads/asset-store-download-folder.83620/page-2"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity.cn/cn/2021.3/Manual/upm-config-cache.html","rel":["nofollow"]},"children":[{"type":"text","value":"Customizing the shared cache locations - Unity 手册"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"包缓存太大","depth":2,"text":"包缓存太大"},{"id":"商店资源太大","depth":2,"text":"商店资源太大"}]}},"_type":"markdown","_id":"content:tool:2020-11-15-unity-is-big.md","_source":"content","_file":"tool/2020-11-15-unity-is-big.md","_extension":"md","date":"2020-11-15"},{"_path":"/tool/2020-11-16-coding-pages","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"关于coding的pages介绍","description":"他是收费的..收费的..收费的..和腾讯云的相关产品https://console.cloud.tencent.com/sls  主要是部署的时候使用https://console.cloud.tencent.com/cdn  如果你使用了自己的域名...则会使用cdnhttps://console.cloud.tencent.com/cos5  你生产的网站实际上是放在这个里面的.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他是收费的..收费的..收费的.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和腾讯云的相关产品"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://console.cloud.tencent.com/sls","rel":["nofollow"]},"children":[{"type":"text","value":"https://console.cloud.tencent.com/sls"}]},{"type":"text","value":"  主要是部署的时候使用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://console.cloud.tencent.com/cdn","rel":["nofollow"]},"children":[{"type":"text","value":"https://console.cloud.tencent.com/cdn"}]},{"type":"text","value":"  如果你使用了自己的域名...则会使用cdn"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://console.cloud.tencent.com/cos5","rel":["nofollow"]},"children":[{"type":"text","value":"https://console.cloud.tencent.com/cos5"}]},{"type":"text","value":"  你生产的网站实际上是放在这个里面的."}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2020-11-16-coding-pages.md","_source":"content","_file":"tool/2020-11-16-coding-pages.md","_extension":"md","date":"2020-11-16"},{"_path":"/tool/2021-05-06-dns","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"一些常用的dns服务器","description":"微软DNS服务器——可以长期信赖的稳定服务器。主用：4.2.2.1备用：4.2.2.2如果你使用win10,且要经常登录微软账号.一定要设置一个国内公共DNS服务提供商：百度DNS服务器——延迟很小，毕竟是大品牌，响应速度也不错，口碑不错。​\t主用：180.76.76.76腾讯DNS服务器——延迟小，响应快，口碑不错。​\t主用：119.29.29.29​\t备用：182.254.116.116阿里DNS服务器——延迟小，响应快，口碑不错。​\t主用：223.5.5.5​\t备用：223.6.6.6CNNIC中国互联网络信息中心 DNS服务器——国家队产品，地址好记，经常用来做网络连通性测试的。​\t主","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"微软dns服务器可以长期信赖的稳定服务器"},"children":[{"type":"text","value":"微软DNS服务器——可以长期信赖的稳定服务器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主用：4.2.2.1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"备用：4.2.2.2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你使用win10,且要经常登录微软账号.一定要设置一个"}]},{"type":"element","tag":"h3","props":{"id":"国内公共dns服务提供商"},"children":[{"type":"text","value":"国内公共DNS服务提供商："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"百度DNS服务器——延迟很小，毕竟是大品牌，响应速度也不错，口碑不错。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t主用：180.76.76.76"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"腾讯DNS服务器——延迟小，响应快，口碑不错。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t主用：119.29.29.29"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t备用：182.254.116.116"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"阿里DNS服务器——延迟小，响应快，口碑不错。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t主用：223.5.5.5"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t备用：223.6.6.6"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CNNIC中国互联网络信息中心 DNS服务器——国家队产品，地址好记，经常用来做网络连通性测试的。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t主用：1.2.4.8"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"​\t备用：202.98.0.68"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"微软dns服务器可以长期信赖的稳定服务器","depth":3,"text":"微软DNS服务器——可以长期信赖的稳定服务器。"},{"id":"国内公共dns服务提供商","depth":3,"text":"国内公共DNS服务提供商："}]}},"_type":"markdown","_id":"content:tool:2021-05-06-dns.md","_source":"content","_file":"tool/2021-05-06-dns.md","_extension":"md","date":"2021-05-06"},{"_path":"/tool/2021-11-06-ue4-view","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"UE4素材破解","description":"Pak解包和打包Pak文件就是UE4游戏生成的数据包文件，PC游戏一般放在游戏路径下的Content\\Paks，安卓则在obb解包后游戏路径下的Content\\Paks中，一般汉化所需的文本都放在pakchunk0-WindowsNoEditor.pak（PC端）或者pakchunk0-Android_ASTC.pak(移动端)中，如果不确定可以全部解包一下。目前主流的解包和打包工具有两种，一种是quickbms，另一种是UnrealPakSwitch。使用quickbms解包首先介绍一下quickbms(开发者论坛网站:https://zenhax.com/)的使用方法，quickbms并非","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Pak解包和打包"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pak文件就是UE4游戏生成的数据包文件，PC游戏一般放在游戏路径下的Content\\Paks，安卓则在obb解包后游戏路径下的Content\\Paks中，一般汉化所需的文本都放在pakchunk0-WindowsNoEditor.pak（PC端）或者pakchunk0-Android_ASTC.pak(移动端)中，如果不确定可以全部解包一下。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前主流的解包和打包工具有两种，一种是quickbms，另一种是UnrealPakSwitch。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"使用quickbms解包"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先介绍一下quickbms(开发者论坛网站:"},{"type":"element","tag":"a","props":{"href":"https://zenhax.com/","rel":["nofollow"]},"children":[{"type":"text","value":"https://zenhax.com/)的使用方法，quickbms并非UE4专用的解包打包工具，而是一个可以根据相应脚本插件来解包的工具，打开quickbms的目录，会看到这些文件，解包主要使用quickbms.exe和quickbms_4gb_files.exe，顾名思义quickbms_4gb_files.exe就是给超过4g的大文件解包使用的，没有超过的使用quickbms.exe解包即可。"}]},{"type":"text","value":"%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%8Cquickbms%E5%B9%B6%E9%9D%9EUE4%E4%B8%93%E7%94%A8%E7%9A%84%E8%A7%A3%E5%8C%85%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%80%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E7%9B%B8%E5%BA%94%E8%84%9A%E6%9C%AC%E6%8F%92%E4%BB%B6%E6%9D%A5%E8%A7%A3%E5%8C%85%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%89%93%E5%BC%80quickbms%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%8C%E4%BC%9A%E7%9C%8B%E5%88%B0%E8%BF%99%E4%BA%9B%E6%96%87%E4%BB%B6%EF%BC%8C%E8%A7%A3%E5%8C%85%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8quickbms.exe%E5%92%8Cquickbms_4gb_files.exe%EF%BC%8C%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89quickbms_4gb_files.exe%E5%B0%B1%E6%98%AF%E7%BB%99%E8%B6%85%E8%BF%874g%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%B6%85%E8%BF%87%E7%9A%84%E4%BD%BF%E7%94%A8quickbms.exe%E8%A7%A3%E5%8C%85%E5%8D%B3%E5%8F%AF%E3%80%82)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844816-d70f13e360aab32.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用过程很简单，打开quickbms.exe会提示选择选择解包脚本，我们选择unreal_tournament_4.bms这个脚本"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844817-dba7c407119b5ba.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后会再次提示选择pak，我们选择对应的pak包即可"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844818-69c6a966ef586fc.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果是没有加密的pak此时就会正常解包，如果是加密的pak，则需要输入密钥(密钥获取方式后面教程会提到)，后面就等待解包完成即可"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844818-e6616f823a65b43.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"使用quickbms打包"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"quickbms打包实际上就是解包的反过程，这里不能再直接使用quickbms.exe打包，而是要用打包脚本，如下图的三个脚本，使用reimport.bat打包有个条件，修改后的文件不能比源文件大。reimport2.bat和reimport3.bat按作者说法已经解决了这个限制，但是在实际使用中仍有问题，所以如果修改后的文件变大了就不建议使用了；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844819-43d08de99d1ba79.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"quickbms打包有一个优点，就是不需要提供全部的文件，只需要将修改后的文件按pak包中的目录放置好就行(注: 一定要是完整目录)，比如修改了Pak包中TWD\\Content\\Localization\\Game\\en中的Game.locres文件，那么就要建立TWD\\Content\\Localization\\Game\\en这个路径将修改的Game.locres文件放入其中，然后双击reimport.bat脚本，同样的选择unreal_tournament_4.bms这个脚本，选择pak包，最后选择刚刚修改文件的目录即可"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"使用UnrealPakSwitch解包和打包"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UnrealPakSwitch工具(作者详细教程链接:"},{"type":"element","tag":"a","props":{"href":"https://gbatemp.net/threads/how-to-unpack-and-repack-unreal-engine-4-files.531784/","rel":["nofollow"]},"children":[{"type":"text","value":"https://gbatemp.net/threads/how-to-unpack-and-repack-unreal-engine-4-files.531784/"}]},{"type":"text","value":" )实际使用的是虚幻4引擎中的UnrealPak.exe工具来进行解包和打包的，所以相对更加可靠，由于依赖的是u4pak.py脚本，所以需要先安装Python环境(可到官网下载，链接: "},{"type":"element","tag":"a","props":{"href":"https://www.python.org/ftp/python/3.9.0/python-3.9.0-amd64.exe","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.python.org/ftp/python/3.9.0/python-3.9.0-amd64.exe)。安装过程不在赘述注意建立Path环境变量。安装好后，首先需要使用1.check这个脚本检测版本，将pak包放入UnrealPakSwitch工具目录下，然后拖动到1.check.cmd上即可弹出版本，Unreal"}]},{"type":"text","value":"%E3%80%82%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%8D%E5%9C%A8%E8%B5%98%E8%BF%B0%E6%B3%A8%E6%84%8F%E5%BB%BA%E7%AB%8BPath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E3%80%82%E5%AE%89%E8%A3%85%E5%A5%BD%E5%90%8E%EF%BC%8C%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A81.check%E8%BF%99%E4%B8%AA%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E7%89%88%E6%9C%AC%EF%BC%8C%E5%B0%86pak%E5%8C%85%E6%94%BE%E5%85%A5UnrealPakSwitch%E5%B7%A5%E5%85%B7%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8B%96%E5%8A%A8%E5%88%B01.check.cmd%E4%B8%8A%E5%8D%B3%E5%8F%AF%E5%BC%B9%E5%87%BA%E7%89%88%E6%9C%AC%EF%BC%8CUnreal) Engine 4.19.2 (for v4 *.pak), Unreal Engine 4.20.3 (for v5 *.pak), Unreal Engine 4.21.2 (for v7 *.pak), Unreal Engine 4.22.3 (for v8 *.pak), Unreal Engine 4.24.1 (for v8.23 *.pak), Unreal Engine 4.25.4 (for v9 *.pak).，检测版本后根据对应的版本放入相应版本的UnrealPak.exe工具，作者教程中写的很详细，不在赘述。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844820-2b83cb865fd7122.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后就是解包，过程很简单，将pak包拖动到相应版本的unpack-vxx.cmd上，如果是加密包则拖动到unpack-encrypted-vxx.cmd上，即可自动进行解包，解包后目录会输出在UnrealPakSwitch工具目录下。同时会生成一个lista.txt文件，这个文件包含pak包中所有文件信息，后面打包需要用到。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当修改好后需要打包的时候，就要对lista.txt文件进行修改，详细修改方法见作者教程"},{"type":"element","tag":"a","props":{"href":"https://gbatemp.net/threads/how-to-unpack-and-repack-unreal-engine-4-files.531784/%E4%B8%AD%E7%9A%84Pack","rel":["nofollow"]},"children":[{"type":"text","value":"https://gbatemp.net/threads/how-to-unpack-and-repack-unreal-engine-4-files.531784/中的Pack"}]},{"type":"text","value":" files部分，修改好后拖动到pack-vxx.cmd上即可。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"简单导出并汉化文本文件"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于多语言的游戏，游戏文本基本都是放在Content\\Localization\\下的，如果目录下的文件是文本文件，那么直接用记事本打开修改即可，如果是locres文件，则需要使用工具来导出文本"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844821-7744d389d53038c.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用unreal_locres_export.exe是导出，unreal_locres_import.exe是导入，导出后的文本就是下面这样"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-06-ue4-view/1607844822-881c9b8a8029f4e.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将其修改成中文后(不要有任何换行动作，文件不要重命名)，使用导入工具生成locres文件即可。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"必备工具："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Umodel 下载网址："},{"type":"element","tag":"a","props":{"href":"http://www.gildor.org/en/projects/umodel","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gildor.org/en/projects/umodel"}]},{"type":"text","value":"   国外大神作品，英文网站，有点英语基础就行。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"不想点开网站的下载链接："},{"type":"element","tag":"a","props":{"href":"http://www.gildor.org/down/43/umodel/umodel_win32.zip","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gildor.org/down/43/umodel/umodel_win32.zip"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"之前只有32位系统可以用，现在更新后64位也可以用了（我的就是）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ActorX Import 也是上个网站上的插件，用于3ds max导入pskx文件用。下载解压后把文件放到3ds max 安装路径里的stdplugs文件夹里面。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3ds max 版本不限，但最好不要太低，我用的2019最新版，可以用。注意3ds max最好破解一下，不然30天用的不舒服。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UE4"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2021-11-06-ue4-view.md","_source":"content","_file":"tool/2021-11-06-ue4-view.md","_extension":"md","date":"2021-11-06"},{"_path":"/tool/2021-11-07-cockpit-linux","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"安装cockpit通过nginx代理访问","description":"安装cockpit后，默认只能通过IP地址+端口号来访问。其实，还可以通过nginx代理来访问。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安装cockpit后，默认只能通过IP地址+端口号来访问。其实，还可以通过nginx代理来访问。"}]},{"type":"element","tag":"h2","props":{"id":"添加nginxconf配置"},"children":[{"type":"text","value":"添加Nginx.conf配置"}]},{"type":"element","tag":"pre","props":{"code":" \n## 添加并修改\nvi /etc/nginx/conf.d/cockpit.godgodgame.com\n\n-------------------------------------------------------------------------------------\n\n#使用cockpt名称配置上游服务器\nupstream cockpit {\n    server 127.0.0.1:9090;\n}\n \n#将http重定向到https\nserver{\n    listen 80;\n    server_name cockpit.godgodgame.com;\n    return 301 https://$server_name$request_uri;\n}\n\n#使用https访问并配置ssl\nserver {\n    listen 443 ssl http2;\n    #填写绑定证书的域名\n    server_name cockpit.godgodgame.com;\n    \n    \n    #证书文件名称\n    ssl_certificate /etc/nginx/cert/1_godgodgame.com_bundle.crt;\n    #私钥文件名称\n    ssl_certificate_key /etc/nginx/cert/2_godgodgame.com.key;\n    ssl_session_timeout 5m;\n    #请按照以下协议配置\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; \n    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; \n    ssl_prefer_server_ciphers on;\n \n    location / {\n        # Required to proxy the connection to Cockpit\n        proxy_pass https://cockpit;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Required for web sockets to function\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Pass ETag header from Cockpit to clients.\n        # See: https://github.com/cockpit-project/cockpit/issues/5239\n        gzip off;\n    }\n}\n-------------------------------------------------------------------------------------\n# 先检查nginx配置是否有效/无有异常,如果有异常请按照异常提示修改；使用nginx -t进行nginx.conf的配置检测\n$ nginx -t;\n \n# 重启nginx\n$ nginx -s reload;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" \n## 添加并修改\nvi /etc/nginx/conf.d/cockpit.godgodgame.com\n\n-------------------------------------------------------------------------------------\n\n#使用cockpt名称配置上游服务器\nupstream cockpit {\n    server 127.0.0.1:9090;\n}\n \n#将http重定向到https\nserver{\n    listen 80;\n    server_name cockpit.godgodgame.com;\n    return 301 https://$server_name$request_uri;\n}\n\n#使用https访问并配置ssl\nserver {\n    listen 443 ssl http2;\n    #填写绑定证书的域名\n    server_name cockpit.godgodgame.com;\n    \n    \n    #证书文件名称\n    ssl_certificate /etc/nginx/cert/1_godgodgame.com_bundle.crt;\n    #私钥文件名称\n    ssl_certificate_key /etc/nginx/cert/2_godgodgame.com.key;\n    ssl_session_timeout 5m;\n    #请按照以下协议配置\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; \n    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; \n    ssl_prefer_server_ciphers on;\n \n    location / {\n        # Required to proxy the connection to Cockpit\n        proxy_pass https://cockpit;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Required for web sockets to function\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Pass ETag header from Cockpit to clients.\n        # See: https://github.com/cockpit-project/cockpit/issues/5239\n        gzip off;\n    }\n}\n-------------------------------------------------------------------------------------\n# 先检查nginx配置是否有效/无有异常,如果有异常请按照异常提示修改；使用nginx -t进行nginx.conf的配置检测\n$ nginx -t;\n \n# 重启nginx\n$ nginx -s reload;\n"}]}]},{"type":"element","tag":"h2","props":{"id":"修改cockpit"},"children":[{"type":"text","value":"修改Cockpit"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时输入域名，能看到登录页面，但登录后，显示不出内容，页面全白"}]},{"type":"element","tag":"pre","props":{"code":"sudo vim /etc/cockpit/cockpit.conf\n\n参照如下配置修改，注意域名替换为your_domain_host：\n[WebService]\nOrigins = https://cockpit.godgodgame.com https://127.0.0.1:9090\nProtocolHeader = X-Forwarded-Proto\nAllowUnencrypted = true\n\nsystemctl restart cockpit\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo vim /etc/cockpit/cockpit.conf\n\n参照如下配置修改，注意域名替换为your_domain_host：\n[WebService]\nOrigins = https://cockpit.godgodgame.com https://127.0.0.1:9090\nProtocolHeader = X-Forwarded-Proto\nAllowUnencrypted = true\n\nsystemctl restart cockpit\n"}]}]},{"type":"element","tag":"pre","props":{"code":"map $http_upgrade $connection_upgrade { default upgrade; '' close; }\n \nupstream websocket {\nserver 127.0.0.1:9090;\n}\n \nserver{\n    listen 80;\n    server_name cockpit.godgodgame.com;\n    return 301 https://$server_name$request_uri;\n}\n \nserver {\n    listen 443 ssl http2;\n    server_name cockpit.godgodgame.com;\n \n    #ssl on;\n    ssl_certificate /etc/nginx/cert/1_cockpit.godgodgame.com_bundle.crt;\n    ssl_certificate_key /etc/nginx/cert/2_cockpit.godgodgame.com.key;\n \n    location / {\n        root /;\n        index index.html;\n        proxy_redirect off;\n        proxy_pass http://websocket;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        proxy_set_header Host $http_host;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"map $http_upgrade $connection_upgrade { default upgrade; '' close; }\n \nupstream websocket {\nserver 127.0.0.1:9090;\n}\n \nserver{\n    listen 80;\n    server_name cockpit.godgodgame.com;\n    return 301 https://$server_name$request_uri;\n}\n \nserver {\n    listen 443 ssl http2;\n    server_name cockpit.godgodgame.com;\n \n    #ssl on;\n    ssl_certificate /etc/nginx/cert/1_cockpit.godgodgame.com_bundle.crt;\n    ssl_certificate_key /etc/nginx/cert/2_cockpit.godgodgame.com.key;\n \n    location / {\n        root /;\n        index index.html;\n        proxy_redirect off;\n        proxy_pass http://websocket;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        proxy_set_header Host $http_host;\n    }\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"参考链接"},"children":[{"type":"text","value":"参考链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/cockpit-project/cockpit/wiki/Proxying-Cockpit-over-nginx","rel":["nofollow"]},"children":[{"type":"text","value":"Proxying Cockpit over nginx · cockpit-project/cockpit Wiki (github.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://cloud.tencent.com/document/product/400/35244","rel":["nofollow"]},"children":[{"type":"text","value":"https://cloud.tencent.com/document/product/400/35244"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"添加nginxconf配置","depth":2,"text":"添加Nginx.conf配置"},{"id":"修改cockpit","depth":2,"text":"修改Cockpit"},{"id":"参考链接","depth":2,"text":"参考链接"}]}},"_type":"markdown","_id":"content:tool:2021-11-07-cockpit-linux.md","_source":"content","_file":"tool/2021-11-07-cockpit-linux.md","_extension":"md","date":"2021-11-07"},{"_path":"/tool/2021-11-15-install-windowsstore","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","description":"打开网址 https://store.rg-adguard.net/","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"打开网址 "},{"type":"element","tag":"a","props":{"href":"https://store.rg-adguard.net/","rel":["nofollow"]},"children":[{"type":"text","value":"https://store.rg-adguard.net/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以 PackageFamilyName 方式搜索 Microsoft.WindowsStore_8wekyb3d8bbwe"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据系统选择对应的包，每一种都要下载"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-15-install-WindowsStore/1595409-20190313101653224-1704280347.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"安装"},"children":[{"type":"text","value":"安装"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在下载目录按住 shift 键，然后鼠标右键，打开 Powershell"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-15-install-WindowsStore/1595409-20190313103101576-1015756103.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行安装命令，此处只安装了 64 位安装包，建议在安装时把 32 位也一并下载安装"}]},{"type":"element","tag":"pre","props":{"code":"# 安装该路径下所有包\nAdd-AppxPackage *\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 安装该路径下所有包\nAdd-AppxPackage *\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-15-install-WindowsStore/1595409-20190313103229471-402846601.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此时点击开始菜单应该就能看到应用商店了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-11-15-install-WindowsStore/1595409-20190313103450428-1760401185.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"清空应用商店缓存 WSReset.exe"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"应用商店 ID 为 9WZDNCRFJBMP"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"应用安装器 ID 为 9NBLGGH4NNS1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/dragonflylee/WimHelper","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/dragonflylee/WimHelper"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/kkkgo/LTSB-Add-MicrosoftStore","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/kkkgo/LTSB-Add-MicrosoftStore"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.microsoft.com/zh-cn/store","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"https://www.microsoft.com/zh-cn/store"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2021-11-15-install-WindowsStore.md","_source":"content","_file":"tool/2021-11-15-install-WindowsStore.md","_extension":"md","date":"2021-11-15"},{"_path":"/tool/2021-12-02-vscode-plugins-big","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","description":"前言最近在打包 VS Code 插件时，发现打包后的插件体积非常大，而且插件在 VS Code 中的启动速度非常慢，对用户的体验不太友好了。对此做了一些研究，并更改了打包策略，终于把插件的体积从 35M 减少到 3M，并提高了插件的启动速度。本文将带你分析插件体积过大和启动速度过慢的原因，并讲解如何通过使用 webpack 进行打包来减少插件体积。最后将讲解如何配置 externals 剥离一些依赖模块，减少 bundle 的体积，避免出现打包失败的问题。原始打包首先，我们会以 iceworks-page-builder VS Code 插件为例子进行分析，具体的代码可以点击此链接查看。其中，","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最近在打包 VS Code 插件时，发现打包后的插件体积非常大，而且插件在 VS Code 中的启动速度非常慢，对用户的体验不太友好了。对此做了一些研究，并更改了打包策略，终于把插件的体积从 35M 减少到 3M，并提高了插件的启动速度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文将带你分析插件体积过大和启动速度过慢的原因，并讲解如何通过使用 webpack 进行打包来减少插件体积。最后将讲解如何配置 externals 剥离一些依赖模块，减少 bundle 的体积，避免出现打包失败的问题。"}]},{"type":"element","tag":"h2","props":{"id":"原始打包"},"children":[{"type":"text","value":"原始打包"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，我们会以 iceworks-page-builder VS Code 插件为例子进行分析，具体的代码可以点击"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/ice-lab/iceworks/tree/v0.1.6/extensions/iceworks-page-builder","rel":["nofollow"]},"children":[{"type":"text","value":"此链接"}]},{"type":"text","value":"查看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中，部分目录结构说明如下："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">├── .vscodeignore            # 插件打包时需要忽略的文件\n├── build                     # 构建产物目录\n├── node_modules\n├── package.json\n├── src                       # 插件相关的源代码\n|  ├── extension.ts\n|  ├── services\n|  └── types.d.ts\n├── tsconfig.json\n└── web                       # webview 相关代码 本质是一个 React 项目</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">├── .vscodeignore            # 插件打包时需要忽略的文件\n├── build                     # 构建产物目录\n├── node_modules\n├── package.json\n├── src                       # 插件相关的源代码\n|  ├── extension.ts\n|  ├── services\n|  └── types.d.ts\n├── tsconfig.json\n└── web                       # webview 相关代码 本质是一个 React 项目</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"打包插件需要使用 "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/microsoft/vscode-vsce","rel":["nofollow"]},"children":[{"type":"text","value":"vsce"}]},{"type":"text","value":" 这个工具。 首先确认已安装 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vsce"}]},{"type":"text","value":" ；若未安装，则执行以下的命令安装 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vsce"}]},{"type":"text","value":" ："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">npm i vsce -g</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">npm i vsce -g</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在项目的根目录下执行以下命令，即开始对插件进行打包："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">vsce package</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">vsce package</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它会先执行 scripts 中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vscode:prepublish"}]},{"type":"text","value":" 命令。从上面可以看出，会先对 Webview 相关的代码进行构建（本质是 CLI 提供的构建能力），得到 js 、html 、css 代码，然后使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"tsc"}]},{"type":"text","value":" 对插件源代码（./src/**）进行编译。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"等待 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vscode:prepublish"}]},{"type":"text","value":" 执行完成后， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vsce"}]},{"type":"text","value":" 将执行剩下的插件打包操作，最后会在项目根目录下出现一个 .vsix 文件，也就是我们成功打包出来的插件。现在，整个插件的体积是 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"35M"}]},{"type":"text","value":"，在 VS Code 中启动速度大概为 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"8s"}]},{"type":"text","value":"。插件启动效果图如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-fbf1b8f5b23a29b359d922f428152455_b.webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那我们有办法知道究竟是哪些文件导致这个 .vsix 文件这么大的吗？答案是有的。我们只需要把 .vsix 的后缀改成 .zip，然后把这个 zip 文件进行解压，即可看到整个插件是由哪些文件构成了。"}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">workspace/ice/iceworks/extensions/iceworks-page-builder/iceworks-page-builder-0.1.7\n└── extension\n   ├── CHANGELOG.md\n   ├── README.en.md\n   ├── README.md\n   ├── assets\n   ├── build                     # 1.86M\n        ├── assets\n      ├── css\n        |   └── index.css\n      ├── extension.js\n      ├── favicon.png\n      ├── index.html\n      ├── js\n      |  └── index.js\n      └── services\n         └── index.js\n   ├── node_modules              # 69.6M\n   ├── package.json\n   ├── package.nls.json\n   └── package.nls.zh-cn.json</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">workspace/ice/iceworks/extensions/iceworks-page-builder/iceworks-page-builder-0.1.7\n└── extension\n   ├── CHANGELOG.md\n   ├── README.en.md\n   ├── README.md\n   ├── assets\n   ├── build                     # 1.86M\n        ├── assets\n      ├── css\n        |   └── index.css\n      ├── extension.js\n      ├── favicon.png\n      ├── index.html\n      ├── js\n      |  └── index.js\n      └── services\n         └── index.js\n   ├── node_modules              # 69.6M\n   ├── package.json\n   ├── package.nls.json\n   └── package.nls.zh-cn.json</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看出其中的 node_modules 目录的体积是最大的，这是导致插件体积过大的问题。另外，build 目录和node_modules 目录下有很多模块，正是如此，VS Code 在加载我们的插件的过程中，会加载很多小模块，这就是加载过慢的原因。"}]},{"type":"element","tag":"h2","props":{"id":"使用-webpack-进行打包"},"children":[{"type":"text","value":"使用 webpack 进行打包"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相信大部分的前端开发者都知道，现在的模块化的前端开发范式非常流行，与此同时出现了很多模块构建工具，比如 Rollup、webpack 等。这些模块构建工具的出发点之一是，把多个模块打包成一个模块，解决加载多个模块速度过慢的问题。那我们能不能用这些构建工具，把多个小的源文件打包成单个入口文件，从而解决上述的问题呢？答案是肯定的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我们需要安装一下 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack-cli"}]},{"type":"text","value":" ，其中， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack"}]},{"type":"text","value":" 是 Webpack 的核心模块， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack-cli"}]},{"type":"text","value":" 是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack"}]},{"type":"text","value":" 的 CLI 程序，用来在命令行中调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack"}]},{"type":"text","value":" 。另外还需要安装 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ts-loader"}]},{"type":"text","value":" ，用于加载 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ts"}]},{"type":"text","value":" 代码并编译成 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"js"}]},{"type":"text","value":" 代码。"}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">npm i --save-dev webpack webpack-cli ts-loader</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">npm i --save-dev webpack webpack-cli ts-loader</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安装完成以后，我们需要在根目录下新建一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack.config.js"}]},{"type":"text","value":" ，并增加以下的内容："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-js\">const path = require('path');\n\nconst tsConfigPath = path.join(__dirname, 'tsconfig.json');\n\nconst config = {\n  target: 'node',\n  entry: './src/extension.ts',\n  output: {\n    path: path.resolve(__dirname, 'build'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2',\n    devtoolModuleFilenameTemplate: '../[resource-path]',\n  },\n  externals: {\n    vscode: 'commonjs vscode'\n  },\n  resolve: {\n    extensions: ['.ts', '.js'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              configFile: tsConfigPath,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n\nmodule.exports = (env, argv) => {\n  if (argv.mode === 'development') {\n    config.devtool = 'source-map';\n  }\n\n  return config;\n};</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-js\">const path = require('path');\n\nconst tsConfigPath = path.join(__dirname, 'tsconfig.json');\n\nconst config = {\n  target: 'node',\n  entry: './src/extension.ts',\n  output: {\n    path: path.resolve(__dirname, 'build'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2',\n    devtoolModuleFilenameTemplate: '../[resource-path]',\n  },\n  externals: {\n    vscode: 'commonjs vscode'\n  },\n  resolve: {\n    extensions: ['.ts', '.js'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              configFile: tsConfigPath,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n\nmodule.exports = (env, argv) => {\n  if (argv.mode === 'development') {\n    config.devtool = 'source-map';\n  }\n\n  return config;\n};</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"修改 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"package.json"}]},{"type":"text","value":" 中 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"scripts"}]},{"type":"text","value":" 的内容，以使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack"}]},{"type":"text","value":" 进行打包："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-json\">{\n    \"scripts\": {\n    \"vscode:prepublish\": \"rm -rf build && npm run build:web && webpack --mode production\",\n    \"build:web\": \"cd web && npm run build\",\n    \"watch:web\": \"cd web && npm run start\",\n    \"webpack\": \"webpack --mode development\",\n    \"webpack-dev\": \"webpack --mode development --watch\"\n  },\n}</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-json\">{\n    \"scripts\": {\n    \"vscode:prepublish\": \"rm -rf build && npm run build:web && webpack --mode production\",\n    \"build:web\": \"cd web && npm run build\",\n    \"watch:web\": \"cd web && npm run start\",\n    \"webpack\": \"webpack --mode development\",\n    \"webpack-dev\": \"webpack --mode development --watch\"\n  },\n}</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于经过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack"}]},{"type":"text","value":" 打包后， bundle 中都已经包括了需要的模块。我们可以修改 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".vscodeignore"}]},{"type":"text","value":" 的内容，把插件打包中不需要的文件忽略掉，当然我们的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"node_modules"}]},{"type":"text","value":" 也可以忽略掉："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">.vscode\nnode_modules\nsrc/\nweb/\ntsconfig.json\nwebpack.config.js</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">.vscode\nnode_modules\nsrc/\nweb/\ntsconfig.json\nwebpack.config.js</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上的相关配置可以点击"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/ice-lab/iceworks/tree/v0.3.0/extensions/iceworks-page-builder","rel":["nofollow"]},"children":[{"type":"text","value":"此链接"}]},{"type":"text","value":"进行查看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在官方文档中，有一个章节专门讲解了如何使用 webpack 对插件进行打包。更详细的步骤可以参考"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//code.visualstudio.com/api/working-with-extensions/bundling-extension","rel":["nofollow"]},"children":[{"type":"text","value":"文档"}]},{"type":"text","value":"。**"}]},{"type":"element","tag":"h2","props":{"id":"使用-externals-减少-bundle-体积"},"children":[{"type":"text","value":"使用 externals 减少 bundle 体积"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当配制好 webpack 相关配置，使用 webpack 打包构建插件时，出现以下的错误："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-0281fdef1bde4672c98eb45a0367ad36_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大概的问题是，使用 webpack 在生产环境下进行打包时，会使用 "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/terser/terser","rel":["nofollow"]},"children":[{"type":"text","value":"terser"}]},{"type":"text","value":" 对源码进行压缩。但是我们的 bundle 太大了（预计 bundle 的大小超过10M的时候），导致在压缩的过程中出现内存溢出的问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"webpack-bundle-analyzer"}]},{"type":"text","value":" 来分析 bundle 的组成。 bundle 的依赖模块组成具体如下图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-1214a43d4854d3899346cd1f6a91b168_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看出我们项目依赖的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"prettier"}]},{"type":"text","value":" 占用了 bundle 中非常大的体积。那我们现在需要借助 webpack 中的 externals，不要把该依赖打包到 bundle 中，而是作为一个外部扩展，在运行时再去从外部获取依赖。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以先在 webpack.config.js 中配置 externals :"}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-js\">module.exports = {\n  externals: {\n    vscode: 'commonjs vscode',\n  + prettier: 'commonjs prettier'\n  },\n}</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-js\">module.exports = {\n  externals: {\n    vscode: 'commonjs vscode',\n  + prettier: 'commonjs prettier'\n  },\n}</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"确保插件在打包的时候，相关依赖也存在于插件中，需要在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".vscodeignore"}]},{"type":"text","value":" 文件中加入以下内容（这里真的踩了坑了）："}]},{"type":"element","tag":"pre","props":{"code":"<code class=\"language-text\">!node_modules/prettier</code>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<code class=\"language-text\">!node_modules/prettier</code>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置完成后，再进行打包，最后打包的插件体积为 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3.6M"}]},{"type":"text","value":"，在 VS Code 中启动速度降到了 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1s"}]},{"type":"text","value":" ，效果图如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-7fa4f670dae3d7e42f8b8e62e041289d_b.jpg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"总结"},"children":[{"type":"text","value":"总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果大家在打包 VS Code 插件时，如果打包出来的插件的体积过大，不妨可以考虑使用 webpack 对你的 VS Code 插件进行打包，会让你的插件有更小的体积，更快的启动速度，更好的用户体验。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"原始打包","depth":2,"text":"原始打包"},{"id":"使用-webpack-进行打包","depth":2,"text":"使用 webpack 进行打包"},{"id":"使用-externals-减少-bundle-体积","depth":2,"text":"使用 externals 减少 bundle 体积"},{"id":"总结","depth":2,"text":"总结"}]}},"_type":"markdown","_id":"content:tool:2021-12-02-vscode-plugins-big.md","_source":"content","_file":"tool/2021-12-02-vscode-plugins-big.md","_extension":"md","date":"2021-12-02"},{"_path":"/tool/2021-12-11-yunxiao-liushuixian-hexo","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"云效部署hexo到自己的主机 ","description":"构建设置构建命令# input your command here\ncnpm install -g hexo-cli\ncnpm install\nhexo clean\nhexo generate\n设置构建物\n部署设置下载路径设置部署脚本# 部署脚本会在部署组的每台机器上执行。\n# 一个典型脚本逻辑如下：先将制品包（在下载路径中配置的下载路径）解压缩到指定目录中，再执行启动脚本（通常在代码中维护，如示例中deploy.sh）。\n# 关于这个例子的详细解释见 https://help.aliyun.com/document_detail/153848.html \nmkdir /usr/local/s","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"构建"},"children":[{"type":"text","value":"构建"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设置构建命令"}]},{"type":"element","tag":"pre","props":{"code":"# input your command here\ncnpm install -g hexo-cli\ncnpm install\nhexo clean\nhexo generate\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# input your command here\ncnpm install -g hexo-cli\ncnpm install\nhexo clean\nhexo generate\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设置构建物\n"},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-11-yunxiao-liushuixian-hexo/2021-12-01-22-00-34uxj0h.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"部署"},"children":[{"type":"text","value":"部署"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设置下载路径"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-11-yunxiao-liushuixian-hexo/2021-12-01-22-01-45guws3.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设置部署脚本"}]},{"type":"element","tag":"pre","props":{"code":"# 部署脚本会在部署组的每台机器上执行。\n# 一个典型脚本逻辑如下：先将制品包（在下载路径中配置的下载路径）解压缩到指定目录中，再执行启动脚本（通常在代码中维护，如示例中deploy.sh）。\n# 关于这个例子的详细解释见 https://help.aliyun.com/document_detail/153848.html \nmkdir /usr/local/src/igiven\ntar -zxvf /usr/local/src/igiven.tgz -C /usr/local/src/igiven/\n\\cp -rf /usr/local/src/igiven/* /usr/share/nginx/html\nrm -rf /usr/local/src/igiven.tgz\nrm -rf /usr/local/src/igiven\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 部署脚本会在部署组的每台机器上执行。\n# 一个典型脚本逻辑如下：先将制品包（在下载路径中配置的下载路径）解压缩到指定目录中，再执行启动脚本（通常在代码中维护，如示例中deploy.sh）。\n# 关于这个例子的详细解释见 https://help.aliyun.com/document_detail/153848.html \nmkdir /usr/local/src/igiven\ntar -zxvf /usr/local/src/igiven.tgz -C /usr/local/src/igiven/\n\\cp -rf /usr/local/src/igiven/* /usr/share/nginx/html\nrm -rf /usr/local/src/igiven.tgz\nrm -rf /usr/local/src/igiven\n"}]}]},{"type":"element","tag":"h2","props":{"id":"注意点"},"children":[{"type":"text","value":"注意点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"仓库的名称不要例如igiven.github.io.不然部署时拉取仓库会失败"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加主机时必须使用python2.7"}]}]},{"type":"element","tag":"pre","props":{"code":"yum install -y nginx python2\nwhereis python\npython -v\nrm /usr/bin/python\nln -s /usr/bin/python2.7 /usr/bin/python\n# 执行过命令可以把python删除再link回去\n\nsystemctl enable nginx\nsystemctl start nginx\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"yum install -y nginx python2\nwhereis python\npython -v\nrm /usr/bin/python\nln -s /usr/bin/python2.7 /usr/bin/python\n# 执行过命令可以把python删除再link回去\n\nsystemctl enable nginx\nsystemctl start nginx\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"构建","depth":2,"text":"构建"},{"id":"部署","depth":2,"text":"部署"},{"id":"注意点","depth":2,"text":"注意点"}]}},"_type":"markdown","_id":"content:tool:2021-12-11-yunxiao-liushuixian-hexo.md","_source":"content","_file":"tool/2021-12-11-yunxiao-liushuixian-hexo.md","_extension":"md","date":"2021-12-11"},{"_path":"/tool/2021-12-12-github-sync","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"github 怎么合并原始分支？ ","description":"复刻仓库On GitHub.com, navigate to the octocat/Spoon-Knife repository.在页面的右上角，单击 Fork（复刻）。$ git clone https://github.com/YOUR-USERNAME/Spoon-Knife\n> Cloning into `Spoon-Knife`...\n> remote: Counting objects: 10, done.\n> remote: Compressing objects: 100% (8/8), done.\n> remove: Total 10 (delta 1), reused 1","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"复刻仓库"},"children":[{"type":"text","value":"复刻仓库"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"On GitHub.com, navigate to the "},{"type":"element","tag":"a","props":{"href":"https://github.com/octocat/Spoon-Knife","rel":["nofollow"]},"children":[{"type":"text","value":"octocat/Spoon-Knife"}]},{"type":"text","value":" repository."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在页面的右上角，单击 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Fork（复刻）"}]},{"type":"text","value":"。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-12-github-sync/2021-11-30-04-25-59.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"$ git clone https://github.com/YOUR-USERNAME/Spoon-Knife\n> Cloning into `Spoon-Knife`...\n> remote: Counting objects: 10, done.\n> remote: Compressing objects: 100% (8/8), done.\n> remove: Total 10 (delta 1), reused 10 (delta 1)\n> Unpacking objects: 100% (10/10), done.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$ git clone https://github.com/YOUR-USERNAME/Spoon-Knife\n> Cloning into `Spoon-Knife`...\n> remote: Counting objects: 10, done.\n> remote: Compressing objects: 100% (8/8), done.\n> remove: Total 10 (delta 1), reused 10 (delta 1)\n> Unpacking objects: 100% (10/10), done.\n"}]}]},{"type":"element","tag":"h2","props":{"id":"增加复刻的仓库作为上游远程仓库"},"children":[{"type":"text","value":"增加复刻的仓库作为上游远程仓库"}]},{"type":"element","tag":"pre","props":{"code":"$ git remote add upstream https://github.com/octocat/Spoon-Knife.git\n\n\n$ git remote -v\n> origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)\n> origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)\n> upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)\n> upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$ git remote add upstream https://github.com/octocat/Spoon-Knife.git\n\n\n$ git remote -v\n> origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)\n> origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)\n> upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)\n> upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后续就可以进行合并操作了"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.github.com/cn/get-started/quickstart/fork-a-repo","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.github.com/cn/get-started/quickstart/fork-a-repo"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"复刻仓库","depth":2,"text":"复刻仓库"},{"id":"增加复刻的仓库作为上游远程仓库","depth":2,"text":"增加复刻的仓库作为上游远程仓库"}]}},"_type":"markdown","_id":"content:tool:2021-12-12-github-sync.md","_source":"content","_file":"tool/2021-12-12-github-sync.md","_extension":"md","date":"2021-12-12"},{"_path":"/tool/2022-01-30-code-server","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"code server安装制作online ide","description":"官方文档code-server v4.0.2 docs (coder.com)coder/code-server: VS Code in the browser (github.com)原理基础code-server是一款基于VScode的在线编辑器,主要用于在Linux服务器环境下,实现任何设备通过浏览器即可访问VScode, 进而实现在远程编程.安装linux标准安装方式mkdir -p ~/.local/lib ~/.local/bin\ncurl -fL https://github.com/cdr/code-server/releases/download/v$VERSION/code","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"官方文档"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"官方文档"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://coder.com/docs/code-server/latest","rel":["nofollow"]},"children":[{"type":"text","value":"code-server v4.0.2 docs ("}]},{"type":"element","tag":"a","props":{"href":"http://coder.com","rel":["nofollow"]},"children":[{"type":"text","value":"coder.com"}]},{"type":"element","tag":"a","props":{"href":"https://coder.com/docs/code-server/latest","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/coder/code-server","rel":["nofollow"]},"children":[{"type":"text","value":"coder/code-server: VS Code in the browser ("}]},{"type":"element","tag":"a","props":{"href":"http://github.com","rel":["nofollow"]},"children":[{"type":"text","value":"github.com"}]},{"type":"element","tag":"a","props":{"href":"https://github.com/coder/code-server","rel":["nofollow"]},"children":[{"type":"text","value":")"}]}]}]},{"type":"element","tag":"h2","props":{"id":"原理基础"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"原理基础"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"code-server是一款基于VScode的在线编辑器,主要用于在Linux服务器环境下,实现任何设备通过浏览器即可访问VScode, 进而实现在远程编程."}]},{"type":"element","tag":"h2","props":{"id":"安装"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"安装"}]}]},{"type":"element","tag":"h3","props":{"id":"linux标准安装方式"},"children":[{"type":"text","value":"linux标准安装方式"}]},{"type":"element","tag":"pre","props":{"code":"mkdir -p ~/.local/lib ~/.local/bin\ncurl -fL https://github.com/cdr/code-server/releases/download/v$VERSION/code-server-$VERSION-linux-amd64.tar.gz \\\n  | tar -C ~/.local/lib -xz\nmv ~/.local/lib/code-server-$VERSION-linux-amd64 ~/.local/lib/code-server-$VERSION\nln -s ~/.local/lib/code-server-$VERSION/bin/code-server ~/.local/bin/code-server\nPATH=\"~/.local/bin:$PATH\"\ncode-server\n# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"mkdir -p ~/.local/lib ~/.local/bin\ncurl -fL https://github.com/cdr/code-server/releases/download/v$VERSION/code-server-$VERSION-linux-amd64.tar.gz \\\n  | tar -C ~/.local/lib -xz\nmv ~/.local/lib/code-server-$VERSION-linux-amd64 ~/.local/lib/code-server-$VERSION\nln -s ~/.local/lib/code-server-$VERSION/bin/code-server ~/.local/bin/code-server\nPATH=\"~/.local/bin:$PATH\"\ncode-server\n# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml\n"}]}]},{"type":"element","tag":"h3","props":{"id":"fedora-centos-rhel-suse"},"children":[{"type":"text","value":"Fedora, CentOS, RHEL, SUSE"}]},{"type":"element","tag":"pre","props":{"code":"curl -fOL https://github.com/cdr/code-server/releases/download/v$VERSION/code-server-$VERSION-amd64.rpm\nsudo rpm -i code-server-$VERSION-amd64.rpm\nsudo systemctl enable --now code-server@$USER\n# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml\n\nsystemctl start code-server@$USER\nsystemctl stop code-server@$USER\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"curl -fOL https://github.com/cdr/code-server/releases/download/v$VERSION/code-server-$VERSION-amd64.rpm\nsudo rpm -i code-server-$VERSION-amd64.rpm\nsudo systemctl enable --now code-server@$USER\n# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml\n\nsystemctl start code-server@$USER\nsystemctl stop code-server@$USER\n"}]}]},{"type":"element","tag":"h3","props":{"id":"windows"},"children":[{"type":"text","value":"windows"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"推荐使用yarn或者npm进行安装"}]},{"type":"element","tag":"pre","props":{"code":"yarn global add code-server\n# Or: npm install -g code-server\ncode-server\n# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"yarn global add code-server\n# Or: npm install -g code-server\ncode-server\n# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml\n"}]}]},{"type":"element","tag":"h2","props":{"id":"配置"},"children":[{"type":"text","value":"配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"配置文件一般在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"~/.config/code-server/config.yaml"}]},{"type":"text","value":",可以将ip配置成"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"0.0.0.0"}]},{"type":"text","value":",然后将域名解析到该服务器"}]},{"type":"element","tag":"pre","props":{"code":"bind-addr: 127.0.0.1:8080\nauth: password\npassword: *************\ncert: false\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"bind-addr: 127.0.0.1:8080\nauth: password\npassword: *************\ncert: false\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安装nginx,并且配置https,否则很多插件不能使用"}]},{"type":"element","tag":"pre","props":{"code":"yum install  -y nginx certbot python3-certbot-nginx\nvim /etc/nginx/conf.d/dev.godgodgame.com.conf\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"yum install  -y nginx certbot python3-certbot-nginx\nvim /etc/nginx/conf.d/dev.godgodgame.com.conf\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"nginx.配置文件"}]},{"type":"element","tag":"pre","props":{"code":"server {\n    listen 443 ssl;\n    #填写绑定证书的域名\n    server_name dev.godgodgame.com;\n    #证书文件名称\n    ssl_certificate  /etc/nginx/certs/dev.godgodgame.com_bundle.crt;\n    #私钥文件名称\n    ssl_certificate_key /etc/nginx/certs/dev.godgodgame.com.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    location / {\n      proxy_pass http://127.0.0.1:8080/;\n      proxy_set_header Host $host;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection upgrade;\n      proxy_set_header Accept-Encoding gzip;\n    }\n}\nserver {\n    listen 80;\n    #填写绑定证书的域名\n    server_name cloud.tencent.com;\n    #把http的域名请求转成https\n    return 301 https://$host$request_uri;\n}\n\n# 先检查nginx配置是否有效/无有异常,如果有异常请按照异常提示修改；使用nginx -t进行nginx.conf的配置检测\n$ nginx -t;\n$ systemctl enable nginx\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"server {\n    listen 443 ssl;\n    #填写绑定证书的域名\n    server_name dev.godgodgame.com;\n    #证书文件名称\n    ssl_certificate  /etc/nginx/certs/dev.godgodgame.com_bundle.crt;\n    #私钥文件名称\n    ssl_certificate_key /etc/nginx/certs/dev.godgodgame.com.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    location / {\n      proxy_pass http://127.0.0.1:8080/;\n      proxy_set_header Host $host;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection upgrade;\n      proxy_set_header Accept-Encoding gzip;\n    }\n}\nserver {\n    listen 80;\n    #填写绑定证书的域名\n    server_name cloud.tencent.com;\n    #把http的域名请求转成https\n    return 301 https://$host$request_uri;\n}\n\n# 先检查nginx配置是否有效/无有异常,如果有异常请按照异常提示修改；使用nginx -t进行nginx.conf的配置检测\n$ nginx -t;\n$ systemctl enable nginx\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"官方文档","depth":2,"text":"官方文档"},{"id":"原理基础","depth":2,"text":"原理基础"},{"id":"安装","depth":2,"text":"安装","children":[{"id":"linux标准安装方式","depth":3,"text":"linux标准安装方式"},{"id":"fedora-centos-rhel-suse","depth":3,"text":"Fedora, CentOS, RHEL, SUSE"},{"id":"windows","depth":3,"text":"windows"}]},{"id":"配置","depth":2,"text":"配置"}]}},"_type":"markdown","_id":"content:tool:2022-01-30-code-server.md","_source":"content","_file":"tool/2022-01-30-code-server.md","_extension":"md","date":"2022-01-30"},{"_path":"/tool/2022-08-02-rider-use","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"rider的使用","description":"由于升级了dots,致使vs使用的时候总是很卡.所以临时使用了rider,记录下使用过程中遇到的问题","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于升级了dots,致使vs使用的时候总是很卡.所以临时使用了rider,记录下使用过程中遇到的问题"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"禁用IntelliJ IDEA向Git自动添加、删除或更新文件的功能"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659421011000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"keymap设置键位："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/6938c7b76587488faea649d26f43dbac.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设置主题：Editor=》 color scheme"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/2edb6d308f1a42a792826418bc903a6f.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设置编辑器字体大小"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659421547000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设置c#命名规范,去除前缀以及设置驼峰"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659428204000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"去出波浪线警告"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"在 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Error and Warnings"}]},{"type":"text","value":" 里有很多选项，你可以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"选取任意一个，预览它的提示效果，并修改或者直接关闭它"}]},{"type":"text","value":"，"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n关闭后是不是觉得整个世界清爽了好多~"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659422704000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"点击下面出现颜色 选择去除绿色和黄色标志"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"推荐这种去除波浪线,可以通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"show Context Actions"}]},{"type":"text","value":" => "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"inspection:\"xxx\""}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659422560000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"有关脚本修改了的标志符，可以在下列设置中开启"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/20201203141714194.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659423520000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"工具栏的显示隐藏"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659423590000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"脚本保存后，Unity后台是否自动刷新"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"有时候我们修改了脚本，刚保存，就会发现后台的Unity已经开始编译了，会造成一定的卡顿。如果期望只有在切到Unity时才开始编译，可以关闭以下设置："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659423746000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"当然unity得需要开启自动刷新才行,否则切换到unity需要按下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ctrl"}]},{"type":"text","value":"+"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"r"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659424615000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"去除灰色参数提示"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-02-rider-use/1659429053000.png"},"children":[]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:tool:2022-08-02-rider-use.md","_source":"content","_file":"tool/2022-08-02-rider-use.md","_extension":"md","date":"2022-08-02"},{"_path":"/tool/2022-08-09-amd-over","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"2022 08 09 Amd Over","description":"title : \"amd 超频总结\"先超cpu再超内存..内存超频问题会影响cpu超频.内存超频的问题也会导致黑屏pbo中的温度墙以及负压,对于定频定压没有效果进入系统后立即黑屏.可以打开防掉压,或者继续加电压,电压过低也会导致黑屏定压定频的功率会高与pbo的功率定压定频,由于没有温度墙等限制..一定要注意温度..基本上黑屏重启都是cpu的温度造成的..cpu核心温度超过100就会黑屏所以如果定压定频的话,一定要确保你有一个好的散热风扇,因为多开应用或者持续高使用率,由于没有温度墙会升高温度,造成黑屏","body":{"type":"root","children":[{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"title-amd-超频总结"},"children":[{"type":"text","value":"title : \"amd 超频总结\""}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"先超cpu再超内存..内存超频问题会影响cpu超频.内存超频的问题也会导致黑屏"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"pbo中的温度墙以及负压,对于定频定压没有效果"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"进入系统后立即黑屏.可以打开防掉压,或者继续加电压,电压过低也会导致黑屏"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定压定频的功率会高与pbo的功率"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定压定频,由于没有温度墙等限制..一定要注意温度..基本上黑屏重启都是cpu的温度造成的..cpu核心温度超过100就会黑屏"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所以如果定压定频的话,一定要确保你有一个好的散热风扇,因为多开应用或者持续高使用率,由于没有温度墙会升高温度,造成黑屏"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"title-amd-超频总结","depth":2,"text":"title : \"amd 超频总结\""}]}},"_type":"markdown","_id":"content:tool:2022-08-09-amd-over.md","_source":"content","_file":"tool/2022-08-09-amd-over.md","_extension":"md","date":"2022-08-09"},{"_path":"/tool/2022-11-19-rider-po-jie","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"rider破解","description":"使用ja-netfilter激活IDEA 2022.2.1背景截止至2022年9月4日，最新的IDEA版本为2022.2.1，对于某些想体验最新版IDEA却暂时没法入正的开发者来说，不能体验新版非常遗憾。\n重置IDEA体验版的插件IDE Eval Resetter已经失效了，不过开发此插件的作者又开发出另一款工具ja-netfilter，但是文档中使用方法写的有些模糊，我就以我自己的使用经验分享给大家。此方法目前适用于IDEA 2022.2.1，更高的版本不保证适用，请注意时效。下载IDEA如果你已经安装了任意版本的IDEA，那么建议你先卸载并清除数据再安装，否则激活可能无效。官网下载IDEA","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"使用ja-netfilter激活idea-202221"},"children":[{"type":"text","value":"使用ja-netfilter激活IDEA 2022.2.1"}]},{"type":"element","tag":"h2","props":{"id":"背景"},"children":[{"type":"text","value":"背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"截止至2022年9月4日，最新的IDEA版本为2022.2.1，对于某些想体验最新版IDEA却暂时没法入正的开发者来说，不能体验新版非常遗憾。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n重置IDEA体验版的插件"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IDE Eval Resetter"}]},{"type":"text","value":"已经失效了，不过开发此插件的作者又开发出另一款工具"},{"type":"element","tag":"a","props":{"href":"https://gitee.com/ja-netfilter/ja-netfilter","rel":["nofollow"]},"children":[{"type":"text","value":"ja-netfilter"}]},{"type":"text","value":"，但是文档中使用方法写的有些模糊，我就以我自己的使用经验分享给大家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-19-rider-po-jie/2084018-20220904174243771-2143320926.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此方法目前适用于IDEA 2022.2.1，更高的版本不保证适用，请注意时效。"}]},{"type":"element","tag":"h2","props":{"id":"下载idea"},"children":[{"type":"text","value":"下载IDEA"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如果你已经安装了任意版本的IDEA，那么建议你先卸载并清除数据再安装，否则激活可能无效。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jetbrains.com/zh-cn/idea/download/#section=windows","rel":["nofollow"]},"children":[{"type":"text","value":"官网下载IDEA 2022.2.1"}]}]},{"type":"element","tag":"h2","props":{"id":"下载ja-netfilter"},"children":[{"type":"text","value":"下载ja-netfilter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html","rel":["nofollow"]},"children":[{"type":"text","value":"作者博客"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"找最新版本的release下载即可"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gitee.com/ja-netfilter/ja-netfilter/releases","rel":["nofollow"]},"children":[{"type":"text","value":"下载地址"}]}]},{"type":"element","tag":"h2","props":{"id":"使用ja-netfilter"},"children":[{"type":"text","value":"使用ja-netfilter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将下载好的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ja-netfilter"}]},{"type":"text","value":"解压到磁盘，最好不要有空格，注意文件后期不能删除，所以请放在自己不会清理的位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解压后是这样："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-19-rider-po-jie/2084018-20220904174636805-1072454980.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解压后在ja-netfilter.jar同目录下应该会有一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"config"}]},{"type":"text","value":"文件夹，找到里面的几个配置文件进行修改。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-19-rider-po-jie/2084018-20220904230435240-2001741988.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"修改dnsconf"},"children":[{"type":"text","value":"修改dns.conf"}]},{"type":"element","tag":"pre","props":{"className":["language-ini"],"code":"[DNS]\nEQUAL,jetbrains.com\n","language":"ini","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[DNS]\nEQUAL,jetbrains.com\n"}]}]},{"type":"element","tag":"h3","props":{"id":"修改urlconf"},"children":[{"type":"text","value":"修改url.conf"}]},{"type":"element","tag":"pre","props":{"className":["language-ini"],"code":"[URL]\nPREFIX,https://dbeaver.com/lmp/checkLicense\nPREFIX,https://store.smartgit.com/check\nPREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action\n","language":"ini","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[URL]\nPREFIX,https://dbeaver.com/lmp/checkLicense\nPREFIX,https://store.smartgit.com/check\nPREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action\n"}]}]},{"type":"element","tag":"h2","props":{"id":"修改idea-vmoption文件"},"children":[{"type":"text","value":"修改IDEA VMOPTION文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"找到IDEA安装目录,再进入bin目录，找到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"idea64.exe.vmoptions"}]},{"type":"text","value":"文件，在最后一行添加"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-19-rider-po-jie/2084018-20220904174024356-819045091.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-x86asm"],"code":"-javaagent:D:\\\\Tools\\\\ja-netfilter\\\\ja-netfilter.jar=jetbrains\n","language":"x86asm","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-javaagent:D:\\\\Tools\\\\ja-netfilter\\\\ja-netfilter.jar=jetbrains\n"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此处需要根据你自己解压的路径去修改，路径中的斜杠使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\\\\"}]},{"type":"text","value":"或者"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/"}]},{"type":"text","value":"，建议路径中不要包含空格。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"完整的文件内容应该是这样的"}]},{"type":"element","tag":"pre","props":{"className":["language-diff"],"code":"-Xms128m\n-Xmx750m\n-XX:ReservedCodeCacheSize=512m\n-XX:+UseG1GC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-XX:CICompilerCount=2\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n-XX:+IgnoreUnrecognizedVMOptions\n-ea\n-Dsun.io.useCanonCaches=false\n-Dsun.java2d.metal=true\n-Djdk.http.auth.tunneling.disabledSchemes=\"\"\n-Djdk.attach.allowAttachSelf=true\n-Djdk.module.illegalAccess.silent=true\n-Dkotlinx.coroutines.debug=off\n-javaagent:D:\\\\Tools\\\\ja-netfilter\\\\ja-netfilter.jar=jetbrains\n","language":"diff","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-Xms128m\n-Xmx750m\n-XX:ReservedCodeCacheSize=512m\n-XX:+UseG1GC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-XX:CICompilerCount=2\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n-XX:+IgnoreUnrecognizedVMOptions\n-ea\n-Dsun.io.useCanonCaches=false\n-Dsun.java2d.metal=true\n-Djdk.http.auth.tunneling.disabledSchemes=\"\"\n-Djdk.attach.allowAttachSelf=true\n-Djdk.module.illegalAccess.silent=true\n-Dkotlinx.coroutines.debug=off\n-javaagent:D:\\\\Tools\\\\ja-netfilter\\\\ja-netfilter.jar=jetbrains\n"}]}]},{"type":"element","tag":"h2","props":{"id":"激活idea"},"children":[{"type":"text","value":"激活IDEA"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"打开IDEA，IDEA会提示你激活，选择输入激活码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"打开这个网站 "},{"type":"element","tag":"a","props":{"href":"https://3.jetbra.in/","rel":["nofollow"]},"children":[{"type":"text","value":"https://3.jetbra.in/"}]},{"type":"text","value":" 等待片刻，选择一个可以访问的网站，然后找到IDEA的卡片选择复制激活码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-11-19-rider-po-jie/2084018-20220904173657931-1850766616.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"填入到IDEA中，点击激活就完成了，不需要关心激活到期时间。"}]},{"type":"element","tag":"h2","props":{"id":"常见问题"},"children":[{"type":"text","value":"常见问题"}]},{"type":"element","tag":"h3","props":{"id":"idea提示激活码无效-invalid-key"},"children":[{"type":"text","value":"IDEA提示激活码无效 Invalid key"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果有登录账号，可以先退出账号试试，再不行就重装IDEA，我就是这么做的。"}]},{"type":"element","tag":"h3","props":{"id":"idea无法启动-运行无反应"},"children":[{"type":"text","value":"IDEA无法启动 运行无反应"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看看任务管理器有没有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"idea64.exe"}]},{"type":"text","value":"这个进程，有就把它关了。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"背景","depth":2,"text":"背景"},{"id":"下载idea","depth":2,"text":"下载IDEA"},{"id":"下载ja-netfilter","depth":2,"text":"下载ja-netfilter"},{"id":"使用ja-netfilter","depth":2,"text":"使用ja-netfilter","children":[{"id":"修改dnsconf","depth":3,"text":"修改dns.conf"},{"id":"修改urlconf","depth":3,"text":"修改url.conf"}]},{"id":"修改idea-vmoption文件","depth":2,"text":"修改IDEA VMOPTION文件"},{"id":"激活idea","depth":2,"text":"激活IDEA"},{"id":"常见问题","depth":2,"text":"常见问题","children":[{"id":"idea提示激活码无效-invalid-key","depth":3,"text":"IDEA提示激活码无效 Invalid key"},{"id":"idea无法启动-运行无反应","depth":3,"text":"IDEA无法启动 运行无反应"}]}]}},"_type":"markdown","_id":"content:tool:2022-11-19-rider-po-jie.md","_source":"content","_file":"tool/2022-11-19-rider-po-jie.md","_extension":"md","date":"2022-11-19"},{"_path":"/tool/2023-01-20-stable-diffusion-install","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"stable diffusion install","description":"硬體需求根據 StableDiffusion 官網 所寫，只要有 6G 以上 RAM 的 NVidia 顯卡都可以跑。不過根據 jimmy 實測，4G 的 1050ti 就可以順利運行了。(在我們這次使用的網頁介面實作項目 AUTOMATIC1111/stable-diffusion-webui 裡提到，2G 也有成功運行的報告)安裝步驟1. 下載並安裝 github for windows這裡我們用 Windows 平台為範例來說明。\n首先到 https://gitforwindows.org 下載 git for windows，並安裝。 ( 安裝過程中可取消與 Windows Explo","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"硬體需求"},"children":[{"type":"text","value":"硬體需求"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根據 "},{"type":"element","tag":"a","props":{"href":"https://stability.ai/faq","rel":["nofollow"]},"children":[{"type":"text","value":"StableDiffusion 官網"}]},{"type":"text","value":" 所寫，只要有 6G 以上 RAM 的 NVidia 顯卡都可以跑。不過根據 jimmy 實測，4G 的 1050ti 就可以順利運行了。(在我們這次使用的網頁介面實作項目 "},{"type":"element","tag":"a","props":{"href":"https://github.com/AUTOMATIC1111/stable-diffusion-webui","rel":["nofollow"]},"children":[{"type":"text","value":"AUTOMATIC1111/stable-diffusion-webui"}]},{"type":"text","value":" 裡提到，2G 也有成功運行的報告)"}]},{"type":"element","tag":"h2","props":{"id":"安裝步驟"},"children":[{"type":"text","value":"安裝步驟"}]},{"type":"element","tag":"h3","props":{"id":"_1-下載並安裝-github-for-windows"},"children":[{"type":"text","value":"1. 下載並安裝 github for windows"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這裡我們用 Windows 平台為範例來說明。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n首先到 "},{"type":"element","tag":"a","props":{"href":"https://gitforwindows.org/","rel":["nofollow"]},"children":[{"type":"text","value":"https://gitforwindows.org"}]},{"type":"text","value":" 下載 git for windows，並安裝。 ( 安裝過程中可取消與 Windows Exploer 整合 )"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-01-20-stable-diffusion-install/gitInstall.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安裝前可以取消 Windows Explorer integration"}]},{"type":"element","tag":"h3","props":{"id":"_2-下載並安裝-python"},"children":[{"type":"text","value":"2. 下載並安裝 Python"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a. 到 "},{"type":"element","tag":"a","props":{"href":"https://www.python.org/downloads/release/python-3106","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.python.org/downloads/release/python-3106"}]},{"type":"text","value":" 下載 Windows installer (64-bit) 版本"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"(這兩天 Python 的版本更新到了 3.11.0，但 AUTOMATIC1111 表示這個程式是基於 3.10.6 版開發的，除非你想給自己找麻煩，否則請不要使用其他版本 )"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nb. 安裝時記得勾選 Add Python.exe to PATH"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-01-20-stable-diffusion-install/pythonInstall.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"記得要把 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Add python.exe to PATH"}]},{"type":"text","value":" 打勾"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设置pip源（一定要设置清华大学的，阿里的有点问题）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更新pip"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"python -m pip install --upgrade pip"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-01-20-stable-diffusion-install/1676391305000.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"_3-下载模型"},"children":[{"type":"text","value":"3. 下载模型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"经过测试目前sd2.0只有以下两种模型可以用 ，其他模型加载都会报错，github上看了issue上大家都有遇到这个问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"768-v-ema.ckpt"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个模型需要生成的图片在768"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"768的时候效果比较好，如果是生成512"}]},{"type":"text","value":"512的，图片有点拉垮；"}]},{"type":"element","tag":"pre","props":{"code":"# 768-v-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2/resolve/main/768-v-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt\n# 配置文件（下载以后注意把文件名修改为768-v-ema.yaml）\nhttps://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/v2-inference-v.yaml\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 768-v-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2/resolve/main/768-v-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt\n# 配置文件（下载以后注意把文件名修改为768-v-ema.yaml）\nhttps://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/v2-inference-v.yaml\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"512-base-ema.ckpt"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果显存不够的，比较小的，可以使用这个模型；比较推荐768，效果比512的好；"}]},{"type":"element","tag":"pre","props":{"code":"# 512-base-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2-base/resolve/main/512-base-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2-1-base/resolve/main/v2-1_512-ema-pruned.ckpt\n# 配置文件（下载以后注意把文件名修改为512-base-ema.yaml）\nhttps://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/v2-inference.yaml\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 512-base-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2-base/resolve/main/512-base-ema.ckpt\nhttps://huggingface.co/stabilityai/stable-diffusion-2-1-base/resolve/main/v2-1_512-ema-pruned.ckpt\n# 配置文件（下载以后注意把文件名修改为512-base-ema.yaml）\nhttps://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/v2-inference.yaml\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安装模型"}]},{"type":"element","tag":"pre","props":{"code":"git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git\ncd stable-diffusion-webui\n./venv/Scripts/python.exe -m pip install --upgrade pip\ncd models/Stable-diffusion/\nInvoke-WebRequest -Uri https://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/v2-inference-v.yaml -OutFile ./v2-1_768-ema-pruned.yaml\nInvoke-WebRequest -Uri https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt -OutFile ./v2-1_768-ema-pruned.ckpt\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git\ncd stable-diffusion-webui\n./venv/Scripts/python.exe -m pip install --upgrade pip\ncd models/Stable-diffusion/\nInvoke-WebRequest -Uri https://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/v2-inference-v.yaml -OutFile ./v2-1_768-ema-pruned.yaml\nInvoke-WebRequest -Uri https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt -OutFile ./v2-1_768-ema-pruned.ckpt\n"}]}]},{"type":"element","tag":"h3","props":{"id":"_4-正式安裝-stable-diffusion"},"children":[{"type":"text","value":"4. 正式安裝 Stable Diffusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在国外，安装Stable Diffusion比较简单，但是由于国内的网络环境，安装过程中可能会遇上不少麻烦。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"编辑“launch.py”（此处我是用的是Visual Studio Code，Linux则需要用到特定的文本编辑器）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"code .\\launch.py"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"替换前"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-01-20-stable-diffusion-install/1676396613000.png"},"children":[]},{"type":"text","value":"替换所有的“"},{"type":"element","tag":"a","props":{"href":"https://github.com%E2%80%9D%E4%B8%BA%E2%80%9Chttps://ghproxy.com/https://github.com%E2%80%9D%E3%80%82%E8%BF%99%E9%87%8C%E4%B9%9F%E6%98%AF%E5%88%A9%E7%94%A8Ghproxy%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%9B%BD%E5%86%85Git%E3%80%82","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com”为“https://ghproxy.com/https://github.com”。这里也是利用Ghproxy进行代理，加速国内Git。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-01-20-stable-diffusion-install/1676396580000.png"},"children":[]},{"type":"text","value":"替换完成后注意保存。"}]},{"type":"element","tag":"pre","props":{"code":"cd ../../\n//修改webui-user.bat 设置启动参数,会自动安装 xformers\nset COMMANDLINE_ARGS=--share --xformers --enable-insecure-extension-access --api --precision full --no-half --medvram \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"cd ../../\n//修改webui-user.bat 设置启动参数,会自动安装 xformers\nset COMMANDLINE_ARGS=--share --xformers --enable-insecure-extension-access --api --precision full --no-half --medvram \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-01-20-stable-diffusion-install/1676428686000.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"参数解释"},"children":[{"type":"text","value":"参数解释"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"xformers：优化显存占用情况的插件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"precision full和no-half：完全精度和非半精度，也就是使用32位浮点运算而不是使用16位浮点运算，开启这两个参数会让显存占用增加，但图的质量会更好，但是cpu和16XX显卡必须开启，不然黑图或者绿图"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"lowvram和medvram  低内存和中内存"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"share 会生成一个供外部访问的链接"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"api 启动api,主要是供插件使用"}]}]},{"type":"element","tag":"h3","props":{"id":"当前遇到的问题"},"children":[{"type":"text","value":"当前遇到的问题"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"modules.devices.NansException: A tensor with all NaNs was produced in Unet. This could be either because there's not enough precision to represent the picture, or because your video card does not support half type. Try setting the \"Upcast cross attention layer to float32\" option in Settings > Stable Diffusion or using the --no-half commandline argument to fix this. Use --disable-nan-check commandline argument to disable this check."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"if you plan to use SD 2.1 models, you go to Settings -> User Interface and set Quicksettings list to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sd_model_checkpoint, upcast_attn"}]},{"type":"text","value":" then click Apply settings and Reload UI. This adds a checkbox (Upcast cross attention layer to float32) next to the model dropdown that should be checked whenever using SD 2.1 models. Uncheck it after you load a model that is not SD 2.1 based."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"硬體需求","depth":2,"text":"硬體需求"},{"id":"安裝步驟","depth":2,"text":"安裝步驟","children":[{"id":"_1-下載並安裝-github-for-windows","depth":3,"text":"1. 下載並安裝 github for windows"},{"id":"_2-下載並安裝-python","depth":3,"text":"2. 下載並安裝 Python"},{"id":"_3-下载模型","depth":3,"text":"3. 下载模型"},{"id":"_4-正式安裝-stable-diffusion","depth":3,"text":"4. 正式安裝 Stable Diffusion"},{"id":"参数解释","depth":3,"text":"参数解释"},{"id":"当前遇到的问题","depth":3,"text":"当前遇到的问题"}]}]}},"_type":"markdown","_id":"content:tool:2023-01-20-stable-diffusion-install.md","_source":"content","_file":"tool/2023-01-20-stable-diffusion-install.md","_extension":"md","date":"2023-01-20"},{"_path":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","description":"在学习 Python Web 开发时候，可能会遇到诸如 uwsgi、wsgi 等名词，下面通过梳理总结，探究它们之间的关系。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在学习 Python Web 开发时候，可能会遇到诸如 uwsgi、wsgi 等名词，下面通过梳理总结，探究它们之间的关系。"}]},{"type":"element","tag":"h3","props":{"id":"cgi"},"children":[{"type":"text","value":"CGI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CGI（Common Gateway Interface）通用网关接口，是一个协议，是外部应用程序（CGI 程序）与 Web 服务器之间的接口标准，该协议定义了 Web 服务器调用外部应用程序的时候需要输入的参数，和给 Web 服务器的返回结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通俗来说，它规定一个程序该如何与 Web 服务器程序之间通信，从而可以让这个程序跑在 Web 服务器上。"}]},{"type":"element","tag":"h3","props":{"id":"起源"},"children":[{"type":"text","value":"起源"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最早的 Web 服务器简单地响应浏览器发来的 HTTP 请求，并将存储在服务器上的 HTML 文件返回给浏览器，也就是静态 HTML。这个场景下的服务器一般被称为 HTTP 服务器，常见的有 Apache 的 httpd 和 Nginx。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"事物总是不 断发展，网站也越来越复杂，所以出现动态技术。但是服务器并不能直接运行 php、asp这样的文件，自己不能做，外包给别人吧，但是要与第三做个约定，我给你什么，然后你给我什么，就是握把请求参数发送给你，然后我接收你的处 理结果给客户端。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那这个约定就是 Common Gateway Interface，简称 CGI。这个协议可以用 VB、C、PHP、Python 来实现。CGI只是接口协议，根本不是什么语言。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/c75c10385343fbf28d11e6289721428965388f60.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"引入 CGI 以便客户端请求能够触发 Web 服务器运行另一个外部程序，客户端所输入的数据也会传给这个外部程序，该程序运行结束后会将生成的 HTML 和其他数据通过 Web 服务器再返回给客户端（即动态请求，比如基于 PHP、Python、Java 实现的应用）。利用 CGI 可以针对用户请求，动态返回给客户端各种各样动态变化的信息。"}]},{"type":"element","tag":"h3","props":{"id":"工作原理"},"children":[{"type":"text","value":"工作原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Web 服务器与 CGI 程序的交互"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Web 服务器将根据 CGI 程序的类型决定数据向 CGI 程序的传送方式，一般是通过标准输入/输出流和环境变量来与 CGI 程序间传递数据。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/6159252dd42a28343479a71f7cea41e314cebfab.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CGI 程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外 CGI 程序还通过环境变量来得到输入，操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。Web 服务器和 CGI 接口又另外设置了一些环境变量，用来向 CGI 程序传递一些重要的参数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"常用 CGI 环境变量："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/b03533fa828ba61ef7e05521636b1f03304e591e.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当客户请求 CGI 的时候，WEB服务器就请求操作系统生成一个新的CGI解释器进程（如 php-cgi.exe），CGI 的一个进程则处理完一个请求后退出，下一个请求来时再创建新进程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然，这样在访问量很少没有并发的情况也行。但当访问量增大，并发存在，这种方式就不适合了，于是就有了FastCGI"}]},{"type":"element","tag":"h3","props":{"id":"fastcgi"},"children":[{"type":"text","value":"FastCGI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FASTCGI 是 Web 服务器（ex:Nginx）和语言解释器（ex:uWsgi）两者底层的通信协议的规范，是对CGI的开放的扩展。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CGI的一个扩展，像是一个常驻（long-live）型的CGI ，废除了 CGI fork-and-execute （来一个请求 fork 一个新进程处理，处理完再把进程 kill 掉）的工作方式，转而使用一种长生存期的方法，减少了进程消耗，提升了性能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而FastCGI 则会先 fork 一个 master 进程，解析配置文件，初始化执行环境，然后再 fork 多个 worker 进程（与 Nginx 有点像），当 HTTP 请求过来时，master 进程将其会传递给一个 worker 进程，然后立即可以接受下一个请求，这样就避免了重复的初始化操作，效率自然也就提高了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而且当 worker 进程不够用时，master 进程还可以根据配置预先启动几个 worker 进程等着；当空闲 worker 进程太多时，也会关掉一些，这样不仅提高了性能，还节约了系统资源"}]},{"type":"element","tag":"h3","props":{"id":"php-fpm"},"children":[{"type":"text","value":"php-fpm"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FastCGI 只是一个协议规范，需要每个语言具体去实现，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"PHP-FPM 就是 PHP 版本的 FastCGI 协议实现"}]},{"type":"text","value":"，有了它，就是实现 PHP 脚本与 Web 服务器（通常是 Nginx）之间的通信，同时它也是一个 PHP SAPI，从而构建起 PHP 解释器与 Web 服务器之间的桥梁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Php-fpm全称是php fastcgi process manager即php fastcgi进程管理器，相比fastcgi静态的唤起cgi，fpm能根据访问的压力动态的唤起cgi进程和销毁以到达动态的调整cgi数量，这样可以有效的使用内存。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除此之外还有其它的一些优点，比如，fpm还可以平滑的重载php配置；由于fpm是使用Unix-Socket来和服务器通讯，所以也不用再配置cgi端口；fpm有更好的状态输出和slowlog日志，502的时候能给出更多的错误细节。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/3812b31bb051f819133af1d2fdebc2e42f73e7f0.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PHP-FPM 负责管理一个进程池来处理来自 Web 服务器的 HTTP 动态请求，在 PHP-FPM 中，master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程进行处理，worker 进程主要负责动态执行 PHP 代码，处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。这就是 PHP-FPM 的基本工作原理"}]},{"type":"element","tag":"h3","props":{"id":"wsgi-uwsgi-uwsgi"},"children":[{"type":"text","value":"WSGI / uwsgi / uWSGI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Python Web 开发中，我们经常使用 Uwsgi 配合 Nginx 部署一个 Web 框架，如 Django 或 flask。同时我们又会说，框架和 Web 服务器之间要符合 WSGI 协议。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那就来厘清一下这几个概念。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Web 服务器和 Web框架"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在讲 uWSGI 和 WSGI 之前，先要弄清楚 Web 开发的两大块，Web服务器和Web框架。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Web服务器即用来接受客户端请求，建立连接，转发响应的程序。至于转发的内容是什么，交由Web框架来处理，即处理这些业务逻辑。如查询数据库、生成实时信息等。Nginx就是一个Web服务器，Django或flask就是Web框架。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么如何实现uWSGI和WSGI的配合呢？如何做到任意一个Web服务器，都能搭配任意一个框架呢？这就产生了WSGI协议。只要Web服务器和Web框架满足WSGI协议，它们就能相互搭配。所以WSGI只是一个协议，一个约定。而不是Python的模块、框架等具体的功能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而uWSGI，则是实现了WSGI协议的一个Web服务器。即用来接受客户端请求，转发响应的程序。实际上，一个uWSGI的Web服务器，再加上Django这样的Web框架，就已经可以实现网站的功能了。"}]},{"type":"element","tag":"h3","props":{"id":"wsgi"},"children":[{"type":"text","value":"WSGI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WSGI，（WEB SERVER GATEWAY INTERFACE），Web服务器网关接口，是一种Web服务器网关接口，它是一个Web服务器（如Nginx，uWSGI等服务器）与Web应用（如Flask框架写的程序）通信的一种规范。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"当前运行在WSGI协议之上的Web框架有Bottle，Flask，Django"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现了Python Web程序与服务器之间交互的通用性。有了这个东西，web.py或者bottle或者django等等的Python Web开发框架，就可以轻松地部署在不同的Web server上了，不需要做任何特殊配置（也需要一些小小的配置调整）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/00e93901213fb80ea214ae5d158ea727bb3894d8.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和application组合实现自己的Web应用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如 uWSGI和 Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的Web框架，可以根据项目实际情况搭配使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"像Django，Flask框架都有自己实现的简单的WSGI server，一般用于服务器调试，生产环境下建议用其他WSGI server，WSGI服务器的选择很多，包括uWSGI和gunicorn"}]},{"type":"element","tag":"h3","props":{"id":"uwsgi"},"children":[{"type":"text","value":"uwsgi"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同WSGI一样是一种通信协议"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。"}]},{"type":"element","tag":"h3","props":{"id":"uwsgi-服务器"},"children":[{"type":"text","value":"uWSGI (服务器)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。用于接收前端服务器转发的动态请求并处理后发给 Web 应用程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为apache也好，Nginx也罢，它们自己都没有解析动态语言如php的功能，而是分派给其他模块来做，比如apache就可以说内置了php模块，支持的非常爽，让人感觉好像apache就支持php一样。uwsgi实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"uWSGI是使用C编写的，显示了自有的uwsgi协议的Web服务器。它自带丰富的组件，其中核心组件包含进程管理、监控、IPC等功能，实现应用服务器接口的请求插件支持多种语言和平台，比如WSGI、Rack、Lua WSAPI，网管组件实现了负载均衡、代理和理由功能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"uWSGI也可以当做中间件。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果是Nginx+uWSGI+App，那uWSGI就是一个中间件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果是uWSGI+App，那它就是服务器"}]}]},{"type":"element","tag":"h3","props":{"id":"nginxuwgsi"},"children":[{"type":"text","value":"Nginx+uWGSI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设我们使用 Python 的 Django 框架写了一个网站，现在要将它挂在网上运行，我们一般需要："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Nginx 做为代理服务器：负责静态资源发送（js、css、图片等）、动态请求转发以及结果的回复。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"uWSGI 做为后端服务器：负责接收 Nginx 转发的请求并处理后发给 Django 应用以及接收 Django 应用返回信息转发给 Nginx。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Django 应用收到请求后处理数据并渲染相应的返回页面给 uWSGI 服务器。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/35a85edf8db1cb1373f2b22aff0bde4793584bdc.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个Django应用，通过WSGI协议连接uWSGI服务器，uWSGI服务器实现WSGI、http等协议，通过uwsgi协议和Nginx服务器实现http的动态请求和转发以及结果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"问题：有 uWGSI 了，Django 为什么还需要 Nginx？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个普通的个人网站，访问量不大的话，当然可以由 uWSGI 和 Django 构成。但是一旦访问量过大，客户端请求连接就要进行长时间的等待。这个时候就出来了分布式服务器，我们可以多来几台 Web 服务器，都能处理请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是谁来分配客户端的请求连接和 Web 服务器呢？Nginx 就是这样一个管家的存在，由它来分配。这也就是由 Nginx 实现反向代理，即代理服务器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2023-02-15-cgi-fastcgi-wsgi-uswgi/f2deb48f8c5494ee428402900faa68f798257e79.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Nginx 是一个 HTTP 和反向代理服务器"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"正向代理：正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"反向代理：反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用Nginx作为反向代理服务器的好处："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"安全"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不管什么请求都要经过代理服务器，可以避免外部程序直接攻击Web服务器"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"负载均衡"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据请求情况和服务器负载情况，将请求分配给不同的Web服务器，保证服务器性能"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"提高Web服务器的IO性能"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请求从客户端传到Web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以由反向代理完整接受该请求，然后再传给Web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过Web服务器"}]},{"type":"element","tag":"h3","props":{"id":"总结"},"children":[{"type":"text","value":"总结"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"WSGI是一种通信协议"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"uwsgi是一种通信协议，常用于在uWSGI服务器与其他网络服务器的数据通信"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"百度百科上说uwsgi是一种线路协议而不是通信协议，个人更倾向于uwsgi是类似WSGI的通信协议的说法，uwsgi和WSGI都是基于CGI扩展出来的。"}]},{"type":"element","tag":"h3","props":{"id":"asgi"},"children":[{"type":"text","value":"ASGI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"异步网关协议接口"}]},{"type":"text","value":"，一个介于网络协议服务和Python应用之间的标准接口，能够处理多种通用的协议类型，包括HTTP，HTTP2和WebSocket。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然而目前的常用的WSGI主要是针对HTTP风格的请求响应模型做的设计，并且越来越多的不遵循这种模式的协议逐渐成为Web变成的标准之一，例如WebSocket。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ASGI尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意的时候、被任意应用进程发送和接受的抽象。并且同样描述了一个新的，兼容HTTP请求响应以及WebSocket数据帧的序列格式。允许这些协议能通过网络或本地socket进行传输，以及让不同的协议被分配到不同的进程中。"}]},{"type":"element","tag":"h3","props":{"id":"wsgi和asgi的区别"},"children":[{"type":"text","value":"WSGI和ASGI的区别"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WSGI是基于HTTP协议模式的，不支持WebSocket，而ASGI的诞生则是为了解决Python常用的WSGI不支持当前Web开发中的一些新的协议标准。同时，ASGI对于WSGI原有的模式的支持和WebSocket的扩展，即ASGI是WSGI的扩展。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"cgi","depth":3,"text":"CGI"},{"id":"起源","depth":3,"text":"起源"},{"id":"工作原理","depth":3,"text":"工作原理"},{"id":"fastcgi","depth":3,"text":"FastCGI"},{"id":"php-fpm","depth":3,"text":"php-fpm"},{"id":"wsgi-uwsgi-uwsgi","depth":3,"text":"WSGI / uwsgi / uWSGI"},{"id":"wsgi","depth":3,"text":"WSGI"},{"id":"uwsgi","depth":3,"text":"uwsgi"},{"id":"uwsgi-服务器","depth":3,"text":"uWSGI (服务器)"},{"id":"nginxuwgsi","depth":3,"text":"Nginx+uWGSI"},{"id":"总结","depth":3,"text":"总结"},{"id":"asgi","depth":3,"text":"ASGI"},{"id":"wsgi和asgi的区别","depth":3,"text":"WSGI和ASGI的区别"}]}},"_type":"markdown","_id":"content:tool:2023-02-15-cgi-fastcgi-wsgi-uswgi.md","_source":"content","_file":"tool/2023-02-15-cgi-fastcgi-wsgi-uswgi.md","_extension":"md","date":"2023-02-15"},{"_path":"/unity/2019-06-20-unity-android-x64","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity 导出 Android 64-bit 版本","description":"导出说明Unity supports x64 since 2017 LTS. To enable it you can go to File > Build Settings > Player Settings.There under \"Other Settings\" you have to change your Script Backend to IL2CPP, and you will have the ARM64 checkbox active. Check it.And then you can either select to generate Split APKs by Targ","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"导出说明"},"children":[{"type":"text","value":"导出说明"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity supports x64 since 2017 LTS. To enable it you can go to File > Build Settings > Player Settings."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There under \"Other Settings\" you have to change your Script Backend to IL2CPP, and you will have the ARM64 checkbox active. Check it."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-06-20-unity-android-x64/2019-06-20-04-48-21.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"And then you can either select to generate Split APKs by Target Architecture"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-06-20-unity-android-x64/2019-06-20-04-48-48.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"or in your Build Settings dialog choose to Build App Bundle (Google Play)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-06-20-unity-android-x64/2019-06-20-04-49-44.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hope it helps, you will need to have the Android NDK for this."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果选择Build ，Unity会生成AAB文件，该文件可以直接发布到Google Play。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果选择Build and Run，Unity会生成AAB文件，该文件会为关联设备生成临时APK文件，然后安装APK文件到设备并运行应用程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果选择Build 并希望手动安装应用程序到设备上，可以使用Google提供的bundletool utility ,你可在Unity安装目录中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Editor/Data/PlaybackEngines/AndroidPlayer/Tools"}]},{"type":"text","value":"目录下找到它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请注意，当构建应用程序包时，菜单"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Edit > Setting > Player"}]},{"type":"text","value":"下的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Split APKs by target architecture"}]},{"type":"text","value":" 会被禁用，因为生成的应用程序包应包含所有支持目标的库。"}]},{"type":"element","tag":"h2","props":{"id":"使用技巧"},"children":[{"type":"text","value":"使用技巧"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在开发期间，为了减少使用构建和运行时的迭代次数，可以禁用应用程序包的生成功能，并使用常规的APK文件，因为从应用程序包生成APK需要额外时间，之后才会部署到设备上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"应用程序包还可以从Android Studio生成，它使用从Unity导出的Gradle项目。为此，你需要使用Android Studio 3.2或更高版本，并选择"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Build > Build Bundle(s) / APK(s) > Build Bundle(s)"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果目标商店不支持Android App Bundles，你可以使用Player settings中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Split APKs by target architecture"}]},{"type":"text","value":"选项，从而根据终端用户设备的CPU架构提供APK文件，或使用bundletool，该工具可以构建支持运行在任何环境的“通用APK”文件"}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://connect.unity.com/p/unity-2018-3-betazhong-de-android-app-bundle-aab-zhi-chi","rel":["nofollow"]},"children":[{"type":"text","value":"https://connect.unity.com/p/unity-2018-3-betazhong-de-android-app-bundle-aab-zhi-chi"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"导出说明","depth":2,"text":"导出说明"},{"id":"使用技巧","depth":2,"text":"使用技巧"},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:unity:2019-06-20-unity-android-x64.md","_source":"content","_file":"unity/2019-06-20-unity-android-x64.md","_extension":"md","date":"2019-06-20"},{"_path":"/unity/2019-06-20-unity-il2cpp-debugger","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity的il2cpp","description":"unity是运行在mono下的,il2cpp有自己的运行时,il2cpp不是运行在mono下的不是mono的aotmono的gc和.net的gc是不同的,il2cpp运行时实现了自己的垃圾回收(Boehm-Demers-Weiser garbage collector)编译和运行时是两个阶段,可以用csc.exe编译然后运行在mono上, .NET 4.x可以使用就是这个原理Note that the .rsp file needs to match the compiler being invoked. For example:when targeting the .NET 3.5 Equi","body":{"type":"root","children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"unity是运行在mono下的,il2cpp有自己的运行时,il2cpp不是运行在mono下的不是mono的aot"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"mono的gc和.net的gc是不同的,il2cpp运行时实现了自己的垃圾回收(Boehm-Demers-Weiser garbage collector)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"编译和运行时是两个阶段,可以用csc.exe编译然后运行在mono上, .NET 4.x可以使用就是这个原理"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"Note that the "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":".rsp"}]},{"type":"text","value":" file needs to match the compiler being invoked. For example:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"when targeting the .NET 3.5 Equivalent (deprecated) scripting runtime version, "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"mcs"}]},{"type":"text","value":" is used with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"mcs.rsp"}]},{"type":"text","value":", and"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"when targeting the .NET 4.x Eqivalent scripting runtime version compiler, "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"csc"}]},{"type":"text","value":" is used with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"csc.rsp"}]},{"type":"text","value":"."}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大约在一年以前，我们写了一篇博客讨论Unity中脚本将来会是个什么样子，在那篇博客中我们提到了崭新的IL2CPP后端，并许诺其会为Unity带来更高效和更适合于各个平台的虚拟机。在2015年的一月份，我们正式发布了第一个使用IL2CPP的平台：iOS 64-bit。而随着Unity 5的发布，又带给大家另一个使用IL2CPP的平台：WebGL。感谢我们社区中用户的大量宝贵的反馈，我们在接下来的时间里根据这些反馈得以更新IL2CPP，发布补丁版本，从而持续的改进IL2CPP的编译器和运行时库。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们没有停止改进IL2CPP的打算，但是在目前这个时间点上，我们觉得可以回过头来抽出点时间告诉大家一些IL2CPP的内部工作机制。在接下来的几个月的时间里，我们打算对以下话题（或者还有其他未列出的话题）进行讨论，来做一个IL2CPP深入讲解系列。目前准备讨论的话题有："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.基础 - 工具链和命令行参数（本篇博文）\n2.IL2CPP生成代码介绍\n3.IL2CPP生成代码调试小窍门\n4.方法调用介绍（一般方法调用和虚方法调用等）"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通用代码共享的实现\n6.P/invoke(Platform Invocation Service)对于类型（types）和方法（methods）的封装\n7.垃圾回收器的集成\n8.测试框架（Testing frameworks）及其使用"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了能让这个系列的讨论成为可能，我们会涉及到一些将来肯定会进行改动的IL2CPP的实现细节。但这也没有关系，通过这些讨论，我们希望能给大家提供一些有用和有趣的信息。"}]},{"type":"element","tag":"h2","props":{"id":"什么是il2cpp"},"children":[{"type":"text","value":"什么是IL2CPP？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从技术层面上来说，我们说的IL2CPP包含了两部分：一个进行 预先编译（译注：ahead-of-time，又叫AOT，以下一律使用AOT缩写）的编译器。"}]},{"type":"element","tag":"h2","props":{"id":"一个支持虚拟机的运行时库"},"children":[{"type":"text","value":"一个支持虚拟机的运行时库"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOT编译器将由.NET 输出的中间语言(IL)代码生成为C++代码。运行时库则提供诸如垃圾回收，与平台无关的线程，IO以及内部调用（C++原生代码直接访问托管代码结构）这样的服务和抽象层。"}]},{"type":"element","tag":"h2","props":{"id":"aot编译器"},"children":[{"type":"text","value":"AOT编译器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL2CPP AOT编译器实际的执行文件是il2cpp.exe。在Windows平台你可以在Unity安装路径的Editor\\Data\\il2cpp目录下找到。对于OSX平台，它位于Unity安装路径的Contents/Frameworks/il2cpp/build目录内。 il2cpp.exe这个工具是一个托管代码可执行文件，其完全由C#写成。在开发IL2CPP的过程中，我们同时使用.NET和Mono编译器对其进行编译。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"il2cpp 接受来自Unity自带的或者由Mono编译器产生的托管程序集，将这些程序集转换成C++代码。这些转换出的C++代码最终由部署目标平台上的C++编译器进行编译。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以参照下图理解IL2CPP工具链的作用："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"il2cpp toolchain smaller","src":"/images/2019-06-20-unity-il2cpp-debugger/il2cpp-toolchain-smaller.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"运行时库"},"children":[{"type":"text","value":"运行时库"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL2CPP的另外一个部分就是对虚拟机提供支持的运行时库。我们基本上是用C++代码来实现整个运行时库的（好吧，其实里面还是有一些和平台相关的代码使用了程序集，这个只要你知我知便好，不要告诉别人 ）。我们把运行时库称之为libli2cpp，它是作为一个静态库被连接到最终的游戏可执行文件中。这么做的一个主要的好处是可以使得整个IL2CPP技术是简单并且是可移植的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你能通过查看随Unity一起发布的libil2cpp头文件来窥探其代码组织方式（Windows平台，头文件在Editor\\Data\\PlaybackEngines\\webglsupport\\BuildTools\\Libraries\\libil2cpp\\include目录中。OSX平台，头文件在Contents/Frameworks/il2cpp/libil2cpp目录中）。举个例子，由il2cpp产生的C++代码和libil2cpp之间的接口API，存在于codegen/il2cpp-codegen.h这个文件中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"运行时的另外一个重要的部分，就是垃圾收集器。在Unity 5中，我们使用libgc垃圾收集器。它是一个典型的贝姆垃圾收集器（Boehm-Demers-Weiser garbage collector）。（译注：相对使用保守垃圾回收策略）。然而我们的libil2cpp被设计成可以方便使用其他垃圾回收器。因此我们现在也在研究集成微软开源的垃圾回收器（Microsoft GC）。对于垃圾回收器这一点，我们会在后续的一篇中专门的讨论，这里就不多说了。"}]},{"type":"element","tag":"h2","props":{"id":"il2cpp是如何执行的"},"children":[{"type":"text","value":"il2cpp是如何执行的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们从一个简单的例子入手。这里使用Unity的版本是5.0.1，在Windows环境并且建立一个全新的空项目。然后创建一个带MonoBehaviour的脚本文件，将其作为组件加入到Main Camera上。代码也是非常的简单，输出Hello World："}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\n\npublic class HelloWorld : MonoBehaviour {\n  void Start () {\n    Debug.Log(\"Hello, IL2CPP!\");\n  }\n}\n","language":"cpp","meta":"","className":["language-cpp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\n\npublic class HelloWorld : MonoBehaviour {\n  void Start () {\n    Debug.Log(\"Hello, IL2CPP!\");\n  }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我切换到WebGL平台进行项目生成的时候，我们可以用Process Explorer来对il2cpp的命令行进行观察，得到以下内容："}]},{"type":"element","tag":"pre","props":{"code":"\n \"C:\\Program Files\\Unity\\Editor\\Data\\MonoBleedingEdge\\bin\\mono.exe\" \"C:\\Program Files\\Unity\\Editor\\Data\\il2cpp/il2cpp.exe\" --copy-level=None --enable-generic-sharing --enable-unity-event-support --output-format=Compact --extra-types.file=\"C:\\Program Files\\Unity\\Editor\\Data\\il2cpp\\il2cpp_default_extra_types.txt\" \"C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\Assembly-CSharp.dll\" \"C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\UnityEngine.UI.dll\" \"C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\il2cppOutput\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n \"C:\\Program Files\\Unity\\Editor\\Data\\MonoBleedingEdge\\bin\\mono.exe\" \"C:\\Program Files\\Unity\\Editor\\Data\\il2cpp/il2cpp.exe\" --copy-level=None --enable-generic-sharing --enable-unity-event-support --output-format=Compact --extra-types.file=\"C:\\Program Files\\Unity\\Editor\\Data\\il2cpp\\il2cpp_default_extra_types.txt\" \"C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\Assembly-CSharp.dll\" \"C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\UnityEngine.UI.dll\" \"C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\il2cppOutput\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"嗯，这个真是老太太的裹脚布 - 又臭又长......，所以让我们把命令分拆一下，Unity运行的是这个可执行文件："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"C:\\Program Files\\Unity\\Editor\\Data\\MonoBleedingEdge\\bin\\mono.exe\""}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下一个参数是il2cpp.exe工具本身：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"C:\\Program Files\\Unity\\Editor\\Data\\il2cpp/il2cpp.exe\""}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请注意剩下的参数其实都是传递给il2cpp.exe的而不是mono.exe。上面的例子里传递了5个参数给il2cpp.exe：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"–copy-level=None"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"指明il2cpp.exe不对生成的C++文件进行copy操作\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":" –enable-generic-sharing"}]},{"type":"text","value":"\n告诉IL2CPP如果可以，对通用方法进行共享。这个可以减少代码并降低最后二进制文件的尺寸"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"–enable-unity-event-support"}]},{"type":"text","value":"\n确保和Unity events相关的，通过反射机制来运作的代码，能够正确生成。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"–output-format=Compact"}]},{"type":"text","value":"\n在生成C++代码时为里面的类型和方法使用更短的名字。这会使得C++代码难以阅读，因为原来在IL中的名字被更短的取代了。但好处是可以让C++编译器运行的更快。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"–extra-types.file=”C:\\Program Files\\Unity\\Editor\\Data\\il2cpp\\il2cpp_default_extra_types.txt”"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用默认的（也是空的）额外类型文件。il2cpp.exe会将在这个文件中出现的基本类型或者数组类型看作是在运行时生成的而不是一开始出现在IL代码中来对待。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是这些参数可能会在以后的Unity版本中有所变化。我们现在还没有稳定到把il2cpp.exe的命令行参数整理固定下来的阶段。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，我们有由两个文件组成的一个列表和一个目录在这个长长的命令行中："}]},{"type":"element","tag":"pre","props":{"code":"\n“C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\Assembly-CSharp.dll”\n“C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\UnityEngine.UI.dll”\n“C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\il2cppOutput”\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n“C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\Assembly-CSharp.dll”\n“C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\Managed\\UnityEngine.UI.dll”\n“C:\\Users\\Josh Peterson\\Documents\\IL2CPP Blog Example\\Temp\\StagingArea\\Data\\il2cppOutput”\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"il2cpp.exe工具可以接收一个由IL程序集组成的列表。在上面这个例子中，程序集包含了项目中的简单脚本程序集：Assembly-CSharp.dll，和GUI程序集：UnityEngine.UI.dll。大家可能会注意到这里面明显少了什么：UnityEngine.dll到哪去了？系统底层的mscorlib.dll也不见了踪影。实际上，il2cpp.exe会在内部自动引用这些程序集。你当然也可以把这些放入列表中，但他们不是必须的。你只需要提及那些根程序集（那些没有被其他任何程序集引用到的程序集），剩下的il2cpp.exe会根据引用关系自动加入。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"裹脚布的最后一块是一个目录，il2cpp.exe会将最终的C++代码生成到这里。如果你还保持着一颗好奇的心，可以看看这个目录中产生的文件。这些文件是我们下一个讨论的主题。在你审视这些代码前，可以考虑将WebGL构建设置中的“Development Player”选项勾上。这么做会移除–output-format=Compact命令行参数从而让C++代码中的类型和方法的名字更加可读。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"尝试在WebGL或者iOS构建设置中进行些改变。这样你会发现传递给il2cpp.exe的参数也会相应的发生变化。例如，将“Enable Exceptions” 设置成“Full” 会将–emit-null-checks，–enable-stacktrace，和 –enable-array-bounds-check这三个参数加入il2cpp.exe命令行。"}]},{"type":"element","tag":"h2","props":{"id":"il2cpp没做的事情"},"children":[{"type":"text","value":"IL2CPP没做的事情"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我想指出IL2CPP有一向挑战我们没有接受,而且我们也高兴我们忽略了它。我们没有尝试重写整个C#标准库。当你使用IL2CPP后端构建Unity项目的时候，所有在mscorlib.dll，System.dll等中的C#标准库和原来使用Mono编译时候的一模一样。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以依赖健壮的且久经考验的C#标准库，所以当处理有关IL2CPP的bug的时候，我们可以很肯定的说问题出在AOT编译器或者运行时库这两个地方而不是在其他地方。"}]},{"type":"element","tag":"h2","props":{"id":"我们如何开发测试发布il2cpp"},"children":[{"type":"text","value":"我们如何开发，测试，发布IL2CPP"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"自从我们在一月份的4.6.1 p5版本中首次引入IL2CPP以来，我们已经连续发布了6个Unity版本和7个补丁（Unity版本号跨越4.6和5.0）。在这些发布中我们修正了超过100个bug。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了确保持续的改进得以实施，我们内部只保留一份最新的开发代码在主干分之（trunk branch）上，在发布各个版本之前，我们会将IL2CPP的改动挂到一个特定的分之下，然后进行测试，确保所有的bug已经正确的修正了。我们的QA和维护工作组为此付出了惊人的努力才得以保证发布版本的快速迭代。（译注：感觉是版本管理的标准的开发流程）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"提供高质量Bug的用户社区被证明是一个无价之宝。我们非常感谢用户的反馈来帮助我们改进IL2CPP，并且希望这类反馈越多越好。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们的IL2CPP研发组有很强烈的“测试优先”意识。我们时常使用“Test Driven Design”方法，在没有进行足够全面的测试的情况下，几乎不会进行代码的合并工作。这个策略用在IL2CPP项目上非常的棒。我们现在所面对的大部分bug并不是意想不到的行为产生的，而是由意想不到的特殊情况产生的。（例如在一个32位的索引数组中使用了64位的指针从而导致C++编译器失败）面对这种类型的bug我们可以快速的并且很自信的进行修正。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有了社区的帮助，我们非常努力的让IL2CPP既快又稳定。顺便说一句，如果你对我刚才说的这些有兴趣，我们正在招人（嗯.....我只是这么一说）"}]},{"type":"element","tag":"h2","props":{"id":"好戏连台"},"children":[{"type":"text","value":"好戏连台"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于IL2CPP我们还有很多可以说的。下一次我们会深入到il2cpp.exe代码生成的细节中。看看对于C++编译器来说，由il2cpp.exe生成的代码会是个什么样子。"}]},{"type":"element","tag":"h1","props":{"id":"il2cpp-脚本限制"},"children":[{"type":"text","value":"IL2CPP 脚本限制"}]},{"type":"element","tag":"h2","props":{"id":"systemreflectionemit"},"children":[{"type":"text","value":"System.Reflection.Emit"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOT 平台无法实现 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Reflection.Emit"}]},{"type":"text","value":" 命名空间中的任何方法。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Reflection"}]},{"type":"text","value":" 的其余部分是可接受的，只要编译器可以推断通过反射使用的代码需要在运行时存在。"}]},{"type":"element","tag":"h2","props":{"id":"序列化"},"children":[{"type":"text","value":"序列化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOT 平台可能会由于使用了反射而遇到序列化和反序列化问题。如果仅通过反射将某个类型或方法作为序列化或反序列化的一部分使用，则 AOT 编译器无法检测到需要为该类型或方法生成代码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是我们常遇到的问题..一个是scriptobject的asset,一个是网络协议都是序列化数据"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"odin,最佳模式新建一个aot场景,将需要的scriptobject放在该场景.或者声明序列化字段"}]}]},{"type":"element","tag":"pre","props":{"code":"public class OdinAOTSetting : Sirenix.OdinInspector.SerializedMonoBehaviour\n{\n\n    public List<ScriptableObject> Configs;\n\n\n    [NonSerialized, OdinSerialize]\n    public UnityEngine.Color Color;\n\n    [NonSerialized, OdinSerialize]\n    public CityMapLandType CityMapLandType;\n\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, InventoryItemConfig> InventoryItemConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, LootTableConfig> LootTableConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, MerchantConfig> MerchantConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, LandConfig> LandConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, MapConfig> MapConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<long, NPCConfig> NPCConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<long, QuestConfig> QuestConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, RedeemCodeConfig> RedeemCodeConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, BuffConfig> BuffConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, ProjectileConfig> ProjectileConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, SkillConfig> SkillConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, AttrAsset> AttrAssets;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, StatAsset> StatAssets;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, StatusEffectAsset> StatusEffectAssets;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class OdinAOTSetting : Sirenix.OdinInspector.SerializedMonoBehaviour\n{\n\n    public List<ScriptableObject> Configs;\n\n\n    [NonSerialized, OdinSerialize]\n    public UnityEngine.Color Color;\n\n    [NonSerialized, OdinSerialize]\n    public CityMapLandType CityMapLandType;\n\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, InventoryItemConfig> InventoryItemConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, LootTableConfig> LootTableConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, MerchantConfig> MerchantConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, LandConfig> LandConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, MapConfig> MapConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<long, NPCConfig> NPCConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<long, QuestConfig> QuestConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, RedeemCodeConfig> RedeemCodeConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, BuffConfig> BuffConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, ProjectileConfig> ProjectileConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<int, SkillConfig> SkillConfigs;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, AttrAsset> AttrAssets;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, StatAsset> StatAssets;\n    [NonSerialized, OdinSerialize]\n    Dictionary<string, StatusEffectAsset> StatusEffectAssets;\n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"网络协议Json,使用字段,而不是使用属性(get,set),il2cpp 在运行时会剥离去除Get属性，"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"网络协议protobuf,虽然protobuf本身是支持Dictionary的,但是aot就不能使用了..未找到解决办法 ,用class代替"}]}]},{"type":"element","tag":"h2","props":{"id":"泛型"},"children":[{"type":"text","value":"泛型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个泛型实例实际上都是一个独立的类型，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"List<A>"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"List<B>"}]},{"type":"text","value":"是两个完全没有关系的类型，这意味着，如果在运行时无法通过JIT来创建新类型的话，代码中没有直接使用过的泛型实例都会在运行时出现问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在ILRuntime中解决这个问题有两种方式，一个是使用CLR绑定，把用到的泛型实例都进行CLR绑定。另外一个方式是在Unity主工程中，建立一个类，然后在里面定义用到的那些泛型实例的public变量。这两种方式都可以告诉IL2CPP保留这个类型的代码供运行中使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此建议大家在实际开发中，尽量使用热更DLL内部的类作为泛型参数，因为DLL内部的类型都是ILTypeInstance，只需处理一个就行了。此外如果泛型模版类就是在DLL里定义的的话，那就完全不需要进行任何处理。"}]},{"type":"element","tag":"h3","props":{"id":"泛型方法"},"children":[{"type":"text","value":"泛型方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"跟泛型实例一样，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"foo.Bar<TypeA>"}]},{"type":"text","value":" 和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"foo.Bar<TypeB>"}]},{"type":"text","value":"是两个完全不同的方法，需要在主工程中显式调用过，IL2CPP才能够完整保留，因此需要尽量避免在热更DLL中调用Unity主工程的泛型方法。如果在iOS上实际运行遇到报错，可以尝试在Unity的主工程中随便写一个static的方法，然后对这个泛型方法调用一下即可，这个方法无需被调用，只是用来告诉IL2CPP我们需要这个方法"}]},{"type":"element","tag":"h2","props":{"id":"animatorcontroller-等"},"children":[{"type":"text","value":"AnimatorController 等"}]},{"type":"element","tag":"pre","props":{"code":"错误信息#\nCould not produce class with ID #\nCould not produce class with ID XXX.\nThis could be caused by a class being stripped from the build even though it is needed. Try disabling 'Strip Engine Code' in Player Settings.:<LoadWWWIEnumerator>c__Iterator99:MoveNext()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"错误信息#\nCould not produce class with ID #\nCould not produce class with ID XXX.\nThis could be caused by a class being stripped from the build even though it is needed. Try disabling 'Strip Engine Code' in Player Settings.:<LoadWWWIEnumerator>c__Iterator99:MoveNext()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果提示的ID的是Editor的，比如 AnimatorController(ID 91)属于Editor包里的，不能用link.xm加回来，可以在"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Resource"}]},{"type":"text","value":"下建一个空的prefab,在上面挂一个AnimatorController，打包时留下这个prefab就可以确保这个类不被strip掉了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"参考 :"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/could-not-produce-class-with-id-91-ios.267548/","rel":["nofollow"]},"children":[{"type":"text","value":"Could not produce class with ID 91 - iOS - Unity Forum"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/Manual/ClassIDReference.html","rel":["nofollow"]},"children":[{"type":"text","value":"YAML 类 ID 参考 - Unity 手册 (unity3d.com)"}]}]}]},{"type":"element","tag":"h2","props":{"id":"其他"},"children":[{"type":"text","value":"其他"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要用dynamic关键字"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"没有使用的字段都不会被编译.."}]}]},{"type":"element","tag":"h1","props":{"id":"托管代码剥离"},"children":[{"type":"text","value":"托管代码剥离"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后ipa包的尺寸的目的。然而在实际使用过程中，很多类型有可能会被意外剪裁掉，造成运行时抛出找不到某个类型的异常。特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity提供了一个方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的。具体做法就是在Unity工程的Assets目录中建立一个叫link.xml的XML文件，然后按照下面的格式指定你需要保留的类型："}]},{"type":"element","tag":"pre","props":{"code":"<linker>\n  <assembly fullname=\"UnityEngine\" preserve=\"all\"/>\n  <assembly fullname=\"Assembly-CSharp\">\n    <namespace fullname=\"MyGame.Utils\" preserve=\"all\"/>\n    <type fullname=\"MyGame.SomeClass\" preserve=\"all\"/>\n  </assembly>  \n</linker>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<linker>\n  <assembly fullname=\"UnityEngine\" preserve=\"all\"/>\n  <assembly fullname=\"Assembly-CSharp\">\n    <namespace fullname=\"MyGame.Utils\" preserve=\"all\"/>\n    <type fullname=\"MyGame.SomeClass\" preserve=\"all\"/>\n  </assembly>  \n</linker>\n"}]}]},{"type":"element","tag":"h2","props":{"id":"il2cpp限制"},"children":[{"type":"text","value":"IL2CPP限制"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将游戏导出到 iOS 等平台时，Unity 将使用其 IL2CPP 引擎将 IL“转换”为 C++ 代码，然后使用目标平台的本机编译器进行编译。 在此方案中，有几个不支持的 .NET 功能，例如反射的部分内容和使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"dynamic"}]},{"type":"text","value":" 关键字。 虽然可在自己的代码中使用这些功能，但使用第三方 DLL 和 SDK 时可能会遇到问题，这些 DLL 和 SDK 并非使用 Unity 和 IL2CPP 编写。 有关此主题的详细信息，请参阅 Unity 站点上的"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/ScriptingRestrictions.html","rel":["nofollow"]},"children":[{"type":"text","value":"脚本限制"}]},{"type":"text","value":"文档。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此外，如之前 Json.NET 示例中所述，Unity 将尝试在 IL2CPP 导出过程中裁剪掉未使用的代码。 虽然这通常不是问题，但对于使用反射的库，它可能会意外地删除在导出时无法确定是否被调用而在运行时可能被调用的属性或方法。 若要解决这些问题，请添加一个 link.xml 文件到项目中，该文件中包含的程序集和命名空间列表不会执行裁剪过程。 有关完整详细信息，请参阅"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html","rel":["nofollow"]},"children":[{"type":"text","value":"有关字节码裁剪的 Unity 文档"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h2","props":{"id":"编译速度优化"},"children":[{"type":"text","value":"编译速度优化"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"增量编译"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关闭实时保护"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用ssd"}]}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-us/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/en-us/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/ScriptingRestrictions.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/ScriptingRestrictions.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/7cfcb7b0cfe7","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.jianshu.com/p/7cfcb7b0cfe7"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blogs.unity3d.com/cn/2015/05/06/an-introduction-to-ilcpp-internals/","rel":["nofollow"]},"children":[{"type":"text","value":"https://blogs.unity3d.com/cn/2015/05/06/an-introduction-to-ilcpp-internals/"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"什么是il2cpp","depth":2,"text":"什么是IL2CPP？"},{"id":"一个支持虚拟机的运行时库","depth":2,"text":"一个支持虚拟机的运行时库"},{"id":"aot编译器","depth":2,"text":"AOT编译器"},{"id":"运行时库","depth":2,"text":"运行时库"},{"id":"il2cpp是如何执行的","depth":2,"text":"il2cpp是如何执行的？"},{"id":"il2cpp没做的事情","depth":2,"text":"IL2CPP没做的事情"},{"id":"我们如何开发测试发布il2cpp","depth":2,"text":"我们如何开发，测试，发布IL2CPP"},{"id":"好戏连台","depth":2,"text":"好戏连台"},{"id":"systemreflectionemit","depth":2,"text":"System.Reflection.Emit"},{"id":"序列化","depth":2,"text":"序列化"},{"id":"泛型","depth":2,"text":"泛型","children":[{"id":"泛型方法","depth":3,"text":"泛型方法"}]},{"id":"animatorcontroller-等","depth":2,"text":"AnimatorController 等"},{"id":"其他","depth":2,"text":"其他"},{"id":"il2cpp限制","depth":2,"text":"IL2CPP限制"},{"id":"编译速度优化","depth":2,"text":"编译速度优化"},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:unity:2019-06-20-unity-il2cpp-debugger.md","_source":"content","_file":"unity/2019-06-20-unity-il2cpp-debugger.md","_extension":"md","date":"2019-06-20"},{"_path":"/unity/2019-06-23-googlplay-pulish","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"googlePlay 发布问题","description":"使用这个站点https://app-privacy-policy-generator.firebaseapp.com/ 根据app的名称，类型，平台等等，选择对应的选项，右边按钮还包含对应的第三方隐私服务链接，如果你用到的话，比如google play service, firebase等等，那么就勾选上。最后点击GENERATE，就会生成一个适合你自己app的privacy-policy页面了。\n最后的最后，记得将这个url输入到google play后台的隐私设置区域，点击保存，重新发布app等候google play团队的审核。一两个小时就好了。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"问题-隐私声明"},"children":[{"type":"text","value":"问题 隐私声明"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用这个站点"},{"type":"element","tag":"a","props":{"href":"https://app-privacy-policy-generator.firebaseapp.com/","rel":["nofollow"]},"children":[{"type":"text","value":"https://app-privacy-policy-generator.firebaseapp.com/"}]},{"type":"text","value":" 根据app的名称，类型，平台等等，选择对应的选项，右边按钮还包含对应的第三方隐私服务链接，如果你用到的话，比如google play service, firebase等等，那么就勾选上。最后点击GENERATE，就会生成一个适合你自己app的privacy-policy页面了。\n最后的最后，记得将这个url输入到google play后台的隐私设置区域，点击保存，重新发布app等候google play团队的审核。一两个小时就好了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.usejournal.com/how-to-fix-advertising-id-policy-violation-in-google-play-store-6d9cf92d335d","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.usejournal.com/how-to-fix-advertising-id-policy-violation-in-google-play-store-6d9cf92d335d"}]}]},{"type":"element","tag":"h1","props":{"id":"问题-1002"},"children":[{"type":"text","value":"问题 -1002"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Google Play应用需要授予\"允许后台弹窗\"的权限"}]},{"type":"element","tag":"h1","props":{"id":"问题-此商品无法在您设备所在的国家地区安装"},"children":[{"type":"text","value":"问题  此商品无法在您设备所在的国家地区安装"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"删除家庭内容.."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用vpn切换到指定国家"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"googleplay--账号里切换地区"}]}]},{"type":"element","tag":"h1","props":{"id":"问题-无法购买您要的商品"},"children":[{"type":"text","value":"问题 无法购买您要的商品"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"做Google Play 支付， 遇到“无法购买您要的商品”的问题，在网上搜了些答案，下面罗列了一些"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"保证 versionCode 和版本号与你上传的apk的包的一样。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"保证后台和你传入的购买商品的 id 一致。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"确保你所使用的账号是在测试人员里。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在\"APK\"页面里，有一个“选择使用网址”，把这个网址给你的测试人员，让你的测试人员用他的google账号点进去，点那个“成为测试人员”（前提是你把他加进了测试人员列表），还需要把连接地址发送给测试人员，必须要测试人员点击同意参加测试才行！！"}]},{"type":"element","tag":"h1","props":{"id":"问题-无法使用该应用此应用的测试版尚未发布或者无法通过此帐号使用"},"children":[{"type":"text","value":"问题 无法使用该应用,此应用的测试版尚未发布，或者无法通过此帐号使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://play.google.com/apps/testing/com.zhepama.gyj","rel":["nofollow"]},"children":[{"type":"text","value":"https://play.google.com/apps/testing/com.zhepama.gyj"}]},{"type":"text","value":"  发给测试人员激活..记住..登录的用户一定是测试人员"}]},{"type":"element","tag":"h1","props":{"id":"问题-此版本的应用未配置为通过googleplay-结算"},"children":[{"type":"text","value":"问题 此版本的应用未配置为通过googleplay 结算"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"造成这个错误的原因有两个:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"第一个是打包的时候，versionCode的值比提交到google play后台的版本要高。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"第二个就是：打包的时候，和google play后台上的包的签名不一致。"}]}]},{"type":"element","tag":"h1","props":{"id":"问题-关于如何测试"},"children":[{"type":"text","value":"问题  关于如何测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先使用release版本发布到googleplay.测试的时候可以使用debug版本,先测试下基本功能..查看哪里报错.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"apk可以使用谷歌提供的测试地址下载"}]},{"type":"element","tag":"h3","props":{"id":"以下是google-iab测试的要求清单"},"children":[{"type":"text","value":"以下是Google IAB测试的要求清单。"}]},{"type":"element","tag":"h4","props":{"id":"先决条件"},"children":[{"type":"text","value":"先决条件："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AndroidManifest必须包含“com.android.vending.BILLING”权限 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"APK内置于发行模式 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"APK已使用发行证书进行 签名 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"至少一次将APK上传到Alpha / Beta版本的渠道（以前 - 作为草稿）到开发者控制台。 （需要一段时间〜2h-24h ）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IAB 产品已发布 ，其状态设置为活动 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试帐户被添加到开发者控制台中。"}]}]},{"type":"element","tag":"h4","props":{"id":"测试要求"},"children":[{"type":"text","value":"测试要求："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试APK 与上传到开发者控制台的版本号相同 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试APK的签名与上传到dev.console的证书相同 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试帐户 （不是开发人员） - 是设备上的主要帐户 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试帐户作为测试者选择加入，并与有效的付款方式相关联 。 （ @Kyone ）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PS： 使用发行证书进行调试"}]}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":""},"children":[{"type":"text","value":"https : //stackoverflow.com/a/15754187/1321401"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"以下是google-iab测试的要求清单","depth":3,"text":"以下是Google IAB测试的要求清单。"},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:unity:2019-06-23-googlplay-pulish.md","_source":"content","_file":"unity/2019-06-23-googlplay-pulish.md","_extension":"md","date":"2019-06-23"},{"_path":"/unity/2019-08-09-unity2d-shipei","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于unity的适配问题","description":"先说明一些基本的概念：1.屏幕的宽高比Aspect Ratio = 屏幕宽度/屏幕高度2.Unity2D中摄像机镜头的尺寸决定了我们实际看到游戏内容的多少，在编辑器中我们可以通过调整摄像机Camera的orthographicSize属性值来调整摄像机的大小。如下图所示，当摄像机orthographicSize属性值等于当前屏幕高度单位的一半时，摄像机大小正好与屏幕大小相等。注意这里提到的是屏幕单位高度的一半，这个数值是经过像素到单位比即Pixels To Units换算的，Unity2D中这个比例的默认值是100，即100像素等于1单位。如果我们的游戏屏幕有640像素高，那么实际换算成单位高","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先说明一些基本的概念："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.屏幕的宽高比Aspect Ratio = 屏幕宽度/屏幕高度"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2.Unity2D中摄像机镜头的尺寸决定了我们实际看到游戏内容的多少，在编辑器中我们可以通过调整摄像机Camera的orthographicSize属性值来调整摄像机的大小。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示，当摄像机orthographicSize属性值等于当前屏幕高度单位的一半时，摄像机大小正好与屏幕大小相等。注意这里提到的是屏幕单位高度的一半，这个数值是经过像素到单位比即Pixels To Units换算的，Unity2D中这个比例的默认值是100，即100像素等于1单位。如果我们的游戏屏幕有640像素高，那么实际换算成单位高度则是6.4个单位，当我们摄像机的orthographicSize值是3.2时，摄像机大小刚好与屏幕大小相等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-09-unity2d-shipei/041527387365011.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以通过此选项调整每张图片的像素单位比"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-09-unity2d-shipei/041505358774753.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"unity编辑器中只能直接调整摄像机的高度那摄像机的宽度是如何确定的呢"},"children":[{"type":"text","value":"Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"答案就是我们最前面提到的屏幕宽高比。Unity会根据当前屏幕实际的宽高比和摄像机的orthographicSize值来计算出摄像机的宽度值，即："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"摄像机实际宽度 = 摄像机orthographicSize * 2 * 屏幕宽高比"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也即是"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"摄像机实际宽度 = 摄像机高度 * 屏幕宽高比"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我举个例子说明一下，iPhone4的屏幕像素为640*960，宽高比为2:3，假设Pixels To Units值为100，那么如果设摄像机高度size值为4.8，那么摄像机实际宽度按照公式算出6.4，刚好就是屏幕的单位宽度。"}]},{"type":"element","tag":"h1","props":{"id":"场景适配"},"children":[{"type":"text","value":"场景适配"}]},{"type":"element","tag":"h2","props":{"id":"_2d场景和3d摄像机的适配"},"children":[{"type":"text","value":"2d场景和3d摄像机的适配"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"因为需要引入3d的内容所以 worldcamera,使用了透视摄像机"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透视摄像机旋转了15度使其可以看到地面..因为是透视相机,这就造成了2d角色在相机移动后会发生偏移的问题..这个时候需要将2d角色始终面向相机.所以2d单位的容器也需要旋转15度"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为什么不单独使用一个正交摄像机看角色?因为这样的画,地面和角色不是用一个相机,且其中一个使用的是透视,会造成人物移动后,地面和角色形成视差,造成其他角色看起来不像站在地面上一样"}]}]},{"type":"element","tag":"h2","props":{"id":"场景和ui位置的适配"},"children":[{"type":"text","value":"场景和ui位置的适配"}]},{"type":"element","tag":"h3","props":{"id":"_3d形象如何展现在ui中"},"children":[{"type":"text","value":"3d形象如何展现在ui中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直接将3d物品拖到ui中然后添加rect transform属性,3d物品会根据ui的位置改变而改变"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后可能会出现看不到3d对象的问题.这个可能和canvas的plane distance有关,即摄像机和canvas的z的距离"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200828173613476","src":"/images/2019-08-09-unity2d-shipei/image-20200828173613476.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用3d视图看下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200828173814986","src":"/images/2019-08-09-unity2d-shipei/image-20200828173814986.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个时候是看不到cube的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意: 想用canvas中的ui去遮挡3d物品是做不到的,sortingGroup也不会有用处..如下图想用绿色盖住cube,是做不到的.因为他们在摄像机的显示是按照z去排的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200828174105986","src":"/images/2019-08-09-unity2d-shipei/image-20200828174105986.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"根据场景位置设置ui位置"},"children":[{"type":"text","value":"根据场景位置设置ui位置.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如竖屏游戏.有一半是场景一半是ui,如何让ui去准确的盖住场景"}]},{"type":"element","tag":"pre","props":{"code":"        public static Vector3 WorldToCanvasPosition(Camera objectCamera, Vector3 objectTransformPosition, RectTransform CanvasRect)\n        {\n            // Get the position on the canvas\n            Vector3 ViewportPosition = objectCamera.WorldToViewportPoint(objectTransformPosition);\n            Vector3 result = new Vector3(\n            ((ViewportPosition.x * CanvasRect.sizeDelta.x) - (CanvasRect.sizeDelta.x * 0.5f)),\n            ((ViewportPosition.y * CanvasRect.sizeDelta.y) - (CanvasRect.sizeDelta.y * 0.5f)), 0);\n\n            return CanvasRect.TransformPoint(result);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static Vector3 WorldToCanvasPosition(Camera objectCamera, Vector3 objectTransformPosition, RectTransform CanvasRect)\n        {\n            // Get the position on the canvas\n            Vector3 ViewportPosition = objectCamera.WorldToViewportPoint(objectTransformPosition);\n            Vector3 result = new Vector3(\n            ((ViewportPosition.x * CanvasRect.sizeDelta.x) - (CanvasRect.sizeDelta.x * 0.5f)),\n            ((ViewportPosition.y * CanvasRect.sizeDelta.y) - (CanvasRect.sizeDelta.y * 0.5f)), 0);\n\n            return CanvasRect.TransformPoint(result);\n        }\n"}]}]},{"type":"element","tag":"pre","props":{"code":"       public static Vector3 WorldToCanvasPosition(Camera objectCamera, Vector3 objectTransformPosition, RectTransform CanvasRect, Canvas Canvas, Camera UICamera)\n        {\n            Vector3 screenPoint = RectTransformUtility.WorldToScreenPoint(objectCamera, objectTransformPosition);\n\n            RectTransformUtility.ScreenPointToLocalPointInRectangle(CanvasRect, screenPoint, Canvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : UICamera, out Vector2 result);\n\n            return CanvasRect.TransformPoint(result);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"       public static Vector3 WorldToCanvasPosition(Camera objectCamera, Vector3 objectTransformPosition, RectTransform CanvasRect, Canvas Canvas, Camera UICamera)\n        {\n            Vector3 screenPoint = RectTransformUtility.WorldToScreenPoint(objectCamera, objectTransformPosition);\n\n            RectTransformUtility.ScreenPointToLocalPointInRectangle(CanvasRect, screenPoint, Canvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : UICamera, out Vector2 result);\n\n            return CanvasRect.TransformPoint(result);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用:"}]},{"type":"element","tag":"pre","props":{"code":"                    //0.3盖住半个单位的地形\n                    var pos = CameraUtils.WorldToCanvasPosition(this.mainCamera, new Vector3(boardRoot.position.x, boardRoot.position.y, boardRoot.position.z), rect);\n                    var perUnit = rect.sizeDelta.y / (2f * this.uiCamera.orthographicSize);\n                    (notification.Body as RectTransform).offsetMax = new Vector2(0, -(this.uiCamera.orthographicSize - pos.y) * perUnit);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"                    //0.3盖住半个单位的地形\n                    var pos = CameraUtils.WorldToCanvasPosition(this.mainCamera, new Vector3(boardRoot.position.x, boardRoot.position.y, boardRoot.position.z), rect);\n                    var perUnit = rect.sizeDelta.y / (2f * this.uiCamera.orthographicSize);\n                    (notification.Body as RectTransform).offsetMax = new Vector2(0, -(this.uiCamera.orthographicSize - pos.y) * perUnit);\n"}]}]},{"type":"element","tag":"h1","props":{"id":"ugui的适配"},"children":[{"type":"text","value":"UGUI的适配"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"锚点是解决ui控件在canvas里面位置的问题.而Canvas Scaler主要是设置canvas(ui控件)显示的大小(缩放)问题"}]},{"type":"element","tag":"h2","props":{"id":"锚点"},"children":[{"type":"text","value":"锚点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"锚点这个概念在Unity文档的多分辨率适配中被明确的提到其作用。简单的说，就是定位。如果一个物体相对于屏幕位置左上角，那么无论屏幕分辨率怎么变化，它始终位于左上角。同理，如果是在（0,0）原点，那么也始终在中心原点。我对锚点定义为，锚点，是相对于父节点的偏移量，这个偏移量随屏幕分辨率变化而按比例变化，如果将分辨率的宽，高，看做归一化的数值（即0~1，实际UGUI就是这么做的），那么锚点是指一个偏移百分比。所以有了锚点，子节点在相对于父节点的位置上保持不变的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如图，参考分辨率960"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"640，我改变GameView的分辨率为800"}]},{"type":"text","value":"468，图中绿色背景大小960"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"640，红色Image大小100"}]},{"type":"text","value":"100，红色图片的锚点为左上，轴点为左上，在参考分辨率下，红色正方形的左上顶点距离Canvas左上顶点距离（50，-150）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-09-unity2d-shipei/php2Hv6xD.1469191739.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-09-unity2d-shipei/phpwptKbd.1469191746.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    当我将屏幕分辨率切换为800*468后，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    因为我选的Screen Match Mode为Weight = 0，所以在800 * 468分辨率下的实际屏幕高度为 960 * （468/800）= 561.6。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    又因为我的UI Scale Mode选的是Scale with Screen Size随屏幕尺寸变化，这个时候的缩放比是由宽度决定的，960/800 = 1.2 ,所以红色正方形此时的高度为100 / 1.2= 83.333"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    红色正方向锚点y轴坐标 = 参考锚点位置 * 缩放比 = 150 * 1.2 = 125，"}]},{"type":"element","tag":"h2","props":{"id":"canvas-scaler"},"children":[{"type":"text","value":"Canvas Scaler"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看名字就知道..是设置canvas如何根据屏幕进行缩放"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI的屏幕自适应，是通过Canvas Scaler来做的，根据屏幕的分辨率，计算出canvas的大小，同时计算ScaleXY,通过Size + Scale来控制Canvas的变换，UI作为canvas的子物体，也会跟随着一起变化；为了保证UI的位置，需要在设计UI的时候，利用锚点来保证UI与边缘或角落的距离，"}]},{"type":"element","tag":"h3","props":{"id":"固定像素-constant-pixel-size"},"children":[{"type":"text","value":"固定像素 (Constant Pixel Size)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"忽略屏幕的大小根据UI元素的实际像素显示 ,像素大小始终不变，即一个100"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"100的图片在任何的分辨率下都占用100"}]},{"type":"text","value":"100的像素。一般PC上会使用这种方式，因为PC端分辨率差异并不大。"}]},{"type":"element","tag":"h3","props":{"id":"根据屏幕大小进行缩放screen-match-mode"},"children":[{"type":"text","value":"根据屏幕大小进行缩放(Screen Match Mode)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此项会根据设备真实分辨率与设计分辨率来对Canvas进行缩放。有三种模式："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Match Width or Height"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据宽或者高来对Canvas进行缩放，比如设备分辨率为1920"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"900，设计分辨率为1280"}]},{"type":"text","value":"720，此时，如果采用宽进行匹配那么可以通过公式计算出此时应该缩放多少倍，公式如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缩放因子：1920/1280 = 1.5"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缩放后的Canvas的宽为：1920（刚好能够完全显示）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缩放后的Canvas的高为：720*1.5 = 1080"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于设备的高为900所以会导致高度上的一部分不会被显示出来"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.Expand"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适配的计算公式同上，只是在此模式下会保证设计分辨率下的东西能够全部显示出来，及选择设备分辨率和设计分辨率的宽、高比中选择最小值作为缩放因子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.Shrink"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和Expand恰好相反，在此模式下不会留黑边但是会导致显示不完全。及选择设备分辨率和设计分辨率的宽、高比中选择最大值作为缩放因子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UiScaleMode一般选择Scale With Screen Size，并设置好设计分辨率。其他两个选项都是固定像素大小。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Screen Match Mode中一般选择Expand，它可以保证ui中的所有元素都在屏幕内部。 相对比的一个选项是Shrink，它可以保证不留空白边。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、多分辨率的思路是Scaler中选择Expand保证所有ui元素在屏幕内部。少部分界面，如主界面、战斗界面等根据需要设置Anchors中的全屏拉伸。注意，这里的拉伸的含义仅仅是设置Panel的宽、高，并不影响子控件的缩放，但是会影响其布局。"}]},{"type":"element","tag":"h3","props":{"id":"固定物理大小constant-physical-size"},"children":[{"type":"text","value":"固定物理大小(Constant Physical Size)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"忽略屏幕大小和分辨率根据UI的实际物理大小来显示。"}]},{"type":"element","tag":"h1","props":{"id":"刘海屏的适配"},"children":[{"type":"text","value":"刘海屏的适配"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"待续"}]},{"type":"element","tag":"h1","props":{"id":"参考链接"},"children":[{"type":"text","value":"参考链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/shitangdejiaozi/article/details/88964850","rel":["nofollow"]},"children":[{"type":"text","value":"Unity记录-UGUI的屏幕自适应原理和应用_shitangdejiaozi的博客-CSDN博客"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/8ead0701d8ef","rel":["nofollow"]},"children":[{"type":"text","value":"Android刘海屏适配方案总结 - 简书 (jianshu.com)"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"unity编辑器中只能直接调整摄像机的高度那摄像机的宽度是如何确定的呢","depth":3,"text":"Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？"},{"id":"_2d场景和3d摄像机的适配","depth":2,"text":"2d场景和3d摄像机的适配"},{"id":"场景和ui位置的适配","depth":2,"text":"场景和ui位置的适配","children":[{"id":"_3d形象如何展现在ui中","depth":3,"text":"3d形象如何展现在ui中"},{"id":"根据场景位置设置ui位置","depth":3,"text":"根据场景位置设置ui位置.."}]},{"id":"锚点","depth":2,"text":"锚点"},{"id":"canvas-scaler","depth":2,"text":"Canvas Scaler","children":[{"id":"固定像素-constant-pixel-size","depth":3,"text":"固定像素 (Constant Pixel Size)"},{"id":"根据屏幕大小进行缩放screen-match-mode","depth":3,"text":"根据屏幕大小进行缩放(Screen Match Mode)"},{"id":"固定物理大小constant-physical-size","depth":3,"text":"固定物理大小(Constant Physical Size)"}]}]}},"_type":"markdown","_id":"content:unity:2019-08-09-unity2d-shipei.md","_source":"content","_file":"unity/2019-08-09-unity2d-shipei.md","_extension":"md","date":"2019-08-09"},{"_path":"/unity/2019-08-10-ugui-recttransform","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"一次精通 RectTransform","description":"在編輯器中快速設定 RectTransform快速控制器的基本操作我們就不在這裡贅述，基本上都可以在 Unity 網站裡找到很好的教學文件與影片。RectTransform 的控制精髓：錨點們 Anchor Points在透過快速設定器修改 RectTransform 的過程中，你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖：Pos X 與 Left、Pos Y 與 Top、Width 與 Right、Height 與 Bottom 這四對屬性個別不會同時出現，有 Pos X 就沒有 Left，有 Width 就沒有 Right，那麼他們出現的規則是什麼呢？簡單來說其實就是：「當兩個","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"在編輯器中快速設定-recttransform"},"children":[{"type":"text","value":"在編輯器中快速設定 RectTransform"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"快速控制器的基本操作我們就不在這裡贅述，基本上都可以在 Unity 網站裡找到很好的教學文件與影片。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/4B112FCB-1D5E-41FC-A19D-AA5322C52414.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"recttransform-的控制精髓錨點們-anchor-points"},"children":[{"type":"text","value":"RectTransform 的控制精髓：錨點們 Anchor Points"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在透過快速設定器修改 RectTransform 的過程中，你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/B30BC54C-DA7C-4882-9B3C-FA194FE9ACA5.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pos X 與 Left、Pos Y 與 Top、Width 與 Right、Height 與 Bottom 這四對屬性個別不會同時出現，有 Pos X 就沒有 Left，有 Width 就沒有 Right，那麼他們出現的規則是什麼呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"簡單來說其實就是："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"「當兩個錨點的某一維度值相等時，該維度的尺寸則是固定的（跟 Parent 尺寸無關），反之該維度的尺寸則是相對於 Parent 的尺寸而變化。」"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其實全部都取決於控制 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":" 型態最重要的屬性「最大與最小錨點們（Min / Max Anchors）」，而快速設定器其實也只是在幫你快速的調整這兩個錨點的值，所以只要了解這兩個設定值關係與行為，其實你已經完全掌握了 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":" ，而依照上述邏輯，透過兩個錨點所產生出的配置型態總共有四種："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A. 當兩錨點 x, y 維度的值都相等時。\nB. 當兩錨點 x 維度的值不相等、y 維度值相等時。\nC. 當兩錨點 x 維度的值相等、y 維度值不相等時。\nD. 當兩錨點 x, y 維度的值都不相等時。"}]},{"type":"element","tag":"h3","props":{"id":"a-當兩錨點-x-y-維度的值都相等時"},"children":[{"type":"text","value":"A. 當兩錨點 x, y 維度的值都相等時："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當兩錨點 x, y 值都相等時，代表此物件的寬高尺寸都是固定值，所以我們會透過 PosX、PosY、Width 以及 Height 來定義此物件的顯示方式，PosX 與 PosY 則分別表示錨點到物件 Pivot 點的位移，而此物件的實際顯示區域則會受到 Pivot 的 x, y 值設定所影響。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/static-anchors.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/ezgif-1-eea893f81f2e.gif"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"b-當兩錨點-x-維度的值不相等y-維度值相等時"},"children":[{"type":"text","value":"B. 當兩錨點 x 維度的值不相等、y 維度值相等時："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當兩錨點 x 維度的值不相等、y 維度值相等時，代表 x 維度的尺寸會受到 Parent 的尺寸影響，在 x 維度上則是使用間距（Padding）的概念來排版，所以會用到 Left、PosY、Right 以及 Height，實際的 Width 是由 Left 與 Right 來控制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/anchor_x1.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/anchor_x.gif"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"c-當兩錨點-x-維度的值相等y-維度值不相等時"},"children":[{"type":"text","value":"C. 當兩錨點 x 維度的值相等、y 維度值不相等時："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當兩錨點 x 維度的值相等、y 維度值不相等時，代表 y 維度的尺寸會受到 Parent 的尺寸影響，在 y 維度上則是使用間距（Padding）的概念來排版，所以會用到 PosX、Top、Width 以及 Bottom，實際的 Height 是由 Top 與 Bottom 來控制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/anchor_y1.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/anchor_y.gif"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"d-當兩錨點-x-y-維度的值都不相等時"},"children":[{"type":"text","value":"D. 當兩錨點 x, y 維度的值都不相等時："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當兩錨點 x, y 維度的值都不相等時，代表物件的寬高尺寸都會受到 Parent 的影響，完全是使用四個方向的間距來定義此物件的顯示區域 Left、Top、Right 以及 Bottom。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/anchor_xy.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/anchor_xy.gif"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"一些术语解释"},"children":[{"type":"text","value":"一些术语解释"}]},{"type":"element","tag":"h3","props":{"id":"pivot"},"children":[{"type":"text","value":"pivot"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"物體自身的支點，影響物體的旋轉、縮放、位置，改變 UI Pivot 必須先開啟控制面板的 Pivot 按鈕，如下圖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Pivot_01","src":"/images/2019-08-10-ugui-RectTransform/Pivot_01.png"},"children":[]},{"type":"text","value":"，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pivot (0.5, 0.5)\n"},{"type":"element","tag":"img","props":{"alt":"Pivot_02","src":"/images/2019-08-10-ugui-RectTransform/Pivot_02.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pivot (0, 1)\n"},{"type":"element","tag":"img","props":{"alt":"Pivot_03","src":"/images/2019-08-10-ugui-RectTransform/Pivot_03.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它是一个X,Y值范围是0到1的点，这个点的会在"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Anchor"}]},{"type":"text","value":"（锚点）计算位置的时候会使用到，下面用一张图来解释"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Pivot"}]},{"type":"text","value":"点的位置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/84177-b27df7bbe9d3c829.webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pivot和text的填充"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200420000104602","src":"/images/2019-08-10-ugui-RectTransform/image-20200420000104602.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当pivot为0.5和0.5时数字的填充时以中心点向上下方向扩展rect"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200420000313192","src":"/images/2019-08-10-ugui-RectTransform/image-20200420000313192.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般来讲,动态改变文本,为了使其按照从上到下,可以把pivot设置在左上角  0,1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200420000549965","src":"/images/2019-08-10-ugui-RectTransform/image-20200420000549965.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"点击上方的pivot可以切换pivot的所在位置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"center 的中心点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pivot的点所在位置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这同样适用于layout,下图设置成0,1.在中间位置添加panel,他会向下扩充,加上verticallayoutgroup和contentsizefitter两个组件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200420013535477","src":"/images/2019-08-10-ugui-RectTransform/image-20200420013535477.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设置成0.5,0.5.他会向上下扩充"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200420013708207","src":"/images/2019-08-10-ugui-RectTransform/image-20200420013708207.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"位置"},"children":[{"type":"text","value":"位置"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"position"}]},{"type":"text","value":"世界坐标是三维的全局坐标,一般作为基准坐标"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"localPosition"}]},{"type":"text","value":" 相对于父级物体的相对位置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"anchoredPosition"}]},{"type":"text","value":" 相对位置，但是相对的是自身的Anchor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"anchoredPosition3D"}]},{"type":"text","value":"  相对位置，但是相对的是自身的Anchor"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"position"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"localPosition"}]},{"type":"text","value":"，它们的值根其所属的Canvas的渲染模式有关。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在Screen Space——Overlay的模式下，由于Canvas的世界尺寸与其像素尺寸在数值上相等，因此其rectTransform的position与其在屏幕空间的坐标在数值上也相等。这种模式下，要获取某个RectTransform的屏幕坐标，直接使用position就可以。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在Screen Space——Camera的模式和World Space下，RectTransform的渲染与摄像机有关，在获取其屏幕坐标时，需要利用canvas.worldCamera，或者transform.TransformPoint等坐标转换函数进行坐标转换。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"anchoredPosition"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"anchoredPositoin3D"}]},{"type":"text","value":"都可以认为是以像素为单位。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当锚点全部重合时，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"anchoredPosition"}]},{"type":"text","value":"代表的就是自身Pivot到Anchor的向量。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-08-10-ugui-RectTransform/20171218185814418.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当Anchor不重合时,Pivot相对于四个锚点"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"中点"}]},{"type":"text","value":"的坐标"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-08-10-ugui-RectTransform/20171218185822581.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"offsetmin-和-offsetmax"},"children":[{"type":"text","value":"offsetMin 和 offsetMax"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"offsetMax"}]},{"type":"text","value":"是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RectTransform右上角"}]},{"type":"text","value":"相对于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"右上Anchor"}]},{"type":"text","value":"的距离；"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"offsetMin"}]},{"type":"text","value":"是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RectTransform左下角"}]},{"type":"text","value":"相对于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"左下Anchor"}]},{"type":"text","value":"的距离。"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"這就是為什麼 offsetMax 的值跟編輯器中 Top、Right 值剛好正負相反的原因。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/84177-3bd3ac83352a431b.webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/84177-6feb68ae67ceaae8.webp"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"rect"},"children":[{"type":"text","value":"rect"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果想要获取一个RectTransform的矩形信息，应该使用rectTransform.rect属性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"rect属性同样是一个计算出来的值，但是它表示的是该rectTransform对应的矩形的相关信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"rect 的 x 和 y 返回左下角相对于pivot的距离,w 和 h 返回本身的宽高."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意:"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Awake中Rectangle还没有初始化出来,所以不要在awake中获取rect"}]}]},{"type":"element","tag":"h3","props":{"id":"anchormin-和-anchormax"},"children":[{"type":"text","value":"anchorMin 和 anchorMax"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个是针对锚点的,锚点时相对于父容器定义的,所以这两个属性也是相对于父容器的.分别指锚点占父容器尺寸的百分比位置."}]},{"type":"element","tag":"h3","props":{"id":"sizedelta"},"children":[{"type":"text","value":"sizeDelta"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sizeDelta是个由引擎计算出来的值，这个值很容易被错误地使用。要正确地使用sizeDelta，就要先理解它是怎么算出来的。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The size of this RectTransform relative to the distances between the anchors.\nIf the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"sizeDelta"}]},{"type":"text","value":"是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"offsetMax-offsetMin"}]},{"type":"text","value":"的结果。在锚点全部重合的情况下，它的值就是面板上的*（Width，Height）*。在锚点完全不重合的情况下，它是相对于父矩形的尺寸。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个常见的错误是，当"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":"的锚点并非全部重合时，使用"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"sizeDelta"}]},{"type":"text","value":"作为这个"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":"的尺寸。此时拿到的结果一般来说并非预期的结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":" 宽和高真正的計算方法是:"}]},{"type":"element","tag":"pre","props":{"code":"GUI.Label(new Rect(20, 20, 600, 40), \"Rect : \" + rect.rect);\nvar width =  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;\nvar height = (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;\nGUI.Label(new Rect(20, 60, 600, 40), $\"width :{width} height:{height} \");\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GUI.Label(new Rect(20, 20, 600, 40), \"Rect : \" + rect.rect);\nvar width =  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;\nvar height = (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;\nGUI.Label(new Rect(20, 60, 600, 40), $\"width :{width} height:{height} \");\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"意思就是 sizeDelta 個別維度的值是跟兩錨點個別維度的差值相關，所以只有當兩錨點某的維度的值相等的時候，sizeDelta 在此維度的值才會剛好等於最後顯示的 size 大小。"}]},{"type":"element","tag":"h1","props":{"id":"代码修改坐标及大小"},"children":[{"type":"text","value":"代码修改坐标及大小"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.改变RectTransform的top"}]},{"type":"text","value":" 注意offsetMax`是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"RectTransform右上角"}]},{"type":"text","value":"相对于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"右上Anchor"}]},{"type":"text","value":"的距离,所以top的值应该是一个负值"}]},{"type":"element","tag":"pre","props":{"code":"GetComponent<RectTransform>().offsetMax = new Vector2(GetComponent<RectTransform>().offsetMax.x, top);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GetComponent<RectTransform>().offsetMax = new Vector2(GetComponent<RectTransform>().offsetMax.x, top);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2.改变RectTransform的bottom"}]}]},{"type":"element","tag":"pre","props":{"code":"GetComponent<RectTransform>().offsetMin = new Vector2(GetComponent<RectTransform>().offsetMin.x, bottom);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GetComponent<RectTransform>().offsetMin = new Vector2(GetComponent<RectTransform>().offsetMin.x, bottom);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3.改变RectTransform的width，height"}]},{"type":"text","value":" ,会根据上面的计算公式重新计算得出width和height,所以如果锚点不是在同一个点的情况下,你设置的值和实际的值是有很大区别的"}]},{"type":"element","tag":"pre","props":{"code":"GetComponent<RectTransform>().sizeDelta = new Vector2(width, height);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GetComponent<RectTransform>().sizeDelta = new Vector2(width, height);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1566677675284","src":"/images/2019-08-10-ugui-RectTransform/1566677675284.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1566678423941","src":"/images/2019-08-10-ugui-RectTransform/1566678423941.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当使用脚本直接改变大小后"}]},{"type":"element","tag":"pre","props":{"code":"rect.sizeDelta = new Vector2(750, 200);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"rect.sizeDelta = new Vector2(750, 200);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1566677736663","src":"/images/2019-08-10-ugui-RectTransform/1566677736663.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"var width =  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;\nvar height = (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var width =  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;\nvar height = (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他的宽和高经过了运算使其分别为1500,1534"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4.改变RectTransform的pos"}]},{"type":"text","value":" 注意anchoredPosition是相对于锚点的位置"}]},{"type":"element","tag":"pre","props":{"code":"GetComponent<RectTransform>().anchoredPosition3D = new Vector3(posx,posy,posz);\nGetComponent<RectTransform>().anchoredPosition = new Vector2(posx,posy);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GetComponent<RectTransform>().anchoredPosition3D = new Vector3(posx,posy,posz);\nGetComponent<RectTransform>().anchoredPosition = new Vector2(posx,posy);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**5.使用SetSizeWithCurrentAnchors函数来进行设定，其中Horizontal和Vertical分别对应宽和高。此函数受当前锚点和中心点的影响。**由于会受到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"povit"}]},{"type":"text","value":"的影响设置的高度是根据povit进行上下缩小的"}]},{"type":"element","tag":"pre","props":{"code":"var rt = gameObject.GetComponent<RectTransform>();\nrt.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 100);\nrt.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 30);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var rt = gameObject.GetComponent<RectTransform>();\nrt.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 100);\nrt.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 30);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面同样的示例:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1566678433363","src":"/images/2019-08-10-ugui-RectTransform/1566678433363.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 200);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 200);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1566678329701","src":"/images/2019-08-10-ugui-RectTransform/1566678329701.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到它围绕着"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"pivot"}]},{"type":"text","value":"上下都缩减了180"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"6.使用SetInsetAndSizeFromParentEdge函数来进行设定。此函数不受锚点和中心的影响，其中第一个参数代表对齐方式，第二个参数为距离边界的距离，第三个参数为宽度。"}]}]},{"type":"element","tag":"pre","props":{"code":"var rt = gameObject.GetComponent<RectTransform>();\nrt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Right, 0, 100);\nrt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Bottom, 0, 30);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var rt = gameObject.GetComponent<RectTransform>();\nrt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Right, 0, 100);\nrt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Bottom, 0, 30);\n"}]}]},{"type":"element","tag":"h1","props":{"id":"recttransform的一些其他操做"},"children":[{"type":"text","value":"recttransform的一些其他操做"}]},{"type":"element","tag":"h3","props":{"id":"blue-print-mode藍圖模式-raw-edit-mode原始编辑模式"},"children":[{"type":"text","value":"Blue Print Mode(藍圖模式) 、 Raw Edit Mode(原始编辑模式)"}]},{"type":"element","tag":"h2","props":{"id":""},"children":[{"type":"element","tag":"img","props":{"alt":"BluePrint_RawEdit_01","src":"/images/2019-08-10-ugui-RectTransform/BluePrint_RawEdit_01.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"blue-print-mode-藍圖模式"},"children":[{"type":"text","value":"Blue Print Mode (藍圖模式)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"忽略了物體的 Local Rotation 和 Local Scale，方便以原來的旋轉與大小調整物體"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-10-ugui-RectTransform/BluePrintMode_m2-1024x711.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"raw-edit-mode-原始编辑模式"},"children":[{"type":"text","value":"Raw Edit Mode (原始编辑模式)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Inspector 中調整 Pivot 和 Anchor 時，物體會維持目前的位置與大小(Inspector 中數值部分)，調整情形如下，請注意數值部分"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inspector 中調整  Pivot"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"RawEditMode_02","src":"/images/2019-08-10-ugui-RectTransform/RawEditMode_02.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inspector 中調整  Anchor"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"RawEditMode_01","src":"/images/2019-08-10-ugui-RectTransform/RawEditMode_01.gif"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"參考資料"},"children":[{"type":"text","value":"參考資料"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://docs.unity3d.com/Manual/UIBasicLayout.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity – Manual: Basic Layout"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://tsubakit1.hateblo.jp/entry/2014/12/19/033946","rel":["nofollow"]},"children":[{"type":"text","value":"UnityのuGUIのレイアウト調整機能について解説してみる（RectTransform入門）"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"在編輯器中快速設定-recttransform","depth":2,"text":"在編輯器中快速設定 RectTransform"},{"id":"recttransform-的控制精髓錨點們-anchor-points","depth":2,"text":"RectTransform 的控制精髓：錨點們 Anchor Points","children":[{"id":"a-當兩錨點-x-y-維度的值都相等時","depth":3,"text":"A. 當兩錨點 x, y 維度的值都相等時："},{"id":"b-當兩錨點-x-維度的值不相等y-維度值相等時","depth":3,"text":"B. 當兩錨點 x 維度的值不相等、y 維度值相等時："},{"id":"c-當兩錨點-x-維度的值相等y-維度值不相等時","depth":3,"text":"C. 當兩錨點 x 維度的值相等、y 維度值不相等時："},{"id":"d-當兩錨點-x-y-維度的值都不相等時","depth":3,"text":"D. 當兩錨點 x, y 維度的值都不相等時："},{"id":"pivot","depth":3,"text":"pivot"},{"id":"位置","depth":3,"text":"位置"},{"id":"offsetmin-和-offsetmax","depth":3,"text":"offsetMin 和 offsetMax"},{"id":"rect","depth":3,"text":"rect"},{"id":"anchormin-和-anchormax","depth":3,"text":"anchorMin 和 anchorMax"},{"id":"sizedelta","depth":3,"text":"sizeDelta"},{"id":"blue-print-mode藍圖模式-raw-edit-mode原始编辑模式","depth":3,"text":"Blue Print Mode(藍圖模式) 、 Raw Edit Mode(原始编辑模式)"}]},{"id":"","depth":2,"text":"","children":[{"id":"參考資料","depth":3,"text":"參考資料"}]}]}},"_type":"markdown","_id":"content:unity:2019-08-10-ugui-RectTransform.md","_source":"content","_file":"unity/2019-08-10-ugui-RectTransform.md","_extension":"md","date":"2019-08-10"},{"_path":"/unity/2019-08-11-ugui-eventmanager","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"一次精通 eventmanager","description":"我们先来看看eventmanager之前unity处理事件的方法,首当其冲的就是MonoBehavior上的事件回调，可以参看MonoBehaviour文档。这是一系列的OnMouse开头的回调函数。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"onmouse事件"},"children":[{"type":"text","value":"OnMouse事件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先来看看eventmanager之前unity处理事件的方法,首当其冲的就是MonoBehavior上的事件回调，可以参看"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/MonoBehaviour.html","rel":["nofollow"]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"文档。这是一系列的OnMouse开头的回调函数。"}]},{"type":"element","tag":"pre","props":{"code":"OnMouseDown\nOnMouseDrag\nOnMouseEnter\nOnMouseExit\nOnMouseOver\nOnMouseUp\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"OnMouseDown\nOnMouseDrag\nOnMouseEnter\nOnMouseExit\nOnMouseOver\nOnMouseUp\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个处理方式有以下几个特点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MonoBehavior所在的GameObject需要有Collider碰撞组件，并且Physics.queriesHitTriggers设置为True，这个在Edit -> Physics Settings -> Physics or Physics2D中设置。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"或者MonoBehavior所在的GameObject存在GUIElement。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"OnMouse处理函数可以是协程。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameObject所有MonoBehavior实现OnMouse的函数都会调用。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Collider或GUIElement的层级顺序，会遮挡事件的传递。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照官方的解释，这是GUI事件的一部分，参看"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/EventFunctions.html","rel":["nofollow"]},"children":[{"type":"text","value":"EventFunctions"}]},{"type":"text","value":"。设计的初衷也是为了GUI服务的。参看"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/ExecutionOrder.html","rel":["nofollow"]},"children":[{"type":"text","value":"ExecutionOrder"}]},{"type":"text","value":"最后的unity执行流程图，会发现OnMouse事件是一个独立的Input Event。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-11-ugui-eventmanager/20171106145111819.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到，OnMouse事件在，Physics事件之后，Update之前，记住这个顺序，后面会用到。并且，这是引擎本身回调的，就引擎使用而言可以看成是，消息驱动。至于引擎的实现，可是轮询也可以是消息驱动。"}]},{"type":"element","tag":"h4","props":{"id":"在update中輪詢input物件"},"children":[{"type":"text","value":"在Update中輪詢Input物件"}]},{"type":"element","tag":"pre","props":{"code":"public class ExampleClass : MonoBehaviour\n{ \n    public void Update() \n    { \n       if (Input.GetButtonDown(\"Fire1\")) \n       { \n            Debug.Log(Input.mousePosition); \n       } \n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class ExampleClass : MonoBehaviour\n{ \n    public void Update() \n    { \n       if (Input.GetButtonDown(\"Fire1\")) \n       { \n            Debug.Log(Input.mousePosition); \n       } \n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是官方的例子，Input拥有各种输入设备的数据信息。每一帧不断的检测，查看有没有需要处理的输入信息，利用GameObject本身的层级顺序来控制Update的调用顺序，从而控制了Input的处理顺序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Input的信息由引擎自己设置的，明显Unity需要实现不同平台的事件处理，然后对Input进行设置。另外有一个InputManager面板用来配置Input相关属性的，在Edit -> Physics Settings -> Input中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由前面的执行流程图可知，OnMouse事件会在Update之前调用，当然我们也可以在OnMouse中使用Input，这样就变成了消息驱动，而不是轮询了。但这样的缺点是，事件必须由touch或pointer碰撞触发，比如键盘或控制器按钮的事件就没有办法捕获了。"}]},{"type":"element","tag":"h1","props":{"id":"eventsystem"},"children":[{"type":"text","value":"EventSystem"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"EventSystem组件主要负责处理输入、射线投射以及发送事件。一个场景中只能有一个EventSystem组件，并且需要BaseInputModule类型组件的协助才能工作。EventSystem在一开始的时候会把自己所属对象下的BaseInputModule类型组件加到一个内部列表，并且在每个Update周期通过接口UpdateModules接口调用这些基本输入模块的UpdateModule接口，然后BaseInputModule会在UpdateModule接口中将自己的状态修改成'Updated'，之后BaseInputModule的Process接口才会被调用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BaseInputModule是一个基类模块，负责发送输入事件（点击、拖拽、选中等）到具体对象。EventSystem下的所有输入模块都必须继承自BaseInputModule组件。StandaloneInputModule和TouchInputModule组件是系统提供的标准输入模块和触摸输入模块，我们可以通过继承BaseInputModule实现自己的输入模块。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BaseRaycaster也是一个基类，前面说的输入模块要检测到鼠标事件必须有射线投射组件才能确定目标对象。系统实现的射线投射类组件有PhysicsRaycaster, Physics2DRaycaster, GraphicRaycaster。这个模块也是可以自己继承BaseRaycaster实现个性化定制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"总的来说，EventSystem负责管理，BaseInputModule负责输入，BaseRaycaster负责确定目标对象，目标对象负责接收事件并处理，然后一个完整的事件系统就有了。"}]}]},{"type":"element","tag":"h1","props":{"id":"eventsystem與onmouse的區別"},"children":[{"type":"text","value":"EventSystem與OnMouse的區別"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"OnMouse 会先于 EventSystem 触发。因为EventSystem的源码显示，其在Update中去轮询检测处理Input的输入。而OnMouse事件先于Update调用。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"OnMouse脚本需要在同一个GameObject上挂载Collider才能检测。EventSystem的脚本会根据子节点的Collider来触发(平行节点不行)。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Rigidbody有个特点，会把子节点所有的Collider统一检测和处理。也就是说，OnMouse脚本与RigidBody在一起就可以检测所有的子节点Collider，而不再需要同级的Collider。而EventSystem的脚本则不依赖于Rigidbody，都可以检测子节点的Collider。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"OnMouse依赖于Tag为MainCamera相机的Culling Mask来过滤射线。EventSystem则是依赖挂载Physics Raycaster的相机。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，当在有Collider的子节点都挂载OnMouse或EventSystem事件的时候，只会触发一次事件。但在同一个GameObject上挂载多个脚本，就会触发多次。"}]},{"type":"element","tag":"h1","props":{"id":"unity-raycasters-和事件处理"},"children":[{"type":"text","value":"Unity Raycasters 和事件处理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Unity Raycasters 中有三种类型的 Raycasters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Physics 2D Raycaster - 用于检测 2D 物体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Physics Raycaster - 用于检测 3D 物体"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raycast 在 Event System 流程中所处的位置大致如下图:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"unity_event_system_raycaster.png","src":"/images/2019-08-11-ugui-eventmanager/unity_event_system_raycaster.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"unity的事件处理"},"children":[{"type":"text","value":"unity的事件处理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当 Event System 处理输入事件并找到合适的接收者，将该接收者作为参数执行 ExecuteEvents 类中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Execute"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ExecuteHierarchy"}]},{"type":"text","value":" 方法；如果此时该接收对象 GameObject 绑定了 EventTrigger 组件，由于 EventTrigger 类实现了所有常用的 UI 事件接口(即实现了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IEventSystemHandler"}]},{"type":"text","value":" 接口)，因此会执行 EventTrigger 类中相应事件接口对应的方法，转而执行 EventTrigger 类的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Execute"}]},{"type":"text","value":" 方法，最终回调在编辑器中设定的方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以如果当一个点击事件被触发,首先会拿到射线检测返回的gameobject，然后搜索当前的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"gameobejct以及其父节点"}]},{"type":"text","value":"上面是否有实现了IPointerDownHandler的接口的控件，如果有实现了的就把newPressed赋值为这个控件的gameobject，如果没有，就去搜索实现了IPointerClickHandler这个接口的控件，如果没有在自身上找到的话，会依次地向父节点层层搜索，直到找到为止，然后依然是把newPressed赋值为这个控件的gameobject。接着会按照类似的方式去搜索自身以及父节点上是否有实现了IDragHandler的组件，如果有的话紧接着便会去触发OnPointerDown和OnDrag方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当鼠标按下并抬起的时候，首先会触发IPointerUpHandler接口中的函数OnPointerUp()，然后会再次搜索当前gameobject以及其父节点上是否有实现了IPointerClickHandler接口的控件，如果有的的话，会和之前存下来的newPressd进行比较，看两者是否为同一个gameobject。如果两者为同一个gameobject的话就会触发Click事件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此我们需要注意，如果一个物体没有父节点的话，那么只实现IPointerClickHandler接口便是可以接收到点击事件的。如果他有父节点，父节点挂载的脚本也是只实现IPointerClickHandler接口的话，点击事件也是可以接收到的。但是如果父节点实现了IPointerDownHandler和IPointerClickHandler接口，子节点只实现IPointerClickHandler接口的话，两者便会都接收不到点击事件，需要子节点也实现IPointerDownHandler这个接口才行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"unity_event_trigger_2.jpeg","src":"/images/2019-08-11-ugui-eventmanager/unity_event_trigger_2.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"事件透传"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果事件被接收后,就不会再被父节点的监听处理,如果需要,则得使用message手动触发"}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n \npublic class Test : MonoBehaviour,IPointerClickHandler ,IPointerDownHandler,IPointerUpHandler\n{ \n \n    //监听按下\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.pointerDownHandler);\n    }\n \n    //监听抬起\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.pointerUpHandler);\n    }\n \n    //监听点击\n    public void OnPointerClick(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.submitHandler);\n        PassEvent(eventData,ExecuteEvents.pointerClickHandler);\n    }\n \n \n    //把事件透下去\n    public void  PassEvent<T>(PointerEventData data,ExecuteEvents.EventFunction<T> function)\n        where T : IEventSystemHandler\n    {\n        List<RaycastResult> results = new List<RaycastResult>();\n        EventSystem.current.RaycastAll(data, results); \n        GameObject current = data.pointerCurrentRaycast.gameObject ;\n        for(int i =0; i< results.Count;i++)\n        {\n            if(current!= results[i].gameObject)\n            {\n                ExecuteEvents.Execute(results[i].gameObject, data,function);\n                //RaycastAll后ugui会自己排序，如果你只想响应透下去的最近的一个响应，这里ExecuteEvents.Execute后直接break就行。\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\nusing System.Collections.Generic;\n \npublic class Test : MonoBehaviour,IPointerClickHandler ,IPointerDownHandler,IPointerUpHandler\n{ \n \n    //监听按下\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.pointerDownHandler);\n    }\n \n    //监听抬起\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.pointerUpHandler);\n    }\n \n    //监听点击\n    public void OnPointerClick(PointerEventData eventData)\n    {\n        PassEvent(eventData,ExecuteEvents.submitHandler);\n        PassEvent(eventData,ExecuteEvents.pointerClickHandler);\n    }\n \n \n    //把事件透下去\n    public void  PassEvent<T>(PointerEventData data,ExecuteEvents.EventFunction<T> function)\n        where T : IEventSystemHandler\n    {\n        List<RaycastResult> results = new List<RaycastResult>();\n        EventSystem.current.RaycastAll(data, results); \n        GameObject current = data.pointerCurrentRaycast.gameObject ;\n        for(int i =0; i< results.Count;i++)\n        {\n            if(current!= results[i].gameObject)\n            {\n                ExecuteEvents.Execute(results[i].gameObject, data,function);\n                //RaycastAll后ugui会自己排序，如果你只想响应透下去的最近的一个响应，这里ExecuteEvents.Execute后直接break就行。\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"事件忽略"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果需要当前节点及子节点都不响应UI事件"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"勾选Raycast Targe"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在当前节点上添加一个组件CanvasGroup，然后取消其Interactable和Blocks Raycasts的勾选"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加脚本"}]}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\npublic class TouchIgnore : MonoBehaviour, ICanvasRaycastFilter\n{\n    public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)\n    {\n        return false;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\npublic class TouchIgnore : MonoBehaviour, ICanvasRaycastFilter\n{\n    public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)\n    {\n        return false;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"事件阻止"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"父子之间阻止向父级传递事件,只要在该对象加上一个EventTrigger起就可以了,代表这个事件已经被处理了."}]},{"type":"element","tag":"pre","props":{"code":" this.GameObject.GetOrAddComponent<EventTrigger>()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" this.GameObject.GetOrAddComponent<EventTrigger>()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如一个案例,点击最顶级的遮罩(白色部分)窗口关闭,但是点击到窗口内部(红色部分)不做处理\n"},{"type":"element","tag":"img","props":{"alt":"image-20200727011714966","src":"/images/2019-08-11-ugui-eventmanager/image-20200727011714966.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ugui事件和射线穿透的问题"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"eventsystem也是向场景发送射线,然后找到"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"第一个"}]},{"type":"text","value":"触碰的有"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Raycast Target"}]},{"type":"text","value":"的game object.然后在向这个gameobject的父级去找."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有如果ui即使全屏了,但是没有设置Raycast Target,仍然会穿透ui.射线会检测到下面的立方体,如图:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200727010842873","src":"/images/2019-08-11-ugui-eventmanager/image-20200727010842873.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"事件和handler的连接触发方式"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于某些ui组件，可以直接设置其对自己产生的事件的handler，如button的onpointerclick"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于任何ui组件，都可以使用eventtrigger这个component，这个trigger放置在产生事件的UI组件上，里面包含了一个事件的类型，以及这个类型关联的处理函数，处理函数可以使用两种函数参数，一种是使用int string简单类型，一种是使用BaseEventData类型，因为当event发生时，会跟随者把这个事件包装成一个PointerEventData类型的参数送进来，里面包含ui事件的详细信息，包括鼠标在哪，而对于前一种简单类型，在编辑器上可以填写当事件发生时传什么参数，这就好比qt的signal和slot连接。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"强制让某个事件发生在某个handler上（也就是强制某个handler执行）：调用ExecuteEvents.Execute<"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ICustomMessageTarget"}]},{"type":"text","value":">(target, null, (x,y)=>x.Message1());"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"这个调用将执行target身上所有继承 了ICustomMessageTarget接口的mono的Message1函数，个人认为这个和给target发送Message1 的sendmessage没什么区别，可能是我还没有立即好这个接口。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"自定义事件处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"建立一個 Script，繼承 Event Interfaces，這裡是IPointerDownHandler(點下事件)，"},{"type":"element","tag":"a","props":{"href":"http://docs.unity3d.com/Manual/SupportedEvents.html","rel":["nofollow"]},"children":[{"type":"text","value":"看更多 Event 請點我"}]}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing UnityEngine.EventSystems;\n \npublic class EventTest : MonoBehaviour, IPointerDownHandler\n{\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        print(gameObject.name);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing UnityEngine.EventSystems;\n \npublic class EventTest : MonoBehaviour, IPointerDownHandler\n{\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        print(gameObject.name);\n    }\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"阻止手动发送射线穿透ugui问题"},"children":[{"type":"text","value":"阻止手动发送射线穿透ugui问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI 提供了一个检测是否点击在UI上的方法\nEventSystem.current.IsPointerOverGameObject();\n在EventSystem的标准输入Standalone Input Model下是正常的，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是在Touch Input Module输入模式下不正常"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考网络资料，解决办法(直接上"},{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/andyhebear/article/details/51433748","rel":["nofollow"]},"children":[{"type":"text","value":"源码"}]},{"type":"text","value":"):"}]},{"type":"element","tag":"pre","props":{"code":" using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\n\npublic class PointerCheck : MonoBehaviour\n{\n //UGUI 提供了一个检测是否点击在UI上的方法\n    //EventSystem.current.IsPointerOverGameObject();\n    //但是该方法在PC上检测正常，结果拿到Android真机测试上，永远检测不到。\n    //方法一， 使用该方法的另一个重载方法，使用时给该方法传递一个整形参数\n    // 该参数即使触摸手势的 id\n    // int id = Input.GetTouch(0).fingerId;\n    //public static bool IsPointerOverGameObject(int fingerID) {\n    //    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(fingerID);//移动输入模式下一样不行\n \n    //}\n    public static bool IsPointerOverGameObject() {\n        //if (Input.touchCount > 0) {\n                        \n        //    int id = Input.GetTouch(0).fingerId;\n        //    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(id);//安卓机上不行\n        //}\n        //else {\n            //return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();\n            PointerEventData eventData = new PointerEventData(UnityEngine.EventSystems.EventSystem.current);\n            eventData.pressPosition = Input.mousePosition;\n            eventData.position = Input.mousePosition;\n \n            List<RaycastResult> list = new List<RaycastResult>();\n            UnityEngine.EventSystems.EventSystem.current.RaycastAll(eventData, list);\n            //Debug.Log(list.Count);\n            return list.Count > 0;\n       // }\n    }\n    //方法二 通过UI事件发射射线\n    //是 2D UI 的位置，非 3D 位置\n    public static bool IsPointerOverGameObject(Vector2 screenPosition) {\n        //实例化点击事件\n        PointerEventData eventDataCurrentPosition = new PointerEventData(UnityEngine.EventSystems.EventSystem.current);\n        //将点击位置的屏幕坐标赋值给点击事件\n        eventDataCurrentPosition.position = new Vector2(screenPosition.x, screenPosition.y);\n \n        List<RaycastResult> results = new List<RaycastResult>();\n        //向点击处发射射线\n        EventSystem.current.RaycastAll(eventDataCurrentPosition, results);\n \n        return results.Count > 0;\n    }\n    //方法三 通过画布上的 GraphicRaycaster 组件发射射线\n    public static bool IsPointerOverGameObject(Canvas canvas, Vector2 screenPosition) {\n        //实例化点击事件\n        PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n        //将点击位置的屏幕坐标赋值给点击事件\n        eventDataCurrentPosition.position = screenPosition;\n        //获取画布上的 GraphicRaycaster 组件\n        GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent<GraphicRaycaster>();\n \n        List<RaycastResult> results = new List<RaycastResult>();\n        // GraphicRaycaster 发射射线\n        uiRaycaster.Raycast(eventDataCurrentPosition, results);\n \n        return results.Count > 0;\n    }\n// For Details => https://blog.csdn.net/andyhebear/article/details/51433748\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\n\npublic class PointerCheck : MonoBehaviour\n{\n //UGUI 提供了一个检测是否点击在UI上的方法\n    //EventSystem.current.IsPointerOverGameObject();\n    //但是该方法在PC上检测正常，结果拿到Android真机测试上，永远检测不到。\n    //方法一， 使用该方法的另一个重载方法，使用时给该方法传递一个整形参数\n    // 该参数即使触摸手势的 id\n    // int id = Input.GetTouch(0).fingerId;\n    //public static bool IsPointerOverGameObject(int fingerID) {\n    //    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(fingerID);//移动输入模式下一样不行\n \n    //}\n    public static bool IsPointerOverGameObject() {\n        //if (Input.touchCount > 0) {\n                        \n        //    int id = Input.GetTouch(0).fingerId;\n        //    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(id);//安卓机上不行\n        //}\n        //else {\n            //return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();\n            PointerEventData eventData = new PointerEventData(UnityEngine.EventSystems.EventSystem.current);\n            eventData.pressPosition = Input.mousePosition;\n            eventData.position = Input.mousePosition;\n \n            List<RaycastResult> list = new List<RaycastResult>();\n            UnityEngine.EventSystems.EventSystem.current.RaycastAll(eventData, list);\n            //Debug.Log(list.Count);\n            return list.Count > 0;\n       // }\n    }\n    //方法二 通过UI事件发射射线\n    //是 2D UI 的位置，非 3D 位置\n    public static bool IsPointerOverGameObject(Vector2 screenPosition) {\n        //实例化点击事件\n        PointerEventData eventDataCurrentPosition = new PointerEventData(UnityEngine.EventSystems.EventSystem.current);\n        //将点击位置的屏幕坐标赋值给点击事件\n        eventDataCurrentPosition.position = new Vector2(screenPosition.x, screenPosition.y);\n \n        List<RaycastResult> results = new List<RaycastResult>();\n        //向点击处发射射线\n        EventSystem.current.RaycastAll(eventDataCurrentPosition, results);\n \n        return results.Count > 0;\n    }\n    //方法三 通过画布上的 GraphicRaycaster 组件发射射线\n    public static bool IsPointerOverGameObject(Canvas canvas, Vector2 screenPosition) {\n        //实例化点击事件\n        PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n        //将点击位置的屏幕坐标赋值给点击事件\n        eventDataCurrentPosition.position = screenPosition;\n        //获取画布上的 GraphicRaycaster 组件\n        GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent<GraphicRaycaster>();\n \n        List<RaycastResult> results = new List<RaycastResult>();\n        // GraphicRaycaster 发射射线\n        uiRaycaster.Raycast(eventDataCurrentPosition, results);\n \n        return results.Count > 0;\n    }\n// For Details => https://blog.csdn.net/andyhebear/article/details/51433748\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"网友解决办法："}]},{"type":"element","tag":"pre","props":{"code":"      /// <summary>\n     /// Cast a ray to test if Input.mousePosition is over any UI object in EventSystem.current. This is a replacement\n     /// for IsPointerOverGameObject() which does not work on Android in 4.6.0f3\n     /// </summary>\n     private static bool IsPointerOverUIObject()\n     {\n         if (EventSystem.current == null)\n             return false;\n \n         // Referencing this code for GraphicRaycaster https://gist.github.com/stramit/ead7ca1f432f3c0f181f\n         // the ray cast appears to require only eventData.position.\n         PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n         eventDataCurrentPosition.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);\n \n         List<RaycastResult> results = new List<RaycastResult>();\n         EventSystem.current.RaycastAll(eventDataCurrentPosition, results);\n \n         return results.Count > 0;\n     }\n \n     /// <summary>\n     /// Cast a ray to test if screenPosition is over any UI object in canvas. This is a replacement\n     /// for IsPointerOverGameObject() which does not work on Android in 4.6.0f3\n     /// </summary>\n     private bool IsPointerOverUIObject(Canvas canvas, Vector2 screenPosition)\n     {\n         if (EventSystem.current == null)\n             return false;\n \n         // Referencing this code for GraphicRaycaster https://gist.github.com/stramit/ead7ca1f432f3c0f181f\n         // the ray cast appears to require only eventData.position.\n         PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n         eventDataCurrentPosition.position = screenPosition;\n \n         GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent<GraphicRaycaster>();\n         List<RaycastResult> results = new List<RaycastResult>();\n         uiRaycaster.Raycast(eventDataCurrentPosition, results);\n         return results.Count > 0;\n     }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"      /// <summary>\n     /// Cast a ray to test if Input.mousePosition is over any UI object in EventSystem.current. This is a replacement\n     /// for IsPointerOverGameObject() which does not work on Android in 4.6.0f3\n     /// </summary>\n     private static bool IsPointerOverUIObject()\n     {\n         if (EventSystem.current == null)\n             return false;\n \n         // Referencing this code for GraphicRaycaster https://gist.github.com/stramit/ead7ca1f432f3c0f181f\n         // the ray cast appears to require only eventData.position.\n         PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n         eventDataCurrentPosition.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);\n \n         List<RaycastResult> results = new List<RaycastResult>();\n         EventSystem.current.RaycastAll(eventDataCurrentPosition, results);\n \n         return results.Count > 0;\n     }\n \n     /// <summary>\n     /// Cast a ray to test if screenPosition is over any UI object in canvas. This is a replacement\n     /// for IsPointerOverGameObject() which does not work on Android in 4.6.0f3\n     /// </summary>\n     private bool IsPointerOverUIObject(Canvas canvas, Vector2 screenPosition)\n     {\n         if (EventSystem.current == null)\n             return false;\n \n         // Referencing this code for GraphicRaycaster https://gist.github.com/stramit/ead7ca1f432f3c0f181f\n         // the ray cast appears to require only eventData.position.\n         PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);\n         eventDataCurrentPosition.position = screenPosition;\n \n         GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent<GraphicRaycaster>();\n         List<RaycastResult> results = new List<RaycastResult>();\n         uiRaycaster.Raycast(eventDataCurrentPosition, results);\n         return results.Count > 0;\n     }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"message-system改进的消息系统"},"children":[{"type":"text","value":"Message System（改进的消息系统）"}]},{"type":"element","tag":"h3","props":{"id":"传统方式进行-message-通信"},"children":[{"type":"text","value":"传统方式进行 Message 通信"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"传统消息通信，通常我们会使用 GameObject 类中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SendMessage"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SendMessageUpwards"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BroadcastMessage"}]},{"type":"text","value":" 方法"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"SendMessage"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"SendMessageUpwards"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"BroadcastMessage"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"自身节点"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"√"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"√"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"√"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"兄弟节点"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"父/祖先节点"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"√"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"子/孙节点"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"×"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"√"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"messaging-system"},"children":[{"type":"text","value":"Messaging System"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 UGUI 的 Event System 中，所有的事件通信都是用了 Messaging System 来实现，它也解决了传统方式进行 Message 通信中可能会遇到的一些问题。下面就来让我们好好看看这套 Messaging System。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，要想让 Component 能够从 Messaging System 接收消息，Component 要实现 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IEventSystemHandler"}]},{"type":"text","value":" 这个接口。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IPointerDownHandler"}]},{"type":"text","value":"等都继承了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IEventSystemHandler"}]},{"type":"text","value":" 接口"}]},{"type":"element","tag":"pre","props":{"code":"public interface ICustomMessageTarget : IEventSystemHandler\n{\n    // functions that can be called via the messaging system\n    void Message1();\n    void Message2();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public interface ICustomMessageTarget : IEventSystemHandler\n{\n    // functions that can be called via the messaging system\n    void Message1();\n    void Message2();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现这个接口 , 把这个脚本挂在某个物体上，这里假设为物体AAA"}]},{"type":"element","tag":"pre","props":{"code":"public class CustomMessageTarget : MonoBehaviour, ICustomMessageTarget\n{\n    public void Message1()\n    {\n        Debug.Log (\"Message 1 received\");\n    }\n\n    public void Message2()\n    {\n        Debug.Log (\"Message 2 received\");\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class CustomMessageTarget : MonoBehaviour, ICustomMessageTarget\n{\n    public void Message1()\n    {\n        Debug.Log (\"Message 1 received\");\n    }\n\n    public void Message2()\n    {\n        Debug.Log (\"Message 2 received\");\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在任何脚本中使用ExecuteEvents静态类发送Message，来执行接口中定义的方法"}]},{"type":"element","tag":"pre","props":{"code":"ExecuteEvents.Execute<ICustomMessageTarget>(target, null, (x,y)=>x.Message1());\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ExecuteEvents.Execute<ICustomMessageTarget>(target, null, (x,y)=>x.Message1());\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Excute泛型方法，有3个参数，第一个参数是发送message的gameobject对象，只有当对象上有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IEventSystemHandler"}]},{"type":"text","value":"实现类的时候才可以，这个例子中自然就是AAA物体。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ExecuteEvents静态类还有其他方法："}]},{"type":"element","tag":"pre","props":{"code":"EventSystems.ExecuteEvents.CanHandleEvent    判断给定的gameobejct是否能处理这个事件\nEventSystems.ExecuteEvents.Execute     执行事件\nEventSystems.ExecuteEvents.ExecuteHierarchy  是递归寻找适合的gameobject，并执行事件 \nEventSystems.ExecuteEvents.GetEventHandler   \nEventSystems.ExecuteEvents.ValidateEventData   \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EventSystems.ExecuteEvents.CanHandleEvent    判断给定的gameobejct是否能处理这个事件\nEventSystems.ExecuteEvents.Execute     执行事件\nEventSystems.ExecuteEvents.ExecuteHierarchy  是递归寻找适合的gameobject，并执行事件 \nEventSystems.ExecuteEvents.GetEventHandler   \nEventSystems.ExecuteEvents.ValidateEventData   \n"}]}]},{"type":"element","tag":"h1","props":{"id":"eventsystem-处理physics"},"children":[{"type":"text","value":"eventsystem 处理Physics"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，我们看一个官方文档的说明 "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/Raycasters.html","rel":["nofollow"]},"children":[{"type":"text","value":"Raycasters"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If multiple Raycasters are used then they will all have casting happen against them and the results will be sorted based on distance to the elements."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当多个Raycaster被使用的时候，结果会按照元素之间的距离排序，然后事件就会按照这个顺序被传递。"}]},{"type":"element","tag":"h2","props":{"id":"第一步"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"第一步"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-11-ugui-eventmanager/v2-733f4cd159b935aeb26518e97b902a7d_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在相机上添加Physics2DRaycaster，我这里只需要对Physics2D检测，如果是3D就用Physics3DRaycaster。Physics Raycaster 依赖一个相机，如果没有会自动添加。我挂载在相机上，射线检测就会依赖这个相机。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里我用在GameCamera上面，当然也可以放在UICamera上面，Physics Raycaster挂载在哪个相机上面，射线就依赖这个相机的Culling Mask。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外需要注意的是，Physics Raycaster所在的相机层级，也就是Depth，会影响到事件传递的顺序。比如，UI Camera层级高于Game Camera，就会永远先出发UI上的事件。同样，OnMouse事件会默认依赖Main Camera的层级。"}]},{"type":"element","tag":"h2","props":{"id":"第二步"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"第二步"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"给需要碰撞检测的GameObject，添加Collider和EventSystem的事件处理回调接口。注意GameObject的Layer也要与Camera和Raycaster一致，才能正确被检测到。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-11-ugui-eventmanager/v2-3c1713c6226906982501aa7c4dd8252d_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"事件接口实现脚本(图中的Test)需要Collider，事件才能正确回调，并且GameObject和相机的距离决定了Collider的层级，也就是事件阻挡关系。"}]},{"type":"element","tag":"h2","props":{"id":"第三步"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"第三步"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样一来，EventSystem的SupportEvents的接口全部被应用到了Physics上面。也就不再需要自己手动去调用射线去检测Physics碰撞了。那么，还隐含着一个事情就是，EventSystem的IsPointerOverGameObject()就无法在判断对UI的点击了。因为现在点击到Physics也会让这个函数返回True。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"unity的事件处理","depth":3,"text":"unity的事件处理"},{"id":"阻止手动发送射线穿透ugui问题","depth":2,"text":"阻止手动发送射线穿透ugui问题","children":[{"id":"传统方式进行-message-通信","depth":3,"text":"传统方式进行 Message 通信"},{"id":"messaging-system","depth":3,"text":"Messaging System"}]},{"id":"第一步","depth":2,"text":"第一步"},{"id":"第二步","depth":2,"text":"第二步"},{"id":"第三步","depth":2,"text":"第三步"}]}},"_type":"markdown","_id":"content:unity:2019-08-11-ugui-eventmanager.md","_source":"content","_file":"unity/2019-08-11-ugui-eventmanager.md","_extension":"md","date":"2019-08-11"},{"_path":"/unity/2019-08-12-ugui-eventsystem-sourcecode","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"ugui的eventsystem源码解读","description":"为什么想看看事件系统的实现很简单，策划又提奇奇怪怪的需求了！比如这些事件要穿透啦，那些事件要做特殊处理啦！之类的……依旧先贴出源码地址：Unity-Technologies / UI - Bitbucketbitbucket.org入手点好那么我们从何处入手呢？当然是我们的EventTrigger了！我们都知道，我们可以通过实现以下接口来实现事件捕捉：大家都爱用的EventTrigger具体怎么做我想大家已经明白了，也就是实现上线的接口中的函数，例如我要监听点击事件我就实现一下IPointerClickHandler然后挂在物体上就好了。这个技巧在很早的时候我在雨松的文章第一次看到，那时候也是","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"为什么想看看事件系统的实现"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"为什么想看看事件系统的实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很简单，策划又提奇奇怪怪的需求了！比如这些事件要穿透啦，那些事件要做特殊处理啦！之类的……"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"依旧先贴出源码地址："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//bitbucket.org/Unity-Technologies/ui","rel":["nofollow"]},"children":[{"type":"text","value":"Unity-Technologies / UI - Bitbucketbitbucket.org"}]}]},{"type":"element","tag":"h2","props":{"id":"入手点"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"入手点"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好那么我们从何处入手呢？当然是我们的EventTrigger了！我们都知道，我们可以通过实现以下接口来实现事件捕捉："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-fed09bee3103f18eb1ee5938dbfdc812_hd.jpg"},"children":[]},{"type":"text","value":"大家都爱用的EventTrigger"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体怎么做我想大家已经明白了，也就是实现上线的接口中的函数，例如我要监听点击事件我就实现一下IPointerClickHandler然后挂在物体上就好了。这个技巧在很早的时候我在雨松的文章第一次看到，那时候也是4.6时期UGUI刚出来的时候发现的。由于和当初的NGUI很像所以被大家广泛使用，但是也会发现如果全部实现了接口但是不实现的话可能会影响上层例如ScrollView的监听，下面我们看下去也可以知道到底是为啥。"}]},{"type":"element","tag":"h2","props":{"id":"顺藤摸瓜"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"顺藤摸瓜"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然我们已经找到了这个宝贝，那我们就可以通过查找引用大法，顺藤摸瓜看看到底是什么地方在调用我们实现的接口。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后理出来所有事件的入口其实都是放在"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"EventSystem"}]},{"type":"text","value":"当中，而具体处理则是放在了"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"InputModule"}]},{"type":"text","value":"里面。在刚刚Enable的时候会更新输入模块列表，也就是我们可以看到的StandaloneInputModule以及TouchInputModule："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-8df2e07d1b1c5d050ce04c0afd436b16_hd.jpg"},"children":[]},{"type":"text","value":"初始化InputModule"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-054935593d03e1601cdf74d9e29839b0_hd.jpg"},"children":[]},{"type":"text","value":"Unity自己提供的各种InputModule"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在EventSystem的Update当中就会分别调用这些InputModule"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-8f1c906ba904af7ef5d374a45992a9e7_hd.jpg"},"children":[]},{"type":"text","value":"EventSystem主循环"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先Tick所有的输入模块，然后选出一个当前在使用的输入模块中的Process进行处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-0e03e0e59611f1fac21575bb3cc56b8f_hd.jpg"},"children":[]},{"type":"text","value":"EventSystem处理函数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最前面是判断是否处于聚焦状态，其实也就只是应用程序的聚焦状态。其中中间是针对Navigation也就是类似于通过键盘上下左右或者手柄进行UI位置切换的操作。最下面两句才是针对所有的Touch以及Mouse的操作的处理。"}]},{"type":"element","tag":"h2","props":{"id":"触摸事件处理"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"触摸事件处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-88eee10ae51d59b799637945e8117fce_hd.jpg"},"children":[]},{"type":"text","value":"处理输入事件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先看看，首先获取Pointer数据，然后对该数据进行处理。"}]},{"type":"element","tag":"h2","props":{"id":"首先处理点击事件-processtouchpress"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"首先处理点击事件 ProcessTouchPress"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先判断是为按下事件还是释放事件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-9947ebbae68433f48ef3a929a8b2001c_hd.jpg"},"children":[]},{"type":"text","value":"处理点击事件"}]},{"type":"element","tag":"h2","props":{"id":"按下的情形"},"children":[{"type":"text","value":"按下的情形"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先找到Raycast找到的对象如果为按下事件，如果按下的对象并不是之前Hover的对象，则触发进入事件。然后就处理PointerDown事件，如果找不到该事件的话就触发PointerClick事件。如果多次点击的话还会增加PointerEventData的clickTime，双击间隔是固定为0.3秒钟。同时保存下拖拽初始状态，如果有相对应的处理方法IInitializePotentialDragHandler的话就一起触发。"}]},{"type":"element","tag":"h2","props":{"id":"放开的情形"},"children":[{"type":"text","value":"放开的情形"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先触发PointUp事件。之后寻找PointClick事件，并且触发。如果不存在的话那就查看是否存在Drag事件并且执行，最后再执行PointerExit事件。"}]},{"type":"element","tag":"h2","props":{"id":"之后处理move以及drag事件"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"之后处理Move以及Drag事件"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主要还是触发Enter、Exit以及BeginDrag还有Drag等逻辑，比较业务向也就不再写了。"}]},{"type":"element","tag":"h2","props":{"id":"点击事件处理"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"点击事件处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e45c89369a8c438b54d3b8169863a8d6_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写得比Touch更加紧凑，左键中建以及右键的处理都是分开的。而且实现方式与Touch也太像了，所以也就不再赘述了。"}]},{"type":"element","tag":"h2","props":{"id":"射线检测"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"射线检测"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"射线检测绝对是其中非常重要的一个东西，在NGUI中我们都知道事件触发靠射线检测，同样在UGUI中射线检测也是同样的存在。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们在上面的Touch事件处理的地方会看到这么一段代码："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-c17f0ef64287112427f0a1f74ed2b323_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过射线raycast来检测我们的射线数据中包含哪些东西。并且取其中的第一个并且进行事件触发。这个数据我们可以具体看RaycastResult这个类："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-942bda4b880dac3f71dfe3c00285c067_hd.jpg"},"children":[]},{"type":"text","value":"射线检测的结果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而具体cast的步骤则在下面这个函数中，其实是依次调用所有的Raycaster中的射线检测。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-116715b89672f76517469347d2d35ae1_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们会去Raycaster Manager中寻找所有的Raycaster。所有Raycast在Enable的时候就会自动注册到Raycaster Manager中"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-61ed280285611f5e56d858e174fb8846_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在就明白Graphic Raycaster是用来做什么的了吧。当然除了Graphic Raycaster以外还有各种各样的Raycaster:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-6307b8a8e615d5c840203f91244d0e74_hd.jpg"},"children":[]},{"type":"text","value":"Unity内部提供的各类Raycaster"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们这里就只着重看一下Graphic Raycaster"}]},{"type":"element","tag":"h2","props":{"id":"graphic-raycaster"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Graphic Raycaster"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"核心方法就是经过重写的Raycaster，这个函数帮助我们检测画布上被射线触发的地方并且返回结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e1049a6eef487dc07f5163b2f5df3a51_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实就是普通的射线检测，无非需要针对多屏幕、以及不同的Block模式进行判断，最终调用的是另外一个Raycast。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-d37195700a8277f762d5da5382e23fd5_hd.jpg"},"children":[]},{"type":"text","value":"找到被射线穿过的Graphic"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"获得射线所穿过的Graphic，将这些结果逐一加入到Result当中。在放入到Result之前会将这些Graphic根据深度进行排序。当然最终结果的筛选规则会有更多，例如是否在摄像机后面、是否大于最大射线距离等等。最终得到的就是我们最终射线结果。"}]},{"type":"element","tag":"h2","props":{"id":"如何执行事件"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如何执行事件"}]}]},{"type":"element","tag":"h2","props":{"id":"直接调用事件-executeeventsexecute"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"直接调用事件 ExecuteEvents.Execute"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"核心方法为ExecuteEvents.Execute，如果需要触发事件就调用该方法吧！我们需要向其中传3个参数："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个是传递的GameObject，也就是挂载事件的对象。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"第二个参数则是PointEventData，这个参数最终会传给事件处理函数，通常是UGUI自己对输入进行处理并且输出的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最后一个参数就是一个传入的delegate，用于接收各种EventData，最后经由一个验证函数来获得具体的EventData。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-de00fc2cb10360aede52694d0cb5710c_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来我们就看一下具体是如何针对一个GameObject进行事件调用的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-d6090585e8a6f6c36c638d487b363ec1_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先调用GetEventList然后获得具体有哪些Handler，然后逐一进行调用。如果handler的数量大于0则返回true。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看一下获取EventList的规则："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-2d6a993c83da534a4c0ec78939d144b4_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实也只是判断了一下是否为IEventSystemHandler这么简单。"}]},{"type":"element","tag":"h2","props":{"id":"向上查找"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"向上查找"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在很多地方例如Click事件触发的时候往往不是在该射线检测到的GameObject上，而是会向上查找Handler:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e50bb99557b9d0a2b43b77f5a92abda2_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中核心方法就是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GetEventHandler"}]},{"type":"text","value":"，我们看看其中的实现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-ffd1913afa8218040803d0dd1889f696_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"获得UGUI会从射线检测到的GameObject开始，不断向上查找，直到根为止，如果找到则返回，如果找不到可以处理的相应事件则直接返回Null。"}]},{"type":"element","tag":"h2","props":{"id":"事件链"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"事件链"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了获取EventHandler这种情形之外，还有触发GameObject树结构中所有挂载事件的物体。这个时候就有了我们上面看到的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ExecuteHierarchy"}]},{"type":"text","value":"，它的作用就是调用Hierarchy中所有挂载事件的GameObject。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-0c8983d7cf4d5e22c296ca5af93ac859_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到，该函数首先获取事件链，然后逐个进行触发，比较重要的就是获取事件链的过程："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-08-12-ugui-eventsystem-sourcecode/v2-3c2ddef8ca9458a8235db5cb8278bcb3_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从下往上进行遍历，将所有拥有事件的对象通通都调用一遍就是这个事件链的本质。"}]},{"type":"element","tag":"h2","props":{"id":"事件触发机制总结"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"事件触发机制总结"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不同的组件触发事件的方法都不一样，比如我们上面 看到的OnPointDown是用事件链，而PointClick则是使用的向上查找。我们要防止类似于PointClick这类事件，因为如果下层已经实现了该回调则上层回调则再也无法被调用到，因为已经被下层拦截，所以也不要一口气把所有的事件全给重载了，要用的时候再加呗。"}]},{"type":"element","tag":"h2","props":{"id":"总结"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"总结"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总的来说UGUI的事件系统并不复杂，各个部分还是较为清晰的，如果我们的UI编写当中遇到了问题，或者我们要自己魔改一个组件出来都可以通过看源码来进行解决。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"了解了其中原理之后就算是事件穿透之类的也完全可以通过源码实现来倒推解决方案，不用到处搜索解决方案了！"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"为什么想看看事件系统的实现","depth":2,"text":"为什么想看看事件系统的实现"},{"id":"入手点","depth":2,"text":"入手点"},{"id":"顺藤摸瓜","depth":2,"text":"顺藤摸瓜"},{"id":"触摸事件处理","depth":2,"text":"触摸事件处理"},{"id":"首先处理点击事件-processtouchpress","depth":2,"text":"首先处理点击事件 ProcessTouchPress"},{"id":"按下的情形","depth":2,"text":"按下的情形"},{"id":"放开的情形","depth":2,"text":"放开的情形"},{"id":"之后处理move以及drag事件","depth":2,"text":"之后处理Move以及Drag事件"},{"id":"点击事件处理","depth":2,"text":"点击事件处理"},{"id":"射线检测","depth":2,"text":"射线检测"},{"id":"graphic-raycaster","depth":2,"text":"Graphic Raycaster"},{"id":"如何执行事件","depth":2,"text":"如何执行事件"},{"id":"直接调用事件-executeeventsexecute","depth":2,"text":"直接调用事件 ExecuteEvents.Execute"},{"id":"向上查找","depth":2,"text":"向上查找"},{"id":"事件链","depth":2,"text":"事件链"},{"id":"事件触发机制总结","depth":2,"text":"事件触发机制总结"},{"id":"总结","depth":2,"text":"总结"}]}},"_type":"markdown","_id":"content:unity:2019-08-12-ugui-eventsystem-sourcecode.md","_source":"content","_file":"unity/2019-08-12-ugui-eventsystem-sourcecode.md","_extension":"md","date":"2019-08-12"},{"_path":"/unity/2019-08-12-ugui-raycasters","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity Raycasters 剖析","description":"Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Unity Raycasters 中有三种类型的 Raycasters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Physics 2D Raycaster - 用于检测 2D 物体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Physics Raycaster - 用于检测 3D 物体"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raycast 在 Event System 流程中所处的位置大致如下图:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"unity_event_system_raycaster.png","src":"/images/2019-08-12-ugui-Raycasters/unity_event_system_raycaster.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"baseraycaster-类"},"children":[{"type":"text","value":"BaseRaycaster 类"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity Raycasters 中的三个 Raycaster 类都继承自 BaseRaycaster。首先就来看看 BaseRaycaster 类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BaseRaycaster 类很简单，它包含一个抽象方法 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Raycast"}]},{"type":"text","value":"，定义如下:"}]},{"type":"element","tag":"pre","props":{"code":"abstract void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"abstract void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个方法供子类覆写以实现对不同类别的物体进行射线检测。BaseRaycaster 类还继承自 UIBehaviour 类，因此它还覆写了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnEnable"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnDisable"}]},{"type":"text","value":" 方法，在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnEnable"}]},{"type":"text","value":" 方法中向 RaycasterManager 类注册了自己，在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnDisable"}]},{"type":"text","value":" 方法中从 RaycasterManager 类移除了自己的注册。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外该类中还包含了 eventCamera、sortOrderPriority、renderOrderPriority 等属性，在射线检测物体时会用到。"}]},{"type":"element","tag":"h2","props":{"id":"physics-raycaster"},"children":[{"type":"text","value":"Physics Raycaster"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Physics Raycaster 用于检测场景中的 3D 物体对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PhysicsRaycaster 类继承自 BaseRaycaster，既然是射线检测那么最重要的方法莫过于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Raycast"}]},{"type":"text","value":"，接下来就一起看看这个方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Raycast"}]},{"type":"text","value":" 方法中，首先使用传入的 PointerEventData 参数调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComputeRayAndDistance"}]},{"type":"text","value":" 方法，计算得到从当前射线检测使用的 Camera 的近裁剪面处出发，穿过屏幕事件发生处位置的一条射线；这个方法还会计算一个射线检测使用的最大距离 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"distanceToClipPlane"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComputeRayAndDistance"}]},{"type":"text","value":" 内部使用了 Camera 类的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ScreenPointToRay"}]},{"type":"text","value":" 方法将某点转换成一条射线，根据得到的射线的方向以及 Camera 的 farClipPlane 和 nearClipPlane 求得检测最大距离 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"distanceToClipPlane"}]},{"type":"text","value":"。具体代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"void ComputeRayAndDistance(PointerEventData eventData, out Ray ray, out float distanceToClipPlane)\n{\n    ray = eventCamera.ScreenPointToRay(eventData.position);\n    float projectionDirection = ray.direction.z;\n    // 这里加了个保护，因为 projectionDirection 近似为 0 的时候不能被除，因此 distanceToClipPlane 取 Mathf.Infinity 无限大\n    distanceToClipPlane = Mathf.Approximately(0.0f, projectionDirection) ? Mathf.Infinity : Mathf.Abs((eventCamera.farClipPlane - eventCamera.nearClipPlane) / projectionDirection);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"void ComputeRayAndDistance(PointerEventData eventData, out Ray ray, out float distanceToClipPlane)\n{\n    ray = eventCamera.ScreenPointToRay(eventData.position);\n    float projectionDirection = ray.direction.z;\n    // 这里加了个保护，因为 projectionDirection 近似为 0 的时候不能被除，因此 distanceToClipPlane 取 Mathf.Infinity 无限大\n    distanceToClipPlane = Mathf.Approximately(0.0f, projectionDirection) ? Mathf.Infinity : Mathf.Abs((eventCamera.farClipPlane - eventCamera.nearClipPlane) / projectionDirection);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来就是进行射线检测了，代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ReflectionMethodsCache"}]},{"type":"text","value":" 类里面缓存了一些通过反射得到的射线检测相关的类方法。在上面的代码中使用了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"raycast3DAll"}]},{"type":"text","value":" 这个代理，最终执行的是 Physics 类的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RaycastAll"}]},{"type":"text","value":" 方法。传入的三个参数就是射线 ray，最大检测距离 distanceToClipPlane 以及需要检测的层 finalEventMask，返回结果就是检测成功得到的 RaycastHit 数组。第三个参数 finalEventMask 定义如下:"}]},{"type":"element","tag":"pre","props":{"code":"public int finalEventMask\n{\n    get { return (eventCamera != null) ? eventCamera.cullingMask & m_EventMask : kNoEventMaskSet; }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int finalEventMask\n{\n    get { return (eventCamera != null) ? eventCamera.cullingMask & m_EventMask : kNoEventMaskSet; }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们知道，射线检测的时候可以设置哪些 layer 可以接收检测碰撞。上面定义的 finalEventMask 就是需要检测的 layer，如果当前 raycaster 所在的对象有 Camera 组件，那么 finalEventMask 就是摄像机设置的渲染的所有层("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"eventCamera.cullingMask & m_EventMask"}]},{"type":"text","value":")，否则就是默认所有的层("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int kNoEventMaskSet = -1"}]},{"type":"text","value":")都可以接收射线碰撞检测。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后对检测得到的 RaycastHit 数组按照 distance 由小到大排序。最后将这些射线检测结果依次拼装成 RaycastResult 并返回给 Event System，这里的 RaycastResult 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。"}]},{"type":"element","tag":"h2","props":{"id":"physics2d-raycaster"},"children":[{"type":"text","value":"Physics2D Raycaster"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Physics2DRaycaster 类继承自 PhysicsRaycaster，主要就是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Raycast"}]},{"type":"text","value":" 方法中的一点点细小的区别。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一，在进行射线检测的时候，Physics2DRaycaster 中最后调用的是 Physics2D 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetRayIntersectionAll"}]},{"type":"text","value":" 方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二处同 PhysicsRaycaster 的不同之处是在返回构造 RaycastResult 时，填充的部分值不一样，包括以下几个:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"distance，这个值是摄像机到射线检测碰撞点的距离，而在 PhysicsRaycaster 中是 RaycastHit 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"distance"}]},{"type":"text","value":" 值(射线起点在近裁剪面发出到碰撞点的距离)。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sortingLayer，这个值是当前对象 SpriteRenderer 组件中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sortingLayerID"}]},{"type":"text","value":" 值，在 PhysicsRaycaster 为 0。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sortingOrder，这个同样为当前对象 SpriteRenderer 组件中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sortingOrder"}]},{"type":"text","value":" 值，在 PhysicsRaycaster 为 0。"}]}]},{"type":"element","tag":"h2","props":{"id":"graphic-raycaster"},"children":[{"type":"text","value":"Graphic Raycaster"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Graphic Raycaster 用于射线检测 Canvas 中的 Graphic 对象物体，通常绑定在 Canvas 所在的对象身上。"}]},{"type":"element","tag":"h3","props":{"id":"属性或方法"},"children":[{"type":"text","value":"属性或方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GraphicRaycaster 类的成员属性很少，除了继承 BaseRaycaster 类的一些属性和方法外，它还拥有以下一些常用的属性或方法:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"属性"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"描述"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Ignore Reversed Graphics"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"射线检测时是否忽略背向的 Graphics"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Blocked Objects"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"哪些类型的对象会阻挡 Graphic raycasts"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Blocking Mask"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"哪些 Layer 会阻挡 Graphic raycasts(对 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Blocked Objects"}]},{"type":"text","value":" 指定的对象生效)"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不同于 PhysicsRaycaster 和 Physics2DRaycaster 类中直接使用父类的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sortOrderPriority"}]},{"type":"text","value":" 方法和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderOrderPriority"}]},{"type":"text","value":"，GraphicRaycaster 覆写了这两个方法，并且当 Canvas 的 render mode 设置为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 时，上面两个方法分别返回 canvas 的 sortingOrder 以及 rootCanvas 的 renderOrder。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于 eventCamera 的 get 方法，如果 Canvas 的 render mode 设置为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 或者 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"enderMode.ScreenSpaceCamera"}]},{"type":"text","value":" 并且 Canvas 的 worldCamera 未设置时，返回 null，否则返回 Canvas 的 worldCamera 或者 Main Camera。"}]},{"type":"element","tag":"h3","props":{"id":"graphicraycasterraycast"},"children":[{"type":"text","value":"GraphicRaycaster.Raycast"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来就来到最重要的覆写的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Raycast"}]},{"type":"text","value":" 方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GraphicRegistry.GetGraphicsForCanvas"}]},{"type":"text","value":" 方法获取当前 Canvas 下所有的 Graphic(canvasGraphics，这些 Graphics 在进行射线检测的时候会用到)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"紧接着就是 MultiDisplay 的一些检测，代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"int displayIndex;\nvar currentEventCamera = eventCamera;\nif (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == null)\n    displayIndex = canvas.targetDisplay;\nelse\n    displayIndex = currentEventCamera.targetDisplay;\nvar eventPosition = Display.RelativeMouseAt(eventData.position);\nif (eventPosition != Vector3.zero)\n{\n    // 当前平台支持 MultiDisplay\n    int eventDisplayIndex = (int)eventPosition.z;\n    if (eventDisplayIndex != displayIndex)\n        return;\n}\nelse\n{\n    // 当前平台不支持 MultiDiplay\n    eventPosition = eventData.position;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"int displayIndex;\nvar currentEventCamera = eventCamera;\nif (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == null)\n    displayIndex = canvas.targetDisplay;\nelse\n    displayIndex = currentEventCamera.targetDisplay;\nvar eventPosition = Display.RelativeMouseAt(eventData.position);\nif (eventPosition != Vector3.zero)\n{\n    // 当前平台支持 MultiDisplay\n    int eventDisplayIndex = (int)eventPosition.z;\n    if (eventDisplayIndex != displayIndex)\n        return;\n}\nelse\n{\n    // 当前平台不支持 MultiDiplay\n    eventPosition = eventData.position;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看出，当平台支持 MultiDisplay 时，如果用户操作的不是当前的 Display，那么所有的其他 Display 上产生的事件都会被舍弃。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后将屏幕坐标转换到 Camera 视窗坐标下。如果 eventCamera 不为空，则使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Camera.ScreenToViewportPoint"}]},{"type":"text","value":" 方法转换坐标，否则直接使用当前 Display 的宽高除以 eventPosition 转换为视窗坐标([0,1]之间)。转换后的坐标若超出 Cmera 的范围(0 - 1)，则舍弃该事件。"}]},{"type":"element","tag":"h4","props":{"id":"blocked-objects-和-blocked-mask-出场"},"children":[{"type":"text","value":"Blocked Objects 和 Blocked Mask 出场"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前面讲到 GraphicRaycaster 可以设置 Blocked Objects 和 Blocked Mask 来指定射线检测阻挡，下面一步就到了使用这两个属性来阻断射线检测部分。"}]},{"type":"element","tag":"pre","props":{"code":"if (canvas.renderMode != RenderMode.ScreenSpaceOverlay && blockingObjects != BlockingObjects.None)\n{\n    float distanceToClipPlane\n    // 计算 distanceToClipPlane...\n    if (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)\n    {\n        if (ReflectionMethodsCache.Singleton.raycast3D != null)\n        {\n            var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n            if (hits.Length > 0)\n                hitDistance = hits[0].distance;\n        }    \n    }\n    //如果 blockingObjects 包含 BlockingObjects.TwoD，使用 ReflectionMethodsCache.Singleton.getRayIntersectionAll 方法再次计算 hitDistance\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (canvas.renderMode != RenderMode.ScreenSpaceOverlay && blockingObjects != BlockingObjects.None)\n{\n    float distanceToClipPlane\n    // 计算 distanceToClipPlane...\n    if (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)\n    {\n        if (ReflectionMethodsCache.Singleton.raycast3D != null)\n        {\n            var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n            if (hits.Length > 0)\n                hitDistance = hits[0].distance;\n        }    \n    }\n    //如果 blockingObjects 包含 BlockingObjects.TwoD，使用 ReflectionMethodsCache.Singleton.getRayIntersectionAll 方法再次计算 hitDistance\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当 Canvas renderMode 不为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 并且设置了 blockingObjects，此时就会 Blocked Objects 和 Blocked Mask 就会生效。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果 blockingObjects 包含了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BlockingObjects.ThreeD"}]},{"type":"text","value":" 那么则会使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ReflectionMethodsCache.Singleton.raycast3DAll"}]},{"type":"text","value":" 方法计算 hitDistance(PhysicsRaycaster 中也使用的该方法进行射线检测)。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果 blockingObjects 也包含了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BlockingObjects.TwoD"}]},{"type":"text","value":"，那么会使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ReflectionMethodsCache.Singleton.getRayIntersectionAll"}]},{"type":"text","value":" 方法(Physics2DRaycaster 射线检测使用)再计算 hitDistance。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体的计算过程大致是: 这上面的代码中 raycast3DAll 时指定了射线检测层 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"m_BlockingMask"}]},{"type":"text","value":"，这个参数就是自定义设定的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Blocking Mask"}]},{"type":"text","value":"，属于 block mask 的对象在这里就会就行射线检测，并得到最小的一个 hitDistance；"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"后面对所有的 Graphics 进行射线检测时，如果检测结果 distance 大于 hitDistance，那么那个结果会被舍弃"}]},{"type":"text","value":"。如此一来，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Blocking Mask"}]},{"type":"text","value":" 就起到了阻挡的作用，属于这个 layer 的所有对象的一旦被射线检测成功并得到 hitDistance，PhysicsRaycaster 最后的射线检测结果都只会包含这个 hitDistance 距离以内的对象。"}]},{"type":"element","tag":"h4","props":{"id":"graphicraycaster-类重载了-真-raycast-方法"},"children":[{"type":"text","value":"GraphicRaycaster 类重载了 “真” Raycast 方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"终于可以进行真真切切的 Graphic Raycast 了。"}]},{"type":"element","tag":"pre","props":{"code":"private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)\n{\n    int totalCount = foundGraphics.Count;\n    for (int i = 0; i < totalCount; ++i)\n    {\n        Graphic graphic = foundGraphics[i];\n        // depth 为 -1 说明没有被 canvas 处理(未被绘制)\n        // raycastTarget 为 false 说明当前 graphic 不需要被射线检测\n        // graphic.canvasRenderer.cull 为 true，忽略当前 graphic 的 CanvasRender 渲染的物体\n        if (graphic.depth == -1 || !graphic.raycastTarget || graphic.canvasRenderer.cull)\n            continue;\n        // 从指定的 eventCamera 计算 pointerPosition 是否在 graphic 的 Rectangle 区域内 \n        if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera))\n            continue;\n        if (graphic.Raycast(pointerPosition, eventCamera))\n        {\n            s_SortedGraphics.Add(graphic);\n        }\n    }\n    s_SortedGraphics.Sort((g1, g2) => g2.depth.CompareTo(g1.depth));\n    // return result\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)\n{\n    int totalCount = foundGraphics.Count;\n    for (int i = 0; i < totalCount; ++i)\n    {\n        Graphic graphic = foundGraphics[i];\n        // depth 为 -1 说明没有被 canvas 处理(未被绘制)\n        // raycastTarget 为 false 说明当前 graphic 不需要被射线检测\n        // graphic.canvasRenderer.cull 为 true，忽略当前 graphic 的 CanvasRender 渲染的物体\n        if (graphic.depth == -1 || !graphic.raycastTarget || graphic.canvasRenderer.cull)\n            continue;\n        // 从指定的 eventCamera 计算 pointerPosition 是否在 graphic 的 Rectangle 区域内 \n        if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera))\n            continue;\n        if (graphic.Raycast(pointerPosition, eventCamera))\n        {\n            s_SortedGraphics.Add(graphic);\n        }\n    }\n    s_SortedGraphics.Sort((g1, g2) => g2.depth.CompareTo(g1.depth));\n    // return result\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在循环中对每一个 Graphic 首先进行了初步的筛选，满足条件的 Graphic 才会调用其 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Raycast"}]},{"type":"text","value":" 方法，这里的条件筛选包括 deth、raycastTarget 设置、位置信息是否满足等。"}]},{"type":"element","tag":"h4","props":{"id":"graphicraycast"},"children":[{"type":"text","value":"Graphic.Raycast"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对 Canvas 下所有的 graphic 遍历，满足条件则进行射线检测。Graphic 射线检测过程如下:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"整个检测过程是在一个循环中实现的，从当前 Graphic 节点开始不断向上"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"递归"}]},{"type":"text","value":"，直至向上再没有节点或者节点绑定的组件中有被射线检测出来结果而返回。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于节点对象，首先获取其绑定的所有组件，依次"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"遍历"}]},{"type":"text","value":"判断组件:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当组件是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Canvas"}]},{"type":"text","value":" 并且其 overrideSorting 为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" 则指定: 若在当前节点绑定的一系列的组件中都未能成功唤起检测，则当前节点组件"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"遍历"}]},{"type":"text","value":"结束后将跳出节点"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"递归"}]},{"type":"text","value":"并默认返回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果组件是实现了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ICanvasRaycastFilter"}]},{"type":"text","value":" 接口，则判断组件是否是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CanvasGroup"}]},{"type":"text","value":"。若是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CanvasGroup"}]},{"type":"text","value":" 且设置了 ignoreParentGroups 为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":"，那么对于接下来的所有 CanvasGroup 组件将不会调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IsRaycastLocationValid"}]},{"type":"text","value":" 方法检测；若 CanvasGroup 都未设置 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ignoreParentGroups"}]},{"type":"text","value":"或者不包含 CanvasGroup 组件，则直接调用组件实现的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IsRaycastLocationValid"}]},{"type":"text","value":" 方法计算是否射线检测成功。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从整个 Graphic.Raycast 检测过程可以看出，检测是自当前 graphic 节点开始，一旦检测到某个节点添加实现了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ICanvasRaycastFilter"}]},{"type":"text","value":" 接口且 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IsRaycastLocationValid"}]},{"type":"text","value":" 方法返回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"false"}]},{"type":"text","value":" 则此 graphic 检测失败并结束检测；否则还会继续向上递归检测父节点，当所有节点(绑定了 Canvas 组件并设置了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Canvas.overrideSorting"}]},{"type":"text","value":" 为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"true"}]},{"type":"text","value":"的节点会截止此次检测)都射线检测成功或是不需要使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IsRaycastLocationValid"}]},{"type":"text","value":" 方法进行检测，则此次 Graphic.Raycast 成功。"}]},{"type":"element","tag":"h4","props":{"id":"graphicraycast-成功的对象深度排序"},"children":[{"type":"text","value":"Graphic.Raycast 成功的对象深度排序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对所有射线检测成功的 graphics 按照深度 depth 从小到大排序。"}]},{"type":"element","tag":"h4","props":{"id":"reversed-graphics-过滤"},"children":[{"type":"text","value":"Reversed Graphics 过滤"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后对检测结果再过滤。如果设置了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Ignore Reversed Graphics"}]},{"type":"text","value":" 为 true，则将背向 Camera 的对象过滤掉，这里面又分为两种情况:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Camera 为空，直接判断当前 Graphic 方向与正方向 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vector3.forward"}]},{"type":"text","value":" 是否相交，如下:"},{"type":"element","tag":"pre","props":{"code":"var dir = go.transform.rotation * Vector3.forward;\nappendGraphic = Vector3.Dot(Vector3.forward, dir) > 0;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var dir = go.transform.rotation * Vector3.forward;\nappendGraphic = Vector3.Dot(Vector3.forward, dir) > 0;\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"首先将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vector3.forward"}]},{"type":"text","value":" 绕着当前 Graphic 的 rotation 旋转得到 Graphic 的正方向，然后通过点积判断 Graphic 正方向是否与默认正方向(没有 Camera 所以默认正方向为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vector3.forward"}]},{"type":"text","value":")相交。点积大于 0 则相交，说明当前 Graphic 可以加入射线加测结果中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当 Camera 不为空，就使用 Camera 的正方向与 Graphic 的正方向比较是否相交。"}]}]},{"type":"element","tag":"h4","props":{"id":"distance-检测是最终一道坎"},"children":[{"type":"text","value":"distance 检测是最终一道坎"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Ignore Reversed Graphics"}]},{"type":"text","value":" 检测完，对结果进行 distance 计算:"}]},{"type":"element","tag":"pre","props":{"code":"float distance = 0;\nif (currentEventCamera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)\n    distance = 0;\nelse\n{\n    Transform trans = go.transform;\n    Vector3 transForward = trans.forward;\n    distance = (Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) / Vector3.Dot(transForward, ray.direction));\n    if (distance < 0)\n        continue;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"float distance = 0;\nif (currentEventCamera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)\n    distance = 0;\nelse\n{\n    Transform trans = go.transform;\n    Vector3 transForward = trans.forward;\n    distance = (Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) / Vector3.Dot(transForward, ray.direction));\n    if (distance < 0)\n        continue;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Render Mode 为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 或者 Camera 为 null，distance 为 0；否则就计算 Graphic 和 Camera 之间的向量在 Graphic 正方向上的投影以及计算射线方向在 Graphic 正方向上的投影，两者相除就得到最终的 distance。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果 distance 小于 hitDistance(设置的 Blocked Objects 和 Blocked Mask 产生)，则结果通过最终的测试可被用作事件的接收者之一。"}]},{"type":"element","tag":"h3","props":{"id":"射线检测前后的一些操作"},"children":[{"type":"text","value":"射线检测前后的一些操作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先来看看这些 Raycaster 被唤起的部分，也就是最开始的流程图中的第三步。Input Module 中使用 Raycaster 处理射线检测，真正的 Raycaster 实施代码又回到了 EventSystem 类中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RaycastAll"}]},{"type":"text","value":" 方法，具体代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"public void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults)\n{\n    raycastResults.Clear();\n    var modules = RaycasterManager.GetRaycasters();\n    for (int i = 0; i < modules.Count; ++i)\n    {\n        var module = modules[i];\n        if (module == null || !module.IsActive())\n            continue;\n        module.Raycast(eventData, raycastResults);\n    }\n    raycastResults.Sort(s_RaycastComparer);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults)\n{\n    raycastResults.Clear();\n    var modules = RaycasterManager.GetRaycasters();\n    for (int i = 0; i < modules.Count; ++i)\n    {\n        var module = modules[i];\n        if (module == null || !module.IsActive())\n            continue;\n        module.Raycast(eventData, raycastResults);\n    }\n    raycastResults.Sort(s_RaycastComparer);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"场景中可以存在一个或多个 Raycaster。当存在多个时，如果需要发起射线检测，那么每个处于 Active 状态的 Raycaster 都会工作，所有 Raycaster 检测得到的结果都会存放在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"raycastResults"}]},{"type":"text","value":" 中(这些 RaycastResult 都是在各自射线检测器中根据 distance 从小到大排过序的)。方法最后使用自定义 Comparer 对所有的 RaycastResult 排序。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"s_RaycastComparer"}]},{"type":"text","value":" 有以下几种比较流程:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"两个 RaycastResult 检测所在的 Raycaster 不同"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先比较两个对象的 Camera 的 depth。在渲染中，Camera depth 越小会越先渲染，越大越往后渲染，因此对于射线检测来说，Camera 的 depth 越大，它对应的物体应该先于 Camera depth 小的物体进行射线检测，检测得到的结果也应排在前面。代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"if (lhsEventCamera.depth < rhsEventCamera.depth)\n    return 1;\nif (lhsEventCamera.depth == rhsEventCamera.depth)\n    return 0;\nreturn -1;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (lhsEventCamera.depth < rhsEventCamera.depth)\n    return 1;\nif (lhsEventCamera.depth == rhsEventCamera.depth)\n    return 0;\nreturn -1;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当 Camera depth 相等的时候，使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sortOrderPriority"}]},{"type":"text","value":" 进行比较。优先级数值越大，越先被射线检测选中，所以这里的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CompareTo"}]},{"type":"text","value":" 方法使用的是右边的参数去比较左边的参数，最终的结果就是按照从大到小(降序)的顺序排列。"}]},{"type":"element","tag":"pre","props":{"code":"return rhs.module.sortOrderPriority.CompareTo(lhs.module.sortOrderPriority);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"return rhs.module.sortOrderPriority.CompareTo(lhs.module.sortOrderPriority);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 PhysicsRaycaster 和 Physics2DRaycaster 类中没有覆写 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sortOrderPriority"}]},{"type":"text","value":" 方法，因此都返回基类的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int.MinValue"}]},{"type":"text","value":"；但在 GraphicRaycaster 类中覆写了此方法，当对应的 Canvas 的 renderMode 设置为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 时，此时的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sortOrderPriority"}]},{"type":"text","value":" 返回 Canvas 的 sortingOrder(Sort Order越大越在上层)，否则同样也是返回基类设置的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int.MinValue"}]},{"type":"text","value":"，这是因为在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 模式下，所有的 distance 都将是 0。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当 sortOrderPriority 相同，再使用 renderOrderPriority 比较。"}]},{"type":"element","tag":"pre","props":{"code":"return rhs.module.renderOrderPriority.CompareTo(lhs.module.renderOrderPriority);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"return rhs.module.renderOrderPriority.CompareTo(lhs.module.renderOrderPriority);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"renderOrderPriority 和 sortOrderPriority 类似，仅在 GraphicRaycaster 类中被覆写，也只有在 Canvas 的 renderMode 设置为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMode.ScreenSpaceOverlay"}]},{"type":"text","value":" 时才返回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"canvas.rootCanvas.renderOrder"}]},{"type":"text","value":"，这是因为 Canvas 在其他几种 renderMode 下，渲染的先后顺序都和距离摄像机的距离有关。所以 renderOrderPriority 比较也是按照从大到小的顺序得到最终的结果。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同属于一个 Raycaster 检测得到，但是它们的 sortingLayer 不一样"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于 PhysicsRaycaster 检测得到的对象，sortingLayer 都为 0。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于 Physics2DRaycaster 检测得到的对象，如果对象上挂载有 SpriteRenderer 组件，那么 sortingLayer 对应的 sortingLayerID，否则也为 0。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于 GraphicRaycaster 检测所得，sortingLayer 就是所在 Canvas 的 sortingLayerID。"}]},{"type":"element","tag":"pre","props":{"code":"var rid = SortingLayer.GetLayerValueFromID(rhs.sortingLayer);\nvar lid = SortingLayer.GetLayerValueFromID(lhs.sortingLayer);\nreturn rid.CompareTo(lid);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var rid = SortingLayer.GetLayerValueFromID(rhs.sortingLayer);\nvar lid = SortingLayer.GetLayerValueFromID(lhs.sortingLayer);\nreturn rid.CompareTo(lid);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SortingLayer.GetLayerValueFromID"}]},{"type":"text","value":" 方法计算 sortingLayer 最终的 sorting layer 值，同样是按照降序排列，因此计算得到的 sorting layer 值越大越先排在前面。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sortingLayer 也相同，使用 sortingOrder 比较"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sortingOrder 和 sortingLayer 类似，PhysicsRaycaster 检测得到的对象 sortingOrder 为 0；Physics2DRaycaster 检测得到的对象是 SpriteRenderer 中的 sortingOrder；GraphicRaycaster 检测所得是所在 Canvas 的 sortingOrder。最终 sortingOrder 越大的对象越排前面。代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"return rhs.sortingOrder.CompareTo(lhs.sortingOrder);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"return rhs.sortingOrder.CompareTo(lhs.sortingOrder);\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sortingOrder 相同，使用 depth 比较"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PhysicsRaycaster 和 Physics2DRaycaster 中 depth 都被设置为了 0；GraphicRaycaster 检测所得的对象的 depth 就是继承自 Graphic 类的对象所在的 Graphic 的 depth，即 Canvas 下所有 Graphic 深度遍历的顺序。比较同样也是按照降序进行的，因此越嵌套在靠近 Canvas 的对象越排在前面。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"depth 相同，使用 distance 比较"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PhysicsRaycaster 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Physics2DRaycaster 类中返回的是 Camera 的位置和射线碰撞点之间的距离。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GraphicRaycaster 类中 distance "},{"type":"element","tag":"a","props":{"href":"http://geomalgorithms.com/a06-_intersect-2.html","rel":["nofollow"]},"children":[{"type":"text","value":"计算"}]},{"type":"text","value":"如下:"}]},{"type":"element","tag":"pre","props":{"code":"var go = m_RaycastResults[index].gameObject;\nTransform trans = go.transform;\nVector3 transForward = trans.forward;\n// TODO why user DOT to caculate distance?\ndistance = Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) / Vector3.Dot(transForward, ray.direction);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var go = m_RaycastResults[index].gameObject;\nTransform trans = go.transform;\nVector3 transForward = trans.forward;\n// TODO why user DOT to caculate distance?\ndistance = Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) / Vector3.Dot(transForward, ray.direction);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"距离 distance 越小越靠前。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最后如果上述情况都不能满足，使用 index 比较。先被射线检测到的对象排在前面。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raycaster 后段部分的流程: 取排过序的 RaycastResult 中第一个结果作为响应事件的输入事件的 pointerCurrentRaycast，根据它来在 Messaging System 中分发事件，大致代码如下:"}]},{"type":"element","tag":"pre","props":{"code":"// 获取 Raycast 结果中对应的 GameObject\nvar currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;\n// 分发事件\nExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.pointerDownHandler);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 获取 Raycast 结果中对应的 GameObject\nvar currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;\n// 分发事件\nExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.pointerDownHandler);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Raycaster 在 Event System 中的作用和流程基本就是上述的内容。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"baseraycaster-类","depth":2,"text":"BaseRaycaster 类"},{"id":"physics-raycaster","depth":2,"text":"Physics Raycaster"},{"id":"physics2d-raycaster","depth":2,"text":"Physics2D Raycaster"},{"id":"graphic-raycaster","depth":2,"text":"Graphic Raycaster","children":[{"id":"属性或方法","depth":3,"text":"属性或方法"},{"id":"graphicraycasterraycast","depth":3,"text":"GraphicRaycaster.Raycast"},{"id":"射线检测前后的一些操作","depth":3,"text":"射线检测前后的一些操作"}]}]}},"_type":"markdown","_id":"content:unity:2019-08-12-ugui-Raycasters.md","_source":"content","_file":"unity/2019-08-12-ugui-Raycasters.md","_extension":"md","date":"2019-08-12"},{"_path":"/unity/2019-09-01-addressable","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于addressable那些事","description":"在本文中将详细的描述Addressable对于内存的管理，如果正确的卸载资源","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在本文中将详细的描述Addressable对于内存的管理，如果正确的卸载资源"}]},{"type":"element","tag":"h2","props":{"id":"镜像资源的加载与卸载"},"children":[{"type":"text","value":"镜像资源的加载与卸载"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Addressables是否能够正确的清理内存主要的取决于是否正确的进行镜像资源的加载与卸载，而如何做到这点又取决于加载的资源的类型与使用加载的方法。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.Release"}]},{"type":"text","value":"方法可以接受加载到的对象，也可以接受加载时返回的操作句柄("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncOperationHandle"}]},{"type":"text","value":").比如，进行场景创建时，加载后返回一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncOperationHandle<SceneInstance>"}]},{"type":"text","value":"，你可以通过返回的句柄或者"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"handle.Result"}]},{"type":"text","value":"(在这种情况下返回的Result为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SceneInstance"}]},{"type":"text","value":"对象)进行场景的的释放。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来将详细的描述一下不同资源的释放方式及规则。"}]},{"type":"element","tag":"h2","props":{"id":"资源加载"},"children":[{"type":"text","value":"资源加载"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此处的资源指的是使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.LoadAssetAsync"}]},{"type":"text","value":" 或者 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.LoadAssetsAsync"}]},{"type":"text","value":"加载的资源。\n使用上述的两个方法会将资源加载到内存中，但是并不实例化它，每次调用后对应的资源的引用记数都会增加1。如果您使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LoadAssetAsync"}]},{"type":"text","value":"对同一个“地址”的资源调用了3次，您将会得到三个不同的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncOperationHandle"}]},{"type":"text","value":"的实例，同时这些实例均引用相同的底层操作，对就应的底层操作的引用记数会变成3。如果资源加载成功，加载到的资源将会被存储到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncOperationHandle.Result"}]},{"type":"text","value":"中，您可以使用Unity的方法进行实例化"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Object.instantite"}]},{"type":"text","value":"，但是这种操作方式不会造成Adressables的引用记数发生变化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.Release"}]},{"type":"text","value":"方法可以进行卸载，调用后引用记数会减1，一旦资源的引用记数为0，那么它会被彻底的卸载掉。"}]},{"type":"element","tag":"h2","props":{"id":"场景加载"},"children":[{"type":"text","value":"场景加载"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.LoadSceneAsync"}]},{"type":"text","value":"进行场景的加载，同时可以在参数中指定使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Single"}]},{"type":"text","value":"或者"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Additive"}]},{"type":"text","value":"模式，如果指定使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Single"}]},{"type":"text","value":"模式，那么当前所在打开的场景都会被关闭。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.UnloadSceneAsync"}]},{"type":"text","value":"进行场景的卸载，或者打开新场景时使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Single"}]},{"type":"text","value":"模式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当想要打开一个新场景时可以使用上述Addressables提供的方法或者使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SceneManager.LoadScene"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SceneManager.LoadSceneAsync"}]},{"type":"text","value":"，一个新场景的打开会关闭当前的场景，那么对应的引用记数也会正确的减少。"}]},{"type":"element","tag":"h2","props":{"id":"gameobject的实例化"},"children":[{"type":"text","value":"GameObject的实例化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GameObject的实例化相对其它的资源有些特殊，在Unity中使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Resources.Load"}]},{"type":"text","value":"其实只是将Prefab的数据加载到了内存中，并未真正的实例化，所以需要再次调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Object.instantite"}]},{"type":"text","value":"才能正确的得到需要的GameObject，在Addressables中也是这样的，不过Addressable提供了一些便利的方法"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.InstantiateAsync"}]},{"type":"text","value":"可以直接得到对应的GameObject。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.InstantiateAsync"}]},{"type":"text","value":"加载一个Prefab时，Addressable会自动实例化，同时在加载的过程中Addressable在加载Prefab的同时也会加载其依赖，将所有的引用记数全部增加。对同一“地址”的资源调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InstantiateAsync"}]},{"type":"text","value":"三次，将会使其依赖的所有资源的引用记数均增加为3.但是与三次调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LoadAssetAsync"}]},{"type":"text","value":"不同的是每次调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InstantiateAsync"}]},{"type":"text","value":"将会得到一个指向同一个操作的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncOperationHandle"}]},{"type":"text","value":",这是因为每一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InstantiateAsync"}]},{"type":"text","value":"都将得到一个唯一的实例。与其它调用方法的另外一个区别在于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InstantiateAsync"}]},{"type":"text","value":"有一个可选参数"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"trackHandle"}]},{"type":"text","value":"，如果将其设置为false，在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncOperationHandle"}]},{"type":"text","value":"释放前，您必须自己保管着此对象，在此期间您可以执行一些操作。这种方法可以提高效率但是需要更多格外的代码来实现。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关闭实例所在场景或者使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.ReleaseInstance"}]},{"type":"text","value":"可以卸载掉实例化的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果您在加载时将"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"trackHandle"}]},{"type":"text","value":"设置为false,那么您只能通过调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.ReleaseInstance"}]},{"type":"text","value":"并将返回的句柄做为参数，而不能再使用真实的GameObject做为参数进行释放了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.ReleaseInstance"}]},{"type":"text","value":"格外的说明：如果调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.ReleaseInstance"}]},{"type":"text","value":"方法来释放一个实例,但是此实例不是由Addressable创建或者说在使用Addressable创建时设置了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"trackHandle=false"}]},{"type":"text","value":"，此方法调用后将会返回false，以表示Addressable无法释放此实例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.InstantiateAsync"}]},{"type":"text","value":"方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，使用此方法就不再合适，可以考虑使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.LoadAssetAsync"}]},{"type":"text","value":"进行资源的加载，同时自己保存返回的结果，然后再使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject.Instantiate()"}]},{"type":"text","value":"进行实例化，同时当所有的GameObject不再使用后，再通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addessables.Release"}]},{"type":"text","value":"方法将保存的结果进行释放。使用此种方法虽然可以提高部分性能，但是需要对其增加格外的管理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Addressables.InstantiateAsync"}]},{"type":"text","value":"方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，可以考虑使用Addressable进行资源的加载"}]},{"type":"element","tag":"h2","props":{"id":"addressable分析工具"},"children":[{"type":"text","value":"Addressable分析工具"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Window->Asset Management->Addressable Profiler"}]},{"type":"text","value":"可以打开Addressable的分析工具，在使用此工具前需要将配置中的"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Send Profiler Events"}]},{"type":"text","value":"打开（默认情况下配置文件为Assets/AddressableAssetsData/AddressableAssetSettings)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Send Profiler Events","src":"/images/2019-09-01-addressable/sendprofilerevent.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"窗口中显示了Addressable操作的引用记数，包括加载的AssetBundle及加载的资源等等。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"白色的竖线表示选择的当前的帧"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"蓝色的背景当前加载的资源"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"绿色的部分表示引用记数"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Profiler","src":"/images/2019-09-01-addressable/profiler.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"内存清理时机"},"children":[{"type":"text","value":"内存清理时机"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"即使一个资源的不再被引用也不代表此资源被卸载了，因为一个AssetBundle中可能包含有多个资源，比如：一个名称\"stuff\"的AssetBundle中包含有三个资源\"tree\",“tank”,“cow”，当资源\"tree”被加载后，能够看到\"tree\"的引用记录会是1，同时\"stuff\"的引用记数也是1，接着如果加载了\"tank\"资源，此时\"tree\"与\"tank\"的引用记数均为1，同时\"stuff\"的记数会是2。接下来卸载资源\"tree\"，则\"tree\"的引用记数将会减少为0，在\"Addressable Profiler\"中对应于\"tree\"的记录将会被删除，但是此时由于AssetBundle对应的\"stuff\"并未被卸载，因为还有其它的在使用此AssetBundle。使用AssetBundle时可以从AssetBundle中加载部分内容，但是不能部分卸载AssetBundle，只有AssetBundle中的任何资源都不再被使用时，此AssetBundle才会被卸载"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当使用Unity的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Resources.UnloadUnusedAssets"}]},{"type":"text","value":" (查看"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)%E6%97%B6%EF%BC%8C%E4%B8%8A%E8%BF%B0%E6%8F%8F%E8%BF%B0%E4%B8%AD%E7%9A%84%22tree%22%E5%B0%86%E4%BC%9A%E8%A2%AB%E5%8D%B8%E8%BD%BD%E6%8E%89%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E5%88%B0%E6%AD%A4%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%8F%AA%E8%83%BD%E5%8F%8D%E6%98%A0%E5%BC%95%E7%94%A8%E8%AE%B0%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E5%86%85%E5%AD%98%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E5%8F%98%E5%8C%96%E3%80%82","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)时，上述描述中的\"tree\"将会被卸载掉，但是由于我们无法检测到此操作，所以我们只能反映引用记数的变化，而不是真正内存中内容的变化。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是：使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Resources.UnloadUnusedAssets"}]},{"type":"text","value":"是一个很费时的操作，一般情况下不建议频繁使用，只有在场景切换时进行调用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此段文字有些绕口，简单来说就是由于一个AssetBundle中包含有多个资源，其中的多个资源被加载出来后，只有所有的资源均不再使用时才会正确的卸载掉AssetBundle，同时对于加载出来的资源一般情况下，即使不再使用后也不是立即卸载的，依赖于引擎底层的实现。在Unity中通过使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Resources.UnloadUnusedAssets"}]},{"type":"text","value":"可以将不再使用的资源给卸载掉，但是由于此接口过于耗时，并不推荐频繁使用。可以使用的情况一般有：1 进行场景切换时，2 在某些大资源被销毁时，比如说：某此UI界面占用资源特别多，当此UI界面关闭时可以调用。"}]},{"type":"element","tag":"h3","props":{"id":"一些注意点"},"children":[{"type":"text","value":"一些注意点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要想着用异步加载ui..那会很卡..会出现莫名其妙的事情"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"镜像资源的加载与卸载","depth":2,"text":"镜像资源的加载与卸载"},{"id":"资源加载","depth":2,"text":"资源加载"},{"id":"场景加载","depth":2,"text":"场景加载"},{"id":"gameobject的实例化","depth":2,"text":"GameObject的实例化"},{"id":"addressable分析工具","depth":2,"text":"Addressable分析工具"},{"id":"内存清理时机","depth":2,"text":"内存清理时机","children":[{"id":"一些注意点","depth":3,"text":"一些注意点"}]}]}},"_type":"markdown","_id":"content:unity:2019-09-01-addressable.md","_source":"content","_file":"unity/2019-09-01-addressable.md","_extension":"md","date":"2019-09-01"},{"_path":"/unity/2019-09-01-spriteatlas","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于spriteAtlas打包那些事","description":"UGUI的合图是在什么时候发生的？Unity合大图的时机是根据设置来的。Edit->ProjectSetting->Editor如上图，可以在打包的时候合，也可以编辑器运行的时候就合。Editor中合成的大图是放在缓存目录里：Library/AtlasCache。Enabled For Builds  （Unity将精灵打包到Sprite Atlas中，仅用于已发布的版本。Editor和Play模式引用原始源纹理而不是Sprite Atlas中的纹理。）。Always Enabled   （默认情况下启用此选项。Unity将选定的纹理打包到Sprite Atlases中，Sprite在运行时引","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"ugui的合图是在什么时候发生的"},"children":[{"type":"text","value":"UGUI的合图是在什么时候发生的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity合大图的时机是根据设置来的。"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Edit->ProjectSetting->Editor"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1567211125212","src":"/images/2019-09-01-spriteAtlas/1567211125212.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如上图，可以在打包的时候合，也可以编辑器运行的时候就合。Editor中合成的大图是放在缓存目录里："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Library/AtlasCache"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Enabled For Builds  （Unity将精灵打包到Sprite Atlas中，仅用于已发布的版本。Editor和Play模式引用原始源纹理而不是Sprite Atlas中的纹理。）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Always Enabled   （默认情况下启用此选项。Unity将选定的纹理打包到Sprite Atlases中，Sprite在运行时引用打包的Textures。但是，Sprites将在Editor模式期间引用原始未压缩的纹理。）。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简单的说:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果想测试spritepacker是否生效以及代码相关..这时候选择Always Enabled..可以理解为生产模式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果平时开发Enabled For Builds,只有打包的时候才构建..可以理解为开发模式"}]}]},{"type":"element","tag":"h3","props":{"id":"include-in-build到底干了什么"},"children":[{"type":"text","value":"Include in Build到底干了什么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"勾选了Include in Build后，图集资源会被打进App包体里（不是AssetBundle包）。如果图集是AssetBundle包管理的，最好不要勾选它，会造成资源双份。至于哪些资源会双份，需要实验下看看。"}]},{"type":"element","tag":"h3","props":{"id":"禁用include-in-build使用late-binding"},"children":[{"type":"text","value":"禁用Include in Build,使用Late Binding"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"只要精灵打包到任何精灵图集内，但精灵图集未绑定为默认图集（例如未选中“Include in build”选项），精灵便会在场景中不可见。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"用户可以监听回调 SpriteAtlas.atlasRequested。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"此委托方法将提供一个要绑定的图集标签和一个接受 SpriteAtlas 资源的 System.Action。用户应按任意方式（脚本引用、Resources.load、资源包）加载该资源，并将该资源提供给 System.Action。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SpriteAtlas.atlasRequested只会请求一次无论成功还是失败,所以要确保你的atlasRequested回调一定能返回正确的值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当使用addressable异步加载spriteatlas的时候,也会触发SpriteAtlas.atlasRequested,这个时候内存中可能会存在两份资源的引用..记得释放其中的一份"}]}]},{"type":"element","tag":"h3","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://connect.unity.com/doc/Manual/SpriteAtlas","rel":["nofollow"]},"children":[{"type":"text","value":"https://connect.unity.com/doc/Manual/SpriteAtlas"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"ugui的合图是在什么时候发生的","depth":3,"text":"UGUI的合图是在什么时候发生的？"},{"id":"include-in-build到底干了什么","depth":3,"text":"Include in Build到底干了什么？"},{"id":"禁用include-in-build使用late-binding","depth":3,"text":"禁用Include in Build,使用Late Binding"},{"id":"相关链接","depth":3,"text":"相关链接"}]}},"_type":"markdown","_id":"content:unity:2019-09-01-spriteAtlas.md","_source":"content","_file":"unity/2019-09-01-spriteAtlas.md","_extension":"md","date":"2019-09-01"},{"_path":"/unity/2019-09-02-ilruntime","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"ilruntime的研究","description":"C#代码在编写后，是需要执行编译的，才能起效，这样如果在手机端，没有对应的编译环境，那么对应的c#代码就无法实现热更。ILRuntime实现的基础，也是基于AssetBundle的资源热更新方式，将需要热更新的c#代码打包成DLL，在每次完成资源打包后，对应的DLL会被作为资源热更新出去。这样就规避了编译相关的环节，实现了热更。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"C#代码在编写后，是需要执行编译的，才能起效，这样如果在手机端，没有对应的编译环境，那么对应的c#代码就无法实现热更。ILRuntime实现的基础，也是基于AssetBundle的资源热更新方式，将需要热更新的c#代码打包成DLL，在每次完成资源打包后，对应的DLL会被作为资源热更新出去。这样就规避了编译相关的环节，实现了热更。"}]},{"type":"element","tag":"h1","props":{"id":"appdomain"},"children":[{"type":"text","value":"AppDomain"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们运行一个.NET应用程序或者一个运行库宿主时，OS会首先建立一个进程，然后会在进程中加载CLR(这个加载一般是通过调用_CorExeMain或者_CorBindToRuntimeEx方法来实现)，在加载CLR时会创建一个默认的AppDomain，它是CLR的运行单元，程序的Main方法就是在这里执行，这个默认的AppDomain是唯一且不能被卸载的，当该进程消灭时，默认AppDomain才会随之消失。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个进程中可以有多个AppDomain，且它们直接是相互隔离的，我们的Assembly是不能单独执行的，它必须被加载到某个AppDomain中，要想"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"卸载一个Assembly"}]},{"type":"text","value":"就只能卸载其AppDomain。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"无法删除WindowsApplication1: 访问被拒绝\n请确定磁盘末被写保护\n而且文件末被使用"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除非你关掉作业管理服务器，然后再操作，显然这样做是很不合理的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"并且默认AppDomain是不能被卸载的，那么我们该怎么办呢，我想到的方法是动态的加载Assembly，新建一个AppDomain，让Assembly加载到这个新AppDomain中然后执行，当执行完后卸载这个新的AppDomain即可。核心思想就是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如果程序集被加载到默认应用程序域中，则当进程运行时将无法从内存中卸载该程序集。但是，如果打开另一个应用程序域来加载和执行程序集，则卸载该应用程序域时也会同时卸载程序集。使用此技术最小化长时间运行的进程的工作集"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525160300209-2123986426.png"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AppDomain vs 进程\nAppDomain被创建在进程中，一个进程内可以有多个AppDomain。一个AppDomain只能属于一个进程。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AppDomain vs 线程\n其实两者本来没什么好对比的。AppDomain是个静态概念，只是限定了对象的边界；线程是个动态概念，它可以运行在不同的AppDomain。一个AppDomain内可以创建多个线程，但是不能限定这些线程只能在本AppDomain内执行代码。CLR中的System.Threading.Thread对象其实是个soft thread，它并不能被操作系统识别；操作系统能识别的是hard thread。一个soft thread只属于一个AppDomain，穿越AppDomain的是hard thread。当hard thread访问到某个AppDomain时,一个AppDomain就会为之产生一个soft thread。\nhard thread有thread local storage(TLS)，这个存储区被CLR用来存储这个hard thread当前对应AppDomain引用以及softthread引用。当一个hard thread穿越到另外一个AppDomain时，TLS中的这些引用也会改变。\n当然这个说法很可能是和CLR的实现相关的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AppDomain vs Assembly\nAssembly是.Net程序的基本部署单元，它可以为CLR提供用于识别类型的元数据等等。Assembly不能单独执行，它必须被加载到AppDomain中，然后由AppDomain创建程序集中的对象。一个Assembly可以被多个AppDomain加载，一个AppDomain可以加载多个Assembly。每个AppDomain引用到某个类型的时候需要把相应的assembly在各自的AppDomain中初始化。因此，每个AppDomain会单独保持一个类的静态变量。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AppDomain vs 对象\n任何对象只能属于一个AppDomain。AppDomain用来隔离对象，不同AppDomain之间的对象必须通过Proxy(reference type)或者Clone(value type)通信。引用类型需要继承System.MarshalByRefObject才能被Marshal/UnMarshal(Proxy)。值类型需要设置Serializable属性才能被Marshal/UnMarshal(Clone)。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AppDomain vs Assembly Code\nAppDomain和程序集的源代码是什么关系呢？每个程序集的代码会分别装载到各个AppDomain中？\n首先我们要把程序集分3类\n1.mscorlib，这是每个.net程序都要引用到的程序集。\n2.GAC，这个是强命名的公用程序集，可以被所有的.net程序引用。\n3.Assembly not in GAC，这是普通的assembly，可以不是强命名，不放到GAC中。\n启动CLR，进入entry point时可以设置LoaderOptimization属性："},{"type":"element","tag":"pre","props":{"code":"[LoaderOptimization(LoaderOptimization.MultiDomain]\nstatic void Main()\n{...}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[LoaderOptimization(LoaderOptimization.MultiDomain]\nstatic void Main()\n{...}\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/20160504151602702.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"LoaderOptimization属性可以设置三个不同的枚举值，来设置针对前面说的三种程序集的代码存放以及访问方式。"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SingleDomain，由于只启动一个AppDomain，那么code就被直接装载到了AppDomain中，访问静态变量更快捷。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MultiDomain，所有的Assembly代码是进程级别的，因此所有的AppDomain只访问一份代码。这大大减少了程序占用的内存，但是由于程序集的静态变量仍然在各个AppDomain中，因此代码访问静态变量需要先得到AppDomain的引用再进行转换，速度会受到影响。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MultiDomainHost，只有GAC代码是共享的，非GAC的Assembly依然会加载到被使用的AppDomain中，这样提高了静态变量的访问速度，当然也增加了程序占用的内存。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"不管是哪种方式，mscorlib始终是process级别的，即只有一份mscorlib代码在内存中。"}]}]}]}]},{"type":"element","tag":"h1","props":{"id":"使用dll进行热更"},"children":[{"type":"text","value":"使用dll进行热更"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文章并不是完全的实现热更新,实现的是windows和android平台下，对于dll文件的热更新。对于IOS为什么不能热更新，我们后续会讨论到，先看看安卓和windows下 dll的热更新步骤。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"新建一个ClassLibrary（类库）的工程，在其中实现对应的类和方法；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将该工程导出为DLL；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将DLL改为bytes文件，存入Unity工程中的StreamingAssets文件夹下；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在工程运行的时候，读取StreamingAssets下的Dll文件，用Assembly.Load(byte[] bytes )的方法，将DLL文件读取出来，进而执行相关的操作。这一步的代码为："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525160707418-392942905.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"unity工程在执行的时候，会构建一个默认的appDomain，Assembly.Load，其实就是在这个程序域上加载Dll,所以相关的实质和前面一个部分相差不大，这就是c#热更新在unity中的应用(IOS不包括)。"}]},{"type":"element","tag":"h3","props":{"id":"ios不能基于以上热更的原因"},"children":[{"type":"text","value":"ios不能基于以上热更的原因"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要我们设定mono的编译模式为full-aot（比如打IOS安装包的时候），则在运行时试图使用JIT编译时，mono自身的JIT编译器就会禁止"},{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"生成新的代码"}]}]},{"type":"text","value":"(不要混淆Reflection.Emit和反射)这种行为进而报告这个异常。JIT编译的过程根本还没开始，就被自己扼杀了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"JIT——just in time，即时编译。"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个程序在它运行的时候创建并且运行了全新的代码，而并非那些最初作为这个程序的一部分保存在硬盘上的固有的代码。就叫JIT。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOS并非把JIT禁止了。或者换个句式讲，IOS封了内存（或者堆）的可执行权限，相当于变相的封锁了JIT这种编译方式。"}]},{"type":"element","tag":"h1","props":{"id":"ilruntime"},"children":[{"type":"text","value":"ILRuntime"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ILRuntime借助Mono.Cecil库来读取DLL的PE信息，以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解译执行虚拟机来执行DLL中的代码"}]}]},{"type":"element","tag":"h3","props":{"id":"借助monoceil库来读取dll的pe信息以及当中类型的所有信息"},"children":[{"type":"text","value":"借助Mono.Ceil库来读取DLL的PE信息以及当中类型的所有信息"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这一步是如何实现的，跟随源代码做一个详细的跟踪。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，是构建一个全局的appDomain(这儿不是程序域的意思，只是取其名字意思来表示)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525183908084-111024744.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于WWW的方式加载AssetBundle或者DLL/PDB后，接下来是将其封入到MemoryStream中，将dll和pdb的bytes都存入到内存流中后，执行其内部实现的LoadAssembly方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525183929820-235902445.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键的是第一行，从Mono中加载模块："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525183948767-1521954007.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"进一步跟踪："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ReadImageFrom的操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184006047-408828631.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中ImageReader最终来自BinaryReader:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184022207-1494733614.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么接下来的ReadImage操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184038682-930110102.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这四个操作，是最核心的操作，分别读取DLL的PE的各个信息，这样我们就进入下一个步骤。"}]},{"type":"element","tag":"h3","props":{"id":"最终得到方法的il汇编码"},"children":[{"type":"text","value":"最终得到方法的IL汇编码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们分拆来看看这几个读取函数的实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1）ReadOptionalHeaders"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主要读取PE的相关信息，不做过多解释，可以参看源码阅读理解；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2）ReadSections"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"读取分块数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184056941-656677137.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"封装一个Section，然后去执行读取，然后赋值给section的Data，注意回退了Index"}]},{"type":"element","tag":"h3","props":{"id":"readcliheader"},"children":[{"type":"text","value":"ReadCLIHeader"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这步比较简单"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184110212-726126206.png"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ReadMetadata"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184136211-1306602825.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"核心是两个操作，一个是ReadMetadataStream，就是根据不同的标识符来新建不同的存储结构；一个是ReadTableHeap:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184150898-1035213362.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"初始化heap中的Table后，进行一次Compute，获取size:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180525184214923-1218850507.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后填充size:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/v2-07369c744923a79035a3729bbc488943_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于这四步操作，我们可以将IL的汇编码存储到Image中，然后进一步执行后续的CreateModule操作:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/v2-0a604dfba776c9c99f2e72627724c340_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体到，就是："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/v2-b252bba4e6d01e512c2305c5c7b355c5_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中的ReadModule为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/v2-32399e9573a7779ecbf82743b30fc184_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体的读取manifest和Module内部数据，可以参看源码。"}]},{"type":"element","tag":"h3","props":{"id":"基于loadedtypes来实现反射方法的调用"},"children":[{"type":"text","value":"基于LoadedTypes来实现反射方法的调用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在ILRuntime中，不能基于System.Type来直接获取热更新DLL中的类，只有基于唯一的appDomain实例，基于LoadedTypes这种来获取热更新中的DLL，基于代码来分析，更为详细："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，加载获取该DLL中的指定类："}]},{"type":"element","tag":"pre","props":{"code":"var it = appDomain.LoadedTypes[\"HotFix_Project.InstanceClass\"]\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var it = appDomain.LoadedTypes[\"HotFix_Project.InstanceClass\"]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"跟踪LoadedTypes："}]},{"type":"element","tag":"pre","props":{"code":"public Dictionary<string, IType> LoadedTypes{get{return mapType.InnerDictionary;}}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public Dictionary<string, IType> LoadedTypes{get{return mapType.InnerDictionary;}}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"跟踪看mapType.InnerDictionary:"}]},{"type":"element","tag":"pre","props":{"code":"ThreadSafeDictionary<string, IType> mapType = new ThreadSafeDictionary<string, IType>();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ThreadSafeDictionary<string, IType> mapType = new ThreadSafeDictionary<string, IType>();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个mapType是什么时候装配的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"来自于文章二中的LoadAssembly的后续操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144431337-1618869539.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么这个module.GetTypes是如何操作的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144453022-436088052.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144501605-1680011964.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分别基于协程来return type以及其nestedTypes，关键是看Types是怎么获取的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144515817-1301453461.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键是read操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144530095-1073548484.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"继续跟进Read操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144543549-1339229040.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键是："}]},{"type":"element","tag":"pre","props":{"code":"var mtypes = metadata.Types\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var mtypes = metadata.Types\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后续都是对其的封装和填充，对于metadata的填充，来自于InitializeTypeDefinitions这个操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144611448-160157189.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键操作是ReadType这个操作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144626456-2070945940.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"构建一个内部定义的类，然后做数据填充，看看关键的几个属性的设置：BaseType ,设置其父类型，fields"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"range/methods_range"}]},{"type":"text","value":" 是对属性范围和方法范围的设置："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144639749-1842647497.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以基本方法还是ReadListRange:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144651716-2020934616.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这儿，我们最终回到了文章二中对于IL虚拟机中的tableHeap的引用，最后实现了和文章二的首尾呼应。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，收起思绪，回到最开始的，获取类，这样获得的一个类，这样得到的一个类，继承自IType，在Unity主工程中，则需要System.Type才能继续使用反射接口，其对于的封装来自昱这个ILType封装的ReflectionType， 其中的ILRuntimeType继承自Type类："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144705308-507336274.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于其，可以直接调用System.Type的GetConstructor方法，构建实例，归并几个代码，可以表示为（直接使用的实例源代码）："}]},{"type":"element","tag":"pre","props":{"code":"var it = appDomain.LoadedTypes[\"HotFix_Project.InstanceClass\"];\nvar type = it.ReflectionType;\nvar ctor = type.GetConstructor(new System.Type[0]);\nvar obj = ctor.Invoke(null);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var it = appDomain.LoadedTypes[\"HotFix_Project.InstanceClass\"];\nvar type = it.ReflectionType;\nvar ctor = type.GetConstructor(new System.Type[0]);\nvar obj = ctor.Invoke(null);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对应可以得到DLL中该类的构造函数的调用："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144743649-1121461434.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"基于appdomain内嵌的invoke来实现反射"},"children":[{"type":"text","value":"基于appDomain内嵌的Invoke来实现反射"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在ILRuntime中，在appDomain中内嵌了一套Invoke的实现，可以在Unity工程中直接调用来实现对热更新DLL中类的方法的调用："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144758068-1015276210.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键操作就是2步： GetType和 GetMethod，获取类型的过程，和前面有点类似，就是对mapType中存储的获取，如果没有，则进行查找和填充，这儿重点说说方法是如何获取的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144811489-2012923950.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"粗看就是从methods中取出来，做相应的检查，如果通过则返回，那么初始化操作看看："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144823104-1803890663.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后还是从definition.Methods中取出，逐个遍历其中的方法做一个分类存储，如果有静态构造函数，且满足对于的参数条件，则执行一次静态构造。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回到开始，在获取到类和方法的相关信息后，就可以执行对于的参数检验，然后执行反射："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144840373-1429288247.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可见，就是获取到一个IL的解释器，然后执行相应的反射，具体Run怎么执行，就不继续深入贴图了，有兴趣的可以持续跟踪（基本思路就是对stack的操作，塞入各个参数，然后执行一次操作，塞入结果，然后退回）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于ILRuntime的反射基本就先研究到这儿，如果要应用到自己的项目中，可以继续深入研究一下代码，看看实现的具体细节。这儿附上开源的相关文档："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"/v1/guide/reflection.html"},"children":[{"type":"text","value":"ILRuntime中的反射"}]}]},{"type":"element","tag":"h3","props":{"id":"热更新dll和unity主工程的相互调用"},"children":[{"type":"text","value":"热更新DLL和Unity主工程的相互调用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于前面的反射，我们可以基本理出热更DLL和unity主工程的交互本质: 基于IL虚拟机或者.net本身反射来实现交互，对于热更新DLL，其调用unity主工程，则主要是在热更新工程中添加对于unity工程的Assembly-CSharp的引用："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144900607-89436059.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于这个引用，可以调用其中类的各自方法，举两个类来测试："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个不继承自MonoBehaviour："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144913680-316348813.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个继承自MonoBehaviour:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144932643-1419524295.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这两个Unity主工程中的类以及其中的方法，在热更新DLL中调用："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528144946464-1425100319.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以在Unity主工程中得到输出："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-ilruntime/656520-20180528145001101-1886163550.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看一下track可以大概了解整个反射的执行过程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于Unity执行热更DLL中的调用，就是第一部分的反射实例。"}]},{"type":"element","tag":"h1","props":{"id":"热修复hotfix"},"children":[{"type":"text","value":"热修复HOTFIX"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"腾讯开源的Unity热更解决方案xLua有一个非常吸引人的特性就是Hotfix，其原理是使用Mono.Cecil库对进行C#层编译出来的dll程序集进行IL代码注入。其作者也在知乎的回答中简单说明了原理："},{"type":"element","tag":"a","props":{"href":"https://link.jianshu.com/?t=https://www.zhihu.com/question/54344452/answer/139413144","rel":["nofollow"]},"children":[{"type":"text","value":"如何评价腾讯在Unity下的xLua（开源）热更方案？ - 车雄生的回答 - 知乎"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Mono.Ceil"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个可加载并浏览现有程序集并进行动态修改并保存的.NET框架。可以静态注入程序集（注入后生成新的程序集）和动态注入程序集（注入后不改变目标程序集，只在运行时改变程序集行为。可以通过其实现AOP等高级功能"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity的代码在修改之后会自动编译到Library\\ScriptAssemblies下的两个Assembly中，所以我会尝试着将代码注入到其中。"}]},{"type":"element","tag":"pre","props":{"code":"public class Test : MonoBehaviour{\n\n    void Start()\n    {\n       InjectMod();\n    }\n\n    void InjectMod () {\n       Debug.Log(\"Heihei asdasd\");\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Test : MonoBehaviour{\n\n    void Start()\n    {\n       InjectMod();\n    }\n\n    void InjectMod () {\n       Debug.Log(\"Heihei asdasd\");\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将Test绑定到场景物体上，运行后我们会发现输出"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Heihei asdasd"}]},{"type":"text","value":"，就像我们预期的一样。 然后我们尝试着将代码注入到该函数中。"}]},{"type":"element","tag":"pre","props":{"code":"private static bool hasGen = false;\n[PostProcessBuild(1000)]\nprivate static void OnPostprocessBuildPlayer(BuildTarget buildTarget, string buildPath)\n{\n   hasGen = false;\n}\n\n[PostProcessScene]\npublic static void TestInjectMothodOnPost()\n{\n   if (hasGen == true) return;\n   hasGen = true;\n\n   TestInjectMothod();\n}\n[InitializeOnLoadMethod]\npublic static void TestInjectMothod()\n{\n   var assembly = AssemblyDefinition.ReadAssembly(@\"D:\\Documents\\Unity5Projects\\UnityDllInjector\\Library\\ScriptAssemblies\\Assembly-CSharp.dll\");\n   var types = assembly.MainModule.GetTypes();\n   foreach(var type in types)\n   {\n      foreach(var Method in type.Methods)\n      {\n         if(Method.Name == \"InjectMod\")\n         {\n            InjectMethod(Method, assembly);\n         }\n      }\n   }\n   var writerParameters = new WriterParameters { WriteSymbols = true };\n   assembly.Write(@\"D:\\Documents\\Unity5Projects\\UnityDllInjector\\Library\\ScriptAssemblies\\Assembly-CSharp.dll\", new WriterParameters());\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private static bool hasGen = false;\n[PostProcessBuild(1000)]\nprivate static void OnPostprocessBuildPlayer(BuildTarget buildTarget, string buildPath)\n{\n   hasGen = false;\n}\n\n[PostProcessScene]\npublic static void TestInjectMothodOnPost()\n{\n   if (hasGen == true) return;\n   hasGen = true;\n\n   TestInjectMothod();\n}\n[InitializeOnLoadMethod]\npublic static void TestInjectMothod()\n{\n   var assembly = AssemblyDefinition.ReadAssembly(@\"D:\\Documents\\Unity5Projects\\UnityDllInjector\\Library\\ScriptAssemblies\\Assembly-CSharp.dll\");\n   var types = assembly.MainModule.GetTypes();\n   foreach(var type in types)\n   {\n      foreach(var Method in type.Methods)\n      {\n         if(Method.Name == \"InjectMod\")\n         {\n            InjectMethod(Method, assembly);\n         }\n      }\n   }\n   var writerParameters = new WriterParameters { WriteSymbols = true };\n   assembly.Write(@\"D:\\Documents\\Unity5Projects\\UnityDllInjector\\Library\\ScriptAssemblies\\Assembly-CSharp.dll\", new WriterParameters());\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们首先看"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TestInjectMothod"}]},{"type":"text","value":",这是我们在编辑器下进行注入的函数，这里我们需要注意的是，每当我们修改代码之后我们注入的结果会被覆盖掉，所以我们在每次修改代码之后都需要进行注入，所以我们这里添加了标签："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InitializeOnLoadMethod "}]},{"type":"text","value":"这个标签的意思是，当初始化的时候都进行执行，所以编译完成之后就会自动执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后我们看前面两个函数，这两个函数是为了在打包时进行注入而存在的，其中hasGen是为了防止重复注入而定义的flag。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后我们查看一下我们的注入方法"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InjectMethod"}]},{"type":"text","value":",在这个函数中我们可以看到，我们首先将我们所需要的函数导入，然后插入到方法的最前端："}]},{"type":"element","tag":"pre","props":{"code":"private static void InjectMethod(MethodDefinition method, AssemblyDefinition assembly)\n{\n   var firstIns = method.Body.Instructions.First();\n   var worker = method.Body.GetILProcessor();\n\n   //获取Debug.Log方法引用\n   var hasPatchRef = assembly.MainModule.Import(\n   typeof(Debug).GetMethod(\"Log\", new Type[] { typeof(string) }));\n   //插入函数\n   var current = InsertBefore(worker, firstIns, worker.Create(OpCodes.Ldstr, \"Inject\"));\n   current = InsertBefore(worker, firstIns, worker.Create(OpCodes.Call, hasPatchRef));\n   //计算Offset\n   ComputeOffsets(method.Body);\n}\n/// <summary>\n/// 语句前插入Instruction, 并返回当前语句\n/// </summary>\nprivate static Instruction InsertBefore(ILProcessor worker, Instruction target, Instruction instruction)\n{\n   worker.InsertBefore(target, instruction);\n   return instruction;\n}\n\n/// <summary>\n/// 语句后插入Instruction, 并返回当前语句\n/// </summary>\nprivate static Instruction InsertAfter(ILProcessor worker, Instruction target, Instruction instruction)\n{\n   worker.InsertAfter(target, instruction);\n   return instruction;\n}\n//计算注入后的函数偏移值\nprivate static void ComputeOffsets(MethodBody body)\n{\n   var offset = 0;\n   foreach (var instruction in body.Instructions)\n   {\n      instruction.Offset = offset;\n      offset += instruction.GetSize();\n   }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private static void InjectMethod(MethodDefinition method, AssemblyDefinition assembly)\n{\n   var firstIns = method.Body.Instructions.First();\n   var worker = method.Body.GetILProcessor();\n\n   //获取Debug.Log方法引用\n   var hasPatchRef = assembly.MainModule.Import(\n   typeof(Debug).GetMethod(\"Log\", new Type[] { typeof(string) }));\n   //插入函数\n   var current = InsertBefore(worker, firstIns, worker.Create(OpCodes.Ldstr, \"Inject\"));\n   current = InsertBefore(worker, firstIns, worker.Create(OpCodes.Call, hasPatchRef));\n   //计算Offset\n   ComputeOffsets(method.Body);\n}\n/// <summary>\n/// 语句前插入Instruction, 并返回当前语句\n/// </summary>\nprivate static Instruction InsertBefore(ILProcessor worker, Instruction target, Instruction instruction)\n{\n   worker.InsertBefore(target, instruction);\n   return instruction;\n}\n\n/// <summary>\n/// 语句后插入Instruction, 并返回当前语句\n/// </summary>\nprivate static Instruction InsertAfter(ILProcessor worker, Instruction target, Instruction instruction)\n{\n   worker.InsertAfter(target, instruction);\n   return instruction;\n}\n//计算注入后的函数偏移值\nprivate static void ComputeOffsets(MethodBody body)\n{\n   var offset = 0;\n   foreach (var instruction in body.Instructions)\n   {\n      instruction.Offset = offset;\n      offset += instruction.GetSize();\n   }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"等待编译完成，并且运行程序，我们发现在输出原来的语句之前多了一句“Inject”\n可是我们在查看代码的时候并没有发生任何改变，这是因为我们只修改了dll而并非修改源代码。"}]},{"type":"element","tag":"h1","props":{"id":"注意"},"children":[{"type":"text","value":"注意"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ILRuntime并没有创建一个Appdomain,只是取其名字意思.始终工作在默认的AppDomain"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ILRuntime中使用Unity项目的委托,需要创建"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"DelegateAdapter"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ILRuntime中继承Unity项目中的类,需要实现"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"继承适配器"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常情况下，如果要从热更DLL中调用Unity主工程或者Unity的接口，是需要通过反射接口来调用的，包括市面上不少其他热更方案，也是通过这种方式来对CLR方接口进行调用的。(反射一个类,然后创建对象,然后保存到runtime中,调用方法也是通过反射)"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"但是这种方式有着明显的弊端，最突出的一点就是通过反射来调用接口调用效率会比直接调用低很多，再加上反射传递函数参数时需要使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"object[]"}]},{"type":"text","value":"数组，这样不可避免的每次调用都会产生不少GC Alloc。众所周知GC Alloc高意味着在Unity中执行会存在较大的性能问题。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"ILRuntime通过CLR方法绑定机制，可以"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"选择性"}]},{"type":"text","value":"的对经常使用的CLR接口进行直接调用，从而尽可能的消除反射调用开销以及额外的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GC Alloc"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"CLR绑定借助了ILRuntime的CLR重定向机制来实现，因为实质上也是将对CLR方法的反射调用重定向到我们自己定义的方法里面来。"}]}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/use","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/use"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/murongxiaopifu/p/4278947.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/murongxiaopifu/p/4278947.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/murongxiaopifu/p/4211964.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/murongxiaopifu/p/4211964.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/zblade/p/9100146.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/zblade/p/9100146.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://ourpalm.github.io/ILRuntime/public/v1/guide/bind.html","rel":["nofollow"]},"children":[{"type":"text","value":"http://ourpalm.github.io/ILRuntime/public/v1/guide/bind.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/4bef7f66aefd","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.jianshu.com/p/4bef7f66aefd"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"ios不能基于以上热更的原因","depth":3,"text":"ios不能基于以上热更的原因"},{"id":"借助monoceil库来读取dll的pe信息以及当中类型的所有信息","depth":3,"text":"借助Mono.Ceil库来读取DLL的PE信息以及当中类型的所有信息"},{"id":"最终得到方法的il汇编码","depth":3,"text":"最终得到方法的IL汇编码"},{"id":"readcliheader","depth":3,"text":"ReadCLIHeader"},{"id":"基于loadedtypes来实现反射方法的调用","depth":3,"text":"基于LoadedTypes来实现反射方法的调用"},{"id":"基于appdomain内嵌的invoke来实现反射","depth":3,"text":"基于appDomain内嵌的Invoke来实现反射"},{"id":"热更新dll和unity主工程的相互调用","depth":3,"text":"热更新DLL和Unity主工程的相互调用"}]}},"_type":"markdown","_id":"content:unity:2019-09-02-ilruntime.md","_source":"content","_file":"unity/2019-09-02-ilruntime.md","_extension":"md","date":"2019-09-02"},{"_path":"/unity/2019-09-02-unity-reference-dll","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity的宏以及添加net框架中未引用的dll","description":"unity默认的#defind宏变量\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty:Function:UNITY_EDITOR#define directive for calling Unity Editor scripts from your game code.UNITY_EDITOR_WIN#define directive for Editor code on Windows.UNITY_EDITOR_O","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"unity默认的defind宏变量"},"children":[{"type":"text","value":"unity默认的#defind宏变量"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Property:"}]}]},{"type":"element","tag":"th","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Function:"}]}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_EDITOR"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for calling Unity Editor scripts from your game code."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_EDITOR_WIN"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for Editor code on Windows."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_EDITOR_OSX"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for Editor code on Mac OS X."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_STANDALONE_OSX"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for compiling/executing code specifically for Mac OS X (including Universal, PPC and Intel architectures)."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_STANDALONE_WIN"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for compiling/executing code specifically for Windows standalone applications."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_STANDALONE_LINUX"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for compiling/executing code specifically for Linux standalone applications."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_STANDALONE"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for compiling/executing code for any standalone platform (Mac OS X, Windows or Linux)."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WII"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for compiling/executing code for the Wii console."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_IOS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for compiling/executing code for the iOS platform."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_IPHONE"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Deprecated. Use "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_IOS"}]},{"type":"text","value":" instead."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_ANDROID"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for the Android platform."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_PS4"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for running "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"PlayStation 4"}]},{"type":"text","value":"  code."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_XBOXONE"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for executing "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Xbox One"}]},{"type":"text","value":"  code."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_TIZEN"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for the Tizen platform."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_TVOS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for the Apple TV platform."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WSA"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Universal Windows Platform"}]},{"type":"text","value":" . Additionally, "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"NETFX_CORE"}]},{"type":"text","value":" is defined when compiling C# files against .NET Core and using .NET "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"scripting backend"}]},{"type":"text","value":" ."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WSA_10_0"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for Universal Windows Platform. Additionally "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"WINDOWS_UWP"}]},{"type":"text","value":" is defined when compiling C# files against .NET Core."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WINRT"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Same as "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WSA"}]},{"type":"text","value":"."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WINRT_10_0"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Equivalent to "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WSA_10_0"}]}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_WEBGL"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"WebGL"}]},{"type":"text","value":" ."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_FACEBOOK"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for the Facebook platform (WebGL or Windows standalone)."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_ADS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for calling Unity Ads methods from your game code. Version 5.2 and above."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_ANALYTICS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for calling Unity "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Analytics"}]},{"type":"text","value":"  methods from your game code. Version 5.2 and above."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UNITY_ASSERTIONS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"#define directive for assertions control process."}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"在-net-4x-和-net-standard-20-配置文件之间进行选择"},"children":[{"type":"text","value":"在 .NET 4.x 和 .NET Standard 2.0 配置文件之间进行选择"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一旦切换到 .NET 4.x 等效脚本运行时，可使用 PlayerSettings 中的下拉菜单指定“Api Compatibility Level”（“Edit > Project Settings > Player”）。 有两种选项："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":".NET Standard 2.0"}]},{"type":"text","value":"。 此配置文件与 .NET Foundation 发布的 "},{"type":"element","tag":"a","props":{"href":"https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md","rel":["nofollow"]},"children":[{"type":"text","value":".NET Standard 2.0 配置文件"}]},{"type":"text","value":"匹配。 Unity 建议新项目使用 .NET Standard 2.0。 它比 .NET 4.x 小，有利于尺寸受限的平台。 此外，Unity 承诺在 Unity 支持的所有平台上支持此配置文件。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":".NET 4.x"}]},{"type":"text","value":"。 此配置文件提供对最新 .NET 4 API 的访问权限。 它包括 .NET Framework 类库中提供的所有代码，并且支持 .NET Standard 2.0 配置文件。 如果 .NET Standard 2.0 配置文件中未包含项目所需的部分 API，请使用 .NET 4.x 配置文件。 但此 API 的某些部分并非在所有 Unity 平台上均受支持。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可在 Unity 的"},{"type":"element","tag":"a","props":{"href":"https://blogs.unity3d.com/2018/03/28/updated-scripting-runtime-in-unity-2018-1-what-does-the-future-hold/","rel":["nofollow"]},"children":[{"type":"text","value":"博客文章"}]},{"type":"text","value":"中阅读有关这些选项的更多信息。"}]},{"type":"element","tag":"h3","props":{"id":"使用-net-4x-api-兼容级别时添加程序集引用"},"children":[{"type":"text","value":"使用 .NET 4.x API 兼容级别时添加程序集引用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在“API 兼容级别”下拉列表中使用 .NET Standard 2.0 设置时，将引用和使用 API 配置文件中的所有程序集。 但是，在使用较大的 .NET 4.x 配置文件时，默认情况下不会引用 Unity 附带的某些程序集。 若要使用这些 API，必须手动添加程序集引用。 可在 Unity 编辑器安装的 MonoBleedingEdge/lib/mono 目录中查看 Unity 附带的程序集："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"MonoBleedingEdge 目录","src":"/images/2019-09-02-unity-reference-dll/vstu_monobleedingedge.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，如果使用的是 .NET 4.x 配置文件且希望使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpClient"}]},{"type":"text","value":"，则必须为 System.Net.Http.dll 添加程序集引用。 如果没有它，编译器将报错，指示缺少程序集引用："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"缺少程序集引用","src":"/images/2019-09-02-unity-reference-dll/vstu_missing-reference.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每次打开 Unity 项目时 Visual Studio 都会为其重新生成 .csproj 和 .sln 文件。 因此，无法直接在 Visual Studio 中添加程序集引用，因为它们将在重新打开项目时丢失。 相反，必须使用名为 mcs.rsp 的特殊文本文件："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 Unity 项目的根Assets目录中创建名为 mcs.rsp 的新文本文件。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在空文本文件的第一行，输入："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"-r:System.Net.Http.dll"}]},{"type":"text","value":"，然后保存文件。 可将“System.Net.Http.dll”替换为可能缺少引用的任何包含的程序集。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重启 Unity 编辑器。"}]}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-cn/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-cn/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/PlatformDependentCompilation.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/PlatformDependentCompilation.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"在-net-4x-和-net-standard-20-配置文件之间进行选择","depth":2,"text":"在 .NET 4.x 和 .NET Standard 2.0 配置文件之间进行选择","children":[{"id":"使用-net-4x-api-兼容级别时添加程序集引用","depth":3,"text":"使用 .NET 4.x API 兼容级别时添加程序集引用"}]},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:unity:2019-09-02-unity-reference-dll.md","_source":"content","_file":"unity/2019-09-02-unity-reference-dll.md","_extension":"md","date":"2019-09-02"},{"_path":"/unity/2019-09-03-xlua-inject","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"xlua注入源码解读","description":"让C#代码支持热更的流程Generate Code\n这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。Hotfix Inject\n这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码Generate Code 实现和生成结果\n在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Im","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让C#代码支持热更的流程"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generate Code\n这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hotfix Inject\n这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Generate Code 实现和生成结果"}]},{"type":"text","value":"\n在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Imp这个就是到时候要重复使用到的映射到Lua中function的委托。"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public void __Gen_Delegate_Imp0()\n{\n    RealStatePtr L = luaEnv.rawL;\n    int errFunc = LuaAPI.pcall_prepare(L, errorFuncRef, luaReference);\n    PCall(L, 0, 0, errFunc);\n    LuaAPI.lua_settop(L, errFunc - 1);\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void __Gen_Delegate_Imp0()\n{\n    RealStatePtr L = luaEnv.rawL;\n    int errFunc = LuaAPI.pcall_prepare(L, errorFuncRef, luaReference);\n    PCall(L, 0, 0, errFunc);\n    LuaAPI.lua_settop(L, errFunc - 1);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生成的代码就是先设置errorFuncRef（异常回调），luaReference（Lua方法）。如果在XLua中设置了热更修复代码，那么就会在C#中生成一个DelegateBridge，而其luaReference的指向就是Lua中的方法，所以这个只能调用指定的__Gen_Delegate_Imp，调用其他会报错。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hotfix Inject"}]},{"type":"text","value":"\n这一步是在Unity为C#代码生成完对应dll之后，由XLua再来对dll注入一些判断条件式来完成是否进行Lua调用的行为。\n判断方法很简单，检查对应类静态字段是否有DelegateBridge对象。\n实现如下："}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"bool injectMethod(MethodDefinition method, HotfixFlagInTool hotfixType)\n{\n            var type = method.DeclaringType;\n            bool isFinalize = (method.Name == \"Finalize\" && method.IsSpecialName);\n            //__Gen_Delegate_Imp 方法引用\n            MethodReference invoke = null;\n            int param_count = method.Parameters.Count + (method.IsStatic ? 0 : 1);\n            //根据返回值和参数个数类型，查找对应的委托方法\n            if (!findHotfixDelegate(method, out invoke, hotfixType))\n            {\n                Error(\"can not find delegate for \" + method.DeclaringType + \".\" + method.Name + \"! try re-genertate code.\");\n                return false;\n            }\n\n            if (invoke == null)\n            {\n                throw new Exception(\"unknow exception!\");\n            }\n            \n            invoke = injectAssembly.MainModule.Import(invoke);\n            //插入的类静态字段，用来标记对应的方法是否有对应的Lua注入\n            FieldReference fieldReference = null;\n            //方法中的变量定义\n            VariableDefinition injection = null;\n            bool isIntKey = hotfixType.HasFlag(HotfixFlagInTool.IntKey) && !type.HasGenericParameters && isTheSameAssembly;\n            //isIntKey = !type.HasGenericParameters;\n\n            if (!isIntKey)\n            {\n                //新建变量，加入方法体的变量组中\n                injection = new VariableDefinition(invoke.DeclaringType);\n                method.Body.Variables.Add(injection);\n                //获取这个方法对应的委托名，因为有重载方法存在，所以之前已经注入的过的方法会在这边获取时候计数加1，\n                //比如第一个重载获取的是__Hotfix0，那么下一个重载会是__Hotfix1，判断是否注入就是是否设置对应FieldReference。\n                var luaDelegateName = getDelegateName(method);\n                if (luaDelegateName == null)\n                {\n                    Error(\"too many overload!\");\n                    return false;\n                }\n                //创建对应的静态Field名字就是上面取到的luaDelegateName \n                FieldDefinition fieldDefinition = new FieldDefinition(luaDelegateName, Mono.Cecil.FieldAttributes.Static | Mono.Cecil.FieldAttributes.Private,\n                    invoke.DeclaringType);\n                type.Fields.Add(fieldDefinition);\n                fieldReference = fieldDefinition.GetGeneric();\n            }\n\n            bool ignoreValueType = hotfixType.HasFlag(HotfixFlagInTool.ValueTypeBoxing);\n            //IL插入位置，现在定位的是方法体的第一行\n            var insertPoint = method.Body.Instructions[0];\n            //获取IL处理器\n            var processor = method.Body.GetILProcessor();\n            //构造函数的处理逻辑先跳过这边不做分析\n            if (method.IsConstructor)\n            {\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            Dictionary<Instruction, Instruction> originToNewTarget = new Dictionary<Instruction, Instruction>();\n            HashSet<Instruction> noCheck = new HashSet<Instruction>();\n            \n            while (insertPoint != null)\n            {\n                //isIntKey这边用到的是Xlua中的AutoIdMap，这边只对最基础的功能做分析，这边就分析基础的注入了。\n                Instruction firstInstruction;\n                if (isIntKey)\n                {\n                    firstInstruction = processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count);\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, hotfixFlagGetter));\n                }\n                else\n                {\n                    //创建第一条IL语句，获取类的静态Field压入方法栈中，其实就是之前luaDelegateName获取的字段\n                    firstInstruction = processor.Create(OpCodes.Ldsfld, fieldReference);\n                    //插入insertPoint之前\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    //创建并插入IL，获取栈顶的值并压入到对应的变量中，injection就是我们之前创建的新建变量\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Stloc, injection));\n                    //创建并插入IL，压入变量体中的值到栈\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n                //创建跳转语句，为false时候直接跳转insertPoint,\n                //这边OpCodes.Brfalse看起来是布尔值判断，其实也会判断是否为null\n                var jmpInstruction = processor.Create(OpCodes.Brfalse, insertPoint);\n                processor.InsertBefore(insertPoint, jmpInstruction);\n\n                if (isIntKey)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count));\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, delegateBridgeGetter));\n                }\n                else\n                {\n                    //创建并插入IL,再次压入变量的值，因为上面做完判断后，栈顶的值就会被弹出，所以这边要再次压入\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n\n                for (int i = 0; i < param_count; i++)\n                {\n                    if (i < ldargs.Length)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(ldargs[i]));\n                    }\n                    else if (i < 256)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg_S, (byte)i));\n                    }\n                    else\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg, (short)i));\n                    }\n                    if (i == 0 && !method.IsStatic && type.IsValueType)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldobj, type));\n                        \n                    }\n                    //对值类型进行Box\n                    if (ignoreValueType)\n                    {\n                        TypeReference paramType;\n                        if (method.IsStatic)\n                        {\n                            paramType = method.Parameters[i].ParameterType;\n                        }\n                        else\n                        {\n                            paramType = (i == 0) ? type : method.Parameters[i - 1].ParameterType;\n                        }\n                        if (paramType.IsValueType)\n                        {\n                            processor.InsertBefore(insertPoint, processor.Create(OpCodes.Box, paramType));\n                        }\n                    }\n                }\n                //创建并插入IL，调用invoke方法，因为之前已经压入injection的值，DelegateBridge的对象\n                processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, invoke));\n                //普通方法，加入返回操作\n                if (!method.IsConstructor && !isFinalize)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ret));\n                }\n\n                if (!method.IsConstructor)\n                {\n                    break;\n                }\n                else\n                {\n                    originToNewTarget[insertPoint] = firstInstruction;\n                    noCheck.Add(jmpInstruction);\n                }\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            if (method.IsConstructor)\n            {\n                fixBranch(processor, method.Body.Instructions, originToNewTarget, noCheck);\n            }\n\n            if (isFinalize)\n            {\n                if (method.Body.ExceptionHandlers.Count == 0)\n                {\n                    throw new InvalidProgramException(\"Finalize has not try-catch? Type :\" + method.DeclaringType);\n                }\n                method.Body.ExceptionHandlers[0].TryStart = method.Body.Instructions[0];\n            }\n            if (isIntKey)\n            {\n                bridgeIndexByKey.Add(method);\n            }\n            return true;\n}\nstatic string getDelegateName(MethodDefinition method)\n{\n            string fieldName = method.Name;\n            if (fieldName.StartsWith(\".\"))\n            {\n                fieldName = fieldName.Substring(1);\n            }\n            string ccFlag = method.IsConstructor ? \"_c\" : \"\";\n            string luaDelegateName = null;\n            var type = method.DeclaringType;\n            for (int i = 0; i < MAX_OVERLOAD; i++)\n            {\n                string tmp = ccFlag + \"__Hotfix\" + i + \"_\" + fieldName;\n                if (!type.Fields.Any(f => f.Name == tmp)) // injected\n                {\n                    luaDelegateName = tmp;\n                    break;\n                }\n            }\n            return luaDelegateName;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"bool injectMethod(MethodDefinition method, HotfixFlagInTool hotfixType)\n{\n            var type = method.DeclaringType;\n            bool isFinalize = (method.Name == \"Finalize\" && method.IsSpecialName);\n            //__Gen_Delegate_Imp 方法引用\n            MethodReference invoke = null;\n            int param_count = method.Parameters.Count + (method.IsStatic ? 0 : 1);\n            //根据返回值和参数个数类型，查找对应的委托方法\n            if (!findHotfixDelegate(method, out invoke, hotfixType))\n            {\n                Error(\"can not find delegate for \" + method.DeclaringType + \".\" + method.Name + \"! try re-genertate code.\");\n                return false;\n            }\n\n            if (invoke == null)\n            {\n                throw new Exception(\"unknow exception!\");\n            }\n            \n            invoke = injectAssembly.MainModule.Import(invoke);\n            //插入的类静态字段，用来标记对应的方法是否有对应的Lua注入\n            FieldReference fieldReference = null;\n            //方法中的变量定义\n            VariableDefinition injection = null;\n            bool isIntKey = hotfixType.HasFlag(HotfixFlagInTool.IntKey) && !type.HasGenericParameters && isTheSameAssembly;\n            //isIntKey = !type.HasGenericParameters;\n\n            if (!isIntKey)\n            {\n                //新建变量，加入方法体的变量组中\n                injection = new VariableDefinition(invoke.DeclaringType);\n                method.Body.Variables.Add(injection);\n                //获取这个方法对应的委托名，因为有重载方法存在，所以之前已经注入的过的方法会在这边获取时候计数加1，\n                //比如第一个重载获取的是__Hotfix0，那么下一个重载会是__Hotfix1，判断是否注入就是是否设置对应FieldReference。\n                var luaDelegateName = getDelegateName(method);\n                if (luaDelegateName == null)\n                {\n                    Error(\"too many overload!\");\n                    return false;\n                }\n                //创建对应的静态Field名字就是上面取到的luaDelegateName \n                FieldDefinition fieldDefinition = new FieldDefinition(luaDelegateName, Mono.Cecil.FieldAttributes.Static | Mono.Cecil.FieldAttributes.Private,\n                    invoke.DeclaringType);\n                type.Fields.Add(fieldDefinition);\n                fieldReference = fieldDefinition.GetGeneric();\n            }\n\n            bool ignoreValueType = hotfixType.HasFlag(HotfixFlagInTool.ValueTypeBoxing);\n            //IL插入位置，现在定位的是方法体的第一行\n            var insertPoint = method.Body.Instructions[0];\n            //获取IL处理器\n            var processor = method.Body.GetILProcessor();\n            //构造函数的处理逻辑先跳过这边不做分析\n            if (method.IsConstructor)\n            {\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            Dictionary<Instruction, Instruction> originToNewTarget = new Dictionary<Instruction, Instruction>();\n            HashSet<Instruction> noCheck = new HashSet<Instruction>();\n            \n            while (insertPoint != null)\n            {\n                //isIntKey这边用到的是Xlua中的AutoIdMap，这边只对最基础的功能做分析，这边就分析基础的注入了。\n                Instruction firstInstruction;\n                if (isIntKey)\n                {\n                    firstInstruction = processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count);\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, hotfixFlagGetter));\n                }\n                else\n                {\n                    //创建第一条IL语句，获取类的静态Field压入方法栈中，其实就是之前luaDelegateName获取的字段\n                    firstInstruction = processor.Create(OpCodes.Ldsfld, fieldReference);\n                    //插入insertPoint之前\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    //创建并插入IL，获取栈顶的值并压入到对应的变量中，injection就是我们之前创建的新建变量\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Stloc, injection));\n                    //创建并插入IL，压入变量体中的值到栈\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n                //创建跳转语句，为false时候直接跳转insertPoint,\n                //这边OpCodes.Brfalse看起来是布尔值判断，其实也会判断是否为null\n                var jmpInstruction = processor.Create(OpCodes.Brfalse, insertPoint);\n                processor.InsertBefore(insertPoint, jmpInstruction);\n\n                if (isIntKey)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count));\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, delegateBridgeGetter));\n                }\n                else\n                {\n                    //创建并插入IL,再次压入变量的值，因为上面做完判断后，栈顶的值就会被弹出，所以这边要再次压入\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n\n                for (int i = 0; i < param_count; i++)\n                {\n                    if (i < ldargs.Length)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(ldargs[i]));\n                    }\n                    else if (i < 256)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg_S, (byte)i));\n                    }\n                    else\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg, (short)i));\n                    }\n                    if (i == 0 && !method.IsStatic && type.IsValueType)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldobj, type));\n                        \n                    }\n                    //对值类型进行Box\n                    if (ignoreValueType)\n                    {\n                        TypeReference paramType;\n                        if (method.IsStatic)\n                        {\n                            paramType = method.Parameters[i].ParameterType;\n                        }\n                        else\n                        {\n                            paramType = (i == 0) ? type : method.Parameters[i - 1].ParameterType;\n                        }\n                        if (paramType.IsValueType)\n                        {\n                            processor.InsertBefore(insertPoint, processor.Create(OpCodes.Box, paramType));\n                        }\n                    }\n                }\n                //创建并插入IL，调用invoke方法，因为之前已经压入injection的值，DelegateBridge的对象\n                processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, invoke));\n                //普通方法，加入返回操作\n                if (!method.IsConstructor && !isFinalize)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ret));\n                }\n\n                if (!method.IsConstructor)\n                {\n                    break;\n                }\n                else\n                {\n                    originToNewTarget[insertPoint] = firstInstruction;\n                    noCheck.Add(jmpInstruction);\n                }\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            if (method.IsConstructor)\n            {\n                fixBranch(processor, method.Body.Instructions, originToNewTarget, noCheck);\n            }\n\n            if (isFinalize)\n            {\n                if (method.Body.ExceptionHandlers.Count == 0)\n                {\n                    throw new InvalidProgramException(\"Finalize has not try-catch? Type :\" + method.DeclaringType);\n                }\n                method.Body.ExceptionHandlers[0].TryStart = method.Body.Instructions[0];\n            }\n            if (isIntKey)\n            {\n                bridgeIndexByKey.Add(method);\n            }\n            return true;\n}\nstatic string getDelegateName(MethodDefinition method)\n{\n            string fieldName = method.Name;\n            if (fieldName.StartsWith(\".\"))\n            {\n                fieldName = fieldName.Substring(1);\n            }\n            string ccFlag = method.IsConstructor ? \"_c\" : \"\";\n            string luaDelegateName = null;\n            var type = method.DeclaringType;\n            for (int i = 0; i < MAX_OVERLOAD; i++)\n            {\n                string tmp = ccFlag + \"__Hotfix\" + i + \"_\" + fieldName;\n                if (!type.Fields.Any(f => f.Name == tmp)) // injected\n                {\n                    luaDelegateName = tmp;\n                    break;\n                }\n            }\n            return luaDelegateName;\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"xlua.hotfix"}]},{"type":"text","value":"在完成生成代码和注入后，只要在Lua中调用xlua.hotfix或util.hotfix*ex方法就可以实现C#代码热更了。*hotfix和hotfixex的区别在与是否可以调用原C#代码，其实ex的实现也是调用了hotfix，在下面将分析hotfix和hotfix_ex的实现原理。\n先分析下hotfix的Lua代码，代码在第一篇文章中的实例化lua中："}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"     init_xlua.lua\n     xlua.hotfix = function(cs, field, func)\n                //判空\n                if func == nil then func = false end\n                //检查并且统一转化为table\n                //因为在Xlua中可以一次传一个方法，或者一次传一组方法\n                local tbl = (type(field) == 'table') and field or {[field] = func}\n                //遍历需要hotfix的代码，key是方法名，v是对应的func\n                for k, v in pairs(tbl) do\n                    //构造函数的hotfix，这边不做分析了，原理一样\n                    local cflag = ''\n                    if k == '.ctor' then\n                        cflag = '_c'\n                        k = 'ctor'\n                    end\n                    //检查v的类型\n                    local f = type(v) == 'function' and v or nil\n                    //调用access函数，其在初始化注册，最终实现在C#中下文解析实现\n                    xlua.access(cs, cflag .. '__Hotfix0_'..k, f) -- at least one\n                    //尝试给重载方法也添加上function如果有重载的话\n                    pcall(function()\n                        for i = 1, 99 do\n                            xlua.access(cs, cflag .. '__Hotfix'..i..'_'..k, f)\n                        end\n                    end)\n                end\n                //设置私有访问\n                xlua.private_accessible(cs)\n              end\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"     init_xlua.lua\n     xlua.hotfix = function(cs, field, func)\n                //判空\n                if func == nil then func = false end\n                //检查并且统一转化为table\n                //因为在Xlua中可以一次传一个方法，或者一次传一组方法\n                local tbl = (type(field) == 'table') and field or {[field] = func}\n                //遍历需要hotfix的代码，key是方法名，v是对应的func\n                for k, v in pairs(tbl) do\n                    //构造函数的hotfix，这边不做分析了，原理一样\n                    local cflag = ''\n                    if k == '.ctor' then\n                        cflag = '_c'\n                        k = 'ctor'\n                    end\n                    //检查v的类型\n                    local f = type(v) == 'function' and v or nil\n                    //调用access函数，其在初始化注册，最终实现在C#中下文解析实现\n                    xlua.access(cs, cflag .. '__Hotfix0_'..k, f) -- at least one\n                    //尝试给重载方法也添加上function如果有重载的话\n                    pcall(function()\n                        for i = 1, 99 do\n                            xlua.access(cs, cflag .. '__Hotfix'..i..'_'..k, f)\n                        end\n                    end)\n                end\n                //设置私有访问\n                xlua.private_accessible(cs)\n              end\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"XLuaAccess在C#中的实现："}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"        //xlua.access(cs, cflag .. '__Hotfix0_'..k, f)\n\n        public static int XLuaAccess(RealStatePtr L)\n        {\n            try\n            {\n                \n                ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n                //获取对应的CS类Type\n                Type type = getType(L, translator, 1);\n                object obj = null;\n                if (type == null && LuaAPI.lua_type(L, 1) == LuaTypes.LUA_TUSERDATA)\n                {\n                    obj = translator.SafeGetCSObj(L, 1);\n                    if (obj == null)\n                    {\n                        return LuaAPI.luaL_error(L, \"xlua.access, #1 parameter must a type/c# object/string\");\n                    }\n                    type = obj.GetType();\n                }\n\n                if (type == null)\n                {\n                    return LuaAPI.luaL_error(L, \"xlua.access, can not find c# type\");\n                }\n                //将cflag .. '__Hotfix0_'..k 转为fieldName，这个字段就是之前Inject时候创建的类静态字段名\n                string fieldName = LuaAPI.lua_tostring(L, 2);\n\n                BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;\n                //这边访问一定是Set所以后面就不分析了，这边就是反射获取对应的FieldInfo，重点在于translator.GetObject方法。\n                if (LuaAPI.lua_gettop(L) > 2) // set\n                {\n                    var field = type.GetField(fieldName, bindingFlags);\n                    if (field != null)\n                    {\n                        field.SetValue(obj, translator.GetObject(L, 3, field.FieldType));\n                        return 0;\n                    }\n                    var prop = type.GetProperty(fieldName, bindingFlags);\n                    if (prop != null)\n                    {\n                        prop.SetValue(obj, translator.GetObject(L, 3, prop.PropertyType), null);\n                        return 0;\n                    }\n                }\n                else\n                {\n                    ...\n                }\n                return LuaAPI.luaL_error(L, \"xlua.access, no field \" + fieldName);\n            }\n            catch (Exception e)\n            {\n                return LuaAPI.luaL_error(L, \"c# exception in xlua.access: \" + e);\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object GetObject(RealStatePtr L, int index, Type type)\n        {\n            int udata = LuaAPI.xlua_tocsobj_safe(L, index);\n\n            if (udata != -1)\n            {\n                ...\n            }\n            else\n            {\n                //一些特殊值类型的返回\n                ...\n                return (objectCasters.GetCaster(type)(L, index, null));\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public ObjectCast GetCaster(Type type)\n       {\n            ...\n            ObjectCast oc;\n            //缓存行为，继续分析第一次获取的caster委托\n            if (!castersMap.TryGetValue(type, out oc))\n            {\n                oc = genCaster(type);\n                castersMap.Add(type, oc);\n            }\n            return oc;\n        }\n        //为了减少篇幅，只展示必要代码\n        private ObjectCast genCaster(Type type)\n        {\n            \n            ObjectCast fixTypeGetter = (RealStatePtr L, int idx, object target) =>\n            {\n                if (LuaAPI.lua_type(L, idx) == LuaTypes.LUA_TUSERDATA)\n                {\n                    object obj = translator.SafeGetCSObj(L, idx);\n                    return (obj != null && type.IsAssignableFrom(obj.GetType())) ? obj : null;\n                }\n                return null;\n            }; \n            if ...\n            //在Inject代码时候我们已经知道其字段类型就是DelegateBridge，所以会返回的就是这个表达式\n            else if (typeof(DelegateBridgeBase).IsAssignableFrom(type))\n            {\n                return (RealStatePtr L, int idx, object target) =>\n                {\n                    //缓存行为，分析CreateDelegateBridge\n                    object obj = fixTypeGetter(L, idx, target);\n                    if (obj != null) return obj;\n\n                    if (!LuaAPI.lua_isfunction(L, idx))\n                    {\n                        return null;\n                    }\n\n                    return translator.CreateDelegateBridge(L, null, idx);\n                };\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx)\n        {\n            //这边只是查找是否这个方法已经有缓存了，有的话直接返回，没有就要Create，我们继续分析Create的事。\n            LuaAPI.lua_pushvalue(L, idx);\n            LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);\n            //不为null就是已经生成过，就直接从缓存获取\n            if (!LuaAPI.lua_isnil(L, -1))\n            {\n                retrun ...\n            }\n            else\n            {\n                //弹出刚刚查询过的nil值\n                LuaAPI.lua_pop(L, 1);\n            }\n            //开始生成对应的DelegateBridge\n            //压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //获取function对应的引用id\n            int reference = LuaAPI.luaL_ref(L);\n            //再次压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //压入function对应的引用id\n            LuaAPI.lua_pushnumber(L, reference);\n            //将栈顶的两个值以字典形式存在全局变量表中，这个的作用就是上面的代码查询是否已经在lua中缓存。\n            LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n            DelegateBridgeBase bridge;\n            try\n            {\n                //创建DelegateBridge，注意这边的reference，这个就是对应了lua中修复的lua函数，\n                //我们在Inject时候call的方法会使用到这个参数。\n                bridge = new DelegateBridge(reference, luaEnv);\n            }\n            catch(Exception e)\n            {\n                //异常情况下的，清场操作\n                LuaAPI.lua_pushvalue(L, idx);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.xlua_rawseti(L, LuaIndexes.LUA_REGISTRYINDEX, reference);\n                throw e;\n            }\n            //因为hotfix时候，delegateType传进来是个null，后续代码不会被调用到，就不做分析了。\n            if (delegateType == null)\n            {\n                //缓存到字典中，注意这里是弱引用所以会被回收，被回收后，需要从lua中查询到对应引用值，然后再生产。\n                delegate_bridges[reference] = new WeakReference(bridge);\n                return bridge;\n            }\n            ...\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        //xlua.access(cs, cflag .. '__Hotfix0_'..k, f)\n\n        public static int XLuaAccess(RealStatePtr L)\n        {\n            try\n            {\n                \n                ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n                //获取对应的CS类Type\n                Type type = getType(L, translator, 1);\n                object obj = null;\n                if (type == null && LuaAPI.lua_type(L, 1) == LuaTypes.LUA_TUSERDATA)\n                {\n                    obj = translator.SafeGetCSObj(L, 1);\n                    if (obj == null)\n                    {\n                        return LuaAPI.luaL_error(L, \"xlua.access, #1 parameter must a type/c# object/string\");\n                    }\n                    type = obj.GetType();\n                }\n\n                if (type == null)\n                {\n                    return LuaAPI.luaL_error(L, \"xlua.access, can not find c# type\");\n                }\n                //将cflag .. '__Hotfix0_'..k 转为fieldName，这个字段就是之前Inject时候创建的类静态字段名\n                string fieldName = LuaAPI.lua_tostring(L, 2);\n\n                BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;\n                //这边访问一定是Set所以后面就不分析了，这边就是反射获取对应的FieldInfo，重点在于translator.GetObject方法。\n                if (LuaAPI.lua_gettop(L) > 2) // set\n                {\n                    var field = type.GetField(fieldName, bindingFlags);\n                    if (field != null)\n                    {\n                        field.SetValue(obj, translator.GetObject(L, 3, field.FieldType));\n                        return 0;\n                    }\n                    var prop = type.GetProperty(fieldName, bindingFlags);\n                    if (prop != null)\n                    {\n                        prop.SetValue(obj, translator.GetObject(L, 3, prop.PropertyType), null);\n                        return 0;\n                    }\n                }\n                else\n                {\n                    ...\n                }\n                return LuaAPI.luaL_error(L, \"xlua.access, no field \" + fieldName);\n            }\n            catch (Exception e)\n            {\n                return LuaAPI.luaL_error(L, \"c# exception in xlua.access: \" + e);\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object GetObject(RealStatePtr L, int index, Type type)\n        {\n            int udata = LuaAPI.xlua_tocsobj_safe(L, index);\n\n            if (udata != -1)\n            {\n                ...\n            }\n            else\n            {\n                //一些特殊值类型的返回\n                ...\n                return (objectCasters.GetCaster(type)(L, index, null));\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public ObjectCast GetCaster(Type type)\n       {\n            ...\n            ObjectCast oc;\n            //缓存行为，继续分析第一次获取的caster委托\n            if (!castersMap.TryGetValue(type, out oc))\n            {\n                oc = genCaster(type);\n                castersMap.Add(type, oc);\n            }\n            return oc;\n        }\n        //为了减少篇幅，只展示必要代码\n        private ObjectCast genCaster(Type type)\n        {\n            \n            ObjectCast fixTypeGetter = (RealStatePtr L, int idx, object target) =>\n            {\n                if (LuaAPI.lua_type(L, idx) == LuaTypes.LUA_TUSERDATA)\n                {\n                    object obj = translator.SafeGetCSObj(L, idx);\n                    return (obj != null && type.IsAssignableFrom(obj.GetType())) ? obj : null;\n                }\n                return null;\n            }; \n            if ...\n            //在Inject代码时候我们已经知道其字段类型就是DelegateBridge，所以会返回的就是这个表达式\n            else if (typeof(DelegateBridgeBase).IsAssignableFrom(type))\n            {\n                return (RealStatePtr L, int idx, object target) =>\n                {\n                    //缓存行为，分析CreateDelegateBridge\n                    object obj = fixTypeGetter(L, idx, target);\n                    if (obj != null) return obj;\n\n                    if (!LuaAPI.lua_isfunction(L, idx))\n                    {\n                        return null;\n                    }\n\n                    return translator.CreateDelegateBridge(L, null, idx);\n                };\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx)\n        {\n            //这边只是查找是否这个方法已经有缓存了，有的话直接返回，没有就要Create，我们继续分析Create的事。\n            LuaAPI.lua_pushvalue(L, idx);\n            LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);\n            //不为null就是已经生成过，就直接从缓存获取\n            if (!LuaAPI.lua_isnil(L, -1))\n            {\n                retrun ...\n            }\n            else\n            {\n                //弹出刚刚查询过的nil值\n                LuaAPI.lua_pop(L, 1);\n            }\n            //开始生成对应的DelegateBridge\n            //压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //获取function对应的引用id\n            int reference = LuaAPI.luaL_ref(L);\n            //再次压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //压入function对应的引用id\n            LuaAPI.lua_pushnumber(L, reference);\n            //将栈顶的两个值以字典形式存在全局变量表中，这个的作用就是上面的代码查询是否已经在lua中缓存。\n            LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n            DelegateBridgeBase bridge;\n            try\n            {\n                //创建DelegateBridge，注意这边的reference，这个就是对应了lua中修复的lua函数，\n                //我们在Inject时候call的方法会使用到这个参数。\n                bridge = new DelegateBridge(reference, luaEnv);\n            }\n            catch(Exception e)\n            {\n                //异常情况下的，清场操作\n                LuaAPI.lua_pushvalue(L, idx);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.xlua_rawseti(L, LuaIndexes.LUA_REGISTRYINDEX, reference);\n                throw e;\n            }\n            //因为hotfix时候，delegateType传进来是个null，后续代码不会被调用到，就不做分析了。\n            if (delegateType == null)\n            {\n                //缓存到字典中，注意这里是弱引用所以会被回收，被回收后，需要从lua中查询到对应引用值，然后再生产。\n                delegate_bridges[reference] = new WeakReference(bridge);\n                return bridge;\n            }\n            ...\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样在进行调用hotfix后，对应的要修复的类的静态字段就会被设置上对应的DelegateBridge对象，然后在C#代码执行到对应的需要热更修复的方法时候，会先执行我们注入的IL代码，检查是否有对应的DelegateBridge。那么就是调用DelegateBridge中对应的方法，方法中包含的reference就是Lua对应的function，这样就执行到了lua中去，实现了热更。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"util.hotfix_ex的实现"}]},{"type":"text","value":"\n其实现直白的来讲就是在调用util.hotfix_ex(functionB)时候，真正设置的是一个中间函数A，它被设置为对应方法的热更修复函数。\n在调用A进行热更时候，它先设置这个方法的热更方法为空，然后调用原先设置的functionB，当functionB调用完后，然后再设置回热更方法为A，那么就能实现在热更修复方法functionB中调用原先的方法。\n因为设置这些参数都是带反射的，所以在高频场景是有性能消耗的。\n代码实现如下："}]}]},{"type":"element","tag":"pre","props":{"className":["language-lua"],"code":"local function hotfix_ex(cs, field, func)\n    --断言，检查参数\n    assert(type(field) == 'string' and type(func) == 'function', 'invalid argument: #2 string needed, #3 function needed!')\n    --创建中间函数，就是上文提到的A\n    local function func_after(...)\n        --先将需要热更修复的方法设置为nil，那么再调用方法时候会执行的就是之前方法\n        xlua.hotfix(cs, field, nil)\n        --执行func，就是上文提到的functionB\n        local ret = {func(...)}\n        ---重新将需要热更修复的方法设置为中间函数A\n        xlua.hotfix(cs, field, func_after)\n        return unpack(ret)\n    end\n    --设置需要热更修复为中间函数A\n    xlua.hotfix(cs, field, func_after)\nend\n","language":"lua","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"local function hotfix_ex(cs, field, func)\n    --断言，检查参数\n    assert(type(field) == 'string' and type(func) == 'function', 'invalid argument: #2 string needed, #3 function needed!')\n    --创建中间函数，就是上文提到的A\n    local function func_after(...)\n        --先将需要热更修复的方法设置为nil，那么再调用方法时候会执行的就是之前方法\n        xlua.hotfix(cs, field, nil)\n        --执行func，就是上文提到的functionB\n        local ret = {func(...)}\n        ---重新将需要热更修复的方法设置为中间函数A\n        xlua.hotfix(cs, field, func_after)\n        return unpack(ret)\n    end\n    --设置需要热更修复为中间函数A\n    xlua.hotfix(cs, field, func_after)\nend\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"结束语"}]},{"type":"text","value":"整个Hotfix的实现也分析完了，后续的文章将继续分析，XLua中的各种优化技巧实现，比如无GC传值，模板生成技术。"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2019-09-03-xlua-inject.md","_source":"content","_file":"unity/2019-09-03-xlua-inject.md","_extension":"md","date":"2019-09-03"},{"_path":"/unity/2019-09-04-mono.cecil-inject","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"如何快速的注入汇编","description":"写汇编码比较麻烦,可以试下下面的方法,先写好你要注入的代码,然后编译好,使用ilsyp查看...选择到要注入的代码再使用Reflexil工具查看","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写汇编码比较麻烦,可以试下下面的方法,先写好你要注入的代码,然后编译好,使用ilsyp查看...选择到要注入的代码再使用Reflexil工具查看"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用ilsyp"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用reflexil就能看到他的汇编码"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"1567660270933","src":"/images/2019-09-04-mono.cecil-inject/1567660270933.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2019-09-04-mono.cecil-inject.md","_source":"content","_file":"unity/2019-09-04-mono.cecil-inject.md","_extension":"md","date":"2019-09-04"},{"_path":"/unity/2019-09-13-parallax-2d","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"2D游戏视差背景的实现","description":"什么是视差背景？视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。简单地说，视差背景其实就是通过多层次的背景来模拟透视视差效果：就是当发生移动时，离照相机越近的背景移动越快；反之越慢。这样，我们的背景就会形成类似于透视视差的效果。那么，既然需要透视效果，为何不直接使用透视投影来做呢？这个原因是如果使用透视投影来产生视差的话，我们的远景必须真的是一个非常大的背景，你如果想模拟出一百倍于近景的远景，那么可能就需要相应尺寸的背景贴图。这种做法显然是","body":{"type":"root","children":[{"type":"element","tag":"h4","props":{"id":"什么是视差背景"},"children":[{"type":"text","value":"什么是视差背景？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简单地说，视差背景其实就是通过多层次的背景来模拟透视视差效果：就是当发生移动时，离照相机越近的背景移动越快；反之越慢。这样，我们的背景就会形成类似于透视视差的效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，既然需要透视效果，为何不直接使用透视投影来做呢？这个原因是如果使用透视投影来产生视差的话，我们的远景必须真的是一个非常大的背景，你如果想模拟出一百倍于近景的远景，那么可能就需要相应尺寸的背景贴图。这种做法显然是做不到的。当然，如果是3D 背景的话有其他方式，不过对于2D 游戏而言，最直接有效的还是多层次背景模拟出视差效果。我们这里也主要聊聊如果通过多层次背景滚动的方式实现视差效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在整个视差背景实现过程中，需要完成两个主要工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"实现单层背景的滚动；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"复合多层背景的滚动，实现视差效果；"}]}]},{"type":"element","tag":"h4","props":{"id":"实现单层背景的滚动"},"children":[{"type":"text","value":"实现单层背景的滚动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"背景滚动是实现视差效果的核心也是最重要的问题。背景滚动存在横向和纵向两种。所有使用视差背景的游戏都会有横向滚动的情况，而纵向滚动则未必都会有。我们这里以横向滚动来介绍背景滚动。我们有四种常规方式可以实现背景的滚动："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过移动一个四边形顶点的 UV 移动形成滚动，之后就称之为 UV 滚动方式；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过滚动移动多个连续的背景精灵形成滚动，之后就称之为精灵滚动方式；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加背景层照相机，移动照相机形成滚动，之后就称之为照相机移动方式；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"精灵滚动方式和照相机移动方式混合使用，之后就称之为混合滚动方式；"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了更好地解释这几种实现方式，需要几张图片用于介绍："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们使用一个黄框精灵代表屏幕取景区域："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952876756Yj6.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来是三张可拼接的背景精灵："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952876820zdg.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952876827Lvz.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952876811twL.png"},"children":[]}]},{"type":"element","tag":"h5","props":{"id":"uv-滚动方式"},"children":[{"type":"text","value":"UV 滚动方式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 UV 坐标移动形成滚动的效果看起来是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952876924lOw.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 UV 坐标移动的方法中，我们只是用一个和照相机取景区域一样大的精灵作为背景渲染区域。然后通过调整它的 UV 坐标和采样方式实现平铺背景以及背景滚动。具体实现步骤："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"准备一个覆盖整个屏幕的四边形顶点，并使用它显示背景贴图；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调整 UV 坐标和纹理之间的采样方式，以实现纹理连续显示；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"移动时，修改四个顶点的 UV 坐标形成滚动；"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为我们只使用一张精灵，我们区域采样的方式就是通过 UV 坐标。因此此方式下 UV 坐标存在两个作用："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UV 坐标的整数部分标记了当前采样位置使用哪一张背景贴图；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UV 坐标小数部分为选中背景贴图的采样 UV 坐标；"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，此精灵的 UV 坐标必定会大于[0,1]区间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果背景使用的背景贴图只有一张的话，这个问题很容易解决。我们只要设置图形 API（OpenGL 或 DirectX，这里以 OpenGL 为例）的纹理包装类型（即所谓的 wrapping 类型）即可。所谓的包装类型即指定了当 UV 坐标值在[ 0,1 ]区间之外时，如何获取纹理。那么这里，我们需要让一张纹理重复出现。在 OpenGL 中，我们需要调用此函数来完成包装类型的设置：glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );稍微解释一下此函数：glTexParameteri 函数会对指定的纹理的参数进行设置。我们这里针对2D 纹理（第一参数 GL_TEXTURE_2D）的 x 方向即横向（第二参数 GL_TEXTURE_WRAP_S）的包装模式设置为重复出现的方式（第三参数 GL_REPEAT）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过如果背景是多张不同的纹理连续出现的话，就不能使用上面的方法解决了。这个时候我们需要编写一个简单的 shader 在 shader 中完成 UV 坐标映射。这里截取出演示 demo 中，获取纹理相关的 shader 代码（GLSL 代码）提供大家参考："}]},{"type":"element","tag":"pre","props":{"code":"//我们有三张背景贴图，对 UV 坐标对3取模，得到使用哪一种背景贴图。             \nint _index = int( mod( v_TexCoord.x, 3.0 ));\n//使用此贴图并使用 UV 坐标的小数部分进行像素采样。            \ngl_FragData[0] = texture( u_BackgroundTextures[_index], fract(v_TexCoord));  \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//我们有三张背景贴图，对 UV 坐标对3取模，得到使用哪一种背景贴图。             \nint _index = int( mod( v_TexCoord.x, 3.0 ));\n//使用此贴图并使用 UV 坐标的小数部分进行像素采样。            \ngl_FragData[0] = texture( u_BackgroundTextures[_index], fract(v_TexCoord));  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UV 方式有着非常良好的性能，但是缺点就是只能处理简单的平铺背景，对于有着复杂结构或是效果的滚动背景没有办法使用。"}]},{"type":"element","tag":"h5","props":{"id":"精灵滚动方式"},"children":[{"type":"text","value":"精灵滚动方式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用精灵滚动形成滚动的效果看起来是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-10195287789913d.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方式应该是比较直接的。我们首先使用背景精灵拼接出背景取景区域覆盖到的背景区域。然后在发生背景移动时，我们依然不需要移动背景取景区域，而是通过滚动移动所有的背景精灵来实现背景移动的效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方式实现简单直接，但缺点是发生背景移动时，需要对所有的背景精灵进行移动。对于结构复杂元素较多的背景需要占用更多的性能。"}]},{"type":"element","tag":"h5","props":{"id":"照相机移动方式"},"children":[{"type":"text","value":"照相机移动方式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用照相机移动形成滚动的效果看起来是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952878215omm.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方式与精灵滚动方式正好相反。在这种方式下，我们需要使用背景精灵拼接出完整的背景。同时在背景移动时，不移动背景精灵转而移动背景取景区域来实现背景移动效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方式在移动过程中由于只需要移动背景照相机，所以有种很好的移动性能。但是为了使用此方法。我们需要预先将整个背景全部拼接。这样导致同时存在过多的背景精灵在场景中。如果使用的游戏引擎没有场景管理器或是场景管理器性能不佳的情况下，此方式反而会带来额外的性能消耗。"}]},{"type":"element","tag":"h5","props":{"id":"混合滚动方式"},"children":[{"type":"text","value":"混合滚动方式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用混合滚动方式形成的滚动效果看起来是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/u-101952878467iBp.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顾名思义，混合移动混合了精灵移动和照相机移动两种方式。我们在移动背景取景区域的同时，适时地滚动背景精灵。使得背景取景区域内的背景正确。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方式结合了精灵滚动方式和照相机移动方式。避免了精灵滚动方式移动过程中，因为需要移动所有背景精灵带来的额外性能开销；也避免了照相机移动方式中，需要预先构建完整的背景而导致场景中存在过多的背景精灵带来的额外性能开销。当然，和照相机移动方式一样，避免不了每一层背景都需要有一个独立的背景照相机。同时在代码实现良好的情况下，性能比前两者都要好。"}]},{"type":"element","tag":"h4","props":{"id":"四种方式的优劣"},"children":[{"type":"text","value":"四种方式的优劣"}]},{"type":"element","tag":"h5","props":{"id":"平均性能"},"children":[{"type":"text","value":"平均性能："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UV 滚动方式只使用了一个四边形并且移动时也只是单纯改变了 UV 采样方式。它的性能是最好的；其次是混合滚动方式；照相机移动方式有更多的空间开销，同时此开销对性能的影响与游戏引擎的场景管理模块密切关联；精灵方式则有最大的移动性能消耗。"}]},{"type":"element","tag":"h5","props":{"id":"对复杂背景的支持"},"children":[{"type":"text","value":"对复杂背景的支持："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"即四种方式所实现的背景可以有多复杂。UV 滚动方式碍于实现只能做简单的平铺背景的滚动效果；精灵滚动方式和混合滚动方式可以实现更为复杂一点的背景，可以在简单的平铺背景之上加入一些其他背景精灵元素；而照相机移动方式对背景的构建没有要求，它可以支持非常复杂的背景。"}]},{"type":"element","tag":"h5","props":{"id":"是否可以无限延伸"},"children":[{"type":"text","value":"是否可以无限延伸："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"理论上四种方式都可以实现无限延伸。但是对于照相机移动方式来说，实现起来会比较麻烦。而另外三种方式都是循环利用同一个背景，所以天然支持无限延伸的背景。"}]},{"type":"element","tag":"h5","props":{"id":"复合多层背景的滚动实现视差效果"},"children":[{"type":"text","value":"复合多层背景的滚动，实现视差效果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有了上面的工作，这一步也是顺其自然就可以完成："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们首先要构建多层背景，多层背景可以同时只是用一种滚动方式；也可以不同层背景使用不同的滚动方式。比如最远的背景由于基本上都是简单的平铺可以使用 UV 滚动方式构建；而再近一点细节较多的背景层可以考虑后几种滚动方式构建背景。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之后是移动，我们需要根据每一层背景的距离决定其在移动过程中的移动速度。速度如何决定并没有统一的方法或是模式。总之，这一点听听美术们的意见是比较合适的。"}]},{"type":"element","tag":"h3","props":{"id":"unity混合模式1"},"children":[{"type":"text","value":"Unity混合模式1"}]},{"type":"element","tag":"pre","props":{"code":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n/// <summary>\n/// Weiva Parallax\n/// 2D 视差效果\n/// 本组件背景视差效果是根据背景对象的世界坐标z值来计算。默认参数中的背景数组第一个元素为最远平面，\n/// 既与摄像机同步的平面，该对象之间的背景根据z值进行视差计算。也可以单独设置参数 synZ 强制设置最\n/// 远平面。大于最远平面的 z 值将会反超摄像机移动。\n/// weivain@qq.com\n/// www.weiva.com\n/// </summary>\npublic class WVParallax : MonoBehaviour {\n \n    [Header(\"背景图片对象，Element 0 为与摄像机同步的背景层\")]\n    public Transform[] backgrounds;\n \n    // 主摄像机\n    private Transform cam;\n    // 上一帧摄像机的位置\n    private Vector3 previousCamPos;\n    // 摄像机同步背景层的 z 值\n    [Header(\"摄像机同步背景层Z值，若0为背景层0\")]\n    public float synZ=0f;\n    [Header(\"偏移x系数\")]\n    public float parallaxScaleX=1f;\n    [Header(\"偏移y系数\")]\n    public float parallaxScaleY=1f;\n \n \n    // 初始化\n    void Start ()\n    {\n        cam = Camera.main.transform;\n        // 上一帧摄像机的位置\n        previousCamPos = cam.position;\n        if(synZ == 0 && null != backgrounds[0])\n        {\n            synZ = backgrounds[0].position.z;\n        }\n        if(synZ == 0)\n        {\n            synZ = 100f;\n        }\n         \n    }\n     \n    // 每一帧执行\n    void Update ()\n    {\n        // 获得摄像机和上一帧的偏移值\n        float parallax = previousCamPos.x - cam.position.x;\n \n        //摄像机偏移矢量\n        Vector3 camMove = cam.position - previousCamPos;\n        camMove.x *= parallaxScaleX;\n        camMove.y *= parallaxScaleY;\n \n        //同步背景\n        for (int i = 0; i < backgrounds.Length; i++)\n        {\n            if (null == backgrounds[i]) continue;\n \n            Vector3 targetToMove = backgrounds[i].position + camMove * (backgrounds[i].position.z/synZ);\n            backgrounds[i].position = targetToMove;\n \n        }\n \n        // 更新上一帧摄像机的位置\n        previousCamPos = cam.position;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n/// <summary>\n/// Weiva Parallax\n/// 2D 视差效果\n/// 本组件背景视差效果是根据背景对象的世界坐标z值来计算。默认参数中的背景数组第一个元素为最远平面，\n/// 既与摄像机同步的平面，该对象之间的背景根据z值进行视差计算。也可以单独设置参数 synZ 强制设置最\n/// 远平面。大于最远平面的 z 值将会反超摄像机移动。\n/// weivain@qq.com\n/// www.weiva.com\n/// </summary>\npublic class WVParallax : MonoBehaviour {\n \n    [Header(\"背景图片对象，Element 0 为与摄像机同步的背景层\")]\n    public Transform[] backgrounds;\n \n    // 主摄像机\n    private Transform cam;\n    // 上一帧摄像机的位置\n    private Vector3 previousCamPos;\n    // 摄像机同步背景层的 z 值\n    [Header(\"摄像机同步背景层Z值，若0为背景层0\")]\n    public float synZ=0f;\n    [Header(\"偏移x系数\")]\n    public float parallaxScaleX=1f;\n    [Header(\"偏移y系数\")]\n    public float parallaxScaleY=1f;\n \n \n    // 初始化\n    void Start ()\n    {\n        cam = Camera.main.transform;\n        // 上一帧摄像机的位置\n        previousCamPos = cam.position;\n        if(synZ == 0 && null != backgrounds[0])\n        {\n            synZ = backgrounds[0].position.z;\n        }\n        if(synZ == 0)\n        {\n            synZ = 100f;\n        }\n         \n    }\n     \n    // 每一帧执行\n    void Update ()\n    {\n        // 获得摄像机和上一帧的偏移值\n        float parallax = previousCamPos.x - cam.position.x;\n \n        //摄像机偏移矢量\n        Vector3 camMove = cam.position - previousCamPos;\n        camMove.x *= parallaxScaleX;\n        camMove.y *= parallaxScaleY;\n \n        //同步背景\n        for (int i = 0; i < backgrounds.Length; i++)\n        {\n            if (null == backgrounds[i]) continue;\n \n            Vector3 targetToMove = backgrounds[i].position + camMove * (backgrounds[i].position.z/synZ);\n            backgrounds[i].position = targetToMove;\n \n        }\n \n        // 更新上一帧摄像机的位置\n        previousCamPos = cam.position;\n    }\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"unity混合模式2"},"children":[{"type":"text","value":"Unity混合模式2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Unity官方2D游戏Demo中已使用到了视差滚动技术，笔者对此 Demo 中的视差滚动技术进行了研究，Demo 中使用 BackgroundParallax 脚本实现了视差功能，笔者编写此脚本代码说明。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"4","src":"/images/2019-09-13-Parallax-2d/424-1024x415.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"官方 demo "},{"type":"element","tag":"a","props":{"href":"https://assetstore.unity.com/packages/essentials/tutorial-projects/2d-platformer-11228","rel":["nofollow"]},"children":[{"type":"text","value":"链接"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BackgroundParallax脚本代码说明："}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\n\npublic class BackgroundParallax : MonoBehaviour\n{\n    public Transform[] backgrounds;             // Array of all the backgrounds to be parallaxed.\n    public float parallaxScale;                 // The proportion of the camera's movement to move the backgrounds by.\n    public float parallaxReductionFactor;       // How much less each successive layer should parallax.\n    public float smoothing;                     // How smooth the parallax effect should be.\n\n\n    private Transform cam;                      // Shorter reference to the main camera's transform.\n    private Vector3 previousCamPos;             // The postion of the camera in the previous frame.\n\n\n    void Awake ()\n    {\n        // Setting up the reference shortcut.\n        cam = Camera.main.transform;\n    }\n\n\n    void Start ()\n    {\n        // The 'previous frame' had the current frame's camera position.\n        previousCamPos = cam.position;\n    }\n\n\n    void Update ()\n    {\n        // The parallax is the opposite of the camera movement since the previous frame multiplied by the scale.\n        float parallax = (previousCamPos.x - cam.position.x) * parallaxScale;\n\n        // For each successive background...\n        for(int i = 0; i < backgrounds.Length; i++)\n        {\n            // ... set a target x position which is their current position plus the parallax multiplied by the reduction.\n            float backgroundTargetPosX = backgrounds[i].position.x + parallax * (i * parallaxReductionFactor + 1);\n\n            // Create a target position which is the background's current position but with it's target x position.\n            Vector3 backgroundTargetPos = new Vector3(backgroundTargetPosX, backgrounds[i].position.y, backgrounds[i].position.z);\n\n            // Lerp the background's position between itself and it's target position.\n            backgrounds[i].position = Vector3.Lerp(backgrounds[i].position, backgroundTargetPos, smoothing * Time.deltaTime);\n        }\n\n        // Set the previousCamPos to the camera's position at the end of this frame.\n        previousCamPos = cam.position;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\n\npublic class BackgroundParallax : MonoBehaviour\n{\n    public Transform[] backgrounds;             // Array of all the backgrounds to be parallaxed.\n    public float parallaxScale;                 // The proportion of the camera's movement to move the backgrounds by.\n    public float parallaxReductionFactor;       // How much less each successive layer should parallax.\n    public float smoothing;                     // How smooth the parallax effect should be.\n\n\n    private Transform cam;                      // Shorter reference to the main camera's transform.\n    private Vector3 previousCamPos;             // The postion of the camera in the previous frame.\n\n\n    void Awake ()\n    {\n        // Setting up the reference shortcut.\n        cam = Camera.main.transform;\n    }\n\n\n    void Start ()\n    {\n        // The 'previous frame' had the current frame's camera position.\n        previousCamPos = cam.position;\n    }\n\n\n    void Update ()\n    {\n        // The parallax is the opposite of the camera movement since the previous frame multiplied by the scale.\n        float parallax = (previousCamPos.x - cam.position.x) * parallaxScale;\n\n        // For each successive background...\n        for(int i = 0; i < backgrounds.Length; i++)\n        {\n            // ... set a target x position which is their current position plus the parallax multiplied by the reduction.\n            float backgroundTargetPosX = backgrounds[i].position.x + parallax * (i * parallaxReductionFactor + 1);\n\n            // Create a target position which is the background's current position but with it's target x position.\n            Vector3 backgroundTargetPos = new Vector3(backgroundTargetPosX, backgrounds[i].position.y, backgrounds[i].position.z);\n\n            // Lerp the background's position between itself and it's target position.\n            backgrounds[i].position = Vector3.Lerp(backgrounds[i].position, backgroundTargetPos, smoothing * Time.deltaTime);\n        }\n\n        // Set the previousCamPos to the camera's position at the end of this frame.\n        previousCamPos = cam.position;\n    }\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"结合透视和正交相机在unity2d游戏中制作视差效果"},"children":[{"type":"text","value":"结合透视和正交相机在Unity2D游戏中制作视差效果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在开发MimpiDreams时，我们知道我们想用背景和前景做丰富的视差层。在Steam版本中，有几个图层来管理。所以我们想出了一个可能并不是独一无二的方法，不过在这里还是想概括一下。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在unity中有好多使用一个正交相机并用脚本移动图层来设置视差层级的教程。还有一些建议用透视相机和对象的Z轴深度。如果这么做了，设置合适的精灵排序就会变的困难，并且还不能使用优化技术和其他想在MimpiDreams中使用的透视相机的特性。经典的 Mimpi 只用了透视相机来创建，对此我们还有一些"},{"type":"element","tag":"a","props":{"href":"http://www.manew.com/forum-ask-1.html","rel":["nofollow"]},"children":[{"type":"text","value":"问题"}]},{"type":"text","value":"。为了节省填充率我们使用了不透明的对象，不过不得不用Z轴偏移来放置它们以免Z方向有冲突。然而，由于对它们应用了透视视角，它们就以不同的速度移动了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最好的方法是获得两者的优势。设置透视相机来渲染视差层，用正交相机来渲染有角色，平台，拼图等的主平面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当为视差使用透视相机时，就很容易设置它们了。在正交视差中，需要基于相机的距离来缩放每一个对象并放在适当的位置。Toby: The SecretMine的作者Lukáš Navrátil告诉我他差不多会花掉一半的工作时间来设置正交视差层。随着我们技术的结合，他可以做的更快。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我和我的同事Jaroslav Stehlík一起开发了这种技术。现在让我们看一下如何设置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Camera and Scene Setup"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相机和场景设置"}]},{"type":"text","value":"\n层级视图很简单。将视差相机放在主相机的下边，这样它们会一起移动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/181708eqz39rii9vrvuopx.png.thumb.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Main Camera"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"主相机"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clear Flags: Don’tclear"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Culling Mask except parallax layer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Projection"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Depth: -1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Parallax Camera Near"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"近距离视差相机"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clear Flags: Depthonly"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Culling Mask"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Projection"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clipping Planes"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Near: 0.01"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Far: 10"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Depth: 0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Parallax Camera Far"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"远距离视差相机"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clear Flags: SolidColor (or whatever else you want to use as a background)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Culling Mask"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Projection"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clipping Planes"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Near: 10"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Far: 500"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Depth: -2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/camera.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主相机会渲染除正交模式中视差层级之外的所有东西。这需要熟练使用“CullingMask”。“Clipping Planes”解决基于Z轴方向哪个视差对象被哪个视差相机渲染的问题，因此前景在正交平面之前，背景则在它的后边。相机放在Z轴-10的位置，所以在Z < 0的视差中的所有东西都会被近处的相机渲染，在Z > 0位置的对象就会被远处的相机渲染。“Depth”决定相机被渲染的正确顺序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在在编辑器中需要把所有的视差对象放入视差层中，并将其他所有对象移出该层。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/cameraview.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你需要考虑正交相机的尺寸和视角设置的透视区域。尤其想在游戏中使用变焦的时候，需要基于主相机的正交尺寸来设置视差的相机视角区域。关键是通常有一个特殊的平面（这个案例中为Z = 0），即视差层会和正交透视有同样的移动速度。这点很重要，因为稍后可以移动和缩放相机并且它会表现的很自然。在Mimpi Dreams开发初期，我们没有意识到那些并在视差设置中出现一些错误。我们不可以稍后更改它，因为它会复位所有的视差层。最后，由于我们没有过多的使用缩放，所以并没有产生多大影响。在下一个工程中，我们肯定会用这个设置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里有一段可以设置缩放的代码。"}]},{"type":"element","tag":"pre","props":{"code":"public float GetFieldOfView(float orthoSize, float distanceFromOrigin)\n{\n    // orthoSize\n    float a = orthoSize;\n    // distanceFromOrigin\n    float b = Mathf.Abs(distanceFromOrigin);\n \n    float fieldOfView = Mathf.Atan(a / b)  * Mathf.Rad2Deg * 2f;\n    return fieldOfView;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public float GetFieldOfView(float orthoSize, float distanceFromOrigin)\n{\n    // orthoSize\n    float a = orthoSize;\n    // distanceFromOrigin\n    float b = Mathf.Abs(distanceFromOrigin);\n \n    float fieldOfView = Mathf.Atan(a / b)  * Mathf.Rad2Deg * 2f;\n    return fieldOfView;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果想在Z轴移动相机，则需要更新视差相机的裁剪平面。"}]},{"type":"element","tag":"pre","props":{"code":"// distanceFromOrigin\nfloat b = Mathf.Abs(mainCamera.transform.position.z);\n \n//change clipping planes based on main camera z-position\nfarCamera.nearClipPlane = b;\nfarCamera.farClipPlane = mainCamera.farClipPlane;\nnearCamera.farClipPlane = b;\nnearCamera.nearClipPlane = mainCamera.nearClipPlane;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// distanceFromOrigin\nfloat b = Mathf.Abs(mainCamera.transform.position.z);\n \n//change clipping planes based on main camera z-position\nfarCamera.nearClipPlane = b;\nfarCamera.farClipPlane = mainCamera.farClipPlane;\nnearCamera.farClipPlane = b;\nnearCamera.nearClipPlane = mainCamera.nearClipPlane;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何变焦相机有两个选择。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以在Z轴移动主相机（并重新计算裁剪平面），或者可以改变主相机的正交尺寸（并重新计算视差相机的视角区域）。两个选择给出不同的效果，改变正交尺寸是更自然的选择。或者，可以结合这两种技术，看下边的视频。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"unity 实例"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Jaroslav准备并给出了你们可以尝试并学习的unity工程。感谢unity提供精选案例的免费资源！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以从Github下载案例工程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"工程是用Unity 5.3.3f1制作的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还要看一下展示案例的视频。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.youtube.com/watch?v=ptdweDDyB8o&feature=youtu.be","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-13-Parallax-2d/0%5B1%5D.jpg"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"编辑工作流程"}]},{"type":"text","value":"\n在视差层设置对象最好的方法是在编辑模式下去播放游戏。可以移动角色（和相机）让玩家看到它并调整对象至实际视口。唯一的问题是播放模式下在unity中做出的更改不会保存。然而可以在播放模式下拷贝编辑过的对象并粘贴到编辑器中然后保存。我们创建一个有子集的“content”。这个content是在播放模式下编辑和复制过的。退出播放模式后，这个原始的content会被删除，新的content从剪切板粘贴过来，然后预制件就可以使用了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/181709gdpgid33t93vjfyf.png.thumb.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有，不要忘记将新的对象放到视差层中。还可以编写或者使用一些编辑器工具来帮助你保存和自动完成对象层级设置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上边的案例实在编辑模式下执行的，所以可以在编辑器中用它来设置。不过我们在MimpiDreams中使用了这个工作流程，因为这对于美术设计在场景中移动很容易，并且他可以自己调整层级。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Summary"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"总结"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-13-Parallax-2d/181711j5s29z585k932ot6.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Some advantages of this solution"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"这种解决方案的优势："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本地基本设置（脚本仅仅为了变焦）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"案例中更好的表现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"静态批处理，因为层级不会移动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简单的编辑工作流程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Disadvantages"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"劣势:"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会产生更多的draw calls"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们介绍了和Mimpi Dreams中制作视差效果不同的制作方法。你可能需要自定义一些东西。例如，我们显示所有摄像机的渲染纹理，不过在这边文章中，我想介绍最简单的设置。"}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\n\n[ExecuteInEditMode]\npublic class CameraParallax : MonoBehaviour {\n\n  public Camera mainCamera;\n  public Camera farCamera;\n  public Camera nearCamera;\n\n  void OnEnable()\n  {\n      InitCameras();\n  }\n\n  void LateUpdate()\n  {\n      UpdateCameras();\n  }\n\n  public void InitCameras()\n  {\n      if(farCamera != null)\n      {\n          farCamera.transform.localPosition = Vector3.zero;\n          farCamera.transform.rotation = Quaternion.identity;\n          farCamera.transform.localScale = Vector3.one;\n          farCamera.orthographic = false;\n          farCamera.clearFlags = CameraClearFlags.SolidColor;\n          farCamera.depth = -2;\n          farCamera.transparencySortMode = TransparencySortMode.Orthographic;\n      }\n\n      if(mainCamera != null)\n      {\n          mainCamera.orthographic = true;\n          mainCamera.clearFlags = CameraClearFlags.Nothing;\n          mainCamera.depth = -1;\n      }\n\n      if(nearCamera != null)\n      {\n          nearCamera.transform.localPosition = Vector3.zero;\n          nearCamera.transform.rotation = Quaternion.identity;\n          nearCamera.transform.localScale = Vector3.one;\n          nearCamera.orthographic = false;\n          nearCamera.clearFlags = CameraClearFlags.Depth;\n          nearCamera.depth = 0;\n          nearCamera.transparencySortMode = TransparencySortMode.Orthographic;\n      }\n  }\n\n  public void UpdateCameras()\n  {\n      if(mainCamera == null || farCamera == null || nearCamera == null) return;\n\n      // orthoSize\n      float a = mainCamera.orthographicSize;\n      // distanceFromOrigin\n      float b = Mathf.Abs(mainCamera.transform.position.z);\n\n      //change clipping planes based on main camera z-position\n      farCamera.nearClipPlane = b;\n      farCamera.farClipPlane = mainCamera.farClipPlane;\n      nearCamera.farClipPlane = b;\n      nearCamera.nearClipPlane = mainCamera.nearClipPlane;\n\n      //update field fo view for parallax cameras\n      float fieldOfView = Mathf.Atan(a / b)  * Mathf.Rad2Deg * 2f;\n      nearCamera.fieldOfView = farCamera.fieldOfView = fieldOfView;\n  }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\n\n[ExecuteInEditMode]\npublic class CameraParallax : MonoBehaviour {\n\n  public Camera mainCamera;\n  public Camera farCamera;\n  public Camera nearCamera;\n\n  void OnEnable()\n  {\n      InitCameras();\n  }\n\n  void LateUpdate()\n  {\n      UpdateCameras();\n  }\n\n  public void InitCameras()\n  {\n      if(farCamera != null)\n      {\n          farCamera.transform.localPosition = Vector3.zero;\n          farCamera.transform.rotation = Quaternion.identity;\n          farCamera.transform.localScale = Vector3.one;\n          farCamera.orthographic = false;\n          farCamera.clearFlags = CameraClearFlags.SolidColor;\n          farCamera.depth = -2;\n          farCamera.transparencySortMode = TransparencySortMode.Orthographic;\n      }\n\n      if(mainCamera != null)\n      {\n          mainCamera.orthographic = true;\n          mainCamera.clearFlags = CameraClearFlags.Nothing;\n          mainCamera.depth = -1;\n      }\n\n      if(nearCamera != null)\n      {\n          nearCamera.transform.localPosition = Vector3.zero;\n          nearCamera.transform.rotation = Quaternion.identity;\n          nearCamera.transform.localScale = Vector3.one;\n          nearCamera.orthographic = false;\n          nearCamera.clearFlags = CameraClearFlags.Depth;\n          nearCamera.depth = 0;\n          nearCamera.transparencySortMode = TransparencySortMode.Orthographic;\n      }\n  }\n\n  public void UpdateCameras()\n  {\n      if(mainCamera == null || farCamera == null || nearCamera == null) return;\n\n      // orthoSize\n      float a = mainCamera.orthographicSize;\n      // distanceFromOrigin\n      float b = Mathf.Abs(mainCamera.transform.position.z);\n\n      //change clipping planes based on main camera z-position\n      farCamera.nearClipPlane = b;\n      farCamera.farClipPlane = mainCamera.farClipPlane;\n      nearCamera.farClipPlane = b;\n      nearCamera.nearClipPlane = mainCamera.nearClipPlane;\n\n      //update field fo view for parallax cameras\n      float fieldOfView = Mathf.Atan(a / b)  * Mathf.Rad2Deg * 2f;\n      nearCamera.fieldOfView = farCamera.fieldOfView = fieldOfView;\n  }\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原文链接："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gamasutra.com/blogs/MichalBerlinger/20160323/268657/Combining_Perspective_and_Orthographic_Camera_for_Parallax_Effect_in_2D_Game.php","rel":["nofollow"]},"children":[{"type":"text","value":"http://www.gamasutra.com/blogs/MichalBerlinger/20160323/268657/Combining_Perspective_and_Orthographic_Camera_for_Parallax_Effect_in_2D_Game.php"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/MichalBerlinger/ParallaxDemo","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/MichalBerlinger/ParallaxDemo"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"unity混合模式1","depth":3,"text":"Unity混合模式1"},{"id":"unity混合模式2","depth":3,"text":"Unity混合模式2"},{"id":"结合透视和正交相机在unity2d游戏中制作视差效果","depth":2,"text":"结合透视和正交相机在Unity2D游戏中制作视差效果"}]}},"_type":"markdown","_id":"content:unity:2019-09-13-Parallax-2d.md","_source":"content","_file":"unity/2019-09-13-Parallax-2d.md","_extension":"md","date":"2019-09-13"},{"_path":"/unity/2019-11-15-unity-proxy","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity使用代理","description":"Unity的AssetStore下载package的时候经常抽风，而且开了代理工具的全局代理依然无效。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity的AssetStore下载package的时候经常抽风，而且开了代理工具的全局代理依然无效。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"检索网络后得知，这是因为它下载的时候不检测IE代理设置，而是取环境变量中HTTPS_proxy和HTTP_proxy的值，所以添加这两个变量并指定其为你的代理服务地址就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体步骤："}]},{"type":"element","tag":"pre","props":{"code":"打开 系统属性->高级->环境变量\n新建 HTTPS_PROXY 和 HTTP_PROXY 系统变量，设置其为你的代理服务地址\n\n例如公司的代理IP是：127.0.0.1 端口：1080 \n变量名：HTTPS_PROXY\n变量值：http://127.0.0.1:1080    这里也是http..因为ss没开https\n\n变量名：HTTP_PROXY\n变量值：http://127.0.0.1:1080\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"打开 系统属性->高级->环境变量\n新建 HTTPS_PROXY 和 HTTP_PROXY 系统变量，设置其为你的代理服务地址\n\n例如公司的代理IP是：127.0.0.1 端口：1080 \n变量名：HTTPS_PROXY\n变量值：http://127.0.0.1:1080    这里也是http..因为ss没开https\n\n变量名：HTTP_PROXY\n变量值：http://127.0.0.1:1080\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-11-15-unity-proxy/20190515220955161%5B1%5D.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要注意的是设置完成后可能需要重启Unity才会生效。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2019-11-15-unity-proxy.md","_source":"content","_file":"unity/2019-11-15-unity-proxy.md","_extension":"md","date":"2019-11-15"},{"_path":"/unity/2020-01-01-unity-entitas","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"一篇文章搞定Entitas","description":"Entitas執行流程​      也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。\n​      在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。\n  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"entitas執行流程"},"children":[{"type":"text","value":"Entitas執行流程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-01-01-unity-entitas/1362861-20190531225036556-1995562595%5B1%5D.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​      也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。\n​      在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。\n  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），只有第一次会遍历所有的Entity生成这个Group，之后再获取该类型Entity的复杂度就只有O(1)。\n  但是也有一定的隐患，当Group和Collector比较少时，这不是一个高消耗操作，但是Group、Collector很多，且在每一帧对Entity进行频繁修改的时候。这可能会成为一个高消耗操作。"}]},{"type":"element","tag":"h1","props":{"id":"tips"},"children":[{"type":"text","value":"Tips"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1. 在销毁一个Entity时，会移除Entity身上所有的Component，然后再进行回收。在移除Component时可能会通过Group把这个移除事件发送到监听Remove行为的Collector中，Collector会持有这个被销毁的Entity。所以在filter、或execute时不能直接依赖Collector的收集条件，还需要对Entity的Component做独立的判断。\n  其实任何时候filter都需要对Entity的Component做判断，因为Collector收集的Entity很可能在其他地方被改变。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2. Entity不应该被ECS系统外的模块持有，因为系统外对Entity的持有不会被自动引用计数（可以自己添加）。可能会导致一个Entity被销毁然后又从池子中重新取出来， 外部模块对这个Entity的引用没有改变，但已经可能不是自己持有的那个Entity了。\n  需要避免在外界持有Entity或通过持有uuid间接从context中持有这个Entity。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3. 在replaceComponent时，发送了Remove、Add、Update三个事件，而不是只发送了Update事件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4. 在代码生成时，对单Componet的Matcher进行了缓存，如游戏中常用的Postion和Name等Component，但是对组合Component的Matcher没有进行缓存。所在在两个不同的ReactiveSystem中使用Matcher相同的Collector时，如："}]},{"type":"element","tag":"pre","props":{"code":"//1,2代表Postion和Name的Index\n//在使用代码生成时会生成类似Matcher.Position、Matcher.Name的静态函数，方便开发者使用\ncontext.CreateCollector(Matcher.AllOf(1,2));\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//1,2代表Postion和Name的Index\n//在使用代码生成时会生成类似Matcher.Position、Matcher.Name的静态函数，方便开发者使用\ncontext.CreateCollector(Matcher.AllOf(1,2));\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样会生成两个Matcher相同的Group实例。\n如果在意这一点的话可以自己对Matcher进行缓存。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"不可修改"}]},{"type":"text","value":"（immutable）component的感觉。"}]}]},{"type":"element","tag":"h1","props":{"id":"group"},"children":[{"type":"text","value":"Group"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Context中可以对Entity进行快速过滤，它能不断的更新以保持当前的组中的Entity是最新的。假设Context有上千个Entities，但只有两个Entities拥有PositionComponent，那只要向Context询问特定的组就能立刻获取到所有符合的Entity。"}]},{"type":"element","tag":"pre","props":{"code":"gameContext.GetGroup(GameMatcher.Position).GetEntities();\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"gameContext.GetGroup(GameMatcher.Position).GetEntities();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Group和Group所过滤到的entities会被缓存下来，所以即使多次调用GetGroup方法，也是非常高效的。"}]},{"type":"element","tag":"pre","props":{"code":"gameContext.GetEntities(GameMatcher.Movable)\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"gameContext.GetEntities(GameMatcher.Movable)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内部也是通过Groups的方式来实现。Groups 拥有以下事件OnEntityAdded, OnEntityRemoved 和 OnEntityUpdated来直接响应Entity的变化。"}]},{"type":"element","tag":"h1","props":{"id":"collector"},"children":[{"type":"text","value":"Collector"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Collector是Group的一个观察者类,Collector提供了一种简单的方法来处理Group中Entity变化的反应。假设你需要收集和处理所有entities，他们的PositionComponent被添加或替换："}]},{"type":"element","tag":"pre","props":{"code":"var group = gameContext.GetGroup(GameMatcher.Position);\nvar collector = group.CreateCollector(GroupEvent.Added);\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var group = gameContext.GetGroup(GameMatcher.Position);\nvar collector = group.CreateCollector(GroupEvent.Added);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之后："}]},{"type":"element","tag":"pre","props":{"code":"foreach (var e in collector.collectedEntities) {\n    // do something with all the entities\n    // that have been collected to this point of time\n}\ncollector.ClearCollectedEntities();\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"foreach (var e in collector.collectedEntities) {\n    // do something with all the entities\n    // that have been collected to this point of time\n}\ncollector.ClearCollectedEntities();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们还可以注销这个Collector"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"collector.Deactivate();"}]},{"type":"element","tag":"h1","props":{"id":"reactivesystem"},"children":[{"type":"text","value":"ReactiveSystem"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"响应式的系统就像执行式系统一样，会每隔一段时间或是在每一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Update"}]},{"type":"text","value":"中被触发"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"响应式系统的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Execute(List entities)"}]},{"type":"text","value":" 方法只会在收集器距离上一次"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Execute"}]},{"type":"text","value":"收集到新的Entity才会被执行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"gettrigger使用Collector根据event建立一个group的entity列表"}]}]},{"type":"element","tag":"pre","props":{"code":"        protected override ICollector<GameEntity> GetTrigger(IContext<GameEntity> context) {\n            return context.CreateCollector(GameMatcher.Destroyed);\n        }\n\n        protected override bool Filter(GameEntity entity) {\n            return entity.isDestroyed;\n        }\n       \n        public void Execute() {\n            if (_collector.count != 0) {\n                foreach (var e in _collector.collectedEntities) {\n                    if (Filter(e)) {\n                        e.Retain(this);\n                        _buffer.Add(e);\n                    }\n                }\n\n                _collector.ClearCollectedEntities();\n\n                if (_buffer.Count != 0) {\n                    try {\n                        Execute(_buffer);\n                    } finally {\n                        for (int i = 0; i < _buffer.Count; i++) {\n                            _buffer[i].Release(this);\n                        }\n                        _buffer.Clear();\n                    }\n                }\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected override ICollector<GameEntity> GetTrigger(IContext<GameEntity> context) {\n            return context.CreateCollector(GameMatcher.Destroyed);\n        }\n\n        protected override bool Filter(GameEntity entity) {\n            return entity.isDestroyed;\n        }\n       \n        public void Execute() {\n            if (_collector.count != 0) {\n                foreach (var e in _collector.collectedEntities) {\n                    if (Filter(e)) {\n                        e.Retain(this);\n                        _buffer.Add(e);\n                    }\n                }\n\n                _collector.ClearCollectedEntities();\n\n                if (_buffer.Count != 0) {\n                    try {\n                        Execute(_buffer);\n                    } finally {\n                        for (int i = 0; i < _buffer.Count; i++) {\n                            _buffer[i].Release(this);\n                        }\n                        _buffer.Clear();\n                    }\n                }\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如上代码:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetTrigger"}]},{"type":"text","value":"方法中返回了一个监测了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Destroyed"}]},{"type":"text","value":"Entity的Collector。在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"context.CreateCollector(GameMatcher.Destroyed)"}]},{"type":"text","value":" 中，我们不需要指定当一个Entity何时应当被收集的事件，因为默认就是会收集在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Added"}]},{"type":"text","value":"情况下被通知到的Entity。所以当我们增加一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Destroyed"}]},{"type":"text","value":"组件到一个Entity上时，这个Entity会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"添加"}]},{"type":"text","value":"到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Destroyed"}]},{"type":"text","value":"的group里面，并因此被对应的collector收集到对应的reactive system里面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下面的代码,AddDebugMessage就会被DebugMessageSystem收集了..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行RemoveDebugMessage()但是DebugMessageSystem仍然收集着呢,但是该实体已经没有了组件DebugMessage.所以需要过滤下Filter(GameEntity entity)否则收集的数据会报错"}]},{"type":"element","tag":"pre","props":{"code":"using Entitas;\n\npublic class HelloWorldSystem : IInitializeSystem\n{\n    // always handy to keep a reference to the context \n    // we're going to be interacting with it\n    readonly GameContext _context;\n\n    public HelloWorldSystem(Contexts contexts)\n    {\n        // get the context from the constructor\n        _context = contexts.game;\n    }\n\n    public void Initialize()\n    {\n        // create an entity and give it a DebugMessageComponent with\n        // the text \"Hello World!\" as its data\n\n        var e = _context.CreateEntity();\n        e.AddDebugMessage(\"Hello World!\");\n        e.RemoveDebugMessage(); \n    }\n}\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Entitas;\n\npublic class HelloWorldSystem : IInitializeSystem\n{\n    // always handy to keep a reference to the context \n    // we're going to be interacting with it\n    readonly GameContext _context;\n\n    public HelloWorldSystem(Contexts contexts)\n    {\n        // get the context from the constructor\n        _context = contexts.game;\n    }\n\n    public void Initialize()\n    {\n        // create an entity and give it a DebugMessageComponent with\n        // the text \"Hello World!\" as its data\n\n        var e = _context.CreateEntity();\n        e.AddDebugMessage(\"Hello World!\");\n        e.RemoveDebugMessage(); \n    }\n}\n\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using System.Collections.Generic;\nusing Entitas;\nusing UnityEngine;\n\npublic class DebugMessageSystem : ReactiveSystem<GameEntity>\n{\n    public DebugMessageSystem(Contexts contexts) : base(contexts.game)\n    {\n    }\n\n    protected override ICollector<GameEntity> GetTrigger(IContext<GameEntity> context)\n    {\n        // we only care about entities with DebugMessageComponent \n        return context.CreateCollector(GameMatcher.DebugMessage);\n    }\n\n    protected override bool Filter(GameEntity entity)\n    {\n        // good practice to perform a final check in case \n        // the entity has been altered in a different system.\n        return entity.hasDebugMessage;\n    }\n\n    protected override void Execute(List<GameEntity> entities)\n    {\n        // this is the list of entities that meet our conditions\n        foreach (var e in entities)\n        {\n            // we can safely access their DebugMessage component\n            // then grab the string data and print it\n            Debug.Log(e.debugMessage.message);\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections.Generic;\nusing Entitas;\nusing UnityEngine;\n\npublic class DebugMessageSystem : ReactiveSystem<GameEntity>\n{\n    public DebugMessageSystem(Contexts contexts) : base(contexts.game)\n    {\n    }\n\n    protected override ICollector<GameEntity> GetTrigger(IContext<GameEntity> context)\n    {\n        // we only care about entities with DebugMessageComponent \n        return context.CreateCollector(GameMatcher.DebugMessage);\n    }\n\n    protected override bool Filter(GameEntity entity)\n    {\n        // good practice to perform a final check in case \n        // the entity has been altered in a different system.\n        return entity.hasDebugMessage;\n    }\n\n    protected override void Execute(List<GameEntity> entities)\n    {\n        // this is the list of entities that meet our conditions\n        foreach (var e in entities)\n        {\n            // we can safely access their DebugMessage component\n            // then grab the string data and print it\n            Debug.Log(e.debugMessage.message);\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"事件"},"children":[{"type":"text","value":"事件"}]},{"type":"element","tag":"h3","props":{"id":"关于replace都干了什么"},"children":[{"type":"text","value":"关于replace都干了什么"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Group具有事件 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnEntityAdded"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnEntityRemoved"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnEntityUpdated"}]},{"type":"text","value":" 可以直接对组的更改做出反应。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看源码"}]},{"type":"element","tag":"pre","props":{"code":" public void UpdateEntity(TEntity entity, int index, IComponent previousComponent, IComponent newComponent) {\n            if (_entities.Contains(entity)) {\n                if (OnEntityRemoved != null) {\n                    OnEntityRemoved(this, entity, index, previousComponent);\n                }\n                if (OnEntityAdded != null) {\n                    OnEntityAdded(this, entity, index, newComponent);\n                }\n                if (OnEntityUpdated != null) {\n                    OnEntityUpdated(\n                        this, entity, index, previousComponent, newComponent\n                    );\n                }\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public void UpdateEntity(TEntity entity, int index, IComponent previousComponent, IComponent newComponent) {\n            if (_entities.Contains(entity)) {\n                if (OnEntityRemoved != null) {\n                    OnEntityRemoved(this, entity, index, previousComponent);\n                }\n                if (OnEntityAdded != null) {\n                    OnEntityAdded(this, entity, index, newComponent);\n                }\n                if (OnEntityUpdated != null) {\n                    OnEntityUpdated(\n                        this, entity, index, previousComponent, newComponent\n                    );\n                }\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"不可修改"}]},{"type":"text","value":"（immutable）component的感觉。"}]},{"type":"element","tag":"h3","props":{"id":"group和collect还有event应该在什么地方添加"},"children":[{"type":"text","value":"group和collect,还有event应该在什么地方添加."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在系统中的构造函数中"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在entitan的system初始化Initialize前"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为初始化系统大多会有add,remove等动作.为了保持你的group,还有collect,还有event能够监听到."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以最好在Initialize前"}]},{"type":"element","tag":"h1","props":{"id":"jenny"},"children":[{"type":"text","value":"Jenny"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"jenny使用了roslyn, DataProviders需要更改下,否则会报错.."}]},{"type":"element","tag":"pre","props":{"code":"Jenny.SearchPaths = Assets\\Plugins\\DesperateDevs\\Editor\\Plugins, \\\n                    Assets\\Plugins\\Entitas\\Editor\\Plugins, \\\n                    Jenny\\Plugins\\Entitas.Roslyn\n\nJenny.Plugins = DesperateDevs.CodeGeneration.Plugins, \\\n                DesperateDevs.CodeGeneration.Unity.Plugins, \\\n                Entitas.CodeGeneration.Plugins, \\\n                Entitas.Roslyn.CodeGeneration.Plugins, \\\n                Entitas.VisualDebugging.CodeGeneration.Plugins\n\nJenny.PreProcessors = DesperateDevs.CodeGeneration.Plugins.ValidateProjectPathPreProcessor, \\\n                      DesperateDevs.CodeGeneration.Plugins.TargetFrameworkProfilePreProcessor\n\nJenny.DataProviders = Entitas.CodeGeneration.Plugins.ContextDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.CleanupDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.ComponentDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.EntityIndexDataProvider\n\nJenny.CodeGenerators = Entitas.CodeGeneration.Plugins.ComponentContextApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentEntityApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentEntityApiInterfaceGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentLookupGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentMatcherApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextAttributeGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextMatcherGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextsGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EntityGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EntityIndexGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventEntityApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventListenerComponentGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventListenertInterfaceGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventSystemGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventSystemsGenerator, \\\n                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemGenerator, \\\n                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemsGenerator, \\\n                       Entitas.VisualDebugging.CodeGeneration.Plugins.ContextObserverGenerator, \\\n                       Entitas.VisualDebugging.CodeGeneration.Plugins.FeatureClassGenerator\n\nJenny.PostProcessors = DesperateDevs.CodeGeneration.Plugins.AddFileHeaderPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.CleanTargetDirectoryPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.MergeFilesPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.NewLinePostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.UpdateCSProjPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.WriteToDiskPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.ConsoleWriteLinePostProcessor\n\nJenny.Server.Port = 3333\nJenny.Client.Host = localhost\nDesperateDevs.CodeGeneration.Plugins.ProjectPath = Assembly-CSharp.csproj\nEntitas.CodeGeneration.Plugins.Assemblies = Library/ScriptAssemblies/Assembly-CSharp.dll\nEntitas.CodeGeneration.Plugins.Contexts = Game, \\\n                                          Unit, \\\n                                          Combat, \\\n                                          Config, \\\n                                          Input\n\nEntitas.CodeGeneration.Plugins.IgnoreNamespaces = true\nDesperateDevs.CodeGeneration.Plugins.TargetDirectory = Assets/Scripts/World\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Jenny.SearchPaths = Assets\\Plugins\\DesperateDevs\\Editor\\Plugins, \\\n                    Assets\\Plugins\\Entitas\\Editor\\Plugins, \\\n                    Jenny\\Plugins\\Entitas.Roslyn\n\nJenny.Plugins = DesperateDevs.CodeGeneration.Plugins, \\\n                DesperateDevs.CodeGeneration.Unity.Plugins, \\\n                Entitas.CodeGeneration.Plugins, \\\n                Entitas.Roslyn.CodeGeneration.Plugins, \\\n                Entitas.VisualDebugging.CodeGeneration.Plugins\n\nJenny.PreProcessors = DesperateDevs.CodeGeneration.Plugins.ValidateProjectPathPreProcessor, \\\n                      DesperateDevs.CodeGeneration.Plugins.TargetFrameworkProfilePreProcessor\n\nJenny.DataProviders = Entitas.CodeGeneration.Plugins.ContextDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.CleanupDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.ComponentDataProvider, \\\n                      Entitas.Roslyn.CodeGeneration.Plugins.EntityIndexDataProvider\n\nJenny.CodeGenerators = Entitas.CodeGeneration.Plugins.ComponentContextApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentEntityApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentEntityApiInterfaceGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentLookupGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ComponentMatcherApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextAttributeGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextMatcherGenerator, \\\n                       Entitas.CodeGeneration.Plugins.ContextsGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EntityGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EntityIndexGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventEntityApiGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventListenerComponentGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventListenertInterfaceGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventSystemGenerator, \\\n                       Entitas.CodeGeneration.Plugins.EventSystemsGenerator, \\\n                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemGenerator, \\\n                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemsGenerator, \\\n                       Entitas.VisualDebugging.CodeGeneration.Plugins.ContextObserverGenerator, \\\n                       Entitas.VisualDebugging.CodeGeneration.Plugins.FeatureClassGenerator\n\nJenny.PostProcessors = DesperateDevs.CodeGeneration.Plugins.AddFileHeaderPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.CleanTargetDirectoryPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.MergeFilesPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.NewLinePostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.UpdateCSProjPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.WriteToDiskPostProcessor, \\\n                       DesperateDevs.CodeGeneration.Plugins.ConsoleWriteLinePostProcessor\n\nJenny.Server.Port = 3333\nJenny.Client.Host = localhost\nDesperateDevs.CodeGeneration.Plugins.ProjectPath = Assembly-CSharp.csproj\nEntitas.CodeGeneration.Plugins.Assemblies = Library/ScriptAssemblies/Assembly-CSharp.dll\nEntitas.CodeGeneration.Plugins.Contexts = Game, \\\n                                          Unit, \\\n                                          Combat, \\\n                                          Config, \\\n                                          Input\n\nEntitas.CodeGeneration.Plugins.IgnoreNamespaces = true\nDesperateDevs.CodeGeneration.Plugins.TargetDirectory = Assets/Scripts/World\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般来说.先运行Jenny-Auto-Import.bat.再运行Jenny-Server.bat就可以了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查看所有命令:"}]},{"type":"element","tag":"pre","props":{"code":".\\Jenny\\Jenny.exe help \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":".\\Jenny\\Jenny.exe help \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以VStudio为例，创建一个外部工具："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-01-unity-entitas/v2-d49876b0ae0100844a372dfb16508b27_hd.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再之后，想要生成代码只需要保持运行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Jenny Server"}]},{"type":"text","value":" 然后在VS中运行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"工具/Jenny"}]},{"type":"text","value":" 就可以了，这个方法可以让你专注于VS而无需切换回Unity。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"jenny.exe client gen"}]},{"type":"text","value":"需要服务器才能使用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"jenny gen"}]},{"type":"text","value":" 不开服务器直接可以使用"}]},{"type":"element","tag":"h2","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/c/e8e4c3f4280c","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.jianshu.com/c/e8e4c3f4280c"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/OneYoungMean/Entitas-CSharp-OYM/wiki","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/OneYoungMean/Entitas-CSharp-OYM/wiki"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/sschmid/Entitas-CSharp","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/sschmid/Entitas-CSharp"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"关于replace都干了什么","depth":3,"text":"关于replace都干了什么"},{"id":"group和collect还有event应该在什么地方添加","depth":3,"text":"group和collect,还有event应该在什么地方添加."},{"id":"相关链接","depth":2,"text":"相关链接"}]}},"_type":"markdown","_id":"content:unity:2020-01-01-unity-entitas.md","_source":"content","_file":"unity/2020-01-01-unity-entitas.md","_extension":"md","date":"2020-01-01"},{"_path":"/unity/2020-01-11-unity-attack-range-detection-type","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity攻击范围检测的方式区别","description":"1.利用碰撞器的触发器Trigger这种是比较基础的做法，利用OnTriggerEntry函数，当目标进入触发器时触发。例如玩家有一把剑，我要做攻击判定的话，我就可以在剑上挂一个触发器，设定好大小，当播放动画时，随着剑的挥动，目标会进入Trigger的范围，此时就会调用OnTriggerEntry函数。但是这样做有个弊端，如果挥舞速度太快，检测会有问题；还有就是必须满足“进入”这个条件，也就是说如果原来目标就在触发器范围内，或者触发器在目标内，是不会触发函数的。所以这种方法不太适用于3D游戏。不过这种方法也不是不能用，只是适用条件有限，在2D游戏上，结合上Animation的录制功能，通过动画","body":{"type":"root","children":[{"type":"element","tag":"h4","props":{"id":"_1利用碰撞器的触发器trigger"},"children":[{"type":"text","value":"1.利用碰撞器的触发器Trigger"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种是比较基础的做法，利用OnTriggerEntry函数，当目标进入触发器时触发。例如玩家有一把剑，我要做攻击判定的话，我就可以在剑上挂一个触发器，设定好大小，当播放动画时，随着剑的挥动，目标会进入Trigger的范围，此时就会调用OnTriggerEntry函数。但是这样做有个弊端，如果挥舞速度太快，检测会有问题；还有就是必须满足“进入”这个条件，也就是说如果原来目标就在触发器范围内，或者触发器在目标内，是不会触发函数的。所以这种方法不太适用于3D游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过这种方法也不是不能用，只是适用条件有限，在2D游戏上，结合上Animation的录制功能，通过动画来改变Trigger的大小，这样就可以触发OnTriggerEntry函数一次或者多次，这样也是可以做出不错效果的。在3D游戏中，可以在人物前面放置一个大小合适Trigger当做攻击范围，再结合动画事件进行攻击判定，不过这样做的缺点是攻击范围大小恒定，如果人物的攻击范围大小不一，就要创建很多空子物体来设定Trigger范围，脚本也不好管理。"}]},{"type":"element","tag":"h4","props":{"id":"_2利用数学判断"},"children":[{"type":"text","value":"2.利用数学判断"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以定义两个向量作为攻击范围，向量有方向也有长度，攻击范围是可以确定的。例如设定两个向量，向量1为Transform.forward的左偏45度，向量2为Transform.forward的右偏45度，长度均为5。此时攻击范围为半径为5，度数为90°的扇形。此时就可以计算敌人是不是在攻击范围内，可以通过Vector3.Angle来计算（角度制），Vector3.Distance来计算距离。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方法的局限在于1.如何获取到敌人的游戏物体，可以通过触发器也可以遍历你的敌人列表。2.当敌人体积过大时，有可能身体的一部分已经进入攻击范围，但是postion没有进入攻击范围，此时判定就会出现错误。看情况使用。"}]},{"type":"element","tag":"h4","props":{"id":"_3利用射线raycast"},"children":[{"type":"text","value":"3.利用射线Raycast"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用Physics.Raycast()这个方法来发射射线，当射线碰到物体，或者碰到指定Laymask层的物体，或者一定距离后就会返回，返回值是Bool类型。通过out关键字来输出碰撞到的物体的信息，变量类型为RaycastHit。例如我定义一个射线Ray ray =new Ray(), 一个射线返回RaycastHit hit，那么就应该这么使用Physics.Raycast(ray,out hit),表示碰到物体，就会返回ture，物体信息储存在hit中。没有碰到，就会范围false，hit为null。这个方法还有很多重载，可以自己查阅API，根据情况使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方法是射击游戏的常用判断方法，可以结合lineRender来渲染子弹飞过的特效。不过这种方法也不是万能的，它的局限在于射出射线的点只有一个，用来做射击游戏的攻击判定是非常合适的，但是不能用来做判定比较严格的游戏。为什么呢，因为射击游戏的发射方向是可以根据准星调整的，视觉上的判定也是准星方向，如果是动作游戏，rpg游戏之类的，攻击类型多样，就会出现差错。例如一个从上至下的斩击，攻击范围应该是竖着的一条线，那么射线应该怎发射呢？如果直直的往前发射，那么当敌人蹲下的时候，就会检测不到。你或许会想做成动作模式不就完了吗？（就是类似于龙之谷的操作方式），也是不行的，判定始终在攻击轨迹中央，和攻击动画和攻击特效有出入。"}]},{"type":"element","tag":"h4","props":{"id":"_4利用射线linecast"},"children":[{"type":"text","value":"4.利用射线Linecast"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这也是Physics的一个方法， Physics.Linecast（）。连接两个点形成线段，如果线段中间有物体，就返回true,否则返回flase，同样，这个方法需要定义一个RaycastHit类型的变量来接收返回数据，具体方法为Physics.Linecast（Vector3 point1, Vector3 point2，out hit）。这种方法需要在武器或者拳头或者其他的需要攻击判定的地方设定一个点，当动画播放时，这个点的世界坐标就会变化，此时我们可以选择记录某几个时间点上判定点的世界坐标，再用Linecast进行判定。一般取判定点的坐标的话我们同样可以利用动画事件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种方法调试的时候最好用lineRender把攻击轨迹渲染出来，或者用Debug.DrawLine()画出来（记得设定存在时间，不然一瞬间就消失了看不到），这样可以方便调整我们取判定点的时间节点，不然可能会疑惑，明明我设定好了，怎么检测不到。这种方法适合于动作游戏，以及一些判定比较精细的游戏。需要注意的一点是，Linecast每一帧都会进行判定，一般我们只需要一个动作判定一次，那么还需要在代码里进行约束。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-01-11-unity-attack-range-detection-type.md","_source":"content","_file":"unity/2020-01-11-unity-attack-range-detection-type.md","_extension":"md","date":"2020-01-11"},{"_path":"/unity/2020-01-12-collision-detection","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"常见的2D碰撞检测","description":"“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，不废话。直入主题——碰撞检测。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 2D 环境下，常见的碰撞检测方法如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"外接图形判别法"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"轴对称包围盒（Axis-Aligned Bounding Box），即无旋转矩形。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"圆形碰撞"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"圆形与矩形（无旋转）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"圆形与旋转矩形（以矩形中心点为旋转轴）"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"光线投射法"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其他"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地图格子划分"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"像素检测"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下文将由易到难的顺序介绍上述各种碰撞检测方法：外接图形判别法 > 其他 > 光线投射法 > 分离轴定理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，有一些场景只要我们约定好限定条件，也能实现我们想要的碰撞，如下面的碰壁反弹："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当球碰到边框就反弹(如"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x/y轴方向速度取反"}]},{"type":"text","value":")。"}]},{"type":"element","tag":"pre","props":{"code":"if(ball.left < 0 || ball.right  > rect.width)  ball.velocityX = -ball.velocityX\nif(ball.top  < 0 || ball.bottom > rect.height) ball.velocityY = -ball.velocityY\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if(ball.left < 0 || ball.right  > rect.width)  ball.velocityX = -ball.velocityX\nif(ball.top  < 0 || ball.bottom > rect.height) ball.velocityY = -ball.velocityY\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再例如当一个人走到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"100px"}]},{"type":"text","value":" 位置时不进行跳跃，就会碰到石头等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，某些场景只需通过设定到适当的参数即可实现碰撞检测。"}]},{"type":"element","tag":"h2","props":{"id":"外接图形判别法"},"children":[{"type":"text","value":"外接图形判别法"}]},{"type":"element","tag":"h3","props":{"id":"轴对称包围盒axis-aligned-bounding-box"},"children":[{"type":"text","value":"轴对称包围盒（Axis-Aligned Bounding Box）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"算法："}]},{"type":"element","tag":"pre","props":{"code":"rect1.x < rect2.x + rect2.width &&\nrect1.x + rect1.width > rect2.x &&\nrect1.y < rect2.y + rect2.height &&\nrect1.height + rect1.y > rect2.y\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"rect1.x < rect2.x + rect2.width &&\nrect1.x + rect1.width > rect2.x &&\nrect1.y < rect2.y + rect2.height &&\nrect1.height + rect1.y > rect2.y\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"两矩形间碰撞的各种情况：\n"},{"type":"element","tag":"img","props":{"alt":"轴对称包围盒","src":"/images/2020-01-12-Collision-detection/rectangle_collision.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在线运行示例（先点击运行示例以获取焦点，下同）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适用案例："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"（类）矩形物体间的碰撞。"}]}]},{"type":"element","tag":"h3","props":{"id":"圆形碰撞circle-collision"},"children":[{"type":"text","value":"圆形碰撞（Circle Collision）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"两点之间的距离由以下公式可得：\n"},{"type":"element","tag":"img","props":{"alt":"两点之间距离","src":"/images/2020-01-12-Collision-detection/two_point_distance.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"判断两圆心距离是否小于两半径之和："}]},{"type":"element","tag":"pre","props":{"code":"Math.sqrt(Math.pow(circleA.x - circleB.x, 2) +\n          Math.pow(circleA.y - circleB.y, 2)) \n    < circleA.radius + circleB.radius\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Math.sqrt(Math.pow(circleA.x - circleB.x, 2) +\n          Math.pow(circleA.y - circleB.y, 2)) \n    < circleA.radius + circleB.radius\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图例：\n"},{"type":"element","tag":"img","props":{"alt":"圆形间的碰撞检测","src":"/images/2020-01-12-Collision-detection/circle_collision.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在线运行示例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"与『轴对称包围盒』类似"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适用案例："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"（类）圆形的物体，如各种球类碰撞。"}]}]},{"type":"element","tag":"h3","props":{"id":"圆形与矩形无旋转"},"children":[{"type":"text","value":"圆形与矩形（无旋转）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那如何找出矩形上离圆心最近的点呢？下面我们从 x 轴、y 轴两个方向分别进行寻找。为了方便描述，我们先约定以下变量："}]},{"type":"element","tag":"pre","props":{"code":"矩形上离圆心最近的点为变量：closestPoint = {x, y};\n矩形 rect = {x, y, w, h}; // 左上角与宽高\n圆形 circle = {x, y, r}; // 圆心与半径\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"矩形上离圆心最近的点为变量：closestPoint = {x, y};\n矩形 rect = {x, y, w, h}; // 左上角与宽高\n圆形 circle = {x, y, r}; // 圆心与半径\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先是 x 轴："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果圆心在矩形的左侧（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"if(circle.x < rect.x)"}]},{"type":"text","value":"），那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"closestPoint.x = rect.x"}]},{"type":"text","value":"。\n"},{"type":"element","tag":"img","props":{"alt":"圆心在矩形的左侧","src":"/images/2020-01-12-Collision-detection/cicle_rectangle_left.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果圆心在矩形的右侧（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"else if(circle.x > rect.x + rect.w)"}]},{"type":"text","value":"），那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"closestPoint.x = rect.x + rect.w"}]},{"type":"text","value":"。\n"},{"type":"element","tag":"img","props":{"alt":"圆心在矩形的右侧","src":"/images/2020-01-12-Collision-detection/circle_rectangle_right.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果圆心在矩形的正上下方（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"else"}]},{"type":"text","value":"），那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"closestPoint.x = circle.x"}]},{"type":"text","value":"。\n"},{"type":"element","tag":"img","props":{"alt":"圆心在矩形的正上下方","src":"/images/2020-01-12-Collision-detection/circle_rectangle_center.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同理，对于 y 轴（此处不列举图例）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果圆心在矩形的上方（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"if(circle.y < rect.y)"}]},{"type":"text","value":"），那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"closestPoint.y = rect.y"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果圆心在矩形的下方（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"else if(circle.y > rect.y + rect.h)"}]},{"type":"text","value":"），那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"closestPoint.y = rect.y + rect.h"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果圆心在矩形的正左右两侧（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"else"}]},{"type":"text","value":"），那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"closestPoint.y = circle.y"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，通过上述方法即可找出矩形上离圆心最近的点了，然后通过『两点之间的距离公式』得出『最近点』与『圆心』的距离，最后将其与圆的半径相比，即可判断是否发生碰撞。"}]},{"type":"element","tag":"pre","props":{"code":"var distance = Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))\n\nif(distance < circle.r) return true // 发生碰撞\nelse return false // 未发生碰撞\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var distance = Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))\n\nif(distance < circle.r) return true // 发生碰撞\nelse return false // 未发生碰撞\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在线运行示例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"矩形需是轴对称的，即不能旋转。"}]}]},{"type":"element","tag":"h3","props":{"id":"圆形与旋转矩形以矩形中心为旋转轴"},"children":[{"type":"text","value":"圆形与旋转矩形（以矩形中心为旋转轴）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于旋转后的矩形，要找出其离圆心最近的点，视乎有些困难。其实，我们可以将我们思想的范围进行扩大：将矩形的旋转看作是整个画布的旋转。那么我们将画布（即 Canvas）反向旋转『矩形旋转的角度』后，所看到的结果就是上一个方法“圆形与矩形（无旋转）”的情形。因此，我们只需求出画布旋转后的圆心位置，即可使用『圆形与矩形（无旋转）』的判断方法了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"绕矩形中心旋转后的画布","src":"/images/2020-01-12-Collision-detection/circle_and_rotated_rect.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先给出可直接套用的公式，从而得出旋转后的圆心坐标："}]},{"type":"element","tag":"pre","props":{"code":"x’ = cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerX\ny’ = sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"x’ = cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerX\ny’ = sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面给出该公式的推导过程："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据下图，计算某个点绕另外一个点旋转一定角度后的坐标。我们设 A(x,y) 绕 B(a,b) 旋转 β 度后的位置为 C(c,d)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"某个点绕另外一个点旋转一定角度后的坐标的公式推导","src":"/images/2020-01-12-Collision-detection/circle_and_rotated_rect_formula.png"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"由于 |AB| 与 |CB| 相等（即长度），且"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"|AB| = y/sin(δ) = x / cos(δ)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"|CB| = d/sin(δ + β) = c / cos(δ + β)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"由以下三角函数两角和差公式："},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可得出旋转后的坐标："},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由上述公式推导后可得：旋转后的坐标 (c,d) 只与旋转前的坐标 (x,y) 及旋转的角度 β 有关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然，(c,d) 是旋转一定角度后『相对于旋转点（轴）的坐标』。因此，前面提到的『可直接套用的公式』中加上了矩形的中心点的坐标值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从图中也可以得出以下结论：A 点旋转后的 C 点总是在圆周（半径为 |AB|）上运动，利用这点可让物体绕旋转点（轴）做圆周运动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"得到旋转后的圆心坐标值后，即可使用『圆形与矩形（无旋转）』方法进行碰撞检测了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在线运行案例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"相对于圆形与矩形（未旋转）的方法，适用范围更广。"}]}]},{"type":"element","tag":"h2","props":{"id":"其他"},"children":[{"type":"text","value":"其他"}]},{"type":"element","tag":"h3","props":{"id":"地图格子划分"},"children":[{"type":"text","value":"地图格子划分"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"蓝色X"}]},{"type":"text","value":" 为障碍物：\n"},{"type":"element","tag":"img","props":{"alt":"地图格子碰撞检测","src":"/images/2020-01-12-Collision-detection/map_cell_collision.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现方法："}]},{"type":"element","tag":"pre","props":{"code":"// 通过特定标识指定（非）可行区域\nmap = [\n  [0, 0, 1, 1, 1, 0, 0, 0, 0],\n  [0, 1, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 1, 1, 1, 1, 1, 1, 0, 0]\n],\n// 设定角色的初始位置\nplayer = {left: 2, top: 2}\n\n// 移动前（后）判断角色的下一步的动作（如不能前行）\n...\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 通过特定标识指定（非）可行区域\nmap = [\n  [0, 0, 1, 1, 1, 0, 0, 0, 0],\n  [0, 1, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 1, 0, 0, 0, 0, 1, 0, 0],\n  [0, 1, 1, 1, 1, 1, 1, 0, 0]\n],\n// 设定角色的初始位置\nplayer = {left: 2, top: 2}\n\n// 移动前（后）判断角色的下一步的动作（如不能前行）\n...\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在线运行示例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"适用场景局限。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适用案例："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"推箱子、踩地雷等"}]}]},{"type":"element","tag":"h3","props":{"id":"像素检测"},"children":[{"type":"text","value":"像素检测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现方法有多种，下面列举在 Canvas 中的两种实现方式："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"利用 canvas 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"globalCompositeOperation = 'destination-in'"}]},{"type":"text","value":" 属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"内存"}]},{"type":"text","value":"。渲染到内存比渲染到屏幕更快。—— "},{"type":"element","tag":"a","props":{"href":"http://devbutze.blogspot.com/2014/02/html5-canvas-offscreen-rendering.html","rel":["nofollow"]},"children":[{"type":"text","value":"Offscreen Rendering"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然，我们这里并不是利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"offscreen render"}]},{"type":"text","value":" 的性能优势，而是利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"offscreen canvas"}]},{"type":"text","value":" 保存独立物体的像素。换句话说："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相交区域"}]},{"type":"text","value":"，然后只对该区域内的像素进行检测即可。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图例：\n"},{"type":"element","tag":"img","props":{"alt":"像素检测","src":"/images/2020-01-12-Collision-detection/pixel_collision.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面示例展示了第一种实现方式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"因为需要检查每一像素来判定是否碰撞，性能要求比较高。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适用案例："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"需要以像素级别检测物体是否碰撞。"}]}]},{"type":"element","tag":"h2","props":{"id":"光线投射法ray-casting"},"children":[{"type":"text","value":"光线投射法（Ray Casting）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"#1"}]},{"type":"text","value":")，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"#2"}]},{"type":"text","value":")，根据两条线的交点位置来判定是否发生碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"抛球进桶图例：\n"},{"type":"element","tag":"img","props":{"alt":"光线投射法","src":"/images/2020-01-12-Collision-detection/ray_casting_collision.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在小球飞行的过程中，需要不断计算两直线的交点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"两直线交点在桶口的左右边沿间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"小球位于第二条线（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"#2"}]},{"type":"text","value":"）下方"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在线运行示例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"适合运动速度快的物体"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"适用范围相对局限。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适用案例："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"抛球运动进桶。"}]}]},{"type":"element","tag":"h2","props":{"id":"分离轴定理separating-axis-theorem"},"children":[{"type":"text","value":"分离轴定理（Separating Axis Theorem）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"概念：通过判断任意两个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"凸多边形"}]},{"type":"text","value":" 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图例：\n"},{"type":"element","tag":"img","props":{"alt":"分离轴定理","src":"/images/2020-01-12-Collision-detection/sat_base.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在程序中，遍历所有角度是不现实的。那如何确定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"投影轴"}]},{"type":"text","value":" 呢？其实"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"投影轴的数量与多边形的边数相等即可。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"https://misc.aotu.io/JChehe/2017-02-13-2d-collision-detection/sat_projection_two.png","src":"/images/2020-01-12-Collision-detection/sat_projection_two.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以较高抽象层次判断两个凸多边形是否碰撞："}]},{"type":"element","tag":"pre","props":{"code":"function polygonsCollide(polygon1, polygon2) {\n    var axes, projection1, projection2\n    \n    // 根据多边形获取所有投影轴\n    axes = polygon1.getAxes()\n    axes.push(polygon2.getAxes())\n    \n    // 遍历所有投影轴，获取多边形在每条投影轴上的投影\n    for(each axis in axes) {\n        projection1 = polygon1.project(axis)\n        projection2 = polygon2.project(axis)\n        \n        // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n        if(!projection1.overlaps(projection2))\n            return false\n    }\n    return true\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"function polygonsCollide(polygon1, polygon2) {\n    var axes, projection1, projection2\n    \n    // 根据多边形获取所有投影轴\n    axes = polygon1.getAxes()\n    axes.push(polygon2.getAxes())\n    \n    // 遍历所有投影轴，获取多边形在每条投影轴上的投影\n    for(each axis in axes) {\n        projection1 = polygon1.project(axis)\n        projection2 = polygon2.project(axis)\n        \n        // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n        if(!projection1.overlaps(projection2))\n            return false\n    }\n    return true\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述代码有几个需要解决的地方："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如何确定多边形的各个投影轴"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如何将多边形投射到某条投影轴上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如何检测两段投影是否发生重叠"}]}]},{"type":"element","tag":"h4","props":{"id":"投影轴"},"children":[{"type":"text","value":"投影轴"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"边缘向量"}]},{"type":"text","value":"。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"边缘法向量"}]},{"type":"text","value":"”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"投影轴"}]},{"type":"text","value":"平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"投影轴","src":"/images/2020-01-12-Collision-detection/sat_projection_one.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"// 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。\nvar v1 = new Vector(p1.x, p1.y)\n    v2 = new Vector(p2.x, p2.y)\n\n// 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。\n// 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。\n// 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 = 0 可得：(-B,A) 或 (B,-A)。\n    axis = v1.edge(v2).normal()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。\nvar v1 = new Vector(p1.x, p1.y)\n    v2 = new Vector(p2.x, p2.y)\n\n// 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。\n// 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。\n// 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 = 0 可得：(-B,A) 或 (B,-A)。\n    axis = v1.edge(v2).normal()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是向量对象的部分实现，具体可看源码。"}]},{"type":"element","tag":"pre","props":{"code":"var Vector = function(x, y) {\n    this.x = x\n    this.y = y\n}\n\nVector.prototype = {\n    // 获取向量大小（即向量的模），即两点间距离\n    getMagnitude: function() {\n        return Math.sqrt(Math.pow(this.x, 2),\n                         Math.pow(this.y, 2))\n    },\n    // 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n    // 后续将会用其计算出投影的长度\n    dotProduct: function(vector) {\n        return this.x * vector.x + this.y + vector.y\n    },\n    // 向量相减 得到边\n    subtarct: function(vector) {\n        var v = new Vector()\n        v.x = this.x - vector.x\n        v.y = this.y - vector.y\n        return v\n    },\n    edge: function(vector) {\n        return this.substract(vector)\n    },\n    // 获取当前向量的法向量（垂直）\n    perpendicular: function() {\n        var v = new Vector()\n        v.x = this.y\n        v.y = 0 - this.x\n        return v\n    },\n    // 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量\n    normalize: function() {\n        var v = new Vector(0, 0)\n            m = this.getMagnitude()\n        if(m !== 0) {\n            v.x = this.x / m\n            v.y = this.y /m\n        }\n        return v\n    },\n    // 获取边缘法向量的单位向量，即投影轴\n    normal: function() {\n        var p = this.perpendicular()\n        return p .normalize()\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var Vector = function(x, y) {\n    this.x = x\n    this.y = y\n}\n\nVector.prototype = {\n    // 获取向量大小（即向量的模），即两点间距离\n    getMagnitude: function() {\n        return Math.sqrt(Math.pow(this.x, 2),\n                         Math.pow(this.y, 2))\n    },\n    // 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n    // 后续将会用其计算出投影的长度\n    dotProduct: function(vector) {\n        return this.x * vector.x + this.y + vector.y\n    },\n    // 向量相减 得到边\n    subtarct: function(vector) {\n        var v = new Vector()\n        v.x = this.x - vector.x\n        v.y = this.y - vector.y\n        return v\n    },\n    edge: function(vector) {\n        return this.substract(vector)\n    },\n    // 获取当前向量的法向量（垂直）\n    perpendicular: function() {\n        var v = new Vector()\n        v.x = this.y\n        v.y = 0 - this.x\n        return v\n    },\n    // 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量\n    normalize: function() {\n        var v = new Vector(0, 0)\n            m = this.getMagnitude()\n        if(m !== 0) {\n            v.x = this.x / m\n            v.y = this.y /m\n        }\n        return v\n    },\n    // 获取边缘法向量的单位向量，即投影轴\n    normal: function() {\n        var p = this.perpendicular()\n        return p .normalize()\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"此处输入图片的描述","src":"/images/2020-01-12-Collision-detection/vector_subtract.png"},"children":[]},{"type":"text","value":"\n向量相减"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更多关于向量的知识可通过其它渠道学习。"}]},{"type":"element","tag":"h4","props":{"id":"投影"},"children":[{"type":"text","value":"投影"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"判断两多边形的投影是否重合："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"projection1.max > projection2.min && project2.max > projection.min"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"此处输入图片的描述","src":"/images/2020-01-12-Collision-detection/sat_project_length.png"},"children":[]},{"type":"text","value":"\n为了易于理解，示例图将坐标轴"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"原点(0,0)"}]},{"type":"text","value":"放置于三角形"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"边1"}]},{"type":"text","value":"投影轴的适当位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由上述可得投影对象："}]},{"type":"element","tag":"pre","props":{"code":"// 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置\nvar Projection = function (min, max) {\n    this.min\n    this.max\n}\n\nprojection.prototype = {\n    // 判断两投影是否重叠\n    overlaps: function(projection) {\n        return this.max > projection.min && projection.max > this.min\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置\nvar Projection = function (min, max) {\n    this.min\n    this.max\n}\n\nprojection.prototype = {\n    // 判断两投影是否重叠\n    overlaps: function(projection) {\n        return this.max > projection.min && projection.max > this.min\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何得到向量在投影轴上的长度？\n向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n由于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"投影轴"}]},{"type":"text","value":"是单位向量（长度为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"），投影的长度为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x1 * x2 + y1 * y2"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"点积","src":"/images/2020-01-12-Collision-detection/dot_product.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"// 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。\nfunction project = function (axis) {\n    var scalars = [], v = new Vector()\n    \n    this.points.forEach(function (point) {\n        v.x = point.x\n        v.y = point.y\n        scalars.push(v.dotProduct(axis))\n    })\n    return new Projection(Math.min.apply(Math, scalars),\n                          Math.max,apply(Math, scalars))\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。\nfunction project = function (axis) {\n    var scalars = [], v = new Vector()\n    \n    this.points.forEach(function (point) {\n        v.x = point.x\n        v.y = point.y\n        scalars.push(v.dotProduct(axis))\n    })\n    return new Projection(Math.min.apply(Math, scalars),\n                          Math.max,apply(Math, scalars))\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"圆形与多边形之间的碰撞检测"},"children":[{"type":"text","value":"圆形与多边形之间的碰撞检测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"圆形与多边形的投影轴","src":"/images/2020-01-12-Collision-detection/sat_projection_circle.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分离轴定理的整体代码实现，可查看以下案例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"精确"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不适用于凹多边形"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适用案例："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"任意凸多边形和圆形。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更多关于分离轴定理的资料："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.sevenson.com.au/actionscript/sat/","rel":["nofollow"]},"children":[{"type":"text","value":"Separating Axis Theorem (SAT) explanation"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.metanetsoftware.com/technique/tutorialA.html","rel":["nofollow"]},"children":[{"type":"text","value":"Collision detection and response"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169","rel":["nofollow"]},"children":[{"type":"text","value":"Collision detection Using the Separating Axis Theorem"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.codezealot.org/archives/55","rel":["nofollow"]},"children":[{"type":"text","value":"SAT (Separating Axis Theorem)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://rocketmandevelopment.com/blog/separation-of-axis-theorem-for-collision-detection/","rel":["nofollow"]},"children":[{"type":"text","value":"Separation of Axis Theorem (SAT) for Collision Detection"}]}]}]},{"type":"element","tag":"h4","props":{"id":"延伸最小平移向量mit"},"children":[{"type":"text","value":"延伸：最小平移向量（MIT）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"最小平移向量","src":"/images/2020-01-12-Collision-detection/mit.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"碰撞性能优化"},"children":[{"type":"text","value":"碰撞性能优化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。"}]},{"type":"element","tag":"h4","props":{"id":"粗略阶段broad-phase"},"children":[{"type":"text","value":"粗略阶段（Broad Phase）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供这些信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"读者若感兴趣，可以自行查阅相关信息。"}]},{"type":"element","tag":"h4","props":{"id":"精细阶段narrow-phase"},"children":[{"type":"text","value":"精细阶段（Narrow Phase）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。"}]},{"type":"element","tag":"h3","props":{"id":"最后"},"children":[{"type":"text","value":"最后"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"碰撞检测有多种，选择合适最重要。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"完！"}]},{"type":"element","tag":"h3","props":{"id":"参考资料"},"children":[{"type":"text","value":"参考资料"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection","rel":["nofollow"]},"children":[{"type":"text","value":"MDN：2D collision detection"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://item.jd.com/11231175.html?dist=jd","rel":["nofollow"]},"children":[{"type":"text","value":"《HTML5 Canvas 核心技术：图形、动画与游戏开发》"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://lazyfoo.net/SDL_tutorials/lesson19/index.php","rel":["nofollow"]},"children":[{"type":"text","value":"Circular Collision Detection"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.migapro.com/circle-and-rotated-rectangle-collision-detection/","rel":["nofollow"]},"children":[{"type":"text","value":"Circle and Rotated Rectangle Collision Detection"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.cnblogs.com/ywxgod/archive/2010/08/06/1793609.html","rel":["nofollow"]},"children":[{"type":"text","value":"推导坐标旋转公式"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"感谢您的阅读，本文由 "},{"type":"element","tag":"a","props":{"href":"https://aotu.io/","rel":["nofollow"]},"children":[{"type":"text","value":"凹凸实验室"}]},{"type":"text","value":" 版权所有。如若转载，请注明出处：凹凸实验室（"},{"type":"element","tag":"a","props":{"href":"https://aotu.io/notes/2017/02/16/2d-collision-detection/%EF%BC%89","rel":["nofollow"]},"children":[{"type":"text","value":"https://aotu.io/notes/2017/02/16/2d-collision-detection/）"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"外接图形判别法","depth":2,"text":"外接图形判别法","children":[{"id":"轴对称包围盒axis-aligned-bounding-box","depth":3,"text":"轴对称包围盒（Axis-Aligned Bounding Box）"},{"id":"圆形碰撞circle-collision","depth":3,"text":"圆形碰撞（Circle Collision）"},{"id":"圆形与矩形无旋转","depth":3,"text":"圆形与矩形（无旋转）"},{"id":"圆形与旋转矩形以矩形中心为旋转轴","depth":3,"text":"圆形与旋转矩形（以矩形中心为旋转轴）"}]},{"id":"其他","depth":2,"text":"其他","children":[{"id":"地图格子划分","depth":3,"text":"地图格子划分"},{"id":"像素检测","depth":3,"text":"像素检测"}]},{"id":"光线投射法ray-casting","depth":2,"text":"光线投射法（Ray Casting）"},{"id":"分离轴定理separating-axis-theorem","depth":2,"text":"分离轴定理（Separating Axis Theorem）","children":[{"id":"碰撞性能优化","depth":3,"text":"碰撞性能优化"},{"id":"最后","depth":3,"text":"最后"},{"id":"参考资料","depth":3,"text":"参考资料"}]}]}},"_type":"markdown","_id":"content:unity:2020-01-12-Collision-detection.md","_source":"content","_file":"unity/2020-01-12-Collision-detection.md","_extension":"md","date":"2020-01-12"},{"_path":"/unity/2020-01-13-unity-attack-detection","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity攻击范围检测","description":"扇形攻击其实这个分为两部分，是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离是扇形角度范围内计算怪物是否在你的视野范围内其实可以这么看\nAvatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。这样就能判断是否在视线范围内。所以现在的问题就是这么计算这个夹角计算的方式是，获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量调用Vector3.Angle(a, b)计算夹角    public ","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"扇形攻击"},"children":[{"type":"text","value":"扇形攻击"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实这个分为两部分，"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是扇形角度范围内"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"计算怪物是否在你的视野范围内其实可以这么看\n"},{"type":"element","tag":"img","props":{"alt":"【小松教你手游开发】【unity实用技能】计算目标物体是否在自己的扇形视野范围","src":"/images/2020-01-13-unity-attack-detection/80f6c4220d181e73991a8dfdfda32a81.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Avatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样就能判断是否在视线范围内。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以现在的问题就是这么计算这个夹角"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"计算的方式是，"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用Vector3.Angle(a, b)计算夹角"}]}]},{"type":"element","tag":"pre","props":{"code":"    public GameObject avatar;\n    public GameObject enemy;\n    \n    //扇形距离 攻击距离  扇形的半径 \n    float minDistance = 10f;\n    //扇形的角度 也就是攻击的角度\n    float minAngle = 120f;\n\n    // Update is called once per frame\n    void Update ()\n    {\n        Vector3 avatarPos = avatar.transform.position;\n        Vector3 enemyPos = enemy.transform.position;\n        \n        //与敌人的距离\n        float distance = Vector3.Distance(avatarPos, enemyPos);\n\n        //主角相对于目标的向量\n        Vector3 srcLocalVect = enemyPos - avatarPos;\n        srcLocalVect.y = 0;\n\n        //获取主角正前方的一个点\n        Vector3 forwardLocalPos = avatar.transform.forward * 1 + avatarPos;\n\n        //获取正方向向量\n        Vector3 forwardLocalVect = forwardLocalPos - avatarPos;\n        forwardLocalVect.y = 0;\n\n        //计算角度\n        float angle = Vector3.Angle(srcLocalVect, forwardLocalVect);\n\n        if(distance < minDistance && angle < minAngle/2)\n        {\n            Debug.Log(\"In EyeSight\");\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public GameObject avatar;\n    public GameObject enemy;\n    \n    //扇形距离 攻击距离  扇形的半径 \n    float minDistance = 10f;\n    //扇形的角度 也就是攻击的角度\n    float minAngle = 120f;\n\n    // Update is called once per frame\n    void Update ()\n    {\n        Vector3 avatarPos = avatar.transform.position;\n        Vector3 enemyPos = enemy.transform.position;\n        \n        //与敌人的距离\n        float distance = Vector3.Distance(avatarPos, enemyPos);\n\n        //主角相对于目标的向量\n        Vector3 srcLocalVect = enemyPos - avatarPos;\n        srcLocalVect.y = 0;\n\n        //获取主角正前方的一个点\n        Vector3 forwardLocalPos = avatar.transform.forward * 1 + avatarPos;\n\n        //获取正方向向量\n        Vector3 forwardLocalVect = forwardLocalPos - avatarPos;\n        forwardLocalVect.y = 0;\n\n        //计算角度\n        float angle = Vector3.Angle(srcLocalVect, forwardLocalVect);\n\n        if(distance < minDistance && angle < minAngle/2)\n        {\n            Debug.Log(\"In EyeSight\");\n        }\n    }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"长方形范围攻击检测"},"children":[{"type":"text","value":"长方形范围攻击检测"}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            float rightDistance = Vector3.Dot(temVec, transform.right.normalized);\n\n            if (Mathf.Abs(rightDistance) <= 3)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            float rightDistance = Vector3.Dot(temVec, transform.right.normalized);\n\n            if (Mathf.Abs(rightDistance) <= 3)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"判断目标点是否在指定的矩形内两个随机点确定的矩形"},"children":[{"type":"text","value":"判断目标点是否在指定的矩形内（两个随机点确定的矩形）"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class Rectangle01\n{\n    /// Min为当前坐标系中矩形的最小点\n    /// Max为当前坐标系中矩形的最大点\n    public Vector2 Min;\n    public Vector2 Max;\n \n    public bool Contains( Vector2 point)\n    {\n        if (point.x < this.Min.x)\n        {\n            return false;\n        }\n        if (point.x > this.Max.x)\n        {\n            return false;\n        }\n        if (point.y < this.Min.y)\n        {\n            return false;\n        }\n        if (point.y > this.Max.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        vertex0 = this.Min;\n        vertex1 = new Vector2(this.Max.x, this.Min.y);\n        vertex2 = this.Max;\n        vertex3 = new Vector2(this.Min.x, this.Max.y);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class Rectangle01\n{\n    /// Min为当前坐标系中矩形的最小点\n    /// Max为当前坐标系中矩形的最大点\n    public Vector2 Min;\n    public Vector2 Max;\n \n    public bool Contains( Vector2 point)\n    {\n        if (point.x < this.Min.x)\n        {\n            return false;\n        }\n        if (point.x > this.Max.x)\n        {\n            return false;\n        }\n        if (point.y < this.Min.y)\n        {\n            return false;\n        }\n        if (point.y > this.Max.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        vertex0 = this.Min;\n        vertex1 = new Vector2(this.Max.x, this.Min.y);\n        vertex2 = this.Max;\n        vertex3 = new Vector2(this.Min.x, this.Max.y);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试   脚本"}]},{"type":"element","tag":"pre","props":{"code":"public class TestRt01 : MonoBehaviour {\n \n    public Transform Point;\n    public Transform RtPoint0, RtPoint1;\n    public Rectangle01 rtBox;\n \n    private const float _pointRadius = 0.1f;\n  \n    private void OnDrawGizmos()\n    {\n        if (rtBox != null)\n        {\n            DrawRt(rtBox);\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            rtBox = CreateFromTwoPoints(RtPoint0.position, RtPoint1.position);\n            bool cont = rtBox.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    public Rectangle01 CreateFromTwoPoints(Vector2 point0, Vector2 point1)\n    {\n        Rectangle01 rt = new Rectangle01();\n        if (point0.x < point1.x)\n        {\n            rt.Min.x = point0.x;\n            rt.Max.x = point1.x;\n        }\n        else\n        {\n            rt.Min.x = point1.x;\n            rt.Max.x = point0.x;\n        }\n        if (point0.y < point1.y)\n        {\n            rt.Min.y = point0.y;\n            rt.Max.y = point1.y;\n        }\n        else\n        {\n            rt.Min.y = point1.y;\n            rt.Max.y = point0.y;\n        }\n        return rt;\n    }\n \n    protected void DrawRt( Rectangle01 box)\n    {\n        Vector2 v0, v1, v2, v3;\n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class TestRt01 : MonoBehaviour {\n \n    public Transform Point;\n    public Transform RtPoint0, RtPoint1;\n    public Rectangle01 rtBox;\n \n    private const float _pointRadius = 0.1f;\n  \n    private void OnDrawGizmos()\n    {\n        if (rtBox != null)\n        {\n            DrawRt(rtBox);\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            rtBox = CreateFromTwoPoints(RtPoint0.position, RtPoint1.position);\n            bool cont = rtBox.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    public Rectangle01 CreateFromTwoPoints(Vector2 point0, Vector2 point1)\n    {\n        Rectangle01 rt = new Rectangle01();\n        if (point0.x < point1.x)\n        {\n            rt.Min.x = point0.x;\n            rt.Max.x = point1.x;\n        }\n        else\n        {\n            rt.Min.x = point1.x;\n            rt.Max.x = point0.x;\n        }\n        if (point0.y < point1.y)\n        {\n            rt.Min.y = point0.y;\n            rt.Max.y = point1.y;\n        }\n        else\n        {\n            rt.Min.y = point1.y;\n            rt.Max.y = point0.y;\n        }\n        return rt;\n    }\n \n    protected void DrawRt( Rectangle01 box)\n    {\n        Vector2 v0, v1, v2, v3;\n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"判断目标点是否在某一矩形区域以任一点为中心的矩形区域"},"children":[{"type":"text","value":"判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）"}]},{"type":"element","tag":"pre","props":{"code":"public class Box {\n \n    public Vector2 Center;\n    public Vector2 Axis0;\n    public Vector2 Axis1;\n    public Vector2 Extents;\n \n    public Box(Vector2 center, Vector2 axis0, Vector2 axis1, Vector2 extents)\n    {\n        this.Center = center;\n        this.Axis0 = axis0;\n        this.Axis1 = axis1;\n        this.Extents = extents;\n    }\n    public bool Contains(Vector2 point)\n    {\n        Vector2 vector;\n        vector.x = point.x - this.Center.x;\n        vector.y = point.y - this.Center.y;\n        float num = vector.Dot(ref this.Axis0);\n        if (num < -this.Extents.x)\n        {\n            return false;\n        }\n        if (num > this.Extents.x)\n        {\n            return false;\n        }\n        num = vector.Dot(ref this.Axis1);\n        if (num < -this.Extents.y)\n        {\n            return false;\n        }\n        if (num > this.Extents.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        Vector2 vector = (Vector2)(this.Axis0 * this.Extents.x);\n        Vector2 vector2 = (Vector2)(this.Axis1 * this.Extents.y);\n        vertex0 = (this.Center - vector) - vector2;\n        vertex1 = (this.Center + vector) - vector2;\n        vertex2 = (this.Center + vector) + vector2;\n        vertex3 = (this.Center - vector) + vector2;\n    }\n \n}\n \npublic static class Vector2ex\n{\n    public static float Dot(this Vector2 vector, ref Vector2 value)\n    {\n        return ((vector.x * value.x) + (vector.y * value.y));\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Box {\n \n    public Vector2 Center;\n    public Vector2 Axis0;\n    public Vector2 Axis1;\n    public Vector2 Extents;\n \n    public Box(Vector2 center, Vector2 axis0, Vector2 axis1, Vector2 extents)\n    {\n        this.Center = center;\n        this.Axis0 = axis0;\n        this.Axis1 = axis1;\n        this.Extents = extents;\n    }\n    public bool Contains(Vector2 point)\n    {\n        Vector2 vector;\n        vector.x = point.x - this.Center.x;\n        vector.y = point.y - this.Center.y;\n        float num = vector.Dot(ref this.Axis0);\n        if (num < -this.Extents.x)\n        {\n            return false;\n        }\n        if (num > this.Extents.x)\n        {\n            return false;\n        }\n        num = vector.Dot(ref this.Axis1);\n        if (num < -this.Extents.y)\n        {\n            return false;\n        }\n        if (num > this.Extents.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        Vector2 vector = (Vector2)(this.Axis0 * this.Extents.x);\n        Vector2 vector2 = (Vector2)(this.Axis1 * this.Extents.y);\n        vertex0 = (this.Center - vector) - vector2;\n        vertex1 = (this.Center + vector) - vector2;\n        vertex2 = (this.Center + vector) + vector2;\n        vertex3 = (this.Center - vector) + vector2;\n    }\n \n}\n \npublic static class Vector2ex\n{\n    public static float Dot(this Vector2 vector, ref Vector2 value)\n    {\n        return ((vector.x * value.x) + (vector.y * value.y));\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试脚本"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class TestBox : MonoBehaviour {\n \n    public Transform Point;\n    public Transform rtBox;\n    Box box;\n    private const float _pointRadius = .11f;\n    private void OnDrawGizmos()\n    {\n        if (box!=null)\n        {\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n            DrawBox(ref box);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            box = new Box(rtBox.position, rtBox.right, rtBox.up, rtBox.localScale); ;\n            bool cont = box.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n \n    protected void DrawBox(ref Box box)\n    {\n        Vector2 v0, v1, v2, v3;\n \n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class TestBox : MonoBehaviour {\n \n    public Transform Point;\n    public Transform rtBox;\n    Box box;\n    private const float _pointRadius = .11f;\n    private void OnDrawGizmos()\n    {\n        if (box!=null)\n        {\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n            DrawBox(ref box);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            box = new Box(rtBox.position, rtBox.right, rtBox.up, rtBox.localScale); ;\n            bool cont = box.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n \n    protected void DrawBox(ref Box box)\n    {\n        Vector2 v0, v1, v2, v3;\n \n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"半圆形攻击范围检测"},"children":[{"type":"text","value":"半圆形攻击范围检测"}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            if (distance <= 5)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            if (distance <= 5)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"圆形攻击范围"},"children":[{"type":"text","value":"圆形攻击范围"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"圆形攻击范围有两种，以玩着荣耀的王昭君大招为例子，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一种是制定位置施法：新版本的王昭君的大招是指定位置施法的，也就是说在玩家固定施法半径以内可随意放一个圆形的技能。在半径之内的敌人受伤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二种是固定位置施法：老版本的王昭君大招是在自身一定半径以内，敌人在这个范围内受伤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实两种判断都很简单，只需要判断敌人和SkillPosition之间的距离是否小于半径即可。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-13-unity-attack-detection/20180425195609483.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"/// <summary>\n    /// 不定点式圆形攻击\n    /// </summary>\n    /// <param name=\"attacked\">被攻击方</param>\n    /// <param name=\"skillPosition\">技能释放位置</param>\n    /// <param name=\"radius\">半径</param>\n    /// <returns></returns>\n    public bool CircleAttack(Transform attacked,Transform skillPosition, float radius)\n    {\n        float distance = Vector3.Distance(attacked.position, skillPosition.position);\n        if (distance < radius)\n        {\n            return true;\n        }\n        return false;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/// <summary>\n    /// 不定点式圆形攻击\n    /// </summary>\n    /// <param name=\"attacked\">被攻击方</param>\n    /// <param name=\"skillPosition\">技能释放位置</param>\n    /// <param name=\"radius\">半径</param>\n    /// <returns></returns>\n    public bool CircleAttack(Transform attacked,Transform skillPosition, float radius)\n    {\n        float distance = Vector3.Distance(attacked.position, skillPosition.position);\n        if (distance < radius)\n        {\n            return true;\n        }\n        return false;\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"方法2"}]},{"type":"element","tag":"pre","props":{"code":"public class Circle {\n \n    public Vector2 Center;\n    public float Radius;\n \n    public Circle(Vector2 center, float radius)\n    {\n        this.Center = center;\n        this.Radius = radius;\n    }\n \n    public bool Contains( Vector2 point)\n    {\n        Vector2 vector = point - this.Center;\n        return (vector.SqrMagnitude() <= (this.Radius * this.Radius));\n    }\n \n    public Vector2 Eval(float t)\n    {\n        return new Vector2(this.Center.x + (this.Radius * Mathf.Cos(t)), this.Center.y + (this.Radius * Mathf.Sin(t)));\n    }\n }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Circle {\n \n    public Vector2 Center;\n    public float Radius;\n \n    public Circle(Vector2 center, float radius)\n    {\n        this.Center = center;\n        this.Radius = radius;\n    }\n \n    public bool Contains( Vector2 point)\n    {\n        Vector2 vector = point - this.Center;\n        return (vector.SqrMagnitude() <= (this.Radius * this.Radius));\n    }\n \n    public Vector2 Eval(float t)\n    {\n        return new Vector2(this.Center.x + (this.Radius * Mathf.Cos(t)), this.Center.y + (this.Radius * Mathf.Sin(t)));\n    }\n }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"判断一个点是否在三角形里面"},"children":[{"type":"text","value":"判断一个点是否在三角形里面"}]},{"type":"element","tag":"pre","props":{"code":"public static  bool InTrigon(Vector3 _target,Vector3 _center,Vector3 _left,Vector3 _right){  \n        Vector3 Ctl=_left-_center;  \n        Vector3 Ctr=_right -_center;  \n        Vector3 Ctt=_target-_center;  \n        Vector3 Ltr=_right-_left;  \n        Vector3 Ltc=_right-_center;  \n        Vector3 Ltt=_left-_target;  \n        Vector3 Rtl=_left-_right;  \n        Vector3 Rtc=_center-_right;  \n        Vector3 Rtt=_target-_right;  \n        if(   \n           Vector3.Dot(Vector3.Cross(Ctl,Ctr).normalized,Vector3.Cross(Ctl,Ctt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Ltr,Ltc).normalized,Vector3.Cross(Ltr,Ltt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Rtc,Rtl).normalized,Vector3.Cross(Rtc,Rtt).normalized)==1  \n           )  \n            return true;  \n        else  \n            return false;  \n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static  bool InTrigon(Vector3 _target,Vector3 _center,Vector3 _left,Vector3 _right){  \n        Vector3 Ctl=_left-_center;  \n        Vector3 Ctr=_right -_center;  \n        Vector3 Ctt=_target-_center;  \n        Vector3 Ltr=_right-_left;  \n        Vector3 Ltc=_right-_center;  \n        Vector3 Ltt=_left-_target;  \n        Vector3 Rtl=_left-_right;  \n        Vector3 Rtc=_center-_right;  \n        Vector3 Rtt=_target-_right;  \n        if(   \n           Vector3.Dot(Vector3.Cross(Ctl,Ctr).normalized,Vector3.Cross(Ctl,Ctt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Ltr,Ltc).normalized,Vector3.Cross(Ltr,Ltt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Rtc,Rtl).normalized,Vector3.Cross(Rtc,Rtt).normalized)==1  \n           )  \n            return true;  \n        else  \n            return false;  \n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原理：通过向量之间的对比，利用点乘和差乘实现判断一个点是否在三角形里面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"叉乘： 叉乘结果用右手判断法则。"}]},{"type":"element","tag":"h3","props":{"id":"方法二"},"children":[{"type":"text","value":"方法二"}]},{"type":"element","tag":"pre","props":{"code":"public class Triangle \n{\n    public enum Orientations\n    {\n        CW,//三个点顺时针\n        CCW,//三个点逆时针\n        None//不清楚点的顺序\n    }\n \n    public Vector2 V0;\n    public Vector2 V1;\n    public Vector2 V2;\n    public Triangle(Vector2 v0, Vector2 v1, Vector2 v2)\n    {\n        this.V0 = v0;\n        this.V1 = v1;\n        this.V2 = v2;\n    }\n    public static Triangle CreateTriangle2(Transform v0, Transform v1, Transform v2)\n    {\n        return new Triangle(v0.position, v1.position, v2.position);\n    }\n \n    public Orientations CalcOrientation(float threshold = 1E-05f)\n    {\n        float num = this.CalcDeterminant();\n        if (num > threshold)\n        {\n            return Orientations.CCW;\n        }\n        if (num < -threshold)\n        {\n            return Orientations.CW;\n        }\n        return Orientations.None;\n    }\n \n    public float CalcDeterminant()\n    {\n        return ((((((this.V1.x * this.V2.y) + (this.V0.x * this.V1.y)) + (this.V2.x * this.V0.y)) - (this.V1.x * this.V0.y)) - (this.V2.x * this.V1.y)) - (this.V0.x * this.V2.y));\n    }\n \n    public bool Contains(Vector2 point)\n    {\n        bool flag = (((point.x - this.V1.x) * (this.V0.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V0.x - this.V1.x))) < 0f;\n        bool flag2 = (((point.x - this.V2.x) * (this.V1.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V1.x - this.V2.x))) < 0f;\n        if (flag != flag2)\n        {\n            return false;\n        }\n        bool flag3 = (((point.x - this.V0.x) * (this.V2.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V2.x - this.V0.x))) < 0f;\n        return (flag2 == flag3);\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是逆时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) > 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是顺时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) < 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Triangle \n{\n    public enum Orientations\n    {\n        CW,//三个点顺时针\n        CCW,//三个点逆时针\n        None//不清楚点的顺序\n    }\n \n    public Vector2 V0;\n    public Vector2 V1;\n    public Vector2 V2;\n    public Triangle(Vector2 v0, Vector2 v1, Vector2 v2)\n    {\n        this.V0 = v0;\n        this.V1 = v1;\n        this.V2 = v2;\n    }\n    public static Triangle CreateTriangle2(Transform v0, Transform v1, Transform v2)\n    {\n        return new Triangle(v0.position, v1.position, v2.position);\n    }\n \n    public Orientations CalcOrientation(float threshold = 1E-05f)\n    {\n        float num = this.CalcDeterminant();\n        if (num > threshold)\n        {\n            return Orientations.CCW;\n        }\n        if (num < -threshold)\n        {\n            return Orientations.CW;\n        }\n        return Orientations.None;\n    }\n \n    public float CalcDeterminant()\n    {\n        return ((((((this.V1.x * this.V2.y) + (this.V0.x * this.V1.y)) + (this.V2.x * this.V0.y)) - (this.V1.x * this.V0.y)) - (this.V2.x * this.V1.y)) - (this.V0.x * this.V2.y));\n    }\n \n    public bool Contains(Vector2 point)\n    {\n        bool flag = (((point.x - this.V1.x) * (this.V0.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V0.x - this.V1.x))) < 0f;\n        bool flag2 = (((point.x - this.V2.x) * (this.V1.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V1.x - this.V2.x))) < 0f;\n        if (flag != flag2)\n        {\n            return false;\n        }\n        bool flag3 = (((point.x - this.V0.x) * (this.V2.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V2.x - this.V0.x))) < 0f;\n        return (flag2 == flag3);\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是逆时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) > 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是顺时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) < 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试脚本"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class TriangleTest : MonoBehaviour {\n    public Transform Point;\n    public Transform V0, V1, V2;\n    Triangle triangle;\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            triangle = Triangle.CreateTriangle2(V0, V1, V2);\n            Triangle.Orientations orientation = triangle.CalcOrientation();\n \n            bool cont = false;\n            if (orientation == Triangle.Orientations.CCW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else if (orientation == Triangle.Orientations.CW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else // Degenerate\n            {\n                Debug.LogError(\"Triangle is degenerate\");\n            }\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    private void OnDrawGizmos()\n    {\n        if (triangle!=null)\n        {\n            DrawTriangle( triangle);\n        }\n    }\n \n \n    void DrawTriangle( Triangle triangle)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(triangle.V0, triangle.V1);\n        Gizmos.DrawLine(triangle.V1, triangle.V2);\n        Gizmos.DrawLine(triangle.V2, triangle.V0);\n    }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class TriangleTest : MonoBehaviour {\n    public Transform Point;\n    public Transform V0, V1, V2;\n    Triangle triangle;\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            triangle = Triangle.CreateTriangle2(V0, V1, V2);\n            Triangle.Orientations orientation = triangle.CalcOrientation();\n \n            bool cont = false;\n            if (orientation == Triangle.Orientations.CCW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else if (orientation == Triangle.Orientations.CW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else // Degenerate\n            {\n                Debug.LogError(\"Triangle is degenerate\");\n            }\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    private void OnDrawGizmos()\n    {\n        if (triangle!=null)\n        {\n            DrawTriangle( triangle);\n        }\n    }\n \n \n    void DrawTriangle( Triangle triangle)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(triangle.V0, triangle.V1);\n        Gizmos.DrawLine(triangle.V1, triangle.V2);\n        Gizmos.DrawLine(triangle.V2, triangle.V0);\n    }\n\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"向量"},"children":[{"type":"text","value":"向量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实这些小算法基本上用的全是向量的计算,向量的计算有两种"}]},{"type":"element","tag":"h3","props":{"id":"向量的点乘"},"children":[{"type":"text","value":"向量的点乘"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"–>A . B = |A| * |B| * cos θ\n–>点乘应用"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果 让 A 等于单位向量 |A| ==1 c点积 等于 B 在 A 上的投影"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果 让 A B等于单位向量 arccos(a.b) == 夹角"}]}]},{"type":"element","tag":"h3","props":{"id":"向量的叉乘"},"children":[{"type":"text","value":"向量的叉乘"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"–>A* B = C C就是A和B的法向量\n–>叉乘应用"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"c 是有方向 。 通过 左手 定则 可以知道 C 的方向"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所以叉乘一般是用来计算方向的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A 和 B 都是单位向量 arcsin(|A*B|) 等于 夹角"}]}]},{"type":"element","tag":"h1","props":{"id":"凸多边形碰撞分离轴定理算法"},"children":[{"type":"text","value":"凸多边形碰撞(分离轴定理算法)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"*"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"正文如下：*"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"多边形碰撞","src":"/images/2020-01-13-unity-attack-detection/20170204235932265.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我发现我需要在flash中检测多边形碰撞时，我碰巧地遇到了一个叫“分离轴定理”的方法。但唯一的问题是，为了真正地掌握它，我可费了不少功夫。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在阅读了大量有关碰撞检测的资料，并参看了一些代码示例后，这个方法总算被我领悟了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了帮助其他那些不精通数学的开发者，我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍。我还在下文引入了一个使用分离轴定理实现的demo，以及供大家下载并使用的ActionScript 3源代码。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"（译者：demo和源代码请到原文中查看和下载）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：分离轴定理需要一点数学向量的知识，所以在深究这个算法前，你最好复习一下这方面的内容。"}]},{"type":"element","tag":"h1","props":{"id":"算法简述"},"children":[{"type":"text","value":"算法简述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从根本上来讲，分离轴定理（以及其他碰撞算法）的用途就是去检测并判断两个图形之间是否有间隙。分离轴定理中用到的方法使算法本身显得十分独特。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我所听到过分离轴定理的最好类比方式是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"投影问题","src":"/images/2020-01-13-unity-attack-detection/20170205000242395.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从编程的角度来讲，从每个可能的角度上去检测会使处理变得十分密集。不过幸运的是，由于多边形的性质，你只需要检测其中几个关键的角度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你需要检测的角度数量就正是这个多边形的边数。也就是说，你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和。举个例子，两个五边形就需要检测10个角度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"角度选取","src":"/images/2020-01-13-unity-attack-detection/20170205000357272.jpg"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"如何在代码中实现"},"children":[{"type":"text","value":"如何在代码中实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个简易但比较啰嗦的方法，以下是基本的步骤："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤一：**从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤一图解","src":"/images/2020-01-13-unity-attack-detection/20170205000919294.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤二：**循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤二图解","src":"/images/2020-01-13-unity-attack-detection/20170205001546835.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤三：**对第二个多边形做同样的处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤三图解","src":"/images/2020-01-13-unity-attack-detection/20170205001940563.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤四：**分别得到这两个多边形的投影，并检测这两段投影是否重叠。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤四图解","src":"/images/2020-01-13-unity-attack-detection/20170205002051627.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个算法基本就是如此的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顺带提一下，如果你记录了哪个轴上的投影重叠值最小（以及重叠了多少），那么你就能用这个值来分开这两个图形。"}]},{"type":"element","tag":"h2","props":{"id":"那么如何处理圆呢"},"children":[{"type":"text","value":"那么如何处理圆呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在分离轴定理中，检测圆与检测多边形相比，会有点点奇异，但仍然是可以实现的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"圆的投影轴","src":"/images/2020-01-13-unity-attack-detection/20170205002152799.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这以后就是按套路遍历另一个多边形的每条投影轴，并检测是否有投影重叠。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"噢，对了，万一你想知道如何把圆投影到轴上，那你只用简单地把圆心投影上去，然后加上和减去半径就能得到投影长度了。"}]},{"type":"element","tag":"h1","props":{"id":"优点与不足"},"children":[{"type":"text","value":"优点与不足"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和其他的碰撞检测技术一样，分离轴定理算法有它自己的优点和不足。以下是其一些优点和不足的简要概述："}]},{"type":"element","tag":"h2","props":{"id":"优点"},"children":[{"type":"text","value":"优点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（译者：原来老外也喜欢先谈优点啊～>～）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……）"}]}]},{"type":"element","tag":"h2","props":{"id":"不足"},"children":[{"type":"text","value":"不足"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可能这个算法会有更多优点和不足之处，但是我想这应该是最主要的几个了。"}]},{"type":"element","tag":"h1","props":{"id":"总结"},"children":[{"type":"text","value":"总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我希望这篇文章能帮助你了解到分离轴定理算法。我已经尽可能地不提供过多的信息并讲解得十分简明了。（我绝不是数学方面的专家，所以如果我遗漏了什么，我深表歉意）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是一些帮助我理解分离轴定理算法的页面："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.harveycartel.org/metanet/tutorials/tutorialA.html","rel":["nofollow"]},"children":[{"type":"text","value":"harverycartel.org"}]},{"type":"text","value":"——有更多详细的表述以及很多很酷的示例。我在这个页面上学到了很多。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://gpwiki.org/index.php/VB:Tutorials:Building_A_Physics_Engine:Basic_Intersection_Detection","rel":["nofollow"]},"children":[{"type":"text","value":"GPWiki.org"}]},{"type":"text","value":"——有不错的讲解和代码示例，我用这些代码作为编写自己代码的基础。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.tonypa.pri.ee/vectors/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"Tony Pa"}]},{"type":"text","value":"——向量教程，学习向量的不错资源。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gamedev.net/community/forums/topic.asp?topic_id=251638","rel":["nofollow"]},"children":[{"type":"text","value":"GameDev.net forum"}]},{"type":"text","value":"——一个论坛成员写的分离轴定理碰撞检测系统，带给了我一些计算方面的想法。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"本文翻译自"}]},{"type":"element","tag":"a","props":{"href":"http://www.sevenson.com.au/","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"@sevenson"}]}]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"的文章"}]},{"type":"element","tag":"a","props":{"href":"http://www.sevenson.com.au/actionscript/sat/","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Separating Axis Theorem (SAT) Explanation"}]}]},{"type":"text","value":"** 。**"}]},{"type":"element","tag":"pre","props":{"code":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XRect{\n    private Vector2 _point0 = new Vector2();\n    private Vector2 _point1 = new Vector2();\n    private Vector2 _point2 = new Vector2();\n    private Vector2 _point3 = new Vector2();\n\n    public List<Vector2> _pointList = new List<Vector2>();\n\n    private float _min = 0;\n    private float _max = 0;\n\n\n    public void UpdatePoint(RectTransform RT)\n    {\n        float x = RT.localPosition.x;\n        float y = RT.localPosition.y;\n        float width = RT.sizeDelta.x;\n        float height = RT.sizeDelta.y;\n        float angle = RT.localRotation.eulerAngles.z;\n\n        Vector2 centerV = new Vector2(RT.localPosition.x, RT.localPosition.y);\n\n        _point0 = new Vector2(x - width / 2, y + height / 2);\n        _point0 = _Transform(_point0,angle,centerV);\n\n        _point1 = new Vector2(x + width / 2, y + height / 2);\n        _point1 = _Transform(_point1, angle, centerV);\n\n        _point2 = new Vector2(x + width / 2, y - height / 2);\n        _point2 = _Transform(_point2, angle, centerV);\n\n        _point3 = new Vector2(x - width / 2, y - height / 2);\n        _point3 = _Transform(_point3, angle, centerV);\n\n        _pointList.Clear();\n        _pointList.Add(_point0);\n        _pointList.Add(_point1);\n        _pointList.Add(_point2);\n        _pointList.Add(_point3);\n\n        Vector3[] temp = new Vector3[4];\n        RT.GetLocalCorners(temp);\n       \n    }\n\n    //获取投影轴\n    public Vector2 GetAxis(int index)\n    {\n        Vector2 v = _GetEdge(index);\n\n        Vector2 result = new Vector2();\n\n        result.x = v.y;\n        result.y = 0 - v.x;\n\n        return result;\n    }\n\n    public void ResetProjection(Vector2 axis)\n    {\n        if (axis.x == 0 && axis.y == 0)\n        {\n            Debug.LogError(\"投影轴数据错误！\");\n            return;\n        }\n        float projectionX;\n        Vector2 v;\n        for (int i = 0; i < _pointList.Count; ++i)\n        {\n            v = _pointList[i];\n            if (axis.x == 0)\n            {\n                projectionX = v.y;\n            }\n            else if (axis.y == 0)\n            {\n                projectionX = v.x;\n            }\n            else\n            {\n                projectionX = (v.x - axis.x / axis.y * v.y) / (1 + Mathf.Pow(axis.x / axis.y, 2));\n            }\n\n\n            if (i == 0)\n            {\n                _min = projectionX;\n                _max = projectionX;\n            }\n            else\n            {\n                if (projectionX > _max)\n                {\n                    _max = projectionX;\n                }\n                if (projectionX < _min)\n                {\n                    _min = projectionX;\n                }\n            }\n\n        } \n    }\n\n    public float GetMin()\n    {\n        return _min;\n    }\n\n    public float GetMax()\n    {\n        return _max;\n    }\n\n\n    //获取边向量\n    private Vector2 _GetEdge(int index)\n    {\n        Vector2 result = new Vector2();\n        switch (index)\n        {\n            case 0:\n                result = _point1 - _point0;\n                break;\n            case 1:\n                result = _point2 - _point1;\n                break;\n            case 2:\n                result = _point3 - _point2;\n                break;\n            case 3:\n                result = _point0 - _point3;\n                break;\n        }\n\n        return result;\n    }\n\n    private Vector2 _Transform(Vector2 v,float angle,Vector2 centerV)\n    {\n        Vector2 result = new Vector2();\n\n        float initX = v.x;\n        float initY = v.y;\n\n        //将顶点移动到原点四周\n        float centerPointX = initX - centerV.x;\n        float centerPointY = initY - centerV.y;\n\n        float r = angle * Mathf.Deg2Rad;\n\n        float a = Mathf.Cos(r);\n        float b = Mathf.Sin(r);\n\n        result.x = centerPointX * a + centerPointY * (-b) + centerV.x;\n        result.y = centerPointX * b + centerPointY * a + centerV.y;\n\n        return result;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XRect{\n    private Vector2 _point0 = new Vector2();\n    private Vector2 _point1 = new Vector2();\n    private Vector2 _point2 = new Vector2();\n    private Vector2 _point3 = new Vector2();\n\n    public List<Vector2> _pointList = new List<Vector2>();\n\n    private float _min = 0;\n    private float _max = 0;\n\n\n    public void UpdatePoint(RectTransform RT)\n    {\n        float x = RT.localPosition.x;\n        float y = RT.localPosition.y;\n        float width = RT.sizeDelta.x;\n        float height = RT.sizeDelta.y;\n        float angle = RT.localRotation.eulerAngles.z;\n\n        Vector2 centerV = new Vector2(RT.localPosition.x, RT.localPosition.y);\n\n        _point0 = new Vector2(x - width / 2, y + height / 2);\n        _point0 = _Transform(_point0,angle,centerV);\n\n        _point1 = new Vector2(x + width / 2, y + height / 2);\n        _point1 = _Transform(_point1, angle, centerV);\n\n        _point2 = new Vector2(x + width / 2, y - height / 2);\n        _point2 = _Transform(_point2, angle, centerV);\n\n        _point3 = new Vector2(x - width / 2, y - height / 2);\n        _point3 = _Transform(_point3, angle, centerV);\n\n        _pointList.Clear();\n        _pointList.Add(_point0);\n        _pointList.Add(_point1);\n        _pointList.Add(_point2);\n        _pointList.Add(_point3);\n\n        Vector3[] temp = new Vector3[4];\n        RT.GetLocalCorners(temp);\n       \n    }\n\n    //获取投影轴\n    public Vector2 GetAxis(int index)\n    {\n        Vector2 v = _GetEdge(index);\n\n        Vector2 result = new Vector2();\n\n        result.x = v.y;\n        result.y = 0 - v.x;\n\n        return result;\n    }\n\n    public void ResetProjection(Vector2 axis)\n    {\n        if (axis.x == 0 && axis.y == 0)\n        {\n            Debug.LogError(\"投影轴数据错误！\");\n            return;\n        }\n        float projectionX;\n        Vector2 v;\n        for (int i = 0; i < _pointList.Count; ++i)\n        {\n            v = _pointList[i];\n            if (axis.x == 0)\n            {\n                projectionX = v.y;\n            }\n            else if (axis.y == 0)\n            {\n                projectionX = v.x;\n            }\n            else\n            {\n                projectionX = (v.x - axis.x / axis.y * v.y) / (1 + Mathf.Pow(axis.x / axis.y, 2));\n            }\n\n\n            if (i == 0)\n            {\n                _min = projectionX;\n                _max = projectionX;\n            }\n            else\n            {\n                if (projectionX > _max)\n                {\n                    _max = projectionX;\n                }\n                if (projectionX < _min)\n                {\n                    _min = projectionX;\n                }\n            }\n\n        } \n    }\n\n    public float GetMin()\n    {\n        return _min;\n    }\n\n    public float GetMax()\n    {\n        return _max;\n    }\n\n\n    //获取边向量\n    private Vector2 _GetEdge(int index)\n    {\n        Vector2 result = new Vector2();\n        switch (index)\n        {\n            case 0:\n                result = _point1 - _point0;\n                break;\n            case 1:\n                result = _point2 - _point1;\n                break;\n            case 2:\n                result = _point3 - _point2;\n                break;\n            case 3:\n                result = _point0 - _point3;\n                break;\n        }\n\n        return result;\n    }\n\n    private Vector2 _Transform(Vector2 v,float angle,Vector2 centerV)\n    {\n        Vector2 result = new Vector2();\n\n        float initX = v.x;\n        float initY = v.y;\n\n        //将顶点移动到原点四周\n        float centerPointX = initX - centerV.x;\n        float centerPointY = initY - centerV.y;\n\n        float r = angle * Mathf.Deg2Rad;\n\n        float a = Mathf.Cos(r);\n        float b = Mathf.Sin(r);\n\n        result.x = centerPointX * a + centerPointY * (-b) + centerV.x;\n        result.y = centerPointX * b + centerPointY * a + centerV.y;\n\n        return result;\n    }\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XCollisionHelper {\n\n    private static XCollisionHelper _instance;\n\n    public static XCollisionHelper GetInstance()\n    {\n        if (_instance  == null)\n        {\n            _instance = new XCollisionHelper();\n        }\n\n        return _instance;\n    }\n\n    public bool Check(XRect xRect1,XRect xRect2)\n    {\n        for (int i = 0; i <4;++i)\n        {\n            Vector2 axis = xRect1.GetAxis(i);\n\n            //获取两个矩形在投影轴上的范围\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        for (int i = 0; i < 4; ++i)\n        {\n            Vector2 axis = xRect2.GetAxis(i);\n\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    \n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XCollisionHelper {\n\n    private static XCollisionHelper _instance;\n\n    public static XCollisionHelper GetInstance()\n    {\n        if (_instance  == null)\n        {\n            _instance = new XCollisionHelper();\n        }\n\n        return _instance;\n    }\n\n    public bool Check(XRect xRect1,XRect xRect2)\n    {\n        for (int i = 0; i <4;++i)\n        {\n            Vector2 axis = xRect1.GetAxis(i);\n\n            //获取两个矩形在投影轴上的范围\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        for (int i = 0; i < 4; ++i)\n        {\n            Vector2 axis = xRect2.GetAxis(i);\n\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    \n\n}\n"}]}]},{"type":"element","tag":"pre","props":{"code":"﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class XRectItemCtrl : MonoBehaviour, IDragHandler\n{\n\n    public Image imgRect;\n    private XRect _xRect = new XRect();\n\n    public XRect GetXRect()\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        _xRect.UpdatePoint(RT);\n\n        if (transform.gameObject.name == \"Image0\")\n        {\n        }\n\n        return _xRect;\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        RT.localPosition = new Vector2(RT.localPosition.x + eventData.delta.x, RT.localPosition.y + eventData.delta.y);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class XRectItemCtrl : MonoBehaviour, IDragHandler\n{\n\n    public Image imgRect;\n    private XRect _xRect = new XRect();\n\n    public XRect GetXRect()\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        _xRect.UpdatePoint(RT);\n\n        if (transform.gameObject.name == \"Image0\")\n        {\n        }\n\n        return _xRect;\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        RT.localPosition = new Vector2(RT.localPosition.x + eventData.delta.x, RT.localPosition.y + eventData.delta.y);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"其他的一些参考"},"children":[{"type":"text","value":"其他的一些参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[]},{"type":"element","tag":"li","props":{},"children":[]},{"type":"element","tag":"li","props":{},"children":[]},{"type":"element","tag":"li","props":{},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"方法二","depth":3,"text":"方法二"},{"id":"向量的点乘","depth":3,"text":"向量的点乘"},{"id":"向量的叉乘","depth":3,"text":"向量的叉乘"},{"id":"那么如何处理圆呢","depth":2,"text":"那么如何处理圆呢？"},{"id":"优点","depth":2,"text":"优点"},{"id":"不足","depth":2,"text":"不足"}]}},"_type":"markdown","_id":"content:unity:2020-01-13-unity-attack-detection.md","_source":"content","_file":"unity/2020-01-13-unity-attack-detection.md","_extension":"md","date":"2020-01-13"},{"_path":"/unity/2020-02-15-skill-system","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"技能系统","description":"从架构上说,主动技能都可以拆分为释放条件检测->释放->目标选择->产生效果\n但是里面很多细节,比如子弹初始位置设置,做成什么样子组合出更多的设计形式,同时可以兼容更多的有效需求\n比如一个回合制卡牌游戏,要啥飞行子弹,区域只要相对和绝对位置2大类,然后直接填坐标就好了示例1:\n玩家释放技能1->释放子弹1对自身加免疫buff,释放子弹2在1秒后对身前范围最近1个友方击中->命中后对自身释放子弹->命令自身对目标释放技能2\n释放技能1后选择对身前最近一个友方追加释放技能2示例2:\n被动技能->获得buff->buff触发器每2秒在自身位置释放单体子弹1清除buff1,aoe子弹击中敌人->每命中","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-15-skill-system/20180602102244475.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从架构上说,主动技能都可以拆分为释放条件检测->释放->目标选择->产生效果\n但是里面很多细节,比如子弹初始位置设置,做成什么样子组合出更多的设计形式,同时可以兼容更多的有效需求\n比如一个回合制卡牌游戏,要啥飞行子弹,区域只要相对和绝对位置2大类,然后直接填坐标就好了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"示例1:"}]},{"type":"text","value":"\n玩家释放技能1->释放子弹1对自身加免疫buff,释放子弹2在1秒后对身前范围最近1个友方击中->命中后对自身释放子弹->命令自身对目标释放技能2\n释放技能1后选择对身前最近一个友方追加释放技能2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"示例2:"}]},{"type":"text","value":"\n被动技能->获得buff->buff触发器每2秒在自身位置释放单体子弹1清除buff1,aoe子弹击中敌人->每命中一个敌人对自身叠加1层buff1\n实际效果:周围敌人越多自身获得越多层buff1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"示例3:"}]},{"type":"text","value":"\n玩家释放技能1->释放子弹1对自身周围友方和敌方击中->对命中的目标释放3个子弹:子弹1筛选敌人产生伤害,子弹2筛选友方30%血以上造成治疗,子弹3筛选敌人血量大于80%命中后产生子弹4对自身添加buff\n实际效果:对周围友方残血造成治疗,对敌人造成伤害,如果击中的敌人血量较高,自身获得增益"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"示例4"}]},{"type":"text","value":"\n玩家有被动技能获得buff1->buff触发器效果为暴击击中时若双方距离>300则对目标发射子弹1和子弹2->子弹1对自身添加buff,子弹2筛选有buff2的敌人\n技能效果:暴击击中距离自身较远的敌人使自身获得增益,触发时若敌人有buff2,则造成额外效果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"示例5"}]},{"type":"text","value":"\n玩家释放主动技能->发射子弹使自身获得6层buff1\nbuff1附带3个触发器\n触发器1->释放技能清除所有层数buff1\n触发器2->受到攻击失去1层\n触发器3->buff1消失时自身获得buff2\nbuff2->触发器每1秒对自身附近发射子弹筛选1个敌人->令目标对自身发射子弹添加增益\n技能效果:主动隐身,受到攻击失去1层,释放技能后解除隐身,隐身结束后一段时间内受到伤害转移给附近一个敌人"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基础内容有这么几个部分：\n1、Actor，这个是角色本身，它不属于技能系统，但是它要给技能系统开放足够的接口，比如播放动画、播放声音、控制位移、造成伤害、添加buff等等\n2、Skill，这个就是技能本身，它在合适的时机调用脚本中的相应函数，脚本中可以在OnCreate  OnHit  OnDeath  OnHeroDeath  OnSoldierDeath等事件中写相应代码。由于是脚本，所以代码非常灵活，而由于限定了只处理技能相关功能，所以代码也不会很复杂，有经验的策划绝对搞的定。\n3、Buff，这个是技能效果的核心。它可以是有时限的，也可以是被动无时限的。在它对应的脚本中，定义了这个Buff会影响哪些角色属性（如血量、暴击、攻击力等等）或者角色状态（如眩晕、隐身、沉默等等），同样，buff脚本也支持事件机制，在脚本的相应事件处理其逻辑功能，可以实现非常丰富的效果。\n4、Modifier，这个是一个技能修改器。技能修改器可以修改技能的流程和效果（比如技能伤害增加、火球击中人会爆炸等等），具体可以参考风暴英雄中的技能天赋系统。技能修改器并没有脚本与之对应，一个技能如果支持某个修改器，需要在脚本中处理相应功能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能的基类是RoleSkill，然后分近战和远程两个大类，记得不要根据职业来分，而是根据功能来抽象，近战的技能是通过武器来产生伤害，而远程技能是通过发射物来伤害。近战技能可以继续分为：近距离接触攻击单人，近距离范围内接触攻击多人等；远程技能可以分为：单发射物攻击单人，远距离范围内非接触攻击多人等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https://github.com/dongweiPeng/SkillSystem/raw/master/Assets/%E6%8A%80%E8%83%BD%E6%B5%81%E7%A8%8B.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"广义的的说，和战斗结算相关的内容都算技能系统，包括技能信息管理、技能调用接口、技能目标查找、技能表现、技能结算、技能创生体（buff/法术场/弹道）管理，此外还涉及的模块包括：AI模块（技能调用者）、动作模块、寻路/移动模块以及人物属性和伤害数值结算等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先说下技能模块每个部分的职责和原理："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能信息管理：管理unit所拥有的技能以及技能的等级、cd等。在我们游戏中，这里还需要负责管理符文，符文会对技能信息进行修改。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能调用接口：AI或者UI操作触发技能，触发技能时可能选择了一个目标（AI），也可能并没有目标。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能流程管理：一个技能可能由多个子技能以移动的执行模式组合而成，而每一个最终执行的技能执行过程也存在一个流程，一般包括：前摇过程-结算点-后摇过程。技能在前摇结束时进入技能真正的结算流程，结算流程可能创建子弹，也可能触发buf或者创建法术场。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能目标查找：若技能触发时已经设置了技能目标unit(如怪物AI释放技能)，则直接将其作为目标unit，否则需要根据一定的策略选择一个目标。此外，技能释放的时候还需要释放方向和释放位置等信息，也通过这个模块获取。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能表现：技能释放过程中，需要创建相应的特效以及执行相应的动作。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能创生体（buf/弹道/法术场）管理：buf挂在unit身上，可能影响unit的一些行为和状态；法术场一般由场景管理，影响场景中某范围内的unit；弹道就是技能创建的一个子弹，这个子弹可能以不同的路线移动（直线／抛物线／直接命中等）"}]}]},{"type":"element","tag":"h2","props":{"id":"_0技能表"},"children":[{"type":"text","value":"0技能表"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先说下实现技能的基本思路。实现技能的基本思路就是通过策划填写表格，来配制成某些技能，在执行某个技能的时候，分别去根据这些表格中的内容，确定技能如何表现。基本的逻辑是："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"if skillTable.get(\"技能动作\"):\n     paly 动作\nif skillTable.get(\"特效\"):\n     播放特效\nif skillTable.get(\"法术场\"):\n    创建法术场\n....\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if skillTable.get(\"技能动作\"):\n     paly 动作\nif skillTable.get(\"特效\"):\n     播放特效\nif skillTable.get(\"法术场\"):\n    创建法术场\n....\n"}]}]},{"type":"element","tag":"h2","props":{"id":"_1-技能信息管理"},"children":[{"type":"text","value":"1 技能信息管理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"unit创建时，此模块管理unit可使用哪些技能，比如游戏中玩家可以选择使用哪些技能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏中技能的升级、技能加点、技能池管理都在这个模块。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此模块还需要管理技能等级／符文／装备等外部模块对技能参数的修改。"}]},{"type":"element","tag":"h2","props":{"id":"_2-技能调用接口"},"children":[{"type":"text","value":"2 技能调用接口"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"提供技能调用的接口供AI或玩家操作调用，调用时可以提供一个目标unit，也可以不提供让技能自己查找。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"提供三个接口："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能开始skill_enter：开始执行技能，若技能不循环进行，则技能可以自动结束。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能结束skill_exit：有的技能不能自己结束，比如某些循环技能，对于循环技能玩家可以按住按钮一直释放。当玩家松开按钮，调用技能结束接口，告诉当前技能使其结束，此时技能到达后摇点时，技能不再继续执行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能停止skill_stop：当技能被强制打断时，如被攻击、晕眩、蓝不足等，技能会被强制停止。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此外，当前一个技能正在执行时新的技能调用启动，此时新的技能调用信息会被保存。一般来说，并不会把所有新的技能调用信息保存下来，那样就成了一个技能执行的序列。我们游戏仅保存一个新的技能调用信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总的来说，技能模块提供尽量少的接口供AI/UI等上层逻辑使用，这样可以有效的与AI和UI进行解耦。"}]},{"type":"element","tag":"h2","props":{"id":"_3-技能流程管理"},"children":[{"type":"text","value":"3 技能流程管理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能流程这里分两点讨论："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个技能可能由多个子技能以一定的模式组合起来。\n一个技能常常由多个子技能以一定的模式组合而成，比如三段击、比如冲锋斩（先冲锋、后斩）等，甚至还存在根据不同的环境选择执行不同的子技能。分析策划需求发现，技能可以分成一个树形结构，这个树形结构非常类似行为树，同样可以将节点分为控制节点和执行节点，甚至可以包括condition节点。为此，我们项目引入一个技能树概念来描述这种数据结构。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个具体的技能（技能树执行节点）也有一个固定的执行流程。这个流程一般为：前摇过程、前摇过程结束=技能结算时间点、后摇时间点。"}]}]},{"type":"element","tag":"h3","props":{"id":"_31-技能树"},"children":[{"type":"text","value":"3.1 技能树"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能树参考传统行为树的设计，使用树形结构控制技能的执行流程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能树和行为树在结构上比较类似，但是在运行逻辑上有很大的不同。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，技能树的重点并不是根据上下文选择一个合适的节点执行，而是以一定的策略将技能树从头到尾遍历执行一遍。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其次，技能树没有tick的概念，而是基于回调的，比如一个顺序节点，顺序节点中一个子节点执行完毕后，马上通知顺序节点，顺序节点执行下一个子节点，直至顺序节点的最后一个子节点执行完毕，顺序节点就会通知父节点（如果有）它已经执行完毕。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此外，为了完成技能的一些需求，控制节点往往存储更多的控制信息来控制子节点的执行流程。具体的信息根据策划需求设置，比如顺序结点包括原子属性和循环属性。如果一个顺序节点具有原子属性，则这个顺树节点在执行的过程中并不会被end，只有全部子节点执行结束才可以end。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以我们游戏中战士普攻三段击为例："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https:////upload-images.jianshu.io/upload_images/36361-5ec18bbce4b863ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/544/format/webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Paste_Image.png"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"三段击本身是一个顺序节点，当技能开始时，此节点顺序执行三个子节点。对于第一个子节点，它依然是一个顺序节点，首先冲锋至目标单位身前，然后对目标单位进行挥砍。但是冲锋节点还包括了一个condition，若和目标的距离很近，则跳过冲锋节点，直接挥砍。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"普攻是一个循环技能，这个技能只要玩家点着按钮不放开，技能就会一直执行，因此根节点（普攻）是一个具有循环属性的顺序节点。而对于子技能1（控制节点），他是一个具有原子属性的顺序技能，即当单位正在冲锋时，玩家松开按钮，单位也会执行完挥砍后才会推出技能。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"！关于技能树的使用和思考"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能树开始的设计思路是，有些技能的执行流程和行为树类似，比如以一定的顺序执行一系列子技能，比如根据不同的上下文确定技能的执行流程。简单的说，技能树的引入有以下好处：1.使技能模块可以获得部分AI的能力，从而将和技能强相关的AI逻辑放在技能模块使技能模块和AI模块降低耦合，2.可以清晰的描述技能流程，3.使用树增加拓展性，策划可以设计出各种各样复杂的技能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于好处1，举个例子：屠夫boss的勾子技能可以将玩家拉过来，若成功的拉过来，boss会执行一个攻击子技能，否则不执行。通过这样可以将勾人和攻击作为两个子技能构成技能树，攻击子技能有一个condition过程，即判断上一个子技能是否成功。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能树在使用后慢慢发现一些问题，首先，技能树的同步要求每个树节点都进行同步，增加同步负担，其次，技能本身并不会有太复杂的控制结构。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为此，后来我们对技能树进行了优化：\n1.简化同步信息，不再同步所有节点的enter/exit信息（具体参考文章《技能模块的同步》）。\n2.取消并行节点，通过拓展表头实现一个技能同时执行多件事情。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终的技能树基本上是只有顺序／随机两种控制类型节点，节点拥有较轻度的condition功能。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h3","props":{"id":"_32-执行节点的技能流程"},"children":[{"type":"text","value":"3.2 执行节点的技能流程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般来说，技能的执行流程包括："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前摇时间：技能开始，但是技能真正的结算流程还没开始。技能开始以后，机能相关的特效和动作就开始播放。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前摇时间结束：技能前摇结束时技能开始真正的释放以及结算，等技能前摇结束以后，技能真正的释放并结算。释放包括创建相应的弹道／法术场和buff。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能后摇点：技能播放到后摇点时间时，技能真正的结束。这时，技能对应的特效以及人物动作可能还会继续播放，但是技能流程已经正式结束了。也就是说，下一个技能可以执行。"}]}]},{"type":"element","tag":"h2","props":{"id":"_4-技能目标查找"},"children":[{"type":"text","value":"4 技能目标查找"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能释放时，目标可能已经由AI传给了技能模块，也有可能没有一个目标，如玩家控制单位。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能在释放法术场、弹道的时候，重要的是技能的方向而不是技能目标一般来说，技能获得一个目标对象以后，技能的方向就是释法者到目标的方向。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此外，技能方向可能需要一些配置，如前摇锁定（前摇过程中目标移动，技能方向不变），UI可控制（技能释放过程中，玩家可以通过控制UI控制技能的释放方向）。"}]},{"type":"element","tag":"h2","props":{"id":"_5技能表现"},"children":[{"type":"text","value":"5技能表现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能的表现包括动作、特效、shader、音效等。其中，特效比较复杂，需要配置的内容也比较多。比如，有些特效挂在模型上，有的特效挂在场景里。对于法术场的特效，分别可以分为法术场开始、结算、结束特效，分别在法术场开始时、结算时、结束时显示。对于buff也类似。"}]},{"type":"element","tag":"h2","props":{"id":"_6-弹道法术场和buff等技能创生体"},"children":[{"type":"text","value":"6 弹道、法术场和buff等技能创生体"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"狭义的来说，技能只是负责技能的执行流程（技能树管理以及技能流程管理），而技能真正的结算主要是由其创生体结算的。当技能前摇结束开始生效时，技能创建相应的弹道和法术场，法术场弹道击中敌人时又有可能产生相应的buff。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般来说，法术场是一个场景的某块检测区域，每隔一段时间法术场检测此区域的敌人，并对其攻击结算。\n弹道是一类子弹移动路径的抽象，创建一个弹道就表示一个子弹特效沿这个弹道移动并检测路径上的敌人。\nbuff就是挂在单位身上的一个具有持续时间的状态，状态对单位产生一些正面或者负面的影响，并且在此段时间内，每隔一段时间进行一次伤害结算 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于技能、法术场、buff之间的功能界定并不是很固定，比如技能能否直接对单位造成伤害，法术场能否对单位造成伤害，甚至技能只能创建法术场，法术场只能检测目标不能造成伤害，只能挂buff，而所有的伤害都是通过buff来结算。当然，这样并不一定好，一般来说，技能和法术场都可以对单位造成伤害。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总之，创生体功能的界定需要根据策划需求、效率考虑等因素调整。"}]},{"type":"element","tag":"h2","props":{"id":"_61-buff状态"},"children":[{"type":"text","value":"6.1 Buff状态"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Buff就是挂在单位身上持续一定时间的有益或者有害的状态，这里状态＝buff。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Buff模块有个需要注意的是Buff之间的相互关系，如排斥（A状态在，B状态挂不上去），清除（A状态挂上去同时导致B状态消失）等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了实现以上功能，最简单的方式是在状态A中直接填写状态关系状态字段，如状态A排斥状态B/C/D/E...，A状态清除状态X/Y/Z...。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上的实现方式有个问题，等游戏做到后期，我们有成千上万个buff状态，那么一个魔法免疫状态，策划需要填表的排斥状态可能成千上万。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决这个问题，可以使用分类的思想解决。定义某类状态和另一类状态之间的规则。\n基于以上思想，引入一个叫buff原子状态的概念，原子状态表示一类状态，如减速、禁魔、魔免、悬空、晕眩、变羊等等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在给单位挂一个新的buff的之前，查询此buff持有的原子状态和单位身上已经有的原子状态之间的关系，根据单位身上已有的原子状态判定新的原子状态应该使用何种行为处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此处的何种行为，代表的就是原子状态之间的规则，如排斥等。这些规则可以让策划填一个名字叫“原子状态关系”的表，此表是一个n*n的二维数组，n为游戏中所有的原子状态的数量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原子状态的数量远远小于buff的数量，所以可以很容易的定义这些规则。"}]},{"type":"element","tag":"h3","props":{"id":"_62-法术场"},"children":[{"type":"text","value":"6.2 法术场"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"法术场描述对一块区域的影响，这块区域可以每隔一段时间进行一次检测，检测这块区域内的单位并且对单位进行结算。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"法术场需要注意一个问题，就是一个法术场每次结算可能使用不同的参数进行结算，比如一个技能，第一次结算对每个单位进行晕眩，第二次结算对单位进行伤害。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决这种问题比较直接的方式是技能直接创建两个法术场，每个法术场结算一次，第二个法术场创建具有延迟时间。但是这种方式有个问题，有可能策划需求做一个结算十次而且每次结算的参数都不同的法术场。那么，一个技能以一定的时间间隔创建是个法术场，同时法术场的管理具有一定的成本，从而导致效率的降低。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为解决这个问题，我们优化了法术场结算的实现机制，增加了一种新的法术场：序列法术场。这类法术场策划可以配置法术场每次结算之间的时间间隔以及每次结算所使用的法术场参数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里所说的技能模块包括：技能流程、法术场、弹道和buff。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先介绍authority和proxy的概念，这两个概念是基于单位unit的基础上进行的区分。\nauthority表示单位的主控端，即此单位是由客户端和还是服务端控制。对于玩家avatar，玩家本地的客户端就是主控端。而对于怪物，他们的行为由服务端控制，主控端就是服务端。\nproxy表示代理端，表示被主控端控制。如对于怪物来说，所有的客户端都是proxy；对于玩家A来说，服务端和其他玩家的客户端都是proxy。"}]},{"type":"element","tag":"h2","props":{"id":"_0-技能同步的原则"},"children":[{"type":"text","value":"0 技能同步的原则"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.客户端先行\n对于玩家控制的单位来说，玩家点击按钮释放一个技能，客户端首先响应，单位播放动作以及相应的技能特效。"}]},{"type":"element","tag":"pre","props":{"className":["language-undefined"],"code":"据我了解，有的已上线游戏并没有做客户端先行，而是所有的技能执行请求都发给服务端，然后由服务端发起。\n这种模式技能流程控制会比较简单，但是在网络环境差的情况下，体验可能差一些。但是，目测也是可以接受的。\n","language":"undefined","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"据我了解，有的已上线游戏并没有做客户端先行，而是所有的技能执行请求都发给服务端，然后由服务端发起。\n这种模式技能流程控制会比较简单，但是在网络环境差的情况下，体验可能差一些。但是，目测也是可以接受的。\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.技能流程以authority为发起端\n玩家单位技能发起是由她的客户端，怪物的技能发起是由AI也就是服务端。\n3.技能结算在服务端发起。\n技能真正的结算，比如法术场检测、buff结算、伤害结算等，统一在服务端处理。"}]},{"type":"element","tag":"h2","props":{"id":"_1-技能执行流程的同步"},"children":[{"type":"text","value":"1 技能执行流程的同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里所说的技能执行流程指的是技能树的一个执行节点的流程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能流程负责动作、特效以及技能结算，其中技能结算包括：释放法术场、弹道或buff。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个技能执行节点的执行流程中，需要同步的有两个时间点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能开始：技能开始播放动作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能结算：前摇结束，即能进入结算逻辑。这类同步消息往往并不是由技能本身去同步，而是技能生成了法术场、弹道等，他们去做相应的同步。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以玩家点击技能按钮开始释放技能为例介绍技能同步流程，如图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https:////upload-images.jianshu.io/upload_images/36361-392299771fc34192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Paste_Image.png"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.主控端点击技能按钮，技能开始播放动作，主控端告诉服务端技能开始。\n2.服务端广播给所有的客户端(多玩家场景)，告知其他所有的客户端此玩家开始执行技能。其他客户端收到指令后可是播放技能表现。\n3.服务端延迟一段时间后，服务端开始进行技能结算，并且将结算结果通知客户端。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"延迟时间=技能前摇时间-上行-下行，下行一半不能确定，所以默认为上行=下行"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一种中庸的计算方式是：延迟时间=技能前摇时间-上行，防止要求技能前摇时间过长"}]}]},{"type":"element","tag":"h3","props":{"id":"使用此同步流程的表现为"},"children":[{"type":"text","value":"使用此同步流程的表现为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.要求技能前摇时间>2*网络延迟，若前摇时间短，则延迟时间=0，效果可能差一些\n2.authority客户端表现完美。\n3.proxy client表现一般，即玩家A看玩家B的效果为：玩家B刚开始执行技能动作，没到前摇时间就进行了技能结算。但是因为玩家一般也不会过分关注其他玩家的动作，所以是可以接受的。"}]},{"type":"element","tag":"h2","props":{"id":"_2-技能树的同步"},"children":[{"type":"text","value":"2 技能树的同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我上篇文章"},{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/551f02f95727","rel":["nofollow"]},"children":[{"type":"text","value":"技能系统"}]},{"type":"text","value":"已经介绍，我们游戏使用的是技能树来管理技能流程。那么就面临一个问题，技能树如何同步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最简单最暴力的方式，是客户端和服务端同时管理技能树，并且将其状态同步。这样，客户端和服务端的技能树状态统一、完备。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后来发现，对于proxy端，并不需要完备的技能树信息，最节省的方式是proxy根本不接受技能树同步信息，只是接受播放动作、技能结算等信息。但这样需要告诉其他proxy播放什么动作、特效等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在我们系统中，技能同步包括三类同步消息:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能根节点enter (root_enter): 表示一个大技能的进入"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"技能叶子节点enter(action_enter): 表示一个技能树的执行节点的进入。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根节点exit(root_exit) ：表示大技能结束"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根节点保存一个完整技能的信息，需要和技能模块外部交互，因此需要知道技能的开始和结束。\n叶子节点的执行代表着技能真正的执行逻辑，也需要同步。\n而对于其他节点，作为流程控制节点，只需要在主端确保技能流程无误即可"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后来这里进行了进一步的优化，对于纯根节点，主控端（玩家控制的客户端）将信息同步给服务端，服务端不再同步给其他客户端。有的技能树只有一个节点，那么按照叶子节点的策略，主控端同步给服务端，服务端广播给所有的其他客户端。"}]}]},{"type":"element","tag":"h2","props":{"id":"_3-技能结算的同步"},"children":[{"type":"text","value":"3 技能结算的同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能结算包括创建法术场、buff、弹道、技能直接伤害等。"}]},{"type":"element","tag":"h4","props":{"id":"法术场弹道的同步"},"children":[{"type":"text","value":"法术场、弹道的同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"法术场、弹道的同步比较类似，他们都作为一个entity（网络同步单元）在服务端创建，创建以后使用entity管理机制服务端通知客户端他们的创建和销毁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以法术场为例，法术场的执行和同步流程："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务端发起创建一个法术场，并且通知客户端"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"法术场每隔一段时间结算一次，注意，法术场结算并不需要同步，每隔一段时间服务端执行检测逻辑，客户端播放结算特效等。两个逻辑互不依赖，也不要求时间一致。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当法术场结算时检测到攻击目标时，服务端计算攻击伤害等信息，并将攻击信息发给客户端。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端收到伤害信息，客户端播放相应的表现，如法术场受击特效等。此处还包括属于通用模块的跳字等。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当服务端的法术场时间到了进行destroy时，使用entity的管理机制通知所有客户端destroy法术场。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"弹道的同步类似，唯一的区别就是法术场在某一位置使用攻击盒检测目标，而弹道是一个移动的子弹，客户端表现是一个特效在飞，而服务端每隔一段时间根据飞行速度等使用胶囊攻击盒去检测目标碰撞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由以上可以发现，法术场作为一个entity他的管理成本是比较高的，所以若策划想出一些需求需要使用多个法术场实现，一般通过拓展法术场功能使用一个法术场来实现。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如，策划要做一个冰火两重天法术场，即法术场在每次结算时使用不同的参数，第一次结算使用火焰，第二次结算是冰霜。若这种需求较少，可以使用两个法术场，但是如果要冰火雷毒水电风魔奥术神圣***N重天，则代价太大。一般可以让法术场支持每次使用不同的结算参数来结算即可。"}]}]},{"type":"element","tag":"h4","props":{"id":"buff同步"},"children":[{"type":"text","value":"buff同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"buff是附加在unit身上的东西（没有unit就没有buff，但是没有unit可能有法术场），所以不需要使用entity来同步。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务端确定buff是否可以挂在unit上面。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端和服务端都维护一个buff管理器，挂buff的消息通知所有客户端，客户端负责表现，服务端负责结算即可。"}]}]},{"type":"element","tag":"h2","props":{"id":"_4-伤害属性的同步"},"children":[{"type":"text","value":"4 伤害、属性的同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主要介绍下伤害的同步，顺便附带介绍下属性同步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于伤害结算来说，技能、buff、法术场和弹道都可能造成伤害，当服务端发现造成伤害时，服务端首先根据技能信息计算伤害值，计算以后将信息通过技能模块发送给所有客户端，所有客户端接到信息后首先播放技能伤害相关的表现，如受击特效等，然后播放跳字等通用伤害客户端表现。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"buff可能修改单位属性，如攻击力、攻击速度等。单位的属性由基础成长属性+装备属性+buff属性构成，前两个属性为面板属性，属于玩家信息。而buff属性只在战斗中有效，在面板中并没有表现。\n因此装备属性的同步需要通知逻辑服务器（真正的服务器），而buff并不需要通知逻辑服务器。"}]},{"type":"element","tag":"h1","props":{"id":"技能说穿了只是一个流程而不该是一个实体"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"技能，说穿了只是一个流程，而不该是一个实体"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、表的作用实际不是定义流程，而是提供流程中需要的数据。因此不管流程需要数据的是前端还是后端，他们都应该从一个表中调用。\n2、并不是因为把技能作为实体才导致它的混乱，真正导致混乱是的技能实体的范围扩大化了（从这个意义上说，把技能做为一个流程也没什么错，技能的承载内容应该仅仅是这个流程本身），把后续效果剥离出来会好很多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我个人的经验，不评价好坏，大概是这样的：技能的表象数据必须要有，技能效果相应的数据应该仅限于这个技能释放条件和它的直接效果（这个与表象共享技能id，所以最好也放在一起）；直接效果之外的触发效果，单独建立BUFF表，为此建立一套单独的流程，供技能调用（也就是技能效果应该是触发了某个buff）"}]},{"type":"element","tag":"h2","props":{"id":"就skill和buff的边界问题"},"children":[{"type":"text","value":"就skill和buff的边界问题，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"恰好新的项目里里面我进行了一个比较新的尝试，就是抹除这个边界。 在这次的项目中，因为技能需求足够复杂，所以采用了以前一直只想没实践的想法，就是取消技能在逻辑中的的概念，或者说在基础逻辑中没有技能的设计，技能只在数据层和讨论的概念中出现。 具体的描述也很简单，所谓的技能我们都理解为 施法者一组行为和数据的组合，它包含了技能的icon，类型，动作等一系列和战斗逻辑有直接关系但没有本质关系的概念与数据的总和，用来在游戏概念中定义一个技能的所有特征。 但是在战斗中，真正发挥作用的是buff，在新的设计中，所有的参与战斗逻辑的实体都是buff。 比如 如果要实现一个火球，那么实现方式是技能数据告诉我会播放什么样的施法动画，同时丢出一个弹道，而这个弹道上附着一个buff，叫做燃烧，该buff附带特效火焰和200点的碰撞伤害（在弹道命中敌人时候）。 而这个一整个流程，在概念里，被定义为 施法者释放了一个技能，映射到现实逻辑，就是某人拿起一个石头，点燃，然后把石头丢出去砸到了某人。 至此，核心的技能结算逻辑里，彻底干掉了skill这个类，技能变成了只在概念讨论里才出现的词汇。战斗结算中，不再存在skill的概念。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"表与脚本混合."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"又有两种分支,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**分支一:主表副脚本,**脚本作为字段绑定于表里.表的某个字段就是技能的脚本路径.技能的主流程,框架逻辑有表的字段来决定."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"分支二:主脚本副表"}]},{"type":"text","value":",主逻辑,流程都是有脚本实现.技能的主流程由脚本实现.脚本读表获取数据,进行技能的操作."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点:增加奇怪技能,很方便,直接写脚本就可以了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点:批量处理工作量大,既要改表,又要改技能.每个技能对应独立的脚本,技能越多,脚本越多.批量处理的时候,工作量大."}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/147681650","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/147681650"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_0技能表","depth":2,"text":"0技能表"},{"id":"_1-技能信息管理","depth":2,"text":"1 技能信息管理"},{"id":"_2-技能调用接口","depth":2,"text":"2 技能调用接口"},{"id":"_3-技能流程管理","depth":2,"text":"3 技能流程管理","children":[{"id":"_31-技能树","depth":3,"text":"3.1 技能树"},{"id":"_32-执行节点的技能流程","depth":3,"text":"3.2 执行节点的技能流程"}]},{"id":"_4-技能目标查找","depth":2,"text":"4 技能目标查找"},{"id":"_5技能表现","depth":2,"text":"5技能表现"},{"id":"_6-弹道法术场和buff等技能创生体","depth":2,"text":"6 弹道、法术场和buff等技能创生体"},{"id":"_61-buff状态","depth":2,"text":"6.1 Buff状态","children":[{"id":"_62-法术场","depth":3,"text":"6.2 法术场"}]},{"id":"_0-技能同步的原则","depth":2,"text":"0 技能同步的原则"},{"id":"_1-技能执行流程的同步","depth":2,"text":"1 技能执行流程的同步","children":[{"id":"使用此同步流程的表现为","depth":3,"text":"使用此同步流程的表现为："}]},{"id":"_2-技能树的同步","depth":2,"text":"2 技能树的同步"},{"id":"_3-技能结算的同步","depth":2,"text":"3 技能结算的同步"},{"id":"_4-伤害属性的同步","depth":2,"text":"4 伤害、属性的同步"},{"id":"就skill和buff的边界问题","depth":2,"text":"就skill和buff的边界问题，"}]}},"_type":"markdown","_id":"content:unity:2020-02-15-skill-system.md","_source":"content","_file":"unity/2020-02-15-skill-system.md","_extension":"md","date":"2020-02-15"},{"_path":"/unity/2020-02-16-buff-system","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"游戏buff系统设计","description":"内部运算\n1、是否包含技能效果？（提高/降低 攻击 命中 闪避 移动速度 群体伤害 替换技能ID 等 ）\n2、是否包含阶段效果？（BUFF分为多个阶段，不同的阶段有不同的效果，比如影之哀伤）\n3、是否包含计时器？（持续时长计算、叠加时长计算 总之所有关于持续性时间的问题 都丢这里）\n4、是否包含计数器？（用来计算阶段、剩余生效次数、比如影之哀伤 LOL电刀）\n5、是否具备分类规则？（魔法效果 诅咒效果 中毒效果 用于进行归类 方便程序进行的 驱散筛选判断）\n6、是否可以被驱散？ （魔法效果只能用祛除魔法解除 中毒效果只能用解药祛除）\n7、是否具备优先级？（附加优先级，低等级BUFF会被高等级BUFF替换，低等级BUFF无法附加给高等级怪）\n8、是否保留母体信息？（比如传染性的DEBUFF，感染者传播一次，母体会获得额外巴拉巴拉。。。多个项）\n9、是否共享同步规则？（比如多个角色共享一个BUFF状态，一个人的BUFF被祛除则其他人也被祛除）\n10、以上功能可以进行再补充，没有需求则可以逐个剔除。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内部运算\n1、是否包含技能效果？（提高/降低 攻击 命中 闪避 移动速度 群体伤害 替换技能ID 等 ）\n2、是否包含阶段效果？（BUFF分为多个阶段，不同的阶段有不同的效果，比如影之哀伤）\n3、是否包含计时器？（持续时长计算、叠加时长计算 总之所有关于持续性时间的问题 都丢这里）\n4、是否包含计数器？（用来计算阶段、剩余生效次数、比如影之哀伤 LOL电刀）\n5、是否具备分类规则？（魔法效果 诅咒效果 中毒效果 用于进行归类 方便程序进行的 驱散筛选判断）\n6、是否可以被驱散？ （魔法效果只能用祛除魔法解除 中毒效果只能用解药祛除）\n7、是否具备优先级？（附加优先级，低等级BUFF会被高等级BUFF替换，低等级BUFF无法附加给高等级怪）\n8、是否保留母体信息？（比如传染性的DEBUFF，感染者传播一次，母体会获得额外巴拉巴拉。。。多个项）\n9、是否共享同步规则？（比如多个角色共享一个BUFF状态，一个人的BUFF被祛除则其他人也被祛除）\n10、以上功能可以进行再补充，没有需求则可以逐个剔除。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"外部表现\n1、是否显示BUFF图标？（传奇里道士的BUFF是不显示图标的）\n2、是否不同阶段表现不同的图标？\n3、是否显示计时器？\n4、是否显示计数器？\n5、是否显示BUFF文字说明？（对BUFF类型、效果的描述）\n6、是否改变角色外形？（DNF里的冰冻、WOW里的变形）\n7、以上表现功能可以进行再补充，同上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我想说的是，这是一套机制，并不是单独的一个系统，所谓机制就是一种从逻辑思想到代码实现的小窍门的组合，只有当你把它运用到一个实际项目中去了，它才能帮助你建立一个系统。我不敢说它是最好的，但这套东西帮我完成了一个又一个项目的制作，我觉得现在可以简单的拿出来和大家分享下思维。事实上这也并不是什么很玄乎的东西，我的Buff的机制更像是Flash的Dispatch机制。更简单的说，你可以把它理解为一种回调机制，在必要的时候进行逻辑回调。我想这一句话应该是可以概括整个机制的工作原理了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个简单的例子来说明，作为一个设计师，在设计系统的同时应当思考好这个游戏的系统中的各个回调点，而他们也正是Buff系统发挥能量的地方，Buff回调点有哪些（当然我可能会把它歪到WoW，毕竟这最早的设计灵感来自WOW）？我简单列一些："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1，BuffOccur"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我认为这是最核心的回调点之一，应该说你把这套机制运用在任何游戏中他都必须由这个时间点，就是当任何情况Buff被添加到一个角色身上的时候（可能来自技能、可能来自道具、可能来自GM命令，等等等等），往往他最杰出的作用就是改变角色的属性、或者是被控制状态。之所以说这是机制是思维方式，因为它并不关心你的游戏有哪些状态或者属性，但是这里有一点比较容易搞混的就是初级策划往往会认为昏迷就是一个Buff(debuff)，可是事实上昏迷是一种组合状态，他在LoL里面的形态是剥夺移动能力、剥夺攻击能力、剥夺商店使用能力的组合（我不知道是不是真的，但是我在做起凡三国争霸2的时候是这么做的，这套机制最早运用的游戏就是那个，虽然我离开起凡后这套系统的代码被删除了）。因此在BuffOccur这个回调点，有着很多的事情会需要做，那么同样的，BuffRemoved回调点也就有了同样的职责。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2，BuffOnTick"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就是通常我们最常见的，每3秒造成伤害、治疗；或者我们可以做每3秒制造一个AOE，甚至每3秒为自己添加一个护盾等等，他的核心在于没一定时间触发一次，但请你注意不是所有的游戏都适用这个回调点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3，BuffRemoved"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在移除Buff的时候，重新计算属性等肯定是需要在这个时间点工作一次的，那么事实上还有很多的效果也可以在这个时间点被调用，典型的是痛苦无常和生命绽放（都来自WOW），痛苦无常是当驱散的时候对驱散者造成伤害并且沉默，因此我们需要传入导致buff终结的人（可能是null）和BuffRemove的时候剩余时间，由此判断是否真的完成了，那么剩余时间越多造成伤害越高也就成了可能的设计；而生命绽放则更加简单，在Removed时候给持有者进行治疗就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4，BuffBeHurt"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在受到攻击的时候触发，大多盾类技能由此而生，这个回调点应当Return一个Int或者Float，用于传递给下一环，已获得新的伤害，而当所有的执行完毕之后，造成的最终伤害就会是这个数字，那么把受到的伤害变成治疗是多么简单的事情？可是否应该有，还得看游戏的Patterns。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5，BuffOnHit"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在攻击的时候产生，虽说字面上是OnHit，你仍然可以把isHit像isCrit一样传给回调函数，战士的压制（老版本）在攻击被闪躲时可以发动，更早的猎人在闪避攻击后可以提高招架？其实都是这个时间点来做的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"6，BuffBeforeKilled"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很多时候BuffBeHurt并不能完成一些设计，比如说必定能杀死目标的伤害被完全吸收（贼爷爷的假死），这时候我们要确定这个角色原本应该死了，因此就需要设定出这样一个回调点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"7，BuffAfterKilled"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当杀死一个角色的时候，恢复自身X%的HP，这时候你就需要这个回调点，精确的在角色死亡后发生。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"机制始终是机制，或者说是思维方式，他真正的运行还是取决于游戏本身，回调点我只是随便举个例子而已，事实上根据游戏不同，完全可以增加或者删除回调点，比如一个MT卡牌游戏他就完全不需要onTick这样的回调点，但他可以有BeforeMove（角色行动前）等回调点，这取决于游戏本身机制。同样的每一个视觉特效都可以在每一个回调点去播放，你可以设计好这样的规则不是吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来，我们就在这个机制的基础上分析一下LoL的一些技能，我印象最深的那些，我已经很久不玩LoL了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1，蛮王的6秒真男人，一个Buff，在BeforeKilled时候调用，Return1作为最后设定的HP，并被写在回调代码的最后。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2，盲僧、瑞文的连续技能，事实上这也是你肉眼看不到的Buff（机制正是如此奇妙，未必被直接运用，正如我所说，他是一种思路），当有Buff的时候技能A变成技能B，移除后恢复，OnSkillCast的回调点（往往技能施展中会需要回调点，因此回调点还是根据游戏具体分析出来的）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3，火男的昏迷，火男的法术会为目标添加一个Buff，而法术在OnHit的时候会检查如果存在这个Buff则执行XX效果导致昏迷，否则普通效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4，安妮的昏迷，你如果有仔细看了2并思考了，这不是问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5，大嘴的自爆，在角色死亡的时候产生免疫性Buff，Buff结束时产生AOE，如果你这么思考，这会简单很多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这套机制在实际工作中，我们需要如何去分工呢？事实上已经很清晰了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"策划：需要设计出所有的回调点，事实上策划如果完全不了解程序的效率等问题是无法设计好的，最好还能大概了解所谓回调机制，因为除了回调点意外，你还需要设计出回调时候传的参数，以及返回给程序的参数及其工作顺序，除此之外一些基础的表象也需要去制作，如buff的名称，那么在做表的时候会有2种风格，在起凡的时候我可以不用太关心，因为每个人都会用Lua写回调函数，但之后的项目中，我是用了我常推荐的Tag机制，比如策划填写一个Buff效果些daze_60之类的我就可以把它分析为60%几率昏迷目标等。在设计这些东西的时候为了更有效地避免夸夸其谈，策划对于实现的了解还是非常重要的，而事实上我们这里已经是策划动手写逻辑代码了，这问题就相对好办些。策划除此之外还应该归纳出特效播放点、数据同步时间点等等和游戏核心机制相结合的东西。这世界上也有很多好的创意，但你必需知道机制士兵不能帮你实现的，更重要的是你要知道自己想做什么和怎么去做，因此设计buff的时候切勿滥用机制，机制用的不好反而弄巧成拙，而合理的拆分Buff的效果也是一个策划的价值所在。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"程序：程序的工作则是优化好回调点和策划可能滥用到家的循环，这是非常头疼的事情，因此很可能需要更好的机制替他们实现一些该死的逻辑优化，可是这并不是最重要的，最主要的工作还是完成一些底层接口功能，比如在某个绑点上播放某个特效之类的，这些是策划都是即使会写逻辑代码也写不好的东西，也正是程序员强势所在（因此我并不认为游戏程序员非得精通游戏，但必须了解一二，才能大概思考一些优化、渲染的逻辑）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"美术：视觉特效肯定少不了你的，搞不好还得弄动作，音乐跑的了音效跑不了，做吧，策划会整理出大量的需求列表的，如果上面说做那就做了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在你了解了Buff的工作机制之后，你才有资格进一步的谈创意，不然都是胡扯蛋，你都不知道怎么去做，你怎么去创造呢？那么假如让我把吕布加入到LoL中，我会给他设计什么样的被动技能呢？就让我们一起YY下（确切的说知道实现方式的YY才是有价值的）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"被动：人中吕布，任何普通攻击（我想LoL的普通攻击应该也是有标记的，起凡当时是skillId==28近战、30远程，事实上我不太赞成这样的skillId特殊标记法）的时候会为吕布添加1层“人中吕布”（另外一个buff）\n“人中吕布”到15层、25层、35层、45层、50层时更换视觉特效(BuffOccur BuffRemoved)。人中吕的特性是15层开始普通攻击有几率造成双倍伤害，25层开始受到伤害有几率减少20%，35层开始释放技能获得导致目标昏迷2秒，45层开始释放技能恢复自身25%生命，50层时技能对20%生命以下目标一击必杀，死亡是损失一半层数(beKilled)。这么牛逼的效果？是啊，中国人当然应该牛逼了。慢来，才YY开始，这算设计好了？早呢，为了这些效果，你需要在“人中吕布”Occur Remove中去根据当前层数添加删除Buff："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人中吕布_双倍伤害，普通攻击OnHit投随机数决定是否伤害x2。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人中吕布_几率免伤，BeHurt时候投随机数决定是否降低一定的伤害。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人中吕布_强力攻击，Onhit判断不是普通攻击则给目标一个2秒的Buff1层。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"强力攻击_昏迷，Occur携带者昏迷属性为true，Remove就不需要设置false了，因为他可能还有别的buff让他昏迷，但是Remove和Occur的时候都要重新计算一次属性状态就对了。说到这里，这个Buff互相堆叠又是很讨厌的逻辑，2个SS可以给同一个目标释放腐蚀术，产生2个，但是自己却只能对1个目标上1个，等等等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人中吕布_技能恢复，OnCast的时候（事实上LoL应该只有OnHit，这也可以），判断不是普通攻击则回复生命。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人中吕布_斩杀，OnHit判断目标生命比，决定是否造成999999伤害。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实如你楼下一层说的，这个机制的最大优势在于，它可以实现很多难以预料的功能，如果策划足够给力的话。\n实际的经验是，一个项目中产生很多沟通问题的本质是，策划并不能归纳出自己想要什么，而程序员更不可能提早知道你想做什么，预判是一道鸿沟，无法跨越，因为我们都不是先知，而年轻的策划很多神奇的想法更是无法预判的，但如果放弃这些想法中的一些精化会非常可惜。因此在项目开发中尽可能去做一些能够更有“包容性”的设计，是非常重要的事情，这解决了后期的很多问题。\n你可以发现我提倡的很多机制或者想法都具有“包容性”或者说“预判性”，包括Tag机制本身，很多年轻的策划或者程序并不能理解为什么明明我们可以用id数字分段做的事情非要想的如此复杂，但事实是当你需要把你的分段规则详细的说给后来的人知道的时候，你甚至需要花费几周时间，还未必能说清楚，更糟糕的是，也许你自己都忘了当初的约定。\nBuff机制也是如此，它的优势在于程序员、包括策划自己并不需要一开始就知道我要具体做什么，但是我们可以先把框架搭起来或者说可以开始动手制作项目了，而后期灵感突发的时候，并不是非得“放到下一个项目”的。\n而技能机制，在我看来反而只是一个辅助的体系，因为它只是一套简单的流程，作为一个入行的新人都应该轻松的完成他的开发，但是很多不太好的做法却是把技能的效果复杂化了，以至于程序员被误导，后期很难对技能维护。因此技能的效果，事实上就是Hp_Dmg（这么多年了我都用这个函数来造成伤害，因为名字很有趣），CreateBuffObj，CreateAoEObj，就是这么简单，一个技能的效果可以同时调用多条这样的功能，但只限于这样的功能。至于花哨的东西，就让Buff系统去完成。\n因此这里还说了一个重点，对于策划来说，研发最大的技巧就是“拆”，如何把你的想法拆成最基础的元素，这样大家在实现的时候就不会有很多不必要的麻烦，在之后的debug中也会方便很多——比如我说的昏迷插法。一个优秀的程序员（至少我不是）他/她一定是把心思放在读书上，至少在学习计算机编程的时候他/她们非常棒，这也导致了他们不太可能像我们策划一样了解游戏，因此不应该把一些“难以理解”的东西拿来去塞给程序员做（事实上难以理解本身是因为它有太多的“专业名词”和超乎自然的地方，这也是游戏魅力所在），你也许没见过把“沉默”做成了“禁言”功能的程序员，他认为法师释放了一个沉默法术后，对方玩家就不能发送聊天内容了，因为被“沉默”了。\n降低研发成本，从设计师角度来说主要还是沟通成本，现在已经成为了很多公司必须面对的课题了，明明一个简单到10小时能完成的逻辑，在很多公司居然能花费好几个人用好几十天去做，并且没能完成（因为策划总是在添加和改变想法，而程序员却陪太子读书了）。\n“猴子”这个称呼并不适合一个200多斤的人"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-16-buff-system/lol.gif"},"children":[]},{"type":"text","value":"，龙与地下城——欧美人眼中最强的生物和它的巢穴，都是字母D开头中间用and连接，它骨子里是一套分析世界的数学模型，骰子实现了世界上很多所谓运气的东西；猴与花果山，它应该是中国人的DND，猴象征着欧美人眼中的中国人，也是孙悟空的表现，花果山则是孙悟空的住所，Monkey and Mountain，前后2个M，就是巧妙的地方，15年前我想做一套中国人的DnD，但至今没法实现，很多原因导致我们在娱乐方面缺少类似骰子这样的基础文化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/150812545","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/150812545"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-02-16-buff-system.md","_source":"content","_file":"unity/2020-02-16-buff-system.md","_extension":"md","date":"2020-02-16"},{"_path":"/unity/2020-02-17-character-states","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"角色状态设计","description":"https://www.cnblogs.com/Renyi-Fan/p/9569090.html","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/Renyi-Fan/p/9569090.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/Renyi-Fan/p/9569090.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.gameres.com/797311.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.gameres.com/797311.html"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-02-17-character-states/20161103213426625"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"public abstract class Attribute\n        {\n            public int Hp { get; set; }\n            public int Mp { get; set; }\n            public int HpTotal { get; set; }\n            public int MpTotal { get; set; }\n\n            private Attribute m_Parent;\n            private string m_Name;\n            public Attribute(int hp, int mp)\n            {\n                this.Hp = hp;\n                this.Mp = mp;\n\n            }\n\n            public Attribute(int hp, int mp, string name) : this(hp, mp)\n            {\n                this.m_Name = name;\n            }\n\n            public abstract void Calc();\n            public abstract int ChildCount();\n            protected void SetParent(Attribute child)\n            {\n                child.m_Parent = this;\n            }\n\n            public Attribute GetParent()\n            {\n                return this.m_Parent;\n            }\n\n            public void Show()\n            {\n                Calc();\n                Console.WriteLine(string.Format(\"{0} 属性为： HP {1} MP {2}\",this.m_Name, this.HpTotal, this.MpTotal));\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public abstract class Attribute\n        {\n            public int Hp { get; set; }\n            public int Mp { get; set; }\n            public int HpTotal { get; set; }\n            public int MpTotal { get; set; }\n\n            private Attribute m_Parent;\n            private string m_Name;\n            public Attribute(int hp, int mp)\n            {\n                this.Hp = hp;\n                this.Mp = mp;\n\n            }\n\n            public Attribute(int hp, int mp, string name) : this(hp, mp)\n            {\n                this.m_Name = name;\n            }\n\n            public abstract void Calc();\n            public abstract int ChildCount();\n            protected void SetParent(Attribute child)\n            {\n                child.m_Parent = this;\n            }\n\n            public Attribute GetParent()\n            {\n                return this.m_Parent;\n            }\n\n            public void Show()\n            {\n                Calc();\n                Console.WriteLine(string.Format(\"{0} 属性为： HP {1} MP {2}\",this.m_Name, this.HpTotal, this.MpTotal));\n            }\n        }\n"}]}]},{"type":"element","tag":"pre","props":{"code":"public class AttributeComponent:Attribute\n        {\n            private List<Attribute> m_AttributeList = new List<Attribute>();\n\n            public AttributeComponent(int hp, int mp) : base(hp, mp)\n            {\n            }\n\n            public AttributeComponent(int hp, int mp, string name) : base(hp, mp, name) { }\n\n            public override void Calc()\n            {\n                this.HpTotal = this.Hp;\n                this.MpTotal = this.Mp;\n\n                foreach (Attribute item in m_AttributeList)\n                {\n                    //递归计算属性和\n                    if (item.ChildCount() > 0)\n                        item.Calc();\n\n                    this.HpTotal += item.HpTotal;\n                    this.MpTotal += item.MpTotal;\n                }\n            }\n\n            public override int ChildCount()\n            {\n                return m_AttributeList.Count;\n            }\n\n            public void AddAttribute(Attribute attribute)\n            {\n                SetParent(attribute);\n                this.m_AttributeList.Add(attribute);\n            }\n\n            public void RemoveAttribute(Attribute attribute)\n            {\n                m_AttributeList.Remove(attribute);\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class AttributeComponent:Attribute\n        {\n            private List<Attribute> m_AttributeList = new List<Attribute>();\n\n            public AttributeComponent(int hp, int mp) : base(hp, mp)\n            {\n            }\n\n            public AttributeComponent(int hp, int mp, string name) : base(hp, mp, name) { }\n\n            public override void Calc()\n            {\n                this.HpTotal = this.Hp;\n                this.MpTotal = this.Mp;\n\n                foreach (Attribute item in m_AttributeList)\n                {\n                    //递归计算属性和\n                    if (item.ChildCount() > 0)\n                        item.Calc();\n\n                    this.HpTotal += item.HpTotal;\n                    this.MpTotal += item.MpTotal;\n                }\n            }\n\n            public override int ChildCount()\n            {\n                return m_AttributeList.Count;\n            }\n\n            public void AddAttribute(Attribute attribute)\n            {\n                SetParent(attribute);\n                this.m_AttributeList.Add(attribute);\n            }\n\n            public void RemoveAttribute(Attribute attribute)\n            {\n                m_AttributeList.Remove(attribute);\n            }\n        }\n"}]}]},{"type":"element","tag":"pre","props":{"code":"\npublic void TestMethod1()\n        {\n            AttributeComponent basic = new AttributeComponent(50, 100, \"Ali\");\n            AttributeComponent lvUp = new AttributeComponent(50, 100, \"升级增加\");\n            AttributeComponent weapon = new AttributeComponent(10, 20, \"无级弓\");\n            AttributeComponent weaponEnchanting = new AttributeComponent(5, 5, \"附魔增加\");\n\n            basic.Show();\n            Console.WriteLine(\"升级啦\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            lvUp.Show();\n            basic.AddAttribute(lvUp);\n            basic.Show();\n            Console.WriteLine();\n            Console.WriteLine(\"装备了武器\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            weapon.Show();\n            basic.AddAttribute(weapon);\n            basic.Show();\n            Console.WriteLine();\n            Console.WriteLine(\"武器附魔\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            weaponEnchanting.Show();\n            weapon.AddAttribute(weaponEnchanting);\n            weapon.Show();\n            basic.Show();\n            Console.WriteLine();\n            Console.WriteLine(\"卸载装备\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            basic.RemoveAttribute(weapon);\n            basic.Show();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic void TestMethod1()\n        {\n            AttributeComponent basic = new AttributeComponent(50, 100, \"Ali\");\n            AttributeComponent lvUp = new AttributeComponent(50, 100, \"升级增加\");\n            AttributeComponent weapon = new AttributeComponent(10, 20, \"无级弓\");\n            AttributeComponent weaponEnchanting = new AttributeComponent(5, 5, \"附魔增加\");\n\n            basic.Show();\n            Console.WriteLine(\"升级啦\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            lvUp.Show();\n            basic.AddAttribute(lvUp);\n            basic.Show();\n            Console.WriteLine();\n            Console.WriteLine(\"装备了武器\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            weapon.Show();\n            basic.AddAttribute(weapon);\n            basic.Show();\n            Console.WriteLine();\n            Console.WriteLine(\"武器附魔\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            weaponEnchanting.Show();\n            weapon.AddAttribute(weaponEnchanting);\n            weapon.Show();\n            basic.Show();\n            Console.WriteLine();\n            Console.WriteLine(\"卸载装备\");\n            Console.WriteLine(\"---------------------------------------------------\");\n            basic.RemoveAttribute(weapon);\n            basic.Show();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/alistair_chow/article/details/53029909","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/alistair_chow/article/details/53029909"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/alistair_chow/article/details/53026375","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/alistair_chow/article/details/53026375"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-02-17-character-states.md","_source":"content","_file":"unity/2020-02-17-character-states.md","_extension":"md","date":"2020-02-17"},{"_path":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"理解托管堆","description":"另一个Unity开发者面对的普遍问题是托管堆的意外扩展。在Unity中，托管堆的扩张比收缩更加容易。进一步说，Unity的垃圾回收策略倾向于碎片化内存，这可以防止收缩出来一个大的堆。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一个Unity开发者面对的普遍问题是托管堆的意外扩展。在Unity中，托管堆的扩张比收缩更加容易。进一步说，Unity的垃圾回收策略倾向于碎片化内存，这可以防止收缩出来一个大的堆。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"技术细节托管堆怎样运行以及为什么它会扩张"},"children":[{"type":"text","value":"技术细节：托管堆怎样运行以及为什么它会扩张"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    托管堆是内存中被项目脚本运行时（Mono或者IL2CPP）的内存管理器自动管理的部分。在托管代码中创造的所有对象必须被分配在托管堆上（请注意：严格的说，所有非空引用类型的对象和所有被装箱的值类型对象都必须被分配到托管堆上）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_0.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在上面的图表中，白色的方块表示分配到托管堆的内存量，它里面有颜色的方块表示托管堆内存空间中存储的数据值。当另外的值被需要时，将会从托管堆中分配更多空间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    垃圾收集器周期运行（请注意：具体时间取决于不同的平台）。会清扫堆上的所有对象，检查那些不再被引用的对象并标记。然后删除没有被引用的对象，释放内存。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    至关重要的是，Unity的垃圾收集是，采用"},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Boehm_garbage_collector","rel":["nofollow"]},"children":[{"type":"text","value":"Boehm GC算法"}]},{"type":"text","value":"，是非世代和非压缩的。非世代意味着当执行一次收集的时候，GC必须清扫全部的托管堆，并且性能会随着堆的扩张而降低。非压缩意味着内存中的对象不会重新移动位置来使对象间的空隙关闭。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_1.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    上面的图显示了一个内存片段的例子。当一个对象被释放时，其内存也会被清空。但是被释放的空间不会变成一个大的可用内存池的一部分。被释放对象两边的对象仍然被使用。由于这个原因，被释放的内存变成了其他内存段中间的空隙（这个空隙在上图中由红圈标明）。这个新释放的空间只能用于存储与它完全相同或者更小大小的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    当分配一个对象时，请记住在内存中对象必须总是占用一段连续的空间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    这导致了内存碎片的核心问题，虽然堆中的总可用空间是非常大的，但是可能一部分或者所有这些可用空间是被分配对象间的小空隙。在这种情况下，尽管可能会有足够的总空间来容纳一个确定大小的分配，但是托管堆找不到一块足够大的连续内存来适配这次分配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_2.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    然而，如果一个大的对象被分配，并且没有足够的连续空间来容纳这个对象，如同上图所示，那么Unity的内存管理器将执行两个操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    首先，如果垃圾收集器还没有运行，那么它就会运行。尝试释放足够的空间来填充内存分配的需求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    如果，GC运行完毕，仍然没有可以满足需求的连续内存空间，那么托管堆将会被扩大。托管堆扩大的具体大小由平台决定；然而，大多数Unity平台将托管堆扩大一倍。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"托管堆的关键问题"},"children":[{"type":"text","value":"托管堆的关键问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    托管堆的核心问题是其扩张是以两倍进行的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·当托管堆扩张时，Unity并不总是释放分配到托管堆的内存页，它采取一个优化策略，保持扩张的托管堆，即使托管堆大部分是空的。这用来避免当有更大的内存分配发生时需要重新扩大托管堆。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·在大多数平台上，Unity最终会将托管堆上那部分空的内存页释放回操作系统。这个发生的间隔时间是不能保证的，并且也不能被依靠。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·用于托管堆的地址空间（栈）不再会被返还给操作系统。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·对于32位程序来说，如果托管堆扩张收缩多次，这会导致地址空间（栈）耗尽。如果一个程序可用内存的地址空间（栈）被耗尽，操作系统将会终止这个程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·对于64位程序来说，地址空间（栈）足够大，这对于运行时间不超过人类平均寿命的程序来说基本不会发生。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"临时分配"},"children":[{"type":"text","value":"临时分配"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    许多Unity项目都发现每帧有几十或几百kb的临时数据分配到托管堆处理。这通常对项目性能是非常有害的。考虑下面的计算："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    如果一个程序每帧分配1kb的临时内存，运行在每秒60帧的情况下，那么它每秒就会分配60kb的内存。在一分钟之内，这在内存中增加了3.6mb的垃圾。每秒执行一次垃圾回收器会降低性能，但是尝试在低内存设备上运行时每分钟分配3.6mb内存是有问题的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    进一步说，考虑到加载操作。如果在一个繁重的资源加载过程中生成了大量的临时对象，并且这些对象被引用到该操作完成，那么垃圾回收器则不能释放这些临时对象并且托管堆需要扩张——即使托管堆中包含的许多这些对象马上就会被释放。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_3.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    保持对托管内存分配的追踪非常简单。在Unity的CPU Profiler中，概述写着“GC Alloc”那一列。这一行显示着在某一帧分配到托管堆的比特数。（请注意：这个数字与在制定帧分配的临时比特数不相同。分析器显示的事在特定帧被分配的比特数量，即使这些被分配内存的一些或全部在随后的帧中被复用。）将“Deep Profiling”选项打开，这就可以追踪这些内存分配是在哪些函数中发生的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    Unity Profiler不会追踪那些没有发生在主线程的内存分配。因此，“GC Alloc”列就不能用来测量在用户自己创建的线程中的托管内存分配。可以把其他线程中的代码切换到主线程中执行来进行调试，或使用BeginThreadProfiling这个API来在Profiler的TimeLine选项卡中来显示样本。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在目标设备上使用开发模式构建可以分析托管内存分配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    请注意：一些脚本函数在Editor中运行会导致内存分配，但是当项目构建后就不会再产生内存分配。GetComponent就是最普遍的例子，这个函数在Editor中运行时总是会产生内存分配，但是在构建好的项目中就不会。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    总体来说，我们强烈的建议所有开发者当项目在交互状态时最小化托管堆内存分配。如果内存分配发生在没有交互操作的时候，比如说场景加载时，问题较少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    Jetbrains Resharper这个Visual Studio插件可以帮助定位代码中的内存分配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    使用Unity的深度分析模式来定位托管内存分配的特定原因。在深度分析模式，所有的函数的调用都被独立记录，在函数调用树中提供一个清晰界面来显示托管内存分配是在哪里发生的。请注意，深度分析模式不止在编辑器中，也可以使用命令行参数-deepprofiling在安卓和桌面上使用。在分析过程中深度分析器按钮保持灰色。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"基础内存维护"},"children":[{"type":"text","value":"基础内存维护"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    有一些相对简单的技术来使托管堆内存分配降低。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"容器和数组重用"},"children":[{"type":"text","value":"容器和数组重用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    当使用C#的容器类或者数组时，如果可能考虑重用或者缓存分配的容器或者数组。容器类暴露了一个Clear函数，当清除容器的值时不会释放分配给容器的内存。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"void Update() {"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"List nearestNeighbors = new List();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"findDistancesToNearestNeighbors(nearestNeighbors);"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"nearestNeighbors.Sort();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// … use the sorted list somehow …"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    当给一个复杂计算分配临时的“帮助性”容器时尤其好用。下面的代码是一个非常简单的例子："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在这个例子中，nearestNeighbors列表每帧被分配一次，用于存储一些数据点。可以把这个列表非常简单的从这个函数中提出来放入函数所在的类中，这避免了每帧分配一个新的列表："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"List m_NearestNeighbors = new List();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"void Update() {"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"m_NearestNeighbors.Clear();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"findDistancesToNearestNeighbors(NearestNeighbors);"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"m_NearestNeighbors.Sort();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// … use the sorted list somehow …"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在这个版本中，每帧列表的内存会被保持和重用。只有当列表需要被扩大时内存才会被分配。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"闭包和匿名函数"},"children":[{"type":"text","value":"闭包和匿名函数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    当使用闭包和匿名函数时，有两点需要考虑。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    首先，所有函数引用在C#中都是引用类型，因此分配到了托管堆。临时内存分配可以通过作为一个参数传递函数引用很简单的创建。这个内存分配不管是使用匿名函数或者是预先定义好的函数来传递都会发生。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    其次，转换一个匿名函数为闭包显著增加了需要传递闭包到函数接收的内存量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    考虑下面的代码："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"List listOfNumbers = createListOfRandomNumbers();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"listOfNumbers.Sort( (x, y) =>"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(int)x.CompareTo((int)(y/2))"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":");"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    这段代码使用了一个简单的匿名函数来控制第一行创建的列表成员的排序方式。可是，如果一个程序员想要重用这段代码，可以考虑使用一个局部变量来代替常量2，像下面这样："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"List listOfNumbers = createListOfRandomNumbers();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"int desiredDivisor = getDesiredDivisor();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"listOfNumbers.Sort( (x, y) =>"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(int)x.CompareTo((int)(y/desiredDivisor))"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":");"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    现在匿名函数需要在此函数作用范围之外获取一个变量的状态，所以变成了一个闭包。desiredDivisor变量必须通过某种方式传进闭包中，以便被闭包中的实际代码所使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    为了实现这个需求，C#生成了一个匿名类，用来保存闭包需要的超过作用范围的对象。当闭包被传入Sort函数时，将生成一个此类的副本，并且这个类的副本通过整数desiredDivisor的值来初始化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    由于执行闭包需要实例化一个生成它的类的拷贝，在C#中所有类都是引用类型，那么执行一个闭包需要在托管堆中分配一个对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    总体来说，如果可能最好避免在C#中使用闭包。在性能敏感的代码中应该尽量最小化使用匿名函数和函数引用，尤其是在基于每帧执行的代码中。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"il2cpp下的匿名函数"},"children":[{"type":"text","value":"IL2CPP下的匿名函数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    目前，检查通过IL2CPP生成的代码，显示简单的声明以及指定一个System.Function类型的变量会分配一个新的对象。无论这个变量是显式（在一个函数或类中声明）或是隐式（作为一个函数的参数声明）都会这样。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    所以，在IL2CPP脚本后端下所有使用匿名函数的情况都会分配托管堆内存。Mono脚本后端不是这种情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    进一步说，在IL2CPP中，由于函数参数声明方式的不同，会有显著不同的托管堆内存分配量级的不同。正如预期的那样，闭包在每次调用中分配最多的内存。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    不直观的说，在IL2CPP脚本后端下，当作为一个参数传递预定义的函数时，分配近似于闭包的内存量。匿名函数在托管堆上生成最少量的暂时垃圾，这是通过一个或多个量级的指令实现的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    所以，如果一个项目想要在IL2CPP脚本后端上发布，有三的关键点需要注意："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·采取不需要传递函数作为参数的的编码风格"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·当这种情况不可避免时，采用匿名函数而不是预定义函数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·避免闭包，不管用什么脚本后端"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"装箱"},"children":[{"type":"text","value":"装箱"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    装箱是Unity项目中最普遍的意识不到的临时内存分配的原。它发生在当一个值类型被当做引用类型使用时；这通常发生在传递原始的值类型变量（比如int和float）到对象类型的函数中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在这个极度简单的例子中，为了要传递到object.Equals函数中，整数x被装箱，由于object的Equals函数要求传入的是一个object作为参数。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"int x = 1;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"object y = new object();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"y.Equals(x);"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    C#的IDE和编译器通常不会对装箱发出警告，即使其导致了无意识的内存分配。这是因为C#语言是在小的临时内存分配会被世代的垃圾回收器和分配大小敏感的内存池有效率处理的假设下开发的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    由于Unity的内存分配器使用不区分内存分配大小的内存池，并且Unity的垃圾回收器也不是世代的，因此其不能有效率的清除由装箱带来的小的，频率的临时内存分配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在Unity运行时使用C#编码时，应该尽量避免装箱。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"识别装箱"},"children":[{"type":"text","value":"识别装箱"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    基于正在使用的脚本后端，装箱在CPU跟踪数据中显示为一些函数的调用。它们通常采用下面的这些形式之一，是一些其他类或者结构体的名字，...是一些参数的数量："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·::Box(…)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·Box(…)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    ·_Box(…)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    它可以通过搜索反编译器或者IL查看器的输出来定位，例如ReSharper中内置的IL查看器或者dotPeek反编译器，IL指令是“box”。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"字典和枚举"},"children":[{"type":"text","value":"字典和枚举"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    一个普遍的造成装箱的问题是使用枚举类型来作为字典的键。声明一个枚举创建了一个新的值类型，在后台被作为像一个整数来对待，但是在编译时强制执行类型安全原则。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    默认情况下，调用Dictionary.add(key, value)的结果是调用Object.getHashCode(Object)。这个函数用于为字典的键获得合适的散列码，并且用于所有接受key的函数：Dictionary.tryGetValue, Dictionary.remove等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    Object.getHashCode函数是一个引用类型，但是枚举值始终是一个值类型。因此，对于枚举作为键的字典来说，每次函数调用都会至少一次对键进行装箱。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    下面的代码片段举出了一个简单的例子展示了装箱的问题："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"enum MyEnum { a, b, c };"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"var myDictionary = new Dictionary<MyEnum, object>();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"myDictionary.Add(MyEnum.a, new object());"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    要解决这个问题，有必要写一个自定义的类实现IEqualityComparer接口，并且传递这个类的实例到字典的比较器中（请注意：这个对象通常是无状态的，所里可以被不同的字典重用以节省内存）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    下面的是一个对上面代片段实现IEqualityComparer的简单例子。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class MyEnumComparer : IEqualityComparer {"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public bool Equals(MyEnum x, MyEnum y) {"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    return x == y;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public int GetHashCode(MyEnum x) {"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    return (int)x;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    可以将上面类的实例传递给字典的构造函数。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"foreach循环"},"children":[{"type":"text","value":"Foreach循环"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在Unity版本的Mono的C#编译器中，使用foreach循环会在每次循环结束时强制Unity去装箱一个值（请注意：在每次循环整个结束的时候这个值会被装箱一次。在这个循环中每次迭代不会装箱，所以不论循环两次还是两百次内存使用都是相同的）。这是因为通过Unity的C#编译器生成的IL构造了一个通用的值类型枚举器以迭代值类型的容器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    这个枚举器实现的IDisposable接口，其肯定会在循环终止时被调用。然而，在值类型对象（比如结构体和枚举器）上调用接口函数需要把它们装箱。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    检查下面非常简单的代码例子："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"int accum = 0;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"foreach(int x in myList) {"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"accum += x;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    上面的代码，当通过Unity的C#编译器运行时，产生下面的中间语言："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".method private hidebysig instance void"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ILForeach() cil managed"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".maxstack 8"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".locals init ("}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[0] int32 num,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[1] int32 current,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[2] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator V_2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":")"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// [67 5 - 67 16]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0000: ldc.i4.0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0001: stloc.0   // num"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// [68 5 - 68 74]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0002: ldarg.0   // this"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0003: ldfld    class [mscorlib]System.Collections.Generic.List`1 test::myList"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0008: callvirt   instance valuetype [mscorlib]System.Collections.Generic.List"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"1/Enumerator<!0/*int32*/> class [mscorlib]System.Collections.Generic.List"}]},{"type":"text","value":"1::GetEnumerator()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_000d: stloc.2   // V_2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".try"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_000e: br      IL_001f"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// [72 9 - 72 41]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0013: ldloca.s   V_2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0015: call     instance !0/"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"int32"}]},{"type":"text","value":"/ valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator::get_Current()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_001a: stloc.1   // current"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// [73 9 - 73 23]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_001b: ldloc.0   // num"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_001c: ldloc.1   // current"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_001d: add"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_001e: stloc.0   // num"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// [70 7 - 70 36]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_001f: ldloca.s   V_2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0021: call     instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator::MoveNext()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0026: brtrue    IL_0013"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_002b: leave    IL_003c"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"} // end of .try"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"finally"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0030: ldloc.2   // V_2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0031: box     valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_0036: callvirt   instance void [mscorlib]System.IDisposable::Dispose()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_003b: endfinally"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"} // end of finally"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IL_003c: ret"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"} // end of method test::ILForeach"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"} // end of class test"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    最有关系的代码是靠近最后的__finally { … }__语句块。callvirt指令在执行这个函数前在内存中发现IDisposable.Dispose方法的定位，并且要求这个枚举器被装箱。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    总体来说，在Unity中应该避免使用foreach循环。不全是因为装箱，还有是通过枚举器实现的容器迭代的函数调用消耗比常规的for或者while循环的迭代要慢的多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    请注意在Unity5.5中C#编译器有了重大升级，增强了Unity生成IL的能力。特别是，装箱操作已经从foreach循环中消除。然而，由于函数调用的开销，与基于数组的等价代码相比CPU性能差距依旧存在。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"有数组值的unity-api译者已查在unity官方文档中会明确表明这些api有临时内存分配"},"children":[{"type":"text","value":"有数组值的Unity API("},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"译者已查，在Unity官方文档中，会明确表明这些API有临时内存分配"}]},{"type":"text","value":")"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    一个更有害且难于发现的是由于重复使用Unity返回数组的API造成的虚拟的数组内存分配。所有返回数组的Unity的API都会在每次它们被访问时返回一个该数组新的拷贝。在没有必要的情况下经常访问有数组值的Unity的API效果非常不理想。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    举个例子，下面的代码在vertices数组的每次迭代中虚拟的创造了四份拷贝。内存分配在每次.vertices属性被访问时发生。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"for(int i = 0; i < mesh.vertices.Length; i++)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"float x, y, z;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"x = mesh.vertices[i].x;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"y = mesh.vertices[i].y;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"z = mesh.vertices[i].z;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// ..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DoSomething(x, y, z);"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    这可以通过普通的重构来使其只有一次数组内存分配，不论循环迭代多少次。这是通过在进入循环前存储vertices数组来实现的。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"var vertices = mesh.vertices;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"for(int i = 0; i < vertices.Length; i++)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"float x, y, z;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"x = vertices[i].x;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"y = vertices[i].y;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"z = vertices[i].z;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// ..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DoSomething(x, y, z);"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    虽然CPU的消耗在访问一个属性一次时并不是非常高，在持续的循环中重复的访问它们会导致性能热点。进一步来讲，没必要的重复访问会导致托管堆的扩张。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    这个问题再移动设备上非常普遍，因为Input.touches这个API的行为与上述类似。这在包含下面的类似代码的项目中也非常普遍，内存分配发生在每次访问.touches属性时。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"for ( int i = 0; i < Input.touches.Length; i++ )"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Touch touch = Input.touches[i];"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// …"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    然而，现在有很多Unity的API有不会造成内存分配的新版本。当使用这些时，应该是更有利的。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"int touchCount = Input.touchCount;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"for ( int i = 0; i < touchCount; i++ )"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Touch touch = Input.GetTouch(i);"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// …"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    转换上面的例子到Touch API 无内存分配的版本是非常简单的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    请注意：这个属性的访问(Input.touchCount)仍旧要放在循环条件的外面，这是为了节省CPU在执行属性get方法时的消耗。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h4","props":{"id":"空数组重用"},"children":[{"type":"text","value":"空数组重用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    一些团队在一个数组返回值的函数需要返回一个空值时，倾向于用返回一个空数组来代替null。这种编码模式在许多托管语言中非常常见，尤其是C#和Java。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    总体来说，当一个函数返回一个长度为0的数组时，返回一个预先分配好的长度为0的数组的单例实例比重复创造空数组被认为更有效率。（请注意：当然，一个例外情况要考虑那就是当返回的数组需要改变长度时）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"技术细节托管堆怎样运行以及为什么它会扩张","depth":2,"text":"技术细节：托管堆怎样运行以及为什么它会扩张"},{"id":"托管堆的关键问题","depth":2,"text":"托管堆的关键问题"},{"id":"临时分配","depth":2,"text":"临时分配"},{"id":"基础内存维护","depth":2,"text":"基础内存维护"},{"id":"装箱","depth":2,"text":"装箱"}]}},"_type":"markdown","_id":"content:unity:2020-02-18-BestPracticeUnderstandingPerformanceInUnity.md","_source":"content","_file":"unity/2020-02-18-BestPracticeUnderstandingPerformanceInUnity.md","_extension":"md","date":"2020-02-18"},{"_path":"/unity/2020-02-19-understandingautomaticmemorymanagement","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"理解自动内存管理","description":"当创建对象、字符串或数组时，存储它所需的内存将从称为堆的中央池中分配。当项目不再使用时，它曾经占用的内存可以被回收并用于别的东西。在过去，通常由程序员通过适当的函数调用明确地分配和释放这些堆内存块。如今，像Unity的Mono引擎这样的运行时系统会自动为您管理内存。自动内存管理需要比显式分配/释放更少的编码工作，并大大降低内存泄漏（内存被分配但从未随后释放的情况）的可能性。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当创建对象、字符串或数组时，存储它所需的内存将从称为堆的中央池中分配。当项目不再使用时，它曾经占用的内存可以被回收并用于别的东西。在过去，通常由程序员通过适当的函数调用明确地分配和释放这些堆内存块。如今，像Unity的Mono引擎这样的运行时系统会自动为您管理内存。自动内存管理需要比显式分配/释放更少的编码工作，并大大降低内存泄漏（内存被分配但从未随后释放的情况）的可能性。"}]},{"type":"element","tag":"h2","props":{"id":"值类型和引用类型"},"children":[{"type":"text","value":"值类型和引用类型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当调用一个函数时，它的参数值将被复制到一个保留特定调用的内存区域。只占用几个字节的数据类型可以非常快速方便地复制。然而，对象、字符串和数组要大得多，如果这些类型的数据被定期复制，那将是非常低效的。幸运的是，这是不必要的；大项目的实际存储空间是从堆中分配的，一个小的“指针”值用来记住它的位置。从那时起，只有指针在参数传递过程中需要被复制。只要运行时系统能够定位指针标识的项，就可以经常使用数据的一个副本。\n在参数传递期间直接存储和复制的类型称为值类型。这些包括整数，浮点数，布尔和Unity的结构类型（例如Color和Vector3）。分配在堆上然后通过指针访问的类型称为引用类型，因为存储在变量中的值仅仅是“引用”到真实数据。引用类型的示例包括对象，字符串和数组。"}]},{"type":"element","tag":"h2","props":{"id":"内存分配和垃圾收集"},"children":[{"type":"text","value":"内存分配和垃圾收集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内存管理器跟踪它知道未被使用的堆中的区域。当请求一个新的内存块时（例如当一个对象被实例化时），管理器选择一个未使用的区域，从中分配该块，然后从已知的未使用的空间中移除分配的内存。后续请求以相同的方式处理，直到没有足够大的空闲区域分配所需的块大小。在这一点上，从堆中分配的所有内存仍然在使用中是非常不可能的。只要还存在可以找到它的引用变量，就只能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则它占用的内存可以安全地重新分配。\n为了确定哪些堆块不再被使用，内存管理器会搜索所有当前活动的引用变量，并将它们所指的块标记为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"live"}]},{"type":"text","value":"。在搜索结束时，内存管理器认为这些"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"live"}]},{"type":"text","value":"块之间的任何空间都是空的，并且可用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程被称为垃圾回收（或简称GC）。"}]},{"type":"element","tag":"h2","props":{"id":"优化"},"children":[{"type":"text","value":"优化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"垃圾收集对程序员来说是自动的、不可见的，但是收集过程实际上需要大量的CPU时间。如果正确使用，自动内存管理通常会等于或击败手动分配的整体性能。但是，对于程序员来说，重要的是要避免那些比实际需要触发更多次收集器和在执行中引入暂停的错误。有一些臭名昭著的算法，可能是GC噩梦，尽管他们乍一看是无辜的。重复字符串连接是一个典型的例子："}]},{"type":"element","tag":"pre","props":{"code":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void ConcatExample(int[] intArray) {\n        string line = intArray[0].ToString();\n        \n        for (i = 1; i < intArray.Length; i++) {\n            line += \", \" + intArray[i].ToString();\n        }\n        \n        return line;\n    }\n}\n\n//JS script example\nfunction ConcatExample(intArray: int[]) {\n    var line = intArray[0].ToString();\n    \n    for (i = 1; i < intArray.Length; i++) {\n        line += \", \" + intArray[i].ToString();\n    }\n    \n    return line;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void ConcatExample(int[] intArray) {\n        string line = intArray[0].ToString();\n        \n        for (i = 1; i < intArray.Length; i++) {\n            line += \", \" + intArray[i].ToString();\n        }\n        \n        return line;\n    }\n}\n\n//JS script example\nfunction ConcatExample(intArray: int[]) {\n    var line = intArray[0].ToString();\n    \n    for (i = 1; i < intArray.Length; i++) {\n        line += \", \" + intArray[i].ToString();\n    }\n    \n    return line;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里的关键细节是，新的部分不会被一个接一个地添加到字符串中。实际情况是，每次循环"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"line"}]},{"type":"text","value":"变量的前一个内容都会变死——一个完整的新字符串被分配到包含原来的部分，再在最后加上新的部分。由于字符串随着"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"i"}]},{"type":"text","value":"值的增加而变得更长，所以所消耗的堆空间数量也增加了，因此每次调用这个函数时都很容易消耗数百字节的空闲堆空间。如果你需要连接多个字符串，那么一个更好的选择是Mono库的"},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-gb/library/system.text.stringbuilder.aspx","rel":["nofollow"]},"children":[{"type":"text","value":"System.Text.StringBuilder"}]},{"type":"text","value":"类。然而，即使反复连接也不会引起太多麻烦，除非它被频繁调用，而在Unity中通常意味着帧更新。就像是："}]},{"type":"element","tag":"pre","props":{"code":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    public GUIText scoreBoard;\n    public int score;\n    \n    void Update() {\n        string scoreText = \"Score: \" + score.ToString();\n        scoreBoard.text = scoreText;\n    }\n}\n\n\n//JS script example\nvar scoreBoard: GUIText;\nvar score: int;\n\nfunction Update() {\n    var scoreText: String = \"Score: \" + score.ToString();\n    scoreBoard.text = scoreText;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    public GUIText scoreBoard;\n    public int score;\n    \n    void Update() {\n        string scoreText = \"Score: \" + score.ToString();\n        scoreBoard.text = scoreText;\n    }\n}\n\n\n//JS script example\nvar scoreBoard: GUIText;\nvar score: int;\n\nfunction Update() {\n    var scoreText: String = \"Score: \" + score.ToString();\n    scoreBoard.text = scoreText;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"...每次调用Update将分配新字符串，并不断生成的新垃圾。大多数情况下，只有当分数变化时才更新文本："}]},{"type":"element","tag":"pre","props":{"code":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    public GUIText scoreBoard;\n    public string scoreText;\n    public int score;\n    public int oldScore;\n    \n    void Update() {\n        if (score != oldScore) {\n            scoreText = \"Score: \" + score.ToString();\n            scoreBoard.text = scoreText;\n            oldScore = score;\n        }\n    }\n}\n\n\n//JS script example\nvar scoreBoard: GUIText;\nvar scoreText: String;\nvar score: int;\nvar oldScore: int;\n\nfunction Update() {\n    if (score != oldScore) {\n        scoreText = \"Score: \" + score.ToString();\n        scoreBoard.text = scoreText;\n        oldScore = score;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    public GUIText scoreBoard;\n    public string scoreText;\n    public int score;\n    public int oldScore;\n    \n    void Update() {\n        if (score != oldScore) {\n            scoreText = \"Score: \" + score.ToString();\n            scoreBoard.text = scoreText;\n            oldScore = score;\n        }\n    }\n}\n\n\n//JS script example\nvar scoreBoard: GUIText;\nvar scoreText: String;\nvar score: int;\nvar oldScore: int;\n\nfunction Update() {\n    if (score != oldScore) {\n        scoreText = \"Score: \" + score.ToString();\n        scoreBoard.text = scoreText;\n        oldScore = score;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当函数返回数组值时，会发生另一个潜在的问题："}]},{"type":"element","tag":"pre","props":{"code":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    float[] RandomList(int numElements) {\n        var result = new float[numElements];\n        \n        for (int i = 0; i < numElements; i++) {\n            result[i] = Random.value;\n        }\n        \n        return result;\n    }\n}\n\n\n//JS script example\nfunction RandomList(numElements: int) {\n    var result = new float[numElements];\n    \n    for (i = 0; i < numElements; i++) {\n        result[i] = Random.value;\n    }\n    \n    return result;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    float[] RandomList(int numElements) {\n        var result = new float[numElements];\n        \n        for (int i = 0; i < numElements; i++) {\n            result[i] = Random.value;\n        }\n        \n        return result;\n    }\n}\n\n\n//JS script example\nfunction RandomList(numElements: int) {\n    var result = new float[numElements];\n    \n    for (i = 0; i < numElements; i++) {\n        result[i] = Random.value;\n    }\n    \n    return result;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当创建一个充满值的新数组时，这种函数非常优雅和方便。但是，如果反复调用，那么每次都会分配新的内存。由于数组可能非常大，可用空间可能会迅速消耗，从而导致垃圾收集频繁。避免这个问题的一个方法是利用数组是引用类型的事实。作为参数传递给函数的数组可以在该函数内修改，结果将在函数返回后保留。\n像上面这样的功能通常可以被替换成："}]},{"type":"element","tag":"pre","props":{"code":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void RandomList(float[] arrayToFill) {\n        for (int i = 0; i < arrayToFill.Length; i++) {\n            arrayToFill[i] = Random.value;\n        }\n    }\n}\n\n\n//JS script example\nfunction RandomList(arrayToFill: float[]) {\n    for (i = 0; i < arrayToFill.Length; i++) {\n        arrayToFill[i] = Random.value;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void RandomList(float[] arrayToFill) {\n        for (int i = 0; i < arrayToFill.Length; i++) {\n            arrayToFill[i] = Random.value;\n        }\n    }\n}\n\n\n//JS script example\nfunction RandomList(arrayToFill: float[]) {\n    for (i = 0; i < arrayToFill.Length; i++) {\n        arrayToFill[i] = Random.value;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这只是用新值替换数组的现有内容。虽然这需要在调用代码中完成数组的初始分配（这似乎有些不雅），但是在调用该函数时不会产生任何新的垃圾。"}]},{"type":"element","tag":"h2","props":{"id":"主动请求垃圾收集"},"children":[{"type":"text","value":"主动请求垃圾收集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如上所述，最好尽量避免分配。然而，鉴于它们不能被完全消除，您可以使用两种主要策略来最大限度地减少其入侵游戏："}]},{"type":"element","tag":"h3","props":{"id":"小堆垃圾收集快速可频繁收集"},"children":[{"type":"text","value":"小堆垃圾收集快速可频繁收集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个策略通常最适合长期游戏的游戏，其中平滑的帧速率是主要的关注点。这样的游戏通常会频繁地分配小块，但这些块将仅在短时间内使用。在iOS上使用此策略时，典型的堆大小约为200KB，iPhone 3G上的垃圾收集大约需要5ms。如果堆增加到1MB，则收集大约需要7ms。因此，有时候可以以规则的帧间隔请求垃圾回收。这通常会使垃圾收集发生的次数比严格的需要的更多，但是它们将被快速处理，对游戏的影响最小："}]},{"type":"element","tag":"pre","props":{"code":"if (Time.frameCount % 30 == 0)\n{\n   System.GC.Collect();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (Time.frameCount % 30 == 0)\n{\n   System.GC.Collect();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是，您应该谨慎使用此技术，并检查profiler统计信息，以确保它真正减少了游戏的收集时间。"}]},{"type":"element","tag":"h3","props":{"id":"大堆垃圾收集缓慢且不可频繁收集"},"children":[{"type":"text","value":"大堆垃圾收集缓慢且不可频繁收集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个策略对于分配（和因此收集）相对不频繁并可以在游戏暂停期间处理的游戏最适用。对于堆来说，尽可能大，而不是因为系统内存太少而导致操作系统杀死你的应用程序。但是，如果可能，Mono运行时会自动避免扩展堆。您可以通过在启动期间预先分配一些占位符空间来手动扩展堆（即，您实例化一个纯粹用于对内存管理器产生影响的“无用”对象）："}]},{"type":"element","tag":"pre","props":{"code":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void Start() {\n        var tmp = new System.Object[1024];\n        \n        // make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks\n        for (int i = 0; i < 1024; i++)\n            tmp[i] = new byte[1024];\n        \n        // release reference\n        tmp = null;\n    }\n}\n\n\n//JS script example\nfunction Start() {\n    var tmp = new System.Object[1024];\n\n    // make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks\n        for (var i : int = 0; i < 1024; i++)\n        tmp[i] = new byte[1024];\n\n    // release reference\n        tmp = null;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//C# script example\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleScript : MonoBehaviour {\n    void Start() {\n        var tmp = new System.Object[1024];\n        \n        // make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks\n        for (int i = 0; i < 1024; i++)\n            tmp[i] = new byte[1024];\n        \n        // release reference\n        tmp = null;\n    }\n}\n\n\n//JS script example\nfunction Start() {\n    var tmp = new System.Object[1024];\n\n    // make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks\n        for (var i : int = 0; i < 1024; i++)\n        tmp[i] = new byte[1024];\n\n    // release reference\n        tmp = null;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个足够大的堆不应该在游戏中的暂停期间完全被填满，这样可以容纳一次收集。当发生这样的暂停时，您可以显式地请求垃圾收集："}]},{"type":"element","tag":"pre","props":{"code":"System.GC.Collect();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"System.GC.Collect();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样，在使用此策略时应该小心，并注意Profiler统计数据，而不是仅仅假定它具有所期望的效果。"}]},{"type":"element","tag":"h2","props":{"id":"可重复使用的对象池"},"children":[{"type":"text","value":"可重复使用的对象池"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很多情况下，只要减少创建和销毁对象的数量，就可以避免生成垃圾。游戏中存在着某些类型的物体，如抛射体，尽管一次只会有少量的物体在游戏中，但它们可能会被反复地遇到。在这种情况下，常常可以重用对象，而不是破坏旧对象，并用新的对象替换它们。"}]},{"type":"element","tag":"h2","props":{"id":"更多信息"},"children":[{"type":"text","value":"更多信息"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内存管理是一个微妙而复杂的课题，它已经投入了大量的学术研究。如果您有兴趣了解更多信息，那么"},{"type":"element","tag":"a","props":{"href":"http://www.memorymanagement.org/","rel":["nofollow"]},"children":[{"type":"text","value":"memorymanagement.org"}]},{"type":"text","value":"是一个很好的资源，列出了许多出版物和在线文章。有关对象池的更多信息可以在"},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Object_pool_pattern","rel":["nofollow"]},"children":[{"type":"text","value":"维基百科页面"}]},{"type":"text","value":"和"},{"type":"element","tag":"a","props":{"href":"https://sourcemaking.com/design_patterns/object_pool","rel":["nofollow"]},"children":[{"type":"text","value":"Sourcemaking.com"}]},{"type":"text","value":"上找到。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原文链接："},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/UnderstandingAutomaticMemoryManagement.html","rel":["nofollow"]},"children":[{"type":"text","value":"Understanding Automatic Memory Management"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"值类型和引用类型","depth":2,"text":"值类型和引用类型"},{"id":"内存分配和垃圾收集","depth":2,"text":"内存分配和垃圾收集"},{"id":"优化","depth":2,"text":"优化"},{"id":"主动请求垃圾收集","depth":2,"text":"主动请求垃圾收集","children":[{"id":"小堆垃圾收集快速可频繁收集","depth":3,"text":"小堆垃圾收集快速可频繁收集"},{"id":"大堆垃圾收集缓慢且不可频繁收集","depth":3,"text":"大堆垃圾收集缓慢且不可频繁收集"}]},{"id":"可重复使用的对象池","depth":2,"text":"可重复使用的对象池"},{"id":"更多信息","depth":2,"text":"更多信息"}]}},"_type":"markdown","_id":"content:unity:2020-02-19-UnderstandingAutomaticMemoryManagement.md","_source":"content","_file":"unity/2020-02-19-UnderstandingAutomaticMemoryManagement.md","_extension":"md","date":"2020-02-19"},{"_path":"/unity/2020-02-20-shader-lost","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity 移动平台打包丢失shader的问题","description":"自己写了个shader，并且是从代码里面来进行加载，编辑器中并没有引用。在编辑器中运行项目没有问题，但是当我发布到iso和android平台之后发现游戏中并不能找到我自己的shader，猜想是unity在打包过程中进行了一些优化，没有用到的shader不会被打到游戏包内。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"自己写了个shader，并且是从代码里面来进行加载，编辑器中并没有引用。在编辑器中运行项目没有问题，但是当我发布到iso和android平台之后发现游戏中并不能找到我自己的shader，猜想是unity在打包过程中进行了一些优化，没有用到的shader不会被打到游戏包内。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我找到了2个解决办法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.随意创建一个物体并添加使用了此shader的材质。并不推荐此方法，正确的方法应该是第二种。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.在GraphicsSettings中添加上此shader："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选择Edit->ProjectSettings->Graphics （不同的unity版本可能有所不同，我的版本是5.6）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将shader拖入到Always Included Shaders数组中："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-20-shader-lost/20180309110801448.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-02-20-shader-lost/20180309110915442.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样我们重新打包之后，就可以正常找到shader了。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-02-20-shader-lost.md","_source":"content","_file":"unity/2020-02-20-shader-lost.md","_extension":"md","date":"2020-02-20"},{"_path":"/unity/2020-03-01-unity-debug","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity的调试相关","description":"s怎么启动调试都无法关联到unity，后来发现自己应该是不小心把attach editor勾选掉了，","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"vs2019-调试unity失效"},"children":[{"type":"text","value":"vs2019 调试unity失效"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"s怎么启动调试都无法关联到unity，后来发现自己应该是不小心把attach editor勾选掉了，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-03-01-unity-debug/v2-8a3a1f8d3c6ed7317f18e2ac89620a38_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意这里要重启unity才会生效。勾选上之后就可以调试了。"}]},{"type":"element","tag":"h1","props":{"id":"unity3d-编辑器调试无响应问题"},"children":[{"type":"text","value":"Unity3D 编辑器调试无响应问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 VS 在 Unity 编辑器中调试代码，点击 VS 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"附加到 Unity"}]},{"type":"text","value":"，Unity 编辑器按下 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Play"}]},{"type":"text","value":" 之后，就会一直等待并且无其他响应，只能结束 Unity 进程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-03-01-unity-debug/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%ADUnity%E6%97%A0%E5%93%8D%E5%BA%94.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"原因分析"},"children":[{"type":"text","value":"原因分析"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"经过分析与测试，发现去掉代码中一个单例类的析构方法中的断点即可调试了，具体原因未知。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再测试了一下，在那个单例类的构造、析构方法中分别打断点，如下表："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"测试"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"构造"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"析构"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"结果"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"可调试"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"可调试"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"无响应"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"*"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"无响应"}]}]}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"表中 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 代表打断点"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可发现只要在那个单例类的析构中打断点就会造成 Unity 无响应。"}]},{"type":"element","tag":"h2","props":{"id":"解决办法"},"children":[{"type":"text","value":"解决办法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"删除析构方法中的断点，或者所有断点，再调试。"}]},{"type":"element","tag":"h1","props":{"id":"关于如何进行unity远程debugger"},"children":[{"type":"text","value":"关于如何进行unity远程debugger"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"首先打开unity的debug模式"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-03-01-unity-debug/2019-06-21-18-19-45.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开启visual sudio中找到attach unity debugger"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2020-03-01-unity-debug/2019-06-21-18-20-01.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"原因分析","depth":2,"text":"原因分析"},{"id":"解决办法","depth":2,"text":"解决办法"}]}},"_type":"markdown","_id":"content:unity:2020-03-01-unity-debug.md","_source":"content","_file":"unity/2020-03-01-unity-debug.md","_extension":"md","date":"2020-03-01"},{"_path":"/unity/2020-03-04-unity-startup","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity启动运行脚本流程","description":"性能分析：所有尝试优化的操作都是从发现问题开始的，在谈论性能时，这是非常重要的。对一个应用进行性能分析，第一步是根据性能分析的结果，找出它的瓶颈。然后再优化项目中的用到的技术和资源的结构。提示：本节性能分析中出现的方法名称，都是从unity5.3中提取的，方法名可能在以后的Unity版本中发生变化。工具：对于unity开发者来说，性能分析的工具有很多种。Unity有一系列的内置工具，比如CPU Profiler，Memory Profiler和5.3中新加的Memory Analyzer。然而最好的分析数据通常来自于特定平台的工具。其中包括：IOS:Instruments和XCode Fram","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"性能分析："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有尝试优化的操作都是从发现问题开始的，在谈论性能时，这是非常重要的。对一个应用进行性能分析，第一步是根据性能分析的结果，找出它的瓶颈。然后再优化项目中的用到的技术和资源的结构。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"提示：本节性能分析中出现的方法名称，都是从unity5.3中提取的，方法名可能在以后的Unity版本中发生变化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"工具："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于unity开发者来说，性能分析的工具有很多种。Unity有一系列的内置工具，比如CPU Profiler，Memory Profiler和5.3中新加的Memory Analyzer。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然而最好的分析数据通常来自于特定平台的工具。其中包括："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOS:Instruments和XCode Frame Debugger"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Android:Snapdragon Profiler"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"运行因特尔CPU/GPU的平台：VTune和Intel GPA"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PS4:Razor系列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Xbox：Pix工具"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些工具通常能分析用IL2CPP打包出来的C++项目。这些本地代码版本中，能清晰的看到堆栈调用和各类方法的执行时间，如果用Mono编译，是做不到这些的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于IOS设备上怎么进行性能分析，Unity官方有一个基本的介绍。请看："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blogs.unity3d.com/cn/2016/02/01/profiling-with-instruments/%3F_ga%3D2.53202159.65875105.1532310232-165234103.1528100648","rel":["nofollow"]},"children":[{"type":"text","value":"Profiling with Instruments – Unity Blogblogs.unity3d.com!"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"启动流程剖析："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当查看启动流程的时间时，有两个方法需要注意。在那些影响启动时间的配置文件、资源和工程代码中，这两个方法起着重要的作用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在不同的平台上，启动时间是不同的。在大多数平台上，Splash Image显示的时间，就是启动的时间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-03-04-unity-startup/v2-e65aeff3106290ff9e3de0580ffa90ab_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的截图来自于在iOS设备上运行的一个示例项目。在此平台的startUnity方法中，请注意UnityInitApplicationGraphics和UnityLoadApplication方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UnityInitApplicationGraphics执行了大量的内部操作，例如设置图形设备和初始化许多Unity的内部系统。另外，为了初始化Resource系统，它必须加载Resource系统所包含下标的所有文件。每个名为“Resources”的文件夹中的每一个资源文件（注意：这只适用于项目“Assets”文件夹中名为“Resources”的文件夹，以及“Resources”文件夹中的所有子文件夹）都包含在Resource系统的数据中。因此，初始化Resource系统所需的时间与“Resource”文件夹中的文件数量至少呈线性关系。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UnityLoadApplication包含加载和初始化第一个场景的方法。在项目中，这包括把需要在第一个场景里需要显示的所有数据进行反序列化和实例化。比如，编译着色器，上传贴图和实例化GameObjects。另外，第一个场景中，所有继承了MonoBehaviour脚本中的Awake方法都会在这个时候被回调。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些过程意味着，如果在项目的第一个场景中，在Awake方法中有长时间运行的代码，那么该代码就会增加项目的启动时间。为了避免这一问题，在Awake方法中不能放运行时间长的代码，或者把这些代码放到程序的其他其他生命周期里。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"运行时流程分析："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在初始化启动之后的性能分析中，最主要的是PlayerLoop方法。这个是Unity的主循环，并且每一帧都会被执行一次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-03-04-unity-startup/v2-5c6c95216621d4ab86b26636ff9a019a_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的截图来自Unity5.4一个示例项目的性能分析。它展示了PlayerLoop中几个最有趣的方法。请注意，不同Unity版本之间，PlayerLoop中的方法名称可能有所不同。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PlayerRender是运行在Unity渲染系统中的方法。它包括对象剔除，计算动态批次，向GPU提交绘制命令。任何的后处理效果（Image Effects）或基于渲染的脚本回调（比如OnWillRenderObject）也都在这里运行。通常来讲，在具有交互的项目中，这个方法也是最影响GPU性能的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BaseBehaviourManager调用了三个类型的CommonUpdate方法。它会调用当前场景中，挂在激活的物体上面的Monobehaviours里的特定方法。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CommonUpdate 回调 Update"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CommonUpdate 回调 LateUpdate"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CommonUpdate 如果勾选了物理系统，就会回调 FixedUpdate"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常，检测BaseBehaviourManager::CommonUpdate这类方法是最有趣的，因为它是多数Unity项目脚本运行的入口。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有几个其他的方法也可以注意一下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果项目用到了Unity的UI系统，UI::CanvasManager就会回调几个不同的方法。包括Unity UI的批次计算和布局更新，在CanvasManager中，这两个方法也是比较常用并且比较重要的方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DelayedCallManager::Update运行协程。这部分内容在之后的”Coroutines”的章节会详细的介绍（如果我能坚持的话，哈哈哈）或者参考官方文档"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity3.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Manual: Coroutinesdocs.unity3d.com!"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PhysicsManager::FixedUpdate执行PhysX物理引擎。它主要涉及到执行PhysX的内部代码，并且也手当前场景中物理对象数量的影响。比如Rigidbodies和Colliders。然而，基于物理的回调也会在OnTriggerStay和OnCollisionStay中出现。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果项目有用到2D物理系统。那么在Physics2DManager::FixedUpdate中也会出现类似的调用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"脚本方法剖析："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当脚本用IL2CPP编译跨平台编译时，找到包含ScriptingInvocation对象这行。这是Unity为了执行脚本代码，从内部代码过渡到运行时脚本的一个时间点（注意：从技术上讲，通过运行IL2CPP，C#和JS脚本也变成了本地代码。然而，这种编译的代码主要通过IL2CPP运行时框架执行方法，这跟手写的C++代码不太相似）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-03-04-unity-startup/v2-ddde913f040c5de47824f8abaca2e978_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的截图来自一个Unity5.4示例项目中的另一个的性能分析。RuntimeInvoker_Void这一行下面的所有方法都是C#脚本编译的，它们每帧都会被执行一次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分析报告阅读起来比较容易：每一个都是类名+“_”+方法名。在上图中，我们可以看到EventSysten.Update，PlayerShooting.Update和几个其他的Update方法，这些是大多数MonoBehaviours脚本中比较标准的Unity Update回调。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"展开这些方法，可以清楚的看到那些正在占用CPU的方法。其中也会包括项目中被用到的Unity API和C#类库的方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图的分析中，也显示了StandaloneInputModule.Process，这个方法会在每一帧都用射线穿过整个UI，为了检测是否有点击事件或者滑动事件触发。这个对性能的主要影响是需要遍历所有的UI元素，并且监测鼠标的位置是否在UI元素的边界内。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"资源加载："}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"资源加载主要是通过SerializedFile::ReadObject方法来实现的。在对CPU性能分析时，就可以找到这个方法。SerializedFile::ReadObject通过Transfer方法，把文件的二进制数据关联到Unity的序列化系统。所有的Asset类型中，都能找到这个Transfer方法，比如Texttures，MonoBehaviours 和Particle Systems。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-03-04-unity-startup/v2-05563390f8cb569523e89841537c0e8f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在上面的截图中，一个场景正在被加载。SerializedFile::ReadObject下面调用的不同Transfer方法表明了Unity正在读取并且反序列化场景中所有的Assets。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常，如果运行时遇到了性能问题，在加载资源时帧率下降，并且通过性能分析是由于SerializedFile::ReadObject这个方法造成的。请注意，在多数情况下，只有当通过SceneManager, Resources 或者 AssetBundle API进行同步加载资源时，SerializedFile::ReadObject才会出现在主线程里。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"避免出现这种性能问题，常规的做法是：你可以使用异步加载资源（这就把大量的ReadObject操作丢给了工作线程），或者提前加载好比较大的资源。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意，当克隆objects时，Transfer也会被调用（在性能分析时出现的CloneObject就是）。如果CloneObject方法下面出现了Transfer方法，这说明资源不是正在从储存器上加载，而是在克隆老的对象。这个过程是：Unity先把老对象序列化，再反序列化数据作为新的对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文翻译自Unity官方文档："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity1.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Manual: Profilingdocs.unity3d.com!"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Q1：第一次启动项目会有冷启动时间过长的情况，请问该怎么优化？"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先肯定是判断游戏在冷启动过程中是在做什么事情消耗了时间，然后针对性地优化。还有就是定义好冷启动的界限，从点击游戏到Unity的闪屏出现这段时间通常定义为冷启动的时间，但是我们项目后来发现在做启动的优化的时候还有很长时间花费在游戏启动之后的一些资源初始化方面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我在优化启动时间的过程中没有使用什么特别多的工具，主要是基于mlogcat.exe查看设备上输出信息的log，结合自己加入的一些log来做问题的排查。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"纯粹的冷启动时间过长，会和Resources目录下的资源有关系，越多越慢。我们是以AssetBundle的方式为主，所以这块注意了下，清理了一些插件引入的确定不需要的资源（直接看打包好的apk里的内容来排查）。另外搜索下还有一些文章说相关问题，可以关注下，这里不赘述。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/qq_34307432/article/details/84023894","rel":["nofollow"]},"children":[{"type":"text","value":"Unity 冷启动简介"}]},{"type":"element","tag":"a","props":{"href":"http://gad.qq.com/article/detail/32076","rel":["nofollow"]},"children":[{"type":"text","value":"Unity3D游戏如何加快冷启动时间"}]},{"type":"element","tag":"a","props":{"href":"https://www.zhihu.com/question/55441136","rel":["nofollow"]},"children":[{"type":"text","value":"如何改进Unity3d手游启动速度？"}]},{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/4366da6dd4a1","rel":["nofollow"]},"children":[{"type":"text","value":"Unity启动耗时优化"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说一下我们遇到的游戏启动时间过长时解决过的几个问题。我们定义启动时间是从点击app图标到进入游戏Patch界面（即游戏逻辑接管）这段时间。\n1）Shader编译时长。如果只有游戏安装之后第一次启动时间过长，一个很大的可能是shader编译，之后游戏启动因为有了Cache所以会快很多。这种情况的话建议查看下Always Include的Shader内容和变体，使用shadervariantcollection等方案替代。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2）Tolua绑定和Lua资源加载。这种是每次游戏启动都会有的，ToLua接口绑定需要一定的时间，我们在确保前期不会使用Lua的情况下采用多线程的方式进行绑定和加载，保证主线程不会卡住。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3）注意设置Web请求的超时时长。我们在游戏启动的时候做了一些hook的事情，会有Web请求，后来我们遇到一个情况是在很多机器上会黑屏等待30s甚至60s这样的时长，后来发现是因为这个Web请求没有设置超时时间，于是使用了机器默认的超时时间，在不同设备上不同，比如红米2A上会有接近1分钟的超时限制。这个很坑，只是因为那个非必须的Web服务没有正确开启，导致排查了很长时间。\nNative层增加界面，减少黑屏等待，提升玩家体验。这个并不能真正解决问题，只是一种缓解手段，等到优化做到位了，其实也就不需要了。\n说的内容大都是启动时间而非冷启动，供题主参考。建议题主多看看Unity进程的输出log，可能会有意外发现，通常情况下，不使用Resources的方式的话，在没Bug的情况下冷启动时间应该不会很长，我们因为没怎么用这种方式，所以不是很清楚。这个链接可以参考下："},{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/4366da6dd4a1","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.jianshu.com/p/4366da6dd4a1"}]}]}]},{"type":"element","tag":"h2","props":{"id":"脚本编译顺序"},"children":[{"type":"text","value":"脚本编译顺序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于大型项目来说，这确实是大家经常遇到的情况。一般来说，Unity Editor会按照脚本的依赖关系编译代码，其主要分为以下四个步骤：\n编译Standard Assets、Pro Standard Assets和Plugins文件夹中的Runtime Script；\n编译以上三个文件夹中Editor文件夹下的Script；\n编译项目中所有剩余的Runtime Script（Editor文件夹以外Script；\n编译剩余Script（即Editor文件夹中Script）。\n知道了Unity编辑器的脚本编译特性后，我们则建议研发团队可以将一些长时间不需要改动的脚本代码（比如各种插件代码）放入到Standard Assets、Pro Standard Assets或Plugins文件夹中，这样这些代码只需要编译一次，后续的时间就都能节省下来。有朋友做过测试，在他们的项目中经过上面的改动，原来项目每次的编译时间从23s下降到7s。想想看，这将节省你和你的团队多少时间！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"脚本编译顺序","depth":2,"text":"脚本编译顺序"}]}},"_type":"markdown","_id":"content:unity:2020-03-04-unity-startup.md","_source":"content","_file":"unity/2020-03-04-unity-startup.md","_extension":"md","date":"2020-03-04"},{"_path":"/unity/2020-07-01-unity-coordinate","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity的坐标体系","description":"一、前言刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了：区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y ","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"一前言"},"children":[{"type":"text","value":"一、前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"zggtdzunj4","src":"/images/2020-07-01-unity-coordinate/zggtdzunj4.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y 轴就是左手坐标系，如果是右手 90 度握紧后到了 y 轴就是右手坐标系。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了 3D 世界中的坐标系，还有其他的几个坐标系也非常常用，比如我们经常要把世界三维坐标系转换成我们最终屏幕中的二维坐标系，或者把手机屏幕的二维坐标系转化成游戏世界中的三维坐标系等，各个坐标系各有特别，不能混用，为了更好的学习 Unity 游戏开发，自己在此总结一下 Unity 当中的坐标系和相关用法，以作备忘和学习。"}]},{"type":"element","tag":"h2","props":{"id":"二坐标体系"},"children":[{"type":"text","value":"二、坐标体系"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity3D 当中基本的坐标体系主要有下面这四种："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"世界坐标系 (World Space)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"屏幕坐标系 (Screen Space)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"视口坐标系 (Viewport Space)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GUI界面坐标系 (GUI System)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"7ku2m8quf5","src":"/images/2020-07-01-unity-coordinate/7ku2m8quf5.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这四种坐标系可以说没有一个是完全相同的，各个坐标系所代表的意思也可以从字面含义中理解出来，它们之间都是可以相互转换的，不过 GUI 坐标体系除外，它比较特殊，也相对来说是最简单的，那么我们就从最简单的说起吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1. 绘制 GUI 界面的坐标体系"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们在做 Unity 游戏开发的时候，经常会使用内置的 GUI 来做一些测试，比如显示一个按钮控制游戏，画一个文本显示相关信息等。它的代码全部控制在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnGUI()"}]},{"type":"text","value":" 函数中："}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"private void OnGUI()\n{\n    if (GUI.Button(new Rect(0f, 0f, 160f, 40f), \"Click Me\"))\n    {\n        //button clicked and do something here...\n    }\n}\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private void OnGUI()\n{\n    if (GUI.Button(new Rect(0f, 0f, 160f, 40f), \"Click Me\"))\n    {\n        //button clicked and do something here...\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个按钮 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Button"}]},{"type":"text","value":" 所在的坐标系就是 GUI 绘制坐标系。大家稍微测试一下就知道了，它的原点 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(0, 0)"}]},{"type":"text","value":" 在最左上角，因为屏幕宽度是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Screen.width"}]},{"type":"text","value":" ，高度是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Screen.height"}]},{"type":"text","value":" ，所以 GUI 体系右下角的坐标为： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(Screen.width, Screen.height)"}]},{"type":"text","value":" , 这是一个二维的坐标体系，坐标 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"z"}]},{"type":"text","value":" 的值都为 0 。大家可以看下图加深理解："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"ojb5jzsb2r","src":"/images/2020-07-01-unity-coordinate/ojb5jzsb2r.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2. 视口 Viewport 坐标体系"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们使用多个相机，在同一个场景中显示多个视口的时候，我们就需要用上视口坐标系了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"视口坐标系对于场景的显示非常重要，对于新手来说我们经常使用一个相机就够了，但是当需要使用到多个视口的时候，我们就必须关注视口坐标体系了，大家可以在相机 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Camera"}]},{"type":"text","value":" 的属性中看到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Viewport Rect"}]},{"type":"text","value":" 就是视口坐标系的设置："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"x9myhu3k73","src":"/images/2020-07-01-unity-coordinate/x9myhu3k73.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个相机对应一个视口，视口预览（ Camera Preview ）展示了相机所看到的所有物体，很显然，它默认大小是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(width = 1, height = 1)"}]},{"type":"text","value":" ，位置也是从 0 到 1 ，这个位置就是我们所讨论的坐标系：左下角为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(0, 0)"}]},{"type":"text","value":" ，右上角是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(1, 1)"}]},{"type":"text","value":" ，一般视口坐标系主要用在相机显示中，我们简单的进行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Viewport Rect"}]},{"type":"text","value":" 的设置就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，新手朋友们可以记住这么一个快捷键： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Ctrl + Shift + F"}]},{"type":"text","value":" ，可以快速设置相机视口到当前场景窗口的视口位置。下图是视口坐标系和鼠标在屏幕上的坐标系的转换结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"6hkl5q24ft","src":"/images/2020-07-01-unity-coordinate/6hkl5q24ft.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3. 屏幕 Screen 坐标体系"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"嗯，非常重要！不管怎样，最终我们所有的成果都会发布到各个平台（屏幕）上，所以，任何坐标系的坐标和屏幕坐标系的转换都是非常重要的。比如我们经常需要处理鼠标的相关事件（鼠标位置、单击、双击事件等），或者手机上的触摸反馈，这些原始数据都是屏幕坐标系相关的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然重要，其实屏幕坐标系处理起来很简单直接， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Input.mousePosition"}]},{"type":"text","value":" 获取的就是鼠标在屏幕中的位置坐标。大家可以测试一下，屏幕坐标系中原点 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(0, 0)"}]},{"type":"text","value":" 位于左下角，那么右上角必然就是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(Screen.width, Screen.height)"}]},{"type":"text","value":" ，对了，还有一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"z"}]},{"type":"text","value":" 呢？都为 0 吗？答案是肯定的，既然是二维坐标系那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"z"}]},{"type":"text","value":" 肯定是 0 了，和 GUI 坐标系一样，但是话又说回来，屏幕坐标系转换成世界坐标系 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"z"}]},{"type":"text","value":" 还是 0 吗？其实不然，屏幕坐标转换成世界坐标后物体的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"z"}]},{"type":"text","value":" 值是取决于相机的，因此： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"gameObject.z = camera.z"}]},{"type":"text","value":" ，其实在上面视口坐标系介绍中的图中我已经把 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mouse Point"}]},{"type":"text","value":" 鼠标位置转换成世界坐标（ "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"World Point"}]},{"type":"text","value":" ）了，大家应该注意到了吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，除了坐标系的转换，还有什么值得注意的呢？这里我要告诉大家的是，我们在控制相机的时候，因为屏幕显示的就是相机所看到的内容，而"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"屏幕的宽高比直接影响了相机的显示"}]},{"type":"text","value":"，也就是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Aspect Ratio"}]},{"type":"text","value":" 的值，大家可以在 Game 面板中轻松地设置 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Aspect"}]},{"type":"text","value":" 宽高比，查看对游戏画面的影响："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"cmpbepr0jw","src":"/images/2020-07-01-unity-coordinate/cmpbepr0jw.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图，相机的宽高比和屏幕宽高比一致，显示结果也一致："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"a0qyr11woq","src":"/images/2020-07-01-unity-coordinate/a0qyr11woq.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果相机的宽高比设置的和屏幕宽高比不一样的话，显示结果就有点不同了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"iadfp03ffu","src":"/images/2020-07-01-unity-coordinate/iadfp03ffu.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，在游戏开发中，**我们要重视相机的宽高比 **"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Camera.aspect"}]},{"type":"text","value":" 的值，一般我们会保持相机宽高比不变，然后通过改变相机的视口尺寸 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Camera.orthographicSize"}]},{"type":"text","value":" 来显示场景中需要显示的物体，关于这个主题我会在我的下一篇文章中提到，大家可以关注我的博客。如何通过宽高比获取摄像机视口尺寸呢？首先可以从上图中知道宽高比的计算方法： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aspect = width / height"}]},{"type":"text","value":" ，当你同时获取到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"width"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"height"}]},{"type":"text","value":" 的时候，你通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mathf.Max(height, width / aspect)"}]},{"type":"text","value":" 来得出最终的尺寸大小（"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"注意这个结果是 2 倍视口尺寸哦"}]},{"type":"text","value":"）。这个在游戏场景中应用的还是比较多的，比如你有这么个需求：两个玩家移动对战，你的相机要把两个移动的玩家随时放置在屏幕显示中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4. 世界 World 三维坐标系"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，世界坐标系！世界坐标系不是最简单的，但却是我们最常用的坐标系。记住一点，任何情况下： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"transform.position"}]},{"type":"text","value":" 都是返回物体的世界坐标值，及时你所使用的是子物体！另外，从上面所讲的屏幕坐标系转换成世界坐标系也是非常简单的，它以当前相机为参考："}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"var position = Input.mousePosition;\nvar worldPoint = Camera.main.ScreenToWorldPoint(position);\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var position = Input.mousePosition;\nvar worldPoint = Camera.main.ScreenToWorldPoint(position);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一方面，我们在游戏开发过程中，经常要处理"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"子物体"}]},{"type":"text","value":"的相对 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"transform"}]},{"type":"text","value":" 值，这个时候我们就需要稍微动点脑子了，当然如何转变 Unity 已经帮我们预制好相应的函数方法了，你只要"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"把父物体当做世界，子物体当做世界中的物体"}]},{"type":"text","value":"，使用这些函数，换一下坐标就和处理绝对坐标一样了，不知道大家理解没有。我举个例子，我们在游戏开发中会遇到这种情况，你的相机如果直接放到世界中那么必然会需要调整它的旋转角度才能达到满意的视口位置，如何不让相机产生任何旋转就能把世界中的游戏物体放到合适的视口位置呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"办法就是：我们"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"把相机放到一个产生了合适旋转角度的父物体当中！这样做的效果就是：相机就相当于子物体，父物体旋转了，子物体就不需要额外旋转了，这时候相机的"}]},{"type":"text","value":"局部旋转就为 0 。这在有些场景中使用起来很方便，相机已经是父物体世界中的子物体了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"cjali0ffbs","src":"/images/2020-07-01-unity-coordinate/cjali0ffbs.jpeg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怎么计算相对坐标呢？在 Unity 中都有相应的函数，使用比较简单："}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"//获取的是世界坐标\nvar childPosition = childObject.transform.position;\n//转化为父物体下的相对坐标，相当于位于父物体世界中\nvar relativePosition = parentObject.transform.InverseTransformPoint(childPosition);\n//转化为世界坐标，注意：这里不能传入 childPosition ，因为 childPosition 就是世界坐标\nvar worldPosition = parentObject.transform.TransformPoint(relativePosition);\n\n//所以，下面结果是相等的！\nprint(childPosition == worldPosition);\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//获取的是世界坐标\nvar childPosition = childObject.transform.position;\n//转化为父物体下的相对坐标，相当于位于父物体世界中\nvar relativePosition = parentObject.transform.InverseTransformPoint(childPosition);\n//转化为世界坐标，注意：这里不能传入 childPosition ，因为 childPosition 就是世界坐标\nvar worldPosition = parentObject.transform.TransformPoint(relativePosition);\n\n//所以，下面结果是相等的！\nprint(childPosition == worldPosition);\n"}]}]},{"type":"element","tag":"h2","props":{"id":"三总结"},"children":[{"type":"text","value":"三、总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然，在使用坐标系过程中我们还要关注其他方方面面，比如欧拉角的旋转，万向锁，平滑过渡视野等等，这些我想我会在后面的文章总结中写道吧。这次就总结介绍了这几个坐标系，看上去有点复杂，总体来说还是挺很好理解的，有什么不对的或者可以加强的请给我留言，谢谢！"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一前言","depth":2,"text":"一、前言"},{"id":"二坐标体系","depth":2,"text":"二、坐标体系"},{"id":"三总结","depth":2,"text":"三、总结"}]}},"_type":"markdown","_id":"content:unity:2020-07-01-unity-coordinate.md","_source":"content","_file":"unity/2020-07-01-unity-coordinate.md","_extension":"md","date":"2020-07-01"},{"_path":"/unity/2020-07-03-unity-mesh","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"2020 07 03 Unity Mesh","description":"title : \"Mesh renderer 和 Mesh 和 Mesh Filter\"基本概念Meshes 是Unity的主要图形基元。 它们定义对象的形状。Materials 通过包含对所用纹理的引用、平铺信息、颜色色调等来定义表面应使用的渲染方式。材质的可用选项取决于材质使用的着色器。Shaders 是一些包含数学计算和算法的小脚本，根据光照输入和材质配置来计算每个像素渲染的颜色。Textures 是位图图像。材质可包含对纹理的引用，因此材质的着色器可在计算游戏对象的表面颜色时使用纹理。除了游戏对象表面的基本颜色（反照率）之外，纹理还可表示材质表面的许多其他方面，例如其反射率或粗糙度。T","body":{"type":"root","children":[{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"title-mesh-renderer-和-mesh-和-mesh-filter"},"children":[{"type":"text","value":"title : \"Mesh renderer 和 Mesh 和 Mesh Filter\""}]},{"type":"element","tag":"h1","props":{"id":"基本概念"},"children":[{"type":"text","value":"基本概念"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Meshes"}]},{"type":"text","value":" 是Unity的主要图形基元。 它们定义对象的形状。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Materials"}]},{"type":"text","value":" 通过包含对所用纹理的引用、平铺信息、颜色色调等来定义表面应使用的渲染方式。材质的可用选项取决于材质使用的着色器。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Shaders"}]},{"type":"text","value":" 是一些包含数学计算和算法的小脚本，根据光照输入和材质配置来计算每个像素渲染的颜色。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Textures"}]},{"type":"text","value":" 是位图图像。材质可包含对纹理的引用，因此材质的着色器可在计算游戏对象的表面颜色时使用纹理。除了游戏对象表面的基本颜色（反照率）之外，纹理还可表示材质表面的许多其他方面，例如其反射率或粗糙度。"}]}]},{"type":"element","tag":"h2","props":{"id":"texture"},"children":[{"type":"text","value":"Texture"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-07-03-unity-mesh/201808082025438"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#Default","rel":["nofollow"]},"children":[{"type":"text","value":"Default"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#NormalMap","rel":["nofollow"]},"children":[{"type":"text","value":"Normal Map"}]},{"type":"text","value":" 法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向，你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#Editor","rel":["nofollow"]},"children":[{"type":"text","value":"Editor GUI and Legacy"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#Sprite","rel":["nofollow"]},"children":[{"type":"text","value":"Sprite (2D and UI)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#Cursor","rel":["nofollow"]},"children":[{"type":"text","value":"Cursor"}]},{"type":"text","value":"  光标文件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#Cookie","rel":["nofollow"]},"children":[{"type":"text","value":"Cookie"}]},{"type":"text","value":" 聚光灯贴图"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#Lightmap","rel":["nofollow"]},"children":[{"type":"text","value":"Lightmap"}]},{"type":"text","value":"  光照贴图"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/TextureTypes.html#SingleChannel","rel":["nofollow"]},"children":[{"type":"text","value":"Single Channel"}]}]}]},{"type":"element","tag":"h1","props":{"id":"mesh"},"children":[{"type":"text","value":"Mesh"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"顶点坐标（vertex） 顶点坐标数组存放Mesh的每个顶点的空间坐标，假设某mesh有n个顶点，则vertex的size为n"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"三角形序列（triangle） 每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，三角形的数组的size = 三角形个数 * 3."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"法线（normal） 法线数组存放mesh每个顶点的法线，大小与顶点坐标对应，normal[i]对应顶点vertex[i]的法线.它不仅说明了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"面片的朝向，还可用于计算光照模型"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"次法线 (subnormal)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"纹理坐标（uv） 它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的, 以决定表面纹理贴图的位置. UV就是将"},{"type":"element","tag":"a","props":{"href":"http://baike.baidu.com/view/42116.htm","rel":["nofollow"]},"children":[{"type":"text","value":"图像"}]},{"type":"text","value":"上每一个点精确对应到模型物体的表面. uv[i]对应vertex[i]"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"切线 (tangent) 切线是垂直于法线的一条向量，由于垂直于法线的向量有无数条，所以切线最终规定为由UV坐标来决定朝向。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如：左图利用三个点绘制了一个三角形，而右图则通过两个三角形得到了一个四边形："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-03-unity-mesh/20190805190859508.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注：这里需要注意的是，很明显从左图中给定的三个点，有两种方式可以得到三角图元，即"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"顺时针旋转（也称左手螺旋）：p0->p1->p2"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"逆时针旋转（右手螺旋）：p0->p2->p1"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它们的区别在哪里呢？类似于物理中左右手判断法则，拇指指示了三角图元的法线方向。法线其中一个作用是指明了三角图元的方向，如果从反方向看的话，这个图元是不可见的。而unity3d是左手坐标系在渲染时默认只渲染正面，背面是看不见的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么要绘制上图中的三角形，即问题在于表达三个点的坐标，也就可以表示为下面的代码："}]},{"type":"element","tag":"pre","props":{"code":"Vector2[] vertices = new Vector2[]{ \n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n };\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Vector2[] vertices = new Vector2[]{ \n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而如果要绘制四边形，也就需要六个点的坐标，如下面所示："}]},{"type":"element","tag":"pre","props":{"code":"Vector2[] vertices = new Vector2[]{ \n    // 三角图元 0\n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n    // 三角图元 1\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 1 ),                            // p3\n    new Vector2( 1, 0 ),                            // p2\n };\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Vector2[] vertices = new Vector2[]{ \n    // 三角图元 0\n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n    // 三角图元 1\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 1 ),                            // p3\n    new Vector2( 1, 0 ),                            // p2\n };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果单纯使用顶点来表示（绘制）图形，是非常直观的——因为我们知道每一个顶点的位置信息，并且知道每三个点构成一个三角图元。然而从上面绘制四边形的数据中可以发现，三角图元1中有两个顶点的位置信息（p1和p3）和三角图元0是一样的。这也就增加了一些开销。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总而言之，这个额外的存储开销是完全可以去除的，方法就是使用索引（Indices）。"}]},{"type":"element","tag":"pre","props":{"code":"Vector2[] vertices = new Vector2[]{ \n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n };\n int[] indices = new indices[]{\n    0, 1, 2                                         // 表示 0->1->2 构成一个三角图元\n };\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Vector2[] vertices = new Vector2[]{ \n    new Vector2( 0, 0 ),                            // p0\n    new Vector2( 0, 1 ),                            // p1\n    new Vector2( 1, 0 ),                            // p2\n };\n int[] indices = new indices[]{\n    0, 1, 2                                         // 表示 0->1->2 构成一个三角图元\n };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"没错，indices就是这么一回事，原来是vertices数组中，每三个顶点表示一个三角图元，现在是indices数组中，每三个整型表示一个图元。这些整形不存储真正的数据，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"只有用到时才从vertices中取出，也就是所谓的索引了"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h1","props":{"id":"submesh"},"children":[{"type":"text","value":"SubMesh"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"面提到过，MeshRenderer负责对MeshFilter中的Mesh进行绘制，而绘制依赖于着色器，或者说着色器生成的材质（Material）。简单来说，材质具体描述了Mesh中的数据如何进行绘制。\nMaterial只负责一个Mesh的一次绘制，但是现在有一个要求是，Mesh的不同部分，要求使用不同的材质。例如上面所绘制的四边形，两个三角面片要求绘制出不同的颜色。这个时候就需要使用SubMesh了。\n从名字也能看出，SubMesh类似于Mesh，并且Mesh包含SubMesh。但是和Mesh不一样的是，SubMesh只有triangles信息，也就是说SubMesh使用自身的 triangles信息，索引找到 Mesh上的顶点信息（如vertices、 uv、normal等）后进行三角面片的绘制。它们的关系如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-07-03-unity-mesh/20190806210636364.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个设置的过程依赖于Mesh中的API是 SetTriangles，其函数原型为："}]},{"type":"element","tag":"pre","props":{"code":"/*\n @parm triangles:           SubMesh的triangles\n @parm submesh:             属于Mesh中的第几个submesh\n @parm calculateBounds： 是否计算包围盒，默认为true。设置为false会使用当前存在的包围盒以减少CPU开销\n @parm baseVertex：          triangles中每一个元素的偏移值，默认为0；\n*/\npublic void SetTriangles(int[] triangles, int submesh, bool calculateBounds = true, int baseVertex = 0);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/*\n @parm triangles:           SubMesh的triangles\n @parm submesh:             属于Mesh中的第几个submesh\n @parm calculateBounds： 是否计算包围盒，默认为true。设置为false会使用当前存在的包围盒以减少CPU开销\n @parm baseVertex：          triangles中每一个元素的偏移值，默认为0；\n*/\npublic void SetTriangles(int[] triangles, int submesh, bool calculateBounds = true, int baseVertex = 0);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用法如下："}]},{"type":"element","tag":"pre","props":{"code":"Vector3[] vertices = new Vector3[]{\n         new Vector3( 0, 0, 0 ),\n         new Vector3( 0, 1, 0 ),\n         new Vector3( 1, 0, 0 ),\n         new Vector3( 1, 1, 0 ),\n    };\n    int[] subTriangles_0 = new int[]{\n        0, 1, 2\n    };\n    int[] subTriangles_1 = new int[]{\n        1, 3, 2\n    };\n    Mesh mesh = new Mesh();\n    mesh.vertices = vertices;\n    // 告诉 Mesh它将会有两个SubMesh\n    mesh.subMeshCount = 2;\n    mesh.SetTriangles( subTriangles_0 , 0 );\n    mesh.SetTriangles( subTriangles_1 , 1 );\n    // 重新计算normal信息，不然后面的 material会不起作用\n    mesh.RecaculateNormals();\n    // MeshFilter\n    MeshFilter meshFilter = GetComponent<MeshFilter>();\n    if( meshFilter == null ) meshFilter = gameObject.AddComponent<MeshFilter>();\n    meshFilter.mesh = mesh;\n    // MeshRenderer\n    MeshRenderer meshRenderer = GetComponent<MeshRenderer>();\n    if( meshRenderer == null ) gameObject.AddComponent<MeshRenderer>();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Vector3[] vertices = new Vector3[]{\n         new Vector3( 0, 0, 0 ),\n         new Vector3( 0, 1, 0 ),\n         new Vector3( 1, 0, 0 ),\n         new Vector3( 1, 1, 0 ),\n    };\n    int[] subTriangles_0 = new int[]{\n        0, 1, 2\n    };\n    int[] subTriangles_1 = new int[]{\n        1, 3, 2\n    };\n    Mesh mesh = new Mesh();\n    mesh.vertices = vertices;\n    // 告诉 Mesh它将会有两个SubMesh\n    mesh.subMeshCount = 2;\n    mesh.SetTriangles( subTriangles_0 , 0 );\n    mesh.SetTriangles( subTriangles_1 , 1 );\n    // 重新计算normal信息，不然后面的 material会不起作用\n    mesh.RecaculateNormals();\n    // MeshFilter\n    MeshFilter meshFilter = GetComponent<MeshFilter>();\n    if( meshFilter == null ) meshFilter = gameObject.AddComponent<MeshFilter>();\n    meshFilter.mesh = mesh;\n    // MeshRenderer\n    MeshRenderer meshRenderer = GetComponent<MeshRenderer>();\n    if( meshRenderer == null ) gameObject.AddComponent<MeshRenderer>();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将上述代码挂载到一个空节点上运行，可以得到以下结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-03-unity-mesh/20190806223230787.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"嗯？！难不成笔者在骗人，这里明明只有一个三角面片。莫慌，之前不是说过，要求两个三角面片使用不同的材质吗？如果运行时，将MeshRenderer的Material的Size设为2的话，你会发现另外一个三角图元也出现了："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-03-unity-mesh/20190806223831570.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-03-unity-mesh/20190806223841210.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就是说，有多少个SubMesh，就需要有多少个Material，并且它们的绘制关系是一一对应的。即第一个SubMesh使用第一个\nMaterial绘制，第二个SubMesh使用第二个Material绘制，以此类推。为了验证这个，接下来创建两个默认的Material，将它们的Albedo分别设置为红色和绿色，接着运行时将这两个 Material赋给MeshRenderer，将会得到如下图所示的运行结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-07-03-unity-mesh/2019080622511158.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，如果双击 MeshFilter的 Mesh属性，从下面的预览窗口，也能看到这个Mesh有两个SubMesh："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-07-03-unity-mesh/20190806225353486.png"},"children":[]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何在unity显示线框图\n选择场景视图在其工具栏左侧的显示模式。前三个选项是阴影线框和阴影线框。"}]}]},{"type":"element","tag":"h1","props":{"id":"meshcombine"},"children":[{"type":"text","value":"MeshCombine"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MeshCombine，就是合并网格。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么好好的模型要进行网格的合并呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果从应用的角度来看的话，通过网格合并可以实现游戏中的换装，你可能会说，更换的服装例如帽子好好的，为什么要合并到人物模型上？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"问题在于，如果游戏中不是所有人物模型都是标准的人型呢？例如魔兽世界中，不同种族的头部模型大小是不一致的，很容易出现穿模。当然可以同一顶帽子制作适配于不同种族的模型，反正这个工作是美术做的（溜）。但是从整体出发的话，这样做无疑增加了游戏容量的大小，也会减慢游戏开发的进度，同时一定程度上影响代码的简洁性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是通过网格合并，将帽子的网格合并到人物模型上，并且蒙皮至人物头部的骨骼上。这样以后，由于骨骼的大小、旋转、位移信息会影响顶点，因此一旦这个帽子戴到别的人物模型身上时，由于它们头部骨骼的大小不一样，那么帽子也会自动变大。也就达到了同一个模型，适用于多个人物模型的目的。\n（关于骨骼、蒙皮、骨骼蒙皮动画，可以参考下面的扩展资料）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关于网格合并，同样Unity在 Mesh提供了相关的API："}]},{"type":"element","tag":"pre","props":{"code":"/*\n @parm combine:             要进行合并的CombineInstance实例\n @parm mergeSubMeshes:      是否将SubMesh进行合并，true为将SubMesh进行合并，false表示以SubMesh的形式存在\n @parm useMatrices:         是否应用定义在CombineInstance中的transform信息\n @hashLightmapData:         如果为true，则应用CombineInstance中的lightmapScaleOffset对mesh中的lightmapUV进行偏移\n*/\npublic void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes = true, bool useMatrices = true, bool hasLightmapData = false);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/*\n @parm combine:             要进行合并的CombineInstance实例\n @parm mergeSubMeshes:      是否将SubMesh进行合并，true为将SubMesh进行合并，false表示以SubMesh的形式存在\n @parm useMatrices:         是否应用定义在CombineInstance中的transform信息\n @hashLightmapData:         如果为true，则应用CombineInstance中的lightmapScaleOffset对mesh中的lightmapUV进行偏移\n*/\npublic void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes = true, bool useMatrices = true, bool hasLightmapData = false);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要使用它也很简单，如下面的代码所示："}]},{"type":"element","tag":"pre","props":{"code":" // 收集要合并的物体的所有Mesh信息\n        MeshFilter[] childMeshFilters = GetComponentsInChildren<MeshFilter>();\n\n        CombineInstance[] destCombineInstances = new CombineInstance[childMeshFilters.Length];\n        for ( int i = 0; i < childMeshFilters.Length; i++)\n        {\n            destCombineInstances[i] = new CombineInstance();\n            destCombineInstances[i].mesh = childMeshFilters[i].mesh;\n            destCombineInstances[i].transform = childMeshFilters[i].transform.localToWorldMatrix;\n\n            // 隐藏子物体，或者Destory\n            childMeshFilters[i].gameObject.SetActive(false);\n        }\n        Mesh destMesh = new Mesh();\n        // 进行合并\n        destMesh.CombineMeshes(destCombineInstances, true);\n        destMesh.RecalculateNormals();\n\n        // 将合并后的mesh赋给当前的MeshFilter\n        MeshFilter meshFilter = GetComponent<MeshFilter>();\n        if (meshFilter == null) meshFilter = gameObject.AddComponent<MeshFilter>();\n        meshFilter.mesh = destMesh;\n\n        MeshRenderer meshRenderer = GetComponent<MeshRenderer>();\n        if( meshRenderer == null)\n        {\n            meshRenderer = gameObject.AddComponent<MeshRenderer>();\n            // 设置MeshRenderer的material\n            Material material = new Material(Shader.Find(\"Standard\"));\n            meshRenderer.material = material;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" // 收集要合并的物体的所有Mesh信息\n        MeshFilter[] childMeshFilters = GetComponentsInChildren<MeshFilter>();\n\n        CombineInstance[] destCombineInstances = new CombineInstance[childMeshFilters.Length];\n        for ( int i = 0; i < childMeshFilters.Length; i++)\n        {\n            destCombineInstances[i] = new CombineInstance();\n            destCombineInstances[i].mesh = childMeshFilters[i].mesh;\n            destCombineInstances[i].transform = childMeshFilters[i].transform.localToWorldMatrix;\n\n            // 隐藏子物体，或者Destory\n            childMeshFilters[i].gameObject.SetActive(false);\n        }\n        Mesh destMesh = new Mesh();\n        // 进行合并\n        destMesh.CombineMeshes(destCombineInstances, true);\n        destMesh.RecalculateNormals();\n\n        // 将合并后的mesh赋给当前的MeshFilter\n        MeshFilter meshFilter = GetComponent<MeshFilter>();\n        if (meshFilter == null) meshFilter = gameObject.AddComponent<MeshFilter>();\n        meshFilter.mesh = destMesh;\n\n        MeshRenderer meshRenderer = GetComponent<MeshRenderer>();\n        if( meshRenderer == null)\n        {\n            meshRenderer = gameObject.AddComponent<MeshRenderer>();\n            // 设置MeshRenderer的material\n            Material material = new Material(Shader.Find(\"Standard\"));\n            meshRenderer.material = material;\n        }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"mesh合并的优缺点"},"children":[{"type":"text","value":"mesh合并的优缺点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"静态批处理后，对内存的增加是非常大的，动则就是几十兆的内存"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"动态批处理，对于合批要求挺多的，同时可能存在，动态合批消耗过大，得不偿失"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"自己在逻辑代码里面进行动态合批，对于mesh的readwrite属性是要求开启的，这无疑也增大了内存的占用，复杂的合批处理可能会消耗更多的cpu时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GPU Instancing可以一次渲染(render)相同网格的多个副本，仅使用少量"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/DrawCallBatching.html","rel":["nofollow"]},"children":[{"type":"text","value":"DrawCalls"}]},{"type":"text","value":"。在渲染诸如建筑、树木、草等在场景中重复出现的事物时，GPU Instancing很有用。将这些静态的物件如植被等全部从场景中剔除，而保存其位置、缩放、uv偏移、"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"lightmapindex"}]},{"type":"text","value":"等相关信息，在需要渲染的时候，根据其保存的信息，通过"},{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Instance"}]}]},{"type":"text","value":"来渲染，这能够减少那些因为内存原因而不能合批的大批量相同物件的渲染时间"}]}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/96084686","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/96084686"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity.cn/cn/2018.4/Manual/class-Mesh.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity.cn/cn/2018.4/Manual/class-Mesh.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity.cn/cn/2020.1/Manual/Shaders.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity.cn/cn/2020.1/Manual/Shaders.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://learnopengl-cn.github.io/","rel":["nofollow"]},"children":[{"type":"text","value":"https://learnopengl-cn.github.io/"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/Arkish/article/details/98482430","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/Arkish/article/details/98482430"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/tw_345/article/details/79771454","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/tw_345/article/details/79771454"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/96084686","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/96084686"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/ecidevilin/category_9266800.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/ecidevilin/category_9266800.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"title-mesh-renderer-和-mesh-和-mesh-filter","depth":2,"text":"title : \"Mesh renderer 和 Mesh 和 Mesh Filter\""},{"id":"texture","depth":2,"text":"Texture"},{"id":"mesh合并的优缺点","depth":2,"text":"mesh合并的优缺点"}]}},"_type":"markdown","_id":"content:unity:2020-07-03-unity-mesh.md","_source":"content","_file":"unity/2020-07-03-unity-mesh.md","_extension":"md","date":"2020-07-03"},{"_path":"/unity/2020-07-04-unity-render-pipeline","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity Render Pipeline","description":"Unity官方API中说的渲染管线(Render Pipeline)有三种","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity官方API中说的渲染管线(Render Pipeline)有三种"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Built-in Render Pipeline(URP):内置渲染管线，自定义选项有限"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Universal Render Pipeline (URP)，可编程的轻量级(通用)渲染管线，前身是Lightweight Render Pipeline简称LWPR，在Unity2019.3版本中正式应用。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"High Definition Render Pipeline (HDRP) 可编程的高保真的渲染管线，有硬件要求"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sciprttable Render Pipeline (SRP) 名词，是一种实现可编程管线的一种方法(即通过C#代码，调用API来自己定义渲染顺序，相机工作方式顺序，光照特性等很多渲染相关的东西)，通过这种方法写出来的代码文件称之为SRP。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/93203710","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/93203710"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-07-04-unity-render-pipeline.md","_source":"content","_file":"unity/2020-07-04-unity-render-pipeline.md","_extension":"md","date":"2020-07-04"},{"_path":"/unity/2020-08-29-notch-solution","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Notch Solution","description":"Screen.safeArea会返回移动平台安全区的Rect。例如，iPhoneX（2436x1125px）横屏时，Screen.safeArea返回的值为Rect（132，63，2172，1062）。如图：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Screen.safeArea会返回移动平台安全区的Rect。例如，iPhoneX（2436x1125px）横屏时，Screen.safeArea返回的值为Rect（132，63，2172，1062）。如图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-2381f8819f70e7cd357662188e2616b6_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适配思路：以界面为单位，打开界面时，获取当前设备的safeArea，调整界面的锚点，进行适配。以下利用SafeArea.cs脚本，对当前window进行适配。主要考虑三种情况："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"情况1：UI中没有全屏背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-b472160ce00e02f830c3e09dd2bc5747_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决思路：直接调整当前window的锚点，进行适配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"情况2：UI中有全屏背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-baffbbebb247c6466fcf5f0b9ddd1a95_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决思路：把背景分离到window之外，只对当前window进行适配，对背景不做处理。为了方便适配，我们可以把背景单独做成window，在UI框架中对window和背景进行分开管理。上图中，蓝色为背景图片，红色为适配的window。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"情况3：适配需要靠边的UI(例如侧边的聊天弹窗等)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-bb8467626340c8dac46c81adf176b1c3_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-615a71b2dfd94b07e4bed4d0fbcea2db_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决思路：把需要靠边的按钮拉伸到屏幕之外，达到适配效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/jirowang0409/Garena","rel":["nofollow"]},"children":[{"type":"text","value":"jirowang0409/Garena: Projects in Garena (github.com)"}]}]},{"type":"element","tag":"h1","props":{"id":"notch-solution"},"children":[{"type":"text","value":"notch solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先分为两个component."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://exceed7.com/notch-solution/components/ui-behaviour/safe-padding.html","rel":["nofollow"]},"children":[{"type":"text","value":"SafePadding"}]},{"type":"text","value":"Works with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":" tree of the uGUI component system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://exceed7.com/notch-solution/components/adaptation/safe-adaptation.html","rel":["nofollow"]},"children":[{"type":"text","value":"SafeAdaptation"}]},{"type":"text","value":"They are based on using "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ScriptReference/Playables.Playable.html","rel":["nofollow"]},"children":[{"type":"text","value":"Playables API"}]},{"type":"text","value":" to control "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" with animation playables, therefore utilizing "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Animator"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AnimationClip"}]},{"type":"text","value":" instead of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":"."}]}]},{"type":"element","tag":"h2","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"pre","props":{"code":"        protected Rect SafeAreaRelative\n            => NotchSolutionUtility.ShouldUseNotchSimulatorValue ? storedSimulatedSafeAreaRelative : NotchSolutionUtility.ScreenSafeAreaRelative;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected Rect SafeAreaRelative\n            => NotchSolutionUtility.ShouldUseNotchSimulatorValue ? storedSimulatedSafeAreaRelative : NotchSolutionUtility.ScreenSafeAreaRelative;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看这句,如果是使用了模拟器,则使用simulatedSafeAreaRelative"}]},{"type":"element","tag":"pre","props":{"code":"        void INotchSimulatorTarget.SimulatorUpdate(Rect simulatedSafeAreaRelative, Rect[] simulatedCutoutsRelative)\n        {\n            this.storedSimulatedSafeAreaRelative = simulatedSafeAreaRelative;\n            this.storedSimulatedCutoutsRelative = simulatedCutoutsRelative;\n            UpdateRectBase();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        void INotchSimulatorTarget.SimulatorUpdate(Rect simulatedSafeAreaRelative, Rect[] simulatedCutoutsRelative)\n        {\n            this.storedSimulatedSafeAreaRelative = simulatedSafeAreaRelative;\n            this.storedSimulatedCutoutsRelative = simulatedCutoutsRelative;\n            UpdateRectBase();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Editor代码中如果改变了模拟器的环境.则会更改该值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而生产环境中则会使用NotchSolutionUtility.ScreenSafeAreaRelative,他也是通过Screen.safeArea进行判断的"}]},{"type":"element","tag":"pre","props":{"code":"        internal static Rect ScreenSafeAreaRelative\n        {\n            get\n            {\n                Rect absolutePaddings = Screen.safeArea;\n                cachedScreenSafeAreaRelative = ToScreenRelativeRect(absolutePaddings);\n                cachedScreenSafeArea = absolutePaddings;\n                safeAreaRelativeCached = true;\n                return cachedScreenSafeAreaRelative;\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        internal static Rect ScreenSafeAreaRelative\n        {\n            get\n            {\n                Rect absolutePaddings = Screen.safeArea;\n                cachedScreenSafeAreaRelative = ToScreenRelativeRect(absolutePaddings);\n                cachedScreenSafeArea = absolutePaddings;\n                safeAreaRelativeCached = true;\n                return cachedScreenSafeAreaRelative;\n            }\n        }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"safepadding"},"children":[{"type":"text","value":"safepadding"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"原理","depth":2,"text":"原理"},{"id":"safepadding","depth":2,"text":"safepadding"}]}},"_type":"markdown","_id":"content:unity:2020-08-29-Notch-Solution.md","_source":"content","_file":"unity/2020-08-29-Notch-Solution.md","_extension":"md","date":"2020-08-29"},{"_path":"/unity/2020-08-30-unity-dll-check","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity 项目dll检查","description":"全部的\nshared模块+contract模块+Odin模块+Json模块+dothassunity模块\nshared模块+contract模块+Odin模块+Json模块\nshared模块+contract模块+Odin模块\nshared模块+contract模块\n只有shared模块空项目\n我们看到包含了form等模块c# - Can I remove System.Windows.Forms.dll referenced by protobuf-net - Stack Overflow (stackoverflow.com)不过不用担心,使用il2cpp都会被切割","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"全部的\n"},{"type":"element","tag":"img","props":{"alt":"Snipaste_2020-08-30_02-12-13","src":"/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-12-13.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"shared模块+contract模块+Odin模块+Json模块+dothassunity模块\n"},{"type":"element","tag":"img","props":{"alt":"Snipaste_2020-08-30_02-16-34--noentity-no-p","src":"/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"shared模块+contract模块+Odin模块+Json模块\n"},{"type":"element","tag":"img","props":{"alt":"Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity","src":"/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"shared模块+contract模块+Odin模块\n"},{"type":"element","tag":"img","props":{"alt":"Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json","src":"/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"shared模块+contract模块\n"},{"type":"element","tag":"img","props":{"alt":"Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin","src":"/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只有shared模块"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin-no-contract","src":"/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin-no-contract.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"空项目\n"},{"type":"element","tag":"img","props":{"alt":"none","src":"/images/2020-08-30-unity-dll-check/none.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到包含了form等模块"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://stackoverflow.com/questions/39161798/can-i-remove-system-windows-forms-dll-referenced-by-protobuf-net","rel":["nofollow"]},"children":[{"type":"text","value":"c# - Can I remove System.Windows.Forms.dll referenced by protobuf-net - Stack Overflow (stackoverflow.com)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过不用担心,使用il2cpp都会被切割"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-08-30-unity-dll-check.md","_source":"content","_file":"unity/2020-08-30-unity-dll-check.md","_extension":"md","date":"2020-08-30"},{"_path":"/unity/2020-09-05-unity-vsynccount","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY的垂直同步和帧率","description":"在显示一帧画面时，显卡先从显示缓冲取数据刷新到显示器存储器上，然后，显示器从左上到右下，逐行显示到屏幕上。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"垂直同步"},"children":[{"type":"text","value":"垂直同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在显示一帧画面时，显卡先从显示缓冲取数据刷新到显示器存储器上，然后，显示器从左上到右下，逐行显示到屏幕上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显示器每画完一行发出一个水平同步信号，画完所有行发出一个垂直同步信号。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若显示器刷新率是75，那么发出一个垂直同步信号后会等待1/75秒，然后重新执行上述步骤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏中的开启垂直同步，意思是指显卡等待到一个垂直同步信号后才开始工作，向显示缓冲绘制数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们选择等待垂直同步信号（也就是我们平时所说的垂直同步打开），那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，显卡无法绘制下一屏，只有等75单位的信号到达，才可以绘制。这样FPS自然要受到操作系统刷新率运行值的制约。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而如果我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），那么游戏中作完一屏画面，显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。取消了垂直同步信号，固然可以换来更快的速度，但是在图像的连续性上势必打折扣。这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"开启垂直同步时"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若游戏的实际显示帧速大于60，显卡就可以在显示器等待的1/60内完成绘制，显示一个无撕裂的画面。此时，游戏的帧速被限制为60。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若游戏的实际显示帧速小于60，显卡无法在在显示器等待的1/60内完成绘制，假如游戏帧速50，那么显卡每2个显示器帧才向显示器刷新一次数据，此时，游戏帧速掉为30。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关闭垂直同步时"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若游戏的实际显示帧速大于60，显卡刷新显示缓冲的速度比显示器快，出现跳帧以及撕裂。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（1）画面撕裂"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设游戏中有一面黑白相间的栅栏墙高速向左运动，显示器设定的刷新率是100Hz，游戏运行速度为200FPS，则显示器扫描第1帧图像至屏幕垂直方向中点时，显卡已经将第2帧图像送了过来，由于栅栏墙高速向左运动，第2帧图像已经左移了一段距离，最终显示的图像如图（图01）。"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"![获得完美游戏效果解析显卡垂直同步设置(/images/2020-09-05-unity-vSyncCount/1520729748.JPG)"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"图1"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CS 1.5、Quake等大多数PC游戏在关闭垂直同步后都会有这种现象产生。如果你的电脑上装有CS 1.5游戏，不妨自己证实一下：关闭垂直同步后进入游戏，按下键盘上的左箭头\"←\"让视角匀速转动，是不是看到了\"画面撕裂\"的现象？打开垂直同步后做相同的测试，画面是不是清爽了许多？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（2）跳帧"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如显示器设定的刷新率是80Hz，显卡以100FPS循环显示0-9数字，那么，在开始的0.1秒内，显卡显示了10个数字而显示器只刷新了8次，最终你看到的图像很可能是这样的：（表格如图02）\n可见，由于显示器刷新率跟不上游戏的FPS，只能舍弃一部分画面，这种现象表现在游戏里就是跳帧。鬼武者3等一些移植到PC上的游戏在关闭垂直同步时通常会出现这种问题。"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"![获得完美游戏效果解析显卡垂直同步设置(/images/2020-09-05-unity-vSyncCount/1536901270.JPG)"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"图2"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过以上的了解，我们认识到，要想在游戏中获得更好的画质，垂直同步一定要开！正是由于垂直同步的存在，游戏才会有完整、稳速、不跳帧的画面。套用一句广告语来说：\"自从开了垂直同步后，画不破了，帧不跳了，头也不眩晕了。\""}]},{"type":"element","tag":"h1","props":{"id":"省电发热优化"},"children":[{"type":"text","value":"省电发热优化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你的游戏跑到60帧,手机很热..这个时候首先想到的是降低帧率,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安卓上:"}]},{"type":"element","tag":"pre","props":{"code":"1. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 0 关闭垂直同步..手动设置帧率..    Application.targetFrameRate = 30;  注意这样可能出现跳帧\n2. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 1 这个时候 Application.targetFrameRate无效...每帧等待垂直同步\n3. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 2 这个时候 Application.targetFrameRate无效...每一秒内等待垂直同步??不好翻译..大概意思是如果平台的默认渲染速率是每秒60帧，而vSyncCount设置为2，则游戏将以每秒30帧为目标。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"1. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 0 关闭垂直同步..手动设置帧率..    Application.targetFrameRate = 30;  注意这样可能出现跳帧\n2. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 1 这个时候 Application.targetFrameRate无效...每帧等待垂直同步\n3. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 2 这个时候 Application.targetFrameRate无效...每一秒内等待垂直同步??不好翻译..大概意思是如果平台的默认渲染速率是每秒60帧，而vSyncCount设置为2，则游戏将以每秒30帧为目标。\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iOS:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"iOS忽略"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html","rel":["nofollow"]},"children":[{"type":"text","value":"QualitySettings"}]},{"type":"text","value":".vSyncCount,ios是根据vblank(垂直同步)显示帧(如果有的话)..他的意思就是如果ios的垂直同步是每秒60帧...在刷新垂直同步的时候,如果存在显卡的帧的时候则会显示帧..不存在.则不显示...所以 Application.targetFrameRate是起作用的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上仅参考文档推测...未进行验证....如有意外概不负责"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/2020.2/Documentation/ScriptReference/Application-targetFrameRate.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Scripting API: Application.targetFrameRate (unity3d.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings-vSyncCount.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Scripting API: QualitySettings.vSyncCount (unity3d.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-09-05-unity-vSyncCount.md","_source":"content","_file":"unity/2020-09-05-unity-vSyncCount.md","_extension":"md","date":"2020-09-05"},{"_path":"/unity/2020-09-10-optimizing-for-performance","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY性能优化流程","description":"首先第一部分.我们要注意在平时工作中需要注意哪些地方养成一套流程规范.避免出现已经被总结出来的问题","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"资源检查"},"children":[{"type":"text","value":"资源检查"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先第一部分.我们要注意在平时工作中需要注意哪些地方养成一套流程规范.避免出现已经被总结出来的问题"}]},{"type":"element","tag":"h2","props":{"id":"代码"},"children":[{"type":"text","value":"代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 的垃圾收集（使用 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Boehm_garbage_collector","rel":["nofollow"]},"children":[{"type":"text","value":"Boehm GC 算法"}]},{"type":"text","value":"）是非分代的，也是非压缩的。“非分代”意味着 GC 在执行每遍收集时必须扫描整个堆，因此随着堆的扩展，其性能会下降。“非压缩”意味着不会为内存中的对象重新分配内存地址来消除对象之间的间隙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-10-optimizing-for-performance/UnderstandingPerformanceinUnity-AssetAuditingSection_image_1.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图为内存碎片化示例。释放对象时，将释放其内存。但是，释放的空间"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不会"}]},{"type":"text","value":"整合成为整个“可用内存”池的一部分。位于释放的对象两侧的对象可能仍在使用中。因此，释放的空间成为其他内存段之间的“间隙”（该间隙由上图中的红色圆圈指示）。因此，新释放的空间仅可用于存储与释放相同大小或更小的对象的数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分配对象时，请注意对象在内存空间中的分配地址必须始终为连续空间块。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这导致了内存碎片化这个核心问题：虽然堆中的可用空间总量可能很大，但是可能其中的部分或全部的可分配空间对象之间存在小的“间隙”。这种情况下，即使可用空间总量高于要分配的空间量，托管堆可能也找不到足够大的连续内存块来满足该分配需求。"}]},{"type":"element","tag":"h3","props":{"id":"cpu"},"children":[{"type":"text","value":"CPU"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unity 不使用字符串名称对 Animator、Material 和 Shader 属性进行内部寻址。为了加快速度，所有属性名称都经过哈希处理为属性 ID，实际上正是这些 ID 用于寻址属性。"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Animator.StringToHash.html","rel":["nofollow"]},"children":[{"type":"text","value":"Animator.StringToHash"}]},{"type":"text","value":" 是用于 Animator 属性名称的对应 API，"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Shader.PropertyToID.html","rel":["nofollow"]},"children":[{"type":"text","value":"Shader.PropertyToID"}]},{"type":"text","value":" 是用于 Material 和 Shader 属性名称的对应 API。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.RaycastAll.html","rel":["nofollow"]},"children":[{"type":"text","value":"RaycastAll"}]},{"type":"text","value":" 调用替换为 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.RaycastNonAlloc.html","rel":["nofollow"]},"children":[{"type":"text","value":"RaycastNonAlloc"}]},{"type":"text","value":"，将 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.SphereCastAll.html","rel":["nofollow"]},"children":[{"type":"text","value":"SphereCastAll"}]},{"type":"text","value":" 调用替换为 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.SphereCastNonAlloc.html","rel":["nofollow"]},"children":[{"type":"text","value":"SphereCastNonAlloc"}]},{"type":"text","value":"，以此类推。对于 2D 应用程序，也存在所有 Physics2D 查询 API 的非分配版本。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"请避免在紧凑循环中或每帧运行的代码中进行UnityEngine.Object 子类和 Null 比较。Il2cpp中此过程必须执行查找和验证以便将脚本引用转换为对原生代码的引用。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"整数数学比浮点数学更快，而浮点数学比矢量、矩阵或四元数运算更快。每当交换或关联算术允许时，请尝试最小化单个数学运算的成本"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最好完全避免在生产代码中使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Object.Find"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Object.FindObjectOfType"}]},{"type":"text","value":"。还有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Camera.main"}]},{"type":"text","value":"也使用了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"FindGameObjectsWithTag"}]},{"type":"text","value":",由于此类 API 要求 Unity 遍历内存中的所有游戏对象和组件，因此它们会随着项目规模的扩大而产生性能问题。(除了单例,因为有缓存)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在紧凑循环中尽量少用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"属性(get,set)"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"方法"}]},{"type":"text","value":",调用的每个方法都必须在内存中找到该方法的地址，并将另一个帧推入栈。所有这些操作都是有成本的，但在大多数代码中，它们都小到可以忽略不计.但是，在紧凑循环中运行较小的方法时，因引入额外方法调用而增加的开销可能会变得非常显著，甚至占主导地位。.例如"},{"type":"element","tag":"pre","props":{"code":"int Accum { get; set; }\nAccum = 0;\n\nfor(int i = 0;\n       i < myList.Count;    // myList.Count 调用 Count 属性上的 get 方法\n       i++) {\n    Accum       // 通过 set 将加法运算的结果分配给 Accum\n+=      // 通过 get 检索 Accum 的当前值，以便将其传递给加法运算\nmyList[i];  // [] 运算符调用列表的 get_Value 方法来检索列表特定索引位置的项值。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"int Accum { get; set; }\nAccum = 0;\n\nfor(int i = 0;\n       i < myList.Count;    // myList.Count 调用 Count 属性上的 get 方法\n       i++) {\n    Accum       // 通过 set 将加法运算的结果分配给 Accum\n+=      // 通过 get 检索 Accum 的当前值，以便将其传递给加法运算\nmyList[i];  // [] 运算符调用列表的 get_Value 方法来检索列表特定索引位置的项值。\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"移除空的MonoBehaviour方法start update awake..理由同上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要在运行时使用AddComponent将组件添加到GameObjects可能是一项非常昂贵的操作。因为他会先看组件有没有DisallowMultipleComponent的设置,然后又重复上述的检查一次最后还需要调用所有被加入的monobehaviour的awake方法,这些所有步骤都发生在堆内存上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要使用Texture2D.SetPixels() ,使用Texture2D.SetPixels32() 或者 GetRawTextureData()/Apply() 代替"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尽量避免调用Object.Instantiate再经常更新的代码。这里可以使用poolmanager代替"}]}]},{"type":"element","tag":"h3","props":{"id":"gpu"},"children":[{"type":"text","value":"GPU"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"meshreander->lighting -> cast shadows关闭阴影投射"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尽可能少的light,然后只对特定曾有用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"过高的分辨率会造成手机发热..可以使用Screen.SetResolution(width,height,false)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"启用GPU实例化,"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/Manual/GPUInstancing.html","rel":["nofollow"]},"children":[{"type":"text","value":"GPU 实例化 - Unity 手册 (unity3d.com)"}]}]}]},{"type":"element","tag":"h3","props":{"id":"ui"},"children":[{"type":"text","value":"UI"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将对象隐藏起来,而不是移动到屏幕外边..因为摄像机依然能看到这些对象,依然会被渲染"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果UI元素改变数值或是位置,会影响批次处理,造成对Gpu发送更多drawcall,所以将更新频率不同的ui分再不同的画布上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同张画布中的ui元素要有一样的z值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ui元素必须拥有一样的材质和纹理"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对象拥有一样的clipping rect(矩形裁剪范围)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"去掉不需要的Graphic Raycaster,每次当用户点击触发事件时,系统就会遍历所有可能接收输入事件的ui元素,这会造成多次\"点落再矩形中\"检查,来判断对象是否该做出反应"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果打开了全屏ui,把渲染3d场景的摄像机关掉"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果打开了全屏ui,隐藏其他被遮蔽的ui,如果可以,建议你关闭canvas组件,而不是游戏对象本身,这样能减少画布再次出现的时间.禁用canvase组件会阻止画布向Gpu发起绘图调用,所以该画布不再可见,然后,此时该画布不会丢弃它的顶点缓冲区,它会保留所有网格和顶点,当重新启用时,不会触发重构过程,它只会重新绘制画布内容.此外禁用canvas组件不会触发canvas层级上性能消耗较大的ondisable/onenable回调,禁用子组件时要小心,注意它是否运行性能消耗较大的每帧代码."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尽可能的降低帧率,如果有个静态的ui,就没有必要设置帧率到60"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果texture是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用Empty4Raycast代替空的image"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要使用ugui的outline和shadow,他时把原来的顶点copy多份进行实现的..可以使用shader进行实现"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"mask会增加一个drawcall,并且mask里面的图片不会和外面的图片合批,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Scroll Rect 组件对应的Content填加 Canvas 组件 ，因为对应的Mask 子元素依然参与全局的Depth排序，避免因拖动打乱原有的Depth排序，造成合批失败"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尽量不要使用layout,因为会从变动节点递归向上调用GetComponents"}]}]},{"type":"element","tag":"h4","props":{"id":"图集整理"},"children":[{"type":"text","value":"图集整理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么使用图集?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"图片尺寸为2的次幂时，GPU处理起来会快很多，小图自己是做不到每张图都是2的次幂的，但打成一张大图就可以（浪费一点也无所谓）；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CPU在传送资源信息给GPU时，只需要传一张大图就可以了，因为GPU可以在这张图中的不同区域进行采样，然后拼出对应的界面。注意，这就是为什么需要用同一个Source Image图集的原因，是Batch的关键，因为一个Drawcall就把所有原材料传过去了，GPU你画去吧"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是显然把所有图片打成一张图集是不合理的，因为这张图可能非常大，所以就要按照一定规则将图片进行分类。在分类思路上，我们希望做到Drawcall尽可能少，同时资源量也尽可能少（多些重用），但这两者某种程度上是互斥的，所以折衷一下，可以遵循以下思路："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设计UI时要考虑重用性，如一些边框、按钮等，这些作为共享资源，放在1~3张大图集中，称为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"重用图集"}]},{"type":"text","value":"；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其它非重用UI按照功能模块进行划分，每个模块使用1~2张图集，为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"功能图集"}]},{"type":"text","value":"；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于一些UI，如果同时用到"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"功能图集"}]},{"type":"text","value":"与"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"重用图集"}]},{"type":"text","value":"，但是其"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"功能图集"}]},{"type":"text","value":"剩下的“空位”较多，则可以考虑将用到的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"重用图集"}]},{"type":"text","value":"中的元素单独拎出来，合入"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"功能图集"}]},{"type":"text","value":"中，从而做到让UI只依赖于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"功能图集"}]},{"type":"text","value":"。也就是通过一定的冗余，来达到性能的提升。"}]}]},{"type":"element","tag":"h4","props":{"id":"ugui层级合并规则与批次生成规则"},"children":[{"type":"text","value":"UGUI层级合并规则与批次生成规则"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI的层叠顺序是按照Hierarchy中的顺序从上往下进行的，也就是越靠上的组件，就会被画在越底部。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以UI就是这样一层一层地叠上去画出来的。当然这样一个一个地画效率肯定是不能接受的，所以要合并，要Batch，Unity自身就提供了一个算法去决定哪些层应该合并到一起，并以什么样的顺序进行绘制。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"所有相邻层的可Batch的UI元素将会在一个Drawcall完成"}]},{"type":"text","value":"。接下来就来讨论一下Unity的层级合并与计算算法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity的UI渲染顺序的确定有2个步骤，第一步计算每个UI元素的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"；第二步合并相同"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"中可以Batch的元素作为一个"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"批次"}]},{"type":"text","value":"，并对"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"批次"}]},{"type":"text","value":"进行排序；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先从直观的角度来解释"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"计算层级号的算法"}]},{"type":"text","value":"："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有一个UI元素，它所占的屏幕范围内（通常是矩形），"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果没有任何UI在它的底下，那么它的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"就是0（最底下）；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有一个UI在其底下且该UI可以和它Batch，那它的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"与底下的UI层级一样；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有一个UI在其底下但是无法与它Batch，那它的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"为底下的UI的层级+1；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有多个UI都在其下面，那么按前两种方式遍历计算所有的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"，其中最大的那个作为自己的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里也给一下伪代码，假设所有UI元素（抛弃层级关系）都按从上往下的顺序被装在一个list中，那么每个UI元素对应的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级号"}]},{"type":"text","value":"计算可以参考以下："}]},{"type":"element","tag":"pre","props":{"code":"function CalLayer(List UIEleLst)\n  if(UIEleLst.Count == 0 ) return;\n  //Initial the first UI Element as layer 0\n  UIEleLst[0].layer = 0;\n  for(i = 1 ~ UIEleLst.Count){\n    var IsCollideWithElements = false; \n    //Compare with all elements beneath\n    for(j = i-1 ~ 0){\n      //If Element-i collide with Element-j\n      if(UIEleLst[i].Rect.CollideWith(UIEleLst[j].Rect)){\n        IsCollideWithElements = true;\n        //If Element-i can be batched with Element-j, same layer as Element-j\n        if(UIEleLst[i].QualifyToBatchWith(UIEleLst[j])){\n          UIEleLst[i].layer = UIEleLst[j].layer;\n        }\n        else{\n          //Or else the layer is larger \n          UIEleLst[i].layer = UIEleLst[j].layer + 1;\n        }\n      }\n    }\n    //If not collide with any elements beneath, set layer to 0\n    if(!IsCollideWithElements)\n    {\n      UIEleLst[i].layer = 0;\n    }\n  }\n\n \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"function CalLayer(List UIEleLst)\n  if(UIEleLst.Count == 0 ) return;\n  //Initial the first UI Element as layer 0\n  UIEleLst[0].layer = 0;\n  for(i = 1 ~ UIEleLst.Count){\n    var IsCollideWithElements = false; \n    //Compare with all elements beneath\n    for(j = i-1 ~ 0){\n      //If Element-i collide with Element-j\n      if(UIEleLst[i].Rect.CollideWith(UIEleLst[j].Rect)){\n        IsCollideWithElements = true;\n        //If Element-i can be batched with Element-j, same layer as Element-j\n        if(UIEleLst[i].QualifyToBatchWith(UIEleLst[j])){\n          UIEleLst[i].layer = UIEleLst[j].layer;\n        }\n        else{\n          //Or else the layer is larger \n          UIEleLst[i].layer = UIEleLst[j].layer + 1;\n        }\n      }\n    }\n    //If not collide with any elements beneath, set layer to 0\n    if(!IsCollideWithElements)\n    {\n      UIEleLst[i].layer = 0;\n    }\n  }\n\n \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有了层级号之后，就要"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"合并批次"}]},{"type":"text","value":"了，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此时，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"批次"}]},{"type":"text","value":"，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"目前已知的排序规则是，Text组件会排在Image组件之前渲染"}]},{"type":"text","value":"，而同一类组件的情况下排序规则未知（好像并没什么规则）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"经过以上排序，就可以得到一个有序的批次序列了"}]},{"type":"text","value":"。这时，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子，一个层级为0的ImageA，一个层级为1的ImageB（2个Image可Batch）和一个层级为0的TextC，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity排序后的批次为TextC->ImageA->ImageB，后两个批次可以合并，所以是2个Drawcall。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再举个栗子，一个层级为0的TextD，一个层级为1的TextE（2个Text可Batch）和一个层级为0的ImageF，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity排序后的批次为TextD->ImageF->TextE，这时就需要3个Drawcall了！（是不是有点晕，再回顾下黑体字）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下的伪代码有些偷懒，实在懒得写排序、合并之类的，一长串也不好读，几个步骤列一下，其它诸位看上面那段文字脑补下吧..."}]},{"type":"element","tag":"pre","props":{"code":"function MergeBatch(List UIEleLst)\n{\n  //Order the UI Elements by their layers and batch-keys, \n  //batch-key is a combination of its component type, \n  //texture and material info\n  UIEleLst.OrderBy(\n   (uiElement)=>{return this.layer > uiElement.layer\n   || this.BatchKey() > uiElement.BatchKey()} \n  );\n\n  //Merge the UI Elements with same layer and batch-key as a batch\n  var BatchLst = UIEleLst.MergeSameElementsAsBatch();\n\n  //Make adjacent batches with same batch-key merged\n  BatchLst.MergeAdjacentBatches();\n\n  return BatchLst;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"function MergeBatch(List UIEleLst)\n{\n  //Order the UI Elements by their layers and batch-keys, \n  //batch-key is a combination of its component type, \n  //texture and material info\n  UIEleLst.OrderBy(\n   (uiElement)=>{return this.layer > uiElement.layer\n   || this.BatchKey() > uiElement.BatchKey()} \n  );\n\n  //Merge the UI Elements with same layer and batch-key as a batch\n  var BatchLst = UIEleLst.MergeSameElementsAsBatch();\n\n  //Make adjacent batches with same batch-key merged\n  BatchLst.MergeAdjacentBatches();\n\n  return BatchLst;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据以上规则，就可以得出一些“摆UI”的技巧："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"有相同材质和纹理的UI元素是可以Batch的，可以Batch的UI上下叠在一块不会影响性能，但是如果不能Batch的UI元素叠在一块，就会增加Drawcall开销。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要注意UI元素间的层叠关系，建议用“T”工具查看其矩形大小，因为有些图片透明，但是却叠在其它UI上面了，然后又无法Batch的话，就会无故多许多Drawcall；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UI中出现最多的就是Image与Text组件，当Text叠在Image上面（如Button)，然后Text上又叠了一个图片时，就会至少多2个Drawcall，可以考虑将字体直接印在下面的图片上；"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"有些情况可以考虑人为增加层级从而减少Drawcall，比如一个Text的层级为0，另一个可Batch的Text叠在一个图片A上，层级为1，那此时2个Text因为层级不同会安排2个Drawcall，但如果在第一个Text下放一个透明的图片（与图片A可Batch），那两个Text的层级就一致了，Drawcall就可以减少一个。"}]}]},{"type":"element","tag":"h4","props":{"id":"ui优化参考"},"children":[{"type":"text","value":"UI优化参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/061e67308e5f","rel":["nofollow"]},"children":[{"type":"text","value":"Unity GUI(uGUI)使用心得与性能总结 - 简书 (jianshu.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://unity3d.com/how-to/unity-ui-optimization-tips?_ga=2.147783095.1436155110.1558584716-746267689.1557026511","rel":["nofollow"]},"children":[{"type":"text","value":"Some of the best optimization tips for Unity UI - Unity (unity3d.com)"}]}]}]},{"type":"element","tag":"h3","props":{"id":"内存"},"children":[{"type":"text","value":"内存"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要再update中重复实例化对象,使用了ecs同样注意,因为他也是执行在update中"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要使用闭包和匿名方法,因为闭包和匿名方法都会都是引用类型(c#将生成一个匿名类)会在堆上进行分配"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"避免装箱..虽然 Unity 的分配器实际会使用不同的内存池进行小型和大型分配，但 Unity 的垃圾回收器“不是”分代的，因此无法有效清除由装箱生成的小型、频繁的临时分配。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要用foreach, Unity 的 C# 编译器生成的 IL 会构造一个通用值类型的枚举器来遍历值集合,而且通过枚举器遍历集合的方法调用成本更高，通常比通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"for"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"while"}]},{"type":"text","value":" 循环进行的手动迭代慢得多。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"unityapi.. mesh.vertices和 Input.touches,每次访问 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".touches"}]},{"type":"text","value":" 这些属性时都会发生分配。所以不要在循环和update中使用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"避免使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetComponentsInChildren()"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetComponentsInParent()"}]},{"type":"text","value":",而是使用GetComponentsInChildren(bool includeInactive, List result);前者会分配托管内存,后者可以传入一个你保存的数组避免重新分配"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要使用linq因为会分配大量的托管内存"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要使用Texture2D.GetPixels() ,使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Texture2D.GetRawTextureData()"}]},{"type":"text","value":"代替此方法返回像素数据的NativeArray,前者会有大量的托管内存"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考 :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html","rel":["nofollow"]},"children":[{"type":"text","value":"了解托管堆 - Unity 手册 (unity3d.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/Manual/UnderstandingAutomaticMemoryManagement.html","rel":["nofollow"]},"children":[{"type":"text","value":"了解自动内存管理 - Unity 手册 (unity3d.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/Manual/BestPracticeUnderstandingPerformanceInUnity7.html","rel":["nofollow"]},"children":[{"type":"text","value":"一般优化 - Unity 手册 (unity3d.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/BV1Tt4y1X7f6","rel":["nofollow"]},"children":[{"type":"text","value":"Unite Now - （中文字幕）性能优化技巧（上）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili"}]}]}]},{"type":"element","tag":"h2","props":{"id":"资源"},"children":[{"type":"text","value":"资源"}]},{"type":"element","tag":"h3","props":{"id":"animation"},"children":[{"type":"text","value":"Animation"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度Custom Parameters: precision : 5"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调小。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。"}]}]},{"type":"element","tag":"h3","props":{"id":"audio"},"children":[{"type":"text","value":"Audio"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果不需要立体声,将音频文件设置为 Force To Mono,这样能省下一半的磁盘和内存"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"降低文件比特率"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ios下使用adpcm和mp3格式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"安卓下使用vorbis格式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果小型文件<200kb,load type设置成Decompress on Load,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果中型文件>=200kb,load type 设置成Compressed in Memory"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"大型文件,如背景音乐,load type设置成streaming"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果时静音模式则销毁audiosourceComponent组件,如果设置成0的话,其实还是会造成不必要的内存与cpu占用"}]}]},{"type":"element","tag":"h3","props":{"id":"editorsetting"},"children":[{"type":"text","value":"EditorSetting"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"禁用 Accelerometer Frequency 陀螺仪"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尝试开启graphicJobs并测试 检查Editor -> Project Settings -> PlayerSettings -> Graphic Jobs(Experimental)*的设置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项 检查Editor -> Project Settings -> PlayerSettings -> PreBake Collision Meshes的设置,这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上,这会增加CPU的负担, 应该取消勾选那些没有必要的格子 检查Editor -> Project Settings -> Physics -> Layer Collision Matrix的设置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上 同上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查Graphics中StandardShaderQuality设置,这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备,检查Editor -> Project Settings -> Graphics -> Tiers -> Standard Shader Quality的设置,StandardShaderQuality选项在所有Graphics Tier中应相同"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查Android的ManagedStrippingLevel设置 检查Editor -> Project Settings -> PlayerSettings -> Managed Stripping Level的设置,Android设置中的ManagedStrippingLevel选项应为Medium或者High"}]}]},{"type":"element","tag":"h3","props":{"id":"mesh"},"children":[{"type":"text","value":"Mesh"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开启mesh compression,来减少磁盘容量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"尽量关闭read/write enabled 选项,如果开启unity会存储两份mesh"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果没有使用动画,关闭Rigs,如石头或者房子"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果没有用到Blendshapes,ye关闭"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Normals and Tangents..法向量和切线信息,如果材质没用到.也关闭"}]}]},{"type":"element","tag":"h3","props":{"id":"prefab"},"children":[{"type":"text","value":"Prefab"}]},{"type":"element","tag":"h3","props":{"id":"scene"},"children":[{"type":"text","value":"Scene"}]},{"type":"element","tag":"h3","props":{"id":"texture"},"children":[{"type":"text","value":"Texture"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"导入大小需要设置maxsize和compression,否则将导致文件过大.打包的时候会占体积"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"max size 尽可能的设置到最小"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"pot(大小为2的幂次方) or atlas"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"移除背景纹理和其他不透明纹理的alpha通道"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关闭read/write,以减少内存使用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果16bit color足够用了就不要使用 32bit"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果不需要使用mipmaps 则禁用,例如 ui和sprites,或者相对于z值不会又任何变化的元素"}]}]},{"type":"element","tag":"h3","props":{"id":"resources文件夹"},"children":[{"type":"text","value":"Resources文件夹"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"尽量不要使用resources文件夹.它会打包到包体中.且在启动时会全部加载.."}]},{"type":"element","tag":"h2","props":{"id":"assetbundle"},"children":[{"type":"text","value":"AssetBundle"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"资源包冗余检测"}]},{"type":"element","tag":"h1","props":{"id":"工具检测"},"children":[{"type":"text","value":"工具检测"}]},{"type":"element","tag":"h2","props":{"id":"drawcall"},"children":[{"type":"text","value":"DrawCall"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一、什么是DrawCall？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    在unity中，每次CPU准备数据并通知GPU的过程就称之为一个DrawCall。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"​    具体过程就是：设置颜色-->绘图方式-->顶点坐标-->绘制-->结束，所以在绘制过程中，如果能在一次DrawCall完成所有绘制就会大大提高运行效率，进而达到优化的目的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"二、DrawCall为什么会影响游戏运行效率？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说道为什么会影响效率，就首先要了解一下他的工作原理：为了CPU和GPU可以进行并行工作，就需要一个命令缓冲区，就是由CPU向其中添加命令，然后又GPU从中读取命令，这样就实现了通过CPU准备数据，通知GPU进行渲染。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在每次调用DrawCall之前，CPU需要向GPU发送很多内容，主要是包括数据，渲染状态（就是设置对象需要的材质纹理等），命令等。CPU进行的操作具体就是："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"准备渲染对象，然后将渲染对象从硬盘加载到内存，然后从内存加载到显存，进而方便GPU高速处理"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"设置每个对象的渲染状态，也就是设置对象的材质、纹理、着色器等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"输出渲染图元，然后向GPU发送DrawCall命令，并将渲染图元传递给GPU"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以如果DrawCall数量过多就会导致CPU进行大量计算，进而导致CPU的过载，影响游戏运行效率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"三、批处理"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"批处理的目的就是为了减少DrawCall。DrawCall即CPU命令GPU去绘制。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果我们需要渲染一千个三角形，那么把它们按一千个单独的网格进行渲染所花费的时间要远大于直接渲染一个包含了一千个三角形的网格。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要想使用批处理，需要物体有相同的材质。这是因为，对于使用同一个材质的物体，它们的不同仅仅在于顶点数据的差别，我们可以把这些顶点数据合并在一起，再一起发送给GPU，就可以完成一次批处理。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在unity中，有两种批处理：一是动态批处理，二是静态批处理。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于动态批处理，unity会自动完成，不需要我们进行操作，而且物体是可以移动的，但是动态批处理有许多限制条件。\n对于静态批处理，物体不可移动，但是限制条件很少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"四、动态批处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给GPU，然后使用同一个材质对其渲染。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"限制："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"顶点属性要小于900。例如，如果shader中需要使用顶点位置、法线和纹理坐标这三个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。因此，优化策略就是shader的优化，少使用顶点属性，或者模型顶点数要尽可能少。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多Pass的shader会中断批处理。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在unity5中，动态批处理对于模型缩放的限制已经不存在了。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用光照纹理的物体需要小心处理。为了让这些物体可以被动态批处理，需要保证它们指向光照纹理中的同一位置。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"五、静态批处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原理：只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格中，这意味着这些模型数据不可以在运行时刻被移动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"优点：因为它只需要进行一次合并操作，因此比动态批处理更加高效。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"缺点：需要占用更多的内存来存储合并后的几何结构。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"操作：将Inspector面板右上角的Static勾选(实际上只需要勾选Batching Static即可)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考链接:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://connect.unity.com/p/dong-tai-he-pi-yuan-li-ji-ru-he-cheng-gong-he-pi?app=true","rel":["nofollow"]},"children":[{"type":"text","value":"动态合批原理及如何成功合批 - Unity Connect"}]}]}]},{"type":"element","tag":"h2","props":{"id":"渲染统计窗口"},"children":[{"type":"text","value":"渲染统计窗口"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-10-optimizing-for-performance/20160721173928287"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Batches：相当于DrawCall"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Saved by batching：通过批处理节省的DrawCall"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SetPass calls：跟Shader中Pass的数量有关，Pass越多这个越大...它大致代表的是摄像机照射范围内，所有GameObject所包含的Material种类数量。（不完全准确，但是这样说易于理解）。假如有30种material，那这个SetpassCall的数值也会离这个30比较接近。这个值越大，肯定会使draw call 越来越大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"影响DrawCall的因素："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Pass越多DrawCall越大。可以通过FrameDebugger来查看DrawCall，当然也可以用Profiler，但后者不能查看DrawCall的具体情况。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不同材质的物体，无法通过静态批处理减少DC。但是静态批处理可以通过合并网格来提高性能。"}]}]},{"type":"element","tag":"h2","props":{"id":"unity-profiler"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unity Profiler"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-10-optimizing-for-performance/20180715180958140"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在面板的下半部分显示了我们选中的profilers当前帧的详细内容，我们可以通过选择列标题，通过这一列的信息值来排序。\n在CPU usage profiler中的列表题分别为：\nTotal:当前任务的时间消耗占当前帧cpu消耗的时间比例。\nSelf:任务自身时间消耗占当前帧cpu消耗的时间比例。\nCalls:当前任务在当前帧内被调用的次数。\nGC Alloc:当前任务在当前帧内进行过内存回收和分配的次数。   "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"注意每帧都具有20B以上内存分配的选项 。"}]},{"type":"text","value":"\nTime ms:当前任务在当前帧内的耗时总时间。   "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"注意占用5ms以上的选项"}]},{"type":"text","value":"\nSelf ms:当前任务自身(不包含内部的子任务)时间消耗。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Unity 的 CPU 性能分析器中，Overview 表有一个“GC Alloc”列。此列显示了在特定帧中的托管堆上分配的字节数(4)（__注意：__这与给定帧期间临时分配的字节数不同。性能分析器会显示特定帧中分配的字节数，不考虑在后续帧中是否重用了部分/全部已分配的内存）。启用“Deep Profiling”选项后，可以跟踪执行这些分配的方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**Unity Profiler 不会跟踪在主线程之外发生的分配。**因此，“GC Alloc”列不能用于统计用户创建的线程中发生的托管分配。请将代码执行从单独线程切换到主线程以进行调试，或使用 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/ScriptReference/Profiling.Profiler.BeginThreadProfiling.html","rel":["nofollow"]},"children":[{"type":"text","value":"BeginThreadProfiling"}]},{"type":"text","value":" API 在时间轴性能分析器 (Timeline Profiler) 中显示例程。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"代码","depth":2,"text":"代码","children":[{"id":"cpu","depth":3,"text":"CPU"},{"id":"gpu","depth":3,"text":"GPU"},{"id":"ui","depth":3,"text":"UI"},{"id":"内存","depth":3,"text":"内存"}]},{"id":"资源","depth":2,"text":"资源","children":[{"id":"animation","depth":3,"text":"Animation"},{"id":"audio","depth":3,"text":"Audio"},{"id":"editorsetting","depth":3,"text":"EditorSetting"},{"id":"mesh","depth":3,"text":"Mesh"},{"id":"prefab","depth":3,"text":"Prefab"},{"id":"scene","depth":3,"text":"Scene"},{"id":"texture","depth":3,"text":"Texture"},{"id":"resources文件夹","depth":3,"text":"Resources文件夹"}]},{"id":"assetbundle","depth":2,"text":"AssetBundle"},{"id":"drawcall","depth":2,"text":"DrawCall"},{"id":"渲染统计窗口","depth":2,"text":"渲染统计窗口"},{"id":"unity-profiler","depth":2,"text":"Unity Profiler"}]}},"_type":"markdown","_id":"content:unity:2020-09-10-optimizing-for-performance.md","_source":"content","_file":"unity/2020-09-10-optimizing-for-performance.md","_extension":"md","date":"2020-09-10"},{"_path":"/unity/2020-09-11-stack-heap","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"堆栈内存Stack和堆内存Heap","description":"堆与栈：有什么不同？栈，或多或少负责跟踪正在程序中运行的代码。堆，或多或少负责跟踪程序对象或数据。栈，把它想像成叠在一起的盒子(像搭积木一样)。每一次调用一个方法就会在最上面叠一个盒子，用来跟踪程序运行情况。我们只能使用栈中叠在最上面的盒子里的东西。当某一最上面的盒子里的代码执行完毕（如方法执行完成），就把它扔掉并继续去使用下一个盒子。堆，与栈类似，只是它是用来保存信息而不是跟踪执行。所以，堆里的任何信息都可以在任何时间被访问。有了堆，访问信息没有约束，而不像栈只能访问最上面的盒子。堆的情况就像你把一堆刚洗完的衣服放在床上还没有时间来的及收走，你可以迅速拿到你想要拿的衣服。栈的情况就像你叠在一","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"堆与栈有什么不同"},"children":[{"type":"text","value":"堆与栈：有什么不同？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"栈"}]},{"type":"text","value":"，或多或少负责跟踪正在程序中运行的代码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"堆"}]},{"type":"text","value":"，或多或少负责跟踪程序对象或数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"栈，把它想像成叠在一起的盒子(像搭积木一样)。每一次调用一个方法就会在最上面叠一个盒子，用来跟踪程序运行情况。我们只能使用栈中叠在最上面的盒子里的东西。当某一最上面的盒子里的代码执行完毕（如方法执行完成），就把它扔掉并继续去使用下一个盒子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"堆，与栈类似，只是它是用来保存信息而不是跟踪执行。所以，堆里的任何信息都可以在任何时间被访问。有了堆，访问信息没有约束，而不像栈只能访问最上面的盒子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"堆的情况就像你把一堆刚洗完的衣服放在床上还没有时间来的及收走，你可以迅速拿到你想要拿的衣服。栈的情况就像你叠在一起的鞋盒子，你需要拿走最上面的盒子才能拿到下一个盒子。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131125031529515"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图并不上真正的内存运行情况，只是为了让大家区分堆和栈。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"栈，会自我管理，它有自己的内存管理机制。当最上面的盒子不再使用时，会自动被扔掉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"堆，相反，我们要控制它的垃圾回收(GC)。我们要去管理堆是否干净，就像管理床上的脏衣服。你不手动扔掉它，就会在床上变臭。"}]},{"type":"element","tag":"h2","props":{"id":"什么在堆和栈里"},"children":[{"type":"text","value":"什么在堆和栈里"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当程序执行时，我们主要有4种类型的东西放进堆和栈里：值类型，引用类型，指针，指令。"}]},{"type":"element","tag":"h3","props":{"id":"值类型"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"值类型:"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"bool"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"byte"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"char"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"decimal"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"double"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"enum"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"float"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"long"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sbyte"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"short"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"struct"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"uint"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ulong"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ushort"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它们都衍生于System.ValueType。"}]},{"type":"element","tag":"h3","props":{"id":"引用类型"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"引用类型:"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"class"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"interface"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"delegate"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"object"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"string"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它们都衍生于System.Object。当然object就是System.Object。"}]},{"type":"element","tag":"h3","props":{"id":"指针"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"指针:"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第三种被放于内存管理体制中的是类型的引用。这个引用通常被叫作指针。我们并不具体的使用指针，它们由CLR管理。一个指针（引用）是不同于引用类型的。我们定义它是一个引用类型，意味着我们可以通过指针访问它。一个指针占有一小块内存，这块内存指向另一块内存。指针占用在内存中的存储和其它的相同，只是存放的值既不是内存地址也不是空null。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131125034525859"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"两个黄金规则"},"children":[{"type":"text","value":"两个黄金规则"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"引用类型永远存储在堆里。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"值类型"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"指针"}]},{"type":"text","value":"永远存储在它们声明时所在的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"堆"}]},{"type":"text","value":"或"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"栈"}]},{"type":"text","value":"里。"}]}]},{"type":"element","tag":"h2","props":{"id":"栈工作原理"},"children":[{"type":"text","value":"栈工作原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"栈，如第一节所说，在代码运行时负责跟踪每一个线程的所在(什么被调用了)。你可以把它想像成一个线程“状态”，而每一个线程都有它自己的栈。当我们的代码执行一次方法调用，线程开始执行寄存在方法(Method)表里的JIT编译过的指令，并且把该方法的参数存放到当前线程栈里。然后，随着代码的执行每遇见方法中的变量，该变量都会被放到栈的最上面，如此重复把所有变量都放到栈上(当然引用类型只存放指针)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了方便理解，让我们看代码与图例。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行下面的方法："}]},{"type":"element","tag":"pre","props":{"code":"public int AddFive(int pValue)\n{\n    int result;\n    result = pValue + 5;\n    return result;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int AddFive(int pValue)\n{\n    int result;\n    result = pValue + 5;\n    return result;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是栈里发生的情况.  有必要提醒的是，我们现在假设当前代码产生的栈存储会放到所有既有项(栈里已经存储的数据)之上。一旦我们开始执行该方法，方法参数pValue会被放到栈上（以后的文章里会介绍参数传递）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：方法并不存在栈里，图只是为了阐述原理而放的引用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126034830281"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下一步，控制(线程执行方法)被传递到寄存在方法类型表里的AddFive()方法对应的指令集中。如果方法是第一次被触发，会执行JIT编译。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126035529343"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随着方法的执行，栈会分配一块内存给变量result存放。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126035747203"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"方法执行完成，返回result。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126035907203"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"该次任务在栈里所占的所有内存将被清理，仅一个指针被移动到AddFive()开始时所在的可用内存地址上。接着会执行栈里AddFive()下面一个方法（图里看不到）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126040806812"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个例子当中，变量result被放到了栈里。事实上，方法体内每次定义的值类型变量都会被放到栈里。"}]},{"type":"element","tag":"h2","props":{"id":"值类型会存储在堆里"},"children":[{"type":"text","value":"值类型会存储在堆里？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是的，值类型有时候就是会存储在堆里。上一节中介绍的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"黄金规则2:值类型和指针永远存储在它们声明时所在的堆或栈里"}]},{"type":"text","value":"。如果一个值类型不是在方法中定义的，而是在一个引用类型里，那么此值类型将会被放在这个引用类型里并存储在堆上。"}]},{"type":"element","tag":"h2","props":{"id":"代码图例"},"children":[{"type":"text","value":"代码图例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们定义一个引用类型："}]},{"type":"element","tag":"pre","props":{"code":"public class MyInt\n{          \n    public int MyValue;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class MyInt\n{          \n    public int MyValue;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"里面包含一个值类型MyValue。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行下面的方法："}]},{"type":"element","tag":"pre","props":{"code":"public MyInt AddFive(int pValue)\n{\n    MyInt result = new MyInt();\n    result.MyValue = pValue + 5;\n    return result;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public MyInt AddFive(int pValue)\n{\n    MyInt result = new MyInt();\n    result.MyValue = pValue + 5;\n    return result;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就像上一节介绍的一样，线程开始执行此方法，参数pValue将会被放到当前线程栈上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126052252140"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来不同于上一节所介绍的是MyInt是一个引用类型，它将被放到堆上并在栈上放一个指针指向它在堆里的存储。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126052522859"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当AddFive()执行完成后，如上一节所讲栈开始清理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131126052806703"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在是需要C#垃圾回收GC的时候了。当我们的程序所占内存到达临界值时(即将溢出)，我们会需要更多的堆空间，GC就会开始运行。GC停止所有当前运行线程(整体停止)，找到堆里所有主程序不会访问到的对象并删除它们。然后，GC会识别所有堆里剩下的对象并分配内存空间给它们，同时调整堆和栈里指向它们的指针。你可以想像这是非常耗资源的，这会影响到程序的性能。这就是为什么我们需要理解和注意堆栈的使用，进而写出高性能代码。"}]},{"type":"element","tag":"h2","props":{"id":"堆栈原理对代码的影响"},"children":[{"type":"text","value":"堆栈原理对代码的影响"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们使用引用类型时，我们在和指向引用类型的指针打交道，而不是引用类型本身。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们使用值类型时，我们就是在和值类型本身打交道。"}]},{"type":"element","tag":"h3","props":{"id":"代码图例-1"},"children":[{"type":"text","value":"代码图例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设执行方法："}]},{"type":"element","tag":"pre","props":{"code":"public int ReturnValue()\n{\n    int x = new int();\n    x = 3;\n    int y = new int();\n    y = x;      \n    y = 4;         \n    return x;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int ReturnValue()\n{\n    int x = new int();\n    x = 3;\n    int y = new int();\n    y = x;      \n    y = 4;         \n    return x;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们会得到值 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用引用类型："}]},{"type":"element","tag":"pre","props":{"code":"public class MyInt\n{\n    public int MyValue;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class MyInt\n{\n    public int MyValue;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果执行方法："}]},{"type":"element","tag":"pre","props":{"code":"public int ReturnValue2()\n{\n    MyInt x = new MyInt();\n    x.MyValue = 3;\n    MyInt y = new MyInt();\n    y = x;        \n    y.MyValue = 4;         \n    return x.MyValue;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int ReturnValue2()\n{\n    MyInt x = new MyInt();\n    x.MyValue = 3;\n    MyInt y = new MyInt();\n    y = x;        \n    y.MyValue = 4;         \n    return x.MyValue;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们得到的值是４而不是３！（译外话：这是很简单，但相信还是有很多人不知道原理的）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一个示例中："}]},{"type":"element","tag":"pre","props":{"code":"public int ReturnValue()\n{\n    int x = 3;\n    int y = x;    \n    y = 4;\n    return x;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int ReturnValue()\n{\n    int x = 3;\n    int y = x;    \n    y = 4;\n    return x;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131128043217031"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"x就是3，y就是4。操作两个不同对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二个示例："}]},{"type":"element","tag":"pre","props":{"code":"public int ReturnValue2()\n{\n    MyInt x;\n    x.MyValue = 3;\n    MyInt y;\n    y = x;              \n    y.MyValue = 4;\n    return x.MyValue;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int ReturnValue2()\n{\n    MyInt x;\n    x.MyValue = 3;\n    MyInt y;\n    y = x;              \n    y.MyValue = 4;\n    return x.MyValue;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131128043332000"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"得到的值是4不是3是因为我们操作栈里两个指针并且它们指向堆里同一个对象。"}]},{"type":"element","tag":"h2","props":{"id":"参数大画面"},"children":[{"type":"text","value":"参数，大画面"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是当代码运行时会产生的一个详细过程。上几节已经介绍过当一个方法被调用时会产生的基本情况，让我们来看一下更加详细的内容。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们调用一个方法时会发生以下情形："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"栈会分配一块内存空间给程序执行所需要的信息(我们叫它栈结构Stack Frame)。一个栈结构包含方法调用地址(指针)，它以一个GOTO指令的形式存在栈里。因此，当程序执行完方法(method)时，它会知道怎么样返回进而曳继续执行代码。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"方法的所有参数将被复制到栈里，这是我们将要更加详细介绍的部分。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"控制被传递到JIT编译过的方法里，同时线程开始执行代码。此时，我们将有另一个方法呈现在栈结构的“回调栈”里。"}]}]},{"type":"element","tag":"pre","props":{"code":"public int AddFive(int pValue)\n{\n    int result;\n    result = pValue + 5;\n    return result;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public int AddFive(int pValue)\n{\n    int result;\n    result = pValue + 5;\n    return result;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"栈像下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131128042641203"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：ReturnValue方法不会存在栈上，图中把ReturnValue作为此栈结构的开始只是为了解释栈原理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"像前几节介绍的，值类型和引用类型在栈里的存储是不同的。栈为任何值类型创建副本，栈也为任何引用类型的指针创建副本。"}]},{"type":"element","tag":"h2","props":{"id":"值类型传递"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"值类型传递"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是值类型传递在栈里的内幕。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，当我们传递一个值类型变量时，栈会为它分配一块内存空间并把值类型变量的值存储进去。看下面的代码："}]},{"type":"element","tag":"pre","props":{"code":"class Class1  \n{  \n     public void Go()  \n     {  \n         int x = 5;  \n         AddFive(x);  \n         Console.WriteLine(x.ToString());  \n     }  \n     public int AddFive(int pValue)  \n     {  \n         pValue += 5;  \n         return pValue;  \n     }  \n} \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Class1  \n{  \n     public void Go()  \n     {  \n         int x = 5;  \n         AddFive(x);  \n         Console.WriteLine(x.ToString());  \n     }  \n     public int AddFive(int pValue)  \n     {  \n         pValue += 5;  \n         return pValue;  \n     }  \n} \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当代码执行时，栈为x分配一块内存空间并存储值5"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127050637031"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，AddFive()被放到栈上，同时栈分配内存空间给参数pValue并复制x的值给它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127051251531"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当AddFive()执行完成，线程被传递回Go()。同时因为AddFive()执行完，它的参数pValue也实质上被移除。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127051718640"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以结果是5是合理的。关键点是任何被传递的值类型参数仅是一个碳复制，因为我们希望保护原始变量的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有一点要记住的是，如果我们有一个非常庞大的值类型(如，庞大的struct类型)传递到栈里，当处理器循环复制它并循环占有栈空间时将会非常耗资源。栈没有无限的空间去使用，就像用水杯不断的接水早晚会溢出一样。Struct类型可以变得非常庞大，我们要小心并清醒的使用它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是一个比较大的struct结构类型："}]},{"type":"element","tag":"pre","props":{"code":"public struct MyStruct  \n{  \n    long a, b, c, d, e, f, g, h, i, j, k, l, m;  \n}  \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public struct MyStruct  \n{  \n    long a, b, c, d, e, f, g, h, i, j, k, l, m;  \n}  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们看看执行下面代码Go()方法时再到DoSomething()方法会发生的情况："}]},{"type":"element","tag":"pre","props":{"code":" public void Go()  \n{  \n   MyStruct x = new MyStruct();  \n   DoSomething(x);  \n}  \npublic void DoSomething(MyStruct pValue)  \n{  \n   // DO SOMETHING HERE....  \n} \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public void Go()  \n{  \n   MyStruct x = new MyStruct();  \n   DoSomething(x);  \n}  \npublic void DoSomething(MyStruct pValue)  \n{  \n   // DO SOMETHING HERE....  \n} \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127054659921"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这可能会非常低效。想像一下如果我们传递MyStruct几千次，它会怎么样让程序死掉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，我们怎么才能回避这样的问题呢？那就是仅传递原始值类型的引用。"}]},{"type":"element","tag":"pre","props":{"code":"public void Go()  \n{  \n   MyStruct x = new MyStruct();  \n   DoSomething(ref x);  \n}  \n public struct MyStruct  \n {  \n     long a, b, c, d, e, f, g, h, i, j, k, l, m;  \n }  \n public void DoSomething(ref MyStruct pValue)  \n {  \n          // DO SOMETHING HERE....  \n } \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Go()  \n{  \n   MyStruct x = new MyStruct();  \n   DoSomething(ref x);  \n}  \n public struct MyStruct  \n {  \n     long a, b, c, d, e, f, g, h, i, j, k, l, m;  \n }  \n public void DoSomething(ref MyStruct pValue)  \n {  \n          // DO SOMETHING HERE....  \n } \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样就能节省内存并提升内存使用效率"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127055230375"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"唯一需要注意的是传递引用时我们在访问原始变量x的值，任可对pValue的改变都会影响到x。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的代码会将x改变成\"12345\"，因为pValue.a实际上指向原始x声明时所在的内存地址。"}]},{"type":"element","tag":"pre","props":{"code":"public void Go()  \n{  \n   MyStruct x = new MyStruct();  \n   x.a = 5;  \n   DoSomething(ref x);  \n   Console.WriteLine(x.a.ToString());  \n}  \npublic void DoSomething(ref MyStruct pValue)  \n{  \n         pValue.a = 12345;  \n}  \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Go()  \n{  \n   MyStruct x = new MyStruct();  \n   x.a = 5;  \n   DoSomething(ref x);  \n   Console.WriteLine(x.a.ToString());  \n}  \npublic void DoSomething(ref MyStruct pValue)  \n{  \n         pValue.a = 12345;  \n}  \n"}]}]},{"type":"element","tag":"h2","props":{"id":"引用类型传递"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"引用类型传递"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"传递引用类型跟上一节所示例中用引用的方式传递值类型相似。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用引用类型（原文可能笔误，写的是值类型）："}]},{"type":"element","tag":"pre","props":{"code":"public class MyInt  \n{  \n    public int MyValue;  \n}  \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class MyInt  \n{  \n    public int MyValue;  \n}  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后调用Go()方法，MyInt会被放到堆里因为它是一个引用类型。"}]},{"type":"element","tag":"pre","props":{"code":"public void Go()  \n{  \n   MyInt x = new MyInt();  \n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Go()  \n{  \n   MyInt x = new MyInt();  \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127070913796"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果执行下面代码中的Go()："}]},{"type":"element","tag":"pre","props":{"code":"public void Go()  \n{  \n   MyInt x = new MyInt();  \n   x.MyValue = 2;  \n   DoSomething(x);  \n   Console.WriteLine(x.MyValue.ToString());  \n}  \n public void DoSomething(MyInt pValue)  \n {  \n     pValue.MyValue = 12345;  \n } \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Go()  \n{  \n   MyInt x = new MyInt();  \n   x.MyValue = 2;  \n   DoSomething(x);  \n   Console.WriteLine(x.MyValue.ToString());  \n}  \n public void DoSomething(MyInt pValue)  \n {  \n     pValue.MyValue = 12345;  \n } \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会发生这种情况："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127071131421"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开始调用Go()，栈分配一块内存空间给x。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行行到DoSomething()，栈分配一块内在空间给pValue。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"x的值是堆中MyInt对应在栈里的内存地址，复制x给pValue。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，我们用pValue改变MyInt的MyValue的值时，x最终也会获得这个改变的值\"12345“。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们用引用的方式传递一个引用类型变量呢？"}]},{"type":"element","tag":"h2","props":{"id":"用引用的方式传递引用类型"},"children":[{"type":"text","value":"用引用的方式传递引用类型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们有一个类Thing, 类Animal和Vegetables衍生于Thing："}]},{"type":"element","tag":"pre","props":{"code":"public class Thing  \n{  \n}  \npublic class Animal:Thing  \n{  \n    public int Weight;  \n}  \npublic class Vegetable:Thing  \n{  \n    public int Length;  \n}  \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Thing  \n{  \n}  \npublic class Animal:Thing  \n{  \n    public int Weight;  \n}  \npublic class Vegetable:Thing  \n{  \n    public int Length;  \n}  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行下面的Go()方法："}]},{"type":"element","tag":"pre","props":{"code":"public void Go()  \n{  \n   Thing x = new Animal();  \n   Switcharoo(ref x);  \n    Console.WriteLine(  \n      \"x is Animal    :   \"  \n      + (x is Animal).ToString());  \n    Console.WriteLine(  \n        \"x is Vegetable :   \"  \n        + (x is Vegetable).ToString());  \n}  \n public void Switcharoo(ref Thing pValue)  \n {  \n     pValue = new Vegetable();  \n }  \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Go()  \n{  \n   Thing x = new Animal();  \n   Switcharoo(ref x);  \n    Console.WriteLine(  \n      \"x is Animal    :   \"  \n      + (x is Animal).ToString());  \n    Console.WriteLine(  \n        \"x is Vegetable :   \"  \n        + (x is Vegetable).ToString());  \n}  \n public void Switcharoo(ref Thing pValue)  \n {  \n     pValue = new Vegetable();  \n }  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"x最终变成Vegetable。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"打印结果："}]},{"type":"element","tag":"pre","props":{"code":"x is Animal    :   False\nx is Vegetable :   True\n","language":"yaml","meta":"","className":["language-yaml"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"x is Animal    :   False\nx is Vegetable :   True\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们看看堆栈里到底发生了什么情况"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127073852765"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用Go()方法，栈分配一块内存空间给x。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"堆分配一块内存空间给Animal。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开始执行Switcharoo()方法，栈分配一块内存空间给pValue并指向x。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131127074345953"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"栈分配一块内存空间给Vegetable。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"pValue改变了x的值使其指向Vegetable的内在地址。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们不是用ref传递的，打印结果正相反。"}]},{"type":"element","tag":"h2","props":{"id":"复制不仅仅是复制"},"children":[{"type":"text","value":"复制不仅仅是复制"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了更清晰的阐述这个问题，让我们测试一下在堆中存储值类型变量和引用类型变量时会产生的不同情况。"}]},{"type":"element","tag":"h3","props":{"id":"值类型测试"},"children":[{"type":"text","value":"值类型测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，我们看一下值类型。下面是一个类和一个结构类型(值类型)，Dude类包含一个Name元素和两个Shoe元素。我们有一个CopyDude()方法用来复制生成新Dude。"}]},{"type":"element","tag":"pre","props":{"code":"public struct Shoe{\n    public string Color;\n}\npublic class Dude\n{\n    public string Name;\n    public Shoe RightShoe;\n    public Shoe LeftShoe;\n    public Dude CopyDude()\n    {\n        Dude newPerson = new Dude();\n        newPerson.Name = Name;\n        newPerson.LeftShoe = LeftShoe;\n        newPerson.RightShoe = RightShoe;\n        return newPerson;\n    }\n    public override string ToString()\n    {\n        return (Name + \" : Dude!, I have a \" + RightShoe.Color + \" shoe on my right foot, and a \" + LeftShoe.Color + \" on my left foot.\");\n    }\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public struct Shoe{\n    public string Color;\n}\npublic class Dude\n{\n    public string Name;\n    public Shoe RightShoe;\n    public Shoe LeftShoe;\n    public Dude CopyDude()\n    {\n        Dude newPerson = new Dude();\n        newPerson.Name = Name;\n        newPerson.LeftShoe = LeftShoe;\n        newPerson.RightShoe = RightShoe;\n        return newPerson;\n    }\n    public override string ToString()\n    {\n        return (Name + \" : Dude!, I have a \" + RightShoe.Color + \" shoe on my right foot, and a \" + LeftShoe.Color + \" on my left foot.\");\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dude类是一个复杂类型，因为值 类型结构Shoe是它的成员， 它们都将存储在堆中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131128023045765"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们执行下面的方法时："}]},{"type":"element","tag":"pre","props":{"code":"public static void Main()\n{\n    Class1 pgm = new Class1();\n    Dude Bill = new Dude();\n    Bill.Name = \"Bill\";\n    Bill.LeftShoe = new Shoe();\n    Bill.RightShoe = new Shoe();\n    Bill.LeftShoe.Color = Bill.RightShoe.Color = \"Blue\";\n    Dude Ted = Bill.CopyDude();\n    Ted.Name = \"Ted\";\n    Ted.LeftShoe.Color = Ted.RightShoe.Color = \"Red\";\n    Console.WriteLine(Bill.ToString());\n    Console.WriteLine(Ted.ToString());\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static void Main()\n{\n    Class1 pgm = new Class1();\n    Dude Bill = new Dude();\n    Bill.Name = \"Bill\";\n    Bill.LeftShoe = new Shoe();\n    Bill.RightShoe = new Shoe();\n    Bill.LeftShoe.Color = Bill.RightShoe.Color = \"Blue\";\n    Dude Ted = Bill.CopyDude();\n    Ted.Name = \"Ted\";\n    Ted.LeftShoe.Color = Ted.RightShoe.Color = \"Red\";\n    Console.WriteLine(Bill.ToString());\n    Console.WriteLine(Ted.ToString());\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们得到了期望的结果："}]},{"type":"element","tag":"pre","props":{"code":"Bill : Dude!, I have a Blue shoe on my right foot, and a Blue on my left foot.\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot.\n","language":"vbscript","meta":"","className":["language-vbscript"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Bill : Dude!, I have a Blue shoe on my right foot, and a Blue on my left foot.\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot.\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们把Shoe换成引用类型呢？"}]},{"type":"element","tag":"h3","props":{"id":"引用类型测试"},"children":[{"type":"text","value":"引用类型测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我们把Shoe改成引用类型时，问题就产生了。"}]},{"type":"element","tag":"pre","props":{"code":"public class Shoe{\n    public string Color;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Shoe{\n    public string Color;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行同样上面的Main()方法，结果改变了，如下："}]},{"type":"element","tag":"pre","props":{"code":"Bill : Dude!, I have a Red shoe on my right foot, and a Red on my left foot\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot\n","language":"vbscript","meta":"","className":["language-vbscript"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Bill : Dude!, I have a Red shoe on my right foot, and a Red on my left foot\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这并不是我们期望的结果。很明显，出错了！看下面的图解："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131128023756781"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为现在Shoe是引用类型而不是值类型，当我们进行复制时仅是复制了指针，我们并没有复制指针真正对应的对象。这就需要我们做一些额外的工作使引用类型Shoe像值类型一样工作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很幸运，我们有一个接口可以帮我们实现：ICloneable。当Dude类实现它时，我们会声明一个Clone()方法用来产生新的Dude复制类。（译外话：复制类及其成员跟原始类不产生任何重叠，即我们所说的深复制)  看下面代码：\nICloneable consists of one method: Clone()"}]},{"type":"element","tag":"pre","props":{"code":"public object Clone()\n{\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public object Clone()\n{\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here's how we'll implement it in the Shoe class:"}]},{"type":"element","tag":"pre","props":{"code":"public class Shoe : ICloneable\n{\n    public string Color;\n    #region ICloneable Members\n    public object Clone()\n    {\n        Shoe newShoe = new Shoe();\n        newShoe.Color = Color.Clone() as string;\n        return newShoe;\n    }\n    #endregion\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Shoe : ICloneable\n{\n    public string Color;\n    #region ICloneable Members\n    public object Clone()\n    {\n        Shoe newShoe = new Shoe();\n        newShoe.Color = Color.Clone() as string;\n        return newShoe;\n    }\n    #endregion\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Clone()方法里，我们创建了一个新的Shoe，克隆所有引用类型变量，复制所有值类型变量，最后返回新的对象Shoe。有些既有类已经实现了ICloneable，我们直接使用即可，如String。因此，我们直接使用Color.Clone()。因为Clone()返回object对象，我们需要进行一下类型转换。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下一步，我们在CopyDude()方法里，用克隆Clone()代替复制："}]},{"type":"element","tag":"pre","props":{"code":"public Dude CopyDude()\n{\n    Dude newPerson = new Dude();\n    newPerson.Name = Name;\n    newPerson.LeftShoe = LeftShoe.Clone() as Shoe;\n    newPerson.RightShoe = RightShoe.Clone() as Shoe;\n    return newPerson;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public Dude CopyDude()\n{\n    Dude newPerson = new Dude();\n    newPerson.Name = Name;\n    newPerson.LeftShoe = LeftShoe.Clone() as Shoe;\n    newPerson.RightShoe = RightShoe.Clone() as Shoe;\n    return newPerson;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再次执行主方法Main()："}]},{"type":"element","tag":"pre","props":{"code":"public static void Main()\n{\n    Class1 pgm = new Class1();\n    Dude Bill = new Dude();\n    Bill.Name = \"Bill\";\n    Bill.LeftShoe = new Shoe();\n    Bill.RightShoe = new Shoe();\n    Bill.LeftShoe.Color = Bill.RightShoe.Color = \"Blue\";\n    Dude Ted = Bill.CopyDude();\n    Ted.Name = \"Ted\";\n    Ted.LeftShoe.Color = Ted.RightShoe.Color = \"Red\";\n    Console.WriteLine(Bill.ToString());\n    Console.WriteLine(Ted.ToString());\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static void Main()\n{\n    Class1 pgm = new Class1();\n    Dude Bill = new Dude();\n    Bill.Name = \"Bill\";\n    Bill.LeftShoe = new Shoe();\n    Bill.RightShoe = new Shoe();\n    Bill.LeftShoe.Color = Bill.RightShoe.Color = \"Blue\";\n    Dude Ted = Bill.CopyDude();\n    Ted.Name = \"Ted\";\n    Ted.LeftShoe.Color = Ted.RightShoe.Color = \"Red\";\n    Console.WriteLine(Bill.ToString());\n    Console.WriteLine(Ted.ToString());\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们得到了期望的结果："}]},{"type":"element","tag":"pre","props":{"code":"Bill : Dude!, I have a Blue shoe on my right foot, and a Blue on my left foot\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot\n","language":"vbscript","meta":"","className":["language-vbscript"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Bill : Dude!, I have a Blue shoe on my right foot, and a Blue on my left foot\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是图解："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-09-11-stack-heap/20131128030404656"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"整理我们的代码"},"children":[{"type":"text","value":"整理我们的代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在实践中，我们是希望克隆引用类型并复制值类型的。这会让你回避很多不易察觉的错误，就像上面演示的一样。这种错误有时不易被调试出来，会让你很头疼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，为了减轻头疼，让我们更进一步清理上面的代码。我们让Dude类实现IConeable代替使用CopyDude()方法："}]},{"type":"element","tag":"pre","props":{"code":"public class Dude: ICloneable\n{\n    public string Name;\n    public Shoe RightShoe;\n    public Shoe LeftShoe;\n    public override string ToString()\n    {\n        return (Name + \" : Dude!, I have a \" + RightShoe.Color + \" shoe on my right foot, and a \" + LeftShoe.Color + \" on my left foot.\");\n    }\n    #region ICloneable Members\n    public object Clone()\n    {\n        Dude newPerson = new Dude();\n        newPerson.Name = Name.Clone() as string;\n        newPerson.LeftShoe = LeftShoe.Clone() as Shoe;\n        newPerson.RightShoe = RightShoe.Clone() as Shoe;\n        return newPerson;\n    }\n    #endregion\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Dude: ICloneable\n{\n    public string Name;\n    public Shoe RightShoe;\n    public Shoe LeftShoe;\n    public override string ToString()\n    {\n        return (Name + \" : Dude!, I have a \" + RightShoe.Color + \" shoe on my right foot, and a \" + LeftShoe.Color + \" on my left foot.\");\n    }\n    #region ICloneable Members\n    public object Clone()\n    {\n        Dude newPerson = new Dude();\n        newPerson.Name = Name.Clone() as string;\n        newPerson.LeftShoe = LeftShoe.Clone() as Shoe;\n        newPerson.RightShoe = RightShoe.Clone() as Shoe;\n        return newPerson;\n    }\n    #endregion\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在主方法Main()使用Dude.Clone()："}]},{"type":"element","tag":"pre","props":{"code":"public static void Main()\n{\n    Class1 pgm = new Class1();\n    Dude Bill = new Dude();\n    Bill.Name = \"Bill\";\n    Bill.LeftShoe = new Shoe();\n    Bill.RightShoe = new Shoe();\n    Bill.LeftShoe.Color = Bill.RightShoe.Color = \"Blue\";\n    Dude Ted = Bill.Clone() as Dude;\n    Ted.Name = \"Ted\";\n    Ted.LeftShoe.Color = Ted.RightShoe.Color = \"Red\";\n    Console.WriteLine(Bill.ToString());\n    Console.WriteLine(Ted.ToString());\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static void Main()\n{\n    Class1 pgm = new Class1();\n    Dude Bill = new Dude();\n    Bill.Name = \"Bill\";\n    Bill.LeftShoe = new Shoe();\n    Bill.RightShoe = new Shoe();\n    Bill.LeftShoe.Color = Bill.RightShoe.Color = \"Blue\";\n    Dude Ted = Bill.Clone() as Dude;\n    Ted.Name = \"Ted\";\n    Ted.LeftShoe.Color = Ted.RightShoe.Color = \"Red\";\n    Console.WriteLine(Bill.ToString());\n    Console.WriteLine(Ted.ToString());\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后得到期望的结果："}]},{"type":"element","tag":"pre","props":{"code":"Bill : Dude!, I have a Blue shoe on my right foot, and a Blue on my left foot.\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot.\n","language":"vbscript","meta":"","className":["language-vbscript"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Bill : Dude!, I have a Blue shoe on my right foot, and a Blue on my left foot.\nTed : Dude!, I have a Red shoe on my right foot, and a Red on my left foot.\n"}]}]},{"type":"element","tag":"h3","props":{"id":"特殊引用类型string"},"children":[{"type":"text","value":"特殊引用类型String"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在C#中有趣的是，当System.String 使用操作符“=”时，实际上是进行了克隆(深复制)。你不必担心你只是在操作一个指针，它会在内存中创建一个新的对象。但是，你一定要注意内存的占用问题("},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"译外话：比如为什么在一定情况下我们使用StringBuilder代替String+String+String+String...前者速度稍慢初始化耗多点内存但在大字符串操作上节省内存，后者速度稍快初始化简单但在大字符串操作上耗内存"}]},{"type":"text","value":")。如果我们回头去看上面的图解中，你会发现Stirng类型在图中并不是一个针指向另一个内存对象，而是为了尽可能的简单，把它当成值类型来演示了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"绘图Graphing"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们站在GC的角度研究一下。如果我们负责“扔垃圾”，我们需要制定一个有效的“扔垃圾”计划。显然，我们需要判断哪些是垃圾，哪些不是。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了决定哪些需要保留，我们假设任何没有正在被使用的东西都是垃圾（如角落里堆积的破旧纸张，阁楼里一箱箱没有用的过时产品,柜子里不用的衣服）。想像一下我们跟两个好朋友生活在一起：JIT 和CLR。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"JIT和CLR"}]},{"type":"text","value":"不断的跟踪他们正在使用的东西，并给我们一个他们需要保留的东西列表。这个初始列表我们叫它“根(root)”列表。因为我们用它做起点。我们将保持一个主列表去绘制一张图，图中分布着所有我们在房子中需要保留东西。任何与主列表中有关联的东西也被画入图中。如，我们保留电视就不要扔掉电视遥控器，所以电视遥控器也会被画入图中。我们保留电脑就不能扔掉显示器键盘鼠标，同样也把它们画入图中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这就是GC怎么决定去保留对象的。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GC会保留从JIT和CLR那收到的一个根(root)对象引用列表，然后递归搜索对象引用并决定什么需要保留。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个根的构成如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"全局/静态 指针。通过以静态变量的方式保持对象的引用，来确保对象不会被GC回收。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"栈里的指针。为了程序的执行，我们不想扔掉那些程序线程始终需要的对象。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CPU寄存器指针。托管堆里任何被CPU内存地址指向的对象都需要被保留。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173037464.png"},"children":[]},{"type":"text","value":"\n在上面的图中，托管堆中的对象1，5被根Roots引用，3被1引用。对象1，5是被直接引用，3是通过递归查询找到。如果关联到我们之前的假设，对象1是我们的电视，对象3则是电视遥控器。当所有对象画完后，我们开始进行下一阶段：垃圾清理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GC垃圾清理Compacting"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们有了一张需要保留对象的关系图，接下来进行GC的清理。\n"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173106186.png"},"children":[]},{"type":"text","value":"\n图中对象2和4被认定为垃圾将被清理。清理对象2，复制（memcpy ）对象3到2的位置。\n"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173121251.png"},"children":[]},{"type":"text","value":"\n由于对象3的地址变了，GC需要修复指针（红色箭头）。然后清理对象4，复制（memcpy ）对象5到原来3的位置（译外话：GC原则：堆中对象之间是没有间隙的，以后会有文章专门介绍GC原理）。\n"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173159935.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173215230.png"},"children":[]},{"type":"text","value":"\n最后清理完毕，新对象将被放到对象5的上面(译外话：GC对一直管理一个指针指向新对象将被放置的地址，如黄色箭头，以后会有文章专门介绍)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"了解GC原理可以帮助我们理解GC清理(复制memcpy ，指针修复等)是怎么消耗掉很多资源的。很明显，减少托管堆里对象的移动（复制memcpy ）可以提高GC清理的效率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"托管堆之外的终止化队列Finalization Queue和终止化-可达队列Freachable Queue"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有些情况下，GC需要执行特定代码去清理非托管资源，如文件操作，数据库连接，网络连接等。一种可行性方案是使用析构函数（终结器）：\n"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173419800.png"},"children":[]},{"type":"text","value":"\n译外话：析构函数会被内部转换成终结器override Finializer()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有终结器的对象在创建时，同时在Finalization Queue里创建指向它们的指针（更正原文说的把对象放到Finalization Queue里）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173504552.png"},"children":[]},{"type":"text","value":"\n上图对象1,4,5实现了终结器，因此在Finalization Queue里创建指向它们的指针。让我们看一下，当对象2和4没有被程序引用要被GC清理时会发生什么情况。\n对象2会被以常规模式清理掉(见文章开始部分)。GC发现对象4有终结器，则会把Finalization Queue里指向它的指针移到Freachable Queue中，如下图：\n"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173647141.png"},"children":[]},{"type":"text","value":"\n但是对象4并不被清理掉。有一个专门处理Freachable Queue的线程，当它处理完对象4在Freachable Queue里的指针后，会把它移除。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173729593.png"},"children":[]},{"type":"text","value":"\n这时对象4可以被清理了。当下次GC清理时会把它移除掉。换句话说，至少执行两次GC清理才能把对象4清理掉，显然会影响程序性能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建终结器，意味着创建了更多的工作给GC，也就会消耗更多资源影响程序性能。因此，当你使用终结器时一定要确保你确实需要使用它。\n更好的方法是使用IDisposable接口。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173836793.png"},"children":[]},{"type":"text","value":"\n实现IDisposable接口的对象可以使用using关键字：\n"},{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919173851233.png"},"children":[]},{"type":"text","value":"\n变量rec的作用域是大括号内，大括号外不可访问。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"静态变量"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"在这里插入图片描述","src":"/images/2020-09-11-stack-heap/20190919174039786.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你初始化了TryoutRunners，那么它将永远不会被GC清理，因为有静态指针一直指向初始化的对象。一旦调用了Runner里GetStats()方法，因为GetStats()里面没有文件关闭操作，它将永远被打开也不会被GC清理。我们可以看到程序的崩溃即将来临。"}]},{"type":"element","tag":"h1","props":{"id":"参考"},"children":[{"type":"text","value":"参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-i/","rel":["nofollow"]},"children":[{"type":"text","value":"C# Heap(ing) Vs Stack(ing) In .NET - Part One (c-sharpcorner.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-ii/","rel":["nofollow"]},"children":[{"type":"text","value":"C# Heap(ing) Vs Stack(ing) In .NET - Part Two (c-sharpcorner.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-iii/","rel":["nofollow"]},"children":[{"type":"text","value":"C# Heap(ing) Vs Stack(ing) In .NET - Part Three (c-sharpcorner.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-iv/","rel":["nofollow"]},"children":[{"type":"text","value":"C# Heap(ing) Vs Stack(ing) In .NET - Part Four (c-sharpcorner.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/BV1Tt4y1X7f6","rel":["nofollow"]},"children":[{"type":"text","value":"Unite Now - （中文字幕）性能优化技巧（上）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"堆与栈有什么不同","depth":2,"text":"堆与栈：有什么不同？"},{"id":"什么在堆和栈里","depth":2,"text":"什么在堆和栈里","children":[{"id":"值类型","depth":3,"text":"值类型:"},{"id":"引用类型","depth":3,"text":"引用类型:"},{"id":"指针","depth":3,"text":"指针:"}]},{"id":"两个黄金规则","depth":2,"text":"两个黄金规则"},{"id":"栈工作原理","depth":2,"text":"栈工作原理"},{"id":"值类型会存储在堆里","depth":2,"text":"值类型会存储在堆里？"},{"id":"代码图例","depth":2,"text":"代码图例"},{"id":"堆栈原理对代码的影响","depth":2,"text":"堆栈原理对代码的影响","children":[{"id":"代码图例-1","depth":3,"text":"代码图例"}]},{"id":"参数大画面","depth":2,"text":"参数，大画面"},{"id":"值类型传递","depth":2,"text":"值类型传递"},{"id":"引用类型传递","depth":2,"text":"引用类型传递"},{"id":"用引用的方式传递引用类型","depth":2,"text":"用引用的方式传递引用类型"},{"id":"复制不仅仅是复制","depth":2,"text":"复制不仅仅是复制","children":[{"id":"值类型测试","depth":3,"text":"值类型测试"},{"id":"引用类型测试","depth":3,"text":"引用类型测试"},{"id":"整理我们的代码","depth":3,"text":"整理我们的代码"},{"id":"特殊引用类型string","depth":3,"text":"特殊引用类型String"}]}]}},"_type":"markdown","_id":"content:unity:2020-09-11-stack-heap.md","_source":"content","_file":"unity/2020-09-11-stack-heap.md","_extension":"md","date":"2020-09-11"},{"_path":"/unity/2020-09-12-addressables","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity的addressables","description":"Addressables.InitializeAsync初始化并填充Addressables.ResourceLocatorsIResourceLocator资源目录,可以通过 代码加载额外的locatorvar  requestCatalog=Addressables.LoadContentCatalogAsync(\"http://192.168.100.100:51879/catalog_extra.json.json\", providerSuffix);\nvar locator = await requestCatalog.Task;\nAddressables.AddResourceLo","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"addressablesinitializeasync"},"children":[{"type":"text","value":"Addressables.InitializeAsync"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"初始化并填充Addressables.ResourceLocators"}]},{"type":"element","tag":"h2","props":{"id":"iresourcelocator"},"children":[{"type":"text","value":"IResourceLocator"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"资源目录,可以通过 代码加载额外的locator"}]},{"type":"element","tag":"pre","props":{"code":"var  requestCatalog=Addressables.LoadContentCatalogAsync(\"http://192.168.100.100:51879/catalog_extra.json.json\", providerSuffix);\nvar locator = await requestCatalog.Task;\nAddressables.AddResourceLocator(locator);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var  requestCatalog=Addressables.LoadContentCatalogAsync(\"http://192.168.100.100:51879/catalog_extra.json.json\", providerSuffix);\nvar locator = await requestCatalog.Task;\nAddressables.AddResourceLocator(locator);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"存储了一个IResourceLocation列表..根据不同的key(label,path)进行存储"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如: 有个资源是ui.prefab,同时又lable"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"enter"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"main"}]},{"type":"text","value":"可能就会有三个IResourceLocation"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"enter为key的IResourceLocation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"main为key的IResourceLocation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Assets/prefabs/ui/ui.prefab"}]},{"type":"text","value":"为key的IResourceLocation"}]}]},{"type":"element","tag":"h2","props":{"id":"iresourcelocation"},"children":[{"type":"text","value":"IResourceLocation"}]},{"type":"element","tag":"h3","props":{"id":"mergemode"},"children":[{"type":"text","value":"MergeMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MergeMode"}]},{"type":"text","value":"是什么呢？翻译过来是合并模式。"}]},{"type":"element","tag":"pre","props":{"code":"public enum MergeMode\n{\n    None = 0,\n    UseFirst = 0,\n    Union,\n    Intersection\n}\n","language":"text","meta":"","className":["language-text"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public enum MergeMode\n{\n    None = 0,\n    UseFirst = 0,\n    Union,\n    Intersection\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会去先查询每一个地址/标签对应的资源，然后再根据MergeMode进行最终结果的计算。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如传入的参数是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"new List<object>{\"cube\", \"red\"}"}]},{"type":"text","value":"，根据cube查询出来的资源有A、B、D，根据red查询出来的资源有C、D、E。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么MergeMode是Node或UseFirst时，会取第一个key查询到的资源：A、B、D；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MergeMode是Union时，会取所有key查询到的资源的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"并集"}]},{"type":"text","value":"：A、B、C、D、E；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MergeMode是Intersection时，会取所有key查询到的资源的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"交集"}]},{"type":"text","value":"：D。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.addressables@1.15/manual/LoadingAddressableAssets.html","rel":["nofollow"]},"children":[{"type":"text","value":"Addressables.LoadAsset(s)Async | Addressables | 1.15.1 (unity3d.com)"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"addressablesinitializeasync","depth":2,"text":"Addressables.InitializeAsync"},{"id":"iresourcelocator","depth":2,"text":"IResourceLocator"},{"id":"iresourcelocation","depth":2,"text":"IResourceLocation","children":[{"id":"mergemode","depth":3,"text":"MergeMode"}]}]}},"_type":"markdown","_id":"content:unity:2020-09-12-Addressables.md","_source":"content","_file":"unity/2020-09-12-Addressables.md","_extension":"md","date":"2020-09-12"},{"_path":"/unity/2020-09-13-vector","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"游戏中的向量使用","description":"向量和点的区别\n向量的长度就是和000 点的距离\n点积的几何意义与游戏中的应用\n向量的单位向量，就是长度为1时的向量","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"向量和点的区别\n向量的长度就是和000 点的距离\n点积的几何意义与游戏中的应用\n向量的单位向量，就是长度为1时的向量"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-09-13-vector.md","_source":"content","_file":"unity/2020-09-13-vector.md","_extension":"md","date":"2020-09-13"},{"_path":"/unity/2020-10-15-unity-ecs","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY ECS 详解","description":"DOTS面向数据栈编程ecs   在OOP方法中，数据不会被组织起来，而是会分散再整个内存中，这是因为使用了自动内存管理功能。job system 传统只使用了单线程,配合ecs提供了多线程解决方案brust compiler 将c#直接转换为汇编ECS核心概念这个图中，System读取了多个实体的Translation和Rotation组件，然后经过计算处理，将结果更新到LocalToWorld组件中。从图中你可以看到，实体A和B还有Renderer组件，但是C并没有。不过这并不会影响System的计算逻辑，因为这个系统不关心Renderer组件。原型 Archetypes多个组件的组合叫做","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DOTS面向数据栈编程"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ecs   在OOP方法中，数据不会被组织起来，而是会分散再整个内存中，这是因为使用了自动内存管理功能。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"job system 传统只使用了单线程,配合ecs提供了多线程解决方案"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"brust compiler 将c#直接转换为汇编"}]}]},{"type":"element","tag":"h1","props":{"id":"ecs核心概念"},"children":[{"type":"text","value":"ECS核心概念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-15-unity-ecs/ECSBlockDiagram.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个图中，System读取了多个实体的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rotation"}]},{"type":"text","value":"组件，然后经过计算处理，将结果更新到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":"组件中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从图中你可以看到，实体A和B还有Renderer组件，但是C并没有。不过这并不会影响System的计算逻辑，因为这个系统不关心"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Renderer"}]},{"type":"text","value":"组件。"}]},{"type":"element","tag":"h2","props":{"id":"原型-archetypes"},"children":[{"type":"text","value":"原型 Archetypes"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多个组件的组合叫做一个原型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如一个3D物体可能会包含用于transform的组件，包括移动、旋转、渲染，每个3D物体对应一个实体，但是他们都有同样的组件，所以ECS会把他们分类成是一类原型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-15-unity-ecs/ArchetypeDiagram.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在上图中，实体A和B的原型都是M，实体C的原型是N。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你也可以通过在运行时添加或者移除component来改变一个实体的原型。例如：如果将实体B的Renderer组件移除，实体B的原型就会变成N。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个实体的原型是什么，决定了ECS会将实体的components也就是数据存在什么地方。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ECS按块分配内存，每块用一个"}]},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ArchetypeChunk"}]},{"type":"text","value":"对象表示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个块只包含一种原型，可以包含的多个实体的数据。如果一个块的内存满了，ECS会分配一个新的块来存储新的实体的components。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你修改了实体的组件，那就相当于修改了实体的原型，这时候ECS会将实体的组件数据移到另外一个块中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-15-unity-ecs/ArchetypeChunkDiagram.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原型和内存块的关系是一对多的关系。这就意味着，如果想查询给定的一组component类型的所有实体，只需要在这些原型中搜索即可。这样会比在所有的实体中查找效率高很多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS在存储实体到内存块中没有特殊的排序，当创建一个实体或者实体的原型发生变化时，ECS会将它放到对应原型的第一个还有空间的内存块中。内存块中的数据会紧密排列。如果一个实体要被移出当前原型的内存块，这时候会有个空位，ECS会把这个内存块最后的实体数据移动到这个空位中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"注意"}]},{"type":"text","value":"：原型中的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"共享组件"}]},{"type":"text","value":"（后面会具体说这是个什么东东）的数据也会影响实体会被存在哪个内存块。同一个内存块中的所有实体的共享组件中的数据值都是相同的。如果你修改了共享组件中的数据，这个实体会被移到另外一个块中，有点类似修改了实体的原型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将共享组件的实体分到一个内存块中会提高处理他们的速度。比如Hybird Renderer（混合渲染）定义了RenderMesh组件来达成这个目的。"}]},{"type":"element","tag":"h2","props":{"id":"实体-entity"},"children":[{"type":"text","value":"实体 Entity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在代码层面，你就可以了解到，实体非常非常的简单。它的核心部分："}]},{"type":"element","tag":"pre","props":{"code":"public struct Entity\n{\n  public int Index;\n  public int Version; \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public struct Entity\n{\n  public int Index;\n  public int Version; \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Index表示这个实体的ID，和身份证一样用于实体与实体之间区分。Version用于描述这个实体的生命周期，由于实体是可以重用的，那么就需要用Version来区分这个Entity是新生实体，还是即将销毁的实体。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS中有一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":"类来管理一个World中的所有实体。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":"使用列表维护所有实体以及和实体关联的数据，以便达到最优的性能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然entity没有类型，但是可以根据entity关联的component将他们分组，也就是上一节讲的实体原型（EntityArchetype），EntityManager会持续跟踪这些实体原型。你可以使用已有的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityArchetype"}]},{"type":"text","value":"来创建entity，也可以提前创建"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityArchetype"}]},{"type":"text","value":"，以便后面的使用。"}]},{"type":"element","tag":"h3","props":{"id":"创建entity"},"children":[{"type":"text","value":"创建Entity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过以下方法可以一次创建一个Entity："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用ComponentType的数组来创建一个entity"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateEntity(ComponentType[])\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateEntity(ComponentType[])\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用EntityArchetype来创建一个entity"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateEntity(EntityArchetype)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateEntity(EntityArchetype)\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager.Instantiate"}]},{"type":"text","value":"复制一个已有的entity，包括它里面的数据"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.Instantiate(Entity srcEntity);\nEntityManager.Instantiate(NativeArray<Entity> srcEntities, NativeArray<Entity> outputEntities)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.Instantiate(Entity srcEntity);\nEntityManager.Instantiate(NativeArray<Entity> srcEntities, NativeArray<Entity> outputEntities)\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"也可以创建一个空的Entity，在需要的时候在加上components。(您可以立即添加组件，也可以根据需要添加其他组件。)"}]}]},{"type":"element","tag":"pre","props":{"code":"var entity = EntityManager.CreateEntity();\nEntityManager.AddComponent(Entity entity, ComponentType componentType)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var entity = EntityManager.CreateEntity();\nEntityManager.AddComponent(Entity entity, ComponentType componentType)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你也可以通过下面的方法一次创建多个Entity："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateEntity"}]},{"type":"text","value":"方法一次性填充多个新的Entity到一个NativeArry中，这些entity用同样的原型"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateEntity(EntityArchetype archetype, NativeArray<Entity> entities)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateEntity(EntityArchetype archetype, NativeArray<Entity> entities)\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"方法一次性复制多个entity，包含数据"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.Instantiate(NativeArray<Entity> srcEntities, NativeArray<Entity> outputEntities)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.Instantiate(NativeArray<Entity> srcEntities, NativeArray<Entity> outputEntities)\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"显式创建使用指定数量的实体填充的块，并使用CreateChunk创建给定原型"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateChunk(EntityArchetype, NativeArray<ArchetypeChunk>, Int32)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateChunk(EntityArchetype, NativeArray<ArchetypeChunk>, Int32)\n"}]}]},{"type":"element","tag":"h3","props":{"id":"添加删除-component"},"children":[{"type":"text","value":"添加/删除 component"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建完Entity后，你可以添加或者移除component。注意添加或移除component时，entity的原型会发生变化，这时候EntityManager需要将entity移到其他内存块，并将当前内存块的空位补上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对实体的更改导致结构性更改-会造成Entity原型变化的操作不能在Job里面执行，比如添加移除component、修改"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":"中的值、销毁entity。你可以将前面说的这几种操作放进"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityCommandBuffer"}]},{"type":"text","value":"中，在job执行完成后执行这个command buffer。后面还会具体讲解CommandBuffer。"}]},{"type":"element","tag":"pre","props":{"code":"struct Lifetime : IComponentData\n{\n    public byte Value;\n}\n\nclass LifetimeSystem : SystemBase\n{\n    EndSimulationEntityCommandBufferSystem m_EndSimulationEcbSystem;\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        // 从World中获取ECS系统并且存起来\n        m_EndSimulationEcbSystem = World\n            .GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();\n    }\n\n    protected override void OnUpdate()\n    {\n        // 请求一个ECB并且转换成可并行的\n        var ecb = m_EndSimulationEcbSystem.CreateCommandBuffer().AsParallelWriter();\n        Entities\n            .ForEach((Entity entity, int entityInQueryIndex, ref Lifetime lifetime) =>\n        {\n            // 检测entity的lifetime，如果为0则销毁它\n            if (lifetime.Value == 0)\n            {\n                // 将entityInQueryIndex传给操作，这样ECS回放时能保证正确的顺序\n                ecb.DestroyEntity(entityInQueryIndex, entity);\n            }\n            else\n            {\n                lifetime.Value -= 1;\n            }\n        }).ScheduleParallel();\n\n        // 保证ECB system依赖当前这个Job\n        m_EndSimulationEcbSystem.AddJobHandleForProducer(this.Dependency);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Lifetime : IComponentData\n{\n    public byte Value;\n}\n\nclass LifetimeSystem : SystemBase\n{\n    EndSimulationEntityCommandBufferSystem m_EndSimulationEcbSystem;\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        // 从World中获取ECS系统并且存起来\n        m_EndSimulationEcbSystem = World\n            .GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();\n    }\n\n    protected override void OnUpdate()\n    {\n        // 请求一个ECB并且转换成可并行的\n        var ecb = m_EndSimulationEcbSystem.CreateCommandBuffer().AsParallelWriter();\n        Entities\n            .ForEach((Entity entity, int entityInQueryIndex, ref Lifetime lifetime) =>\n        {\n            // 检测entity的lifetime，如果为0则销毁它\n            if (lifetime.Value == 0)\n            {\n                // 将entityInQueryIndex传给操作，这样ECS回放时能保证正确的顺序\n                ecb.DestroyEntity(entityInQueryIndex, entity);\n            }\n            else\n            {\n                lifetime.Value -= 1;\n            }\n        }).ScheduleParallel();\n\n        // 保证ECB system依赖当前这个Job\n        m_EndSimulationEcbSystem.AddJobHandleForProducer(this.Dependency);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"EntityManager也提供了方法用来添加、移除单个entity中的组件，也可以移除一个entity的NativeArray中的组件。后面组件部分会详细说明。"}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.AddComponent(Entity entity, ComponentType componentType)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.AddComponent(Entity entity, ComponentType componentType)\n"}]}]},{"type":"element","tag":"h3","props":{"id":"访问实体数据"},"children":[{"type":"text","value":"访问实体数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"遍历实体和组件最有效的方式时在一个并行化的Job中按顺序处理组件 . 这利用了CPU的多核性能，并避免CPU的缓存丢失"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS API提供了多种遍历的方式，每个都有自己的性能影响和限制. 下面是方法:"}]},{"type":"element","tag":"h4","props":{"id":"systembaseentitiesforeach"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.14/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities","rel":["nofollow"]},"children":[{"type":"text","value":"SystemBase.Entities.ForEach"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用一个job结构来有效的遍历实体."}]},{"type":"element","tag":"pre","props":{"code":"       Entities\n           .WithName(\"Update_Position\") // Shown in error messages and profiler\n           .WithAll<LocalToWorld>() // Require the LocalToWorld component\n           .ForEach(\n               // Write to Displacement (ref), read Velocity (in)\n               (ref Position position, in Velocity velocity) =>\n               {\n                   //Execute for each selected entity\n                   position = new Position()\n                   {\n                       // dT is a captured variable\n                       Value = position.Value + velocity.Value * dT\n                   };\n               }\n           )\n           .ScheduleParallel(); // Schedule as a parallel job\n           \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"       Entities\n           .WithName(\"Update_Position\") // Shown in error messages and profiler\n           .WithAll<LocalToWorld>() // Require the LocalToWorld component\n           .ForEach(\n               // Write to Displacement (ref), read Velocity (in)\n               (ref Position position, in Velocity velocity) =>\n               {\n                   //Execute for each selected entity\n                   position = new Position()\n                   {\n                       // dT is a captured variable\n                       Value = position.Value + velocity.Value * dT\n                   };\n               }\n           )\n           .ScheduleParallel(); // Schedule as a parallel job\n           \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"实体查询"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WithAll<T>"}]},{"type":"text","value":" — 一个实体必须具有所有这些组件类型 (除了在lambda参数列表中找到所有组件类型之外)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WithAny<T,U>"}]},{"type":"text","value":" — 一个实体必须有一个或多个这样的组件类型.注意，允许使用WithAny指定单个组件类型;但是，由于实体必须有一个或多个这样的“可选”组件类型供查询选择，因此使用带有单个类型的WithAny等同于将该类型放在WithAll语句中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WithNone<T>"}]},{"type":"text","value":" — 实体不能具有任何这些组件类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WithChangeFilter<T>"}]},{"type":"text","value":" — 只选择子上次 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.6/api/Unity.Entities.JobComponentSystem.html","rel":["nofollow"]},"children":[{"type":"text","value":"JobComponentSystem"}]},{"type":"text","value":" 更新以来，特性组件发生变化的实体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WithSharedComponentFilter"}]},{"type":"text","value":" — 只选择拥有特定值的share component的块"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WithStoreEntityQueryInField"}]},{"type":"text","value":" — 把Entities.ForEach生成的 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.6/api/Unity.Entities.EntityQuery.html","rel":["nofollow"]},"children":[{"type":"text","value":"EntityQuery"}]},{"type":"text","value":" 对象存储在一个 EntityQuery 字段里. 您可以使用这个EntityQuery对象用于获取符合条件的实体的数量.注意，这个函数在创建JobComponentSystem时将EntityQuery实例分配给您的字段. 这意味着您可以在第一次执行lambda函数之前使用查询。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不要使用WithAny<T、U>或WithNone向查询添加参数列表中的组件。所有添加到lambda函数参数列表中的组件都会自动添加到实体查询的WithAll列表中;向WithAll列表和WithAny或WithNone列表添加组件会创建一个不合逻辑的查询。"}]},{"type":"element","tag":"pre","props":{"code":" Entities.WithAll<LocalToWorld>()\n    .WithAny<Rotation, Translation, Scale>()\n    .WithNone<LocalToParent>()\n    .ForEach((ref Destination outputData, in Source inputData) =>\n    {\n        /* do some work */\n    })\n    .Schedule(inputDeps);\n    \nEntities\n    .WithChangeFilter<Source>()\n    .ForEach((ref Destination outputData,\n    in Source inputData) =>\n    {\n    /* Do work */\n    })\n    .Schedule(inputDeps);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" Entities.WithAll<LocalToWorld>()\n    .WithAny<Rotation, Translation, Scale>()\n    .WithNone<LocalToParent>()\n    .ForEach((ref Destination outputData, in Source inputData) =>\n    {\n        /* do some work */\n    })\n    .Schedule(inputDeps);\n    \nEntities\n    .WithChangeFilter<Source>()\n    .ForEach((ref Destination outputData,\n    in Source inputData) =>\n    {\n    /* Do work */\n    })\n    .Schedule(inputDeps);\n"}]}]},{"type":"element","tag":"h4","props":{"id":"ijobchunk"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.14/manual/chunk_iteration_job.html","rel":["nofollow"]},"children":[{"type":"text","value":"IJobChunk"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"遍历所有符合条件的内存块(called a "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Chunk"}]},{"type":"text","value":")，其中包含的是符合条件的实体 . Job Execute() 方法可以用for循环遍历所有的块中的元素，你可以使用 IJobChunk 来执行比 IJobForEach更复杂的操作,同时保持最高效率."}]},{"type":"element","tag":"pre","props":{"code":"[BurstCompile]\nstruct UpdateJob : IJobChunk\n{\n    public ComponentTypeHandle<InputA> InputATypeHandle;\n    public ComponentTypeHandle<InputB> InputBTypeHandle;\n    [ReadOnly] public ComponentTypeHandle<Output> OutputTypeHandle;\n    public uint LastSystemVersion;\n\n    public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n    {\n        var inputAChanged = chunk.DidChange(InputATypeHandle, LastSystemVersion);\n        var inputBChanged = chunk.DidChange(InputBTypeHandle, LastSystemVersion);\n\n        // If neither component changed, skip the current chunk\n        if (!(inputAChanged || inputBChanged))\n            return;\n\n        var inputAs = chunk.GetNativeArray(InputATypeHandle);\n        var inputBs = chunk.GetNativeArray(InputBTypeHandle);\n        var outputs = chunk.GetNativeArray(OutputTypeHandle);\n\n        for (var i = 0; i < outputs.Length; i++)\n        {\n            outputs[i] = new Output { Value = inputAs[i].Value + inputBs[i].Value };\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[BurstCompile]\nstruct UpdateJob : IJobChunk\n{\n    public ComponentTypeHandle<InputA> InputATypeHandle;\n    public ComponentTypeHandle<InputB> InputBTypeHandle;\n    [ReadOnly] public ComponentTypeHandle<Output> OutputTypeHandle;\n    public uint LastSystemVersion;\n\n    public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n    {\n        var inputAChanged = chunk.DidChange(InputATypeHandle, LastSystemVersion);\n        var inputBChanged = chunk.DidChange(InputBTypeHandle, LastSystemVersion);\n\n        // If neither component changed, skip the current chunk\n        if (!(inputAChanged || inputBChanged))\n            return;\n\n        var inputAs = chunk.GetNativeArray(InputATypeHandle);\n        var inputBs = chunk.GetNativeArray(InputBTypeHandle);\n        var outputs = chunk.GetNativeArray(OutputTypeHandle);\n\n        for (var i = 0; i < outputs.Length; i++)\n        {\n            outputs[i] = new Output { Value = inputAs[i].Value + inputBs[i].Value };\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"manual-iteration"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/manual_iteration.html","rel":["nofollow"]},"children":[{"type":"text","value":"Manual iteration"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果以前的方法不足, 您可以手动遍历实体或块.例如，您可以获得一个包含实体的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeArray"}]},{"type":"text","value":"，或者您想要处理的实体的块，使用Job(比如"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobParallelFor"}]},{"type":"text","value":")对它们进行遍历。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/ecs_entity_query.html","rel":["nofollow"]},"children":[{"type":"text","value":"EntityQuery"}]},{"type":"text","value":" 类提供了一个构造一个你数据的视图方法，这个视图仅仅包含你算法或者程序中需要的特定的数据. 上面列表中的许多遍历方法都使用EntityQuery，无论是显式的还是内部的。就是可以通过 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/ecs_entity_query.html","rel":["nofollow"]},"children":[{"type":"text","value":"EntityQuery"}]},{"type":"text","value":" 来只遍历符合条件的实体或组件"}]},{"type":"element","tag":"h2","props":{"id":"系统-system"},"children":[{"type":"text","value":"系统 System"}]},{"type":"element","tag":"h3","props":{"id":"disableautocreation"},"children":[{"type":"text","value":"DisableAutoCreation"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果只是单纯的createsystem,不会执行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnStartRunning"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnStopRunning"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnUpdate"}]},{"type":"text","value":"..但是会执行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnCreate"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnDestroy"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddSystemToUpdateList"}]},{"type":"text","value":" 且 Entities.ForEach中的query有结果才会执行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnStartRunning"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnStopRunning"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnUpdate"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DisableAutoCreation"}]},{"type":"text","value":",但不"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddSystemToUpdateList"}]},{"type":"text","value":"添加到循环列表中,把一个system当作工具类使用"}]},{"type":"element","tag":"h3","props":{"id":"实体查询"},"children":[{"type":"text","value":"实体查询"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个System根据什么来决定处理哪些实体呢？这时候会用到一个叫实体查询(Entity Query)的东西。实体查询首先需要一些组件类型，然后根据你传入的组件类型的组合，在包含这些组件的原型中查询符合要求的实体。查询时可以指定下面三种类型："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"All"}]},{"type":"text","value":" 必须包含All中所有的组件类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Any"}]},{"type":"text","value":" 必须包含Any中至少一个组件类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"None"}]},{"type":"text","value":" 不能包含None中任意一个组件类型"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一次实体查询的结果会返回所有符合查询要求的内存块，你可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobChunk"}]},{"type":"text","value":"来迭代遍历所有的组件"}]},{"type":"element","tag":"h3","props":{"id":"jobs-作业"},"children":[{"type":"text","value":"Jobs 作业"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之前说过，ECS配合Job使用才能发挥多线程的威力。ECS提供了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemBase"}]},{"type":"text","value":"类，其中包含"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entities.ForEach"}]},{"type":"text","value":"方法，还包含了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobChunk"}]},{"type":"text","value":"的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule()"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ScheduleParallel()"}]},{"type":"text","value":"方法，可以在子线程中处理数据。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entities.ForEach"}]},{"type":"text","value":"是最简单的方法，只需要几行代码就能实现。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJobChunk"}]},{"type":"text","value":"可以用来处理比较复杂的情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS会在主线程调度Job，根据System的顺序。当job调度后，ECS会追踪哪些job在读写哪些组件。需要读权限的job需要等待前面写权限的job执行完，反之亦然。Job调度器会使用job依赖来决定哪些job可以并行，哪些必须串行。"}]},{"type":"element","tag":"h3","props":{"id":"system的组织"},"children":[{"type":"text","value":"System的组织"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"World"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"group"}]},{"type":"text","value":"来组织system。默认情况下，ECS会创建一个默认的World，包含一些预定义的group组。它会找到工程中所有的System，实例化他们，并添加到预定义的group中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以指定同一个group中system的Update的执行顺序。Group也是一种system，所以你可以将一个group添加到另外一个group中。如果你没有指定顺序，system的执行顺序会不太确定，并不会按照它们创建的顺序。不过，同一个group中的所有system都会比下一个group中的system先执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"System的Update是在主线程中执行的，不过可以使用Job将工作分配到子线程中。"}]},{"type":"element","tag":"h2","props":{"id":"组件-component"},"children":[{"type":"text","value":"组件 Component"}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.14/manual/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"Entity Component System 官方文档"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/BV1sD4y1Q7an","rel":["nofollow"]},"children":[{"type":"text","value":"DOTS从原理到应用"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/BV18J411t7G8","rel":["nofollow"]},"children":[{"type":"text","value":"Unity DOTS技术详解"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://connect.unity.com/u/enthervarope/column","rel":["nofollow"]},"children":[{"type":"text","value":"Unity ECS简单示例"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/andrewfan/category_8967683.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity中的ECS编程"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/lrh3025/category_9668656.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity ECS_翻译"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"原型-archetypes","depth":2,"text":"原型 Archetypes"},{"id":"实体-entity","depth":2,"text":"实体 Entity","children":[{"id":"创建entity","depth":3,"text":"创建Entity"},{"id":"添加删除-component","depth":3,"text":"添加/删除 component"},{"id":"访问实体数据","depth":3,"text":"访问实体数据"}]},{"id":"系统-system","depth":2,"text":"系统 System","children":[{"id":"disableautocreation","depth":3,"text":"DisableAutoCreation"},{"id":"实体查询","depth":3,"text":"实体查询"},{"id":"jobs-作业","depth":3,"text":"Jobs 作业"},{"id":"system的组织","depth":3,"text":"System的组织"}]},{"id":"组件-component","depth":2,"text":"组件 Component"}]}},"_type":"markdown","_id":"content:unity:2020-10-15-unity-ecs.md","_source":"content","_file":"unity/2020-10-15-unity-ecs.md","_extension":"md","date":"2020-10-15"},{"_path":"/unity/2020-10-16-unity-job","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY JOB SYSTEM详解","description":"创建Job需要定义一个结构体，实现IJob接口。实现了IJob接口之后，就可以让这个Job和其他Job并行运行了。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"创建job"},"children":[{"type":"text","value":"创建Job"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建Job需要定义一个结构体，实现"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":"接口。实现了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":"接口之后，就可以让这个Job和其他Job并行运行了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"到这呢，就可以给Job一个真正的定义了：Job是一个统称，任何实现了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":"接口的结构体，都可以成为一个Job。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建Job的步骤如下：\n1、创建一个实现"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IJob"}]},{"type":"text","value":"接口的结构体\n2、给结构体添加所需的成员变量，可以使用blittable类型或者NativeContainer类型。\n3、在结构体中添加一个Execute方法，具体执行的任务在这个方法里实现。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当执行Job时，Execute方法会在一个内核上执行完毕。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：设计job时，记住job操作的是数据的拷贝，除非使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeContainer"}]},{"type":"text","value":"。所以，在主线程访问job数据的唯一方法就是写入"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeContainer"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实例代码如下："}]},{"type":"element","tag":"pre","props":{"className":["language-cpp"],"code":"// 这个Job的功能：将两个浮点数相加\npublic struct MyJob : IJob\n{\n    public float a;\n    public float b;\n    public NativeArray<float> result;\n\n    public void Execute()\n    {\n        result[0] = a + b;\n    }\n}\n","language":"cpp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 这个Job的功能：将两个浮点数相加\npublic struct MyJob : IJob\n{\n    public float a;\n    public float b;\n    public NativeArray<float> result;\n\n    public void Execute()\n    {\n        result[0] = a + b;\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"调度job"},"children":[{"type":"text","value":"调度Job"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建Job后，如何执行一个Job呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时候需要调度Job，调度Job的步骤如下：\n1、实例化Job\n2、构造Job的数据\n3、调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule"}]},{"type":"text","value":"方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule"}]},{"type":"text","value":"方法会将Job放到Job执行队列的适当位置。一旦安排了Job后，就不能再中断job执行了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"注意"}]},{"type":"text","value":"：只能在主线程中调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule"}]},{"type":"text","value":"方法。"}]},{"type":"element","tag":"pre","props":{"className":["language-cpp"],"code":"// 创建一个长度为1的native array用来存储job执行后的结果\nNativeArray<float> result = new NativeArray<float>(1, Allocator.TempJob);\n\n// 设置job的数据\nMyJob jobData = new MyJob();\njobData.a = 10;\njobData.b = 10;\njobData.result = result;\n\n// Schedule\nJobHandle handle = jobData.Schedule();\n\n// 等待job执行完毕\nhandle.Complete();\n\n// 获取result中的数据\nfloat aPlusB = result[0];\n\n// 一定要释放native array申请的内存\nresult.Dispose();\n","language":"cpp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 创建一个长度为1的native array用来存储job执行后的结果\nNativeArray<float> result = new NativeArray<float>(1, Allocator.TempJob);\n\n// 设置job的数据\nMyJob jobData = new MyJob();\njobData.a = 10;\njobData.b = 10;\njobData.result = result;\n\n// Schedule\nJobHandle handle = jobData.Schedule();\n\n// 等待job执行完毕\nhandle.Complete();\n\n// 获取result中的数据\nfloat aPlusB = result[0];\n\n// 一定要释放native array申请的内存\nresult.Dispose();\n"}]}]},{"type":"element","tag":"h1","props":{"id":"job的依赖关系"},"children":[{"type":"text","value":"Job的依赖关系"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很多时候，Job并不是独立运行的，需要依赖前一个Job的结果，这时候如何调度呢？"}]},{"type":"element","tag":"h2","props":{"id":"jobhandle"},"children":[{"type":"text","value":"JobHandle"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule"}]},{"type":"text","value":"方法时，会返回一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobHandle"}]},{"type":"text","value":"。你可以使用这个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobHandle"}]},{"type":"text","value":"作为其他job的依赖项。具体方法就是将第一个job的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobHandle"}]},{"type":"text","value":"传给第二个job调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule"}]},{"type":"text","value":"时的参数，例如："}]},{"type":"element","tag":"pre","props":{"className":["language-undefined"],"code":"JobHandle firstJobHandle = firstJob.Schedule();\nsecondJob.Schedule(firstJobHandle);\n","language":"undefined","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"JobHandle firstJobHandle = firstJob.Schedule();\nsecondJob.Schedule(firstJobHandle);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那如果一个job有多个依赖项怎么办呢？这时候可以用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobHandle.CombineDependencies"}]},{"type":"text","value":"方法合并他们。具体如下："}]},{"type":"element","tag":"pre","props":{"className":["language-cpp"],"code":"// 声明一个JobHandle的NativeArray数组\nNativeArray<JobHandle> handles = new NativeArray<JobHandle>(numJobs, Allocator.TempJob);\n\n// 将多个handles放到数组中\n\n// 将多个handles合并到一起\nJobHandle jh = JobHandle.CombineDependencies(handles);\n","language":"cpp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 声明一个JobHandle的NativeArray数组\nNativeArray<JobHandle> handles = new NativeArray<JobHandle>(numJobs, Allocator.TempJob);\n\n// 将多个handles放到数组中\n\n// 将多个handles合并到一起\nJobHandle jh = JobHandle.CombineDependencies(handles);\n"}]}]},{"type":"element","tag":"h1","props":{"id":"等待job执行完毕"},"children":[{"type":"text","value":"等待Job执行完毕"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在主线程中如何等待Job执行完毕呢？可以调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobHandle"}]},{"type":"text","value":"中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Complete"}]},{"type":"text","value":"方法强制等待。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Complete"}]},{"type":"text","value":"方法执行过后，你就可以在主线程中安全地访问job中使用的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeContainer"}]},{"type":"text","value":"了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"注意"}]},{"type":"text","value":"\n当你调用job的Schedule方法后，job并不会立即开始执行。如果你在主线程中等待job执行完毕，并且你需要访问job使用的NativeContainer中的数据时，你可以调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"JobHandle.Complete"}]},{"type":"text","value":"方法。这个方法会启动job的执行。调用JobHandle的Complete方法后，会将job的NativeContainer所有权还给主线程。所以只有调用过JobHandle上的Complete方法后，主线程才能安全的访问NativeContainer中的数据。同理，也可以调用依赖此job的JobHandle上的Complete方法。例如，你可以调用jobA的Complete方法，也可以调用依赖jobA的JobB的Complete方法。这两种情况下，主线程都可以安全访问jobA使用的NativeContainer。"}]},{"type":"element","tag":"h2","props":{"id":"实例代码"},"children":[{"type":"text","value":"实例代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Job代码："}]},{"type":"element","tag":"pre","props":{"className":["language-cpp"],"code":"// Job：两个浮点数相加\npublic struct MyJob : IJob\n{\n    public float a;\n    public float b;\n    public NativeArray<float> result;\n\n    public void Execute()\n    {\n        result[0] = a + b;\n    }\n}\n\n// Job：给一个值加一\npublic struct AddOneJob : IJob\n{\n    public NativeArray<float> result;\n    \n    public void Execute()\n    {\n        result[0] = result[0] + 1;\n    }\n}\n","language":"cpp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Job：两个浮点数相加\npublic struct MyJob : IJob\n{\n    public float a;\n    public float b;\n    public NativeArray<float> result;\n\n    public void Execute()\n    {\n        result[0] = a + b;\n    }\n}\n\n// Job：给一个值加一\npublic struct AddOneJob : IJob\n{\n    public NativeArray<float> result;\n    \n    public void Execute()\n    {\n        result[0] = result[0] + 1;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主线程代码："}]},{"type":"element","tag":"pre","props":{"className":["language-cpp"],"code":"// 创建存储结果的NativeArray\nNativeArray<float> result = new NativeArray<float>(1, Allocator.TempJob);\n\n// 设置job #1\nMyJob jobData = new MyJob();\njobData.a = 10;\njobData.b = 10;\njobData.result = result;\n\n// 调度job1\nJobHandle firstHandle = jobData.Schedule();\n\n// 设置job2\nAddOneJob incJobData = new AddOneJob();\nincJobData.result = result;\n\n// 调度 job2，依赖job1\nJobHandle secondHandle = incJobData.Schedule(firstHandle);\n\n// 等待job2执行完毕\nsecondHandle.Complete();\n\n// 访问结果\nfloat aPlusB = result[0];\n\n// 释放内存\nresult.Dispose();\n","language":"cpp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 创建存储结果的NativeArray\nNativeArray<float> result = new NativeArray<float>(1, Allocator.TempJob);\n\n// 设置job #1\nMyJob jobData = new MyJob();\njobData.a = 10;\njobData.b = 10;\njobData.result = result;\n\n// 调度job1\nJobHandle firstHandle = jobData.Schedule();\n\n// 设置job2\nAddOneJob incJobData = new AddOneJob();\nincJobData.result = result;\n\n// 调度 job2，依赖job1\nJobHandle secondHandle = incJobData.Schedule(firstHandle);\n\n// 等待job2执行完毕\nsecondHandle.Complete();\n\n// 访问结果\nfloat aPlusB = result[0];\n\n// 释放内存\nresult.Dispose();\n"}]}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/cn/2020.2/Manual/JobSystem.html","rel":["nofollow"]},"children":[{"type":"text","value":"C# 作业系统 - Unity 手册 (unity3d.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://mp.weixin.qq.com/s/ZOVzDZQYBkfs6gAdrTMJUA","rel":["nofollow"]},"children":[{"type":"text","value":"Job System介绍"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://mp.weixin.qq.com/s?__biz=MzU5MjQ1NTEwOA==&mid=2247495224&idx=1&sn=6da0b515c54aee71ae64166369ae2320&chksm=fe1dda93c96a53851da09775d9c4a8947a26b26dfdc4aba2775685efee3451c026a8d353a851&mpshare=1&scene=23&srcid=1026M4Dnvzb65VokHexArRV2#rd","rel":["nofollow"]},"children":[{"type":"text","value":"深入解读Job System（1） "}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://mp.weixin.qq.com/s?__biz=MzU5MjQ1NTEwOA==&mid=2247495225&idx=1&sn=8c7212a747704da0b85d364529464509&chksm=fe1dda92c96a53848bca7cf95731ce8a9c853c80a4d3e7aa3f249c87d3a50620f30ce85254d6&mpshare=1&scene=23&srcid=1026HlBykd8qHTStfScE4ION#rd","rel":["nofollow"]},"children":[{"type":"text","value":"深入解读Job system（2）"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"jobhandle","depth":2,"text":"JobHandle"},{"id":"实例代码","depth":2,"text":"实例代码"}]}},"_type":"markdown","_id":"content:unity:2020-10-16-unity-job.md","_source":"content","_file":"unity/2020-10-16-unity-job.md","_extension":"md","date":"2020-10-16"},{"_path":"/unity/2020-10-17-runtime-spriteatlas","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"运行时打包图集","description":"不管NGUI还是UGUI，图集都是在制作期间就生成了的，运行时是一张大图，这样做的好处在于我们可以在一定程度上去合并批次，但是图集通常在制作过程中，会分成commonatlas和系统atlas两类，一个界面prefab至少会用到两张图集，就会出现ABA的图集穿插打断合批的情况。还有一种游戏内容多了以后，各种图片也相应的变多，类似图标、commonatlas这种图集，一张2048x2048可能就放不下了，这时候如果用到两张2048x2048，就又出现了之前说的ABA的情况，而且内存上也上去了。这时候就出现了新的解决方案：动态图集。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不管NGUI还是UGUI，图集都是在制作期间就生成了的，运行时是一张大图，这样做的好处在于我们可以在一定程度上去合并批次，但是图集通常在制作过程中，会分成commonatlas和系统atlas两类，一个界面prefab至少会用到两张图集，就会出现ABA的图集穿插打断合批的情况。还有一种游戏内容多了以后，各种图片也相应的变多，类似图标、commonatlas这种图集，一张2048x2048可能就放不下了，这时候如果用到两张2048x2048，就又出现了之前说的ABA的情况，而且内存上也上去了。这时候就出现了新的解决方案：动态图集。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"动态图集其实就是我们在打包的时候，图片是零散的，但是最后运行时，自动生成一张空白大图片，然后将界面上用到的零散的图片绘制在这个大图上，只将这个大图传入到gpu里头，达到合批的效果。由于手机界面制作过程中，标准分辨率往往是低于2048的，所以一张2048的动态图集就能完全解决一个界面的绘制工作了，但是动态图集也是有缺点的，动态图集因为将图集的生成过程延迟到了游戏运行时，所以必然会比静态图集多了图集生成的成本，当然这也是可以优化的。并且在目前的动态图集生成方案中，还没有出现公开的支持压缩的动态图集解决方案，所以动态图集目前看来只能是RGBA32的格式。还有一点，静态图集由于图片在生成过程中是确定的，可以将分配算法做得很好，图集的利用率也能做到很高。动态图集由于图片是动态生成的，在游戏运行过程中也会动态的增减图片，类似操作系统的内存分配算法，图集必然会出现碎片，图集的利用率也不可能做得很高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说了那么多 就做个demo来看看动态图集的威力吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个demo只是简单的演示一下动态图集的主要思路，图片分配算法也只是将大图片分成128x128的一个一个分区，每个分区采用引用计数开控制是否在使用图片，用于维护整个UI系统的话，这种算法并不适用，但是如果只是用于icon图标的话，由于icon图标是固定尺寸的，所以这套算法就很合适了。下面上源码："}]},{"type":"element","tag":"pre","props":{"code":"\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n \npublic class NxSpriteInfo\n{\n    private int _x;\n    private int _y;\n    private Sprite _sprite;\n    private int _referenceCount;\n \n    private int _width;\n    private int _height;\n \n    public int x { get { return _x; } }\n    public int y { get { return _y; } }\n \n    public Sprite sprite\n    {\n        get { return _sprite; }\n    }\n \n    public NxSpriteInfo(int x, int y, Texture2D mainTexture, int startX, int startY, int width, int height)\n    {\n        _x = x;\n        _y = y;\n        _referenceCount = 0;\n \n        _width = width;\n        _height = height;\n \n        _sprite = Sprite.Create(mainTexture, new Rect(startX, startY, width, height), Vector2.one / 2f);\n    }\n \n    public bool IsEmpty()\n    {\n        return _referenceCount == 0;\n    }\n \n    public void AddReference()\n    {\n        ++_referenceCount;\n        Debug.Log(string.Format(\"[AddReference]Sprite:[{0},{1}] ref:{2}\", x, y, _referenceCount));\n    }\n \n    public void RemoveReference()\n    {\n        if (_referenceCount == 0) return;\n        --_referenceCount;\n \n        Debug.Log(string.Format(\"[RemoveReference]Sprite:[{0},{1}] ref:{2}\", x, y, _referenceCount));\n    }\n}\n \npublic class DynamicAtlas : MonoBehaviour\n{\n    private const int MAX_DYNAMIC_ATLAS_SIZE = 1024;\n    private const int DYNAMIC_ATLAS_CELL_SIZE = 128;\n    private const int DYNAMIC_ATLAS_CELL_COUNT = MAX_DYNAMIC_ATLAS_SIZE / DYNAMIC_ATLAS_CELL_SIZE;\n \n    [SerializeField]\n    private Texture2D _dynamicAtlasTex;\n \n    // 策略 分成格子\n    private List<NxSpriteInfo> _spriteCacheList;\n    private Dictionary<int, int> _spriteRedirectMap = new Dictionary<int, int>();\n \n    private void Awake()\n    {\n        _dynamicAtlasTex = new Texture2D(MAX_DYNAMIC_ATLAS_SIZE, MAX_DYNAMIC_ATLAS_SIZE, TextureFormat.RGBA32, false);\n        _initCacheSprite();\n    }\n \n    private void _initCacheSprite()\n    {\n        int cellCount = DYNAMIC_ATLAS_CELL_COUNT;\n \n        _spriteCacheList = new List<NxSpriteInfo>();\n        for (int i = 0; i < cellCount; ++i)\n        {\n            for (int j = 0; j < cellCount; ++j)\n            {\n                _spriteCacheList.Add(new NxSpriteInfo(i, j, \n                    _dynamicAtlasTex,\n                    i * DYNAMIC_ATLAS_CELL_SIZE, j * DYNAMIC_ATLAS_CELL_SIZE,\n                    DYNAMIC_ATLAS_CELL_SIZE, DYNAMIC_ATLAS_CELL_SIZE));\n            }\n        }\n    }\n \n    public Sprite GetOrLoadSprite(Sprite sprite)\n    {\n        // 拿缓存\n        var spriteInstanceID = sprite.GetInstanceID();\n        //Debug.Log(string.Format(\" name: {0} instanceid: {1}\", sprite.name, spriteInstanceID));\n        int index = -1;\n        if (_spriteRedirectMap.TryGetValue(spriteInstanceID, out index))\n        {\n            var newSprite = _spriteCacheList[index];\n            newSprite.AddReference();\n            return newSprite.sprite;\n        }\n \n        // 检查是不是本身就是动态生成的 如果是的话 什么都不用做\n        for (int i = 0; i < _spriteCacheList.Count; ++i)\n        {\n            var sp = _spriteCacheList[i];\n            if (sp.sprite == sprite)\n            {\n                return sprite;\n            }\n        }\n \n        // 拿不到缓存就找个空格子新增\n        var emptySprite = GetEmptySprite();\n        if (emptySprite != null)\n        {\n            // GPU上直接操作 速度快 兼容性差\n            Graphics.CopyTexture(sprite.texture, 0, 0, (int)sprite.rect.x, (int)sprite.rect.y, (int)sprite.rect.width, (int)sprite.rect.height,\n                                _dynamicAtlasTex, 0, 0, (int)emptySprite.sprite.rect.x, (int)emptySprite.sprite.rect.y);\n \n            // 这里要先删除上一个的\n            index = GetIndex(emptySprite);\n            foreach (var redirect in _spriteRedirectMap)\n            {\n                if (redirect.Value == index)\n                {\n                    _spriteRedirectMap.Remove(redirect.Key);\n                    break;\n                }\n            }\n            _spriteRedirectMap.Add(spriteInstanceID, GetIndex(emptySprite));\n            emptySprite.AddReference();\n            emptySprite.sprite.name = sprite.name + \"(Dynamic)\";\n            return emptySprite.sprite;\n        }\n \n        // 找不到空格子就直接返回sprite\n        return sprite;\n    }\n \n    public void ReleaseSprite(Sprite sprite)\n    {\n        for (int i = 0; i < _spriteCacheList.Count; ++i)\n        {\n            var sp = _spriteCacheList[i];\n            if (sp.sprite == sprite)\n            {\n                sp.RemoveReference();\n                break;\n            }\n        }\n    }\n \n    private NxSpriteInfo GetEmptySprite()\n    {\n        for (int i = 0; i < _spriteCacheList.Count; ++i)\n        {\n            var sp = _spriteCacheList[i];\n            if (sp.IsEmpty())\n                return sp;\n        }\n        return null;\n    }\n \n    private int GetIndex(NxSpriteInfo sprite)\n    {\n        return sprite.x * DYNAMIC_ATLAS_CELL_COUNT + sprite.y;\n    }\n \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n \npublic class NxSpriteInfo\n{\n    private int _x;\n    private int _y;\n    private Sprite _sprite;\n    private int _referenceCount;\n \n    private int _width;\n    private int _height;\n \n    public int x { get { return _x; } }\n    public int y { get { return _y; } }\n \n    public Sprite sprite\n    {\n        get { return _sprite; }\n    }\n \n    public NxSpriteInfo(int x, int y, Texture2D mainTexture, int startX, int startY, int width, int height)\n    {\n        _x = x;\n        _y = y;\n        _referenceCount = 0;\n \n        _width = width;\n        _height = height;\n \n        _sprite = Sprite.Create(mainTexture, new Rect(startX, startY, width, height), Vector2.one / 2f);\n    }\n \n    public bool IsEmpty()\n    {\n        return _referenceCount == 0;\n    }\n \n    public void AddReference()\n    {\n        ++_referenceCount;\n        Debug.Log(string.Format(\"[AddReference]Sprite:[{0},{1}] ref:{2}\", x, y, _referenceCount));\n    }\n \n    public void RemoveReference()\n    {\n        if (_referenceCount == 0) return;\n        --_referenceCount;\n \n        Debug.Log(string.Format(\"[RemoveReference]Sprite:[{0},{1}] ref:{2}\", x, y, _referenceCount));\n    }\n}\n \npublic class DynamicAtlas : MonoBehaviour\n{\n    private const int MAX_DYNAMIC_ATLAS_SIZE = 1024;\n    private const int DYNAMIC_ATLAS_CELL_SIZE = 128;\n    private const int DYNAMIC_ATLAS_CELL_COUNT = MAX_DYNAMIC_ATLAS_SIZE / DYNAMIC_ATLAS_CELL_SIZE;\n \n    [SerializeField]\n    private Texture2D _dynamicAtlasTex;\n \n    // 策略 分成格子\n    private List<NxSpriteInfo> _spriteCacheList;\n    private Dictionary<int, int> _spriteRedirectMap = new Dictionary<int, int>();\n \n    private void Awake()\n    {\n        _dynamicAtlasTex = new Texture2D(MAX_DYNAMIC_ATLAS_SIZE, MAX_DYNAMIC_ATLAS_SIZE, TextureFormat.RGBA32, false);\n        _initCacheSprite();\n    }\n \n    private void _initCacheSprite()\n    {\n        int cellCount = DYNAMIC_ATLAS_CELL_COUNT;\n \n        _spriteCacheList = new List<NxSpriteInfo>();\n        for (int i = 0; i < cellCount; ++i)\n        {\n            for (int j = 0; j < cellCount; ++j)\n            {\n                _spriteCacheList.Add(new NxSpriteInfo(i, j, \n                    _dynamicAtlasTex,\n                    i * DYNAMIC_ATLAS_CELL_SIZE, j * DYNAMIC_ATLAS_CELL_SIZE,\n                    DYNAMIC_ATLAS_CELL_SIZE, DYNAMIC_ATLAS_CELL_SIZE));\n            }\n        }\n    }\n \n    public Sprite GetOrLoadSprite(Sprite sprite)\n    {\n        // 拿缓存\n        var spriteInstanceID = sprite.GetInstanceID();\n        //Debug.Log(string.Format(\" name: {0} instanceid: {1}\", sprite.name, spriteInstanceID));\n        int index = -1;\n        if (_spriteRedirectMap.TryGetValue(spriteInstanceID, out index))\n        {\n            var newSprite = _spriteCacheList[index];\n            newSprite.AddReference();\n            return newSprite.sprite;\n        }\n \n        // 检查是不是本身就是动态生成的 如果是的话 什么都不用做\n        for (int i = 0; i < _spriteCacheList.Count; ++i)\n        {\n            var sp = _spriteCacheList[i];\n            if (sp.sprite == sprite)\n            {\n                return sprite;\n            }\n        }\n \n        // 拿不到缓存就找个空格子新增\n        var emptySprite = GetEmptySprite();\n        if (emptySprite != null)\n        {\n            // GPU上直接操作 速度快 兼容性差\n            Graphics.CopyTexture(sprite.texture, 0, 0, (int)sprite.rect.x, (int)sprite.rect.y, (int)sprite.rect.width, (int)sprite.rect.height,\n                                _dynamicAtlasTex, 0, 0, (int)emptySprite.sprite.rect.x, (int)emptySprite.sprite.rect.y);\n \n            // 这里要先删除上一个的\n            index = GetIndex(emptySprite);\n            foreach (var redirect in _spriteRedirectMap)\n            {\n                if (redirect.Value == index)\n                {\n                    _spriteRedirectMap.Remove(redirect.Key);\n                    break;\n                }\n            }\n            _spriteRedirectMap.Add(spriteInstanceID, GetIndex(emptySprite));\n            emptySprite.AddReference();\n            emptySprite.sprite.name = sprite.name + \"(Dynamic)\";\n            return emptySprite.sprite;\n        }\n \n        // 找不到空格子就直接返回sprite\n        return sprite;\n    }\n \n    public void ReleaseSprite(Sprite sprite)\n    {\n        for (int i = 0; i < _spriteCacheList.Count; ++i)\n        {\n            var sp = _spriteCacheList[i];\n            if (sp.sprite == sprite)\n            {\n                sp.RemoveReference();\n                break;\n            }\n        }\n    }\n \n    private NxSpriteInfo GetEmptySprite()\n    {\n        for (int i = 0; i < _spriteCacheList.Count; ++i)\n        {\n            var sp = _spriteCacheList[i];\n            if (sp.IsEmpty())\n                return sp;\n        }\n        return null;\n    }\n \n    private int GetIndex(NxSpriteInfo sprite)\n    {\n        return sprite.x * DYNAMIC_ATLAS_CELL_COUNT + sprite.y;\n    }\n \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键代码都在GetOrLoadSprite这个函数里面了，其中最重要的一句就是Graphics.CopyTexture，这个是直接在GPU上操作图片，速度非常快，但是缺点是兼容性不是很好，也用备用方案，直接上内存copy再传到gpu上，会慢一些，demo这里就不做演示了，需要的自行查相关资料，我记得雨松似乎做过类似分享，当时应该是用于角色的贴图合并。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外配合这个DynamicAtlas，我也做了一个NxImage来配合它，简单继承了一下ugui的image，在awake和ondestory做了引用计数的加减，只是用于功能演示，真正用到项目中，应该会更加注重细节。"}]},{"type":"element","tag":"pre","props":{"code":"\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.UI;\n \npublic class NxImage : Image\n{\n    protected override void Start()\n    {\n        base.Start();\n \n        if (Application.isPlaying && this.sprite != null)\n        {\n            var dynamicAtlasGo = GameObject.Find(\"DynamicAtlas\");\n            if (dynamicAtlasGo == null)\n            {\n                GameObject go = new GameObject();\n                go.name = \"DynamicAtlas\";\n                go.AddComponent<DynamicAtlas>();\n                dynamicAtlasGo = go;\n            }\n \n            if (dynamicAtlasGo != null)\n            {\n                var dynamicAtlas = dynamicAtlasGo.GetComponent<DynamicAtlas>();\n                if (dynamicAtlas != null)\n                {\n                    this.sprite = dynamicAtlas.GetOrLoadSprite(this.sprite);\n                }\n            }\n        }\n    }\n \n    public void SetNewSprite(Sprite sp)\n    {\n        var dynamicAtlasGo = GameObject.Find(\"DynamicAtlas\");\n        if (dynamicAtlasGo != null)\n        {\n            var dynamicAtlas = dynamicAtlasGo.GetComponent<DynamicAtlas>();\n            if (dynamicAtlas != null)\n            {\n                if (this.sprite != null)\n                    dynamicAtlas.ReleaseSprite(this.sprite);\n                this.sprite = dynamicAtlas.GetOrLoadSprite(sp);\n            }\n        }\n    }\n \n    protected override void OnDestroy()\n    {\n        base.OnDestroy();\n \n        if (this.sprite != null)\n        {\n            var dynamicAtlasGo = GameObject.Find(\"DynamicAtlas\");\n            if (dynamicAtlasGo != null)\n            {\n                var dynamicAtlas = dynamicAtlasGo.GetComponent<DynamicAtlas>();\n                if (dynamicAtlas != null)\n                {\n                    dynamicAtlas.ReleaseSprite(this.sprite);\n                }\n            }\n        }\n \n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.UI;\n \npublic class NxImage : Image\n{\n    protected override void Start()\n    {\n        base.Start();\n \n        if (Application.isPlaying && this.sprite != null)\n        {\n            var dynamicAtlasGo = GameObject.Find(\"DynamicAtlas\");\n            if (dynamicAtlasGo == null)\n            {\n                GameObject go = new GameObject();\n                go.name = \"DynamicAtlas\";\n                go.AddComponent<DynamicAtlas>();\n                dynamicAtlasGo = go;\n            }\n \n            if (dynamicAtlasGo != null)\n            {\n                var dynamicAtlas = dynamicAtlasGo.GetComponent<DynamicAtlas>();\n                if (dynamicAtlas != null)\n                {\n                    this.sprite = dynamicAtlas.GetOrLoadSprite(this.sprite);\n                }\n            }\n        }\n    }\n \n    public void SetNewSprite(Sprite sp)\n    {\n        var dynamicAtlasGo = GameObject.Find(\"DynamicAtlas\");\n        if (dynamicAtlasGo != null)\n        {\n            var dynamicAtlas = dynamicAtlasGo.GetComponent<DynamicAtlas>();\n            if (dynamicAtlas != null)\n            {\n                if (this.sprite != null)\n                    dynamicAtlas.ReleaseSprite(this.sprite);\n                this.sprite = dynamicAtlas.GetOrLoadSprite(sp);\n            }\n        }\n    }\n \n    protected override void OnDestroy()\n    {\n        base.OnDestroy();\n \n        if (this.sprite != null)\n        {\n            var dynamicAtlasGo = GameObject.Find(\"DynamicAtlas\");\n            if (dynamicAtlasGo != null)\n            {\n                var dynamicAtlas = dynamicAtlasGo.GetComponent<DynamicAtlas>();\n                if (dynamicAtlas != null)\n                {\n                    dynamicAtlas.ReleaseSprite(this.sprite);\n                }\n            }\n        }\n \n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简单挂了几个图片上去测试，效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-17-runtime-spriteatlas/20190531235426813.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"运行后："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-17-runtime-spriteatlas/20190531235500426.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到drawcall明显降低了，我们再看看合并后真正用到的图片："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-17-runtime-spriteatlas/20190531235616604.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-17-runtime-spriteatlas/20190531235636594.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上就是动态生成图集的简单思路 仅供参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/DaVikingCode/UnityRuntimeSpriteSheetsGenerator","rel":["nofollow"]},"children":[{"type":"text","value":"DaVikingCode/UnityRuntimeSpriteSheetsGenerator: Unity – generate SpriteSheets at runtime! (github.com)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/jintiao/RuntimeTextureAtlas","rel":["nofollow"]},"children":[{"type":"text","value":"jintiao/RuntimeTextureAtlas: runtime texture atlas (github.com)"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-10-17-runtime-spriteatlas.md","_source":"content","_file":"unity/2020-10-17-runtime-spriteatlas.md","_extension":"md","date":"2020-10-17"},{"_path":"/unity/2020-10-18-unity-ecs-component","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity ecs component","description":"General Purpose ComponentShared component data    不存储在chunk中,而是存储在sharedComponentManager,而chunk中存的是索引.. 若ForEach中包含了Share Component，那么必须调用WithoutBurst方法和使用Run来执行Chunk component data    相当于单例...更改后,会更改所有相关实体System State Components  类似一个标记..但是实体销毁时,并不会回收entity,只有当所有satecomponent移除后Dynamic buffer compo","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"General Purpose Component"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Shared component data    不存储在chunk中,而是存储在sharedComponentManager,而chunk中存的是索引.. 若ForEach中包含了Share Component，那么必须调用WithoutBurst方法和使用Run来执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Chunk component data    相当于单例...更改后,会更改所有相关实体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"System State Components  类似一个标记..但是实体销毁时,并不会回收entity,只有当所有satecomponent移除后"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dynamic buffer components    可以理解为一个数组component"}]}]},{"type":"element","tag":"h2","props":{"id":"general-purpose-component普通用途组件"},"children":[{"type":"text","value":"General Purpose Component（普通用途组件）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里指的是最普通的组件，可以通过实现 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 接口来创建。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 不存储行为，只储存数据。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 还是一个结构体（Struct）而不是一个类（Class），这意味着被复制时默认是通过值而不是通过引用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常我们会用下面的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"模式"}]},{"type":"text","value":"来修改组件数据："}]},{"type":"element","tag":"pre","props":{"code":"var transform = group.transform[index]; // Read\n    \ntransform.heading = playerInput.move; // Modify\ntransform.position += deltaTime * playerInput.move * settings.playerMoveSpeed;\n\ngroup.transform[index] = transform; // Write\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var transform = group.transform[index]; // Read\n    \ntransform.heading = playerInput.move; // Modify\ntransform.position += deltaTime * playerInput.move * settings.playerMoveSpeed;\n\ngroup.transform[index] = transform; // Write\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 结构不包含托管对象（managed objects）的引用，所有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 被存在无垃圾回收的"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html","rel":["nofollow"]},"children":[{"type":"text","value":"块内存（chunk memory）"}]},{"type":"text","value":"中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能还听过一种组件是不包含数据、只用来标记的“Tag”组件（Tag component），其用途也很广，例如我们可以轻易地给实体加标记来区分玩家和敌人，这样系统中能更容易通过组件的类型来筛选我们想要的实体。如果我们给一个内存块（Chunk）中的所有实体都添加\"Tag“组件的话，只有内存块中对应的原型会修改，不添加数据，因此官方也推荐利用好”Tag“组件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"See file: /Packages/com.unity.entities/Unity.Entities/IComponentData.cs."}]},{"type":"element","tag":"h2","props":{"id":"shared-components共享组件"},"children":[{"type":"text","value":"Shared components（共享组件）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Shared components 是一种特殊的组件，你可以把某些特殊的需要共享的值放到 shared component 中，从而在实体中与其他组件划分开。例如有时候我们的实体需要共享一套材质，我们可以为需要共享的材质创建 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rendering.RenderMesh"}]},{"type":"text","value":"，再放到 shared components 中。原型中也可以定义 shared components，这一点和其他组件是一样的。"}]},{"type":"element","tag":"pre","props":{"code":"[System.Serializable]\npublic struct RenderMesh : ISharedComponentData\n{\n    public Mesh                 mesh;\n    public Material             material;\n\n    public ShadowCastingMode    castShadows;\n    public bool                 receiveShadows;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[System.Serializable]\npublic struct RenderMesh : ISharedComponentData\n{\n    public Mesh                 mesh;\n    public Material             material;\n\n    public ShadowCastingMode    castShadows;\n    public bool                 receiveShadows;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当你为一个实体添加一个 shared components 时， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":" 会把所有带有同样 shared components 的实体放到一个同样的内存块中（Chunks）。shared components 允许我们的系统去一并处理相似的（有同样 shared components 的）实体。"}]},{"type":"element","tag":"h3","props":{"id":"内存结构"},"children":[{"type":"text","value":"内存结构"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-18-unity-ecs-component/5d295d398f62598876.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个内存块（Chunk）会有一个存放 shared components 索引的数组。这句话包含了几个要点："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于实体来说，有同样 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的实体会被一起放到同样的内存块（Chunk）中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果我们有两个存储在同样的内存块中的两个实体，它们有同样的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 类型和值。我们修改其中一个实体的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的值，这样会导致这个实体会被移动到一个新的内存块中，因为一个内存块共享同一个数组的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 索引。事实上，从一个实体中增加或者移除一个组件，或者改变 shared components 的值都会导致这种操作的发生。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其索引存储在内存块而非实体中，因此 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 对实体来说是低开销的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"因为内存块只需要存其索引，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的内存消耗几乎可以忽略不计。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为上面的第二个要点，我们不能滥用 shared components。滥用 shared components 将让 Unity 不能利用好内存块（Chunk），因此我们要避免添加不必要的数据或修改数据到 shared components 中。我们可以通过 Entity Debugger 来监测内存块的利用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-18-unity-ecs-component/5d295b6d78b7f51832.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拿上一段 RenderMesh 的例子来说，共享材质会更有效率，因为 shared components 有其自己的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"manager"}]},{"type":"text","value":" 和哈希表。其中 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"manager"}]},{"type":"text","value":" 带有一个存储 shared components 数据的自由列表（"},{"type":"element","tag":"a","props":{"href":"https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%A1%A8","rel":["nofollow"]},"children":[{"type":"text","value":"freelist"}]},{"type":"text","value":"），哈希表可以快速地找到相应的值。内存块里面存的是索引数组，需要找数据的时候就会从 Shared Component Manager 中找。"}]},{"type":"element","tag":"h3","props":{"id":"其他要点"},"children":[{"type":"text","value":"其他要点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityQuery"}]},{"type":"text","value":" 可以迭代所有拥有相同 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的实体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"我们可以用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityQuery.SetFilter()"}]},{"type":"text","value":" 来迭代所有拥有某个特定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的实体。这种操作开销十分低，因为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetFilter"}]},{"type":"text","value":" 内部筛选的只是 int 的索引。前面说了每个内存块都有一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 索引数组，因此对于每个内存块来说，筛选（filtering）的消耗都是可以忽略不计的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"怎么样获取 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的值呢？"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager.GetAllUniqueSharedComponentData<T>"}]},{"type":"text","value":" 可以得到在存活的实体中（alive entities）的所有的泛型 T 类型的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 值，结果以参数中的列表返回，你也可以通过其重载的方法获得所有值的索引。其他获取值的方法可以参考 /Packages/com.unity.entities/Unity.Entities/EntityManagerAccessComponentData.cs。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 是自动引用计数的，例如在没有任何内存块拥有某个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 索引的时候，引用计数会置零，从而知道要删除"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 的数据 。这一点就能看出其在 ECS 的世界中是非常独特的存在，想要深入了解可以看这篇文章"},{"type":"element","tag":"a","props":{"href":"https://gametorrahod.com/everything-about-isharedcomponentdata/","rel":["nofollow"]},"children":[{"type":"text","value":"《Everything about ISharedComponentData》"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 应该尽量不去更改，因为更改 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 会导致实体的组件数据需要复制到其他的内存块中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你也可以读读这篇更深入的文章"},{"type":"element","tag":"a","props":{"href":"https://gametorrahod.com/everything-about-isharedcomponentdata/","rel":["nofollow"]},"children":[{"type":"text","value":"《Everything about ISharedComponentData》"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h2","props":{"id":"system-state-components系统状态组件"},"children":[{"type":"text","value":"System state components（系统状态组件）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemStateComponentData"}]},{"type":"text","value":" 允许你跟踪系统（System）的资源，并允许你合适地创建和删除某些资源，这些过程中不依赖独立的回调（individual callback）。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设有一个网络同步 System State，其监控一个 Component A 的同步，则我只需要定义一个 SystemStateComponent SA。当 Entity [有 A，无 SA] 时，表示 A 刚添加，此时添加 SA。等到 Entity [无 A，有 SA] 时,表示 A 被删除（尝试销毁Entity 时也会删除 A）。\n"},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/51289405","rel":["nofollow"]},"children":[{"type":"text","value":"《浅入浅出Unity ECS》"}]},{"type":"text","value":" BenzzZX"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemStateComponentData"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemStateSharedComponentData"}]},{"type":"text","value":" 这两个类型与 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentData"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SharedComponentData"}]},{"type":"text","value":" 十分相似，不同的是前者两个类型都是系统级别的，不会在实体删除的时候被删除。"}]},{"type":"element","tag":"h3","props":{"id":"motivation诱因"},"children":[{"type":"text","value":"Motivation（诱因）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"System state components 有这样特殊的行为，是因为："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"系统可能需要保持一个基于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentData"}]},{"type":"text","value":" 的内部状态。例如已经被分配的资源。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"系统需要通过值来管理这些状态，也需要管理其他系统所造成的的状态改变。例如在组件中的值改变的时候，或者在相关组件被添加或者被删除的时候。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"“没有回调”是 ECS 设计规则的重要元素。"}]}]},{"type":"element","tag":"h3","props":{"id":"concept概念"},"children":[{"type":"text","value":"Concept（概念）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemStateComponentData"}]},{"type":"text","value":" 普遍用法是镜像一个用户组件，并提供内部状态。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面引用的网络同步的例子中，A 就是用户分配的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentData"}]},{"type":"text","value":"，SA 就是系统分配的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemComponentData"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面以 FooComponent （"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentData"}]},{"type":"text","value":"）和 FooStateComponent（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemComponentData"}]},{"type":"text","value":"）做主要用途的示例。前两个用途已经在前面的网络同步例子中呈现过。"}]},{"type":"element","tag":"h4","props":{"id":"检测组件的添加"},"children":[{"type":"text","value":"检测组件的添加"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果用户添加 FooComponent 时，FooStateComponent 还不存在。FooSystem 会在 update 中查询，如果实体只有 FooComponent 而没有 FooStateComponent,，则可以判断这个实体是新添加的。这时候 FooSystem 会加上 FooStateComponent 组件和其他需要的内部状态。"}]},{"type":"element","tag":"h4","props":{"id":"检测组件的删除"},"children":[{"type":"text","value":"检测组件的删除"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果用户删除 FooComponent 后，FooStateComponent 仍然存在。FooSystem 会在 update 中查询，如果实体没有 FooComponent 而有 FooStateComponent,，则可以判断 FooComponent 已经被删除了。这时候 FooSystem 会给删除 FooStateComponent 组件和修改其他需要的内部状态。"}]},{"type":"element","tag":"h4","props":{"id":"监测实体的删除"},"children":[{"type":"text","value":"监测实体的删除"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 这个方法可以用来："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"找到所有由某个实体 ID 标记的所有组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"删除那些组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"回收实体 ID 以作重用"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然而，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 无法删除 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemStateComponentData"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在你删除实体时，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不会"}]},{"type":"text","value":"移除任何 system state components，在它们没被删除的时候，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":" 也不会回收其实体的 ID 。这样允许系统（System）在一个实体被删除的时候，去整理内部的状态（internal state），也能清理关联着实体 ID 的相关的资源和状态。实体 ID 只会在所有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SystemStateComponentData"}]},{"type":"text","value":" 被删除的时候才被重用。"}]},{"type":"element","tag":"h2","props":{"id":"dynamic-buffers动态缓冲"},"children":[{"type":"text","value":"Dynamic Buffers（动态缓冲）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 也是组件的一种类型，它能把一个变量内存空间大小的弹性的缓冲（variable-sized, “stretchy” buffer）和一个实体关联起来。它内部存储着一定数量的元素，但如果内部所占内存空间太大，会额外划分一个堆内存（heap memory）来存储。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"动态缓冲的内存管理是全自动的。与 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 关联的内存由 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":" 来管理，这样当"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 组件被删除的时候，所关联的堆内存空间也会自动释放掉。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的解释可能略显苍白，实际上 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 可以看成一个有默认大小的数组，其行为和性能都和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeArray"}]},{"type":"text","value":"（在 ECS 中常用的无 GC 容器类型）差不多，但是存储数据超过默认大小也没关系，上文提到了会创建一个堆内存来存储多的数据。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 可以通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ToNativeArray"}]},{"type":"text","value":" 转成 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeArray"}]},{"type":"text","value":" 类型，其中只是把指针重新指向缓冲，不会复制数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://tsubakit1.hateblo.jp/entry/2018/11/07/234502","rel":["nofollow"]},"children":[{"type":"text","value":"【Unity】ECSで配列を格納する Dynamic Buffers"}]},{"type":"text","value":" 这篇文章中，作者用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 来储存临近的圆柱体实体，从而更方便地与这些实体交互。"}]},{"type":"element","tag":"h3","props":{"id":"定义缓冲"},"children":[{"type":"text","value":"定义缓冲"}]},{"type":"element","tag":"pre","props":{"code":"// 8 指的是缓冲中默认元素的数量，例如这例子中存的是 Integer 类型\n// 那么 8 integers （32 bytes）就是缓冲的默认大小\n// 64 位机器中则占 16 bytes\n[InternalBufferCapacity(8)]\npublic struct MyBufferElement : IBufferElementData\n{\n    // 下面的隐式转换是可选的，这样可以少写些代码\n    public static implicit operator int(MyBufferElement e) { return e.Value; }\n    public static implicit operator MyBufferElement(int e) { return new MyBufferElement { Value = e }; }\n\n    // 每个缓冲元素要存储的值\n    public int Value;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 8 指的是缓冲中默认元素的数量，例如这例子中存的是 Integer 类型\n// 那么 8 integers （32 bytes）就是缓冲的默认大小\n// 64 位机器中则占 16 bytes\n[InternalBufferCapacity(8)]\npublic struct MyBufferElement : IBufferElementData\n{\n    // 下面的隐式转换是可选的，这样可以少写些代码\n    public static implicit operator int(MyBufferElement e) { return e.Value; }\n    public static implicit operator MyBufferElement(int e) { return new MyBufferElement { Value = e }; }\n\n    // 每个缓冲元素要存储的值\n    public int Value;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可能有点奇怪，我们要定义缓冲中元素的结构而不是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Buffer"}]},{"type":"text","value":" 缓冲本身，其实这样在 ECS 中有两个好处："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"float3"}]},{"type":"text","value":" 或者其他常见的值类型来说，这样能支持多种 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DynamicBuffer"}]},{"type":"text","value":" 。我们可以重用已有的缓冲元素的结构，来定义其他的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Buffers"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"我们可以将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Buffer"}]},{"type":"text","value":" 的元素类型包含在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityArchetypes"}]},{"type":"text","value":" 中，这样它会表现得像拥有一个组件一样。例如用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddBuffer()"}]},{"type":"text","value":" 方法，可以通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"entityManager.AddBuffer<MyBufferElement>(entity);"}]},{"type":"text","value":" 来添加缓冲。"}]}]},{"type":"element","tag":"h2","props":{"id":"关于prefab到entity"},"children":[{"type":"text","value":"关于prefab到entity"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IDeclareReferencedPrefabs"}]},{"type":"text","value":" ： 将prefab引用添加到Conversion World。在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IConvertGameObjectToEntity"}]},{"type":"text","value":"中可以通过GameObjectConversionSystem根据prefab获取entity"}]}]},{"type":"element","tag":"pre","props":{"code":"public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs) => referencedPrefabs.Add(Prefab);\n","language":"cpp","meta":"","className":["language-cpp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs) => referencedPrefabs.Add(Prefab);\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IConvertGameObjectToEntity"}]},{"type":"text","value":"：自动生成一个新的entity，然后自定义对entity的操作。"}]}]},{"type":"element","tag":"pre","props":{"code":"public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentData(entity, new PeriodicSpawner\n        {\n            Prefab = conversionSystem.GetPrimaryEntity(Prefab),\n            SecondsBetweenSpawns = 1 / SpawnsPerSecond\n        });\n    }\n","language":"cpp","meta":"","className":["language-cpp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentData(entity, new PeriodicSpawner\n        {\n            Prefab = conversionSystem.GetPrimaryEntity(Prefab),\n            SecondsBetweenSpawns = 1 / SpawnsPerSecond\n        });\n    }\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/Knightmore/MultiWorldBootstrap","rel":["nofollow"]},"children":[{"type":"text","value":"Knightmore/MultiWorldBootstrap: Unity ICustomBootstrap extension for multiple custom world creation in ECS (github.com)"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"general-purpose-component普通用途组件","depth":2,"text":"General Purpose Component（普通用途组件）"},{"id":"shared-components共享组件","depth":2,"text":"Shared components（共享组件）","children":[{"id":"内存结构","depth":3,"text":"内存结构"},{"id":"其他要点","depth":3,"text":"其他要点"}]},{"id":"system-state-components系统状态组件","depth":2,"text":"System state components（系统状态组件）","children":[{"id":"motivation诱因","depth":3,"text":"Motivation（诱因）"},{"id":"concept概念","depth":3,"text":"Concept（概念）"}]},{"id":"dynamic-buffers动态缓冲","depth":2,"text":"Dynamic Buffers（动态缓冲）","children":[{"id":"定义缓冲","depth":3,"text":"定义缓冲"}]},{"id":"关于prefab到entity","depth":2,"text":"关于prefab到entity"}]}},"_type":"markdown","_id":"content:unity:2020-10-18-unity-ecs-component.md","_source":"content","_file":"unity/2020-10-18-unity-ecs-component.md","_extension":"md","date":"2020-10-18"},{"_path":"/unity/2020-10-19-game-object-conversion-and-subscene","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","description":"*(译前言: Unity DOTS提出了一套全新的开发技术栈, 但目前少有精讲如何结合现有工作流进行开发的资料, 外网 *这篇文章 (Game Object Conversion and SubScene) 详细解构了基于 GameObject 和 Subscene 的工作流程和原理, 要求读者对 DOTS/ECS 有基本的了解, 虽然非常之长, 但值得一读)","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"*(译前言: Unity DOTS提出了一套全新的开发技术栈, 但目前少有精讲如何结合现有工作流进行开发的资料, 外网 *"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//gametorrahod.com/game-object-conversion-and-subscene/","rel":["nofollow"]},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"这篇文章 (Game Object Conversion and SubScene)"}]}]},{"type":"text","value":" 详细解构了基于 GameObject 和 Subscene 的工作流程和原理, 要求读者对 DOTS/ECS 有基本的了解, 虽然非常之长, 但值得一读)"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏基本上就是关于玩家的输入如何改变(设计好的)数据, 并从渲染结果中得到乐趣的过程. 传统上, 这些数据是用 Unity 的所见即所得的编辑器来设计的. 但是基于 GameObject 的数据和 ECS 并不兼容. 如果在设计数据阶段能保留Unity的传统模式同时在 Runtime 阶段使用 ECS 高效处理数据, 那就能完美结合两者的优点."}]},{"type":"element","tag":"h2","props":{"id":"以前是如何制作游戏的"},"children":[{"type":"text","value":"以前是如何制作游戏的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-6189e6b1d575c1ad9bbec966f5e99ee4_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如上图, 首先想想为什么方块能在每帧都被正确绘制到屏幕上? 在传统的 GameObject 里, 引擎会编译并排序整个 hierarchy 树, 同时按顺序调用绘制函数(draw call). 每次 Draw call 调用之间引擎需要初始化 material 和 mesh (也即 set pass call, 如果和前一次调用一样则无需初始化). 在内部 Unity 可能尝试合并 mesh 来减少 draw call (dynamic batching 和 static batching), 如果是 Dynamic 对象这步操作会增加一些 CPU 开销, 如果是 static 则会在build 时预先合并."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说, 我们使用 Unity 构建的游戏保存在 YAML格式的 Scene文件中. 尽管游戏并非在 YAML 基础上运行, 在加载 Scene 并解析了方块 .prefab 文件后, 引起会准备一些 C++ 的内存用来存储 Transform, 相应代码则基于此来绘制."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在同一帧中这是同一块操作. 并取决于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"数据"}]},{"type":"text","value":"本身, 每个方块的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":"和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":" 告知了我们绘制什么. 不幸的是, 绘制都关注于什么样draw call 顺序能得到的正确的结果, 而所有这些绘制都来自于对于数据某些形式的迭代. (在C++中如果数据排布不佳依然不一定能高效迭代). 大家知道 ECS 擅长数据迭代. 而 Burst 加 ECS 则能帮助数据容易多线程处理, 这是我们为什么要用 ECS 来开发游戏的原因."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一块操作则是逻辑. 在绘制之前, 比如方块可能有个 Bouncing 组件在持续地改变它的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":" (好让你的游戏变得更有趣). 在改变用于绘制的数据这方面, ECS 依然能帮到你."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏基本上就这些了, 你有一些数据, 然后可能根据玩家的输入等因素来改变, 最后在每一帧中绘制出来."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结合改变数据和对数据的绘制, 玩家应该开始能感受到乐趣了! 事实上这一过程也常常使人放松(比如看着一个球在屏幕上下移动). 从纯数据的角度来审视游戏非常重要, 否则你无法接受基于 DOTS 来开发游戏的方式."}]},{"type":"element","tag":"h2","props":{"id":"如何在-dots-的世界里做游戏"},"children":[{"type":"text","value":"如何在 DOTS 的世界里做游戏"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameOjbect"}]},{"type":"text","value":"不同, 数据在ECS里类似数据库, 设想一下, 因为我们可以使用Jobs或者 SIMD指令来更快地迭代数据, 所以不仅改变数据的逻辑非常高效而且绘制本身也是高效的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来我们直接跳到最后. 我现在已经在使用ECS并且我有3个 transform 矩阵需要绘制(以"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IcomponentData"}]},{"type":"text","value":"形式, 所以迭代是线性且快速的) , 外加对应的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mesh"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Material"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 Unity 的 Graphics Api 我们可以直接绘制这些数据而无需 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 这个数据容器! 参考 "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/Graphics.html","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Scripting API: Graphics"}]},{"type":"text","value":" 以及支持 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeArray"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":"("},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html"}]},{"type":"text","value":"). 这时你已经可以直接从数据来绘制了. 只需要用 ECS 的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityQuery"}]},{"type":"text","value":"等方法来获取数据并绘制它们."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考这篇日文博客("},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//virtualcast.jp/blog/2019/10/batchrenderergroup/","rel":["nofollow"]},"children":[{"type":"text","value":"https://virtualcast.jp/blog/2019/10/batchrenderergroup/"}]},{"type":"text","value":"), 描述了 BatchRendererGroup 的优势. 尽管 \"batches\" 数量巨大, 性能依然优异. 要注意 batching 实际上是合并 mesh 的操作, 因此有一定的计算量. 绘制就是重复地调用没有改变的数据,只要你将 NativeArray 的内存留在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 里面, 1000+的 \"batches\" 一点也不可怕.(较低的\"set pass call\"展示了在帧间绘制时并没有太多了 material 切换)"}]},{"type":"element","tag":"h2","props":{"id":"hybrid-renderer"},"children":[{"type":"text","value":"Hybrid Renderer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 开发了 Hybrid Renderer ("},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.rendering.hybrid%40latest","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Packages/com.unity.rendering.hybrid@latest"}]},{"type":"text","value":") 来完成上文提到的绘制工作. 如果你有一个关联 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToworld"}]},{"type":"text","value":" 组件(也即Transform矩阵)的 Entity , 且Entity 所在 Chunk 关联了是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ISharedComponentData"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMesh"}]},{"type":"text","value":" 组件 ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mesh"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Material"}]},{"type":"text","value":" 不在 ECS 框架下), 那么它就会使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 来绘制数据."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"整个 Chunk 基于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 的数量来绘制的是同样数量的 mesh 和 material. 这已经类似于CPU版本的 GPU instancing 了, 只使用 draw call 是非常快的, 这种粗暴的绘制方式甚至可能比花费 CPU 来每帧合并 mesh 的方式还要快. 由于同一 chunk 使用同样的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mesh"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Material"}]},{"type":"text","value":" , 并非100%无需 set pass call. 如果你的 Material 开启了 GPU instancing, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 可以批量绘制可不是快速的重绘."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之所以这种方式称之为 Hybrid 是因为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 是普通的 Unity API 而不是 ECS API. 但是这并不意味着这不是 Data-Oriented. 事实上 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 工作的方式非常地 Data-Oriented: 就是由 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MaterialPropertyBlock"}]},{"type":"text","value":" 和 Transform 矩阵构成的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeArray"}]},{"type":"text","value":" 数据. 所以别害怕使用它(Hybrid Renderer) 除非你知道如何使用 Graphics API 或者使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":"构建你自己的渲染模式. (或许可以去掉非必须的步骤比如 culling)."}]},{"type":"element","tag":"h2","props":{"id":"让我们用纯数据来做个游戏吧"},"children":[{"type":"text","value":"让我们用纯数据来做个游戏吧"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然已经接受了游戏就是改变数据和展示数据, 使用 Hybrid Renderer 我们就可以来做游戏了. 我们假设这就是关于一个上下弹跳的方块的游戏, 按住空格的时候让它跳的更疯狂, 这可能对于小孩子来讲非常有趣."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先要解决的问题, 如何获取到我们需要的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mesh"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Material"}]},{"type":"text","value":". 我想我会使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rensources.Load"}]},{"type":"text","value":"来加载一个引用了相关 asset 的 prefab:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using UnityEngine;\n\npublic class AssetHolder : MonoBehaviour\n{\n    public Mesh myMesh;\n    public Material myMaterial;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\n\npublic class AssetHolder : MonoBehaviour\n{\n    public Mesh myMesh;\n    public Material myMaterial;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-2fd0d4674c7f066e2e1059dd48558882_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的 System 用来创建Hybrid Renderer 要使用的数据."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Rendering;\nusing Unity.Transforms;\nusing UnityEngine;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class CubeGameSystem : JobComponentSystem\n{\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        var myCube = EntityManager.CreateEntity(\n            ComponentType.ReadOnly<LocalToWorld>(),\n            ComponentType.ReadOnly<RenderMesh>()\n        );\n        EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n        var ah = Resources.Load<GameObject>(\"AssetHolder\").GetComponent<AssetHolder>();\n        EntityManager.SetSharedComponentData(myCube, new RenderMesh\n        {\n            mesh = ah.myMesh,\n            material = ah.myMaterial\n        });\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        return default;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Rendering;\nusing Unity.Transforms;\nusing UnityEngine;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class CubeGameSystem : JobComponentSystem\n{\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        var myCube = EntityManager.CreateEntity(\n            ComponentType.ReadOnly<LocalToWorld>(),\n            ComponentType.ReadOnly<RenderMesh>()\n        );\n        EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n        var ah = Resources.Load<GameObject>(\"AssetHolder\").GetComponent<AssetHolder>();\n        EntityManager.SetSharedComponentData(myCube, new RenderMesh\n        {\n            mesh = ah.myMesh,\n            material = ah.myMaterial\n        });\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        return default;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"瞧, 我的 data-oriented 方块坐标位于 (1, 2, 3)!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-e531723f584b5747646fc3340dc937ef_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到 Hierarchy 窗口里什么都没有, 但是方块却出现了. 编辑器窗口里也无法选中它, 它仅仅是被绘制了而已. 事实上编辑器里之所以可以选中是因为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 容器连接了绘制的内容和其他编辑的内容."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果现在检查 Entity Debugger, 你会注意到 Hybrid Renderer 又添加了一些别的东西. 它会在提交数据到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 之前剔除掉无法被看到的东西."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-218f24f57c5b783f8d52064804a8e977_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上意味着: \"你拥有 1 个chunk, 该 chunk 能容纳 128 个 Entity ( 1 个 Entity占用 125 字节, 1 个 chunk 16kb), 你已经使用了该 chunk 其中 1 个位置, 你还能添加 127 个方块. Hybrid Renderer 把方块 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 数据喂给 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 时, 这些数据在内存中都是连续排列的."}]},{"type":"element","tag":"h2","props":{"id":"transform-systems"},"children":[{"type":"text","value":"Transform systems"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你有一个数据并且绘制了, 接下来我们加点玩法."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-1eb72ea2222c31c50554021afecb27d1_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rotation"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Scale"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NonUniformScale"}]},{"type":"text","value":"组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 组件指向了父 Entity, 那么最终该 Entity 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 值将会和父 Entity的 LocalToWorld 一样."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来我们添加 Translation 给方块. 玩法系统现在就可以通过修改 Translation 而不是 LocalToWorld了. 我同时添加了 Cube 组件作为 Tag, 这样子代码会更加清晰:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"var myCube = EntityManager.CreateEntity(\n    ComponentType.ReadOnly<Translation>(),\n    ComponentType.ReadOnly<Cube>(), //Tag\n    ComponentType.ReadOnly<LocalToWorld>(),\n    ComponentType.ReadOnly<RenderMesh>()\n);\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var myCube = EntityManager.CreateEntity(\n    ComponentType.ReadOnly<Translation>(),\n    ComponentType.ReadOnly<Cube>(), //Tag\n    ComponentType.ReadOnly<LocalToWorld>(),\n    ComponentType.ReadOnly<RenderMesh>()\n);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来实现弹跳. 我们使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Time .ElapsedTime"}]},{"type":"text","value":" 作为余弦函数的输入, 会返回一个从 0 到 1来回的值."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意, ECS 妙的一点在于你可以不断地添加新系统来实现代码的\"横向地\"以构建更多玩法. 模式则是从 ECS 快速的数据库里查询数据, 然后修改, 再存回去. 你可能对这种每次都查询-修改都要增加新 System 的模式觉得有些不安, 但这种模式提升了代码的扩展性. 而 Unity ECS 则确保了重复的数据查询是高效的, 因此在代码中有大量逻辑简单的 System 是完全可行的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们的弹跳系统先在主线程检查空格是否按下, 并声明相关变量, 最后在 Lambda jobs 中捕获这些变量, 并根据此并行修改查询到的 Cube 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":" 值, 其中每一个线程会运行时会使用 1 个 chunk 的 Cube 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":" 数据. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Time"}]},{"type":"text","value":" 是由 ECS 库维护的一个属性, 它每帧都会从传统的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UnityEngine.Time"}]},{"type":"text","value":" 获取相应的数据"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\n[UpdateBefore(typeof(TransformSystemGroup))]\npublic class CubeBouncingSystem : JobComponentSystem\n{\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        int multiplier = Input.GetKey(KeyCode.Space) ? 100 : 20;\n        var elapsedTime = Time.ElapsedTime;\n        \n        JobHandle jh = Entities.WithAll<Cube>().ForEach((ref Translation t) =>\n        {\n            float3 value = t.Value;\n            value.y = math.cos((float) elapsedTime * multiplier);\n            t.Value = value;\n        }).Schedule(inputDeps);\n        return jh;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\n[UpdateBefore(typeof(TransformSystemGroup))]\npublic class CubeBouncingSystem : JobComponentSystem\n{\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        int multiplier = Input.GetKey(KeyCode.Space) ? 100 : 20;\n        var elapsedTime = Time.ElapsedTime;\n        \n        JobHandle jh = Entities.WithAll<Cube>().ForEach((ref Translation t) =>\n        {\n            float3 value = t.Value;\n            value.y = math.cos((float) elapsedTime * multiplier);\n            t.Value = value;\n        }).Schedule(inputDeps);\n        return jh;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f23943863e0ab8ec8907f242579a0884_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Worker 线程现在已经在工作了. 当你用这种方式构建游戏, 最终几乎每个 Worker 线程都会来回使用以避免闲置:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f116b2bea7e7ca411112bc9e82265c54_720w.jpg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"可是这样构建游戏实在是太痛苦了"},"children":[{"type":"text","value":"可是这样构建游戏实在是太痛苦了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你应该已经注意到, 正儿八经的游戏要改成 data-oriented 并不容易. (除了上文的弹跳球这样的简单场景). 甚至现在你都没法使用所见即所得的编辑器了. 整个游戏如果按照这种方式获取 LTW + Mesh + Material 将会是噩梦般的开发旅程. 虽然整个游戏按照这样的方式构建非常恐怖, 但性能确实是会非常好. 有点倒退回 Cocos2D 时代的感觉. 自然你是想要在编辑器中快速地迭代玩法/美术相关内容."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但记住这个方块绘制效率极高, 如果你添加更多的方块, 它们都会打包喂给"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BatchRendererGroup"}]},{"type":"text","value":" 因为在同一个 chunk 内存里 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 已经被连续排列好了. 而复制一个方块也不再是复制"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":"这样昂贵的操作, 只需要添加更多 Entity 以及相应的组件."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样的, 一个 Entity 将数据转存回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 也不是什么好主意 ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectEntity"}]},{"type":"text","value":" 就做了这样的事儿), 我们想要运行时的 pure ECS , 而不是桥接回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":" 的 ECS."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"简言之, 你想要 ECS 的高性能, 但不想要按这样的方式来开发游戏."}]},{"type":"element","tag":"h2","props":{"id":"conversion-workflow"},"children":[{"type":"text","value":"Conversion workflow"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以 Unity 团队采用了常规的 GameObject 来仅实现"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"编辑操作(authoring),"}]},{"type":"text","value":" 而在运行时, 则将这些 GameObject **转换(convert)**为纯粹的 ECS data."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我之所以之前介绍 renderer 和 transform, 是因为转换过程实际上是将编辑时方便的 GameObject 对象转换为高性能 transform 和 renderring 系统支持的 entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Component object"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在进阶之前, 我假设你已经知道了 component objects. 这不仅是可以添加到 Entity 上的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 组件, 你甚至可以使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":" 类型."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只不过你无法在 jobs 使用这些类型, 很多有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 约束的泛型 API 也无法被使用. 但是这种类型的组件确实是关联到 Entity 上的, 也有相关的 API 可以使用. 以下是一些支持 component objects API 例子:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":":"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddComponentObject"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetComponentObject"}]},{"type":"text","value":". 如果添加不存在的组件, 你在获取时会得到一个 null."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentType"}]},{"type":"text","value":": 你可以创建 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<T>"}]},{"type":"text","value":" (如"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":")类型的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentType"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"system.GetEntityQuery"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"em.CreateArchetype"}]},{"type":"text","value":": 因此你可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"类型的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentType"}]},{"type":"text","value":" 来创建组件的查询."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityQuery"}]},{"type":"text","value":":"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ToComponentArray"}]},{"type":"text","value":"会返回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"T[]"}]},{"type":"text","value":". 这会返回以托管数组方式存储托管组件的结果, 而不是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ToComponentDataArray"}]},{"type":"text","value":"那样返回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NativeArray<T>"}]}]}]},{"type":"element","tag":"h2","props":{"id":"conversion-world-destination-world-primary-entity"},"children":[{"type":"text","value":"Conversion world, destination world, primary entity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在内部, 转换过程是创建特定目的的 World, 并在其中运行特定的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"conversion systems"}]},{"type":"text","value":" (这样你会得到一个新的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":", 以及存储entities 的数据库). 这被称为 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"conversion world"}]},{"type":"text","value":". conversion world 同时也知晓用于存储转换结果的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"destination world."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为conversion world is一个 ECS World, 我们可以从 Entity 出发来而不是仅仅是 Hierarchy 中的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":". 由于前文所提到的 component object 的存在, 从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Gamebject"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"importing"}]},{"type":"text","value":" 的过程也非常容易, 所以你也可以得到一堆完整复刻 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Gameobject"}]},{"type":"text","value":"原有层级关系和组件的 Entity (使用 class 类型组件). 也就是说, 让每个 entity 也拥有 Unity 传统的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":" 或者 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LineRenderer"}]},{"type":"text","value":" 组件."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些拥有component object 的 entity 并不优秀, 我们更希望得到更优的基于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":" 的组件."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"单次调用"}]},{"type":"text","value":" conversion world 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"update"}]},{"type":"text","value":" 方法, 其中的特定 system 也会 update 单次, 这会导入 component object entity 并将结果存入 destination world. 至少, 这会为每一个conversion world 中找到的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":" 组件创建一个空的 Entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-bff28dd360d229c6ba16b991033abf0d_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图中, destination world 的 Entity A 被成为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject A "}]},{"type":"text","value":"的 \"primary entity\". 之所以没有被称为 \"resulting entity\", 是因为这转换过程并非是一对一的过程. 比如 A 可能在 destination world 中构建出 A1 和 A2 两个 entity, 这种情况, 其中一个将成为 primary entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一个"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在 conversion world 工作时"}]},{"type":"text","value":"的特点是你可以通过原始的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 获取 primary entity(当然也可以传入任一 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":" 来获取, 内部将会调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".gameObject"}]},{"type":"text","value":"来替代). 比如上图 A 的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":" 也可以用于获取 primary entity, 这在更复杂的转换过程中可能有用."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后, 包含那些并不高效的 Entity 的 conversion world 将会被 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"destroy"}]},{"type":"text","value":" 掉."}]},{"type":"element","tag":"h2","props":{"id":"gameobjectconversionsystem"},"children":[{"type":"text","value":"GameObjectConversionSystem"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"被标记了如下 attribute 的 system 将在 conversion world 中被调用:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"[WorldSystemFilter(WorldSystemFilterFlags.GameObjectConversion)]\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[WorldSystemFilter(WorldSystemFilterFlags.GameObjectConversion)]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个 attribute 是可继承的, 因此更推荐的方法是直接继承ECS库里已提供的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionSystem"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拿 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":" system 为例. 它会在 conversion world 里面寻找 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":" 组件, 依此来构建 destination world 中 entity 的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translate"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rotation"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NonUniformScale"}]},{"type":"text","value":"组件, 它甚至知道在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":"的 scale 为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(1,1,1)"}]},{"type":"text","value":"时不添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NonUniformScale"}]},{"type":"text","value":"!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-48b3c53e12f6c638b561e55ad6b095cb_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一个值得看的例子是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRendererConversion"}]},{"type":"text","value":". 这是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRenderer"}]},{"type":"text","value":"转换为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMesh"}]},{"type":"text","value":" 加 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Mesh"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Material"}]},{"type":"text","value":" 的地方"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-acf0da5e1a80bd23ba69b1bf80870973_720w.jpg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"conversion-的顺序"},"children":[{"type":"text","value":"Conversion 的顺序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"conversion systems 都是被扫描以及归集到一起的, 因此顺序并没有被清晰地定义. 假设你想要转换过程中 \"get primary entity\" 并获取到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 组件, 执行顺序就变得很重要了, 因为你要确保你的 conversion system 在 Unity 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":"之后执行."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UpdateInGroup"}]},{"type":"text","value":"依然排得上用场. 在 conversion world, 有如下一些 groups:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class GameObjectDeclareReferencedObjectsGroup : ComponentSystemGroup { }\n\npublic class GameObjectBeforeConversionGroup : ComponentSystemGroup { }\npublic class GameObjectConversionGroup : ComponentSystemGroup { }\npublic class GameObjectAfterConversionGroup : ComponentSystemGroup { }\n\npublic class GameObjectExportGroup : ComponentSystemGroup { }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class GameObjectDeclareReferencedObjectsGroup : ComponentSystemGroup { }\n\npublic class GameObjectBeforeConversionGroup : ComponentSystemGroup { }\npublic class GameObjectConversionGroup : ComponentSystemGroup { }\npublic class GameObjectAfterConversionGroup : ComponentSystemGroup { }\n\npublic class GameObjectExportGroup : ComponentSystemGroup { }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如非特别指定, 你的 system 将运行在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionGroup"}]},{"type":"text","value":"中. 因此如果你想要在Unity内置的 conversion system 之后做事情, 你得确保你的 system 运行在其后. 要注意的是你不能使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[UpdateAfter(typeof(TransformConversion))]"}]},{"type":"text","value":"因为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":"不是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"public"}]},{"type":"text","value":"的. 从前文截图你可以看到它运行在 before group 中, 因此你的默认运行在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionGroup"}]},{"type":"text","value":" 中的 system 是可以获取到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":"等组件的. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRendererConversion"}]},{"type":"text","value":" 则运行在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionGroup"}]},{"type":"text","value":" 中, 因此如果你想要获取到 RenderMesh, 则需要将你的 system 放在其后."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"declare 和 export Group 很特殊, 因为它们运行在特定的过程的前后, 而中间三个 Group则是一紧挨着运行, 因此, 你如果要放在这两个 Group 内运行, 一定得明白它们前后都做了些什么事儿(后文会讲)."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"???\nGameObjectDeclareReferencedObjectsGroup.Update()\n???\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n???\nGameObjectExportGroup.Update()\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"???\nGameObjectDeclareReferencedObjectsGroup.Update()\n???\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n???\nGameObjectExportGroup.Update()\n"}]}]},{"type":"element","tag":"h2","props":{"id":"gameobjectconversionmappingsystem"},"children":[{"type":"text","value":"GameObjectConversionMappingSystem"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"conversion world 还有一个非常特别的系统附加在所有可用的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionSystem"}]},{"type":"text","value":" 里, 就是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionMappingSystem"}]},{"type":"text","value":". (下文称之为 mapping system). 该系统是所有 conversion world 的 boss, 奇迹发生之地."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先这是一个纯粹的 \"tooling system\", 意思是它只有一个空的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnUpdate"}]},{"type":"text","value":" 函数, 完全是用来被其他系统获取, 并在它们的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnUpdate"}]},{"type":"text","value":"中使用的工具.(这种设计也适用于你自己的游戏.)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里你可以执行"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetPrimaryEntity"}]},{"type":"text","value":" 来与 destination world 沟通, 或者创建更多的 entity. 当你想执行 conversion, 你需要显式地指定 destination world. 这个 world 用来当作 mapping system 的 constructor."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在你的 conversion system 里面, 你可以 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetOrCreateSystem"}]},{"type":"text","value":" 来获取 mapping system, 但如果你继承了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionSystem"}]},{"type":"text","value":", 则可以直接通过相应的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"protected"}]},{"type":"text","value":" 方法获取到."}]},{"type":"element","tag":"h2","props":{"id":"让我们使用-converttoentity-来convert吧"},"children":[{"type":"text","value":"让我们使用 ConvertToEntity 来convert吧"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在已经有足够的知识来执行转换过程了. 目前我们仅仅使用 Unity 内置的 conversion system. 也即"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRendererConversion"}]},{"type":"text","value":" , 因此确保你的输入拥有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRenderer"}]},{"type":"text","value":" 来得到结果."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要在scene里面选择 game objects导入 conversion world, 我们可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"组件. 在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Awake"}]},{"type":"text","value":" 里面, 它会基于一些标准来选择导入什么. 所以若如下图附加到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":"上, 那么在 conversion world里, 我会得到这些ECS的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"component objects:"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Hello"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-a96ebb838511e15934a42fd1b2000b1c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当进入 play mode 时, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Awake"}]},{"type":"text","value":" 被调用的瞬间后你得到:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-dcece28b71a8313f75f0e4fd6ca7667c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-87122268425b7052676a0b7cce6c8cc8_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当前状态当然还没准备好绘制, 因为还没有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMesh"}]},{"type":"text","value":", 但是你可以看到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":"发现了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":"component object 然后就在conversion world 被销毁之前, 在 Primary entity 上构建了 LTW/TR ."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我修改一下 scale:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-84dbdfe15794ce27a4b4957f7480abcb_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"转换的结果:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-6d131a5073402ee6700baf5c1c9a7829_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-bf7ebc16e636d69937377796cc12a334_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":" conversion system 的代码发现了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":"有非 1 的 scale, 于是决定加上额外的组件到 primary entity 上."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来看看"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRendererConversion"}]},{"type":"text","value":"在我们添加了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRenderer"}]},{"type":"text","value":" 后做些什么:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-2cc3d708a668ecd3a34776ae9860b433_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-adeb3de47a701bf36a971fa9baeaae97_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我得到了一个正确转换且拥有纯粹ECS数据后的方块! 另外 conversion world 也可以分配 entity name, 因为 conversion world 知晓 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":" 的存在, 所以可以在 conversion world 被销毁前通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".gameObject.name"}]},{"type":"text","value":" 来追踪其名字."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-992e31a0522e8183fcbee75cf061ec4b_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"组件里\"and destroy\" 选项并非 conversion world 流程里的内容, 由该MonoBehaviour 组件自行完成. 因为它并不觉得你想要复制出同样的结果, 如果我不销毁掉原对象, 那么我就会得到两个方块, 一个来自"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRenderer"}]},{"type":"text","value":" , 另一个来自Hybrid Renderer 渲染的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMesh"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" ."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你不想要默认的行为, 你可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionUtility.ConvertGameObjectHierarchy"}]},{"type":"text","value":"手工转换. 后文会细讲."}]},{"type":"element","tag":"h2","props":{"id":"hierarchy-conversion"},"children":[{"type":"text","value":"Hierarchy conversion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":" 实际上提交了所有子 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 给 conversion world, 除非你在子对象中使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity (Stop)"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-3ecf0a5ef86786b295197e8b9af42d3e_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图的结构中, conversion world 最后会得到: A B E F G H. 每一个元素的 component objects 都会和最初的类似. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":"component object 是关键点, 因为它有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".parent"}]},{"type":"text","value":"属性, 这样 conversion world 才能基于此构建出整个层级树."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"给 D 添加 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"是不会有效果的(在C处转换就停止了), 因此会抛出警告. 而添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"给 B 则没有警告, 但也不会有额外的作用, 因为 A 处隐含了 B也将被纳入层级的事实."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECS 里有一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"组件, 该组件仅有一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entity"}]},{"type":"text","value":"字段用来表示 transform 的层级关系."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":"的计算总是基于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"组件. 如果 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":"是 0, 那么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 矩阵的结果并不是在行1 2 3 和 列4为0, 而是直接复制"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"所指示Entity的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 的值."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而负责计算"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"的正是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TransformConversion"}]},{"type":"text","value":", 让我们看看结果:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-cf1b98c0bfc171a75faaeb1708bb6807_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先猜猜A B E F G H 会占用多少 chunk? (不管转换过程中有多少魔法, 我们永远得关注数据本身!) 先假设我们这些对象的 scale 都为1 (这样就不会产出"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NonUniformScale"}]},{"type":"text","value":"组件)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-b03840ef2f4026f8171dd5a0981ab1f5_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为何有 3 个chunk?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能会猜测所有 chunk 都会有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 而对于根部的 A, 其"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"则可以是一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entity.Null"}]},{"type":"text","value":" , 但是 Unity 并没有选择这样做, 因为在复杂一些的游戏里, 查询时使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ComponentType.Exclude"}]},{"type":"text","value":" 会相对更加高效一点. (你可以想象成如果没有parent组件, transform systems 可以忽略掉一些矩阵运算.)"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"没有 Parent, 但有 child : A"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Parent 和 Child 都有: F"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"叶子节点, 仅有 Child: B E H G"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以看到还有一些 component 被添加了: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToParent"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Child"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PreviousParent"}]},{"type":"text","value":".目前还无需关心它们, 总之它们会最终参与"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":"的计算."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意到 conversion 过程中有多少个不同的 Archetype 产生有时候很有用. 比如当你有个巨大的 game objects 层级树, 且其中有些对象仅仅是用来组织结构的空对象, 有些则真正拥有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":"and"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRenderer"}]},{"type":"text","value":", 这样你最终可能会至少得到 6 个 chunk. (3个前述chunk, 以及3个包含"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMesh"}]},{"type":"text","value":" 的chunk). 因为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RenderMesh"}]},{"type":"text","value":"是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ISharedComponentData"}]},{"type":"text","value":", 如果你有更多的 mesh 和 materials, 那么 chunk 的数量还会继续增加. 总之, 这类的思想也出现在dynamic/static batching, GPU instancing, 或 SRP batchers 之中, 而不是 ECS 独有. 使用Entity Debugger 可以清楚地看到 chunks 是如何被组织的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"and destroy\" 的行为在 stop 时也会有一些变化, 被 stop 的对象之下的层级会被单独摘出来并保留(因为 Unity 猜测既然那里你没有相应的 entity, 那么就为你保留 gameobject)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-ad321f404c9cc350778236f78db75bab_720w.jpg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"disabled-与-gameobject-conversion"},"children":[{"type":"text","value":"Disabled 与 GameObject conversion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"被 disabled 了的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":"会被加上一个 ECS 中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"component, 如下所示, Convert and destroying 顶部的 Cube, 你会得到 5 个 Entity, 其中 3 个关联 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"component:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-aa8d98f0c436030e2833da7985bb4f51_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然你依然可以在层级任何位置添加 Convert To Entity (Stop), 其行为不会发生变化. 比如我在 Cube(1) 和 Cube(4) 上添加 stop, 那么我最终将得到 3 个 Entity: Cube(2) , 有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"的Cube(3), 没有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"Cube ."}]},{"type":"element","tag":"h2","props":{"id":"convert-and-inject-模式"},"children":[{"type":"text","value":"Convert and inject 模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你想保留原始的 game object"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同时想在 conversion world 销毁之前导出 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"component objects"}]},{"type":"text","value":" 给 primary entity. (当然也包含转换过程中新增的 components)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如前文中提到的, 我有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Hello"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LineRenderer"}]},{"type":"text","value":"会被带进 conversion world , 但由于并没有conversion system会处理"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Hello"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LineRenderer"}]},{"type":"text","value":", 因此会在 conversion world 被销毁时也同时被销毁."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-310140196c94a5d298a09d2551b3382f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但在\"Convert and inject\"模式下, 这两者就可以被保留:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-3a5a13b66d3362a1fbf6e30aa20a6223_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-b635d5f273e58223e298b87a1edebc82_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样, 我像之前一样正常得到了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" , 但同时我也得到了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Transform"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Hello"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LineRenderer"}]},{"type":"text","value":", 这意味着你得到了一个可以追溯回原始 GameObject 的 Entity. 如果我们在别处 destroy 这个 GameObject, 那么 ECS 侧的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"em.GetComponentObject<Transform/LineRenderer>"}]},{"type":"text","value":" 也相应回返回 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"null"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你应该明白了, 销毁或者不销毁原始 Gameobject 两种模式都有各自的意义 (前者是为了避免重复, 后者为了访问 component objects)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这意味着如果我有一个关联"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshRenderer"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MeshFilter"}]},{"type":"text","value":"的方块同时又选择了inject模式, 我会得到渲染在同一位置的两个方块. 如下图, 一个方块是 2 * 6 * 2 = 24个 tris(额外 2个 tris是蓝色的背景所占用的), 如果使用 convert and destroy, 我依然会得到 26 个 tris并被Hybrid Renderer所用, 在但 inject 模式下, 会变为 50 个 tris, 因为转换前后的对象都被保留了:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-689301524050755bbcf6ed29b45330f0_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-3b37442f567073f3500c401bdadc285a_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面这个例子并不是 inject 模式的预期用法, 该模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯."}]},{"type":"element","tag":"h2","props":{"id":"使用-ecs-的system-来管理传统的-monobehaviour"},"children":[{"type":"text","value":"使用 ECS 的System 来管理传统的 MonoBehaviour"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"inject 模式最酷的在于, 从现在开始, 你就可以制作 hybrid ECS 游戏了. 你可以把 inject 模式视作将对象转化为 ECS system 可访问的对象, 甚至在你没有 conversion system 的时候. 仅仅是保留 component objects 以及是非常有用了. 你完全可以用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"进行组件的开发, 然后用 system 来控制它们."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 上就如同"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IComponentData"}]},{"type":"text","value":"一般添加 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":", \"tag 用途的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"\" 也是完全可行的. 不过过去常见的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"继承模式在ECS的世界里, 你可能需要考虑用组合模式来替代了, 一如 ECS 里常用的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":" 并不能继承."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然并没有性能上的提升, 但是依托 ECS 的查询能力可以获得 system 设计上极佳的灵活性."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或许你过去常常使用一种\"manager优化\"手段, 就是你去掉移除对象的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Update"}]},{"type":"text","value":" 方法, 然后让一个 Manager 来追踪该对象的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"List"}]},{"type":"text","value":"来统一地 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"update"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而用于操作 component object (monobehaviour) 的 system 正是和上述优化一模一样的玩意儿! 而且 ECS 在查询上更加灵活. 你可以不断添加查询不同种类 component object 的 system. 这样对于在团队中分割工作量更容易. 也可以通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UpdateBefore/After"}]},{"type":"text","value":" 调整执行顺序, 而不是过去地狱般的 script execution order."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举一个 UGUI 按钮的例子. 我想要用 system 来添加一段逻辑: 改变"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"interactable"}]},{"type":"text","value":"时按钮会在正常和禁用状态之间闪烁."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-691223f5e1d1debbb595f47a4b38c2ed_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有按钮都使用 convert and inject, 其中一个缺少"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BlinkingButton"}]},{"type":"text","value":"\"tag\""},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":". 目前还没有任何实际代码, 不过我想要用这些类型来进行查询."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"来看看 conversion 后的结果, 我们得到 2个 chunk, 其中一个有3个 entity (橙色的竖条往右边移动了一点, 意味着其包含 3/160 个 entity), 另一个则有一个 entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f6a2d6ad3e349d49a3b6ef3d34b2aa44_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的 system 则能自动到 ECS 的数据库里面查询 scene 里面所有带有 blinking 组件的按钮. 这种\"凭空\"查询"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":"的能力让声明"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject[]"}]},{"type":"text","value":"成为了过去时. 即便你对 ECS 毫无兴趣, 这种查询能力也让其成为非常便捷的 Unity 开发工具."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing Unity.Jobs;\nusing UnityEngine.UI;\n\n[UpdateInGroup(typeof(PresentationSystemGroup))]\npublic class BlinkingButtonSystem : JobComponentSystem\n{\n    EntityQuery blinkingButtonQuery;\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        blinkingButtonQuery = GetEntityQuery(\n            ComponentType.ReadOnly<Button>(),\n            ComponentType.ReadOnly<BlinkingButton>()\n        );\n    }\n\n    //It is not a good idea to have data in system!\n    float collectTime;\n    bool on;\n    \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        collectTime += Time.DeltaTime;\n        if (collectTime > 0.2f)\n        {\n            collectTime -= 0.2f;\n            on = !on;\n        }\n\n        Button[] buttons = blinkingButtonQuery.ToComponentArray<Button>();\n        foreach (var b in buttons)\n        {\n            b.interactable = on;\n        }\n        return default;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.Jobs;\nusing UnityEngine.UI;\n\n[UpdateInGroup(typeof(PresentationSystemGroup))]\npublic class BlinkingButtonSystem : JobComponentSystem\n{\n    EntityQuery blinkingButtonQuery;\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        blinkingButtonQuery = GetEntityQuery(\n            ComponentType.ReadOnly<Button>(),\n            ComponentType.ReadOnly<BlinkingButton>()\n        );\n    }\n\n    //It is not a good idea to have data in system!\n    float collectTime;\n    bool on;\n    \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        collectTime += Time.DeltaTime;\n        if (collectTime > 0.2f)\n        {\n            collectTime -= 0.2f;\n            on = !on;\n        }\n\n        Button[] buttons = blinkingButtonQuery.ToComponentArray<Button>();\n        foreach (var b in buttons)\n        {\n            b.interactable = on;\n        }\n        return default;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-5ed751beea434345f9972273619f2ed2_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entities.ForEach"}]},{"type":"text","value":"也可以使用 component objects, 只不过这时候不能使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ref"}]},{"type":"text","value":"或"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"in"}]},{"type":"text","value":"关键字, 同时为了防止使用 Burst, 你需要用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Run"}]},{"type":"text","value":"来替代"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Schedule"}]},{"type":"text","value":"."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"Entities.WithAll<BlinkingButton>()\n  .ForEach((Button b) => { b.interactable = on; }).WithoutBurst().Run(); \n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Entities.WithAll<BlinkingButton>()\n  .ForEach((Button b) => { b.interactable = on; }).WithoutBurst().Run(); \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样完全或者部分移植到 ECS 的游戏, 也可以自由使用 system 了, 只需要 inject 模式, 你便拥有了基于 Entity 的查询能力."}]},{"type":"element","tag":"h2","props":{"id":"inject-模式的-conversion-规则"},"children":[{"type":"text","value":"Inject 模式的 conversion 规则"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上文例子中将所有的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Button"}]},{"type":"text","value":"转换到 ECS 了, 那"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Button"}]},{"type":"text","value":" 里的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Text"}]},{"type":"text","value":"怎么办呢?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和会将所有子层级提交到 conversion world 的 destroy 模式"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不同"}]},{"type":"text","value":", 这时所有的子层级将被忽略(即便你为它们添加了inject模式的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"组件). 仅有顶层对象会正常convert and inject. 所以 ECS 不会为创建关联"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Text"}]},{"type":"text","value":"component object的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entity"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了更清晰地说明这条规则, 我试着 convert 更上层的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Canvas"}]},{"type":"text","value":":"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-44014cd244f3d5aa39e4c0cf8d534e47_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-5b8285a1bdd4c30a3aa57bf7c8cd3f7f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这下我的 Button 并没出现在 ECS 的世界里, 而只得到了 Canvas, 如果我把模式切回 destroy, 则得到一堆 pure 的 entity 而不带任何 component objects:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-e573126980ccfb5cf19b281e234acbb4_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到, 所有在conversion world 中的 component objects 最终都被销毁了."}]},{"type":"element","tag":"h2","props":{"id":"iconvertgameobjecttoentity"},"children":[{"type":"text","value":"IConvertGameObjectToEntity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现 conversion system(通过继承"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionSystem"}]},{"type":"text","value":")可以让你自由控制conversion 的过程. 但如果你想按照具体类型来转换呢? 每当转换执行时, 应当相应地执行一些代码."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 内置了另一种名为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertGameObjectToEntitySystem"}]},{"type":"text","value":" 的 conversion system. 该 system 会迭代 conversion world 中所有的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":", 接着使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetComponents"}]},{"type":"text","value":" 并判断是否实现"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IConvertGameObjectToEntity"}]},{"type":"text","value":" 接口, 然后再调用该接口的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".Convert"}]},{"type":"text","value":" 方法. 你可以把任何逻辑都放在这里:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing UnityEngine;\n\npublic class BlinkingButton : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing UnityEngine;\n\npublic class BlinkingButton : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"entity"}]},{"type":"text","value":"参数是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":"产生的 primary entity. 回忆一下前文提到\"primary entity\"与"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 以及相应"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":" 关联. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"dstManager"}]},{"type":"text","value":"参数则是 destination world 里的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"EntityManager"}]},{"type":"text","value":". 在这里你可以做任何相关联的事儿, 比如为每个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BlinkingButton"}]},{"type":"text","value":"添加 500 个屁用没有的 Entity?当然可以!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以利用这里的机会来使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"dstManager.Add / SetComponentData"}]},{"type":"text","value":"来初始化更多数据. 要注意这里有一丝\"遥控\" destination world 的味道(因为实际上你工作在 conversion world 层面). 所以重视这个参数名字, 因为确实有另一个属于 conversion world 的 manager."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单独创建 conversion system 并使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entities.ForEach"}]},{"type":"text","value":"来初始化数据也许会更高效一些(因为你在这里使用 Burst 和 jobs). 但是 Convert 方法运行你获取到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MonoBehaviour"}]},{"type":"text","value":"中序列化的字段, 这样更加随心的修改每个 entity 关联的数据."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"conversionSystem"}]},{"type":"text","value":"参数则是调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Convert"}]},{"type":"text","value":"方法的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertGameObjectToEntitySystem"}]},{"type":"text","value":"本体, 但是强制被转换成了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionSystem"}]},{"type":"text","value":" 类型(小心名称有点易混). 其目的是让你可以使用 mapping system 中的方法."}]},{"type":"element","tag":"h2","props":{"id":"linkedentitygroup"},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"是一个 dynamic buffer , 通常它会影响:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":". 注意实例化并不一定和ECS中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Prefab"}]},{"type":"text","value":" component 直接关联."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":"时也会同时销毁 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"中的所有 entity. 类似在编辑器中删除"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"entityManager.SetEnabled"}]},{"type":"text","value":" 加上的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"component 会告知 ECS 的查询系统忽略它们, 而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":" 中的 entity 也会受到同样的影响. 有点类似禁用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 时同时会禁用整个层级树."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意如果buffer 中的 entity 也有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":", 系统"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不会递归地"}]},{"type":"text","value":"执行instantiation/destroy/disabled 过程."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些过程在具体执行当中也有一些细微不同."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":"只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"必须要把自己包括在内"}]},{"type":"text","value":"才能正常工作**.** 然而"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":"则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要注意"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的."}]},{"type":"element","tag":"h2","props":{"id":"从非-prefab-conversion-中获取linkedentitygroup"},"children":[{"type":"text","value":"从非 prefab conversion 中获取LinkedEntityGroup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前, 我们使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"并不能得到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":". 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"却可以正常得到基于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 的层级结构)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":" public void DeclareLinkedEntityGroup(GameObject gameObject)\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public void DeclareLinkedEntityGroup(GameObject gameObject)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果)."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-fe2983f48e754c910758292e0a0dfc91_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从 debbuger 现在可以看到已经正常添加了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":", 目前它已经支持"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnable"}]},{"type":"text","value":" 的正常工作了:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 也在其他一些地方执行这一过程, 比如在转换 prefab "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"asset"}]},{"type":"text","value":" 的时候.(后文会讲)"}]},{"type":"element","tag":"h2","props":{"id":"尺寸警告"},"children":[{"type":"text","value":"尺寸警告!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能觉得每个 chunk 16KB 非常多了, 你最多可以放进去 2000个 entity. 一旦你开始转换层级结构, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"和它那些朋友们(比如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Child"}]},{"type":"text","value":" )会很快耗光这些预算, 每一个 buffer 里的元素都是一个 8 bytes 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entity"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下图中 12 个 chunks 中, 每个只能容纳 45 个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Entity"}]},{"type":"text","value":" , 哪怕只是非常简单的层级结构和非常少量的 component, 远达不到我们的千个级别."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-398058d78c2ab70ef17a48f705fe5195_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 entities-0.5.1版本里, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TypeManager.cs"}]},{"type":"text","value":" 源码中可看到, 任何没有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[InternalBufferCapacity]"}]},{"type":"text","value":" 的buffer 类型都会默认 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"128/size"}]},{"type":"text","value":" 的容量. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"里面装的是 entity, 因此其容量是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"128/8 = 16"}]},{"type":"text","value":" ."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-fe0be3a9fca17f9a89108d85d8ba961c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这意味着:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"每个 Entity"}]},{"type":"text","value":" 关联的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"除非显式调用, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 数量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"正常工作."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后, 16kb 一个 chunk 意味着 1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析)."}]},{"type":"element","tag":"h2","props":{"id":"创建额外的-entity"},"children":[{"type":"text","value":"创建额外的 entity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个常见的情况是一个 GameObject 对应一个 Entity, 也即 \"primary entity\". 在 mapping system 里面, 调用 CreateAdditionalEntity(gameObject)来创建更多的Entity .这些 entity 现在属于这个 game object 的 \"secondary entity\"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设想我们的新设计是每当CubeMultiple 转换时将会创建额外的两个 entity:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class CubeMultiple : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $\"{this.name}_Add1\");\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $\"{this.name}_Add2\");\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class CubeMultiple : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $\"{this.name}_Add1\");\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $\"{this.name}_Add2\");\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意Convert调用是递归的, ConvertToEntity 附加在顶部的 CubeHead 上."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-9cbab2ea04976cef1e61cc2b365e71af_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要注意额外的entity都是新增的, 且没有为它们添加 components, 这不像那些被默认转换的component objects (如 Transform), 注意下方拥有 2008 容量的 chunk:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f1a5fb905599fc0439e0a6764dd09072_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能意识的到使用 destination entity manager 的 dstManager.CreateEntity() 来做同样的事情, 下文你会看到这不只是处理方式的问题."}]},{"type":"element","tag":"h2","props":{"id":"从单一源得到-entity"},"children":[{"type":"text","value":"从单一源得到 entity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要这样做, 需要在 mapping system 里, 调用GetEntities(gameObject/component). 因为我们增加了额外的 entity, 让 conversion world 知道这些 entity 来自特定的东西, 这样让我们可以查询到它们. 比如, 如果我有一个GameObject CubeMultiple 的引用, 那么使用GetEntities 我就能得到 primary entity 和另外两个新增的 entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你无需担心它们是否已经被创建了或者担心Convert 顺序, 因为这类调用会例行调用Convert . (这一点同样适用于GetPrimaryEntity )"}]},{"type":"element","tag":"h2","props":{"id":"如何影响-linked-entity-group"},"children":[{"type":"text","value":"如何影响 linked entity group"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回忆一下DeclareLinkedEntityGroup. 通过正确增加额外的 entity, conversion system 知道它们如何关联至 GameObject. 这些结果也会添加进 linked entity group."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前面 CubeHead 的例子在自己身上调用DeclareLinkedEntityGroup , 结果是已经把额外增加的 entity 包含进来了:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-549d3983b0e3532643b81a2a3cecf79a_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而只是单纯地通过dstManager 来创建 entity 则不会有这样的效果. 这样看起来转换CubeMultiple 更像是带着一些添加更多 Entity 到 destination world 的\"副作用\", 而不是它变成了多个 entity. 而这种模式也能配合 live link 的工作. (后文会解释)"}]},{"type":"element","tag":"h2","props":{"id":"声明-asset"},"children":[{"type":"text","value":"声明 Asset"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或许你也想通过 asset 而不仅仅是 scene 来生成 entity, 好消息是 primary entity 可以关联到 asset 上, 不只是GameObject (或MonoBehaviour), 如果你调用GetPrimaryEntity 时传入 asset, 最后会在 mapping system 里面注册, 并得到正确的 entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为你无法将ConvertToEntity放置到 asset 文件上, 你需要在 conversion 后某种\"声明\"它们是 entity的方法."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"什么时候声明?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"答案是在 conversion 真实发生之前. 这被称之为 discovering 过程. 如果你在这个conversion过程之中试图添加, 声明的 API 就会报错. 在声明之后, 在 conversion 过程中, 你就可以使用 GetPrimaryEntity来传入 asset 的 primary entity了. 如果你不这样做, 那么查询它们将会有点困难."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"IDeclareReferencedPrefabs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 discovering 阶段, 首先, 实现了IDeclareReferencedPrefabs组件接口的GameObject会被扫描, 在这里你可以通过添加 prefab asset (目前只支持 prefab 文件) 到相应的 list 中来进行声明. 你可以在inspector里通过序列化的 GameObject 字段来引用它们."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在conversion systems里面声明"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在扫描了接口之后, 回忆一下我们前面提到的GameObjectExportGroup. 所有运行在第一个 GameObjectDeclareReferencedObjectsGroup 中的 conversion system 会被 update. 在这里, 你有另一个声明 asset 的机会, 这里支持 prefab 和"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"其他任意类型的 assets."}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class GameObjectDeclareReferencedObjectsGroup : ComponentSystemGroup { }\n\npublic class GameObjectBeforeConversionGroup : ComponentSystemGroup { }\npublic class GameObjectConversionGroup : ComponentSystemGroup { }\npublic class GameObjectAfterConversionGroup : ComponentSystemGroup { }\n\npublic class GameObjectExportGroup : ComponentSystemGroup { }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class GameObjectDeclareReferencedObjectsGroup : ComponentSystemGroup { }\n\npublic class GameObjectBeforeConversionGroup : ComponentSystemGroup { }\npublic class GameObjectConversionGroup : ComponentSystemGroup { }\npublic class GameObjectAfterConversionGroup : ComponentSystemGroup { }\n\npublic class GameObjectExportGroup : ComponentSystemGroup { }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 conversion system 意味着你手边可以使用 mapping system. 其中有几个方法可以用来声明 asset. 接下来你将如何在 system 代码中获取到这些 asset 引用呢? 你可以在conversion world 中查询任意可能链接了 asset 的 component object (比如通过在可以在 inspector 中添加的字段). 当然可能某个时间点你会意识到不如最开始就使用IDeclareReferencedPrefabs , 因为反正你都得实现某种\"占位\"机制. 所以, 如非必要, 尽可能使用 IDeclareReferencedPrefabs 吧."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来到了正常 conversion 的时候, 这时候你可以结合 IConvertGameObjectToEntity 来获取已经被转换好的 asset/prefab 的 Entity, 传入之前一样的引用即可:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class BlinkingButton : MonoBehaviour, IDeclareReferencedPrefabs, IConvertGameObjectToEntity\n{\n    public GameObject myPrefab;\n    \n    //This first\n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(myPrefab);\n    }\n    \n    // |\n    // V\n    \n    //Then GameObjectDeclareReferencedObjectsGroup <- last chance to declare stuff\n    \n    //Then GameObjectBeforeConversionGroup\n    //Then GameObjectConversionGroup, which contains ConvertGameObjectToEntitySystem that run the following Convert\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        //Get primary entity of the prefab asset, to assign to primary entity converted from this component.\n        Entity prefabAssetEntity = conversionSystem.GetPrimaryEntity(myPrefab);\n        //Remember it, etc.\n    }\n    \n    // |\n    // V\n    \n    //Then GameObjectAfterConversionGroup\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class BlinkingButton : MonoBehaviour, IDeclareReferencedPrefabs, IConvertGameObjectToEntity\n{\n    public GameObject myPrefab;\n    \n    //This first\n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(myPrefab);\n    }\n    \n    // |\n    // V\n    \n    //Then GameObjectDeclareReferencedObjectsGroup <- last chance to declare stuff\n    \n    //Then GameObjectBeforeConversionGroup\n    //Then GameObjectConversionGroup, which contains ConvertGameObjectToEntitySystem that run the following Convert\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        //Get primary entity of the prefab asset, to assign to primary entity converted from this component.\n        Entity prefabAssetEntity = conversionSystem.GetPrimaryEntity(myPrefab);\n        //Remember it, etc.\n    }\n    \n    // |\n    // V\n    \n    //Then GameObjectAfterConversionGroup\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要注意 IConvertToGameObjectToEntity 的 Convert 被调用时你依然有机会使用 mapping system. (添加额外 entity, 遍历其他 primary entity 等等) 但如果你这时候使用 mapping system 来声明更多东西就太晚了会报错."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下就是完整的过程:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n// ???\nGameObjectExportGroup.Update()\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n// ???\nGameObjectExportGroup.Update()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顺便一提声明截至仅仅针对 asset/prefab, 你依然可以在conversion 过程中调用DeclareLinkedEntityGroup."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"声明任意 asset"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 mapping system 里 使用DeclareReferencedAsset , "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在 conversion world 里"}]},{"type":"text","value":", 你会得到一个关联 Asset conponent , 外加一个你声明的 asset 类型的 component object 的 Entity (注意并非 destination world)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如我可以通过DeclareReferencedAsset(mySpriteAtlas).来创建一个Entity+Asset+SpriteAtlas , 这时候 destination world 的 primary entity 依然是空的, 目前还不明白这个系统设计的目的, 也许是为了让你自己处理Asset的转换过程."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"声明 prefab asset"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"添加进IDeclareReferencedPrefabs 里的 list 就行. 对于 GameObjectDeclareReferencedObjectsGroup 里的 system 来讲, 则是使用 mapping system 的DeclareReferencedPrefab 方法."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过这一次和AssetandGameObject component object 不一样, 你会在 destination world 中得到一个真正的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"prefab engity"}]},{"type":"text","value":" (而不是前面说到的空结果)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来简单解释下什么是 Entityprefab. 如果你添加一个 Prefab 组件到任何 Entity, 除非你显式指定, 那么它将在默认 query 中隐身, 和Disabled组件的行为很相似. 使用 Instantiate方法则会将实例化出的 entity 将该prefab组件删掉. (毕竟你不太可能想要实例化另一个 prefab 出来...)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过该行为的目的又有所不同, 之所以在 query 中隐藏它们是并非主观上想要让它们处于 \"inactive\" 状态, 而是它们本就该是 \"inactive\". 它们只不过是用来快速创建新数据的蓝图. 因此, 在创建 query 时有两个不同的参数模式: \"include disabled\" 和 \"include prefabs\". 使用时注意语义上的区别 (如不要使用 Prefab 来隐藏 Entity)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结合前面提到的LinkedEntityGroup , 现在ECS的实例化已经和传统 Unity 的实例化感觉一样了!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过声明 prefab asset, 你便同时添加了Prefab和LinkedEntityGroup 到目标primary entity上."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要注意ConvertToEntity只是转换对象为普通的 Entity, 因为 scene 里的层级结构并不是 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"asset."}]},{"type":"text","value":" 无论它们是不是蓝色的(即在scene里被实例化的 prefab), 我们都无法得到Prefab或LinkedEntityGroup."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Prefab 本身则属于 asset 文件, 你无法在 Project panel 中粘贴ConvertToEntity运行. ECS 库通过查看它是不是位于 scene 中来决定它是不是一个 prefab, 显然可以粘贴ConvertToEntity 则意味着对象在 scene 中."}]},{"type":"element","tag":"h2","props":{"id":"prefab-asset-conversion-过程"},"children":[{"type":"text","value":"Prefab asset conversion 过程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的声明过程实际上会调用 convert 过程. 接下来我说说和转换 scene 中GameObject在细节上有哪些不同. 只要在 scene 层级中, 是否从 prefab 实例化就无关紧要, 只有在从 Project panel 处声明的 asset 被实例化时才会有区别:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"为实例化准备的自动 LinkedEntityGroup"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下所示的 prefab asset 设置:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-de0722a0a9b1b64f962e00c0655f6641_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-968dbba1c2b6b1579f9cd5d7b1083d42_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要意识到 CubeHead 是一个 asset, 而不是 scene 对象."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"[GenerateAuthoringComponent]\npublic struct PrefabConversion : IComponentData\n{\n    public Entity prefab;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[GenerateAuthoringComponent]\npublic struct PrefabConversion : IComponentData\n{\n    public Entity prefab;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们会得到:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-eca8ecacce32b7cb618f690308873ba7_720w.jpg"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果我们 convert 位于 scene 中的 CubeHead, 我们无法获取到LinkedEntityGroup. 该行为仅仅针对 prefab asset, 其目的显然是为了实例化. (链锁销毁行为也一样)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"LinkedEntityGroup 包含层级树下的所有对象以及自己, 包括 cube 3 和 cube 4. Conversion过程让 prefab \"线性化\"了, 实例化过程就无需递归调用了, 是需要遍历 LinkedEntityGroup即可."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前文提到过, 之所以LinkedEntityGroup包含它自己是因为 SetEnable 可以一次性完成工作, 而不是一个接一个的调用."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有转换后的 entity 都会添加 Prefab组件, 但是我们只需要使用最顶层的那个 Entity 用于实例化. 事实上, 实例化过程没有Prefab 什么事儿, 主要是用LinkedEntityGroup 来完成工作. 实际上你可以实例化任何 entity."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"为禁用功能准备的自动LinkedEntityGroup"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前文解释过 prefab 的顶层对象会得到LinkedEntityGroup 是因为需要实例化."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"额外地, 如果在 prefab 的任何位置发现了被禁用的GameObject,该位置的对象也会得到包含所有子级对象的LinkedEntityGroup ."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"该行为的目的是为了你可以在已经被实例化的 Entity 上使用SetEnable 时能高效地添加 Disabled组件. 当然Disabled的 conversion 过程依然遵循相同的规则: 当 convert 一个非 asset 的GameObject , 会自动添加LinkedEntityGroup."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Can't stop won't stop"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你不能在 prefab 中使用 Convert To Entity (Stop), 没用."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"来点小测验吧."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"依照目前这些 conversion 的规则, 来检查一下你是否能推算出上面例子正确的结果吧: Parent(还记得这是为 transform systems准备的么),Prefab,Disabled,LinkedEntityGroup(以及里面的 entity).Child和相关组件会根据Parent组件在一轮 transform systems 的update 之后被添加."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-081c8f1dcb6bece2eeb25a3e11620da6_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"Cube : Prefab, LinkedEntityGroup (Cube,1,2,3,4)\n1    : Prefab, Parent (Cube)\n2    : Prefab, Parent (Cube)\n3    : Prefab, Parent (2)\n4    : Prefab, Parent (2)\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Cube : Prefab, LinkedEntityGroup (Cube,1,2,3,4)\n1    : Prefab, Parent (Cube)\n2    : Prefab, Parent (Cube)\n3    : Prefab, Parent (2)\n4    : Prefab, Parent (2)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f0ecb3bdbdef8bdba3b8ec63f994015c_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"Cube : Prefab, Prefab, LinkedEntityGroup (Cube,1,2,3,4)\n1    : Prefab, Parent (Cube)\n2    : Prefab, Parent (Cube), Disabled, LinkedEntityGroup (2,3,4)\n3    : Prefab, Parent (2), Disabled\n4    : Prefab, Parent (2), Disabled\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Cube : Prefab, Prefab, LinkedEntityGroup (Cube,1,2,3,4)\n1    : Prefab, Parent (Cube)\n2    : Prefab, Parent (Cube), Disabled, LinkedEntityGroup (2,3,4)\n3    : Prefab, Parent (2), Disabled\n4    : Prefab, Parent (2), Disabled\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要记住LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.(也许你觉得这无所谓, 但实际上这会让 chunks 的碎片变多)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-8abf5ccdb436f84aa87e0982f3eba30b_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube)\n3    : Parent (2)\n4    : Parent (2)\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube)\n3    : Parent (2)\n4    : Parent (2)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-43536999ecd92ac2b1f1788ba43257c8_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube)\n3    : Parent (2)\n4    : Parent (2)\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube)\n3    : Parent (2)\n4    : Parent (2)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是否蓝色名字(说明它连接这 prefab asset)无所谓, 它不是 asset, 不会遵循LinkedEntityGroup的conversion 规则."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-9b32027c1ea133d6cc35ff6861ff544a_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube), Disabled\n3    : Parent (2), Disabled\n4    : Parent (2), Disabled\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Cube : \n1    : Parent (Cube)\n2    : Parent (Cube), Disabled\n3    : Parent (2), Disabled\n4    : Parent (2), Disabled\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意, 这时候你无法通过Cube (2) 连锁地禁用 Cube (3) 和 (4), 因为没有自动生成LinkedEntityGroup, 但你可以人工声明它."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"prefab 实例化时的 Remapping 过程"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当在拥有LinkedEntityGroup的entity上调用Instantiate时, 会发生 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"entity remap"}]},{"type":"text","value":" 过程. (这里阅读更多内容: "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//gametorrahod.com/entity-remapping/","rel":["nofollow"]},"children":[{"type":"text","value":"https://gametorrahod.com/entity-remapping/"}]},{"type":"text","value":") 目前你只需要知道 convert 一个 prefab "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"asset"}]},{"type":"text","value":" 让LinkedEntityGroup 能工作, 就行了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"(译注: entity id 在一个 world 当中是不可重复也不可被外部修改的, 当序列化存储 entity 时, 反序列化过程会因版本问题丢失掉 entity id 引用, 这一问题同样影响实例化过程, 而 entity remap 过程就为了解决这一问题而出现的)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以, \"烘焙\" Entity 值到 prefab entity 的 conversion 结果中是可行的, 当实例化时, 这些烘焙好的值又会\"活了过来\"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在前例的情况中, 如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-de0722a0a9b1b64f962e00c0655f6641_720w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<LinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer<LinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<LinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer<LinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-50abef20adb51226bd0af6bddba9e8bb_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"![img](data/svg+xml;utf8,)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当你调用Instantiate时, 一旦它发现可以被 Remap 的情况(如LinkedEntityGroup) Remapping 就会发生. 因此在 conversion 把它变成 Prefab 之前, \"连接\" Entity 引用是非常有用的, 这样一旦你Instantiate 它, 里面包含的 Entity 关系就已经可用了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"没有LinkedEntityGroup则 Remapping不会发生, 因为在那种情况下就没有同级对象需要 remapping Entity 的值了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GameObjectExportGroup 是什么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前面 4 个我们都介绍了它们的作用, 来看看最后这一个. 前面介绍的过程你也许会发现不仅仅可以将 conversion 结果用作运行时, 也可以用来"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"导出"}]},{"type":"text","value":". 通常 export group 是不包含在conversion 流程中的, 仅当我们显式要求时才导出."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你的 conversion system 运行在这里, 那么所有的 conversion 都已经完成, LinkedEntityGroup Prefab都已经准备就绪, 当然你不能在这时候继续 convert 了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前究竟什么是\"导出(export)\"依然是个谜, 或许得等 Unity 团队写点我能看懂的文档. 目前你可以认为这个 Group 在你日常的 conversion 中用不太上. 而且猜想它一定和 Assetentity有某些关系."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n// ??? <- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update()\nGameObjectAfterConversionGroup.Update()\n// ??? <- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"mapping system 上的 DeclareDependency 是啥"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们还漏掉了一个\"声明\". 但是我不清楚这是什么, 它看起来像是 live link 会用到的东西. (后文会解释 live link)."}]},{"type":"element","tag":"h2","props":{"id":"声明和使用-prefab-asset-的示例"},"children":[{"type":"text","value":"声明和使用 prefab asset 的示例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-88397d41a933c41fecc23cfdf0ca8e74_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我 convert and destroy 上面这些 cubes 的 MeshFilter和MeshRenderer, 我会得到两个 chunk:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-7b1b82fa14a9c96763edcd0cc98fe34c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-84ff4d8fe1120763c200837ec2c6e6fb_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我将把它变成 prefab asset, 并从 scene 中删掉, 接着我会把该 prefab 转换为隐藏的 Prefab entity 以用于后面的 Instantiate."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是我的计划: 做一个 SpawnHere 用于存储实例化位置 (\"tag\" 性质的MonoBehaviour)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-b92b5408db5a1d0c1b57c3bc876c1b63_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不用担心上图中有3个GameObject声明了同一个 prefab, conversion system 知道如何处理重复情况, 下面是代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n    \n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n    \n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 discovery 阶段 asset 的 primary entity 已经被创建了且包含了Prefab和LinkedEntityGroup, 能够正常用于实例化. (由于 Prefab 的存在, 虽然拥有 RenderMesh和LocalToWorld组件, 但 Cube entity 是对于查询隐藏的, 因此也没有在画面中显示)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-61b91e13ae93422ebf600817a3d04dd2_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-32ab362213045eb4e7f2b0e5668928d0_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"conversion 之后, 我就可以获取Prefab在 SpawnHere 所在的位置进行实例化了, 因为LocalToWorld或Translation很多 entity 都包含, 被销毁的SpawnHere 是无法被区分的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-fcc91ab4bc4773a9cea287ca4ef89419_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此我们添加 SpawnHereEcs 当作 Tag 来使用:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\npublic struct SpawnHereEcs : IComponentData\n{\n}\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n    \n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<SpawnHereEcs>(entity);\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\npublic struct SpawnHereEcs : IComponentData\n{\n}\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n    \n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<SpawnHereEcs>(entity);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外, 我们可以直接在 SpawnHereEcs 里面加上 prefab entity 的引用, 而获取该 entity 的方式就是前文提到的声明过程:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System.Collections.Generic;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Transforms;\nusing UnityEngine;\n\npublic struct SpawnHereEcs : IComponentData\n{\n    public Entity thatPrefabEntity;\n}\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n\n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);\n        dstManager.AddComponentData<SpawnHereEcs>(entity, new SpawnHereEcs {thatPrefabEntity = prefabEntity});\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections.Generic;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Transforms;\nusing UnityEngine;\n\npublic struct SpawnHereEcs : IComponentData\n{\n    public Entity thatPrefabEntity;\n}\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n\n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);\n        dstManager.AddComponentData<SpawnHereEcs>(entity, new SpawnHereEcs {thatPrefabEntity = prefabEntity});\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后我们的 system 将查询SpawnHereEcsentity 并在这些位置执行实例化, 之后再销毁SpawnHereEcs以避免重复实例化."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":" [UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class SpawnSystem : JobComponentSystem\n{\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities.ForEach(\n                (Entity e, in Translation t, in SpawnHereEcs she) =>\n                {\n                    Entity instantiated = EntityManager.Instantiate(she.thatPrefabEntity);\n                    //Set to the same translation.\n                    EntityManager.SetComponentData(instantiated, t);\n                    EntityManager.RemoveComponent<SpawnHereEcs>(e);\n                })\n            .WithStructuralChanges().Run();\n        return default;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" [UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class SpawnSystem : JobComponentSystem\n{\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities.ForEach(\n                (Entity e, in Translation t, in SpawnHereEcs she) =>\n                {\n                    Entity instantiated = EntityManager.Instantiate(she.thatPrefabEntity);\n                    //Set to the same translation.\n                    EntityManager.SetComponentData(instantiated, t);\n                    EntityManager.RemoveComponent<SpawnHereEcs>(e);\n                })\n            .WithStructuralChanges().Run();\n        return default;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以按照 chunk 来批量RemoveComponent , 使用WithStoreEntityQueryInField 来导出 lambda 定义的 EntityQuery, 然后在 ForEach 之后使用 EntityManager.RemoveComponent 传入该EntityQuery."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是我们的结果:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-a9888335c0aec5a24d809d2d49fd372c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-d2fe910f9e5023e20a942675396ee977_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和Prefab 一样我们实例化的结果也拥有LinkedEntityGroup, 你还可以注意到 debugger 现在支持 select 按钮来选中 entity."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么有没有可能在 conversion 阶段就能预先实例化呢? 这样我们就无需 SpawnHereEcstag 了, 因为我们知道TransformConversion完成的确切时间, 所以我们已经可以利用其 primary entity 来获取位置. 然后利用 dstManager来完成实例化. 看起来就像是SpawnHere MonoBehaviour"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"直接转化"}]},{"type":"text","value":"成了 prefab 实例, 而不是在运行时分开来完成这一切."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以思考一下为什么这种方法无法正确工作然后再继续往下看"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System.Collections.Generic;\nusing Unity.Entities;\nusing Unity.Transforms;\nusing UnityEngine;\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n\n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);\n        \n        var spawnPosition = dstManager.GetComponentData<Translation>(entity);\n\n        Entity instantiated = dstManager.Instantiate(prefabEntity);\n        dstManager.SetComponentData<Translation>(instantiated, spawnPosition);\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections.Generic;\nusing Unity.Entities;\nusing Unity.Transforms;\nusing UnityEngine;\n\npublic class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n{\n    public GameObject forDeclare;\n\n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(forDeclare);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);\n        \n        var spawnPosition = dstManager.GetComponentData<Translation>(entity);\n\n        Entity instantiated = dstManager.Instantiate(prefabEntity);\n        dstManager.SetComponentData<Translation>(instantiated, spawnPosition);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-aa979cae836c032b9353451a6c1b3f31_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"几乎"}]},{"type":"text","value":"能够工作, 但是结果是只有三个cubes. 从图中可以知道, GetPrimaryEntity显然是能够正常工作的, 因为已经度过了 discovery 阶段. GetComponentData 也能正常工作, 因为Transform会在 GameObjectBeforeConversionGroup 阶段转换完成."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是回忆一下LinkedEntityGroup和Prefab 所涉及的声明过程:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() <-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? <- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() <-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? <- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LinkedEntityGroup和Prefab 并未就绪! 缺乏LinkedEntityGroup导致我们最终的结果里仅仅实例化了最顶层的那个 cube. 因此在conversion过程中你无法这样使用刚刚声明的 Prefab. 如果你不清楚 conversion 流程, 很难知道为什么会有这样的结果."}]},{"type":"element","tag":"h2","props":{"id":"generateauthoringcomponent"},"children":[{"type":"text","value":"[GenerateAuthoringComponent]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SpawnHere->SpawnHereEcs 这种模式要求你有一个 MonoBehaviourcomponent 在 inspector 中暴露一些字段, 然后在 conversion 后转换为等价的数据. 我们把这个MonoBehaviour称为 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"authoring component."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们当然可以创建GameObjectConversionSystem来完成相同的工作. 但是使用IConvertGameObjectToEntity无疑是更精简的方式."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing UnityEngine;\n\n//The real ECS\npublic struct MyData : IComponentData\n{\n    public float data1;\n    public int data2;\n    public bool data3;\n}\n\n//For authoring\npublic class MyDataOnScene : MonoBehaviour, IConvertGameObjectToEntity\n{\n    // Ugly duplicated code\n    public float data1;\n    public int data2;\n    public bool data3;\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentData<MyData>(entity, new MyData\n        {\n            // Tedious work\n            data1 = data1,\n            data2 = data2,\n            data3 = data3,\n        });\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing UnityEngine;\n\n//The real ECS\npublic struct MyData : IComponentData\n{\n    public float data1;\n    public int data2;\n    public bool data3;\n}\n\n//For authoring\npublic class MyDataOnScene : MonoBehaviour, IConvertGameObjectToEntity\n{\n    // Ugly duplicated code\n    public float data1;\n    public int data2;\n    public bool data3;\n    \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentData<MyData>(entity, new MyData\n        {\n            // Tedious work\n            data1 = data1,\n            data2 = data2,\n            data3 = data3,\n        });\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-35431ad3689e54c311b7c1256e5cbe7f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-4a05be4b1b63bd7fc675c8a697d36565_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更棒的是, ECS 还有 IL 黑魔法来帮助你完成这个过程:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public float data1;\n    public int data2;\n    public bool data3;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public float data1;\n    public int data2;\n    public bool data3;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-29e1525831cf721dcee0618eff79b2ec_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意我们这里并没有定义 MonoBehaviour, 我们自动获取到了名为\"My Data Authoring\" 的组件, 甚至 \"My Data\" 也可以作为相同结果来添加. 这部分生成代码会和我们手写有类似 Convert 过程, 由于你无法查看生成的代码是什么, 这基本相当于魔法."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前要施放该魔法, ECS 字段必须定义为 public, 下面这样的代码并无法按你所设想的那样工作:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing UnityEngine;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    [SerializeField] internal float data1;\n    [SerializeField] public int data2;\n    [SerializeField] public bool data3;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing UnityEngine;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    [SerializeField] internal float data1;\n    [SerializeField] public int data2;\n    [SerializeField] public bool data3;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-babbcac3eb118386ffd7120ee87295d2_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有一个小技巧是可以生成 \"声明 prefab asset\" 模式功能的代码 (前面SpawnHereEcs的例子), "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"仅需定义一个 Entity字段即可."}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public Entity magic;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public Entity magic;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-e3e22ca2eab52093ca323900d9d4ddd7_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上和以下代码是完全等同的"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\n//[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public Entity magic;\n}\n\npublic class MyDataAuthoring : MonoBehaviour, IDeclareReferencedPrefabs, IConvertGameObjectToEntity\n{\n    public GameObject magic;\n    \n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(magic);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity primaryEntityOfDeclaredPrefab = conversionSystem.GetPrimaryEntity(magic);\n        dstManager.AddComponentData<MyData>(entity, new MyData\n        {\n            magic = primaryEntityOfDeclaredPrefab\n        });\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections.Generic;\nusing Unity.Entities;\nusing UnityEngine;\n\n//[GenerateAuthoringComponent]\npublic struct MyData : IComponentData\n{\n    public Entity magic;\n}\n\npublic class MyDataAuthoring : MonoBehaviour, IDeclareReferencedPrefabs, IConvertGameObjectToEntity\n{\n    public GameObject magic;\n    \n    public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n    {\n        referencedPrefabs.Add(magic);\n    }\n\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        Entity primaryEntityOfDeclaredPrefab = conversionSystem.GetPrimaryEntity(magic);\n        dstManager.AddComponentData<MyData>(entity, new MyData\n        {\n            magic = primaryEntityOfDeclaredPrefab\n        });\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然, 你可以正常混搭Entity或float字段在一起."}]},{"type":"element","tag":"h2","props":{"id":"混用converttoentity的-destroy-和-inject-模式"},"children":[{"type":"text","value":"混用ConvertToEntity的 destroy 和 inject 模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"inject 模式会产生太多的 component objectes, 而且也不能访问整个层级树. 同样的, destroy 模式也不能清晰完整地转换整个层级到 ECS 中去. 你可能会想要介于二者之间部分地\"inject\". \"stop\" 组件并没有满足需求 (因为你并不是要跳过转换)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子, 如果我用Transform,MeshFilter, 和MeshRenderer建造一个飞船, ConvertToEntity 在 destroy 模式下会被转换成LocalToWorld+RenderMesh"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-64c6e9c8dcf9a4cbd9b6565c3308d9cf_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-c65c039ba549ed6676f01af4d00dd49c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之前我们的 bouncing system 对 Cube和 Translation有效, 如果添加Cube到飞船的根对象上, 应该也能工作. 当然我们可以继续使用魔法生成代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":" using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct Cube : IComponentData\n{\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct Cube : IComponentData\n{\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-ead555ad6345028ebcfebc0546bbb150_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们在排气孔位置增加一个粒子效果对象, 我想要的结果粒子随着飞船能上下弹跳:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-cc2adc78e27b72b13f67732d1cbab225_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"destroy 模式下, 当 ParticleSystem 这个 component object 进入 conversion world 后, 最终是会被销毁的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我添加 ConvertToEntity (Stop) 给它, 那么该对象会变成完全和 ECS 无关的东西."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么如果在 destroy 模式里面的子对象上添加 inject 模式呢? 这样做我确实会得到一个包含 ParticleSystem的 Entity . 但它是否和 destroy模式转换的飞船能关联起来呢?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-3c54d97e347fd5a0a340eba132b883bb_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结果并不如我们所期望那样:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-291facdfb1aa6949c491128d172ea9ef_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但从 Entity Debugger 中我们可以看到, 这个对象确实是有destroy 模式下转换后的Parent和LocalToParent , 同时也有inject 模式下添加的ParticleSystem这个 component object. 你现在已经实现混用两种模式了!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-5e0a38c25b41d2feb69bbfcff52db36c_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就我们目前所知, Parent会帮助我们计算最终的 LocalToWorld , 但是粒子没有上下弹跳是因为没有什么其他系统在使用它的LocalToWorld, 所以我们可以将它的值复制回原Transform 组件, 这可以通过copy transform to game object proxy 组件来实现, 这个组件同时也需要你添加 GameObjectEntity :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-a9447ea8f2906a1127dd652ceb9a313f_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意如果飞船以 prefab asset 形式被实例化, 那么结果将会像仅使用了 destroy 模式, 也即这里的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"particle system 会缺失"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h2","props":{"id":"companion-game-object"},"children":[{"type":"text","value":"Companion Game Object"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前文所述的方案听起来像是 hack. Particle System 依然存在于 Hierachy 中, 像是它被\"胶粘\"在被转换后的 Entity 上进行移动."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Companion game object 是一种更加\"干净\"的混合转换方式, 它会创建一个新的 game object 来**\"伴随\"(companion)"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"被转换的数据, 并用它来选择你想保留的组件. 这让它"}]},{"type":"text","value":"看起来像**是被完美 conversion 了."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们使用 mapping system 来实现该模式. 如下代码所示, 我没有增加太多非 ECS 内容, 只不过修改了一下转换相关的代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing UnityEngine;\n\npublic class Ship : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public ParticleSystem particleCompanion;\n    public ParticleSystemRenderer rendererCompanion;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.AddHybridComponent(particleCompanion);\n        conversionSystem.AddHybridComponent(rendererCompanion);\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing UnityEngine;\n\npublic class Ship : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public ParticleSystem particleCompanion;\n    public ParticleSystemRenderer rendererCompanion;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.AddHybridComponent(particleCompanion);\n        conversionSystem.AddHybridComponent(rendererCompanion);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然这模式的名称叫 companion game object, 但你需要配置的其实是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"components."}]},{"type":"text","value":" AddHybridComponent 调用不仅指定了哪个GameObject应该\"伴随\", 同时也指定哪些组件会被保留.(primary entity 是按照组件来识别的). 因此我定义了组件的 public 字段而不是 GameObject字段."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在下面这个 ParticleSystem 的例子里, 还隐含着一个 ParticleSystemRenderer, 如果缺失了 renderer, 那么最终的 companion game object 里就只有ParticleSystem 从而导致不会渲染结果. (但是 CPU 依然会运行粒子模拟)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-7fdcefe0ddf7884e12d264419ca52a92_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到, 之前那些 Hack 的内容现在全都不在了! (去掉了ConvertToEntity inject 模式, 去掉了 copy proxy, 去掉了 GameObjectEntity), 现在conversion 完全正常工作!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-9654b7da425abca92137e2cd44ff6e70_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到现在 Hierarchy 窗口里没有 Particle System 了, 但在 Game view 窗口却正常显示着, 所以它是哪里来的?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先来看看它对应的 primary entity 的 conversion 结果:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-2bc082bdb4447fc2ed9e59a18799f81f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用AddHybridComponent方法让 companion 相关的组件自动添加到了GameObject的 primary entity (也即 Particle System entity) 上, 同时也加上了指定的ParticleSystem和ParticleSystemRenderer."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实这些 component object 仍然关联到 scene 中的对象, 只不过这些对象使用了HideFlags.HideInHierarchy 来隐藏自己. 而CompanionLink组件则指向了这个隐藏对象, 接下来 CompanionGameObjectUpdateTransformSystem 则负责将 transform 复制到 game object 当中."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和我们上面的 hack 几乎是一致的过程, 但是更加简洁和官方, 和 conversion system 的衔接也更加无缝."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"同时也兼容 prefab !"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Companion 的另一个好处是, 它完全支持 Prefab 转换流程, 并能"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"正常地实例化."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这意味着每次实例化时, 从 MeshFilter和MeshRenderer 中得到RenderMesh会被高效地处理, 而遇到 CompanionLink指定的 component object 则创建有HideFlag的 game object. 并关联好相应的 Entity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上, 这感觉就和 EntityManager.Instantiate 一样, 完美地实现了 ECS 版本的ParticleSystem."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体来说, 我们将飞船先变成一个 prefab asset. 然后在 Ship 组件正常引用子对象里的组件即可."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-393b0c8128a558d1a8cf9825bb89a609_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我继续使用前面说到的魔法:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct ShipAndCo : IComponentData\n{\n    public Entity shipPrefab;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\n\n[GenerateAuthoringComponent]\npublic struct ShipAndCo : IComponentData\n{\n    public Entity shipPrefab;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-c25ff43a9da4a6adce9ec3ae6f5d6d89_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"进入 play mode 时, 我已经在 ShipAndCo上拥有一个 就绪的Prefabentity了, 由于我知道ShipAndCo是一个 singleton, 我们用如下系统来玩一玩: 每次我按下 A 键, 在0~10之间的随机位置上实例化该 Entity."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Transforms;\nusing UnityEngine;\nusing Random = Unity.Mathematics.Random;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class ShipAndCoSpawnerSystem : JobComponentSystem\n{\n    Random randomizer;\n\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        RequireSingletonForUpdate<ShipAndCo>();\n        randomizer = new Random();\n        randomizer.InitState(seed: 12345);\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        if (Input.GetKeyDown(KeyCode.A))\n        {\n            var sac = GetSingleton<ShipAndCo>();\n            Entity prefabEntity = sac.shipPrefab;\n            Entity instantiated = EntityManager.Instantiate(prefabEntity);\n            EntityManager.SetComponentData<Translation>(instantiated, new Translation\n            {\n                Value = randomizer.NextFloat3() * 10\n            });\n        }\n\n        return default;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Transforms;\nusing UnityEngine;\nusing Random = Unity.Mathematics.Random;\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class ShipAndCoSpawnerSystem : JobComponentSystem\n{\n    Random randomizer;\n\n    protected override void OnCreate()\n    {\n        base.OnCreate();\n        RequireSingletonForUpdate<ShipAndCo>();\n        randomizer = new Random();\n        randomizer.InitState(seed: 12345);\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        if (Input.GetKeyDown(KeyCode.A))\n        {\n            var sac = GetSingleton<ShipAndCo>();\n            Entity prefabEntity = sac.shipPrefab;\n            Entity instantiated = EntityManager.Instantiate(prefabEntity);\n            EntityManager.SetComponentData<Translation>(instantiated, new Translation\n            {\n                Value = randomizer.NextFloat3() * 10\n            });\n        }\n\n        return default;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我得到了一个正常支持 Entity 实例化的 companion particle systems, 很酷吧:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-97834b5340ef86b4326a2390efef9da6_b.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"截止到这里, companion game object 可以说是 conversion 过程的最后一块拼图了."}]},{"type":"element","tag":"h2","props":{"id":"gameobjectconversionutility"},"children":[{"type":"text","value":"GameObjectConversionUtility"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果前述的 convert and destroy 或者 convert and inject 规则你都不喜欢, 你完全可以使用下述static方法自行 convert."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static Entity ConvertGameObjectHierarchy(GameObject root, GameObjectConversionSettings settings)\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static Entity ConvertGameObjectHierarchy(GameObject root, GameObjectConversionSettings settings)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但你得先拿到 GameObject才行. ConvertToEntity之所以方便是因为你添加时就选择了该对象, 另外还有它的子层级(根据模式的不同). 而现在你只能传入"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一个"}]},{"type":"text","value":"GameObject 参数到这个方法中."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"root 自然是你想要 convert 的对象, 方法名字有 \"hierarchy\", 它知道如何处理这些情况:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果root 是 prefab asset, 那么你得到的结果和前述在 conversion 中声明 prefab 的结果一样. 如果你不喜欢声明和创建 prefab entity 绑定在一起, 那么你可以一个一个来."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果root 是 scene 中的对象, 它会和ConvertToEntity的工作模式类似, 要注意这个方法同时也会执行LinkedEntityGroup过程."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"settings可以通过 destination world 来获得:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":" public static GameObjectConversionSettings FromWorld(World destinationWorld, BlobAssetStore blobAssetStore)\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public static GameObjectConversionSettings FromWorld(World destinationWorld, BlobAssetStore blobAssetStore)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如非特殊, Destination world 通常是 World.DefaultGameObjectInjectionWorld. ConvertToEntity就会在内部默认使用该值."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BlobAssetStore我猜测是当你需要产生某些有BlobAssetReference字段的component时需要用到的东西, 目前你可以传入 null 或者 new BlobAssetStore , 但是记得要Dispose."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GameObjectConversionUtility 其他有趣的方法"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static void ConvertScene(Scene scene, GameObjectConversionSettings settings)\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static void ConvertScene(Scene scene, GameObjectConversionSettings settings)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和ConvertGameObjectHierarchy几乎一样, 只不过针对的是 scene 中所有的东西. 它不会添加LinkedEntityGroupbuffer, 除非scene中有被禁用的对象. (禁用行为参考前文)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个方法比给每个 scene 对象都加上ConvertToEntity 要高级一些, 后者你无法得到disabled entity 作为结果. 有 ConvertToEntity且被禁用的GameObject 的 Awake 方法不会被调用, 也就完全不会有 conversion 过程."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static World ConvertIncrementalInitialize(Scene scene, GameObjectConversionSettings settings)\npublic static void ConvertIncremental(World conversionWorld, IEnumerable<GameObject> gameObjects, ConversionFlags flags)\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static World ConvertIncrementalInitialize(Scene scene, GameObjectConversionSettings settings)\npublic static void ConvertIncremental(World conversionWorld, IEnumerable<GameObject> gameObjects, ConversionFlags flags)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这两个方法是什么? 第一个返回 World, 看起来像是 scene 中的内容可能会变化, 你可以用还未销毁的 conversion world 增量地 convert scene中新增的内容."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这两个方法在 live link 系统中有被用到, 后文会解释."}]},{"type":"element","tag":"h2","props":{"id":"subscene"},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Subscene"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为 subscene 还处于开发中, 用法随时可能改变, 所以我计划先写到这里, 不过我会大致解释一下, 然后等 entities package 正式发布."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你已经可以使用 GameObject 来编辑游戏, 在 ECS 的环境里运行了, 那么还缺点啥?"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你可能想要在"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"编辑模式"}]},{"type":"text","value":"时查看 conversion 的结果, 无论你多么小心地设计 conversion 过程都有可能出错."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你太懒了, 不想复制粘贴ConvertToEntity, 或者使用 utility 里的 Scene 方法."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你想在发布游戏时, 游戏能预先转换好("},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"pre-converted"}]},{"type":"text","value":"). 当加载 scene 时你就可以不用再重新运行转换过程, 而是加载 chunk 内存直接使用."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你懒得点\"序列化 ECS 内存\" 按钮来保存play mode下的内存供运行时使用, 更懒得添加内存加载的代码."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 play mode 时, 你不想让这些 pure Entity 从 Hierarchy 窗口消失. (当然你也不想使用 inject 模式来实现, 这会导致重复绘制对象的问题). 在 inspector 快速查看和修改运行时的对象非常有用."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-c924c16e23d2b941e4058ae2a720f115_b.jpg"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你可能想要一边修改内容, 一边实时 convert 这些数据. (比如调整Transform后里面更新到 LocalToWorld/Translation)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好消息是, 以上内容在 Subscene 里都是可行的! subscene 并不是比scene \"少\" 些东西, 而是被设计为可以嵌套进普通 scene 中的工具. 它的能力甚至比普通的 scene 要更强."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们开始吧, 先创建一个 GameObject并添加Subscenecomponent. 这时候你会被告知需要添加一个新的 Scene asset 用来存放 subscene 的内容."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-6d07337664d2fd541b8d1742f070e5e2_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以点击 \"Edit\" 来添加内容, 或者双击 scene asset 来打开 scene 进行修改 (这和常规的 scene 操作是一样的). 这里我添加了 2 个cube GameObject , 不过我不再需要ConvertToEntity了, scene 中的所有内容偶会被自动 convert (甚至还会警告你把已经没用的 ConvertToEntity 删掉)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-cf47b079fde25956965c75cfafd062e8_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-6ca9f8540a1bf57028c0878103a3d4d6_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在当你进入 play mode, 两个\"世界\"的好处都能获得. Hybrid Renderer负责渲染, tris 数量正常, 没有重复的对象出现."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-b1487642fdc3ba9a7ab3fc3698c1d27b_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而且, 它们是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"可被选中"}]},{"type":"text","value":"的. 这意味着尽管已经被convert 并 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"destroy"}]},{"type":"text","value":" 了, 但不知为何点击 Hierarchy 的对象依然可以选中转换前的状态."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"相应地, 如果你点击 scene view 你也可以选中 Hierarchy 中的对象!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能注意到上图中橙色的轮廓线不见了, 这时因为我开启了下面的选项:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-720ebb51d4072e9b804c87a57b1bf758_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"SceneView : Live Game State"}]},{"type":"text","value":" 意思是让 scene view 里面显示已经 convert 过的内容. 因此这时候 scene view 在使用 Hybrid Renderer 来渲染结果, 也无法显示那些橙色的轮廓线."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"SceneView: Editing State"}]},{"type":"text","value":" 则是让 scene view 在 play mode 时依然保持在 edit mode 时的状态, 这时候橙色轮廓线就能够显示了. 当然 cube 依然和 MeshFilter+MeshRenderer=RenderMesh设计地那样一样绘制. 但是如果 conversion 过程中将cube 染成了绿色, scene view 中将无法感知这一修改, cube 依然呈灰色."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-a1038be6c110edc989089a85047257eb_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最上面的 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Live Conversion in Edit Mode"}]},{"type":"text","value":" 指示在 edit mode 时的行为, 你可以选中它然后在 edit mode 看到 convert 的状态. "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"SceneView: Live Game State"}]},{"type":"text","value":" 开启而 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Live Conversion in Edit Mode"}]},{"type":"text","value":" 保持禁用这种情况没什么用, 因为你本想要在scene view + edit mode 查看实时的游戏状态, 而同时你又禁止它这样做."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你在 play mode 时移动 scene 中的 Transform (很可能因为 subscene 用预先转换的状态保持了 Hierarchy 的完整), 则会通过增量地重新转换(reconverted, diff-ed)无缝地更新到新状态, 这套机制就是 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"live link."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"比较 ConvertToEntity 和 Subscene"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-00f0364648daf575b2595c3583779473_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面两图中, 前者是通过 Subscene 进行转换, 后者则通过ConvertToEntity. 两者都是 destroy 模式, 所以MeshFilter这样的 component object 会被销毁:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f669be4df96944af4b995954d229e5b7_720w.jpg"},"children":[]},{"type":"text","value":"Subscene, 上方是 CubeInside, 下方是 Cube"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-a1d3fdd0f7bf0aa49578990dc5109b99_720w.jpg"},"children":[]},{"type":"text","value":"ConvertToEntity, 上下同理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"EditorRenderData,EntityGuid,SceneSection,SceneTag是这里最大的区别. 除了EntityGuid, 其他三者都是 ISharedComponentData. 所以基本不用操心 chunk 碎片的问题, 基本上所有 subscene 里的对象都会得到同样的结果."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConvertToEntity或 subscene 都不会为层级结构添加LinkedEntityGroupbuffer, 但是因为 subscene 与 ConvertScene 方法的规则相同, 因此如果有被 disabled 的对象时, 它会添加LinkedEntityGroup."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-fa31f3d1c34e5328ea654b88792039bd_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不是一次 conversion, 而是一个 scene!"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 并不希望传达出\"subscene 是一堆ConvertToEntity的结果\"这样的观念, 这是一个真正的 scene."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"包括在调用SceneManager.LoadScene 时. 下面的例子中, GO 有一个ConvertToEntity, InSubScene1什么都没有但是位于 subscene 中:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-d03443f3982058272989d61a6fda8259_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当进入 play mode 时, 两者都按照期望被转换了, Subscene 和ConvertToEntity 这时是等价的."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-0dd4504f76658d822b0c78eee4606300_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但如果我们 SceneManager.LoadScene 改变当前的 scene:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-f26e95d0237f8cfb9753c38397a681d8_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到 subscene 里的 entity 同样被删除了, 但是正如ConvertToEntity名字所隐含的意义, 转换后就和 scene 没什么关系了, GO 依然存在. 这对于 entity 的生命周期管理很有帮助. ( 在进入 scene 前, 相关 system 无需做无用功)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我猜想 DeclareDependency 应该对这个功能有所帮助."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-19-game-object-conversion-and-subscene/v2-36bbe1659c6b2da765b54421090f2319_720w.jpg"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"以前是如何制作游戏的","depth":2,"text":"以前是如何制作游戏的"},{"id":"如何在-dots-的世界里做游戏","depth":2,"text":"如何在 DOTS 的世界里做游戏"},{"id":"hybrid-renderer","depth":2,"text":"Hybrid Renderer"},{"id":"让我们用纯数据来做个游戏吧","depth":2,"text":"让我们用纯数据来做个游戏吧"},{"id":"transform-systems","depth":2,"text":"Transform systems"},{"id":"可是这样构建游戏实在是太痛苦了","depth":2,"text":"可是这样构建游戏实在是太痛苦了"},{"id":"conversion-workflow","depth":2,"text":"Conversion workflow"},{"id":"conversion-world-destination-world-primary-entity","depth":2,"text":"Conversion world, destination world, primary entity"},{"id":"gameobjectconversionsystem","depth":2,"text":"GameObjectConversionSystem"},{"id":"conversion-的顺序","depth":2,"text":"Conversion 的顺序"},{"id":"gameobjectconversionmappingsystem","depth":2,"text":"GameObjectConversionMappingSystem"},{"id":"让我们使用-converttoentity-来convert吧","depth":2,"text":"让我们使用 ConvertToEntity 来convert吧"},{"id":"hierarchy-conversion","depth":2,"text":"Hierarchy conversion"},{"id":"disabled-与-gameobject-conversion","depth":2,"text":"Disabled 与 GameObject conversion"},{"id":"convert-and-inject-模式","depth":2,"text":"Convert and inject 模式"},{"id":"使用-ecs-的system-来管理传统的-monobehaviour","depth":2,"text":"使用 ECS 的System 来管理传统的 MonoBehaviour"},{"id":"inject-模式的-conversion-规则","depth":2,"text":"Inject 模式的 conversion 规则"},{"id":"iconvertgameobjecttoentity","depth":2,"text":"IConvertGameObjectToEntity"},{"id":"linkedentitygroup","depth":2,"text":"LinkedEntityGroup"},{"id":"从非-prefab-conversion-中获取linkedentitygroup","depth":2,"text":"从非 prefab conversion 中获取LinkedEntityGroup"},{"id":"尺寸警告","depth":2,"text":"尺寸警告!"},{"id":"创建额外的-entity","depth":2,"text":"创建额外的 entity"},{"id":"从单一源得到-entity","depth":2,"text":"从单一源得到 entity"},{"id":"如何影响-linked-entity-group","depth":2,"text":"如何影响 linked entity group"},{"id":"声明-asset","depth":2,"text":"声明 Asset"},{"id":"prefab-asset-conversion-过程","depth":2,"text":"Prefab asset conversion 过程"},{"id":"声明和使用-prefab-asset-的示例","depth":2,"text":"声明和使用 prefab asset 的示例"},{"id":"generateauthoringcomponent","depth":2,"text":"[GenerateAuthoringComponent]"},{"id":"混用converttoentity的-destroy-和-inject-模式","depth":2,"text":"混用ConvertToEntity的 destroy 和 inject 模式"},{"id":"companion-game-object","depth":2,"text":"Companion Game Object"},{"id":"gameobjectconversionutility","depth":2,"text":"GameObjectConversionUtility"},{"id":"subscene","depth":2,"text":"Subscene"}]}},"_type":"markdown","_id":"content:unity:2020-10-19-game-object-conversion-and-subscene.md","_source":"content","_file":"unity/2020-10-19-game-object-conversion-and-subscene.md","_extension":"md","date":"2020-10-19"},{"_path":"/unity/2020-10-20-ecs-world","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"源代码分析world的创建","description":"Packages/com.unity.entities/Unity.Entities.Hybrid/Injection/AutomaticWorldBootstrap.cs","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Packages/com.unity.entities/Unity.Entities.Hybrid/Injection/AutomaticWorldBootstrap.cs"}]},{"type":"element","tag":"pre","props":{"code":"    static class AutomaticWorldBootstrap\n    {\n        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\n        static void Initialize()\n        {\n            DefaultWorldInitialization.Initialize(\"Default World\", false);\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    static class AutomaticWorldBootstrap\n    {\n        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\n        static void Initialize()\n        {\n            DefaultWorldInitialization.Initialize(\"Default World\", false);\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Packages/com.unity.entities/Unity.Entities/DefaultWorldInitialization.cs"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"检查是否有bootstrap没有的话则自动创建world"}]},{"type":"element","tag":"pre","props":{"code":"        /// <summary>\n        /// Initializes the default world or runs ICustomBootstrap if one is available.\n        /// </summary>\n        /// <param name=\"defaultWorldName\">The name of the world that will be created. Unless there is a custom bootstrap.</param>\n        /// <param name=\"editorWorld\">Editor worlds by default only include systems with [ExecuteAlways]. If editorWorld is true, ICustomBootstrap will not be used.</param>\n        public static World Initialize(string defaultWorldName, bool editorWorld = false)\n        {\n            RegisterUnloadOrPlayModeChangeShutdown();\n\n            if (!editorWorld)\n            {\n                var bootStrap = CreateBootStrap();\n                if (bootStrap != null && bootStrap.Initialize(defaultWorldName))\n                {\n                    Assert.IsTrue(World.DefaultGameObjectInjectionWorld != null,\n                        $\"ICustomBootstrap.Initialize() implementation failed to set \" +\n                        $\"World.DefaultGameObjectInjectionWorld, despite returning true \" +\n                        $\"(indicating the World has been properly initialized)\");\n                    return World.DefaultGameObjectInjectionWorld;\n                }\n            }\n\n            var world = new World(defaultWorldName, editorWorld ? WorldFlags.Editor : WorldFlags.Game);\n            World.DefaultGameObjectInjectionWorld = world;\n\n            var systemList = GetAllSystems(WorldSystemFilterFlags.Default, editorWorld);\n            AddSystemToRootLevelSystemGroupsInternal(world, systemList, systemList.Count);\n\n#if !UNITY_DOTSRUNTIME\n            ScriptBehaviourUpdateOrder.AddWorldToCurrentPlayerLoop(world);\n#endif\n\n            DefaultWorldInitialized?.Invoke(world);\n            return world;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        /// <summary>\n        /// Initializes the default world or runs ICustomBootstrap if one is available.\n        /// </summary>\n        /// <param name=\"defaultWorldName\">The name of the world that will be created. Unless there is a custom bootstrap.</param>\n        /// <param name=\"editorWorld\">Editor worlds by default only include systems with [ExecuteAlways]. If editorWorld is true, ICustomBootstrap will not be used.</param>\n        public static World Initialize(string defaultWorldName, bool editorWorld = false)\n        {\n            RegisterUnloadOrPlayModeChangeShutdown();\n\n            if (!editorWorld)\n            {\n                var bootStrap = CreateBootStrap();\n                if (bootStrap != null && bootStrap.Initialize(defaultWorldName))\n                {\n                    Assert.IsTrue(World.DefaultGameObjectInjectionWorld != null,\n                        $\"ICustomBootstrap.Initialize() implementation failed to set \" +\n                        $\"World.DefaultGameObjectInjectionWorld, despite returning true \" +\n                        $\"(indicating the World has been properly initialized)\");\n                    return World.DefaultGameObjectInjectionWorld;\n                }\n            }\n\n            var world = new World(defaultWorldName, editorWorld ? WorldFlags.Editor : WorldFlags.Game);\n            World.DefaultGameObjectInjectionWorld = world;\n\n            var systemList = GetAllSystems(WorldSystemFilterFlags.Default, editorWorld);\n            AddSystemToRootLevelSystemGroupsInternal(world, systemList, systemList.Count);\n\n#if !UNITY_DOTSRUNTIME\n            ScriptBehaviourUpdateOrder.AddWorldToCurrentPlayerLoop(world);\n#endif\n\n            DefaultWorldInitialized?.Invoke(world);\n            return world;\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查找可用的bootstrap并实例化"}]},{"type":"element","tag":"pre","props":{"code":"        static ICustomBootstrap CreateBootStrap()\n        {\n#if !UNITY_DOTSRUNTIME\n            var bootstrapTypes = TypeManager.GetTypesDerivedFrom(typeof(ICustomBootstrap));\n            Type selectedType = null;\n\n            foreach (var bootType in bootstrapTypes)\n            {\n                if (bootType.IsAbstract || bootType.ContainsGenericParameters)\n                    continue;\n\n                if (selectedType == null)\n                    selectedType = bootType;\n                else if (selectedType.IsAssignableFrom(bootType))\n                    selectedType = bootType;\n                else if (!bootType.IsAssignableFrom(selectedType))\n                    Debug.LogError(\"Multiple custom ICustomBootstrap specified, ignoring \" + bootType);\n            }\n            ICustomBootstrap bootstrap = null;\n            if (selectedType != null)\n                bootstrap = Activator.CreateInstance(selectedType) as ICustomBootstrap;\n\n            return bootstrap;\n#else\n            throw new Exception(\"This method should have been replaced by code-gen.\");\n#endif\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        static ICustomBootstrap CreateBootStrap()\n        {\n#if !UNITY_DOTSRUNTIME\n            var bootstrapTypes = TypeManager.GetTypesDerivedFrom(typeof(ICustomBootstrap));\n            Type selectedType = null;\n\n            foreach (var bootType in bootstrapTypes)\n            {\n                if (bootType.IsAbstract || bootType.ContainsGenericParameters)\n                    continue;\n\n                if (selectedType == null)\n                    selectedType = bootType;\n                else if (selectedType.IsAssignableFrom(bootType))\n                    selectedType = bootType;\n                else if (!bootType.IsAssignableFrom(selectedType))\n                    Debug.LogError(\"Multiple custom ICustomBootstrap specified, ignoring \" + bootType);\n            }\n            ICustomBootstrap bootstrap = null;\n            if (selectedType != null)\n                bootstrap = Activator.CreateInstance(selectedType) as ICustomBootstrap;\n\n            return bootstrap;\n#else\n            throw new Exception(\"This method should have been replaced by code-gen.\");\n#endif\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"小技巧: 新建一个ICustomBootstrap,在Initialize抛出异常.则能在追踪栈找到代码的入口"}]},{"type":"element","tag":"pre","props":{"code":"Multiple custom ICustomBootstrap specified, ignoring GameBootstrap\nUnityEngine.Debug:LogError(Object)\nUnity.Debug:LogError(Object) (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities/Stubs/Unity/Debug.cs:13)\nUnity.Entities.DefaultWorldInitialization:CreateBootStrap() (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities/DefaultWorldInitialization.cs:351)\nUnity.Entities.DefaultWorldInitialization:Initialize(String, Boolean) (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities/DefaultWorldInitialization.cs:116)\nUnity.Entities.AutomaticWorldBootstrap:Initialize() (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities.Hybrid/Injection/AutomaticWorldBootstrap.cs:15)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Multiple custom ICustomBootstrap specified, ignoring GameBootstrap\nUnityEngine.Debug:LogError(Object)\nUnity.Debug:LogError(Object) (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities/Stubs/Unity/Debug.cs:13)\nUnity.Entities.DefaultWorldInitialization:CreateBootStrap() (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities/DefaultWorldInitialization.cs:351)\nUnity.Entities.DefaultWorldInitialization:Initialize(String, Boolean) (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities/DefaultWorldInitialization.cs:116)\nUnity.Entities.AutomaticWorldBootstrap:Initialize() (at Library/PackageCache/com.unity.entities@0.14.0-preview.18/Unity.Entities.Hybrid/Injection/AutomaticWorldBootstrap.cs:15)\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-10-20-ecs-world.md","_source":"content","_file":"unity/2020-10-20-ecs-world.md","_extension":"md","date":"2020-10-20"},{"_path":"/unity/2020-10-21-platform","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity使用platforms构建","description":"BuildConfiguration他继承于scriptobject,他的扩展名是\".buildconfiguration\"导入的时候执行了编辑器脚本    [ScriptedImporter(3, new[] { BuildConfiguration.AssetExtension })]\n    sealed class BuildConfigurationScriptedImporter : ScriptedImporter\n    {\n        public override void OnImportAsset(AssetImportContext context)\n      ","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"buildconfiguration"},"children":[{"type":"text","value":"BuildConfiguration"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"他继承于scriptobject,他的扩展名是\".buildconfiguration\"导入的时候执行了编辑器脚本"}]}]},{"type":"element","tag":"pre","props":{"code":"    [ScriptedImporter(3, new[] { BuildConfiguration.AssetExtension })]\n    sealed class BuildConfigurationScriptedImporter : ScriptedImporter\n    {\n        public override void OnImportAsset(AssetImportContext context)\n        {\n            var asset = BuildConfiguration.CreateInstance();\n            if (BuildConfiguration.DeserializeFromPath(asset, context.assetPath))\n            {\n                context.AddObjectToAsset(\"asset\", asset/*, icon*/);\n                context.SetMainObject(asset);\n            }\n        }\n    ...\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    [ScriptedImporter(3, new[] { BuildConfiguration.AssetExtension })]\n    sealed class BuildConfigurationScriptedImporter : ScriptedImporter\n    {\n        public override void OnImportAsset(AssetImportContext context)\n        {\n            var asset = BuildConfiguration.CreateInstance();\n            if (BuildConfiguration.DeserializeFromPath(asset, context.assetPath))\n            {\n                context.AddObjectToAsset(\"asset\", asset/*, icon*/);\n                context.SetMainObject(asset);\n            }\n        }\n    ...\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"再看下他再unity中的编辑器显示"}]}]},{"type":"element","tag":"pre","props":{"code":"[CustomEditor(typeof(BuildConfigurationScriptedImporter))]\n    internal sealed class BuildConfigurationScriptedImporterEditor : ScriptedImporterEditor\n    {\n        static class ClassNames\n        {\n            public const string BaseClassName = nameof(BuildConfiguration);\n            public const string Dependencies = BaseClassName + \"__asset-dependencies\";\n            public const string Header = BaseClassName + \"__asset-header\";\n            public const string HeaderLabel = BaseClassName + \"__asset-header-label\";\n            public const string BuildAction = BaseClassName + \"__build-action\";\n            public const string BuildDropdown = BaseClassName + \"__build-dropdown\";\n            public const string AddComponent = BaseClassName + \"__add-component-button\";\n            public const string OptionalComponents = BaseClassName + \"__optional-components\";\n        }\n\n        internal struct BuildAction : IEquatable<BuildAction>\n        {\n            public string Name;\n            public Action<BuildConfiguration> Action;\n\n            public bool Equals(BuildAction other)\n            {\n                return Name == other.Name;\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[CustomEditor(typeof(BuildConfigurationScriptedImporter))]\n    internal sealed class BuildConfigurationScriptedImporterEditor : ScriptedImporterEditor\n    {\n        static class ClassNames\n        {\n            public const string BaseClassName = nameof(BuildConfiguration);\n            public const string Dependencies = BaseClassName + \"__asset-dependencies\";\n            public const string Header = BaseClassName + \"__asset-header\";\n            public const string HeaderLabel = BaseClassName + \"__asset-header-label\";\n            public const string BuildAction = BaseClassName + \"__build-action\";\n            public const string BuildDropdown = BaseClassName + \"__build-dropdown\";\n            public const string AddComponent = BaseClassName + \"__add-component-button\";\n            public const string OptionalComponents = BaseClassName + \"__optional-components\";\n        }\n\n        internal struct BuildAction : IEquatable<BuildAction>\n        {\n            public string Name;\n            public Action<BuildConfiguration> Action;\n\n            public bool Equals(BuildAction other)\n            {\n                return Name == other.Name;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"该脚本定义了三个按钮"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"build"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"run"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"build and run"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如何建立"}]}]},{"type":"element","tag":"pre","props":{"code":"        public BuildResult Build()\n        {\n            var pipeline = GetBuildPipeline();\n            var canUse = CanUsePipeline(pipeline);\n            if (!canUse.Result)\n            {\n                return BuildResult.Failure(pipeline, this, canUse.Reason);\n            }\n\n            var what = !string.IsNullOrEmpty(name) ? $\" {name}\" : string.Empty;\n            using (var progress = new BuildProgress($\"Building{what}\", \"Please wait...\"))\n            {\n                return pipeline.Build(this, progress);\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public BuildResult Build()\n        {\n            var pipeline = GetBuildPipeline();\n            var canUse = CanUsePipeline(pipeline);\n            if (!canUse.Result)\n            {\n                return BuildResult.Failure(pipeline, this, canUse.Reason);\n            }\n\n            var what = !string.IsNullOrEmpty(name) ? $\" {name}\" : string.Empty;\n            using (var progress = new BuildProgress($\"Building{what}\", \"Please wait...\"))\n            {\n                return pipeline.Build(this, progress);\n            }\n        }\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"从IBuildPipelineComponent组件中获取Pipeline..继承IBuildPipelineComponent接口的组件有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ClassicBuildProfile"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DotsRuntimeBuildProfile"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关于platform,我们看下安卓建立的配置,可以看到手动实例化了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ClassicBuildProfile"}]},{"type":"text","value":",并且设置了platform"},{"type":"element","tag":"pre","props":{"code":"    static class AndroidMenuItem\n    {\n        const string k_CreateBuildConfigurationAssetClassic = BuildConfigurationMenuItem.k_BuildConfigurationMenu + \"Android Classic Build Configuration\";\n\n        [MenuItem(k_CreateBuildConfigurationAssetClassic, true)]\n        static bool CreateBuildConfigurationAssetClassicValidation()\n        {\n            return Directory.Exists(AssetDatabase.GetAssetPath(Selection.activeObject));\n        }\n\n        [MenuItem(k_CreateBuildConfigurationAssetClassic)]\n        static void CreateBuildConfigurationAssetClassic()\n        {\n            Selection.activeObject = BuildConfigurationMenuItem.CreateAssetInActiveDirectory(\n                \"AndroidClassic\",\n                new GeneralSettings(),\n                new SceneList(),\n                new ClassicBuildProfile { Platform = new AndroidPlatform() });\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    static class AndroidMenuItem\n    {\n        const string k_CreateBuildConfigurationAssetClassic = BuildConfigurationMenuItem.k_BuildConfigurationMenu + \"Android Classic Build Configuration\";\n\n        [MenuItem(k_CreateBuildConfigurationAssetClassic, true)]\n        static bool CreateBuildConfigurationAssetClassicValidation()\n        {\n            return Directory.Exists(AssetDatabase.GetAssetPath(Selection.activeObject));\n        }\n\n        [MenuItem(k_CreateBuildConfigurationAssetClassic)]\n        static void CreateBuildConfigurationAssetClassic()\n        {\n            Selection.activeObject = BuildConfigurationMenuItem.CreateAssetInActiveDirectory(\n                \"AndroidClassic\",\n                new GeneralSettings(),\n                new SceneList(),\n                new ClassicBuildProfile { Platform = new AndroidPlatform() });\n        }\n    }\n"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"buildplayerstep"},"children":[{"type":"text","value":"BuildPlayerStep"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"我们看到他的最终执行仍然使用了API, UnityEditor.BuildPipeline.BuildPlayer(buildPlayerOptions);"}]}]},{"type":"element","tag":"pre","props":{"code":"sealed class BuildPlayerStep : BuildStepBase\n    {\n        public override Type[] UsedComponents { get; } =\n        {\n            typeof(ClassicBuildProfile),\n            typeof(SceneList),\n            typeof(GeneralSettings),\n            typeof(OutputBuildDirectory)\n        };\n\n        public override BuildResult Run(BuildContext context)\n        {\n            var classicSharedData = context.GetValue<ClassicSharedData>();\n            var target = classicSharedData.BuildTarget;\n            if (target <= 0)\n                return context.Failure($\"Invalid build target '{target.ToString()}'.\");\n            if (target != EditorUserBuildSettings.activeBuildTarget)\n                return context.Failure($\"{nameof(EditorUserBuildSettings.activeBuildTarget)} must be switched before {nameof(BuildPlayerStep)} step.\");\n\n            var embeddedScenes = context.GetValue<EmbeddedScenesValue>().Scenes;\n            if (embeddedScenes.Length == 0)\n                return context.Failure(\"There are no scenes to build.\");\n\n            var outputPath = context.GetOutputBuildDirectory();\n            if (!Directory.Exists(outputPath))\n                Directory.CreateDirectory(outputPath);\n\n            string locationPathName;\n            if (context.HasValue<LocationInfo>())\n            {\n                locationPathName = context.GetValue<LocationInfo>().Path;\n            }\n            else\n            {\n                var generalSettings = context.GetComponentOrDefault<GeneralSettings>();\n                locationPathName = Path.Combine(outputPath, generalSettings.ProductName + ClassicBuildProfile.GetExecutableExtension(target));\n            }\n\n            var buildPlayerOptions = new BuildPlayerOptions()\n            {\n                scenes = embeddedScenes,\n                target = target,\n                locationPathName = locationPathName,\n                targetGroup = UnityEditor.BuildPipeline.GetBuildTargetGroup(target),\n            };\n\n            buildPlayerOptions.options = BuildOptions.None;\n\n            foreach (var customizer in classicSharedData.Customizers)\n                buildPlayerOptions.options |= customizer.ProvideBuildOptions();\n\n            var extraScriptingDefines = classicSharedData.Customizers.SelectMany(c => c.ProvidePlayerScriptingDefines()).ToArray();\n            buildPlayerOptions.extraScriptingDefines = extraScriptingDefines;\n\n            var report = UnityEditor.BuildPipeline.BuildPlayer(buildPlayerOptions);\n            context.SetValue(report);\n\n            return context.FromReport(report);\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sealed class BuildPlayerStep : BuildStepBase\n    {\n        public override Type[] UsedComponents { get; } =\n        {\n            typeof(ClassicBuildProfile),\n            typeof(SceneList),\n            typeof(GeneralSettings),\n            typeof(OutputBuildDirectory)\n        };\n\n        public override BuildResult Run(BuildContext context)\n        {\n            var classicSharedData = context.GetValue<ClassicSharedData>();\n            var target = classicSharedData.BuildTarget;\n            if (target <= 0)\n                return context.Failure($\"Invalid build target '{target.ToString()}'.\");\n            if (target != EditorUserBuildSettings.activeBuildTarget)\n                return context.Failure($\"{nameof(EditorUserBuildSettings.activeBuildTarget)} must be switched before {nameof(BuildPlayerStep)} step.\");\n\n            var embeddedScenes = context.GetValue<EmbeddedScenesValue>().Scenes;\n            if (embeddedScenes.Length == 0)\n                return context.Failure(\"There are no scenes to build.\");\n\n            var outputPath = context.GetOutputBuildDirectory();\n            if (!Directory.Exists(outputPath))\n                Directory.CreateDirectory(outputPath);\n\n            string locationPathName;\n            if (context.HasValue<LocationInfo>())\n            {\n                locationPathName = context.GetValue<LocationInfo>().Path;\n            }\n            else\n            {\n                var generalSettings = context.GetComponentOrDefault<GeneralSettings>();\n                locationPathName = Path.Combine(outputPath, generalSettings.ProductName + ClassicBuildProfile.GetExecutableExtension(target));\n            }\n\n            var buildPlayerOptions = new BuildPlayerOptions()\n            {\n                scenes = embeddedScenes,\n                target = target,\n                locationPathName = locationPathName,\n                targetGroup = UnityEditor.BuildPipeline.GetBuildTargetGroup(target),\n            };\n\n            buildPlayerOptions.options = BuildOptions.None;\n\n            foreach (var customizer in classicSharedData.Customizers)\n                buildPlayerOptions.options |= customizer.ProvideBuildOptions();\n\n            var extraScriptingDefines = classicSharedData.Customizers.SelectMany(c => c.ProvidePlayerScriptingDefines()).ToArray();\n            buildPlayerOptions.extraScriptingDefines = extraScriptingDefines;\n\n            var report = UnityEditor.BuildPipeline.BuildPlayer(buildPlayerOptions);\n            context.SetValue(report);\n\n            return context.FromReport(report);\n        }\n    }\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"buildconfiguration","depth":2,"text":"BuildConfiguration"},{"id":"buildplayerstep","depth":2,"text":"BuildPlayerStep"}]}},"_type":"markdown","_id":"content:unity:2020-10-21-platform.md","_source":"content","_file":"unity/2020-10-21-platform.md","_extension":"md","date":"2020-10-21"},{"_path":"/unity/2020-10-22-unity-render-order","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity rendering order渲染顺序","description":"關於深度緩衝 (Depth buffering, or z-buffering)勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 Rasterization 怎麼透過 z-buffering ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"關於深度緩衝-depth-buffering-or-z-buffering"},"children":[{"type":"text","value":"關於深度緩衝 (Depth buffering, or z-buffering)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Rasterisation","rel":["nofollow"]},"children":[{"type":"text","value":"Rasterization"}]},{"type":"text","value":" 怎麼透過 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Z-buffering","rel":["nofollow"]},"children":[{"type":"text","value":"z-buffering"}]},{"type":"text","value":" ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小與最後成像尺寸相同。在 Unity shader 中可利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZWrite On | Off"}]},{"type":"text","value":" 來切換是否將深度資訊要寫入到 z-buffer。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果場景中其他物件 rendering 時，也在同一個 pixel 位置渲染結果時，會檢查 z-buffer 所儲存的深度資訊，是否將渲染結果覆蓋原本的 pixel，並且將新的深度資訊寫入到 z-buffer。通常條件會設定為深度資訊比原本更接近攝影機時，就能夠覆蓋原本結果。在 Unity shader 中可利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always"}]},{"type":"text","value":" 來調整判斷方式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"有 z-buffering 機制，可不管物件算繪順序 (rendering order)，使得離攝影機越近的物件，永遠都描繪在其他離攝影機越遠的物件之前"}]},{"type":"text","value":" ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZTest LEqual"}]},{"type":"text","value":")。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-xEsBEXX2jiQ/Wv_KFd2e3hI/AAAAAAAAwHY/aMJAzz3UIPkMUZOUqd9sgz_dsKZYN0PmQCHMYCw/s1600/bed-room.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"房間示意圖","src":"/images/2020-10-22-unity-render-order/bed-room.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"房間示意圖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-x6KnmDnIk6o/Wv_KF_uymYI/AAAAAAAAwHc/XyV7-wddP-0QgqxstR_8MGzLGOxMlbUuACHMYCw/s1600/depth-info-bed-room.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"房間的深度資訊，越深色表示離攝影機越近","src":"/images/2020-10-22-unity-render-order/depth-info-bed-room.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"房間的深度資訊，越深色表示離攝影機越近"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://assetstore.unity.com/packages/3d/props/furniture/pack-gesta-furniture-1-28237","rel":["nofollow"]},"children":[{"type":"text","value":"場景來源"}]}]},{"type":"element","tag":"h2","props":{"id":"renderers-rendering-order"},"children":[{"type":"text","value":"Renderer’s rendering order"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假設 shader 中關閉深度機制的判斷 ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZTest Always"}]},{"type":"text","value":")，或者在 render 場景物件的過程中都不寫入深度 ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZWrite Off"}]},{"type":"text","value":")，即"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"沒有 z-buffering 機制，rendering order 會決定成像的結果，越晚畫的物件永遠都在其他較早畫的物件之上"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而在 SpriteRenderer 直接修改 sorting layer 以及 order in layer 來改變 rendering order，就能調整該物件在算繪結果的物件前後，便是基於此緣故，更多細節可查看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Sprites/Default"}]},{"type":"text","value":" shader 程式碼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"故整理在 Unity 中，rendering order 是根據以下參數進行排序："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Camera depth > Material type > Sorting layer > Order in layer > Material render queue > Camera order algorithm"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Camera depth"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常無法搭配 Clear Flags: Don’t Clear，因為不會清除 depth buffer (z-buffer)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"camera.depth"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇場景中的 camera 編輯"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-VdjJ2P8mRSw/Wv_KGL2e9kI/AAAAAAAAwHg/bf871Tz0ZCgcM_pTnENDlLA2EVCVEOXgQCHMYCw/s1600/edit-camera-depth-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 depth 參數","src":"/images/2020-10-22-unity-render-order/edit-camera-depth-unity.png"},"children":[]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"編輯 depth 參數"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material type"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"先畫不透明物件 (opaque)，再畫透明物件 (transparent)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根據 material render queue 來決定，數值小於等於 2500 為不透明物件，數值大於 2500 為透明物件"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sorting layer"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯（不過自定義編輯器來達成）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingLayerID"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 Tag Manager 編輯 Sorting layer"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-HQnwI_JP7dQ/Wv_KG_RuisI/AAAAAAAAwHo/8ecZFCMsknsP2XOd227LgYyr_JsP-k5fwCHMYCw/s1600/edit-sorting-layers-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Sorting layers","src":"/images/2020-10-22-unity-render-order/edit-sorting-layers-unity.png"},"children":[]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Sorting layer"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-74IY8tFv9b4/WwAf4mJ-bqI/AAAAAAAAwJQ/xHzyeHjHwP89PPKkCo3Ahp_OrsCdEJNKwCLcBGAs/s1600/edit-sorting-layer-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Sorting layer","src":"/images/2020-10-22-unity-render-order/edit-sorting-layer-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Order in layer"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingOrder"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Order in layer"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-8VZ0pu3-ZdI/WwAfrRVqL9I/AAAAAAAAwJM/89ZAUPkUfUsy9eXQn1bZUW9y_Q8HxBCxwCLcBGAs/s1600/edit-order-in-layer-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Order in layer","src":"/images/2020-10-22-unity-render-order/edit-order-in-layer-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material render queue"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"預設值會從 Shader 取得，但可自行定義"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不透明物件 (Opaque)、半透明物件 (AlphaTest)、透明物件 (Transparent) 預設值分別 2000、2450、以及 3000"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常只有透明物件會關閉 ZWrite"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"material.renderQueue"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇專案中的 material 編輯"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/--4-IFurF7lk/Wv_KGSiPZ2I/AAAAAAAAwHk/95Bv8w902lke-HN_CCP1wigeekWuMQknQCHMYCw/s1600/edit-render-queue-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 render queue","src":"/images/2020-10-22-unity-render-order/edit-render-queue-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Camera render algorithm"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"無法在預設編輯器修改，使用程式調整"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"非透明物件排序演算法"},{"type":"element","tag":"pre","props":{"code":"camera.opaqueSortMode\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"camera.opaqueSortMode\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Default：在 Unity 2018.1 預設值 FrontToBack"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"FrontToBack：粗略低由近到遠排序繪製，能使得 GPU rendering 時有更好的效能"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"NoDistanceSort：關閉排序繪製，能降低 CPU 的使用量"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透明物件排序演算法"},{"type":"element","tag":"pre","props":{"code":"camera.transparencySortMode\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"camera.transparencySortMode\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Default：根據 camera projection mode 調整"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Perspective：根據 camera 位置到物件中心 (object center) 的距離排序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Orthographic：根據 view plane 到物件中心 (object center) 的距離排序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CustomAxis：制定 axis 排序，專門用於 2D 遊戲製作，可參考"},{"type":"element","tag":"a","props":{"href":"https://qiita.com/RyotaMurohoshi/items/3f0de2689af72f9b46f9","rel":["nofollow"]},"children":[{"type":"text","value":"這篇文章"}]}]}]}]}]}]}]},{"type":"element","tag":"h4","props":{"id":"补充renderqueue"},"children":[{"type":"text","value":"补充RenderQueue"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"nderQueue ，RenderQueue 其实就是shader中tags中的Queue"}]},{"type":"element","tag":"pre","props":{"code":"Tags { \"Queue\"=\"Geometry\" }\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Tags { \"Queue\"=\"Geometry\" }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下，Unity会基于对象距离摄像机的远近来排序你的对象。因此，当一个对象离摄像机越近，它就会优先绘制在其他更远的对象上面。对于大多数情况这是有效并合适的，但是在一些特殊情况下，你可能想要自己控制对象的绘制顺序。而使用Tags{}块我们就可以得到这样的控制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity提供给我们一些默认的渲染队列，每一个对应一个唯一的值，来指导Unity绘制对象到屏幕上。这些内置的渲染队列被称为Background, Geometry, AlphaTest, GeometryLast,Transparent, Overlay。这些队列不是随便创建的，它们是为了让我们更容易地编写Shader并处理实时渲染的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同时需在SubShader中显示声明ZWrite Off，通知Unity我们会重写物体的渲染深度排序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https:////upload-images.jianshu.io/upload_images/15536448-9a2deda21e4f661e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/744/format/webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，最后给出一个最终的总结：\n依次按条件先后顺序进行排序渲染处理。先按大项条件排序，后按小项条件排序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.Camera Depth: 越小越优先\n2.RenderQueue 2500以下"}]},{"type":"element","tag":"pre","props":{"code":"1. Sorting Layer/Order in Layer\n    1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n    2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n    2.RenderQueue 越小越优先\n    3.RenderQueue 相等，`由近到远排序优先`\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"1. Sorting Layer/Order in Layer\n    1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n    2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n    2.RenderQueue 越小越优先\n    3.RenderQueue 相等，`由近到远排序优先`\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.RenderQueue 2500以上\n1. Sorting Layer/Order in Layer\n1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n2.RenderQueue 越小越优先\n3.RenderQueue 相等，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"由远到近排序优先"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说明一下：2500是关键值，它是透明跟不透明的分界点，因此我们考虑层级的时候要注意着点：renderqueue > 2500的物体绝对会在renderqueue <= 2500的物体前面，即渲染时renderqueue大的会挡住renderqueue小的，不论它的sortingLayer和sortingOrder怎么设置都是不起作用的。知道了这点，其他的就很好理解了。当两个的RenderQueue都在同一侧时，在SortingLayer高的绝对会在sortingLayer前面，无视renderqueue跟soringOrder，只有在sortingLayer相同的前提下，soringOrder高的会在sortingOrder低的前面，无视renderqueue。当sortingLayer跟sortingOrder相同时，才看renderqueue的高低，高的在前面。特别要注意一下半透明物体的渲染顺序是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"越远越先渲染"}]},{"type":"text","value":"，这与不透明物体是相反的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI中的ui默认使用的是UI/Default 材质，对应的shader中的渲染队列是Transparent"}]},{"type":"element","tag":"pre","props":{"code":"Shader \"UI/Default\"\n{\n    Properties\n    {\n       ...\n    }\n\n    SubShader\n    {\n        Tags\n        {\n            \"Queue\"=\"Transparent\"\n            \"IgnoreProjector\"=\"True\"\n            \"RenderType\"=\"Transparent\"\n            \"PreviewType\"=\"Plane\"\n            \"CanUseSpriteAtlas\"=\"True\"\n        }\n        ...\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Shader \"UI/Default\"\n{\n    Properties\n    {\n       ...\n    }\n\n    SubShader\n    {\n        Tags\n        {\n            \"Queue\"=\"Transparent\"\n            \"IgnoreProjector\"=\"True\"\n            \"RenderType\"=\"Transparent\"\n            \"PreviewType\"=\"Plane\"\n            \"CanUseSpriteAtlas\"=\"True\"\n        }\n        ...\n    }\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"uguis-rendering-order"},"children":[{"type":"text","value":"UGUI’s rendering order"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Unity 5.x 推出的 UGUI 系統中，其 rendering order 卻是另外規則，這分成兩個部分探討 Canvas & CanvasRenderer，其概念可想像是 CanvasRenderer 可視為畫在畫布 Canvas 的元件，之後該畫布再畫在最終的畫面上（e.g. render target）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"關於 Canvas 的 rendering order："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Screen Space - Overlay"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"想像該 canvas 由隱藏的 camera 處理，其 depth = 101 (最後才處理)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多個相同的 canvas 使用 Sort Order 來決定描繪順序，數字越大越晚畫"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-Jwq-GkVy5Pg/Wv_MaxvDuEI/AAAAAAAAwII/8xeKRt-08sw9AtYHAxXbPztqk3rlwMH6QCLcBGAs/s1600/edit-canvas-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Canvas's Sort Order","src":"/images/2020-10-22-unity-render-order/edit-canvas-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Screen Space - Camera & World Space"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"想像為存在在世界場景的平面"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多個相同 canvas 使用 Sorting layer 以及 Order in layer 來決定 rendering order"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://4.bp.blogspot.com/-u-mDDKcRfAY/Wv_NHS9SsZI/AAAAAAAAwIU/Mt_mBRPL8DYo7Xj9Cbh-hOPTFbg6X3UMgCLcBGAs/s1600/edit-canvas-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Canvas's Sorting layer & Order in layer","src":"/images/2020-10-22-unity-render-order/edit-canvas-unity.png"},"children":[]}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"關於同一個 canvas 下，其 CanvasRenderer 之間的 rendering order："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material render queue > Transform order"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material render queue 同前面說明，看材質球 (material) 的 render queue 參數"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Transform order：依照 Transform 階層關係，採 Pre-order 方式排序"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://4.bp.blogspot.com/-fCMusmLKj4k/Wv_NnqL6SXI/AAAAAAAAwIo/suCM_XaddIAEwirQkIibP2wB8Mas3EjagCLcBGAs/s1600/canvas-renderer-rendering-order-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"Canvas renderer's rendering order example","src":"/images/2020-10-22-unity-render-order/canvas-renderer-rendering-order-unity.png"},"children":[]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意：當所屬的 Canvas 之 render mode 為 Screen Space - Overlay，則無視 Material render queue"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"使用實踐情境"},"children":[{"type":"text","value":"使用實踐情境"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3D"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不透明物件 & 半透明物件 (e.g. 草、鐵絲網等等) 依照場景擺放"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不需要特別設定 rendering order"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一切交給 z-buffering 機制"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透明物件或是粒子特效 (particle system) 可透過 sort layer & order in layer 機制調整 rendering order"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透明物件 shader 通常不會寫 z-buffer (e.g. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZWrite Off"}]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可 hack inspector 來設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingLayerID"}]},{"type":"text","value":" 以及 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingOrder"}]}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2D"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sprite renderer 使用 sort layer & order in layer 機制來調整 rendering order，以控制 depth"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UGUI"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"利用 transform hierarchy 來建立 rendering order，因應效能優化可能還得拆成多個 canvas"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"若採用 Canvas render mode: World space，想讓 UI 與 3D 場景物件的結合，可將 canvas 視為 3D 物件去設計場景架構 (這自己就沒有經驗…)"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"關於深度緩衝-depth-buffering-or-z-buffering","depth":2,"text":"關於深度緩衝 (Depth buffering, or z-buffering)"},{"id":"renderers-rendering-order","depth":2,"text":"Renderer’s rendering order"},{"id":"uguis-rendering-order","depth":2,"text":"UGUI’s rendering order"},{"id":"使用實踐情境","depth":2,"text":"使用實踐情境"}]}},"_type":"markdown","_id":"content:unity:2020-10-22-unity-render-order.md","_source":"content","_file":"unity/2020-10-22-unity-render-order.md","_extension":"md","date":"2020-10-22"},{"_path":"/unity/2020-10-23-unity-optimizing-gpu","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","description":"静态批处理[1]定义标明为 Static 的静态物件，如果在使用相同材质球的条件下，在**Build（项目打包）**的时候Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"静态批处理1"},"children":[{"type":"text","value":"静态批处理["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_1","rel":["nofollow"]},"children":[{"type":"text","value":"1]"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"定义"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"标明为 Static 的静态物件，如果在使用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相同材质球"}]},{"type":"text","value":"的条件下，在**Build（项目打包）**的时候Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-48b948e088a2310817c67c6530637a95_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次Draw call分别绘制每一个子模型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-9e2e1e5df3ad1b37ebe0dc1af4712005_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Static batching并**不减少Draw call的数量（**但是在编辑器时由于计算方法区别Draw call数量是会显示减少了的["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_2","rel":["nofollow"]},"children":[{"type":"text","value":"2]"}]},{"type":"text","value":"），但是由于我们预先把所有的子模型的顶点变换到了世界空间下，所以在运行时cpu不需要再次执行顶点变换操作，节约了少量的计算资源，并且这些子模型共享材质，所以在多次Draw call调用之间并没有渲染状态的切换，渲染API（Command Buffer）会缓存绘制命令，起到了渲染优化的目的 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但Static batching也会带来一些性能的负面影响。Static batching会导致应用打包之后体积增大，应用运行时所占用的内存体积也会增大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，在很多不同的GameObject引用同一模型的情况下，如果不开启Static batching，GameObject共享的模型会在应用程序包内或者内存中只存在一份，绘制的时候提交模型顶点信息，然后设置每一个GameObjec的材质信息，分别调用渲染API绘制。开启Static batching，在Unity执行Build的时候，场景中所有引用相同模型的GameObject都必须将模型顶点信息复制，并经过计算变化到最终在世界空间中，存储在最终生成的Vertex buffer中。这就导致了打包的体积及运行时内存的占用增大。例如，在茂密的森林级别将树标记为静态会严重影响内存["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_3","rel":["nofollow"]},"children":[{"type":"text","value":"3]"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"无法参与批处理情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相同材质批处理断开情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行同批处理（除非他们指向lightmap的同一部分）。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"流程原理"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-37b225e02afe6dca369647e4a3bf3bd4_720w.jpg"},"children":[]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"动态批处理4"},"children":[{"type":"text","value":"动态批处理["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_4","rel":["nofollow"]},"children":[{"type":"text","value":"4]"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"定义"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在使用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相同材质球"}]},{"type":"text","value":"的情况下，Unity会在运行时对于"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"正在视野中"}]},{"type":"text","value":"的符合条件的动态对象在一个Draw call内绘制，所以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"会降低Draw Calls"}]},{"type":"text","value":"的数量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dynamic batching的原理也很简单，在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中，然后通过一次Draw call绘制多个模型，达到合批的目的。模型顶点变换的操作是由CPU完成的，所以这会带来一些CPU的性能消耗。并且计算的模型顶点数量不宜太多，否则CPU串行计算耗费的时间太长会造成场景渲染卡顿，所以Dynamic batching只能处理一些小模型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dynamic batching在降低Draw call的同时会导致额外的CPU性能消耗，所以仅仅在合批操作的性能消耗小于不合批，Dynamic batching才会有意义。而新一代图形API（ Metal、Vulkan）在批次间的消耗降低了很多，所以在这种情况下使用Dynamic batching很可能不能获得性能提升。Dynamic batching相对于Static batching不需要预先复制模型顶点，所以在内存占用和发布的程序体积方面要优于Static batching。但是Dynamic batching会带来一些运行时CPU性能消耗，Static batching在这一点要比Dynamic batching更加高效。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"无法参与批处理情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物件Mesh大于等于900个面。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"代码动态改变材质变量后不算同一个材质，会不参与合批。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体，否则都无法参与合批。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"批处理中断情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物体如果都符合条件会优先参与静态批处理，再是GPU Instancing，然后才到动态批处理，假如物体符合前两者，此次批处理都会被打断。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameObject之间如果有镜像变换不能进行合批，例如，\"GameObject A with +1 scale and GameObject B with –1 scale cannot be batched together\"。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用Multi-pass Shader的物体会禁用Dynamic batching，因为Multi-pass Shader通常会导致一个物体要连续绘制多次，并切换渲染状态。这会打破其跟其他物体进行Dynamic batching的机会。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"我们知道能够进行合批的前提是多个GameObject共享同一材质，但是对于Shadow casters的渲染是个例外。仅管Shadow casters使用不同的材质，但是只要它们的材质中给Shadow Caster Pass使用的参数是相同的，他们也能够进行Dynamic batching。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unity的Forward Rendering Path中如果一个GameObject接受多个光照会为每一个per-pixel light产生多余的模型提交和绘制，从而附加了多个Pass导致无法合批，如下图:"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-177f53a633d2eac753abe07805367d4d_720w.jpg"},"children":[]},{"type":"text","value":"可以接收多个光源的shader，在受到多个光源是无法合批"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"流程原理"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-8c69d718432ba4045155c700fda6f6b6_720w.jpg"},"children":[]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"gpu-instancing"},"children":[{"type":"text","value":"GPU Instancing"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"定义"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在使用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相同材质球、相同Mesh(预设体的实例会自动地使用相同的网格模型和材质)的情况下，Unity会在运行时对于"}]},{"type":"text","value":"正在视野中的符合要求的所有对象使用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Constant Buffer"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_5","rel":["nofollow"]},"children":[{"type":"text","value":"5]"}]},{"type":"text","value":"将其位置、缩放、uv偏移、"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"lightmapindex"}]},{"type":"text","value":"等相关信息保存在显存中的**“统一/常量缓冲器”"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"["}]},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_6","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"6]"}]}]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"中，然后从中抽取一个对象作为实例送入渲染流程，当在执行DrawCall操作后，从显存中取出实例的部分共享信息与从GPU常量缓冲器中取出对应对象的相关信息一并传递到下一渲染阶段，与此同时，不同的着色器阶段可以从缓存区中直接获取到需要的常量，不用设置两次常量。比起以上两种批处理，GPU Instancing可以"}]},{"type":"text","value":"规避合并Mesh导致的内存与性能上升**的问题，但是由于场景中所有符合该合批条件的渲染物体的信息每帧都要被重新创建，放入“统一/常量缓冲区”中，而碍于缓存区的大小限制，每一个Constant Buffer的大小要严格限制（不得大于64k）。详细请阅读："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/34499251","rel":["nofollow"]},"children":[{"type":"text","value":"Testplus：U3D优化批处理-GPU Instancing了解一下zhuanlan.zhihu.com"},{"type":"element","tag":"img","props":{"alt":"图标","src":"/images/2020-10-23-unity-optimizing-gpu/v2-b06a0dbdf07544a4d0687a8917611afd_180x120.jpg"},"children":[]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"无法参与加速情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缩放为负值的情况下，会不参与加速。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"代码动态改变材质变量后不算同一个材质，会不参与加速，但可以通过将颜色变化等变量加入常量缓冲器中实现["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_7","rel":["nofollow"]},"children":[{"type":"text","value":"7]"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"受限于常量缓冲区在不同设备上的大小的上限，移动端支持的个数可能较低。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"只支持一盏实时光，要在多个光源的情况下使用实例化，我们别无选择，只能切换到延迟渲染路径。为了能够让这套机制运作起来，请将所需的编译器指令添加到我们着色器的延迟渲染通道中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-5c97567b099e9d98ca9d957282b1922e_720w.jpg"},"children":[]},{"type":"text","value":"当在多个光源开启GPU Instancing"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"批处理中断情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个批次超过125个物体（受限于常量缓冲区在不同设备上的大小的上限，移动端数量有浮动）的时候会新建另一个加速流程。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物体如果都符合条件会优先参与静态批处理，然后才到GPU Instancing，假如物体符合前者，此次加速都会被打断。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"流程原理"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-0dde54b930bef9c768c10d3c79126e16_720w.jpg"},"children":[]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"srp-batcher8"},"children":[{"type":"text","value":"SRP Batcher["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_8","rel":["nofollow"]},"children":[{"type":"text","value":"8]"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"定义"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在使用LWRP或者HWRP时，开启SRP Batcher的情况下，只要物体的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Shader中变体"}]},{"type":"text","value":"一致，就可以启用SRP Batcher加速。它与上文GPU Instancing实现的原理相近，Unity会在运行时对于正在视野中的符合要求的所有对象使用**“Per Object” GPU BUFFER（一个独立的Buffer）** 将其位置、缩放、uv偏移、"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"lightmapindex"}]},{"type":"text","value":"等相关信息保存在GPU内存中，同时也会将正在视野中的符合要求的所有对象使用"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Constant Buffer"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_5","rel":["nofollow"]},"children":[{"type":"text","value":"5]"}]},{"type":"text","value":"将材质信息保存在保存在显存中的**“统一/常量缓冲器”"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"["}]},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_6","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"6]"}]}]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"中。与GPU Instancing相比，因为数据不再每帧被重新创建，而且需要保存进“统一/常量缓冲区”的数据排除了各自的位置、缩放、uv偏移、"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"lightmapindex"}]}]},{"type":"text","value":"等相关信息，所以缓冲区内有更多的空间可以动态地**存储场景中所有渲染物体的材质信息。由于数据不再每帧被重新创建，而是动态更新，所以SRP Batcher的本质并不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-7b93309c00f2866639a2f7c529495608_720w.jpg"},"children":[]},{"type":"text","value":"因为不用重新创建Constant Buffer，所以本质上SRP Batcher不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"无法参与加速情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对象不可以是粒子或蒙皮网格。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Shader中"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"变体"}]},{"type":"text","value":"不一致，如下图两个"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"相同Shader"}]},{"type":"text","value":"的材质，但是因为Surface Options不一致，导致"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"变体不一样"}]},{"type":"text","value":"而无法合并。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-b0599861b3304d19979816413cb13a43_720w.jpg"},"children":[]},{"type":"text","value":"变体不同的不同材质"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"批处理中断情况"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"位置不相邻且中间夹杂着"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不同Shader"}]},{"type":"text","value":"，或者"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不同变体"}]},{"type":"text","value":"的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"流程原理"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-23-unity-optimizing-gpu/v2-6125b513800939912bb07853ae0a1f90_720w.jpg"},"children":[]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"_2020年2月13日-更新-更改对统一常量缓冲器的描述对srp-batcher与gpu-instancing的实现原理进行了比较大的修改"},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2020年2月13日-更新： 更改对”统一/常量缓冲器“的描述，对SRP Batcher与GPU Instancing的实现原理进行了比较大的修改。"}]}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"^ ^ 以上只是我工作中的一些小总结"}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"有什么不正确的地方可以在评论告诉我"}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"我的微信号是：sam2b2b"}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"有想一起进步的小伙伴可以加微信逛逛圈"}]}]}]},{"type":"element","tag":"h2","props":{"id":"参考"},"children":[{"type":"text","value":"参考"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_1_0","rel":["nofollow"]},"children":[{"type":"text","value":"^"}]},{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/community/detail/114323","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/community/detail/114323"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_2_0","rel":["nofollow"]},"children":[{"type":"text","value":"^"}]},{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/","rel":["nofollow"]},"children":[{"type":"text","value":"https://forum.unity.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_3_0","rel":["nofollow"]},"children":[{"type":"text","value":"^"}]},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Manual/DrawCallBatching.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.unity3d.com/Manual/DrawCallBatching.html"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_4_0","rel":["nofollow"]},"children":[{"type":"text","value":"^"}]},{"type":"element","tag":"a","props":{"href":"https://gameinstitute.qq.com/community/detail/114323","rel":["nofollow"]},"children":[{"type":"text","value":"https://gameinstitute.qq.com/community/detail/114323"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"^"},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_5_0","rel":["nofollow"]},"children":[{"type":"text","value":"a"}]},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_5_1","rel":["nofollow"]},"children":[{"type":"text","value":"b"}]},{"type":"text","value":"Constant Buffer "},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/35830868","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/35830868"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"^"},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_6_0","rel":["nofollow"]},"children":[{"type":"text","value":"a"}]},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_6_1","rel":["nofollow"]},"children":[{"type":"text","value":"b"}]},{"type":"text","value":"unity将常量存储在4M的缓冲池里，并每帧循环池（这个池子被绑定到GPU上，可以在截帧工具比如XCode或者Snapdragon上看到）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_7_0","rel":["nofollow"]},"children":[{"type":"text","value":"^"}]},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/lzhq1982/article/details/88119283","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/lzhq1982/article/details/88119283"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/98642798#ref_8_0","rel":["nofollow"]},"children":[{"type":"text","value":"^"}]},{"type":"text","value":"SRP Batcher 官方文档： "},{"type":"element","tag":"a","props":{"href":"https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw","rel":["nofollow"]},"children":[{"type":"text","value":"https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"静态批处理1","depth":2,"text":"静态批处理[1]"},{"id":"动态批处理4","depth":2,"text":"动态批处理[4]"},{"id":"gpu-instancing","depth":2,"text":"GPU Instancing"},{"id":"srp-batcher8","depth":2,"text":"SRP Batcher[8]"},{"id":"_2020年2月13日-更新-更改对统一常量缓冲器的描述对srp-batcher与gpu-instancing的实现原理进行了比较大的修改","depth":2,"text":"2020年2月13日-更新： 更改对”统一/常量缓冲器“的描述，对SRP Batcher与GPU Instancing的实现原理进行了比较大的修改。"},{"id":"参考","depth":2,"text":"参考"}]}},"_type":"markdown","_id":"content:unity:2020-10-23-unity-optimizing-gpu.md","_source":"content","_file":"unity/2020-10-23-unity-optimizing-gpu.md","_extension":"md","date":"2020-10-23"},{"_path":"/unity/2020-10-24-screentoworldpoint","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity的ScreenToWorldPoint","description":"在使用Camera.main.ScreenToWorldPoint(Input.mousePosition))的時候，有時候會發現取得的是Camera的座標而不是滑鼠的座標。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在使用Camera.main.ScreenToWorldPoint(Input.mousePosition))的時候，有時候會發現取得的是Camera的座標而不是滑鼠的座標。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因為事實上是需要提供Z參數的\nCamera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, Z));\n　　Z代表的是Depth，因此如果Z=0的話就會是Camera的transform position了，因為此時nearClip趨近於Camera，不論你畫面中哪個點都會趨近於Camera的position"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"自己做的參考圖。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://ref.gamer.com.tw/redir.php?url=http%3A%2F%2F3.bp.blogspot.com%2F-R7XPjFKkYxw%2FU2VzYO6WanI%2FAAAAAAAAAqs%2FFYk7Y6UuSTU%2Fs1600%2F1.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-10-24-ScreenToWorldPoint/1.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以Perspective攝影機來看，當我用ScreenToWorldPoint(Input.mousePosition)想要來取得目前滑鼠座標在世界座標的位置的時候，可以看到當設定的Ｚ值不同，不只是取得的Ｚ座標不同連ＸＹ的座標都會不同（上圖的紅點位置，在遊戲視窗中是相同的左上角）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以假設Ｚ值趨近於0的時候會怎樣，也就是該點座標會趨近於Camera的座標，因此當你沒有設定Ｚ值，而Ｚ值為0的時候，不管你滑鼠在哪都只會取得攝影機的座標。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解決辦法：在Perspective攝影機的狀態下Ｚ值不要為0，或是使用Camera.main.nearClipPlane來設定最短的Clip位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而Orthographic的攝影機呢，反而沒有這個問題，當Ｚ值設定為0的時候還是可以有相對正確的ＸＹ座標。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-10-24-ScreenToWorldPoint.md","_source":"content","_file":"unity/2020-10-24-ScreenToWorldPoint.md","_extension":"md","date":"2020-10-24"},{"_path":"/unity/2020-10-24-unity-urp-performance","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"URP性能测试","description":"2d下z轴对性能的影响\n多个摄像机对性能的影响","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2d下z轴对性能的影响\n多个摄像机对性能的影响"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sprites-default和Unlit差不多\n背景图像不要使用lit,太影响性能\n大面积的图像不要使用lit"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"建立spriteatlas测试优化\n为角色建立动态纹理"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-10-24-unity-urp-performance.md","_source":"content","_file":"unity/2020-10-24-unity-urp-performance.md","_extension":"md","date":"2020-10-24"},{"_path":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"如何使用Unity ECS打造Reactive System？","description":"1. 使用SystemStateComponent原理所谓State，含义是只能被手动删除的Component，在删除Entity后，依然留下做一些殿后工作，只有被指名要求删除的时候才会被删除。这种特性就让我们可以通过不同的Query去获得结构变化的消息。栗子假设我们有一个Entity，身上有两个组件，A：IComponentData 与 B: ISystemStateComponentData当我们添加A组件的时候，通过Filter{ 有A无B }，我们可以在别处得知这个Entity何时被添加。在添加后手动加入B组件。当我们删除Entity，或者移除A组件的时候，通过Filter { 有B无","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"_1-使用systemstatecomponent"},"children":[{"type":"text","value":"1. 使用SystemStateComponent"}]},{"type":"element","tag":"h3","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓State，含义是只能被手动删除的Component，在删除Entity后，依然留下做一些殿后工作，只有被指名要求删除的时候才会被删除。这种特性就让我们可以通过不同的Query去获得结构变化的消息。"}]},{"type":"element","tag":"h3","props":{"id":"栗子"},"children":[{"type":"text","value":"栗子"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"假设我们有一个Entity，身上有两个组件，A：IComponentData 与 B: ISystemStateComponentData"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当我们添加A组件的时候，通过Filter{ 有A无B }，我们可以在别处得知这个Entity何时被添加。在添加后手动加入B组件。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当我们删除Entity，或者移除A组件的时候，通过Filter { 有B无A }，同理可得知何时这个Entity被移除或是A组件被移除。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更具体的实现可以在查看官方对于ParentSystem的设计。"}]},{"type":"element","tag":"h3","props":{"id":"_2-查询componentversion"},"children":[{"type":"text","value":"2. 查询ComponentVersion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当出现某Component相关的结构性变化的时候，该Component的版本就会+1 。"}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.GetComponentVersion()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.GetComponentVersion()\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"数据变化"},"children":[{"type":"text","value":"数据变化"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顾名思义。方法有三种。"}]},{"type":"element","tag":"h3","props":{"id":"_1-chunk检查"},"children":[{"type":"text","value":"1. Chunk检查"}]},{"type":"element","tag":"h3","props":{"id":"原理-1"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"pre","props":{"code":"chunk.DidChange(ArchetypeChunkComponentType, version)\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"chunk.DidChange(ArchetypeChunkComponentType, version)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查看其内部实现"}]},{"type":"element","tag":"pre","props":{"code":"if ( ComponentVer > LastSystemVersion ) \n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if ( ComponentVer > LastSystemVersion ) \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"什么意思呢？"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GlobalSystemVersion为记录一个世界所有系统更新信息的版本号。在每一个系统更新"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"之前"}]},{"type":"text","value":"，GSV++。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"LastSystemVersion为系统记录自己的版本号。在某系统更新"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"之后"}]},{"type":"text","value":"，它会保存GSV，含义是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"上次"}]},{"type":"text","value":"运行时的版本号，直到下次某系统更新之后，它的版本号不会更改"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一种Component，在System申请写入权限的时候，都会记录该System的LSV 获取方式为chunk.GetArch"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，if ( ComponentVer > LSV ) 就说明该Component被修改了（有系统获得了写入权限）。翻译成大白话，就是Component是否在提供的版本号之后的时间被更新？在当前系统请求LSV的结果是上一帧该系统的版本号，如果Component被写入时的版本号大于该系统上一帧的版本号，就说明Component在此时至上一帧的某个时间点被写入。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"由于这个Component只有在遍历的时候申请写入权限时才会记住版本号，因此EntityManager手动更新信息是不会被记录的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这个信息时效性只有一帧，从上次该系统更新后到这次更新后的一帧，因此在这次更新中，修改Component后查询是否改变，答案是True，反之为False。"}]}]},{"type":"element","tag":"h3","props":{"id":"举例"},"children":[{"type":"text","value":"举例"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"系统的更新顺序为A->B->C->A"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"那么GSV ：0 -> 1 -> 2 -> 3，每个系统更新之前+1"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当数据在B系统被写入，Component就记住了B的GSV = 1"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当我们在第二次轮到A系统的时候监测是否Component被改动，DidChange自动使用A系统上次的GSV记录 LSV = 0 与 Component记录的信息CV = 1做对比，发现CV > LSV，得知信息已经被更改了，返回True。"}]}]},{"type":"element","tag":"h3","props":{"id":"api"},"children":[{"type":"text","value":"API"}]},{"type":"element","tag":"pre","props":{"code":"chunk.DidChange(InputAType, LastSystemVersion);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"chunk.DidChange(InputAType, LastSystemVersion);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意LSV应从EntityManager.LastSystemVersion取得，并传入Job"}]},{"type":"element","tag":"pre","props":{"code":"[BurstCompile]\nstruct UpdateJob : IJobChunk\n{\n   public ArchetypeChunkComponentType<InputA> InputAType;\n   public ArchetypeChunkComponentType<InputB> InputBType;\n   [ReadOnly] public ArchetypeChunkComponentType<Output> OutputType;\n   public uint LastSystemVersion;\n\n   public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n   {\n       var inputAChanged = chunk.DidChange(InputAType, LastSystemVersion);\n       var inputBChanged = chunk.DidChange(InputBType, LastSystemVersion);\n       if (!(inputAChanged || inputBChanged))\n           return;\n      //...\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[BurstCompile]\nstruct UpdateJob : IJobChunk\n{\n   public ArchetypeChunkComponentType<InputA> InputAType;\n   public ArchetypeChunkComponentType<InputB> InputBType;\n   [ReadOnly] public ArchetypeChunkComponentType<Output> OutputType;\n   public uint LastSystemVersion;\n\n   public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n   {\n       var inputAChanged = chunk.DidChange(InputAType, LastSystemVersion);\n       var inputBChanged = chunk.DidChange(InputBType, LastSystemVersion);\n       if (!(inputAChanged || inputBChanged))\n           return;\n      //...\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"_2-query自动检查"},"children":[{"type":"text","value":"2. Query自动检查"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在声明Query的时候，特别注明"}]},{"type":"element","tag":"pre","props":{"code":"m_Group.SetFilterChanged(new ComponentType{ typeof(InputA), typeof(InputB)});\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"m_Group.SetFilterChanged(new ComponentType{ typeof(InputA), typeof(InputB)});\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样Query就会把没被修改的ComponentType排除在外。注意，这种检查是Component层级，而不是单个Entity层级的。"}]},{"type":"element","tag":"pre","props":{"code":"EntityQuery m_Group;\nprotected override void OnCreate()\n{\n   m_Group = GetEntityQuery(typeof(Output), \n                               ComponentType.ReadOnly<InputA>(), \n                               ComponentType.ReadOnly<InputB>());\n   m_Group.SetFilterChanged(new ComponentType{ typeof(InputA), typeof(InputB)});\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityQuery m_Group;\nprotected override void OnCreate()\n{\n   m_Group = GetEntityQuery(typeof(Output), \n                               ComponentType.ReadOnly<InputA>(), \n                               ComponentType.ReadOnly<InputB>());\n   m_Group.SetFilterChanged(new ComponentType{ typeof(InputA), typeof(InputB)});\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"_3-ijobforeach中使用-changefilter"},"children":[{"type":"text","value":"3. IJobForEach中使用 [ChangeFilter]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与Query的排除效果类似。"}]},{"type":"element","tag":"h3","props":{"id":"示例"},"children":[{"type":"text","value":"示例"}]},{"type":"element","tag":"pre","props":{"code":"public struct ProcessTendency : IJobForEachWithEntity<HumanState, HumanStock>\n{\n    public void Execute(Entity entity, int index, [ChangedFilter] ref State state)\n    {\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public struct ProcessTendency : IJobForEachWithEntity<HumanState, HumanStock>\n{\n    public void Execute(Entity entity, int index, [ChangedFilter] ref State state)\n    {\n"}]}]},{"type":"element","tag":"h2","props":{"id":"best-practice"},"children":[{"type":"text","value":"Best Practice"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对自己的系统做了一些单元测试后，我觉得有几点应该记录下来。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果要做一套响应式系统循环触发，慎用EntityManager获取信息。因为EntityManager的Get系列API会直接获取写入权限。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Job有延迟，因此单元测试的时候，如果涉及Version，应该做一些操作“等待”正确的版本号刷新，比如Debug.Log()。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GetEntityQuery会在系统注册，因此在Query里SetFilterChanged即可，毋需在Execute()中再声明一遍。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在主线程获取DynamicBuffer的长度时，Query与EM都不能做到以只读方式做到。因此正确的做法是"}]}]},{"type":"element","tag":"pre","props":{"code":"var query    = GetEntityQuery(ComponentType.ReadOnly<T>());\nvar entities  = query.ToEntityArray(Allocator.TempJob);\nvar entity    = entities[0];\nvar length   = EntityManager.GetChunk(entity).GetBufferAccessor(GetArchetypeChunkBufferType<Tendency>(true))[0].Length;\nentities.Dispose();\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var query    = GetEntityQuery(ComponentType.ReadOnly<T>());\nvar entities  = query.ToEntityArray(Allocator.TempJob);\nvar entity    = entities[0];\nvar length   = EntityManager.GetChunk(entity).GetBufferAccessor(GetArchetypeChunkBufferType<Tendency>(true))[0].Length;\nentities.Dispose();\n"}]}]},{"type":"element","tag":"h2","props":{"id":"reference"},"children":[{"type":"text","value":"Reference"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//gametorrahod.com/designing-an-efficient-system-with-version-numbers/","rel":["nofollow"]},"children":[{"type":"text","value":"https://gametorrahod.com/designing-an-efficient-system-with-version-numbers/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.entities%400.0/manual/chunk_iteration_job.html","rel":["nofollow"]},"children":[{"type":"text","value":"Using IJobChunk | Package Manager UI website"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://medium.com/@icex33/coping-with-change-in-unity3d-ecs-45422fff8dda#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImQ5NDZiMTM3NzM3Yjk3MzczOGU1Mjg2YzIwOGI2NmU3YTM5ZWU3YzEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2MDUxMTkzMDksImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExNTYwNDIyOTcxMDAwNDczMDgwOCIsImVtYWlsIjoiemhlcGFtYUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiMjE2Mjk2MDM1ODM0LWsxazZxZTA2MHMydHAyYTJqYW00bGpkY21zMDBzdHRnLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwibmFtZSI6IuadjuS5neS7mSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vLXlfSnhUTXJkQWk4L0FBQUFBQUFBQUFJL0FBQUFBQUFBQUFBL0FNWnV1Y25xLVNRSGVVR1FRUENfUjJ0Zk93RGh2QzRHbHcvczk2LWMvcGhvdG8uanBnIiwiZ2l2ZW5fbmFtZSI6IuS5neS7mSIsImZhbWlseV9uYW1lIjoi5p2OIiwiaWF0IjoxNjA1MTE5NjA5LCJleHAiOjE2MDUxMjMyMDksImp0aSI6IjQyM2E3NTM3NmE0YTZkNzI3ODgzYmYyZDIyMDljMGNjZTg2NDRjMTUifQ.eicZfv00n72yCqIDVFxy8XOMlWkcjychu8aPN6q9Cj61MvcJfIAAVgdREk1J5t4dpTxqN10FOZnfFxRZBnkbHFjjVLI0Lu1lYr7bE5NhxdRnjaNwbs-WQbuMHAKBeMvdKzIIeqRAswuHNlwtd_ATfON4V0v3aobOlVPOFUz3mgstb5cFhoH2oJIGTfnYj108-1_IVJRUoTo80Eii2gTEsC4frSGweQNZlu2XMnfsfRz3724NqinN7csfXXQ9zZ8vh29zHBgEUYnVh7JNOONr8A9wQY9RxI1v73HEC2YNFekuB87qCjGRpgUKGGFBaUwClpOifr9W-Z30U3t_TSgENw","rel":["nofollow"]},"children":[{"type":"text","value":"Coping with Change in Unity3D ECS | by Maxim Zaks | Medium"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.effectiveunity.com/ecs/06-how-to-build-reactive-systems-with-unity-ecs-part-1/","rel":["nofollow"]},"children":[{"type":"text","value":"How to build reactive systems with Unity ECS: Part 1 • Effective Unity"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.effectiveunity.com/ecs/07-how-to-build-reactive-systems-with-unity-ecs-part-2/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.effectiveunity.com/ecs/07-how-to-build-reactive-systems-with-unity-ecs-part-2/"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1-使用systemstatecomponent","depth":3,"text":"1. 使用SystemStateComponent"},{"id":"原理","depth":3,"text":"原理"},{"id":"栗子","depth":3,"text":"栗子"},{"id":"_2-查询componentversion","depth":3,"text":"2. 查询ComponentVersion"},{"id":"数据变化","depth":2,"text":"数据变化","children":[{"id":"_1-chunk检查","depth":3,"text":"1. Chunk检查"},{"id":"原理-1","depth":3,"text":"原理"},{"id":"举例","depth":3,"text":"举例"},{"id":"api","depth":3,"text":"API"},{"id":"_2-query自动检查","depth":3,"text":"2. Query自动检查"},{"id":"_3-ijobforeach中使用-changefilter","depth":3,"text":"3. IJobForEach中使用 [ChangeFilter]"},{"id":"示例","depth":3,"text":"示例"}]},{"id":"best-practice","depth":2,"text":"Best Practice"},{"id":"reference","depth":2,"text":"Reference"}]}},"_type":"markdown","_id":"content:unity:2020-11-11-how-to-build-reactive-systems-with-unity-ecs.md","_source":"content","_file":"unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs.md","_extension":"md","date":"2020-11-11"},{"_path":"/unity/2020-11-12-sprite-image-diff","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity中Sprite和UI Image的区别","description":"coffeecato写在前面：\n本文确实不错，作者用以说明自动生成网格的示图非常具有代表性，从drawcall的生成过程分析性能开销的重点，引出了overdraw和达到GPU像素填充率限制的原因，从中也可以看出作者对这个主题的理解颇有深度。查看作者的个人自述，居然是个2012年毕业的小伙子，后生可畏啊！翻译本文对自己也是个考验。\n英文水平捉急，如果错误请多多指正。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"coffeecato写在前面：\n本文确实不错，作者用以说明自动生成网格的示图非常具有代表性，从drawcall的生成过程分析性能开销的重点，引出了overdraw和达到GPU像素填充率限制的原因，从中也可以看出作者对这个主题的理解颇有深度。查看作者的个人自述，居然是个2012年毕业的小伙子，后生可畏啊！翻译本文对自己也是个考验。\n英文水平捉急，如果错误请多多指正。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"原文："}]},{"type":"element","tag":"a","props":{"href":"https://rubentorresbonet.wordpress.com/2016/05/26/unity-sprites-spriterenderer-vs-canvasrenderer-ui-image/","rel":["nofollow"]},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"UNITY SPRITES: SPRITERENDERER VS. CANVASRENDERER (UI IMAGE)"}]}]},{"type":"text","value":"\n翻译已征得原作者同意：\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171116103038856"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当在一个公司项目工作时，我被问到关于sprites(SpriteRenderer)和UI image(CanvasRenderer)的区别。我没找到多少相关的信息，所以我决定在公司准备一场介绍来帮助大家把两者的区别搞清楚。本文中你将会看到一个比当时的介绍更完整的版本。运行环境是Unity5.3.4f1."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sprites本质上是半透明texture，其中texture是在导入时被设置导入为sprites的。它们不是直接被应用于meshes,而是会应用于长方形/多边形（最后，它们始终是meshes，因为没有那么大的区别）。Sprites就是被渲染到2d/3d场景或者其他界面中的图片."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.用法"}]},{"type":"text","value":"\n在Unity中使用sprites很简单。只需将目标图片移动到assets文件夹下然后点击打开inspector settings.将texture type改为sprite(2D and UI),如下图：\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114233841299"},"children":[]},{"type":"text","value":"\n现在你该决定将图片当成sprite使用还是作为UI Image.但是如果考虑到渲染，你可能并不确定你想要使用哪种方式。我们将会在下一节描述两种方式间的区别；现在我们大概描述一下如何在Unity中创建它们。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你想使用SpriteRenderer,将sprite从Project窗口移动到Hierarchy窗口或者Scene窗口。成功创建后的窗口应该像这样：\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114233856654"},"children":[]},{"type":"text","value":"\n如果你想创建UI Image,在Hierarchy中右键然后create new UI–>Image.这个控件需要canvas,如果没有canvas会自动创建一个。最后，你将看到：\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114233911906"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2.对比：SpriteRenderer vs CanvasRenderer"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Hierarchy窗口,你可以把sprites随便放在哪。然而，UI Images不得不放在canvas下面。你可以通过transform移动其他obejcts那样移动sprites,但是images使用RectTransform来在界面系统中移动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用默认材质时，Sprites是在”Queue” = “Transparent” “RenderType” = “Geometry”(原文： transparent geometry queue)模式下渲染的。UI Images也是在这种模式下渲染的，除非你使用了Overlay 模式渲染（coffeecato补充：Canvas的Render Mode）,这种情况下它将会通过Canvas.RenderOverlay渲染。你可能会猜到，这样在移动设备上的开销很大。我们稍后会讨论到。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sprites和images的一个最重要的区别在于sprites支持网格的自动构造，而UI Image的网格始终由矩形构成。构造网格的原因将会在下一节讲到；我们将会看到它的重要性及它对性能的重大影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，两种方式都可以通过使用sprite atlases来减少draw calls."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的例子将会帮助看到二者之间的区别：\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114233924452"},"children":[]},{"type":"text","value":"\n上图中可以看到，UI Image创造了一个紧密的矩形来包裹sprite,而SpriteRenderer创造了一个能更好匹配将要渲染的sprite的网格。看看另一个例子：\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114233938619"},"children":[]},{"type":"text","value":"\n同样的情况出现这个例子中。但是网格这次看起来更复杂了，为什么呢？Unity尝试去为sprites构造最佳的网格来避免引入太多的多边形。可能有人会说这样的权衡到底是利是弊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们导入一张拥有孤岛（coffeecato补充：原文是islands）的png，一张图片包含被透明区域分隔开的图形会发生什么情况？\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114233951951"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图中我们看到的情况很有意思，SpriteRenderer创造了两个子网格，一个对应一个孤岛；然后UI Image只是通过扩展矩形来覆盖整个图片。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3.性能"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可能会猜到，上面例子显示的不同处理方式可能会导致性能的差异。当渲染很多对象时，差别会更明显（比如地形中的草，或者粒子特效）。下面我们来分析一下其中的原因。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当渲染texture时，设置好顶点，索引，uv坐标，纹理数据和shader参数，然后向GPU发送数据，这个过程就是著名的draw call.随后，在图片最终显示之前，一些乱七八糟的事情在GPU发生。一个简单的渲染管线通常包括："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CPU 发送一个draw命令到GPU"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GPU获取到绘制所需的所有信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"几何图形通过顶点着色器和光栅化被转化为像素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个像素通过片元着色器被转化然后被写入到帧缓存一次或数次"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当一帧结束时，图形会显示在你的显示器上"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回到主题，SpriteRenderer和UI Image之间的区别是什么？显而易见，sprites的开销更大，因为它的几何数据更复杂。但是如果我告诉你顶点操作通常比片元操作开销小的多呢？尤其对于移动设备和半透明对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在很多引擎包括Unity中，半透明材质是由后向前渲染的。那意味着，最远的物体（从camera出发）最先渲染，这样alpha混合操作才能像预期那样工作。对于不透明材质，渲染正好反过来这样便于我们剔除不可见物体。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"像素着色器会被渲染sprite中的每一个像素都执行，因此，当存在较大的图形时（相对屏幕尺寸），片元着色器将会在很多像素上执行。问题在于，当透明物体在视锥体内时没有很有效的方法将它们剔除，因此你将会渲染所有的半透明物体即使其中的大多数最终都不可见。所以你会发现同一个像素会渲染多次，在帧缓存中也会重写多次。这个问题通常被称为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"overdraw"}]},{"type":"text","value":".同样地，由于这种现象带来了"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"内存带宽"}]},{"type":"text","value":"的浪费，会很快达到GPU "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"像素填充率"}]},{"type":"text","value":"的限制，这种情况是移动设备应当极力避免的。这就是问题的关键。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你确实理解了上面一段，你将会弄明白SpriteRenderer和CanvasRenderer是多么的不同。前者通过构造网格清除了不必要的透明像素（因此，避免了执行开销巨大的片元着色器，从而避免了overdraw），然而UI Image创建了一个简单的网格很可能会引起很多overdraw。你需要在复杂的几何图形和更多的片操作之间做一个权衡。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你应该会想到使用sprite atlases，因为spritest通常数量很大同时尺寸很小。这会导致绘制sprites有很多drawcall.同样地，对于较大的图形，图形压缩也是不错的方法。\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114234009365"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以通过Atlas Packer很方便的创建sprite atlas.同时，有时自动构造的网格性能上并不好你也无法控制它，因此你可能会使用一些性能更好的插件比如ShoeBox 或者 TexturePacker.\n"},{"type":"element","tag":"img","props":{"alt":"这里写图片描述","src":"/images/2020-11-12-sprite-image-diff/20171114234059641"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4.结论"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当下次再遇到sprites时，不妨考虑下面的建议："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果sprites的数量不多，想用什么用什么。如果拥有上百个sprites，重新读读本文。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用profiler和frame debugger来搞清楚发生的状况。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"避免使用透明，尽量使用不透明的物体替代透明物体。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"避免在屏幕上渲染尺寸较大的sprites，这会引起更多的overdraw。你可以通过在Scene View中选择rendering mode为Overdraw来查看overdraw的情况。这对于粒子特效很关键。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"选择更复杂的几何体而不是更多的像素，尤其对于移动设备。可以通过选择Scene View中的Shading Mode为shaded wireframe来查看。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果需要对界面进行较多的位置操作（比如content fitter, vertical groups等）选择UI Images."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"减少渲染区域的分辨率来查看性能有没有实质的提升，通过这种方法来判断是否达到了像素填充率的限制。"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-12-sprite-image-diff.md","_source":"content","_file":"unity/2020-11-12-sprite-image-diff.md","_extension":"md","date":"2020-11-12"},{"_path":"/unity/2020-11-13-simple-save","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"简单保存工具","description":"using Newtonsoft.Json;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DotHass.Unity\n{\n    public class SaveService : ISaveService\n    {\n        // IMPORTANT: Make sure to change this key for each project you use thi","body":{"type":"root","children":[{"type":"element","tag":"pre","props":{"code":"using Newtonsoft.Json;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DotHass.Unity\n{\n    public class SaveService : ISaveService\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        public string Key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26e\";\n\n        public bool Encrypt = false;\n\n        public SaveService()\n        {\n            // Create a new encryption provider\n            SimpleEncryption.provider = new RijndaelManaged\n            {\n                // Get the bytes from the supplied string key and use it as the provider's key\n                Key = Encoding.ASCII.GetBytes(Key),\n\n                // Ensure that the same data is always encrypted the same way when used with the same key\n                Mode = CipherMode.ECB\n            };\n        }\n\n        protected Task DeleteAsync(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            this.Delete(fullPath);\n            return Task.CompletedTask;\n        }\n\n        protected Task SaveAsync(string key, object value)\n        {\n           \n\n            var fullPath = this.GetFullPath(key);\n            var content = JsonConvert.SerializeObject(value);\n\n            return WriteAsync(fullPath, content);\n        }\n\n        protected async Task<T> LoadAsync<T>(string key, T defaultValue)\n        {\n            var fullPath = this.GetFullPath(key);\n\n            if (this.Exists(fullPath) == false)\n            {\n                return defaultValue;\n            }\n            return await LoadAsync<T>(key);\n        }\n\n        private async Task<T> LoadAsync<T>(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            var content = await this.ReadAsync(fullPath);\n            return JsonConvert.DeserializeObject<T>(content);\n        }\n\n        protected string GetFullPath(string key)\n        {\n            return Path.Combine(Application.persistentDataPath, key.ToUpper());\n        }\n\n        public bool Exists(string fullPath)\n        {\n            return File.Exists(fullPath);\n        }\n\n        public void Delete(string fullPath)\n        {\n            if (File.Exists(fullPath))\n            {\n                File.Delete(fullPath);\n            }\n            else if (Directory.Exists(fullPath))\n            {\n                Directory.Delete(fullPath, true);\n            }\n        }\n\n        public async Task WriteAsync(string fullPath, string content)\n        {\n            if (this.Encrypt == true)\n            {\n                content = SimpleEncryption.EncryptString(content);\n            }\n            using (StreamWriter sw = new StreamWriter(fullPath, false, Encoding.UTF8))\n            {\n                //覆盖该文件\n                await sw.WriteAsync(content);\n            }\n        }\n\n        public async Task<string> ReadAsync(string fullPath)\n        {\n            using (StreamReader sw = new StreamReader(fullPath, Encoding.UTF8))\n            {\n                var fetchedString = await sw.ReadToEndAsync();\n\n                if (this.Encrypt == true)\n                {\n                    fetchedString = SimpleEncryption.DecryptString(fetchedString);\n                }\n                return fetchedString;\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Newtonsoft.Json;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DotHass.Unity\n{\n    public class SaveService : ISaveService\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        public string Key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26e\";\n\n        public bool Encrypt = false;\n\n        public SaveService()\n        {\n            // Create a new encryption provider\n            SimpleEncryption.provider = new RijndaelManaged\n            {\n                // Get the bytes from the supplied string key and use it as the provider's key\n                Key = Encoding.ASCII.GetBytes(Key),\n\n                // Ensure that the same data is always encrypted the same way when used with the same key\n                Mode = CipherMode.ECB\n            };\n        }\n\n        protected Task DeleteAsync(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            this.Delete(fullPath);\n            return Task.CompletedTask;\n        }\n\n        protected Task SaveAsync(string key, object value)\n        {\n           \n\n            var fullPath = this.GetFullPath(key);\n            var content = JsonConvert.SerializeObject(value);\n\n            return WriteAsync(fullPath, content);\n        }\n\n        protected async Task<T> LoadAsync<T>(string key, T defaultValue)\n        {\n            var fullPath = this.GetFullPath(key);\n\n            if (this.Exists(fullPath) == false)\n            {\n                return defaultValue;\n            }\n            return await LoadAsync<T>(key);\n        }\n\n        private async Task<T> LoadAsync<T>(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            var content = await this.ReadAsync(fullPath);\n            return JsonConvert.DeserializeObject<T>(content);\n        }\n\n        protected string GetFullPath(string key)\n        {\n            return Path.Combine(Application.persistentDataPath, key.ToUpper());\n        }\n\n        public bool Exists(string fullPath)\n        {\n            return File.Exists(fullPath);\n        }\n\n        public void Delete(string fullPath)\n        {\n            if (File.Exists(fullPath))\n            {\n                File.Delete(fullPath);\n            }\n            else if (Directory.Exists(fullPath))\n            {\n                Directory.Delete(fullPath, true);\n            }\n        }\n\n        public async Task WriteAsync(string fullPath, string content)\n        {\n            if (this.Encrypt == true)\n            {\n                content = SimpleEncryption.EncryptString(content);\n            }\n            using (StreamWriter sw = new StreamWriter(fullPath, false, Encoding.UTF8))\n            {\n                //覆盖该文件\n                await sw.WriteAsync(content);\n            }\n        }\n\n        public async Task<string> ReadAsync(string fullPath)\n        {\n            using (StreamReader sw = new StreamReader(fullPath, Encoding.UTF8))\n            {\n                var fetchedString = await sw.ReadToEndAsync();\n\n                if (this.Encrypt == true)\n                {\n                    fetchedString = SimpleEncryption.DecryptString(fetchedString);\n                }\n                return fetchedString;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\n/// <summary>\n/// https://github.com/sabresaurus/PlayerPrefsEditor/blob/master/Runtime/SimpleEncryption.cs\n/// </summary>\nnamespace DotHass.Unity\n{\n    public static class SimpleEncryption\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        private static readonly string key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26C\";\n\n        // Cache the encryption provider\n        public static RijndaelManaged provider = null;\n\n        private static void SetupProvider()\n        {\n            // Create a new encryption provider\n            provider = new RijndaelManaged();\n\n            // Get the bytes from the supplied string key and use it as the provider's key\n            provider.Key = Encoding.ASCII.GetBytes(key);\n\n            // Ensure that the same data is always encrypted the same way when used with the same key\n            provider.Mode = CipherMode.ECB;\n        }\n\n        /// <summary>\n        /// Encrypts the specified string using the key stored in SimpleEncryption and returns the encrypted result\n        /// </summary>\n        public static string EncryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create an encryptor to encrypt the bytes\n            ICryptoTransform encryptor = provider.CreateEncryptor();\n\n            // Convert the source string into bytes to be encrypted\n            byte[] sourceBytes = Encoding.UTF8.GetBytes(sourceString);\n\n            // Encrypt the bytes using the encryptor we just created\n            byte[] outputBytes = encryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Convert the encrypted bytes into a Base 64 string, so we can safely represent them as a string and return\n            // that string\n            return Convert.ToBase64String(outputBytes);\n        }\n\n        /// <summary>\n        /// Decrypts the specified string from its specified encrypted value into the returned decrypted value using the\n        /// key stored in SimpleEncryption\n        /// </summary>\n        public static string DecryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create a decryptor to decrypt the encrypted bytes\n            ICryptoTransform decryptor = provider.CreateDecryptor();\n\n            // Convert the base 64 string representing the encrypted bytes back into an array of encrypted bytes\n            byte[] sourceBytes = Convert.FromBase64String(sourceString);\n\n            // Use the decryptor we just created to decrypt those bytes\n            byte[] outputBytes = decryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Turn the decrypted bytes back into the decrypted string and return it\n            return Encoding.UTF8.GetString(outputBytes);\n        }\n\n        /// <summary>\n        /// Encrypts the specified float value and returns an encrypted string\n        /// </summary>\n        public static string EncryptFloat(float value)\n        {\n            // Convert the float into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Encrypts the specified int value and returns an encrypted string\n        /// </summary>\n        public static string EncryptInt(int value)\n        {\n            // Convert the int value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// Encrypts the specified bool value and returns an encrypted string\n        /// </summary>\n        public static string EncryptBool(bool value)\n        {\n            // Convert the bool value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a float into the decrypted float\n        /// </summary>\n        public static float DecryptFloat(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a float and return it\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing an int into the decrypted int\n        /// </summary>\n        public static int DecryptInt(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a int and return it\n            return BitConverter.ToInt32(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a bool into the decrypted bool\n        /// </summary>\n        public static bool DecryptBool(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a bool and return it\n            return BitConverter.ToBoolean(bytes, 0);\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\n/// <summary>\n/// https://github.com/sabresaurus/PlayerPrefsEditor/blob/master/Runtime/SimpleEncryption.cs\n/// </summary>\nnamespace DotHass.Unity\n{\n    public static class SimpleEncryption\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        private static readonly string key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26C\";\n\n        // Cache the encryption provider\n        public static RijndaelManaged provider = null;\n\n        private static void SetupProvider()\n        {\n            // Create a new encryption provider\n            provider = new RijndaelManaged();\n\n            // Get the bytes from the supplied string key and use it as the provider's key\n            provider.Key = Encoding.ASCII.GetBytes(key);\n\n            // Ensure that the same data is always encrypted the same way when used with the same key\n            provider.Mode = CipherMode.ECB;\n        }\n\n        /// <summary>\n        /// Encrypts the specified string using the key stored in SimpleEncryption and returns the encrypted result\n        /// </summary>\n        public static string EncryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create an encryptor to encrypt the bytes\n            ICryptoTransform encryptor = provider.CreateEncryptor();\n\n            // Convert the source string into bytes to be encrypted\n            byte[] sourceBytes = Encoding.UTF8.GetBytes(sourceString);\n\n            // Encrypt the bytes using the encryptor we just created\n            byte[] outputBytes = encryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Convert the encrypted bytes into a Base 64 string, so we can safely represent them as a string and return\n            // that string\n            return Convert.ToBase64String(outputBytes);\n        }\n\n        /// <summary>\n        /// Decrypts the specified string from its specified encrypted value into the returned decrypted value using the\n        /// key stored in SimpleEncryption\n        /// </summary>\n        public static string DecryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create a decryptor to decrypt the encrypted bytes\n            ICryptoTransform decryptor = provider.CreateDecryptor();\n\n            // Convert the base 64 string representing the encrypted bytes back into an array of encrypted bytes\n            byte[] sourceBytes = Convert.FromBase64String(sourceString);\n\n            // Use the decryptor we just created to decrypt those bytes\n            byte[] outputBytes = decryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Turn the decrypted bytes back into the decrypted string and return it\n            return Encoding.UTF8.GetString(outputBytes);\n        }\n\n        /// <summary>\n        /// Encrypts the specified float value and returns an encrypted string\n        /// </summary>\n        public static string EncryptFloat(float value)\n        {\n            // Convert the float into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Encrypts the specified int value and returns an encrypted string\n        /// </summary>\n        public static string EncryptInt(int value)\n        {\n            // Convert the int value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// Encrypts the specified bool value and returns an encrypted string\n        /// </summary>\n        public static string EncryptBool(bool value)\n        {\n            // Convert the bool value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a float into the decrypted float\n        /// </summary>\n        public static float DecryptFloat(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a float and return it\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing an int into the decrypted int\n        /// </summary>\n        public static int DecryptInt(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a int and return it\n            return BitConverter.ToInt32(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a bool into the decrypted bool\n        /// </summary>\n        public static bool DecryptBool(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a bool and return it\n            return BitConverter.ToBoolean(bytes, 0);\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-13-simple-save.md","_source":"content","_file":"unity/2020-11-13-simple-save.md","_extension":"md","date":"2020-11-13"},{"_path":"/unity/2020-11-14-netcode","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"2020 11 14 Netcode","description":"We do not have a PVS (potential visibility set) system in place yet, but we do have distance based importance scaling which mostly solves the bandwidth aspect of it (but no the anit-cheat aspect). It solves it by sending things close by more frequently than things far away rather than not sending things far away.\nMy recommendation would be to start with distance based scaling and see how far it takes you. When we add a PVS solution it will probably be based on segmenting the entities into separate chunks and run the visibility logic per chunk - I guess that is closest to the subworlds you mention.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We do not have a PVS (potential visibility set) system in place yet, but we do have distance based importance scaling which mostly solves the bandwidth aspect of it (but no the anit-cheat aspect). It solves it by sending things close by more frequently than things far away rather than not sending things far away.\nMy recommendation would be to start with distance based scaling and see how far it takes you. When we add a PVS solution it will probably be based on segmenting the entities into separate chunks and run the visibility logic per chunk - I guess that is closest to the subworlds you mention."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Distance based importance is used in asteroids and we can scale up to >20.000 active entities with it as long as only a subset of those entities are close by (tested with 20.000 asteroids and 8k x 8k map). I expect it will continue scaling far beyond that but never tried."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The way distance based importance works is that it first segments the entities into different chunks based on a user defined grid. No entities will be in the same chunk unless they are in the same grid cell. Once we have that segmentation we run a user defined importance scaling method per chunk, where the method knows the grid position of the chunk and the grid position of the camera, and it can scale importance based on distance in grid cells."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The code to setup the grid segmentation is in "},{"type":"element","tag":"a","props":{"href":"https://github.com/Unity-Technologies/multiplayer/blob/master/sampleproject/Assets/Samples/Asteroids/GameMain.cs","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/Unity-Technologi...eproject/Assets/Samples/Asteroids/GameMain.cs"}]},{"type":"text","value":" - see the code doing something like entityManager.AddComponentData(grid, new GhostDistanceImportance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We also add a GhostConnectionPosition to all connections when going in-game and there is a system to update the position - see "},{"type":"element","tag":"a","props":{"href":"https://github.com/Unity-Technologies/multiplayer/blob/master/sampleproject/Assets/Samples/Asteroids/Server/Systems/UpdateConnectionPositionSystem.cs","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/Unity-Technologi...ver/Systems/UpdateConnectionPositionSystem.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.netcode@0.5/manual/ghost-snapshots.html#distance-based-importance","rel":["nofollow"]},"children":[{"type":"text","value":"Ghost snapshots | Unity NetCode | 0.5.0-preview.5 (unity3d.com)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/unity-netcode-0-0-2-preview-1.785558/page-2","rel":["nofollow"]},"children":[{"type":"text","value":"Unity NetCode 0.0.2-preview.1 | Page 2 - Unity Forum"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/netcode-expected-amount-of-ghosts.790742/","rel":["nofollow"]},"children":[{"type":"text","value":"NetCode] Expected amount of ghosts? - Unity Forum"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TileCenter offsets the grid a bit. Say you want 0,0,0 to be at the border of a tile instead of in the center of a tile, you would then set TileCenter to TileSize / 2. Unless you need fine grained control over the grid alignment you can just leave it at 0."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The tile border is related to reducing tile changes when an entity is between two tiles. The tiles are expanded by a border to have some overlap. This overlap means that you have to go a bit (the border size) outside your current tile before you switch to a new one, so if you are the the edge between two tiles and move a little bit back and forth you will not switch tile every frame."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-14-netcode.md","_source":"content","_file":"unity/2020-11-14-netcode.md","_extension":"md","date":"2020-11-14"},{"_path":"/unity/2020-11-15-ecs-parent","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"ecs中的parent","description":"ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"关于转换系统"},"children":[{"type":"text","value":"关于转换系统"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终调用的时候是使用."}]},{"type":"element","tag":"pre","props":{"code":"GameObjectConversionUtility.Convert(gameObjectWorld);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GameObjectConversionUtility.Convert(gameObjectWorld);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后具体的转换过程会新疆一个转换world主要执行GameObjectConversionMappingSystem,然后转换完成后销毁这个world"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameObjectConversionUtility.ConvertGameObjectHierarchy(unitView.gameObject, settings)会转换所有child."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameObjectConversionMappingSystem.conversion.MappingSystem.AddGameObjectOrPrefab(root);会递归所有child"}]}]},{"type":"element","tag":"h1","props":{"id":"parent"},"children":[{"type":"text","value":"parent"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"localtoworld是一个矩阵"}]},{"type":"element","tag":"pre","props":{"code":"      EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"      EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-1eb72ea2222c31c50554021afecb27d1_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rotation"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Scale"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NonUniformScale"}]},{"type":"text","value":"组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 组件指向了父 Entity, 那么最终该 Entity 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 值将会和父 Entity的 LocalToWorld 一样."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们新建一个场景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20201116024147417","src":"/images/2020-11-15-ecs-parent/image-20201116024147417.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查看分析器.就能看到如下关系图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20201116024105067","src":"/images/2020-11-15-ecs-parent/image-20201116024105067.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CUBE   "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"child"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"physicsCollider"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SPHER "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"parent"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"localtoparent"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"previousparent"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于物理的转化规则,子物体没有physicscollider."}]},{"type":"element","tag":"h2","props":{"id":"linkedentitygroup"},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"是一个 dynamic buffer , 通常它会影响:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":". 注意实例化并不一定和ECS中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Prefab"}]},{"type":"text","value":" component 直接关联."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":"时也会同时销毁 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"中的所有 entity. 类似在编辑器中删除"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"entityManager.SetEnabled"}]},{"type":"text","value":" 加上的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"component 会告知 ECS 的查询系统忽略它们, 而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":" 中的 entity 也会受到同样的影响. 有点类似禁用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 时同时会禁用整个层级树."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意如果buffer 中的 entity 也有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":", 系统"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不会递归地"}]},{"type":"text","value":"执行instantiation/destroy/disabled 过程."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些过程在具体执行当中也有一些细微不同."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":"只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"必须要把自己包括在内"}]},{"type":"text","value":"才能正常工作**.** 然而"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":"则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要注意"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的."}]},{"type":"element","tag":"h2","props":{"id":"从非-prefab-conversion-中获取linkedentitygroup"},"children":[{"type":"text","value":"从非 prefab conversion 中获取LinkedEntityGroup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前, 我们使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"并不能得到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":". 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"却可以正常得到基于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 的层级结构)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:"}]},{"type":"element","tag":"pre","props":{"code":" public void DeclareLinkedEntityGroup(GameObject gameObject)\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public void DeclareLinkedEntityGroup(GameObject gameObject)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果)."}]},{"type":"element","tag":"pre","props":{"code":"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-fe2983f48e754c910758292e0a0dfc91_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从 debbuger 现在可以看到已经正常添加了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":", 目前它已经支持"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnable"}]},{"type":"text","value":" 的正常工作了:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup."}]},{"type":"element","tag":"h2","props":{"id":"关于手动添加linkedentitygroup"},"children":[{"type":"text","value":"关于手动添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-de0722a0a9b1b64f962e00c0655f6641_1440w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<LinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer<LinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<LinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer<LinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-50abef20adb51226bd0af6bddba9e8bb_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-287469fff9e08d15954ccf00d6b63df5_1440w.jpg"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"关于parent和linkedentitygroup"},"children":[{"type":"text","value":"关于parent和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"linkedEntityGroup 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":"  "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 有关"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"被disable的组件不会被foreach到,除非主动申请选取disable"}]},{"type":"element","tag":"h1","props":{"id":"最佳的方式去关联entity和prefab"},"children":[{"type":"text","value":"最佳的方式去关联entity和prefab"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/hybrid-ecs-best-way-to-handle-convert-and-inject-game-object-prefab.736646/","rel":["nofollow"]},"children":[{"type":"text","value":"Hybrid ECS] Best way to handle Convert and Inject Game Object Prefab? - Unity Forum"}]}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\n \npublic class Prefabs : MonoBehaviour\n{\n    private static Prefabs m_Instance;\n \n    public static GameObject PlayerModel => m_Instance.playerModel;\n \n    public GameObject playerModel;\n \n    private void Awake()\n    {\n        if (m_Instance == null)\n        {\n            m_Instance = this;\n        }\n        else\n        {\n            Debug.LogError(\"Prefab Singleton loaded twice\");\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\n \npublic class Prefabs : MonoBehaviour\n{\n    private static Prefabs m_Instance;\n \n    public static GameObject PlayerModel => m_Instance.playerModel;\n \n    public GameObject playerModel;\n \n    private void Awake()\n    {\n        if (m_Instance == null)\n        {\n            m_Instance = this;\n        }\n        else\n        {\n            Debug.LogError(\"Prefab Singleton loaded twice\");\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using Unity.Entities;\nusing Unity.NetCode;\nusing Unity.Transforms;\nusing UnityEngine;\n \n[UpdateInGroup(typeof(ClientSimulationSystemGroup))]\n \npublic class PlayerModelSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.WithNone<Transform>().ForEach((Entity playerEntity, ref PlayerComponent playerComponent) => {\n            if (Prefabs.PlayerModel != null)\n            {\n                var playerModel = Object.Instantiate(Prefabs.PlayerModel);\n                EntityManager.AddComponentObject(playerEntity, playerModel.GetComponent<Transform>());\n                EntityManager.AddComponentData(playerEntity, new CopyTransformToGameObject());\n            }\n        });\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.NetCode;\nusing Unity.Transforms;\nusing UnityEngine;\n \n[UpdateInGroup(typeof(ClientSimulationSystemGroup))]\n \npublic class PlayerModelSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.WithNone<Transform>().ForEach((Entity playerEntity, ref PlayerComponent playerComponent) => {\n            if (Prefabs.PlayerModel != null)\n            {\n                var playerModel = Object.Instantiate(Prefabs.PlayerModel);\n                EntityManager.AddComponentObject(playerEntity, playerModel.GetComponent<Transform>());\n                EntityManager.AddComponentData(playerEntity, new CopyTransformToGameObject());\n            }\n        });\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/unity-tech-where-is-the-simple-bridge-between-monobehaviours-and-ecs.823485/","rel":["nofollow"]},"children":[{"type":"text","value":"Unity Tech - Where is the SIMPLE Bridge Between MonoBehaviours and ECS?? - Unity Forum"}]}]},{"type":"element","tag":"pre","props":{"code":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n \n// Attach to your Game Object to be converted, the GameObjectPrefab is a pure Game Object with no conversion that may contain MonoBehaviour components such as the particle system.\npublic class GameObjectPrefabAuthoring : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject GameObjectPrefab;\n \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentObject(entity, new GameObjectPrefab\n        {\n            Value = GameObjectPrefab\n        });\n    }\n}\n \npublic class GameObjectPrefab : IComponentData\n{\n    public GameObject Value;\n}\n \n// Instantiate and destroy the referenced prefab when the entity is created or destroyed. You can even pool the Game Object.\npublic class GameObjectPrefabSystem : JobComponentSystem\n{\n    public class GameObjectPrefabInstance : ISystemStateComponentData\n    {\n        public GameObject Value;\n    }\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities\n            .WithNone<GameObjectPrefabInstance>()\n            .ForEach((Entity entity, GameObjectPrefab gameObjectPrefab) =>\n            {\n                var gameObjectPrefabInstance = Object.Instantiate(gameObjectPrefab.Value);\n \n                EntityManager.AddComponentData(entity, new GameObjectPrefabInstance\n                {\n                    Value = gameObjectPrefabInstance\n                });\n \n                // Just an example to make the GameObject Prefab instance follow the entity.\n                EntityManager.AddComponentObject(entity, gameObjectPrefabInstance.transform);\n                EntityManager.AddComponent<CopyTransformToGameObject>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        Entities\n            .WithNone<GameObjectPrefab>()\n            .ForEach((Entity entity, GameObjectPrefabInstance gameObjectPrefabInstance) =>\n            {\n                Object.Destroy(gameObjectPrefabInstance.Value);\n \n                EntityManager.RemoveComponent<GameObjectPrefabInstance>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        return default;\n    }\n}\n \n// A dummy system for testing purposes.\npublic class DummyEntityWithGameObjectControllerSystem : JobComponentSystem\n{\n    EntityQuery m_Query;\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var deltaTime = Time.DeltaTime;\n        var speed = 3;\n        var direction = new float2(Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\"));\n        var destroy = Input.GetKeyDown(KeyCode.Delete);\n \n        if (destroy)\n        {\n            EntityManager.DestroyEntity(m_Query);\n        }\n \n        return Entities\n            .WithStoreEntityQueryInField(ref m_Query)\n            .WithAll<GameObjectPrefab>()\n            .ForEach((ref Translation translation) =>\n            {\n                translation.Value += math.normalizesafe(new float3(direction, 0).xzy) * speed * deltaTime;\n            })\n            .Schedule(inputDeps);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n \n// Attach to your Game Object to be converted, the GameObjectPrefab is a pure Game Object with no conversion that may contain MonoBehaviour components such as the particle system.\npublic class GameObjectPrefabAuthoring : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject GameObjectPrefab;\n \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentObject(entity, new GameObjectPrefab\n        {\n            Value = GameObjectPrefab\n        });\n    }\n}\n \npublic class GameObjectPrefab : IComponentData\n{\n    public GameObject Value;\n}\n \n// Instantiate and destroy the referenced prefab when the entity is created or destroyed. You can even pool the Game Object.\npublic class GameObjectPrefabSystem : JobComponentSystem\n{\n    public class GameObjectPrefabInstance : ISystemStateComponentData\n    {\n        public GameObject Value;\n    }\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities\n            .WithNone<GameObjectPrefabInstance>()\n            .ForEach((Entity entity, GameObjectPrefab gameObjectPrefab) =>\n            {\n                var gameObjectPrefabInstance = Object.Instantiate(gameObjectPrefab.Value);\n \n                EntityManager.AddComponentData(entity, new GameObjectPrefabInstance\n                {\n                    Value = gameObjectPrefabInstance\n                });\n \n                // Just an example to make the GameObject Prefab instance follow the entity.\n                EntityManager.AddComponentObject(entity, gameObjectPrefabInstance.transform);\n                EntityManager.AddComponent<CopyTransformToGameObject>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        Entities\n            .WithNone<GameObjectPrefab>()\n            .ForEach((Entity entity, GameObjectPrefabInstance gameObjectPrefabInstance) =>\n            {\n                Object.Destroy(gameObjectPrefabInstance.Value);\n \n                EntityManager.RemoveComponent<GameObjectPrefabInstance>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        return default;\n    }\n}\n \n// A dummy system for testing purposes.\npublic class DummyEntityWithGameObjectControllerSystem : JobComponentSystem\n{\n    EntityQuery m_Query;\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var deltaTime = Time.DeltaTime;\n        var speed = 3;\n        var direction = new float2(Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\"));\n        var destroy = Input.GetKeyDown(KeyCode.Delete);\n \n        if (destroy)\n        {\n            EntityManager.DestroyEntity(m_Query);\n        }\n \n        return Entities\n            .WithStoreEntityQueryInField(ref m_Query)\n            .WithAll<GameObjectPrefab>()\n            .ForEach((ref Translation translation) =>\n            {\n                translation.Value += math.normalizesafe(new float3(direction, 0).xzy) * speed * deltaTime;\n            })\n            .Schedule(inputDeps);\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"linkedentitygroup","depth":2,"text":"LinkedEntityGroup"},{"id":"从非-prefab-conversion-中获取linkedentitygroup","depth":2,"text":"从非 prefab conversion 中获取LinkedEntityGroup"},{"id":"关于手动添加linkedentitygroup","depth":2,"text":"关于手动添加LinkedEntityGroup"}]}},"_type":"markdown","_id":"content:unity:2020-11-15-ecs-parent.md","_source":"content","_file":"unity/2020-11-15-ecs-parent.md","_extension":"md","date":"2020-11-15"},{"_path":"/unity/2020-11-16-dotssample","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"ability","description":"首先ability总是和item或者character结合在一起的","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ability"},"children":[{"type":"text","value":"ability"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先ability总是和item或者character结合在一起的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下Authoring 会为ability加上不同的组件"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AbilityAutoRifleAuthoring"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AbilityMovementAuthoring"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AbilitySprintAuthoring"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AbilityDeadAuthoring"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AbilitySelectSlotAuthoring"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AbilityMeleeAuthoring"}]}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateArchetype(\ntypeof(Ability.AbilityControl),  //控制器\ntypeof(Ability.AbilityTag), //技能tag( Melee,Movement,AutoRifle, SelectSlot,Dead,Sprint)\ntypeof(Ability.AbilityAction),  //技能动作(None,PrimaryFire,SecondaryFire,Reloading,Melee,NumActions)会通过Item关联具体值\ntypeof(settings),  // 技能的配置\ntypeof(state), // 技能状态  \ntypeof(PredictedState),  // 预测状态\ntypeof(InterpolatedState), // 插值状态\n);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateArchetype(\ntypeof(Ability.AbilityControl),  //控制器\ntypeof(Ability.AbilityTag), //技能tag( Melee,Movement,AutoRifle, SelectSlot,Dead,Sprint)\ntypeof(Ability.AbilityAction),  //技能动作(None,PrimaryFire,SecondaryFire,Reloading,Melee,NumActions)会通过Item关联具体值\ntypeof(settings),  // 技能的配置\ntypeof(state), // 技能状态  \ntypeof(PredictedState),  // 预测状态\ntypeof(InterpolatedState), // 插值状态\n);\n"}]}]},{"type":"element","tag":"h2","props":{"id":"abilitycollection"},"children":[{"type":"text","value":"AbilityCollection"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AbilityEntry"}]},{"type":"text","value":"是一个IBufferElementData.存储了多个ability"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义了技能类型,能和什么类型一起运行,会打断什么类型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个技能可能会有多个触发button,比如一把枪,会有开火键和装弹键"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UpdateAbilityOwnership系统.. 填充character的OwnedCollection组件.分别为自己和item"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再根据OwnedCollection填充ownedAbilities"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PrepareOwnerForAbilityUpdate系统"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"检查ability是否启用.未启用则删除"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SelectActiveBehavior系统"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选择激活一个ability"}]},{"type":"element","tag":"h1","props":{"id":"item"},"children":[{"type":"text","value":"Item"}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateArchetype(\ntypeof(Item.InputState),  //输入状态\ntypeof(AbilityCollection.State),   //存储的是技能拥有者entity\ntypeof(AbilityCollection.AbilityEntry),//一个item可能有多个技能\n);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateArchetype(\ntypeof(Item.InputState),  //输入状态\ntypeof(AbilityCollection.State),   //存储的是技能拥有者entity\ntypeof(AbilityCollection.AbilityEntry),//一个item可能有多个技能\n);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Item.Initialize会查找所有拥有(Inventory.ItemEntry)的实体(就是character)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后将item添加到character的Inventory.ItemEntry组件的buff中."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将item和character关联起来"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inventory.update系统"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比较activeslot和lastactiveinventoryslot.来在item上添加和删除PartOwner.Visible组件"}]},{"type":"element","tag":"h1","props":{"id":"character"},"children":[{"type":"text","value":"Character"}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateArchetype(\ntypeof(Settings),  //角色设置\ntypeof(InterpolatedData), // 插值数据\ntypeof(PredictedData),//预测数据\ntypeof(ReplicatedData),// 角色类型\n\ntypeof(Player.OwnerPlayerId.Default),// 拥有者id\ntypeof(PlayerControlled.State),// 玩家控制器状态\ntypeof(HitColliderOwner.State),  //碰撞器状态\n\n//Inventory\ntypeof(Inventory.ItemEntry)   //一个item的buff\ntypeof(Inventory.State)   //状态..激活的是哪一个item\ntypeof(Inventory.InternalState)  //最后激活的item\n\n//生命和伤害\ntypeof(HealthStateData),\ntypeof(DamageEvent), //注意是个buff\ntypeof(DamageHistoryData),  \n\n//ability\ntypeof(AbilityCollection.State),   //存储的是技能拥有者entity\ntypeof(AbilityCollection.AbilityEntry),//一个角色可能有多个能力\ntypeof(AbilityOwner.State),//技能拥有者状态\ntypeof(AbilityOwner.OwnedCollection),//技能拥有者是个buff  拥有者有可能是角色也有可能是item\ntypeof(AbilityOwner.OwnedAbility),//拥有的所有技能,包括角色和item的\n\n\n\n\n\n//角色控制器数据\ntypeof(CharacterControllerComponentData),  // 一些角色控制器数据\ntypeof(CharacterControllerInitializationData),   //碰撞盒数据\ntypeof(CharacterControllerVelocity),\ntypeof(CharacterControllerMoveQuery),\ntypeof(CharacterControllerMoveResult),\ntypeof(CharacterControllerGroundSupportData),\n\n\n\n);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateArchetype(\ntypeof(Settings),  //角色设置\ntypeof(InterpolatedData), // 插值数据\ntypeof(PredictedData),//预测数据\ntypeof(ReplicatedData),// 角色类型\n\ntypeof(Player.OwnerPlayerId.Default),// 拥有者id\ntypeof(PlayerControlled.State),// 玩家控制器状态\ntypeof(HitColliderOwner.State),  //碰撞器状态\n\n//Inventory\ntypeof(Inventory.ItemEntry)   //一个item的buff\ntypeof(Inventory.State)   //状态..激活的是哪一个item\ntypeof(Inventory.InternalState)  //最后激活的item\n\n//生命和伤害\ntypeof(HealthStateData),\ntypeof(DamageEvent), //注意是个buff\ntypeof(DamageHistoryData),  \n\n//ability\ntypeof(AbilityCollection.State),   //存储的是技能拥有者entity\ntypeof(AbilityCollection.AbilityEntry),//一个角色可能有多个能力\ntypeof(AbilityOwner.State),//技能拥有者状态\ntypeof(AbilityOwner.OwnedCollection),//技能拥有者是个buff  拥有者有可能是角色也有可能是item\ntypeof(AbilityOwner.OwnedAbility),//拥有的所有技能,包括角色和item的\n\n\n\n\n\n//角色控制器数据\ntypeof(CharacterControllerComponentData),  // 一些角色控制器数据\ntypeof(CharacterControllerInitializationData),   //碰撞盒数据\ntypeof(CharacterControllerVelocity),\ntypeof(CharacterControllerMoveQuery),\ntypeof(CharacterControllerMoveResult),\ntypeof(CharacterControllerGroundSupportData),\n\n\n\n);\n"}]}]},{"type":"element","tag":"h1","props":{"id":"part"},"children":[{"type":"text","value":"part"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Part 模块是抽象\"部分关系\"的一种存在, 不过具体到实现来说, 就是可以用来管理角色模型, 武器模型(以及其LOD), 以角色配置为例说明下述具体用法"}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateArchetype(\ntypeof(Part.Owner),  //部件拥有者\ntypeof(TerraformerWeaponPart.AutoringData)  //声音\ntypeof(TerraformerWeaponPart.AuthoringClass)  //材质,特效之类的\ntypeof(TerraformerWeaponPart.State)  //状态\n);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateArchetype(\ntypeof(Part.Owner),  //部件拥有者\ntypeof(TerraformerWeaponPart.AutoringData)  //声音\ntypeof(TerraformerWeaponPart.AuthoringClass)  //材质,特效之类的\ntypeof(TerraformerWeaponPart.State)  //状态\n);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样的item和character都可以拥有part"}]},{"type":"element","tag":"h1","props":{"id":"local-player"},"children":[{"type":"text","value":"local player"}]},{"type":"element","tag":"pre","props":{"code":"EntityManager.CreateArchetype(\ntypeof(Player.State)  \ntypeof(UserCommand)    //是个buff\ntypeof(LocalPlayer)  \ntypeof(LocalPlayerCharacterControl.State)\n\ntypeof(AbilityUIElement)\ntypeof(PresentationElement)\ntypeof(PlayerCameraControl.State)\n);\n\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EntityManager.CreateArchetype(\ntypeof(Player.State)  \ntypeof(UserCommand)    //是个buff\ntypeof(LocalPlayer)  \ntypeof(LocalPlayerCharacterControl.State)\n\ntypeof(AbilityUIElement)\ntypeof(PresentationElement)\ntypeof(PlayerCameraControl.State)\n);\n\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先看"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CharacterAuthoring"}]},{"type":"text","value":"然后我们就知道.一个character到底有哪些东东了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"//Assets/Unity.Sample.Terraformer/Prefabs/Characters/Terraformer/Char_Terraformer.prefab"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SpawnCharacter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ItemAuthoring"}]},{"type":"element","tag":"h1","props":{"id":"palyer-实例化流程"},"children":[{"type":"text","value":"palyer 实例化流程"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端连接的时候,服务端PlayerModuleServer.CreatePlayerEntity 创建player实体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务端根据GameMode,创建角色GameModeSystemServer.Update()"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端创建localplayer.并根据系统将localplayer和character和player进行绑定"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"abilitycollection","depth":2,"text":"AbilityCollection"}]}},"_type":"markdown","_id":"content:unity:2020-11-16-dotssample.md","_source":"content","_file":"unity/2020-11-16-dotssample.md","_extension":"md","date":"2020-11-16"},{"_path":"/unity/2020-11-17-unity-ecs-worldtime","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity world time system","description":"\n  [Preserve]\n    [UpdateInGroup(typeof(InitializationSystemGroup))]\n    public class UpdateWorldTimeSystem : ComponentSystem\n    {\n        private bool hasTickedOnce = false;\n\n        protected override void OnUpdate()\n        {\n            var currentElapsedTime = Time.ElapsedTime;\n            var","body":{"type":"root","children":[{"type":"element","tag":"pre","props":{"code":"\n  [Preserve]\n    [UpdateInGroup(typeof(InitializationSystemGroup))]\n    public class UpdateWorldTimeSystem : ComponentSystem\n    {\n        private bool hasTickedOnce = false;\n\n        protected override void OnUpdate()\n        {\n            var currentElapsedTime = Time.ElapsedTime;\n            var deltaTime = math.min(UnityEngine.Time.deltaTime, World.MaximumDeltaTime);\n            World.SetTime(new TimeData(\n                elapsedTime: hasTickedOnce ? (currentElapsedTime + deltaTime) : currentElapsedTime,\n                deltaTime: deltaTime\n            ));\n            hasTickedOnce = true;\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n  [Preserve]\n    [UpdateInGroup(typeof(InitializationSystemGroup))]\n    public class UpdateWorldTimeSystem : ComponentSystem\n    {\n        private bool hasTickedOnce = false;\n\n        protected override void OnUpdate()\n        {\n            var currentElapsedTime = Time.ElapsedTime;\n            var deltaTime = math.min(UnityEngine.Time.deltaTime, World.MaximumDeltaTime);\n            World.SetTime(new TimeData(\n                elapsedTime: hasTickedOnce ? (currentElapsedTime + deltaTime) : currentElapsedTime,\n                deltaTime: deltaTime\n            ));\n            hasTickedOnce = true;\n        }\n    }\n"}]}]},{"type":"element","tag":"pre","props":{"code":"    internal struct WorldTime : IComponentData\n    {\n        public TimeData Time;\n    }\n\n    internal struct WorldTimeQueue : IBufferElementData\n    {\n        public TimeData Time;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    internal struct WorldTime : IComponentData\n    {\n        public TimeData Time;\n    }\n\n    internal struct WorldTimeQueue : IBufferElementData\n    {\n        public TimeData Time;\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"World.cs"}]},{"type":"element","tag":"pre","props":{"code":"\n        protected Entity TimeSingleton\n        {\n            get\n            {\n                if (m_TimeSingletonQuery.IsEmptyIgnoreFilter)\n                {\n        #if UNITY_EDITOR\n                    var entity = EntityManager.CreateEntity(typeof(WorldTime), typeof(WorldTimeQueue));\n                    EntityManager.SetName(entity , \"WorldTime\");\n        #else\n                    EntityManager.CreateEntity(typeof(WorldTime), typeof(WorldTimeQueue));\n        #endif\n                }\n\n                return m_TimeSingletonQuery.GetSingletonEntity();\n            }\n        }\n\n        public void SetTime(TimeData newTimeData)\n        {\n            EntityManager.SetComponentData(TimeSingleton, new WorldTime() {Time = newTimeData});\n            this.Time = newTimeData;\n        }\n\n        public void PushTime(TimeData newTimeData)\n        {\n            var queue = EntityManager.GetBuffer<WorldTimeQueue>(TimeSingleton);\n            queue.Add(new WorldTimeQueue() { Time = this.Time });\n            SetTime(newTimeData);\n        }\n\n        public void PopTime()\n        {\n            var queue = EntityManager.GetBuffer<WorldTimeQueue>(TimeSingleton);\n\n            Assert.IsTrue(queue.Length > 0, \"PopTime without a matching PushTime\");\n\n            var prevTime = queue[queue.Length - 1];\n            queue.RemoveAt(queue.Length - 1);\n            SetTime(prevTime.Time);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n        protected Entity TimeSingleton\n        {\n            get\n            {\n                if (m_TimeSingletonQuery.IsEmptyIgnoreFilter)\n                {\n        #if UNITY_EDITOR\n                    var entity = EntityManager.CreateEntity(typeof(WorldTime), typeof(WorldTimeQueue));\n                    EntityManager.SetName(entity , \"WorldTime\");\n        #else\n                    EntityManager.CreateEntity(typeof(WorldTime), typeof(WorldTimeQueue));\n        #endif\n                }\n\n                return m_TimeSingletonQuery.GetSingletonEntity();\n            }\n        }\n\n        public void SetTime(TimeData newTimeData)\n        {\n            EntityManager.SetComponentData(TimeSingleton, new WorldTime() {Time = newTimeData});\n            this.Time = newTimeData;\n        }\n\n        public void PushTime(TimeData newTimeData)\n        {\n            var queue = EntityManager.GetBuffer<WorldTimeQueue>(TimeSingleton);\n            queue.Add(new WorldTimeQueue() { Time = this.Time });\n            SetTime(newTimeData);\n        }\n\n        public void PopTime()\n        {\n            var queue = EntityManager.GetBuffer<WorldTimeQueue>(TimeSingleton);\n\n            Assert.IsTrue(queue.Length > 0, \"PopTime without a matching PushTime\");\n\n            var prevTime = queue[queue.Length - 1];\n            queue.RemoveAt(queue.Length - 1);\n            SetTime(prevTime.Time);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ComponentSystemBase"}]},{"type":"element","tag":"pre","props":{"code":"        /// <summary>\n        /// The World in which this system exists.\n        /// </summary>\n        /// <value>The World of this system.</value>\n        public World World => m_StatePtr != null ? (World)m_StatePtr->m_World.Target : null;\n\n        /// <summary>\n        /// The current Time data for this system's world.\n        /// </summary>\n        public ref readonly TimeData Time => ref World.Time;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        /// <summary>\n        /// The World in which this system exists.\n        /// </summary>\n        /// <value>The World of this system.</value>\n        public World World => m_StatePtr != null ? (World)m_StatePtr->m_World.Target : null;\n\n        /// <summary>\n        /// The current Time data for this system's world.\n        /// </summary>\n        public ref readonly TimeData Time => ref World.Time;\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-17-unity-ecs-worldtime.md","_source":"content","_file":"unity/2020-11-17-unity-ecs-worldtime.md","_extension":"md","date":"2020-11-17"},{"_path":"/unity/2020-11-18-netcode-sourcecode","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"netcode源代码解读","description":"NetworkStreamReceiveSystem客户端连接服务端  ,服务端创建NetworkIdComponent客户端添加NetworkStreamInGame组件,并通过rpc 发送GoInGameRequest请求服务端接收到请求后,实例化player为player添加GhostOwnerComponent初始化player添加一些其他不需要同步的组件为connection添加NetworkStreamInGame组件为connection设置CommandTargetComponent客户端根据player独有的组件特性,查找已经被ghost同步过来的实体比对NetworkIdC","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"networkstreamreceivesystem"},"children":[{"type":"text","value":"NetworkStreamReceiveSystem"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端连接服务端  ,服务端创建NetworkIdComponent"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端添加NetworkStreamInGame组件,并通过rpc 发送GoInGameRequest请求"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"服务端接收到请求后,实例化player"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为player添加GhostOwnerComponent"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"初始化player添加一些其他不需要同步的组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为connection添加NetworkStreamInGame组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为connection设置CommandTargetComponent"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端根据player独有的组件特性,查找已经被ghost同步过来的实体"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"比对NetworkIdComponent和GhostOwnerComponent的id,判断是否是localPlayer"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对localplayer进行初始化"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为connection设置CommandTargetComponent为localplayer"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端使用CommandTargetComponent的targetEntity进行command发送"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"客户端和服务端对传送的command同时使用PredictedGhostComponent进行预测????"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"预测不是发生在客户端的吗???貌似netcode服务端也做了预测"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"在服务器上，预测循环始终仅运行一次，并且不会更新TimeData结构，因为它已经正确。它仍然设置GhostPredictionSystemGroup.PredictingTick以确保可以在客户端和服务器上运行完全相同的代码。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"插值 是针对其他玩家的本地显示...预测是针对自己操作的角色,最后从服务器校正"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"延迟补偿是服务器在做的一件事情.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GhostReceiveSystem  接收快照"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GhostUpdateSystem  应用快照     设置了predictionStartTick和AppliedTick"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GhostPredictionSystemGroup   设置了 PredictingTick ,服务端永远为ServerSimulationSystemGroup.servertick"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"======================================================================="}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端的servertick在不同的两帧之间可能是相同的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20201206011918426","src":"/images/2020-11-18-netcode-sourcecode/image-20201206011918426.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"servertick    235"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    230"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    231"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    232"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    233"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    234"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    235"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"servertick    240  因为跑预测所以这里可能过了好几帧servertick这里不是236"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    240  //自己先跑一下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"servertick    240 //又可能tick增长时间还没有过"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    238"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    239"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PredictingTick    240"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上没多大复杂的事情..客户端发送命令给服务端,服务端处理后将tick和数据同步给客户端..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端拿到数据..该预测的预测..该插值的插值..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后还需要处理这帧的自己的命令..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ghost数据(服务端传送的同步)--预测---输入命令--发送命令给服务端---处理命令----覆盖同步数据(一般是覆盖自己的)--应用数据(位移,动画等)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务端:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务端接收到命令---处理命令----写入Ghost数据(同步)--应用数据(位移,动画等)"}]},{"type":"element","tag":"h2","props":{"id":"预测"},"children":[{"type":"text","value":"预测"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"输入的时候, 添加发送给服务器时的servertick ,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意这个servertick和ServerSimulationSystemGroup.servertick没有多大关系."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"m_ClientSimulationSystemGroup.ServerTick标记发送给服务器的命令所在的tick,以及用来接收服务器快照后(快照会包含该tick),丢弃执行过的命令,以及预测未执行的命令使用"}]},{"type":"element","tag":"pre","props":{"code":"        var input = default(CubeInput);\n        input.Tick = m_ClientSimulationSystemGroup.ServerTick;\n        if (Input.GetKey(\"a\"))\n            input.horizontal -= 1;\n        if (Input.GetKey(\"d\"))\n            input.horizontal += 1;\n        if (Input.GetKey(\"s\"))\n            input.vertical -= 1;\n        if (Input.GetKey(\"w\"))\n            input.vertical += 1;\n        var inputBuffer = EntityManager.GetBuffer<CubeInput>(localInput);\n        inputBuffer.AddCommandData(input);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        var input = default(CubeInput);\n        input.Tick = m_ClientSimulationSystemGroup.ServerTick;\n        if (Input.GetKey(\"a\"))\n            input.horizontal -= 1;\n        if (Input.GetKey(\"d\"))\n            input.horizontal += 1;\n        if (Input.GetKey(\"s\"))\n            input.vertical -= 1;\n        if (Input.GetKey(\"w\"))\n            input.vertical += 1;\n        var inputBuffer = EntityManager.GetBuffer<CubeInput>(localInput);\n        inputBuffer.AddCommandData(input);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端使用服务端的快照时,将更新PredictedGhostComponent,可以看到他有两个tick,一个是应用tick,一个是预测开始的tick"}]},{"type":"element","tag":"pre","props":{"code":"    public struct PredictedGhostComponent : IComponentData\n    {\n        public uint AppliedTick;\n        public uint PredictionStartTick;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public struct PredictedGhostComponent : IComponentData\n    {\n        public uint AppliedTick;\n        public uint PredictionStartTick;\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务端PredictedGhostComponent其中AppliedTick和PredictionStartTick永远为0"}]},{"type":"element","tag":"pre","props":{"code":"[UpdateInGroup(typeof(GhostPredictionSystemGroup))]\npublic class MoveCubeSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        var group = World.GetExistingSystem<GhostPredictionSystemGroup>();\n        var tick = group.PredictingTick;\n        var deltaTime = Time.DeltaTime;\n        Entities.ForEach((DynamicBuffer<CubeInput> inputBuffer, ref Translation trans, ref PredictedGhostComponent prediction) =>\n        {\n            if (!GhostPredictionSystemGroup.ShouldPredict(tick, prediction))\n                return;\n            CubeInput input;\n            inputBuffer.GetDataAtTick(tick, out input);\n            if (input.horizontal > 0)\n                trans.Value.x += deltaTime;\n            if (input.horizontal < 0)\n                trans.Value.x -= deltaTime;\n            if (input.vertical > 0)\n                trans.Value.z += deltaTime;\n            if (input.vertical < 0)\n                trans.Value.z -= deltaTime;\n        });\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[UpdateInGroup(typeof(GhostPredictionSystemGroup))]\npublic class MoveCubeSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        var group = World.GetExistingSystem<GhostPredictionSystemGroup>();\n        var tick = group.PredictingTick;\n        var deltaTime = Time.DeltaTime;\n        Entities.ForEach((DynamicBuffer<CubeInput> inputBuffer, ref Translation trans, ref PredictedGhostComponent prediction) =>\n        {\n            if (!GhostPredictionSystemGroup.ShouldPredict(tick, prediction))\n                return;\n            CubeInput input;\n            inputBuffer.GetDataAtTick(tick, out input);\n            if (input.horizontal > 0)\n                trans.Value.x += deltaTime;\n            if (input.horizontal < 0)\n                trans.Value.x -= deltaTime;\n            if (input.vertical > 0)\n                trans.Value.z += deltaTime;\n            if (input.vertical < 0)\n                trans.Value.z -= deltaTime;\n        });\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们看下GhostPredictionSystemGroup的源代码:"}]},{"type":"element","tag":"pre","props":{"code":"   protected override void OnUpdate()\n        {\n            // If client, go from oldest applied predicted tick to target tick, apply. Allow filtering on latest received tick somehow\n            if (isServer)\n            {\n                // If server, apply once\n                var simulationSystemGroup = World.GetExistingSystem<ServerSimulationSystemGroup>();\n                PredictingTick = simulationSystemGroup.ServerTick;\n                IsFinalPredictionTick = true;\n                base.OnUpdate();\n            }\n            else\n            {\n                if (predictedTickWriters.Length > 1)\n                {\n                    predictedTickWriters[0] = JobHandle.CombineDependencies(predictedTickWriters);\n                    predictedTickWriters.ResizeUninitialized(1);\n                }\n\n                if (predictedTickWriters.Length > 0)\n                    predictedTickWriters[0].Complete();\n                predictedTickWriters.Clear();\n                uint oldestAppliedTick = 0;\n                for (int i = 0; i < OldestPredictedTick.Length; ++i)\n                {\n                    if (OldestPredictedTick[i] != 0)\n                    {\n                        if (oldestAppliedTick == 0 ||\n                            SequenceHelpers.IsNewer(oldestAppliedTick, OldestPredictedTick[i]))\n                            oldestAppliedTick = OldestPredictedTick[i];\n                        OldestPredictedTick[i] = 0;\n                    }\n                }\n\n                var simulationSystemGroup = World.GetExistingSystem<ClientSimulationSystemGroup>();\n                var serverTick = simulationSystemGroup.ServerTick;\n                var targetTick = serverTick;\n\n                if (oldestAppliedTick == 0 ||\n                    !SequenceHelpers.IsNewer(targetTick, oldestAppliedTick))\n                    //oldestAppliedTick = targetTick - 1;\n                    return; // Nothing rolled back - nothing to predict\n                // Do not try to predict more frames than we can have input for\n                if (targetTick - oldestAppliedTick > CommandDataUtility.k_CommandDataMaxSize)\n                    oldestAppliedTick = targetTick - CommandDataUtility.k_CommandDataMaxSize;\n\n                var previousTime = Time;\n                var elapsedTime = previousTime.ElapsedTime;\n                if (simulationSystemGroup.ServerTickFraction < 1)\n                {\n                    --targetTick;\n                    elapsedTime -= simulationSystemGroup.ServerTickDeltaTime * simulationSystemGroup.ServerTickFraction;\n                }\n\n                for (uint i = oldestAppliedTick + 1; i != targetTick+1; ++i)\n                {\n                    uint tickAge = targetTick - i;\n                    World.SetTime(new TimeData(elapsedTime - simulationSystemGroup.ServerTickDeltaTime*tickAge, simulationSystemGroup.ServerTickDeltaTime));\n                    PredictingTick = i;\n                    IsFinalPredictionTick = (i == serverTick);\n                    base.OnUpdate();\n                }\n\n                if (simulationSystemGroup.ServerTickFraction < 1)\n                {\n                    PredictingTick = targetTick + 1;\n                    IsFinalPredictionTick = true;\n                    World.SetTime(new TimeData(previousTime.ElapsedTime, simulationSystemGroup.ServerTickDeltaTime *\n                                                                        simulationSystemGroup.ServerTickFraction));\n                    base.OnUpdate();\n                }\n                World.SetTime(previousTime);\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   protected override void OnUpdate()\n        {\n            // If client, go from oldest applied predicted tick to target tick, apply. Allow filtering on latest received tick somehow\n            if (isServer)\n            {\n                // If server, apply once\n                var simulationSystemGroup = World.GetExistingSystem<ServerSimulationSystemGroup>();\n                PredictingTick = simulationSystemGroup.ServerTick;\n                IsFinalPredictionTick = true;\n                base.OnUpdate();\n            }\n            else\n            {\n                if (predictedTickWriters.Length > 1)\n                {\n                    predictedTickWriters[0] = JobHandle.CombineDependencies(predictedTickWriters);\n                    predictedTickWriters.ResizeUninitialized(1);\n                }\n\n                if (predictedTickWriters.Length > 0)\n                    predictedTickWriters[0].Complete();\n                predictedTickWriters.Clear();\n                uint oldestAppliedTick = 0;\n                for (int i = 0; i < OldestPredictedTick.Length; ++i)\n                {\n                    if (OldestPredictedTick[i] != 0)\n                    {\n                        if (oldestAppliedTick == 0 ||\n                            SequenceHelpers.IsNewer(oldestAppliedTick, OldestPredictedTick[i]))\n                            oldestAppliedTick = OldestPredictedTick[i];\n                        OldestPredictedTick[i] = 0;\n                    }\n                }\n\n                var simulationSystemGroup = World.GetExistingSystem<ClientSimulationSystemGroup>();\n                var serverTick = simulationSystemGroup.ServerTick;\n                var targetTick = serverTick;\n\n                if (oldestAppliedTick == 0 ||\n                    !SequenceHelpers.IsNewer(targetTick, oldestAppliedTick))\n                    //oldestAppliedTick = targetTick - 1;\n                    return; // Nothing rolled back - nothing to predict\n                // Do not try to predict more frames than we can have input for\n                if (targetTick - oldestAppliedTick > CommandDataUtility.k_CommandDataMaxSize)\n                    oldestAppliedTick = targetTick - CommandDataUtility.k_CommandDataMaxSize;\n\n                var previousTime = Time;\n                var elapsedTime = previousTime.ElapsedTime;\n                if (simulationSystemGroup.ServerTickFraction < 1)\n                {\n                    --targetTick;\n                    elapsedTime -= simulationSystemGroup.ServerTickDeltaTime * simulationSystemGroup.ServerTickFraction;\n                }\n\n                for (uint i = oldestAppliedTick + 1; i != targetTick+1; ++i)\n                {\n                    uint tickAge = targetTick - i;\n                    World.SetTime(new TimeData(elapsedTime - simulationSystemGroup.ServerTickDeltaTime*tickAge, simulationSystemGroup.ServerTickDeltaTime));\n                    PredictingTick = i;\n                    IsFinalPredictionTick = (i == serverTick);\n                    base.OnUpdate();\n                }\n\n                if (simulationSystemGroup.ServerTickFraction < 1)\n                {\n                    PredictingTick = targetTick + 1;\n                    IsFinalPredictionTick = true;\n                    World.SetTime(new TimeData(previousTime.ElapsedTime, simulationSystemGroup.ServerTickDeltaTime *\n                                                                        simulationSystemGroup.ServerTickFraction));\n                    base.OnUpdate();\n                }\n                World.SetTime(previousTime);\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到从开始值不断的改变PredictingTick进行预测,然后执行了base.OnUpdate()"}]},{"type":"element","tag":"h1","props":{"id":"插值"},"children":[{"type":"text","value":"插值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"插值就是将网络玩家显示在过去的某个时刻"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。"}]},{"type":"element","tag":"h3","props":{"id":"translation和rotation的转换"},"children":[{"type":"text","value":"Translation和Rotation的转换"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity.NetCode.Editor.GhostAuthoringComponentEditor"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"中添加了Translation和Rotation的转换,只有被转换的才会被传输..如果不想转换可以在code gen window中勾掉Unity.Transforms..auto compile也勾掉"}]},{"type":"element","tag":"pre","props":{"code":"    public static void InitDefaultOverrides()\n        {\n            GhostDefaultOverrides = new Dictionary<string, GhostComponent>();\n            AssembliesDefaultOverrides = new HashSet<string>(new []{\n                \"Unity.NetCode\",\n                \"Unity.Transforms\",\n            });\n\n            var comp = new GhostComponent\n            {\n                name = \"Unity.Transforms.Translation\",\n                attribute = new GhostComponentAttribute{PrefabType = GhostPrefabType.All, OwnerPredictedSendType = GhostSendType.All, SendDataForChildEntity = false},\n                fields = new GhostComponentField[]\n                {\n                    new GhostComponentField\n                    {\n                        name = \"Value\",\n                        attribute = new GhostFieldAttribute{Quantization = 100, Interpolate = true}\n                    }\n                },\n                entityIndex = 0\n            };\n            GhostDefaultOverrides.Add(comp.name, comp);\n            comp = new GhostComponent\n            {\n                name = \"Unity.Transforms.Rotation\",\n                attribute = new GhostComponentAttribute{PrefabType = GhostPrefabType.All, OwnerPredictedSendType = GhostSendType.All, SendDataForChildEntity = false},\n                fields = new GhostComponentField[]\n                {\n                    new GhostComponentField\n                    {\n                        name = \"Value\",\n                        attribute = new GhostFieldAttribute{Quantization = 1000, Interpolate = true}\n                    }\n                },\n                entityIndex = 0\n            };\n            GhostDefaultOverrides.Add(comp.name, comp);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public static void InitDefaultOverrides()\n        {\n            GhostDefaultOverrides = new Dictionary<string, GhostComponent>();\n            AssembliesDefaultOverrides = new HashSet<string>(new []{\n                \"Unity.NetCode\",\n                \"Unity.Transforms\",\n            });\n\n            var comp = new GhostComponent\n            {\n                name = \"Unity.Transforms.Translation\",\n                attribute = new GhostComponentAttribute{PrefabType = GhostPrefabType.All, OwnerPredictedSendType = GhostSendType.All, SendDataForChildEntity = false},\n                fields = new GhostComponentField[]\n                {\n                    new GhostComponentField\n                    {\n                        name = \"Value\",\n                        attribute = new GhostFieldAttribute{Quantization = 100, Interpolate = true}\n                    }\n                },\n                entityIndex = 0\n            };\n            GhostDefaultOverrides.Add(comp.name, comp);\n            comp = new GhostComponent\n            {\n                name = \"Unity.Transforms.Rotation\",\n                attribute = new GhostComponentAttribute{PrefabType = GhostPrefabType.All, OwnerPredictedSendType = GhostSendType.All, SendDataForChildEntity = false},\n                fields = new GhostComponentField[]\n                {\n                    new GhostComponentField\n                    {\n                        name = \"Value\",\n                        attribute = new GhostFieldAttribute{Quantization = 1000, Interpolate = true}\n                    }\n                },\n                entityIndex = 0\n            };\n            GhostDefaultOverrides.Add(comp.name, comp);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以看到这里使用了GhostFiled并且将其设置为Interpolate..我们在看下他生成的code"}]},{"type":"element","tag":"pre","props":{"code":"        [BurstCompile]\n        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]\n        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)\n        {\n            for (int i = 0; i < count; ++i)\n            {\n                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);\n                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);\n                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);\n                float snapshotInterpolationFactor = snapshotInterpolationData.InterpolationFactor;\n                ref var component = ref GhostComponentSerializer.TypeCast<Unity.Transforms.Translation>(componentData, componentStride*i);\n                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);\n                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;\n                component.Value = math.lerp(\n                    new float3(snapshotBefore.Value_x * 0.01f, snapshotBefore.Value_y * 0.01f, snapshotBefore.Value_z * 0.01f),\n                    new float3(snapshotAfter.Value_x * 0.01f, snapshotAfter.Value_y * 0.01f, snapshotAfter.Value_z * 0.01f),\n                    snapshotInterpolationFactor);\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        [BurstCompile]\n        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]\n        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)\n        {\n            for (int i = 0; i < count; ++i)\n            {\n                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);\n                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);\n                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);\n                float snapshotInterpolationFactor = snapshotInterpolationData.InterpolationFactor;\n                ref var component = ref GhostComponentSerializer.TypeCast<Unity.Transforms.Translation>(componentData, componentStride*i);\n                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);\n                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;\n                component.Value = math.lerp(\n                    new float3(snapshotBefore.Value_x * 0.01f, snapshotBefore.Value_y * 0.01f, snapshotBefore.Value_z * 0.01f),\n                    new float3(snapshotAfter.Value_x * 0.01f, snapshotAfter.Value_y * 0.01f, snapshotAfter.Value_z * 0.01f),\n                    snapshotInterpolationFactor);\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到在读取快照的时候使用了snapshotInterpolationFactor进行插值,SnapshotData类中"}]},{"type":"element","tag":"pre","props":{"code":"\n  public unsafe bool GetDataAtTick(uint targetTick, float targetTickFraction, in DynamicBuffer<SnapshotDataBuffer> buffer, out DataAtTick data)\n        {\n            data = default;\n            if (buffer.Length == 0)\n                return false;\n            var numBuffers = buffer.Length / SnapshotSize;\n            int beforeIdx = 0;\n            uint beforeTick = 0;\n            int afterIdx = 0;\n            uint afterTick = 0;\n            // If last tick is fractional before should not include the tick we are targeting, it should instead be included in after\n            if (targetTickFraction < 1)\n                --targetTick;\n            byte* snapshotData;\n            // Loop from latest available to oldest available snapshot\n            for (int slot = 0; slot < numBuffers; ++slot)\n            {\n                var curIndex = (LatestIndex + GhostSystemConstants.SnapshotHistorySize - slot) % GhostSystemConstants.SnapshotHistorySize;\n                snapshotData = (byte*)buffer.GetUnsafePtr() + curIndex * SnapshotSize;\n                uint tick = *(uint*)snapshotData;\n                if (tick == 0)\n                    continue;\n                if (SequenceHelpers.IsNewer(tick, targetTick))\n                {\n                    afterTick = tick;\n                    afterIdx = curIndex;\n                }\n                else\n                {\n                    beforeTick = tick;\n                    beforeIdx = curIndex;\n                    break;\n                }\n            }\n\n            if (beforeTick == 0)\n            {\n                return false;\n            }\n\n            data.SnapshotBefore = (System.IntPtr)((byte*)buffer.GetUnsafePtr() + beforeIdx * SnapshotSize);\n            data.Tick = beforeTick;\n            if (afterTick == 0)\n            {\n                data.SnapshotAfter = data.SnapshotBefore;\n                data.InterpolationFactor = 0;\n            }\n            else\n            {\n                data.SnapshotAfter = (System.IntPtr)((byte*)buffer.GetUnsafePtr() + afterIdx * SnapshotSize);\n                data.InterpolationFactor = (float) (targetTick - beforeTick) / (float) (afterTick - beforeTick);\n                if (targetTickFraction < 1)\n                    data.InterpolationFactor += targetTickFraction / (float) (afterTick - beforeTick);\n            }\n\n            return true;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n  public unsafe bool GetDataAtTick(uint targetTick, float targetTickFraction, in DynamicBuffer<SnapshotDataBuffer> buffer, out DataAtTick data)\n        {\n            data = default;\n            if (buffer.Length == 0)\n                return false;\n            var numBuffers = buffer.Length / SnapshotSize;\n            int beforeIdx = 0;\n            uint beforeTick = 0;\n            int afterIdx = 0;\n            uint afterTick = 0;\n            // If last tick is fractional before should not include the tick we are targeting, it should instead be included in after\n            if (targetTickFraction < 1)\n                --targetTick;\n            byte* snapshotData;\n            // Loop from latest available to oldest available snapshot\n            for (int slot = 0; slot < numBuffers; ++slot)\n            {\n                var curIndex = (LatestIndex + GhostSystemConstants.SnapshotHistorySize - slot) % GhostSystemConstants.SnapshotHistorySize;\n                snapshotData = (byte*)buffer.GetUnsafePtr() + curIndex * SnapshotSize;\n                uint tick = *(uint*)snapshotData;\n                if (tick == 0)\n                    continue;\n                if (SequenceHelpers.IsNewer(tick, targetTick))\n                {\n                    afterTick = tick;\n                    afterIdx = curIndex;\n                }\n                else\n                {\n                    beforeTick = tick;\n                    beforeIdx = curIndex;\n                    break;\n                }\n            }\n\n            if (beforeTick == 0)\n            {\n                return false;\n            }\n\n            data.SnapshotBefore = (System.IntPtr)((byte*)buffer.GetUnsafePtr() + beforeIdx * SnapshotSize);\n            data.Tick = beforeTick;\n            if (afterTick == 0)\n            {\n                data.SnapshotAfter = data.SnapshotBefore;\n                data.InterpolationFactor = 0;\n            }\n            else\n            {\n                data.SnapshotAfter = (System.IntPtr)((byte*)buffer.GetUnsafePtr() + afterIdx * SnapshotSize);\n                data.InterpolationFactor = (float) (targetTick - beforeTick) / (float) (afterTick - beforeTick);\n                if (targetTickFraction < 1)\n                    data.InterpolationFactor += targetTickFraction / (float) (afterTick - beforeTick);\n            }\n\n            return true;\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在其中计算了InterpolationFactor."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"无论是插值和预测都是先读取快照.我们看下GhostUpdateSystem"}]},{"type":"element","tag":"pre","props":{"code":" public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex, DynamicComponentTypeHandle* ghostChunkComponentTypesPtr, int ghostChunkComponentTypesLength)\n            {\n                bool predicted = chunk.Has(predictedGhostComponentType);\n                uint targetTick = predicted ? predictedTargetTick : interpolatedTargetTick;\n                float targetTickFraction = predicted ? 1.0f : interpolatedTargetTickFraction;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex, DynamicComponentTypeHandle* ghostChunkComponentTypesPtr, int ghostChunkComponentTypesLength)\n            {\n                bool predicted = chunk.Has(predictedGhostComponentType);\n                uint targetTick = predicted ? predictedTargetTick : interpolatedTargetTick;\n                float targetTickFraction = predicted ? 1.0f : interpolatedTargetTickFraction;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"预测使用的是predictedTargetTick,插值使用的是interpolatedTargetTick"}]},{"type":"element","tag":"pre","props":{"code":" interpolatedTargetTick = m_ClientSimulationSystemGroup.InterpolationTick,\n                interpolatedTargetTickFraction = m_ClientSimulationSystemGroup.InterpolationTickFraction,\n\n                predictedTargetTick = m_ClientSimulationSystemGroup.ServerTick,\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" interpolatedTargetTick = m_ClientSimulationSystemGroup.InterpolationTick,\n                interpolatedTargetTickFraction = m_ClientSimulationSystemGroup.InterpolationTickFraction,\n\n                predictedTargetTick = m_ClientSimulationSystemGroup.ServerTick,\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而他们又都来自m_ClientSimulationSystemGroup,m_ClientSimulationSystemGroup的tick又来自NetworkTimeSystem"}]},{"type":"element","tag":"h3","props":{"id":"clientservertickrate"},"children":[{"type":"text","value":"ClientServerTickRate"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RpcSetNetworkId"}]},{"type":"element","tag":"pre","props":{"code":" [BurstCompile]\n        [AOT.MonoPInvokeCallback(typeof(RpcExecutor.ExecuteDelegate))]\n        private static void InvokeExecute(ref RpcExecutor.Parameters parameters)\n        {\n            var rpcData = default(RpcSetNetworkId);\n            var rpcSerializer = default(RpcSetNetworkId);\n            rpcSerializer.Deserialize(ref parameters.Reader, parameters.DeserializerState, ref rpcData);\n\n            parameters.CommandBuffer.AddComponent(parameters.JobIndex, parameters.Connection, new NetworkIdComponent {Value = rpcData.nid});\n            var ent = parameters.CommandBuffer.CreateEntity(parameters.JobIndex);\n            parameters.CommandBuffer.AddComponent(parameters.JobIndex, ent, new ClientServerTickRateRefreshRequest\n            {\n                MaxSimulationStepsPerFrame = rpcData.simMaxSteps,\n                NetworkTickRate = rpcData.netTickRate,\n                SimulationTickRate = rpcData.simTickRate\n            });\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" [BurstCompile]\n        [AOT.MonoPInvokeCallback(typeof(RpcExecutor.ExecuteDelegate))]\n        private static void InvokeExecute(ref RpcExecutor.Parameters parameters)\n        {\n            var rpcData = default(RpcSetNetworkId);\n            var rpcSerializer = default(RpcSetNetworkId);\n            rpcSerializer.Deserialize(ref parameters.Reader, parameters.DeserializerState, ref rpcData);\n\n            parameters.CommandBuffer.AddComponent(parameters.JobIndex, parameters.Connection, new NetworkIdComponent {Value = rpcData.nid});\n            var ent = parameters.CommandBuffer.CreateEntity(parameters.JobIndex);\n            parameters.CommandBuffer.AddComponent(parameters.JobIndex, ent, new ClientServerTickRateRefreshRequest\n            {\n                MaxSimulationStepsPerFrame = rpcData.simMaxSteps,\n                NetworkTickRate = rpcData.netTickRate,\n                SimulationTickRate = rpcData.simTickRate\n            });\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务端在同步networkid的时候会一起同步ClientServerTickRate"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端会比服务端多一个NetworkTimeSystem根据往返时间和最近从服务器收到的快照来计算服务器时间的初始估计"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"来看下插值tick的计算..他首先是算出predictTargetTick然后减去一个插值"}]},{"type":"element","tag":"pre","props":{"code":"\n var idiff = (uint)currentInterpolationFrames;\n            interpolateTargetTick = predictTargetTick - idiff;\n            var subidiff = currentInterpolationFrames - idiff;\n            subidiff -= subInterpolateTargetTick+subPredictTargetTick;\n            if (subidiff < 0)\n            {\n                ++interpolateTargetTick;\n                subidiff = -subidiff;\n            }\n            else if (subidiff > 0)\n            {\n                idiff = (uint)subidiff;\n                subidiff -= idiff;\n                interpolateTargetTick -= idiff;\n                subidiff = 1f-subidiff;\n            }\n            subInterpolateTargetTick = subidiff;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n var idiff = (uint)currentInterpolationFrames;\n            interpolateTargetTick = predictTargetTick - idiff;\n            var subidiff = currentInterpolationFrames - idiff;\n            subidiff -= subInterpolateTargetTick+subPredictTargetTick;\n            if (subidiff < 0)\n            {\n                ++interpolateTargetTick;\n                subidiff = -subidiff;\n            }\n            else if (subidiff > 0)\n            {\n                idiff = (uint)subidiff;\n                subidiff -= idiff;\n                interpolateTargetTick -= idiff;\n                subidiff = 1f-subidiff;\n            }\n            subInterpolateTargetTick = subidiff;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它是根据网络延迟算出一个tick,然后从快照中取出..."}]},{"type":"element","tag":"h1","props":{"id":"补偿"},"children":[{"type":"text","value":"补偿"}]},{"type":"element","tag":"h1","props":{"id":"ghostsendsystem"},"children":[{"type":"text","value":"GhostSendSystem"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下皆为脑补:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"发送的时候根据ghost的设置,来判断发送给该用户的数据(ghosts),其中谁是插值,谁是预测..因为插值和预测的包应该是有区别的.."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接收的时候再根据是否预测,还是插值.进行PredictedGhostComponent的设置"}]},{"type":"element","tag":"h2","props":{"id":"ghost"},"children":[{"type":"text","value":"GHOST"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GhostAuthoringComponent验证的时候会生成prefabId"}]},{"type":"element","tag":"pre","props":{"code":"    if (gameObject.transform.parent == null)\n            {\n                // The common case is a root object in a prefab, in this case we always validate the guid to detect cloned files\n                var prefabStage = UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetPrefabStage(gameObject);\n                if (prefabStage != null)\n                {\n#if UNITY_2020_1_OR_NEWER\n                    var assetPath = prefabStage.assetPath;\n#else\n                    var assetPath = prefabStage.prefabAssetPath;\n#endif\n                    guid = UnityEditor.AssetDatabase.AssetPathToGUID(assetPath);\n                }\n                else if (UnityEditor.PrefabUtility.GetPrefabAssetType(gameObject) != UnityEditor.PrefabAssetType.NotAPrefab)\n                {\n                    var path = UnityEditor.AssetDatabase.GetAssetPath(gameObject);\n                    if (String.IsNullOrEmpty(path))\n                        return;\n                    guid = UnityEditor.AssetDatabase.AssetPathToGUID(path);\n                }\n            }\n            if (guid != prefabId)\n            {\n                UnityEditor.Undo.RecordObject(this, \"\");\n                prefabId = guid;\n            }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    if (gameObject.transform.parent == null)\n            {\n                // The common case is a root object in a prefab, in this case we always validate the guid to detect cloned files\n                var prefabStage = UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetPrefabStage(gameObject);\n                if (prefabStage != null)\n                {\n#if UNITY_2020_1_OR_NEWER\n                    var assetPath = prefabStage.assetPath;\n#else\n                    var assetPath = prefabStage.prefabAssetPath;\n#endif\n                    guid = UnityEditor.AssetDatabase.AssetPathToGUID(assetPath);\n                }\n                else if (UnityEditor.PrefabUtility.GetPrefabAssetType(gameObject) != UnityEditor.PrefabAssetType.NotAPrefab)\n                {\n                    var path = UnityEditor.AssetDatabase.GetAssetPath(gameObject);\n                    if (String.IsNullOrEmpty(path))\n                        return;\n                    guid = UnityEditor.AssetDatabase.AssetPathToGUID(path);\n                }\n            }\n            if (guid != prefabId)\n            {\n                UnityEditor.Undo.RecordObject(this, \"\");\n                prefabId = guid;\n            }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GhostAuthoringConversion,会为prefab根据client和server添加各种组件ghost, Snapshot"}]},{"type":"element","tag":"pre","props":{"code":"    var ghostType = new GhostTypeComponent();\n    ghostType.guid0 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(0, 8), 16);\n    ghostType.guid1 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(8, 8), 16);\n    ghostType.guid2 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(16, 8), 16);\n    ghostType.guid3 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(24, 8), 16);\n    DstEntityManager.AddComponentData(entity, ghostType);\n                    \n                    \n                    \n                    \n  DstEntityManager.AddComponentData(entity, new GhostComponent());\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    var ghostType = new GhostTypeComponent();\n    ghostType.guid0 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(0, 8), 16);\n    ghostType.guid1 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(8, 8), 16);\n    ghostType.guid2 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(16, 8), 16);\n    ghostType.guid3 = Convert.ToUInt32(ghostAuthoring.prefabId.Substring(24, 8), 16);\n    DstEntityManager.AddComponentData(entity, ghostType);\n                    \n                    \n                    \n                    \n  DstEntityManager.AddComponentData(entity, new GhostComponent());\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认一定会添加的组件:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"客户端会添加 snapshotData和snapshotDataBuffer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务端会添加PredictedGhostComponent,GhostSystemStateComponent,sharedGhostTypeComponent"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[GhostComponent(PrefabType=GhostPrefabType.Client)] 可以控制服务端和客户端是否添加该组件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他会同步ghost prefab..根据ghostid..然后客户端.根据ghostid实例化ghost"}]},{"type":"element","tag":"pre","props":{"code":"    public struct SpawnedGhost : IEquatable<SpawnedGhost>\n    {\n        public int ghostId;\n        public uint spawnTick;\n        public override int GetHashCode()\n        {\n            return ghostId;\n        }\n        public bool Equals(SpawnedGhost ghost)\n        {\n            return ghost.ghostId == ghostId && ghost.spawnTick == spawnTick;\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public struct SpawnedGhost : IEquatable<SpawnedGhost>\n    {\n        public int ghostId;\n        public uint spawnTick;\n        public override int GetHashCode()\n        {\n            return ghostId;\n        }\n        public bool Equals(SpawnedGhost ghost)\n        {\n            return ghost.ghostId == ghostId && ghost.spawnTick == spawnTick;\n        }\n    }\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"预测","depth":2,"text":"预测","children":[{"id":"translation和rotation的转换","depth":3,"text":"Translation和Rotation的转换"},{"id":"clientservertickrate","depth":3,"text":"ClientServerTickRate"}]},{"id":"ghost","depth":2,"text":"GHOST"}]}},"_type":"markdown","_id":"content:unity:2020-11-18-netcode-sourcecode.md","_source":"content","_file":"unity/2020-11-18-netcode-sourcecode.md","_extension":"md","date":"2020-11-18"},{"_path":"/unity/2020-11-29-pitch-yaw-roll","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"pitch yaw roll是什么","description":"三维空间的右手笛卡尔坐标如图1所示。图1在航空中，pitch, yaw, roll如图2所示。pitch是围绕X轴旋转，也叫做俯仰角，如图3所示。yaw是围绕Y轴旋转，也叫偏航角，如图4所示。roll是围绕Z轴旋转，也叫翻滚角，如图5所示。图2图3-pitch是围绕X轴旋转图4-yaw是围绕Y轴旋转图5-roll是围绕Z轴旋转绕三个轴的旋转值pitch，yaw，roll来自航空界的叫法，翻译为俯仰角，偏航角，翻滚角，非常形象。\n从英文意思出发，roll:是卷；滚动，转动；辗的意思；\nyaw是（火箭、飞机、宇宙飞船等）偏航的意思；\npitch是坠落；倾斜；投掷的意思；\n所以，roll的意思是翻滚","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"三维空间的右手笛卡尔坐标如图1所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183456562"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在航空中，pitch, yaw, roll如图2所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pitch是围绕X轴旋转，也叫做俯仰角，如图3所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"yaw是围绕Y轴旋转，也叫偏航角，如图4所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"roll是围绕Z轴旋转，也叫翻滚角，如图5所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183507359"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183518578"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图3-pitch是围绕X轴旋转"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183525562"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图4-yaw是围绕Y轴旋转"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183537890"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图5-roll是围绕Z轴旋转"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"绕三个轴的旋转值pitch，yaw，roll来自航空界的叫法，翻译为俯仰角，偏航角，翻滚角，非常形象。\n从英文意思出发，roll:是卷；滚动，转动；辗的意思；\nyaw是（火箭、飞机、宇宙飞船等）偏航的意思；\npitch是坠落；倾斜；投掷的意思；\n所以，roll的意思是翻滚，就是绕着机身所在的那个轴。yaw是偏航的意思，偏航就是绕着重力方向为轴。pitch倾斜、坠落的意思（头朝地坠落）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外值得注意的是，pitch值是不能超过90度，这里牵扯到了万向锁的知识，不再多说，网上很多讨论。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面这张图是以摄像机的角度来阐述欧拉角的，可以加深理解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20151125212621964"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-29-pitch-yaw-roll.md","_source":"content","_file":"unity/2020-11-29-pitch-yaw-roll.md","_extension":"md","date":"2020-11-29"},{"_path":"/unity/2020-12-20-collection-has-not-been-disposed","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","description":"A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.\n启用堆栈跟踪单击 Unity 菜单中的 Jobs > Leak Detection > Full Stack Traces 以选中它。还有记得重启unity然后，控制台中的错误内容将显示内存泄漏发生在数据保留位置。A Native Collection has not been disposed, resulting in a memory leak. Alloca","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"f:id:sugar_affordance:20201110091446p","src":"/images/2020-12-20-Collection-has-not-been-disposed/20201110091446.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.\n"}]}]},{"type":"element","tag":"h3","props":{"id":"启用堆栈跟踪"},"children":[{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%B9%A5%BF%A5%C3%A5%AF%A5%C8%A5%EC%A1%BC%A5%B9","rel":["nofollow"]},"children":[{"type":"text","value":"启用"}]},{"type":"text","value":"堆栈跟踪"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单击 Unity 菜单中的 Jobs > Leak Detection > Full Stack Traces 以选中它。还有记得重启unity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"f:id:sugar_affordance:20201110091520p","src":"/images/2020-12-20-Collection-has-not-been-disposed/20201110091520.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，控制台中的错误内容将显示内存"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"泄漏"}]},{"type":"text","value":"发生在数据保留位置。"}]},{"type":"element","tag":"pre","props":{"code":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:\nUnity.Entities.BlobAssetStore:.ctor() (at Library/PackageCache/com.unity.entities@0.16.0-preview.21/Unity.Entities.Hybrid/GameObjectConversion/BlobAssetStore.cs:26)\nCreateEntitySystem:Setup(Transform) (at Assets/0_MainAssets/Scripts/ECS/System/CreateEntitySystem.cs:116)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:\nUnity.Entities.BlobAssetStore:.ctor() (at Library/PackageCache/com.unity.entities@0.16.0-preview.21/Unity.Entities.Hybrid/GameObjectConversion/BlobAssetStore.cs:26)\nCreateEntitySystem:Setup(Transform) (at Assets/0_MainAssets/Scripts/ECS/System/CreateEntitySystem.cs:116)\n"}]}]},{"type":"element","tag":"h4","props":{"id":"关于分配器"},"children":[{"type":"text","value":"关于分配器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NativeContainer（如 NativeArray）在 Dispose 中未释放内存时，会根据某些条件"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"检测"}]},{"type":"text","value":"为内存泄漏。 条件"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"因分配器"}]},{"type":"text","value":"的类型而异，分配器是 Allocator.TempJob，在确保本机 Array 时指定。"}]},{"type":"element","tag":"pre","props":{"code":"NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob);\n","language":"cs","meta":"","className":["language-cs"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个详细的解释。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ja/current/Manual/JobSystemNativeContainer.html","rel":["nofollow"]},"children":[{"type":"text","value":"NativeContainer - Unity 手册"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如果 Allocator.Temp"}]},{"type":"text","value":"在函数中没有 Dispose， 否则内存"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"泄漏"}]},{"type":"text","value":"，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"确定 Allocator.TempJob"}]},{"type":"text","value":"必须在\n4 帧内释放， 否则内存"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"泄漏确定"}]},{"type":"text","value":"__Allocator.Persistent 将永久保留，"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"并且不会"}]},{"type":"text","value":"检测到内存泄漏。"}]},{"type":"element","tag":"h3","props":{"id":"用-using-括起来确保内存安全"},"children":[{"type":"text","value":"用 using 括起来，确保内存安全"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"知道泄漏的位置后，我们只是将变量放在 Dispose 中，但**建议在 using"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%B9%A5%C6%A1%BC%A5%C8%A5%E1%A5%F3%A5%C8","rel":["nofollow"]},"children":[{"type":"text","value":"语句"}]},{"type":"text","value":"**中括起来。"}]},{"type":"element","tag":"pre","props":{"code":"using (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n","language":"cs","meta":"","className":["language-cs"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样，当您离开块时，将自动释放变量。\n当有多个变量时，请并排排列它们。"}]},{"type":"element","tag":"pre","props":{"code":"using (NativeArray<ArchetypeChunk> chunks = AnimationBatcherQuery.CreateArchetypeChunkArray(Allocator.TempJob))\nusing (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n","language":"cs","meta":"","className":["language-cs"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (NativeArray<ArchetypeChunk> chunks = AnimationBatcherQuery.CreateArchetypeChunkArray(Allocator.TempJob))\nusing (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/C%23","rel":["nofollow"]},"children":[{"type":"text","value":"从 C#"}]},{"type":"text","value":"8 开始，您可以在 Coco 中并排编写句点，但 Unity 现在"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/C%23","rel":["nofollow"]},"children":[{"type":"text","value":"像 C#"}]},{"type":"text","value":"7.3 一样，将来会起作用吗？"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"启用堆栈跟踪","depth":3,"text":"启用堆栈跟踪"},{"id":"用-using-括起来确保内存安全","depth":3,"text":"用 using 括起来，确保内存安全"}]}},"_type":"markdown","_id":"content:unity:2020-12-20-Collection-has-not-been-disposed.md","_source":"content","_file":"unity/2020-12-20-Collection-has-not-been-disposed.md","_extension":"md","date":"2020-12-20"},{"_path":"/unity/2021-01-24-screentoworld","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"解决Unity鼠标坐标点转成世界坐标系坐标点","description":"使用射线这是一种发射线，获取当前点击的物体（具有碰撞器）的坐标点（也就是碰撞器范围的坐标点）if (Input.GetMouseButtonDown(0))\n{\n\n    RaycastHit hitt = new RaycastHit();\n\n    Ray ray =Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    Physics.Raycast(ray, out hitt);\n\n    Debug.Log(hitt.point);\n\n    //Debug.Log(Camera.main.ScreenToWorldPoint(","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"使用射线"},"children":[{"type":"text","value":"使用射线"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一种发射线，获取当前点击的物体（具有碰撞器）的坐标点（也就是碰撞器范围的坐标点）"}]},{"type":"element","tag":"pre","props":{"code":"if (Input.GetMouseButtonDown(0))\n{\n\n    RaycastHit hitt = new RaycastHit();\n\n    Ray ray =Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    Physics.Raycast(ray, out hitt);\n\n    Debug.Log(hitt.point);\n\n    //Debug.Log(Camera.main.ScreenToWorldPoint(Input.mousePosition));\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (Input.GetMouseButtonDown(0))\n{\n\n    RaycastHit hitt = new RaycastHit();\n\n    Ray ray =Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    Physics.Raycast(ray, out hitt);\n\n    Debug.Log(hitt.point);\n\n    //Debug.Log(Camera.main.ScreenToWorldPoint(Input.mousePosition));\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"直接转换"},"children":[{"type":"text","value":"直接转换"}]},{"type":"element","tag":"pre","props":{"code":" void Update()\n {\n    if(Input.GetMouseButtonDown(0))\n   {    \n     var  z = target.transform.position.z - camera.transform.position.z;\n     Debug.Log(TempC.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, z)));\n    }\n }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" void Update()\n {\n    if(Input.GetMouseButtonDown(0))\n   {    \n     var  z = target.transform.position.z - camera.transform.position.z;\n     Debug.Log(TempC.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, z)));\n    }\n }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"摄像机对游戏世界的渲染范围是一个平截头体，渲染边界是一个矩形，用与near clippingplane或者far clippingplane平行的平面截取这个平截头体，可以获得无数个平行的矩形面，也就是我们看到的屏幕矩形。离摄像机越远，矩形越大，离摄像机越近，矩形越小。所以，同样大小的物体，随着离摄像机越来越远，相对于对应屏幕矩形就越来越小，所看起来就越来越小。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在屏幕上，某个像素点相对于屏幕矩形的位置，可以对应于游戏世界中的点相对于某个截面的位置，关键在于这个点在哪个截面上，也就是说，关键在于这个截面离摄像机有多远！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在ScreenToWorldPoint这个方法中，参数是一个三维坐标，而实际上，屏幕坐标只能是二维坐标。参数中的z坐标的作用就是：用来表示上述平面离摄像机的距离。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就是说，给定一个坐标（X，Y，Z），"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先截取一个垂直于摄像机Z轴的，距离为Z的平面P，这样不管X，Y怎么变化，返回的点都只能在这个平面上；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，X，Y表示像素坐标，根据（X，Y）相对于屏幕的位置，得到游戏世界中的点相对于截面P的位置，我们也就将屏幕坐标转换为了世界坐标。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以如果要判断是否点中一个目标,则传入的z的值即你想选中的目标到摄像机的距离"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"使用射线","depth":2,"text":"使用射线"},{"id":"直接转换","depth":2,"text":"直接转换"}]}},"_type":"markdown","_id":"content:unity:2021-01-24-screentoworld.md","_source":"content","_file":"unity/2021-01-24-screentoworld.md","_extension":"md","date":"2021-01-24"},{"_path":"/unity/2021-01-25-tilemap","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"2021 01 25 Tilemap","description":"B站圈毛君翻译教程：The Basic：https://www.bilibili.com/video/av48965588/Rule Tile：https://www.bilibili.com/video/av49083381/Prefab Brush：https://www.bilibili.com/video/av49098444/Tilemap Collider：https://www.bilibili.com/video/av49115670/TileBaseGetTileData 确定瓦片在瓦片地图上的外观 ,相当于滚动列表中的getdata..获取数据用于显示,,RefreshTi","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"b站圈毛君翻译教程"},"children":[{"type":"text","value":"B站圈毛君翻译教程："}]},{"type":"element","tag":"h3","props":{"id":"the-basichttpswwwbilibilicomvideoav48965588"},"children":[{"type":"text","value":"The Basic："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av48965588/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av48965588/"}]}]},{"type":"element","tag":"h3","props":{"id":"rule-tilehttpswwwbilibilicomvideoav49083381"},"children":[{"type":"text","value":"Rule Tile："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av49083381/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av49083381/"}]}]},{"type":"element","tag":"h3","props":{"id":"prefab-brushhttpswwwbilibilicomvideoav49098444"},"children":[{"type":"text","value":"Prefab Brush："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av49098444/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av49098444/"}]}]},{"type":"element","tag":"h3","props":{"id":"tilemap-colliderhttpswwwbilibilicomvideoav49115670"},"children":[{"type":"text","value":"Tilemap Collider："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av49115670/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av49115670/"}]}]},{"type":"element","tag":"h1","props":{"id":"tilebase"},"children":[{"type":"text","value":"TileBase"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetTileData"}]},{"type":"text","value":" 确定瓦片在瓦片地图上的外观 ,相当于滚动列表中的getdata..获取数据用于显示,,RefreshTile后会触发"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"b站圈毛君翻译教程","depth":3,"text":"B站圈毛君翻译教程："},{"id":"the-basichttpswwwbilibilicomvideoav48965588","depth":3,"text":"The Basic：https://www.bilibili.com/video/av48965588/"},{"id":"rule-tilehttpswwwbilibilicomvideoav49083381","depth":3,"text":"Rule Tile：https://www.bilibili.com/video/av49083381/"},{"id":"prefab-brushhttpswwwbilibilicomvideoav49098444","depth":3,"text":"Prefab Brush：https://www.bilibili.com/video/av49098444/"},{"id":"tilemap-colliderhttpswwwbilibilicomvideoav49115670","depth":3,"text":"Tilemap Collider：https://www.bilibili.com/video/av49115670/"}]}},"_type":"markdown","_id":"content:unity:2021-01-25-tilemap.md","_source":"content","_file":"unity/2021-01-25-tilemap.md","_extension":"md","date":"2021-01-25"},{"_path":"/unity/2021-04-11-render-texture","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity RenderTexture的应用","description":"1. UGUI上显示模型UGUI上显示模型.png创建拍摄用的摄像机创建RenderTexture并绑定到摄像机camera.targetTexture上RenderTexture绑定到rawImage.texture上（rawImage见上图）创建显示的模型，相机可见注意Destroy销毁 创建出来的RenderTexture 和相机注意模型上的粒子特效由于Alpha透明通道，显示会有一点问题，可以通过Shader Blend混合处理，挂载在rawImage上。public void CreateCamera(Vector3 pos, Vector3 rot, int width, int ","body":{"type":"root","children":[{"type":"element","tag":"h4","props":{"id":"_1-ugui上显示模型"},"children":[{"type":"text","value":"1. UGUI上显示模型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/4276633-05b67353425f7248.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI上显示模型.png"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建拍摄用的摄像机"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建RenderTexture并绑定到摄像机camera.targetTexture上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RenderTexture绑定到rawImage.texture上（rawImage见上图）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建显示的模型，相机可见"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意Destroy销毁 创建出来的RenderTexture 和相机"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意模型上的粒子特效由于Alpha透明通道，显示会有一点问题，可以通过Shader Blend混合处理，挂载在rawImage上。"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public void CreateCamera(Vector3 pos, Vector3 rot, int width, int height, string layerName, float size)\n{\n    // 创建拍摄用的摄像机\n    GameObject go = new GameObject(\"ModelCamera\");\n    _camera = go.AddComponent<Camera>();\n    _camera.clearFlags = CameraClearFlags.SolidColor;\n    _camera.transform.position = pos;\n    _camera.transform.rotation = Quaternion.Euler(rot);\n    _camera.cullingMask = LayerMask.GetMask(layerName);\n    _camera.orthographic = true;\n    _camera.orthographicSize = size;\n    _camera.backgroundColor = new Color(0,0,0,0);\n\n    // 创建RenderTexture并绑定到摄像机上\n    _renderTexture = new RenderTexture(width, height, 8);\n    _camera.targetTexture = _renderTexture;\n\n    if (_rawImage != null)\n    {\n        _rawImage.texture = _renderTexture;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void CreateCamera(Vector3 pos, Vector3 rot, int width, int height, string layerName, float size)\n{\n    // 创建拍摄用的摄像机\n    GameObject go = new GameObject(\"ModelCamera\");\n    _camera = go.AddComponent<Camera>();\n    _camera.clearFlags = CameraClearFlags.SolidColor;\n    _camera.transform.position = pos;\n    _camera.transform.rotation = Quaternion.Euler(rot);\n    _camera.cullingMask = LayerMask.GetMask(layerName);\n    _camera.orthographic = true;\n    _camera.orthographicSize = size;\n    _camera.backgroundColor = new Color(0,0,0,0);\n\n    // 创建RenderTexture并绑定到摄像机上\n    _renderTexture = new RenderTexture(width, height, 8);\n    _camera.targetTexture = _renderTexture;\n\n    if (_rawImage != null)\n    {\n        _rawImage.texture = _renderTexture;\n    }\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"_2-camera相机拍照分享保存为jpg"},"children":[{"type":"text","value":"2. Camera相机拍照分享，保存为jpg"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"private IEnumerator CameraPhoto(Camera cam, Rect rect, string name) {\n    if (rt == null) {\n        rt = RenderTexture.GetTemporary(renderTextureDesc);\n    }\n    cam.targetTexture = rt;\n    cam.Render();\n\n    RenderTexture currentActiveRT = RenderTexture.active;\n    RenderTexture.active = rt;\n    Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false);\n    screenShot.ReadPixels(rect, 0, 0);\n    screenShot.Apply();\n    yield return new WaitForEndOfFrame();\n\n    cam.targetTexture = null;\n    RenderTexture.active = currentActiveRT;\n\n    byte[] bytes = screenShot.EncodeToJPG();\n    string file = Application.dataPath + \"/Texture/\" + name;\n    System.IO.File.WriteAllBytes(file, bytes);\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private IEnumerator CameraPhoto(Camera cam, Rect rect, string name) {\n    if (rt == null) {\n        rt = RenderTexture.GetTemporary(renderTextureDesc);\n    }\n    cam.targetTexture = rt;\n    cam.Render();\n\n    RenderTexture currentActiveRT = RenderTexture.active;\n    RenderTexture.active = rt;\n    Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false);\n    screenShot.ReadPixels(rect, 0, 0);\n    screenShot.Apply();\n    yield return new WaitForEndOfFrame();\n\n    cam.targetTexture = null;\n    RenderTexture.active = currentActiveRT;\n\n    byte[] bytes = screenShot.EncodeToJPG();\n    string file = Application.dataPath + \"/Texture/\" + name;\n    System.IO.File.WriteAllBytes(file, bytes);\n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Rendertexture的分配和销毁上有一个地方需要注意：\n如果频繁的要new一个rt出来，那么不要直接new，而是使用RenderTexture提供的GetTemporary和ReleaseTemporary，它将在内部维护一个池，反复重用一些大小格式一样的rt资源，因为让GPU为你分配一个新的texture其实是要耗时间的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"EncodeToJPG 生成的图片体积更小"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"有的时候我们想人为的控制每一次渲染，你可以将这个摄像机disable掉，然后手动的调用一次render。"}]},{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"_3-制作小地图"},"children":[{"type":"text","value":"3. 制作小地图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-153a6a121210c7f7.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里需要新建一个Layer。依次点击菜单项Edit -> Project Settings -> Tags and Layers新建Layer命名为Minimap。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-f96f6a1a4c01bae2.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后新建三个球体。一个设为蓝色代表Unity Chan。将该球体设为Unity Chan的子对象，并将其Layer设为Minimap。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-dfdc8f16823fbf32.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对两个机器人进行同样的操作，将球体改为红色。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-4b34ec3b3279e6aa.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在最关键的一步来了！选中Main Camera并确保其Culling Mask中不包括Minimap这一层。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-1eb8533ebe757f7d.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后选中Minimap Camera让其Culling Mask只包括Minimap这一层。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-e16613658b088db8.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在这个小地图看起来就比较完善了！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-694ef4f538aae2e1.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-04-11-render-texture.md","_source":"content","_file":"unity/2021-04-11-render-texture.md","_extension":"md","date":"2021-04-11"},{"_path":"/unity/2021-05-20-ecs-commandbuff-question","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"commandbuff的一些问题","description":"componentpublic struct State:IComponentData\n{\n    public int a;\n} \na系统\n var PostUpdateCommands = World.GetExistingSystem<AbilityUpdateCommandBufferSystem>().CreateCommandBuffer();\nEntities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        st","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"component"}]},{"type":"element","tag":"pre","props":{"code":"public struct State:IComponentData\n{\n    public int a;\n} \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public struct State:IComponentData\n{\n    public int a;\n} \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a系统"}]},{"type":"element","tag":"pre","props":{"code":"\n var PostUpdateCommands = World.GetExistingSystem<AbilityUpdateCommandBufferSystem>().CreateCommandBuffer();\nEntities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 1111;\n        PostUpdateCommands.SetComponent(entity,state);\n    })\n    .WithoutBurst()\n    .Run();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n var PostUpdateCommands = World.GetExistingSystem<AbilityUpdateCommandBufferSystem>().CreateCommandBuffer();\nEntities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 1111;\n        PostUpdateCommands.SetComponent(entity,state);\n    })\n    .WithoutBurst()\n    .Run();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"b系统"}]},{"type":"element","tag":"pre","props":{"code":"Entities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 2222;\n        EntityManager.SetComponentData(entity,state);\n    })\n     .WithStructuralChanges()\n    .Run();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Entities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 2222;\n        EntityManager.SetComponentData(entity,state);\n    })\n     .WithStructuralChanges()\n    .Run();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行顺序"}]},{"type":"element","tag":"pre","props":{"code":"A-->B-->AbilityUpdateCommandBufferSystem\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"A-->B-->AbilityUpdateCommandBufferSystem\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里的结果,我们以为是2222.其实是1111."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以要么全是使用commandbuff.否则容易造成数据错误"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-05-20-ecs-commandbuff-question.md","_source":"content","_file":"unity/2021-05-20-ecs-commandbuff-question.md","_extension":"md","date":"2021-05-20"},{"_path":"/unity/2021-06-13-how-to-make-one-way-platform","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"How to Make One Way Platform in unity","description":"Hello Readers, I'll Show you how to make simple one way platform. It is simple, useful and efficient technique to achieve this result. Here is the procedure --","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hello Readers, I'll Show you how to make simple one way platform. It is simple, useful and efficient technique to achieve this result. Here is the procedure --"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make a Simple platform using Box collider."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make a new game object children of the platform and add a box collider just below the original platform as shown in image and tick its 'is trigger' checkbox so that we can check player's collision in it."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"111","src":"/images/2021-06-13-How-to-Make-One-Way-Platform/111-1623584452229.jpg"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Create a new Script to the game object we create in step 2 and assign the following script --"}]}]},{"type":"element","tag":"pre","props":{"code":"//the collider of the main visible platform\nvar platform : BoxCollider2D;\n//this variable is true when the players is just below the platform so that its Box collider can be disabled that will allow the player to pass through the platform\nvar oneway : boolean;\n\n\nfunction Update () {\n    //Enabling or Disabling the platform's Box collider to allowing player to pass\n    if (oneway)\n     platform.enabled=false;\n     if (!oneway)\n     platform.enabled=true; \n}\n//Checking the collison of the gameobject we created in step 2 for checking if the player is just below the platform and nedded to ignore the collison to the platform\nfunction OnTriggerStay2D(other: Collider2D) {\n   oneway = true;\n}\n\nfunction OnTriggerExit2D(other: Collider2D) {\n//Just to make sure that the platform's Box Collider does not get permantly disabled and it should be enabeled once the player get its through\n   oneway = false;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//the collider of the main visible platform\nvar platform : BoxCollider2D;\n//this variable is true when the players is just below the platform so that its Box collider can be disabled that will allow the player to pass through the platform\nvar oneway : boolean;\n\n\nfunction Update () {\n    //Enabling or Disabling the platform's Box collider to allowing player to pass\n    if (oneway)\n     platform.enabled=false;\n     if (!oneway)\n     platform.enabled=true; \n}\n//Checking the collison of the gameobject we created in step 2 for checking if the player is just below the platform and nedded to ignore the collison to the platform\nfunction OnTriggerStay2D(other: Collider2D) {\n   oneway = true;\n}\n\nfunction OnTriggerExit2D(other: Collider2D) {\n//Just to make sure that the platform's Box Collider does not get permantly disabled and it should be enabeled once the player get its through\n   oneway = false;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I've made a simple ball game to illustrate the application of the one way platforms. You can download the example project folder below. --"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-06-13-How-to-Make-One-Way-Platform.md","_source":"content","_file":"unity/2021-06-13-How-to-Make-One-Way-Platform.md","_extension":"md","date":"2021-06-13"},{"_path":"/unity/2021-06-14-unity-render-order","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY的渲染顺序","description":"工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gist.github.com/qxsoftware/499135b6482ca57727c69e11b91a12bf","rel":["nofollow"]},"children":[{"type":"text","value":"MeshRendererInspector.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/mesh-renderer-inspector.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何添加新的 SortingLayer？请通过 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Edit/Project Settings/Tags and Layers"}]},{"type":"text","value":" 菜单选项打开："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/tags-layers.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后添加三个 Sorting Layer，如上图所示。注意，Sorting Layer 添加后是可以拖动调整顺序的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"便捷修改 Camera 的 opaqueSortMode 和 transparencySortMode："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gist.github.com/qxsoftware/1821915377e333e45f7a632ae07e64aa","rel":["nofollow"]},"children":[{"type":"text","value":"CameraInspector.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/sort-mode.jpg"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"实际测试"},"children":[{"type":"text","value":"实际测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试之前首先明确两点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"什么因素影响绘制顺序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"深度缓冲区对绘制结果的影响"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了弄清楚第一点，什么因素影响绘制顺序，我们需要把 ZWrite 关闭。同时结合 Unity Frame Debugger来观察绘制顺序。"}]},{"type":"element","tag":"h5","props":{"id":"render-queue"},"children":[{"type":"text","value":"Render Queue"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RenderQueue 是材质（Material）的关键属性，当我们在 Unity 中创建一个材质后，Unity 会给这个材质设置一个默认 Shader，然后这个材质的 RenderQueue 被改为其 Shader 中设定的 RenderQueue。如果给这个材质球换了 Shader，Unity 会更新它的 RenderQueue（但是请注意，假如当前材质的 Shader 的 RenderQueue 是 3000，然后你修改 Shader 让其 RenderQueue 变成 3100，对应材质球的 RenderQueue 并不会更新！）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unity 最终以 Material 的 RenderQueue 为准。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 内置了几个 RenderQueue 的字面值："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"RenderQueue"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"值"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Background"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"这个渲染队列最先渲染，一般用于渲染背景"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Geometry(默认值)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"这个渲染队列是大多数物体的默认队列，用于渲染不透明物体"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"AlphaTest"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2450"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"使用了 AlphaTest 的物体在这个队列渲染，当所有的不透明物体都渲染完了再渲染这个，有助于提升性能"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Transparent"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"在 Geometry 和 AlphaTest 之后、从后往前渲染，所有的半透明物体都应该在这里渲染"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Overlay"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"在之前的所有渲染队列都渲染完了之后渲染，比如镜头光晕"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到，RenderQueue 越大，渲染越靠后。"}]},{"type":"element","tag":"h5","props":{"id":"cameraopaquesortmode"},"children":[{"type":"text","value":"Camera.opaqueSortMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下，不透明物体被放在粗略分隔的从前往后排布的桶中，GPU 按照这种方式渲染能节省性能。但是也有部分 GPU 不这么干，比如 PowerVR。Camera.opaqueSortMode 这个值的默认值是 Dafault，根据不同硬件平台，这个值有可能是：OpaqueSortMode.FrontToBack 或者 OpaqueSortMode.NoDistanceSort。我们也可以主动设置这个值为某一种。比如为了减少 CPU 消耗，把这个值设置为 NoDistanceSort。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，不透明物体大部分情况下是按照从前往后渲染，也就是离相机越近，越先渲染。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果是手动选择了 FrontToBack，就是从前往后渲染；如果是 NoDistanceSort，就是从后往前渲染。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据实际测试，渲染的顺序并不是完全按照物体几何中心离相机的距离进行排序，而是一个近似的排序。"}]}]},{"type":"element","tag":"h5","props":{"id":"cameratransparencysortmode"},"children":[{"type":"text","value":"Camera.transparencySortMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照我测试用的 Unity5.3.4f1，修改这个值也会影响不透明物体的渲染顺序。所以这个东西很可能不重要，而且有 bug。"}]},{"type":"element","tag":"h5","props":{"id":"sortinglayer"},"children":[{"type":"text","value":"SortingLayer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SortingLayer 拥有最高优先级，如果 SortingLayer 不同，则首先按照 SortingLayer 排序；如果 SortingLayer 相同，再按照 RenderQueue 排序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示，有 6 个立方体，分别按顺序在摄像机前排开："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/preview.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/cubes.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中，g1 组的立方体 SortingLayer 都是 Layer3，RenderQueue 都是 3000；g2 组的立方体 SortingLayer 都是 Layer2，RenderQueue 都是3500，最终渲染顺序是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"g2m1 g2m2 g2m3 g1m1 g1m2 g1m3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直观地说，就是 SortingLayer 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。SortingLayer 默认只有一个：Default，越往后添加的 SortingLayer 越大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在把 g1 组的立方体 SortingLayer 改成 Layer2，RenderQueue 改成 3600，最终渲染顺序还是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"g2m1 g2m2 g2m3 g1m1 g1m2 g1m3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直观地说，SortingLayer 相同的前提下，RenderQueue 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"h5","props":{"id":"sortingorder"},"children":[{"type":"text","value":"SortingOrder"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果 SortingLayer 和 RenderQueue 都一样，则 SortingOrder 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果只是 SortingLayer 一样，RenderQueue 和 SortingOrder 都不一样，则物体的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"由 RenderQueue 和 SortingOrder 之和决定，相加之和越大，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上结论是通过 Frame Debugger 单步执行得出的。"}]}]},{"type":"element","tag":"h5","props":{"id":"cameradepth"},"children":[{"type":"text","value":"Camera.depth"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有一个很常用的调整渲染顺序的选项：摄像机深度。摄像机深度是优先级最高的选项，深度值越大，物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。常用的比如 NGUI 就是用一个单独的相机（深度值比渲染场景的相机大）来渲染 UI，这样就保证 UI 在所有东西上方。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考资料："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://jakobknudsen.wordpress.com/2013/07/20/transparency-and-sorting/","rel":["nofollow"]},"children":[{"type":"text","value":"Transparency and sorting in Unity"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-06-14-unity-render-order.md","_source":"content","_file":"unity/2021-06-14-unity-render-order.md","_extension":"md","date":"2021-06-14"},{"_path":"/unity/2021-07-20-formerlyserializedas","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"防止变量引用丢失 FormerlySerializedAs","description":"public class shishi : MonoBehaviour\n{\n    public CameraSizeHandler CameraSize01;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset Vie","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-07-20-FormerlySerializedAs/20200110140001821.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"public class shishi : MonoBehaviour\n{\n    public CameraSizeHandler CameraSize01;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class shishi : MonoBehaviour\n{\n    public CameraSizeHandler CameraSize01;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在有一个需求，想改一改CameraSize01这个字段的名字，比如想修改为CameraSize02，并且需要将之前在监视器面板中为CameraSize01设置的各项值保留下来，如果直接修改，则会丢失属性中的值"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class shishi : MonoBehaviour\n{\n    [FormerlySerializedAs(\"CameraSize01\")]\n    public CameraSizeHandler CameraSize02;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class shishi : MonoBehaviour\n{\n    [FormerlySerializedAs(\"CameraSize01\")]\n    public CameraSizeHandler CameraSize02;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-07-20-FormerlySerializedAs.md","_source":"content","_file":"unity/2021-07-20-FormerlySerializedAs.md","_extension":"md","date":"2021-07-20"},{"_path":"/unity/2021-08-01-ai-planner","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"AI-PLANNER使用","description":"定义实体和组件SemanticObject  为gameobject添加各种componentTraits : 相当于component.可以定义各种属性定义处理系统Problem  依托 DecisionController运行计划StateTermination  为Problem  提供中止条件SemanticQuery   根据query为 DecisionController提供实体Action : 相当于一个特殊的system的基类.他定义了参数,和处理条件.以及effects和reward,但是没有实现具体的方法(executionInfo),executionInfo是需要手动","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"定义实体和组件"},"children":[{"type":"text","value":"定义实体和组件"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SemanticObject  为gameobject添加各种component"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Traits : 相当于component.可以定义各种属性"}]}]},{"type":"element","tag":"h2","props":{"id":"定义处理系统"},"children":[{"type":"text","value":"定义处理系统"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Problem  依托 DecisionController运行计划"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"StateTermination  为Problem  提供中止条件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SemanticQuery   根据query为 DecisionController提供实体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Action : 相当于一个特殊的system的基类.他定义了参数,和处理条件.以及effects和reward,但是没有实现具体的方法(executionInfo),executionInfo是需要手动定义的"},{"type":"element","tag":"pre","props":{"code":"    public abstract class PlannerActionSystem : SystemBase\n    {\n\n        List<ParameterDefinition> m_Parameters = new List<ParameterDefinition>();\n\n\n        List<Operation> m_Preconditions = new List<Operation>();\n\n\n\n        List<ParameterDefinition> m_CreatedObjects = new List<ParameterDefinition>();\n\n\n        List<string> m_RemovedObjects = new List<string>();\n\n\n        List<Operation> m_ObjectModifiers = new List<Operation>();\n\n\n        float m_Reward;\n\n        List<CustomRewardData> m_CustomRewards;\n\n\n        Unity.AI.Planner.Controller.ActionExecutionInfo executionInfo;\n\n\n        protected override void OnUpdate()\n        {\n            //检查条件\n\n            //将参数传给executionInfo\n\n            //然后执行方法\n            \n            \n            //处理effect.对object进行修改,创建,删除\n            \n            //然后处理reward\n            \n        }\n\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public abstract class PlannerActionSystem : SystemBase\n    {\n\n        List<ParameterDefinition> m_Parameters = new List<ParameterDefinition>();\n\n\n        List<Operation> m_Preconditions = new List<Operation>();\n\n\n\n        List<ParameterDefinition> m_CreatedObjects = new List<ParameterDefinition>();\n\n\n        List<string> m_RemovedObjects = new List<string>();\n\n\n        List<Operation> m_ObjectModifiers = new List<Operation>();\n\n\n        float m_Reward;\n\n        List<CustomRewardData> m_CustomRewards;\n\n\n        Unity.AI.Planner.Controller.ActionExecutionInfo executionInfo;\n\n\n        protected override void OnUpdate()\n        {\n            //检查条件\n\n            //将参数传给executionInfo\n\n            //然后执行方法\n            \n            \n            //处理effect.对object进行修改,创建,删除\n            \n            //然后处理reward\n            \n        }\n\n    }\n"}]}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"actions"},"children":[{"type":"text","value":"actions"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"motives  相当于 preconditions   ..需要一些设定才会执行这个"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Requirements   也可以使用preconditions代替   ,"}]}]},{"type":"element","tag":"h2","props":{"id":"domain"},"children":[{"type":"text","value":"domain"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"维护了一个entities列表,当entity触发了OnTriggerEnter事件会增加到这个列表中."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"aiplanner倒是不需要这个..他们是通过entity和component进行目标查找的"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"定义实体和组件","depth":2,"text":"定义实体和组件"},{"id":"定义处理系统","depth":2,"text":"定义处理系统"},{"id":"actions","depth":2,"text":"actions"},{"id":"domain","depth":2,"text":"domain"}]}},"_type":"markdown","_id":"content:unity:2021-08-01-AI-Planner.md","_source":"content","_file":"unity/2021-08-01-AI-Planner.md","_extension":"md","date":"2021-08-01"},{"_path":"/unity/2021-10-01-increased-script-assembly-reload-time","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Increased script assembly reload time","description":"Hi,\nWe found out that this particular issue is very hard to work on as domain reload depends on a lot of things:\n- Number and types of UI widgets alive in the editor\n- Quantity of code in the project (including from packages)\n- Callbacks run as part of the domain reload (InitializeOnLoad, EditorApplication events...) that can be handled by both editor, first party packages, 3rd party packages or user code\n- Topology of the project...","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hi,\nWe found out that this particular issue is very hard to work on as domain reload depends on a lot of things:\n- Number and types of UI widgets alive in the editor\n- Quantity of code in the project (including from packages)\n- Callbacks run as part of the domain reload (InitializeOnLoad, EditorApplication events...) that can be handled by both editor, first party packages, 3rd party packages or user code\n- Topology of the project..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So when we get numbers from users, about Domain Reload times, there are a lot of times where we can't find where the root issue come from."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The good news is that this is going to change !"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In next version, Unity will ship with a diagnostic switch enabling detailed domain reload timings, allowing any user to see what actually happen on domain reload. This will help us figure what are the most common problematic components and on which ones we should prioritize optimization effort. This will also help users find workarounds for improving performance (e.g. close a particularly consuming UI widget, remove a package that is not really needed in the project,...).\nShortly after, we will backport this diagnostic switch to LTS versions of Unity (current plan is to backport down to 2019.4), to allow for more precise performance comparison."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We are also working internally to leverage that diagnostic tools to detect problems earlier in packages that we ship, as part of our internal package validation suites. This is an ongoing effort though, so don't put your expectations too high on this, and please report your detailed domain reload logs as soon as you get the update !"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Domain reload detailed timings can now be enabled in 2021.2.0a20 an 2021.1.11f1 (and we are busy backporting this to 2019.4 and 2020.3).\n- In 2021.2.x it can be enabled using the diagnostics switches in Editor Preferences\n"},{"type":"element","tag":"img","props":{"alt":"upload_2021-6-14_12-14-44.png","src":"/images/2021-10-01-Increased-script-assembly-reload-time/upload_2021-6-14_12-14-44-png.871142"},"children":[]},{"type":"text","value":"\n- In 2021.1 (which does not have the diagnostic switches UI), you can enable it with the environment variable UNITY_DIAG_ENABLE_DOMAIN_RELOAD_TIMINGS.\n(e.g. in a Powershell console, you can run"}]},{"type":"element","tag":"pre","props":{"code":" $env:UNITY_DIAG_ENABLE_DOMAIN_RELOAD_TIMINGS=\"1\"; & 'C:\\Program Files\\Unity\\Hub\\Editor\\2021.1.11f1\\Editor\\Unity.exe'\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" $env:UNITY_DIAG_ENABLE_DOMAIN_RELOAD_TIMINGS=\"1\"; & 'C:\\Program Files\\Unity\\Hub\\Editor\\2021.1.11f1\\Editor\\Unity.exe'\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":")."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After that, in your editor logs ("}]},{"type":"element","tag":"pre","props":{"code":"%LOCALAPPDATA%\\Unity\\Editor\\Editor.log\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"%LOCALAPPDATA%\\Unity\\Editor\\Editor.log\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"), you'll see detailed timings on domain reload."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/any-update-regarding-increased-script-assembly-reload-time.1117138/?_ga=2.41177696.399908227.1633157438-1122779591.1605612681","rel":["nofollow"]},"children":[{"type":"text","value":"Any update regarding \"Increased script assembly reload time\"? - Unity Forum"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-10-01-Increased-script-assembly-reload-time.md","_source":"content","_file":"unity/2021-10-01-Increased-script-assembly-reload-time.md","_extension":"md","date":"2021-10-01"},{"_path":"/unity/2022-01-02-unity-hot-reload","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于unity的热重载的研究","description":"Roslyn C# - Runtime Compiler通过FileSystemWatcher监控目录检查改变的文件unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.Get","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"roslyn-c-runtime-compiler"},"children":[{"type":"text","value":"Roslyn C# - Runtime Compiler"}]},{"type":"element","tag":"h3","props":{"id":"通过filesystemwatcher监控目录检查改变的文件"},"children":[{"type":"text","value":"通过FileSystemWatcher监控目录检查改变的文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.GetFiles(folderPath,\"*.cs\", SearchOption.AllDirectories);\n    foreach (var item in fileEntries)\n    {\n        var key = Path.GetFileName(item);\n        if (Files.TryGetValue(key,out var f) == false)\n        {\n            Files.Add(key, item);\n        }\n        else\n        {\n            Debug.LogError($\"{f}和{item}的文件名相同\");\n        }\n    }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.GetFiles(folderPath,\"*.cs\", SearchOption.AllDirectories);\n    foreach (var item in fileEntries)\n    {\n        var key = Path.GetFileName(item);\n        if (Files.TryGetValue(key,out var f) == false)\n        {\n            Files.Add(key, item);\n        }\n        else\n        {\n            Debug.LogError($\"{f}和{item}的文件名相同\");\n        }\n    }\n"}]}]},{"type":"element","tag":"h3","props":{"id":"编译修改的文件并重新加载"},"children":[{"type":"text","value":"编译修改的文件并重新加载"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"  // Recompile the script\n    ScriptAssembly asm = domain.CompileAndLoadFile(path, securityMode);\n    \n    // Check for success\n    if(asm == null)\n    {\n        domain.LogCompilerOutputToConsole();\n        return;\n    }\n    \n    // Find the type for the changed source file\n    Type mainMonoType = GetMainMonoTypeForSourceFile(path);\n    \n    // Find type with matching full name\n    ScriptType reloadType = asm.FindType(mainMonoType);\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  // Recompile the script\n    ScriptAssembly asm = domain.CompileAndLoadFile(path, securityMode);\n    \n    // Check for success\n    if(asm == null)\n    {\n        domain.LogCompilerOutputToConsole();\n        return;\n    }\n    \n    // Find the type for the changed source file\n    Type mainMonoType = GetMainMonoTypeForSourceFile(path);\n    \n    // Find type with matching full name\n    ScriptType reloadType = asm.FindType(mainMonoType);\n"}]}]},{"type":"element","tag":"h3","props":{"id":"替换场景中的monobehavior"},"children":[{"type":"text","value":"替换场景中的monobehavior"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static bool ReplaceScriptsForScene(Scene targetScene, ScriptType scriptType, out ModScriptReplacerReport report, ScriptReplacerOptions options = ScriptReplacerOptions.Default)\n{\n    bool failed = false;\n    report = new ModScriptReplacerReport();\n\n    bool includeInactive = (options & ScriptReplacerOptions.ReplaceDisabledScripts) != 0;\n\n    foreach (GameObject gameObject in targetScene.GetRootGameObjects())\n    {\n        foreach (MonoBehaviour behaviour in gameObject.GetComponentsInChildren<MonoBehaviour>(includeInactive))\n        {\n            if (ReplaceScriptBehaviourImpl(behaviour, scriptType, ref report, options) == false)\n                failed = true;\n        }\n    }\n    return failed == false;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static bool ReplaceScriptsForScene(Scene targetScene, ScriptType scriptType, out ModScriptReplacerReport report, ScriptReplacerOptions options = ScriptReplacerOptions.Default)\n{\n    bool failed = false;\n    report = new ModScriptReplacerReport();\n\n    bool includeInactive = (options & ScriptReplacerOptions.ReplaceDisabledScripts) != 0;\n\n    foreach (GameObject gameObject in targetScene.GetRootGameObjects())\n    {\n        foreach (MonoBehaviour behaviour in gameObject.GetComponentsInChildren<MonoBehaviour>(includeInactive))\n        {\n            if (ReplaceScriptBehaviourImpl(behaviour, scriptType, ref report, options) == false)\n                failed = true;\n        }\n    }\n    return failed == false;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过以上可以看到明显的缺点只支持monobehavior"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若想支持非monobehavior可能需要自己进行处理"}]},{"type":"element","tag":"h2","props":{"id":"et的热重载"},"children":[{"type":"text","value":"ET的热重载"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离项目到不同的dll中"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过代码加载dll"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Reflection.Assembly.Load(assBytes, pdbBytes)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"首先进行编译dll"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"按R热加载后,通过反射,对现有的对象进行销毁,然后重新创建"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"\npublic class CodeLoader: IDisposable\n{\n    public static CodeLoader Instance = new CodeLoader();\n\n    public Action Update;\n    public Action LateUpdate;\n    public Action OnApplicationQuit;\n\n    private Assembly assembly;\n\n    private ILRuntime.Runtime.Enviorment.AppDomain appDomain;\n    \n    private Type[] allTypes;\n    \n    public CodeMode CodeMode { get; set; }\n\n    private CodeLoader()\n    {\n    }\n\n    public void Dispose()\n    {\n        this.appDomain?.Dispose();\n    }\n    \n    public void Start()\n    {\n        switch (this.CodeMode)\n        {\n            case CodeMode.Mono:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.allTypes = assembly.GetTypes();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n            case CodeMode.ILRuntime:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                //byte[] assBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.dll\"));\n                //byte[] pdbBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.pdb\"));\n            \n                appDomain = new ILRuntime.Runtime.Enviorment.AppDomain();\n                MemoryStream assStream = new MemoryStream(assBytes);\n                MemoryStream pdbStream = new MemoryStream(pdbBytes);\n                appDomain.LoadAssembly(assStream, pdbStream, new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());\n\n                ILHelper.InitILRuntime(appDomain);\n\n                this.allTypes = appDomain.LoadedTypes.Values.Select(x => x.ReflectionType).ToArray();\n                IStaticMethod start = new ILStaticMethod(appDomain, \"ET.Entry\", \"Start\", 0);\n                start.Run();\n                break;\n            }\n            case CodeMode.Reload:\n            {\n                byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.dll\"));\n                byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.pdb\"));\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.LoadLogic();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n        }\n    }\n\n    // 热重载调用下面三个方法\n    // CodeLoader.Instance.LoadLogic();\n    // Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n    // Game.EventSystem.Load();\n    public void LoadLogic()\n    {\n        if (this.CodeMode != CodeMode.Reload)\n        {\n            throw new Exception(\"CodeMode != Reload!\");\n        }\n        \n        // 傻屌Unity在这里搞了个傻逼优化，认为同一个路径的dll，返回的程序集就一样。所以这里每次编译都要随机名字\n        string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*.dll\");\n        if (logicFiles.Length != 1)\n        {\n            throw new Exception(\"Logic dll count != 1\");\n        }\n\n        string logicName = Path.GetFileNameWithoutExtension(logicFiles[0]);\n        byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.dll\"));\n        byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.pdb\"));\n\n        Assembly hotfixAssembly = Assembly.Load(assBytes, pdbBytes);\n        \n        List<Type> listType = new List<Type>();\n        listType.AddRange(this.assembly.GetTypes());\n        listType.AddRange(hotfixAssembly.GetTypes());\n        this.allTypes = listType.ToArray();\n    }\n\n    public Type[] GetTypes()\n    {\n        return this.allTypes;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class CodeLoader: IDisposable\n{\n    public static CodeLoader Instance = new CodeLoader();\n\n    public Action Update;\n    public Action LateUpdate;\n    public Action OnApplicationQuit;\n\n    private Assembly assembly;\n\n    private ILRuntime.Runtime.Enviorment.AppDomain appDomain;\n    \n    private Type[] allTypes;\n    \n    public CodeMode CodeMode { get; set; }\n\n    private CodeLoader()\n    {\n    }\n\n    public void Dispose()\n    {\n        this.appDomain?.Dispose();\n    }\n    \n    public void Start()\n    {\n        switch (this.CodeMode)\n        {\n            case CodeMode.Mono:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.allTypes = assembly.GetTypes();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n            case CodeMode.ILRuntime:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                //byte[] assBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.dll\"));\n                //byte[] pdbBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.pdb\"));\n            \n                appDomain = new ILRuntime.Runtime.Enviorment.AppDomain();\n                MemoryStream assStream = new MemoryStream(assBytes);\n                MemoryStream pdbStream = new MemoryStream(pdbBytes);\n                appDomain.LoadAssembly(assStream, pdbStream, new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());\n\n                ILHelper.InitILRuntime(appDomain);\n\n                this.allTypes = appDomain.LoadedTypes.Values.Select(x => x.ReflectionType).ToArray();\n                IStaticMethod start = new ILStaticMethod(appDomain, \"ET.Entry\", \"Start\", 0);\n                start.Run();\n                break;\n            }\n            case CodeMode.Reload:\n            {\n                byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.dll\"));\n                byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.pdb\"));\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.LoadLogic();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n        }\n    }\n\n    // 热重载调用下面三个方法\n    // CodeLoader.Instance.LoadLogic();\n    // Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n    // Game.EventSystem.Load();\n    public void LoadLogic()\n    {\n        if (this.CodeMode != CodeMode.Reload)\n        {\n            throw new Exception(\"CodeMode != Reload!\");\n        }\n        \n        // 傻屌Unity在这里搞了个傻逼优化，认为同一个路径的dll，返回的程序集就一样。所以这里每次编译都要随机名字\n        string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*.dll\");\n        if (logicFiles.Length != 1)\n        {\n            throw new Exception(\"Logic dll count != 1\");\n        }\n\n        string logicName = Path.GetFileNameWithoutExtension(logicFiles[0]);\n        byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.dll\"));\n        byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.pdb\"));\n\n        Assembly hotfixAssembly = Assembly.Load(assBytes, pdbBytes);\n        \n        List<Type> listType = new List<Type>();\n        listType.AddRange(this.assembly.GetTypes());\n        listType.AddRange(hotfixAssembly.GetTypes());\n        this.allTypes = listType.ToArray();\n    }\n\n    public Type[] GetTypes()\n    {\n        return this.allTypes;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按下f8编译dll"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static class BuildAssemblieEditor\n{\n        [MenuItem(\"Tools/BuildLogic _F8\")]\n        public static void BuildLogic()\n        {\n            string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*\");\n            foreach (string file in logicFiles)\n            {\n                File.Delete(file);\n            }\n            \n            int random = RandomHelper.RandomNumber(100000000, 999999999);\n            string logicFile = $\"Logic_{random}\";\n            \n            BuildAssemblieEditor.BuildMuteAssembly(logicFile, new []\n            {\n                \"Codes/Hotfix/\",\n                \"Codes/HotfixView/\",\n            }, new[]{Path.Combine(Define.BuildOutputDir, \"Data.dll\")}, CodeOptimization.Debug);\n        }\n\n\n    private static void BuildMuteAssembly(string assemblyName, string[] CodeDirectorys, string[] additionalReferences, CodeOptimization codeOptimization)\n        {\n            List<string> scripts = new List<string>();\n            for (int i = 0; i < CodeDirectorys.Length; i++)\n            {\n                DirectoryInfo dti = new DirectoryInfo(CodeDirectorys[i]);\n                FileInfo[] fileInfos = dti.GetFiles(\"*.cs\", System.IO.SearchOption.AllDirectories);\n                for (int j = 0; j < fileInfos.Length; j++)\n                {\n                    scripts.Add(fileInfos[j].FullName);\n                }\n            }\n\n            string dllPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.dll\");\n            string pdbPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.pdb\");\n            File.Delete(dllPath);\n            File.Delete(pdbPath);\n\n            Directory.CreateDirectory(Define.BuildOutputDir);\n\n            AssemblyBuilder assemblyBuilder = new AssemblyBuilder(dllPath, scripts.ToArray());\n            \n            //启用UnSafe\n            //assemblyBuilder.compilerOptions.AllowUnsafeCode = true;\n\n            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);\n\n            assemblyBuilder.compilerOptions.CodeOptimization = codeOptimization;\n            assemblyBuilder.compilerOptions.ApiCompatibilityLevel = PlayerSettings.GetApiCompatibilityLevel(buildTargetGroup);\n            // assemblyBuilder.compilerOptions.ApiCompatibilityLevel = ApiCompatibilityLevel.NET_4_6;\n\n            assemblyBuilder.additionalReferences = additionalReferences;\n            \n            assemblyBuilder.flags = AssemblyBuilderFlags.None;\n            //AssemblyBuilderFlags.None                 正常发布\n            //AssemblyBuilderFlags.DevelopmentBuild     开发模式打包\n            //AssemblyBuilderFlags.EditorAssembly       编辑器状态\n            assemblyBuilder.referencesOptions = ReferencesOptions.UseEngineModules;\n\n            assemblyBuilder.buildTarget = EditorUserBuildSettings.activeBuildTarget;\n\n            assemblyBuilder.buildTargetGroup = buildTargetGroup;\n\n            assemblyBuilder.buildStarted += delegate(string assemblyPath) { Debug.LogFormat(\"build start：\" + assemblyPath); };\n\n            assemblyBuilder.buildFinished += delegate(string assemblyPath, CompilerMessage[] compilerMessages)\n            {\n                int errorCount = compilerMessages.Count(m => m.type == CompilerMessageType.Error);\n                int warningCount = compilerMessages.Count(m => m.type == CompilerMessageType.Warning);\n\n                Debug.LogFormat(\"Warnings: {0} - Errors: {1}\", warningCount, errorCount);\n\n                if (warningCount > 0)\n                {\n                    Debug.LogFormat(\"有{0}个Warning!!!\", warningCount);\n                }\n\n                if (errorCount > 0)\n                {\n                    for (int i = 0; i < compilerMessages.Length; i++)\n                    {\n                        if (compilerMessages[i].type == CompilerMessageType.Error)\n                        {\n                            Debug.LogError(compilerMessages[i].message);\n                        }\n                    }\n                }\n            };\n            \n            //开始构建\n            if (!assemblyBuilder.Build())\n            {\n                Debug.LogErrorFormat(\"build fail：\" + assemblyBuilder.assemblyPath);\n                return;\n            }\n        }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static class BuildAssemblieEditor\n{\n        [MenuItem(\"Tools/BuildLogic _F8\")]\n        public static void BuildLogic()\n        {\n            string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*\");\n            foreach (string file in logicFiles)\n            {\n                File.Delete(file);\n            }\n            \n            int random = RandomHelper.RandomNumber(100000000, 999999999);\n            string logicFile = $\"Logic_{random}\";\n            \n            BuildAssemblieEditor.BuildMuteAssembly(logicFile, new []\n            {\n                \"Codes/Hotfix/\",\n                \"Codes/HotfixView/\",\n            }, new[]{Path.Combine(Define.BuildOutputDir, \"Data.dll\")}, CodeOptimization.Debug);\n        }\n\n\n    private static void BuildMuteAssembly(string assemblyName, string[] CodeDirectorys, string[] additionalReferences, CodeOptimization codeOptimization)\n        {\n            List<string> scripts = new List<string>();\n            for (int i = 0; i < CodeDirectorys.Length; i++)\n            {\n                DirectoryInfo dti = new DirectoryInfo(CodeDirectorys[i]);\n                FileInfo[] fileInfos = dti.GetFiles(\"*.cs\", System.IO.SearchOption.AllDirectories);\n                for (int j = 0; j < fileInfos.Length; j++)\n                {\n                    scripts.Add(fileInfos[j].FullName);\n                }\n            }\n\n            string dllPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.dll\");\n            string pdbPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.pdb\");\n            File.Delete(dllPath);\n            File.Delete(pdbPath);\n\n            Directory.CreateDirectory(Define.BuildOutputDir);\n\n            AssemblyBuilder assemblyBuilder = new AssemblyBuilder(dllPath, scripts.ToArray());\n            \n            //启用UnSafe\n            //assemblyBuilder.compilerOptions.AllowUnsafeCode = true;\n\n            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);\n\n            assemblyBuilder.compilerOptions.CodeOptimization = codeOptimization;\n            assemblyBuilder.compilerOptions.ApiCompatibilityLevel = PlayerSettings.GetApiCompatibilityLevel(buildTargetGroup);\n            // assemblyBuilder.compilerOptions.ApiCompatibilityLevel = ApiCompatibilityLevel.NET_4_6;\n\n            assemblyBuilder.additionalReferences = additionalReferences;\n            \n            assemblyBuilder.flags = AssemblyBuilderFlags.None;\n            //AssemblyBuilderFlags.None                 正常发布\n            //AssemblyBuilderFlags.DevelopmentBuild     开发模式打包\n            //AssemblyBuilderFlags.EditorAssembly       编辑器状态\n            assemblyBuilder.referencesOptions = ReferencesOptions.UseEngineModules;\n\n            assemblyBuilder.buildTarget = EditorUserBuildSettings.activeBuildTarget;\n\n            assemblyBuilder.buildTargetGroup = buildTargetGroup;\n\n            assemblyBuilder.buildStarted += delegate(string assemblyPath) { Debug.LogFormat(\"build start：\" + assemblyPath); };\n\n            assemblyBuilder.buildFinished += delegate(string assemblyPath, CompilerMessage[] compilerMessages)\n            {\n                int errorCount = compilerMessages.Count(m => m.type == CompilerMessageType.Error);\n                int warningCount = compilerMessages.Count(m => m.type == CompilerMessageType.Warning);\n\n                Debug.LogFormat(\"Warnings: {0} - Errors: {1}\", warningCount, errorCount);\n\n                if (warningCount > 0)\n                {\n                    Debug.LogFormat(\"有{0}个Warning!!!\", warningCount);\n                }\n\n                if (errorCount > 0)\n                {\n                    for (int i = 0; i < compilerMessages.Length; i++)\n                    {\n                        if (compilerMessages[i].type == CompilerMessageType.Error)\n                        {\n                            Debug.LogError(compilerMessages[i].message);\n                        }\n                    }\n                }\n            };\n            \n            //开始构建\n            if (!assemblyBuilder.Build())\n            {\n                Debug.LogErrorFormat(\"build fail：\" + assemblyBuilder.assemblyPath);\n                return;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按下R重载"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"    \npublic static class OperaComponentSystem\n{\n    public static void Update()\n    { \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            CodeLoader.Instance.LoadLogic();\n            Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n            Game.EventSystem.Load();\n            Log.Debug(\"hot reload success!\");\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \npublic static class OperaComponentSystem\n{\n    public static void Update()\n    { \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            CodeLoader.Instance.LoadLogic();\n            Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n            Game.EventSystem.Load();\n            Log.Debug(\"hot reload success!\");\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"roslyn-c-runtime-compiler","depth":2,"text":"Roslyn C# - Runtime Compiler","children":[{"id":"通过filesystemwatcher监控目录检查改变的文件","depth":3,"text":"通过FileSystemWatcher监控目录检查改变的文件"},{"id":"编译修改的文件并重新加载","depth":3,"text":"编译修改的文件并重新加载"},{"id":"替换场景中的monobehavior","depth":3,"text":"替换场景中的monobehavior"}]},{"id":"et的热重载","depth":2,"text":"ET的热重载"}]}},"_type":"markdown","_id":"content:unity:2022-01-02-unity-hot-reload.md","_source":"content","_file":"unity/2022-01-02-unity-hot-reload.md","_extension":"md","date":"2022-01-02"},{"_path":"/unity/2022-01-28-unity-editor-iteration-profiler","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Editor Iteration Profiler的使用","description":"一些记录关闭netcode的代码生成Multiplayer->Code Generation Windown 关闭burst的编译,命令行添加参数--burst-disable-compilation ,查看Plugins\\TranslucentImage\\Script\\Editor\\ScenceGizmoAutoDisable.cs 删除特性UnityEditor.Callbacks.DidReloadScriptsUnity 重新生成 TypeCache。这大约需要 4000毫秒，具体取决于程序集中的类型数量。所以避免使用过多无用的插件.减少类型数量参考链接Fast Domain Relo","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"一些记录"},"children":[{"type":"text","value":"一些记录"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关闭netcode的代码生成"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Multiplayer->Code Generation Windown "}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关闭burst的编译,命令行添加参数"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"--burst-disable-compilation"}]},{"type":"text","value":" ,"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.burst@1.6/manual/docs/QuickStart.html","rel":["nofollow"]},"children":[{"type":"text","value":"查看"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Plugins\\TranslucentImage\\Script\\Editor\\ScenceGizmoAutoDisable.cs"}]},{"type":"text","value":" 删除特性"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UnityEditor.Callbacks.DidReloadScripts"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unity 重新生成 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ScriptReference/TypeCache.html","rel":["nofollow"]},"children":[{"type":"text","value":"TypeCache"}]},{"type":"text","value":"。这大约需要 4000毫秒，具体取决于程序集中的类型数量。所以避免使用过多无用的插件.减少类型数量"}]}]},{"type":"element","tag":"h2","props":{"id":"参考链接"},"children":[{"type":"text","value":"参考链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://johnaustin.io/articles/2020/domain-reloads-in-unity","rel":["nofollow"]},"children":[{"type":"text","value":"Fast Domain Reloads in Unity — John Austin"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/improving-iteration-time-on-c-script-changes.1184446/","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Improving iteration time on C# script changes - Unity Forum"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一些记录","depth":2,"text":"一些记录"},{"id":"参考链接","depth":2,"text":"参考链接"}]}},"_type":"markdown","_id":"content:unity:2022-01-28-unity-Editor-Iteration-Profiler.md","_source":"content","_file":"unity/2022-01-28-unity-Editor-Iteration-Profiler.md","_extension":"md","date":"2022-01-28"},{"_path":"/unity/2022-04-02-circlecast-overlapple-diff","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"CircleCast和Overlapple的区别是什么","description":"从以上可以看出CircleCastAll是投射了一个⚪的运动轨迹","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-04-02-CircleCast-Overlapple-diff/1648876953000.png"},"children":[]},{"type":"text","value":"从以上可以看出CircleCastAll是投射了一个⚪的运动轨迹"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而OverlapCircleAll只是检查了一个⚪内的范围"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然如果CircleCastAll的参数"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"distance设置为0,它的功能和"}]},{"type":"text","value":"OverlapCircleAll就类似了"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2022-04-02-CircleCast-Overlapple-diff.md","_source":"content","_file":"unity/2022-04-02-CircleCast-Overlapple-diff.md","_extension":"md","date":"2022-04-02"},{"_path":"/unity/2022-09-10-ecs-beiwang","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity ecs的备忘录","description":"关于parent和LinkedEntityGroupparent 涉及到localtoworld, 以及一些物理和其他的转换规则parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"关于parent和linkedentitygroup"},"children":[{"type":"text","value":"关于parent和LinkedEntityGroup"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获取世界坐标..可以使用LocalToWorld.pos"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"linkedEntityGroup 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 有关"}]}]},{"type":"element","tag":"h2","props":{"id":"关于转换"},"children":[{"type":"text","value":"关于转换"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Conversion World中，仅仅是复制生成了来自Classic World的、保留原有Hierarchy关系的GameObject Entity，这些Entity拥有的组件仍然是我们熟知的传统Unity组件，例如Transform、MeshFilter。接下来，将调用DOTS预置的或我们自定义的Convert接口，完成向IComponentData组件的转换。自然而然的，可能没有实现对某Component Object的转换接口，那么在转换过程中将被丢弃，所以该转换不一定是“一对一”，所以Unity称呼其为\"Primary Entity\"。下图呈现了转换全过程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-09-10-ecs-beiwang/v2-332760451f516eb225e95ea7683945e5_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"转换过程都是在Conversion World中完成的,DOTS在内部为转换过程创建了一个World。作为独立World，它拥有自己的EntityManager和ComponentSystem，进而拥有并管理自己的Entity和ComponentData。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用ConvertToEntity组件,添加IConvertGameObjectToEntity接口,或者在组件上添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[GenerateAuthoringComponent]"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-09-10-ecs-beiwang/1662571573000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同一,但是使用代码控制转换的时机,继承ConvertToSingleEntity,并覆盖awake,然后在手动调用."},{"type":"element","tag":"pre","props":{"code":"public class ConvertToSingleEntity : ConvertToEntity\n{\n    void Awake()\n    {\n    }\n}\n\n//实际上就是ConvertToEntity中的代码\npublic static void ConvertGameObejct(World dstWorld, GameObject gameObject)\n{\n    var system = World.DefaultGameObjectInjectionWorld.GetOrCreateSystem<ConvertToEntitySystem>();\n\n    var convert = gameObject.GetComponent<ConvertToEntity>();\n\n    if (convert == null)\n    {\n        return ;\n    }\n    system.AddToBeConverted(dstWorld, convert);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class ConvertToSingleEntity : ConvertToEntity\n{\n    void Awake()\n    {\n    }\n}\n\n//实际上就是ConvertToEntity中的代码\npublic static void ConvertGameObejct(World dstWorld, GameObject gameObject)\n{\n    var system = World.DefaultGameObjectInjectionWorld.GetOrCreateSystem<ConvertToEntitySystem>();\n\n    var convert = gameObject.GetComponent<ConvertToEntity>();\n\n    if (convert == null)\n    {\n        return ;\n    }\n    system.AddToBeConverted(dstWorld, convert);\n}\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用IDeclareReferencedPrefabs.声明实体的prefab,然后进行存储,以便进行之后的实例化"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"对于转换世界中的每个游戏对象，在任何转换系统运行之前，都会在目标世界中自动创建一个主要实体。随后可以通过 GameObjectConversionSystem.GetPrimaryEntity 访问与 GameObject 关联的实体。"},{"type":"element","tag":"pre","props":{"code":"  /*\n     *    \n     *    \n         if (m_Prefab == Entity.Null)\n               {\n                   var prefabEntity = GetSingletonEntity<GamePrefabCollectionComponent>();\n                   var prefabs = GetBuffer<GamePrefabBuffer>(prefabEntity);\n                   for (int i = 0; i < prefabs.Length; ++i)\n                   {\n                       if (HasComponent<Player.State>(prefabs[i].Value))\n                           m_Prefab = prefabs[i].Value;\n                   }\n               }\n     * \n     * \n     * 添加进来的prefab不需要添加convert to entity\n     * 可以用单例获取GamePrefabCollectionComponent,然后获取想要的entity\n     * \n     */\n    public class GameDeclareReferencedPrefabs : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n    {\n   \n        public List<GameObject> Prefabs = new List<GameObject>();\n\n        public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n        {\n            dstManager.AddComponentData(entity, default(GamePrefabCollectionComponent));\n            var prefabs = dstManager.AddBuffer<GamePrefabBuffer>(entity);\n\n            foreach (var prefab in Prefabs)\n            { \n                var prefabEnt = conversionSystem.GetPrimaryEntity(prefab);\n                if (dstManager.Exists(prefabEnt))\n                    prefabs.Add(new GamePrefabBuffer { Value = prefabEnt });\n                else\n                    Debug.LogError($\"The prefab {prefab.name} in the ghost collection was no converted to an entity, skipping it\");\n            }\n        }\n\n        public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n        {\n            foreach (var prefab in Prefabs)\n            {\n                if(prefab == null)\n                {\n                    continue;\n                }\n                referencedPrefabs.Add(prefab);\n            }\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  /*\n     *    \n     *    \n         if (m_Prefab == Entity.Null)\n               {\n                   var prefabEntity = GetSingletonEntity<GamePrefabCollectionComponent>();\n                   var prefabs = GetBuffer<GamePrefabBuffer>(prefabEntity);\n                   for (int i = 0; i < prefabs.Length; ++i)\n                   {\n                       if (HasComponent<Player.State>(prefabs[i].Value))\n                           m_Prefab = prefabs[i].Value;\n                   }\n               }\n     * \n     * \n     * 添加进来的prefab不需要添加convert to entity\n     * 可以用单例获取GamePrefabCollectionComponent,然后获取想要的entity\n     * \n     */\n    public class GameDeclareReferencedPrefabs : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n    {\n   \n        public List<GameObject> Prefabs = new List<GameObject>();\n\n        public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n        {\n            dstManager.AddComponentData(entity, default(GamePrefabCollectionComponent));\n            var prefabs = dstManager.AddBuffer<GamePrefabBuffer>(entity);\n\n            foreach (var prefab in Prefabs)\n            { \n                var prefabEnt = conversionSystem.GetPrimaryEntity(prefab);\n                if (dstManager.Exists(prefabEnt))\n                    prefabs.Add(new GamePrefabBuffer { Value = prefabEnt });\n                else\n                    Debug.LogError($\"The prefab {prefab.name} in the ghost collection was no converted to an entity, skipping it\");\n            }\n        }\n\n        public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n        {\n            foreach (var prefab in Prefabs)\n            {\n                if(prefab == null)\n                {\n                    continue;\n                }\n                referencedPrefabs.Add(prefab);\n            }\n        }\n    }\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"4.从转换系统中根据component获取实体,和上面类似..因为转换子物体的时候,转换系统中会生成实体,这个时候可以使用组件从conversionSystem中获取,"},{"type":"element","tag":"pre","props":{"code":"     public static void AddAbilityComponents(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem, AbilityAuthoring[] abilities)\n        {\n            dstManager.AddComponentData(entity, new AbilityCollection.State());\n\n            // Create ability entities\n            var abilityEntities = new List<Entity>(abilities.Length);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                var e = conversionSystem.GetEntities(abilities[i]);\n                e.MoveNext();\n                var abilityEntity = e.Current;\n\n                if (abilityEntities.Contains(abilityEntity))\n                {\n                    GameDebug.LogError(\"Ability \" + abilities[i] + \" registered multiple times in abilities list\");\n                }\n\n                abilityEntities.Add(abilityEntity);\n            }\n\n            // Add abilities to ability buffer\n            dstManager.AddBuffer<AbilityCollection.AbilityEntry>(entity);\n            var abilityBuffer = dstManager.GetBuffer<AbilityCollection.AbilityEntry>(entity);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                abilityBuffer.Add(new AbilityCollection.AbilityEntry\n                {\n                    entity = abilityEntities[i],\n                    abilityType = abilities[i].abilityTypeFlags,\n                    canRunWith = abilities[i].canRunWithFlags,\n                    canInterrupt = abilities[i].canInterruptFlags,\n                });\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"     public static void AddAbilityComponents(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem, AbilityAuthoring[] abilities)\n        {\n            dstManager.AddComponentData(entity, new AbilityCollection.State());\n\n            // Create ability entities\n            var abilityEntities = new List<Entity>(abilities.Length);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                var e = conversionSystem.GetEntities(abilities[i]);\n                e.MoveNext();\n                var abilityEntity = e.Current;\n\n                if (abilityEntities.Contains(abilityEntity))\n                {\n                    GameDebug.LogError(\"Ability \" + abilities[i] + \" registered multiple times in abilities list\");\n                }\n\n                abilityEntities.Add(abilityEntity);\n            }\n\n            // Add abilities to ability buffer\n            dstManager.AddBuffer<AbilityCollection.AbilityEntry>(entity);\n            var abilityBuffer = dstManager.GetBuffer<AbilityCollection.AbilityEntry>(entity);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                abilityBuffer.Add(new AbilityCollection.AbilityEntry\n                {\n                    entity = abilityEntities[i],\n                    abilityType = abilities[i].abilityTypeFlags,\n                    canRunWith = abilities[i].canRunWithFlags,\n                    canInterrupt = abilities[i].canInterruptFlags,\n                });\n            }\n        }\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"5.手动转换gameobject,他的代码和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntitySystem"}]},{"type":"text","value":"的代码差不多.会创建一个ConversionWorld,然后进行转换,都是使用了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionUtility.Convert"}]},{"type":"text","value":"工作"},{"type":"element","tag":"pre","props":{"code":"        public static Entity ConvertGameObjectPrefab(GameObject go,World dstWorld,out BlobAssetStore blob)\n        {\n            Entity returnEntity = Entity.Null;\n        \n            blob = new BlobAssetStore();\n\n            returnEntity =\n                GameObjectConversionUtility.ConvertGameObjectHierarchy(go,GameObjectConversionSettings.FromWorld(dstWorld, blob));\n\n            return returnEntity;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static Entity ConvertGameObjectPrefab(GameObject go,World dstWorld,out BlobAssetStore blob)\n        {\n            Entity returnEntity = Entity.Null;\n        \n            blob = new BlobAssetStore();\n\n            returnEntity =\n                GameObjectConversionUtility.ConvertGameObjectHierarchy(go,GameObjectConversionSettings.FromWorld(dstWorld, blob));\n\n            return returnEntity;\n        }\n"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"关于parent和linkedentitygroup","depth":2,"text":"关于parent和LinkedEntityGroup"},{"id":"关于转换","depth":2,"text":"关于转换"}]}},"_type":"markdown","_id":"content:unity:2022-09-10-ecs-beiwang.md","_source":"content","_file":"unity/2022-09-10-ecs-beiwang.md","_extension":"md","date":"2022-09-10"}],"navigation":[{"title":"Art","_path":"/art","children":[{"title":"如何用蒙版将两个图过渡融合","_path":"/art/2020-09-03-ps-ronghe-pics"},{"title":"像素画入门","_path":"/art/2022-02-02-xiangsuhuarumen"}]},{"title":"Dotnet","_path":"/dotnet","children":[{"title":"Linux部署dotnetcore记录","_path":"/dotnet/2019-06-05-linux-dotnet-daemon"},{"title":"时间轮的引入","_path":"/dotnet/2019-10-29-time-wheel"},{"title":"帧同步的相关问题","_path":"/dotnet/2019-11-01-lock-step"},{"title":"状态同步的相关问题","_path":"/dotnet/2019-11-01-state-sync-npc"},{"title":"状态同步--技能系统的同步机制分析","_path":"/dotnet/2019-11-02-state-sync-skill"},{"title":"Creating a Quartz.NET hosted service with ASP.NET Core","_path":"/dotnet/2019-11-05-quartz"},{"title":"DatetimeOffset和Datetime的区别","_path":"/dotnet/2019-12-01-datetimeoffset"},{"title":"大小端字节序(Big Endian和Little Endian)","_path":"/dotnet/2020-01-05-big-little-endian"},{"title":"dll文件的加载","_path":"/dotnet/2020-01-06-dll-load"},{"title":"延迟补偿在C/S架构游戏协议设计和优化中的应用","_path":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization"},{"title":"延迟补偿和对时的相关总结","_path":"/dotnet/2020-02-02-latency_compensating-rtt"},{"title":"快节奏多人游戏同步(1)-ClientServer架构","_path":"/dotnet/2020-02-02-net-sync-client-server-game-architecture"},{"title":"快节奏多人游戏同步(2)-客户端预测与服务器校对","_path":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation"},{"title":"快节奏多人游戏同步(3)-Entity插值","_path":"/dotnet/2020-02-02-net-sync-entity-interpolation"},{"title":"快节奏多人游戏同步(4)-延时补偿","_path":"/dotnet/2020-02-02-net-sync-lag-compensation"},{"title":"守望先锋等FPS游戏的网络同步","_path":"/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode"},{"title":"起源引擎网络同步模型","_path":"/dotnet/2020-02-02-source_multiplayer_networking"},{"title":"orleans的部署模式","_path":"/dotnet/2020-02-03-orleans-deployment"},{"title":"一致性hash算法","_path":"/dotnet/2020-02-06-consistent_hash"},{"title":"地图的aoi","_path":"/dotnet/2020-02-07-aoi"},{"title":"游戏的匹配机制ELO","_path":"/dotnet/2020-02-09-room-elo"},{"title":"C# 深浅复制","_path":"/dotnet/2020-02-10-icloneable"},{"title":"C#引用类型对象在循环引用时会不会内存泄漏","_path":"/dotnet/2020-02-11-gc"},{"title":"扒一扒.net、.net framework、mono和Unity","_path":"/dotnet/2020-02-12-netcore-mono-netframework"},{"title":"c#编译和运行启动原理","_path":"/dotnet/2020-02-13-csharp-run"},{"title":"abp新建项目指南","_path":"/dotnet/2020-05-29-abp-start"},{"title":"2020 06 11 IdentityServer Use","_path":"/dotnet/2020-06-11-identityserver-use"},{"title":"关于abp的用户的一些问题","_path":"/dotnet/2020-07-05-abp-database-user"},{"title":"abp的dOC模块使用","_path":"/dotnet/2020-07-10-abp-doc"},{"title":"abp默认语言规则","_path":"/dotnet/2020-07-15-abp-default-language"},{"title":"Orleans 最佳实践","_path":"/dotnet/2020-08-09-orleans-best-practices"},{"title":"c#特性参数","_path":"/dotnet/2020-08-10-param-attribute"},{"title":".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","_path":"/dotnet/2020-08-11-httpcontextaccessor-asynclocal"},{"title":"Kestrel源码分析","_path":"/dotnet/2020-08-15-kestrel-source-code"},{"title":"ConcurrentDictionary并发字典","_path":"/dotnet/2020-08-16-concurrentdictionary"},{"title":"IOptions、IOptionsMonitor以及IOptionsSnapshot","_path":"/dotnet/2020-08-17-netcore-options"},{"title":".NET Core/Framework 创建委托以大幅度提高反射调用的性能","_path":"/dotnet/2020-11-13-reflection-method"},{"title":"C＃枚举中使用Flags特性","_path":"/dotnet/2020-11-24-flags"},{"title":"谷歌浏览器下netcore登录失败问题","_path":"/dotnet/2020-12-11-chrome-login-fail"},{"title":"Converting between Structs and Byte Arrays","_path":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays"},{"title":"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","_path":"/dotnet/2022-08-15-equal-hashcode"}]},{"title":"Game","_path":"/game","children":[{"title":"使用柏林噪声算法生成地图","_path":"/game/2021-01-20-perlin-map"},{"title":"波函数坍塌算法生成地图","_path":"/game/2021-01-21-wave-collapse-function"},{"title":"文明6地图生成算法","_path":"/game/2021-01-22-civ-map"},{"title":"roguelike地牢生成算法","_path":"/game/2021-01-23-roguelike-map"},{"title":"Spelunky关卡生成","_path":"/game/2021-01-23-spelunky-map"},{"title":"Edgar源代码解读","_path":"/game/2021-06-12-edgar-code-read"},{"title":"rpgbuild的一些备注","_path":"/game/2021-06-15-rpgbuilder"},{"title":"游戏人物设计","_path":"/game/2021-08-05-game-task-design"},{"title":"unity gameplay ability源代码解析","_path":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode"},{"title":"苟与剑游戏技能分析","_path":"/game/2021-12-21-gyj-skill"},{"title":"quest machine 使用相关","_path":"/game/2022-02-19-quest-machine"},{"title":"苟与剑中的单位生成方式","_path":"/game/2022-03-16-gyj-map"},{"title":"ecs中实体创建方法","_path":"/game/2022-08-03-ecs"},{"title":"暗黑2怪物等级和掉落规则","_path":"/game/2022-08-05-dia2"},{"title":"行为树源代码解析","_path":"/game/2022-08-21-behavior-tree-source-code"}]},{"title":"Gyj","_path":"/gyj","children":[{"title":"美术要求","_path":"/gyj/2022-06-11-meishuyaoqiu"},{"title":"游戏基础知识","_path":"/gyj/2022-06-12-jichuzhishi"},{"title":"2022 08 22 地图房间的种类","_path":"/gyj/2022-08-22-detufangjiandezhonglei"},{"title":"2022 08 22 奇遇事件","_path":"/gyj/2022-08-22-qiyushijian"},{"title":"游戏流程","_path":"/gyj/2022-08-22-youxiliucheng"},{"title":"物品产出表","_path":"/gyj/2022-08-22-wupinchanchubiao"},{"title":"玩法","_path":"/gyj/2022-08-22-wanfa"},{"title":"初入江湖","_path":"/gyj/2022-08-22-diyizhang"},{"title":"2022 08 22 职业与工作","_path":"/gyj/2022-08-22-zhiyeyugongzuo"},{"title":"天下霸图研究","_path":"/gyj/2022-11-01-tianxiabatu"},{"title":"流放之路关于伤害公式和技能的分析","_path":"/gyj/2022-11-17-liufangzhilu"},{"title":"门派内容相关","_path":"/gyj/2022-11-17-sect"},{"title":"2022 12 01 养殖","_path":"/gyj/2022-12-01-yangzhi"},{"title":"种植","_path":"/gyj/2022-12-01-zhongzhi"},{"title":"人物属性设计","_path":"/gyj/2022-12-15-renwushuxing"},{"title":"跑商","_path":"/gyj/2023-11-01-paoshang"}]},{"title":"Js","_path":"/js","children":[{"title":"如何在TypeScript中使用JS类库","_path":"/js/2022-02-12-typescript-use-js"},{"title":"nuxt3项目初始化失败","_path":"/js/2023-05-16-nuxt3-init-fail"},{"title":"Flex 布局使用","_path":"/js/2024-03-17-flex-use"}]},{"title":"Tool","_path":"/tool","children":[{"title":"windows发送到手机Ftp","_path":"/tool/2019-06-20-windows-send-to-ftp"},{"title":"windows特殊目录修复","_path":"/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows"},{"title":"scourcetree  总是需要输入密码","_path":"/tool/2019-08-07-sourcetree-git-password"},{"title":"powershell 常用命令","_path":"/tool/2019-08-10-powershell-command"},{"title":"scoop的使用","_path":"/tool/2019-08-20-scoop-use"},{"title":"使用配置文件来管理NuGet包版本F","_path":"/tool/2019-09-02-nuget-manager"},{"title":"Redis的两种持久化RDB和AOF","_path":"/tool/2019-09-02-redis-aof-rdb"},{"title":"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","_path":"/tool/2020-01-02-google-clound-local-login"},{"title":"CentOS 下安装Shadowsocks 搭建ss","_path":"/tool/2020-01-12-centosn-ss-install"},{"title":"mac下brew 使用","_path":"/tool/2020-01-13-brew"},{"title":"术语中英文对照","_path":"/tool/2020-02-05-game_en_zh"},{"title":"Excel中以文本形式存储的数字","_path":"/tool/2020-02-06-excel-text-number"},{"title":"protobuf序列化的一些问题","_path":"/tool/2020-03-25-protobuf-empty-collections"},{"title":"为博客将 RSS 转为邮件订阅","_path":"/tool/2020-06-26-blog-mail-sub"},{"title":"github下载代码的速度太慢","_path":"/tool/2020-06-27-linux-github-slow"},{"title":"win10开始菜单添加软件以及备份和恢复","_path":"/tool/2020-07-02-win10-start-menu"},{"title":"gitbook的使用","_path":"/tool/2020-07-06-gitbook-use"},{"title":"github actions 简单使用","_path":"/tool/2020-07-11-github-actions"},{"title":"使用hexo建立博客并部署到github","_path":"/tool/2020-07-12-hexo-github"},{"title":"终端下设置代理","_path":"/tool/2020-07-13-terminal-proxy"},{"title":"发现nuget包太占用C盘，怎么办？","_path":"/tool/2020-08-30-nuget-is-big"},{"title":"unity商店下载资源迁移","_path":"/tool/2020-11-15-unity-is-big"},{"title":"关于coding的pages介绍","_path":"/tool/2020-11-16-coding-pages"},{"title":"一些常用的dns服务器","_path":"/tool/2021-05-06-dns"},{"title":"UE4素材破解","_path":"/tool/2021-11-06-ue4-view"},{"title":"安装cockpit通过nginx代理访问","_path":"/tool/2021-11-07-cockpit-linux"},{"title":"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","_path":"/tool/2021-11-15-install-windowsstore"},{"title":"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","_path":"/tool/2021-12-02-vscode-plugins-big"},{"title":"云效部署hexo到自己的主机 ","_path":"/tool/2021-12-11-yunxiao-liushuixian-hexo"},{"title":"github 怎么合并原始分支？ ","_path":"/tool/2021-12-12-github-sync"},{"title":"code server安装制作online ide","_path":"/tool/2022-01-30-code-server"},{"title":"rider的使用","_path":"/tool/2022-08-02-rider-use"},{"title":"2022 08 09 Amd Over","_path":"/tool/2022-08-09-amd-over"},{"title":"rider破解","_path":"/tool/2022-11-19-rider-po-jie"},{"title":"stable diffusion install","_path":"/tool/2023-01-20-stable-diffusion-install"},{"title":"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","_path":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi"}]},{"title":"Unity","_path":"/unity","children":[{"title":"Unity 导出 Android 64-bit 版本","_path":"/unity/2019-06-20-unity-android-x64"},{"title":"Unity的il2cpp","_path":"/unity/2019-06-20-unity-il2cpp-debugger"},{"title":"googlePlay 发布问题","_path":"/unity/2019-06-23-googlplay-pulish"},{"title":"关于unity的适配问题","_path":"/unity/2019-08-09-unity2d-shipei"},{"title":"一次精通 RectTransform","_path":"/unity/2019-08-10-ugui-recttransform"},{"title":"一次精通 eventmanager","_path":"/unity/2019-08-11-ugui-eventmanager"},{"title":"ugui的eventsystem源码解读","_path":"/unity/2019-08-12-ugui-eventsystem-sourcecode"},{"title":"Unity Raycasters 剖析","_path":"/unity/2019-08-12-ugui-raycasters"},{"title":"关于addressable那些事","_path":"/unity/2019-09-01-addressable"},{"title":"关于spriteAtlas打包那些事","_path":"/unity/2019-09-01-spriteatlas"},{"title":"ilruntime的研究","_path":"/unity/2019-09-02-ilruntime"},{"title":"unity的宏以及添加net框架中未引用的dll","_path":"/unity/2019-09-02-unity-reference-dll"},{"title":"xlua注入源码解读","_path":"/unity/2019-09-03-xlua-inject"},{"title":"如何快速的注入汇编","_path":"/unity/2019-09-04-mono.cecil-inject"},{"title":"2D游戏视差背景的实现","_path":"/unity/2019-09-13-parallax-2d"},{"title":"unity使用代理","_path":"/unity/2019-11-15-unity-proxy"},{"title":"一篇文章搞定Entitas","_path":"/unity/2020-01-01-unity-entitas"},{"title":"unity攻击范围检测的方式区别","_path":"/unity/2020-01-11-unity-attack-range-detection-type"},{"title":"常见的2D碰撞检测","_path":"/unity/2020-01-12-collision-detection"},{"title":"unity攻击范围检测","_path":"/unity/2020-01-13-unity-attack-detection"},{"title":"技能系统","_path":"/unity/2020-02-15-skill-system"},{"title":"游戏buff系统设计","_path":"/unity/2020-02-16-buff-system"},{"title":"角色状态设计","_path":"/unity/2020-02-17-character-states"},{"title":"理解托管堆","_path":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity"},{"title":"理解自动内存管理","_path":"/unity/2020-02-19-understandingautomaticmemorymanagement"},{"title":"unity 移动平台打包丢失shader的问题","_path":"/unity/2020-02-20-shader-lost"},{"title":"Unity的调试相关","_path":"/unity/2020-03-01-unity-debug"},{"title":"unity启动运行脚本流程","_path":"/unity/2020-03-04-unity-startup"},{"title":"unity的坐标体系","_path":"/unity/2020-07-01-unity-coordinate"},{"title":"2020 07 03 Unity Mesh","_path":"/unity/2020-07-03-unity-mesh"},{"title":"unity Render Pipeline","_path":"/unity/2020-07-04-unity-render-pipeline"},{"title":"Notch Solution","_path":"/unity/2020-08-29-notch-solution"},{"title":"unity 项目dll检查","_path":"/unity/2020-08-30-unity-dll-check"},{"title":"UNITY的垂直同步和帧率","_path":"/unity/2020-09-05-unity-vsynccount"},{"title":"UNITY性能优化流程","_path":"/unity/2020-09-10-optimizing-for-performance"},{"title":"堆栈内存Stack和堆内存Heap","_path":"/unity/2020-09-11-stack-heap"},{"title":"unity的addressables","_path":"/unity/2020-09-12-addressables"},{"title":"游戏中的向量使用","_path":"/unity/2020-09-13-vector"},{"title":"UNITY ECS 详解","_path":"/unity/2020-10-15-unity-ecs"},{"title":"UNITY JOB SYSTEM详解","_path":"/unity/2020-10-16-unity-job"},{"title":"运行时打包图集","_path":"/unity/2020-10-17-runtime-spriteatlas"},{"title":"unity ecs component","_path":"/unity/2020-10-18-unity-ecs-component"},{"title":"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","_path":"/unity/2020-10-19-game-object-conversion-and-subscene"},{"title":"源代码分析world的创建","_path":"/unity/2020-10-20-ecs-world"},{"title":"unity使用platforms构建","_path":"/unity/2020-10-21-platform"},{"title":"Unity rendering order渲染顺序","_path":"/unity/2020-10-22-unity-render-order"},{"title":"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","_path":"/unity/2020-10-23-unity-optimizing-gpu"},{"title":"unity的ScreenToWorldPoint","_path":"/unity/2020-10-24-screentoworldpoint"},{"title":"URP性能测试","_path":"/unity/2020-10-24-unity-urp-performance"},{"title":"如何使用Unity ECS打造Reactive System？","_path":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs"},{"title":"Unity中Sprite和UI Image的区别","_path":"/unity/2020-11-12-sprite-image-diff"},{"title":"简单保存工具","_path":"/unity/2020-11-13-simple-save"},{"title":"2020 11 14 Netcode","_path":"/unity/2020-11-14-netcode"},{"title":"ecs中的parent","_path":"/unity/2020-11-15-ecs-parent"},{"title":"ability","_path":"/unity/2020-11-16-dotssample"},{"title":"unity world time system","_path":"/unity/2020-11-17-unity-ecs-worldtime"},{"title":"netcode源代码解读","_path":"/unity/2020-11-18-netcode-sourcecode"},{"title":"pitch yaw roll是什么","_path":"/unity/2020-11-29-pitch-yaw-roll"},{"title":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","_path":"/unity/2020-12-20-collection-has-not-been-disposed"},{"title":"解决Unity鼠标坐标点转成世界坐标系坐标点","_path":"/unity/2021-01-24-screentoworld"},{"title":"2021 01 25 Tilemap","_path":"/unity/2021-01-25-tilemap"},{"title":"Unity RenderTexture的应用","_path":"/unity/2021-04-11-render-texture"},{"title":"commandbuff的一些问题","_path":"/unity/2021-05-20-ecs-commandbuff-question"},{"title":"How to Make One Way Platform in unity","_path":"/unity/2021-06-13-how-to-make-one-way-platform"},{"title":"UNITY的渲染顺序","_path":"/unity/2021-06-14-unity-render-order"},{"title":"防止变量引用丢失 FormerlySerializedAs","_path":"/unity/2021-07-20-formerlyserializedas"},{"title":"AI-PLANNER使用","_path":"/unity/2021-08-01-ai-planner"},{"title":"Increased script assembly reload time","_path":"/unity/2021-10-01-increased-script-assembly-reload-time"},{"title":"关于unity的热重载的研究","_path":"/unity/2022-01-02-unity-hot-reload"},{"title":"Editor Iteration Profiler的使用","_path":"/unity/2022-01-28-unity-editor-iteration-profiler"},{"title":"CircleCast和Overlapple的区别是什么","_path":"/unity/2022-04-02-circlecast-overlapple-diff"},{"title":"unity ecs的备忘录","_path":"/unity/2022-09-10-ecs-beiwang"}]}]}