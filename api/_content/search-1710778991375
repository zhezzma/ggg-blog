{"documentCount":1055,"nextId":1055,"documentIds":{"0":"/art/2020-09-03-ps-ronghe-pics#原理","1":"/art/2020-09-03-ps-ronghe-pics#应用图层蒙版是不能执行的","2":"/art/2020-09-03-ps-ronghe-pics#去色","3":"/dotnet/2019-06-05-linux-dotnet-daemon#daemon","4":"/dotnet/2019-06-05-linux-dotnet-daemon#配置文件","5":"/dotnet/2019-06-05-linux-dotnet-daemon#命令","6":"/dotnet/2019-06-05-linux-dotnet-daemon#jenkins","7":"/dotnet/2019-06-05-linux-dotnet-daemon#efcore-update","8":"/dotnet/2019-06-05-linux-dotnet-daemon#mysql","9":"/dotnet/2019-06-05-linux-dotnet-daemon#windows下绝对路径启动问题","10":"/dotnet/2019-10-29-time-wheel#a-full-example","11":"/dotnet/2019-11-01-lock-step#lock-step","12":"/dotnet/2019-11-01-lock-step#bucket-synchronization乐观锁","13":"/dotnet/2019-11-01-lock-step#timewrap-synchronization","14":"/dotnet/2019-11-01-lock-step#trailing-state-synchronization","15":"/dotnet/2019-11-01-lock-step#state-hash","16":"/dotnet/2019-11-01-state-sync-npc#怪物状态同步","17":"/dotnet/2019-11-01-state-sync-npc#基于客户端的状态同步","18":"/dotnet/2019-11-01-state-sync-npc#a-怪物的随机移动不同步","19":"/dotnet/2019-11-01-state-sync-npc#b-怪物的行为同步","20":"/dotnet/2019-11-01-state-sync-npc#c-精英怪和boss怪的ai","21":"/dotnet/2019-11-01-state-sync-npc#相关链接","22":"/dotnet/2019-11-05-quartz#introduction-what-is-quartznet","23":"/dotnet/2019-11-05-quartz#installing-quartznet","24":"/dotnet/2019-11-05-quartz#creating-an-ijob","25":"/dotnet/2019-11-05-quartz#creating-an-ijobfactory","26":"/dotnet/2019-11-05-quartz#configuring-the-job","27":"/dotnet/2019-11-05-quartz#creating-the-quartzhostedservice","28":"/dotnet/2019-11-05-quartz#using-scoped-services-in-jobs","29":"/dotnet/2019-11-05-quartz#summary","30":"/dotnet/2019-11-05-quartz#hangfire-与quartznet对比","31":"/dotnet/2019-12-01-datetimeoffset#还有就是不要混用不要将datetime当成datetimeoffset使用","32":"/dotnet/2020-01-05-big-little-endian#那么何为字节序endia呢","33":"/dotnet/2020-01-05-big-little-endian#为什么会有这样的情况呢","34":"/dotnet/2020-01-05-big-little-endian#为什么要注意字节序的问题呢","35":"/dotnet/2020-01-05-big-little-endian#网络字节序","36":"/dotnet/2020-01-05-big-little-endian#一在进行网络通信时是否需要进行字节序转换","37":"/dotnet/2020-01-05-big-little-endian#二网络字节序","38":"/dotnet/2020-01-05-big-little-endian#c-大端转换","39":"/dotnet/2020-01-05-big-little-endian#对于字符串型","40":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_1综述","41":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_2cs游戏的基本架构","42":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_3用户消息的内容","43":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_4客户端预测","44":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_5开火过程中的客户端预测","45":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_6一些工作","46":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_7目标的显示","47":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_8延迟补偿","48":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_9游戏涉及中延迟补偿的使用","49":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#_10总结","50":"/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization#脚注","51":"/dotnet/2020-02-02-latency_compensating-rtt#网络对时","52":"/dotnet/2020-02-02-latency_compensating-rtt#服务器和客户端时间差算法-st0st2-2ct12","53":"/dotnet/2020-02-02-latency_compensating-rtt#两种理解方式","54":"/dotnet/2020-02-02-latency_compensating-rtt#第一种方式","55":"/dotnet/2020-02-02-latency_compensating-rtt#第二种方式","56":"/dotnet/2020-02-02-latency_compensating-rtt#检查安全性","57":"/dotnet/2020-02-02-latency_compensating-rtt#移动的延迟补偿","58":"/dotnet/2020-02-02-latency_compensating-rtt#boss攻击的延迟补偿","59":"/dotnet/2020-02-02-latency_compensating-rtt#玩家-的延迟补偿","60":"/dotnet/2020-02-02-latency_compensating-rtt#一些模拟恶劣网络环境工具","61":"/dotnet/2020-02-02-net-sync-client-server-game-architecture#part-1-概述","62":"/dotnet/2020-02-02-net-sync-client-server-game-architecture#part-2-反作弊","63":"/dotnet/2020-02-02-net-sync-client-server-game-architecture#part-3-权威服务器和静默客户端","64":"/dotnet/2020-02-02-net-sync-client-server-game-architecture#part-4-考虑网络问题","65":"/dotnet/2020-02-02-net-sync-client-server-game-architecture#part-5-总结","66":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation#part-1-概述","67":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation#part-2-客户端预测","68":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation#part-3-同步问题","69":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation#part-4-服务器校对","70":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation#part-5-误差","71":"/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation#part-6-总结","72":"/dotnet/2020-02-02-net-sync-entity-interpolation#part-1-概述","73":"/dotnet/2020-02-02-net-sync-entity-interpolation#part-2-服务器-time-step","74":"/dotnet/2020-02-02-net-sync-entity-interpolation#part-3-低频更新处理","75":"/dotnet/2020-02-02-net-sync-entity-interpolation#part-4-航位推测法","76":"/dotnet/2020-02-02-net-sync-entity-interpolation#part-5-实体插值","77":"/dotnet/2020-02-02-net-sync-entity-interpolation#part-6-总结","78":"/dotnet/2020-02-02-net-sync-lag-compensation#part-1-概述","79":"/dotnet/2020-02-02-net-sync-lag-compensation#part-2-延时补偿","80":"/dotnet/2020-02-02-net-sync-lag-compensation#part-3-总结","81":"/dotnet/2020-02-02-net-sync-lag-compensation#扩展阅读","82":"/dotnet/2020-02-02-source_multiplayer_networking#基本网络模型","83":"/dotnet/2020-02-02-source_multiplayer_networking#enitiy插值平滑","84":"/dotnet/2020-02-02-source_multiplayer_networking#输入预测","85":"/dotnet/2020-02-02-source_multiplayer_networking#延迟补偿","86":"/dotnet/2020-02-02-source_multiplayer_networking#网络视图net_graph","87":"/dotnet/2020-02-02-source_multiplayer_networking#tips","88":"/dotnet/2020-02-03-orleans-deployment#蓝绿部署bluegreen-deployment","89":"/dotnet/2020-02-03-orleans-deployment#滚动发布rolling-update","90":"/dotnet/2020-02-03-orleans-deployment#orleans支持-蓝绿部署模型以及滚动部署模型","91":"/dotnet/2020-02-06-consistent_hash#应用场景","92":"/dotnet/2020-02-06-consistent_hash#_2-一致性哈希算法","93":"/dotnet/2020-02-06-consistent_hash#_3-容错性和扩展性","94":"/dotnet/2020-02-06-consistent_hash#_31-容错性","95":"/dotnet/2020-02-06-consistent_hash#_32-扩展性","96":"/dotnet/2020-02-06-consistent_hash#_4-虚拟节点","97":"/dotnet/2020-02-07-aoi#为什么要进行视野管理","98":"/dotnet/2020-02-07-aoi#格子","99":"/dotnet/2020-02-07-aoi#land","100":"/dotnet/2020-02-07-aoi#patch","101":"/dotnet/2020-02-07-aoi#分块管理","102":"/dotnet/2020-02-07-aoi#incserver的aoi","103":"/dotnet/2020-02-07-aoi#九宫格","104":"/dotnet/2020-02-07-aoi#灯塔法","105":"/dotnet/2020-02-07-aoi#十字链表法","106":"/dotnet/2020-02-07-aoi#十字链表基本原理","107":"/dotnet/2020-02-07-aoi#目前常用的排序算法","108":"/dotnet/2020-02-07-aoi#快慢针","109":"/dotnet/2020-02-07-aoi#实现方式","110":"/dotnet/2020-02-07-aoi#优缺点","111":"/dotnet/2020-02-10-icloneable#icloneable接口","112":"/dotnet/2020-02-10-icloneable#一个测试类","113":"/dotnet/2020-02-11-gc#一gc的工作区域","114":"/dotnet/2020-02-11-gc#二垃圾对象的判定","115":"/dotnet/2020-02-11-gc#_1引用计数法","116":"/dotnet/2020-02-11-gc#_2可达性分析算法","117":"/dotnet/2020-02-11-gc#三垃圾回收算法","118":"/dotnet/2020-02-11-gc#_1标记-清除算法","119":"/dotnet/2020-02-11-gc#_2标记整理压缩算法","120":"/dotnet/2020-02-11-gc#_3复制算法","121":"/dotnet/2020-02-11-gc#_4三种算法总结","122":"/dotnet/2020-02-11-gc#_5分代收集算法","123":"/dotnet/2020-02-11-gc#各平台gc算法","124":"/dotnet/2020-02-11-gc#关于c和java中的循环引用","125":"/dotnet/2020-02-13-csharp-run#编译器","126":"/dotnet/2020-02-13-csharp-run#mono系列","127":"/dotnet/2020-02-13-csharp-run#编译为-msil","128":"/dotnet/2020-02-13-csharp-run#将-msil-编译为本机代码","129":"/dotnet/2020-02-13-csharp-run#由-jit-编译器编译","130":"/dotnet/2020-02-13-csharp-run#使用-ngenexe-的安装时代码生成","131":"/dotnet/2020-02-13-csharp-run#运行","132":"/dotnet/2020-05-29-abp-start#替换数据库为mysql","133":"/dotnet/2020-05-29-abp-start#初始化项目","134":"/dotnet/2020-05-29-abp-start#关于客户端js","135":"/dotnet/2020-06-11-identityserver-use#错误","136":"/dotnet/2020-07-05-abp-database-user#数据迁移上下文","137":"/dotnet/2020-07-05-abp-database-user#为什么这样设计","138":"/dotnet/2020-07-05-abp-database-user#如何共用user","139":"/dotnet/2020-07-05-abp-database-user#如何给identityuser添加额外的属性","140":"/dotnet/2020-07-05-abp-database-user#extra-properties","141":"/dotnet/2020-07-05-abp-database-user#映射","142":"/dotnet/2020-07-05-abp-database-user#同步","143":"/dotnet/2020-07-10-abp-doc#配置","144":"/dotnet/2020-07-10-abp-doc#原理","145":"/dotnet/2020-07-10-abp-doc#关于版本","146":"/dotnet/2020-07-10-abp-doc#关于多语言","147":"/dotnet/2020-07-10-abp-doc#关于参数doc-params","148":"/dotnet/2020-07-10-abp-doc#关于doc-template","149":"/dotnet/2020-07-10-abp-doc#_404","150":"/dotnet/2020-07-15-abp-default-language#abp默认语言规则","151":"/dotnet/2020-07-15-abp-default-language#中间件request的语言判断","152":"/dotnet/2020-07-15-abp-default-language#querystringrequestcultureprovider","153":"/dotnet/2020-07-15-abp-default-language#cookierequestcultureprovider","154":"/dotnet/2020-07-15-abp-default-language#acceptlanguageheaderrequestcultureprovider","155":"/dotnet/2020-07-15-abp-default-language#cultures","156":"/dotnet/2020-07-15-abp-default-language#abp的实现","157":"/dotnet/2020-07-15-abp-default-language#如何修改默认语言","158":"/dotnet/2020-08-09-orleans-best-practices#重入","159":"/dotnet/2020-08-09-orleans-best-practices#无状态grain","160":"/dotnet/2020-08-09-orleans-best-practices#time","161":"/dotnet/2020-08-09-orleans-best-practices#错误","162":"/dotnet/2020-08-09-orleans-best-practices#相关链接","163":"/dotnet/2020-08-15-kestrel-source-code#定义-iserverihttpapplicationtcontext","164":"/dotnet/2020-08-15-kestrel-source-code#web-服务器-iserver","165":"/dotnet/2020-08-15-kestrel-source-code#http应用程序-ihttpapplicationtcontext","166":"/dotnet/2020-08-15-kestrel-source-code#实现-kestrelserver","167":"/dotnet/2020-08-15-kestrel-source-code#服务器启动端口监听协议解析及请求处理","168":"/dotnet/2020-08-15-kestrel-source-code#处理http请求-httpconnectionmiddlewareservicecontexthttpconnection","169":"/dotnet/2020-08-15-kestrel-source-code#http版本控制-httpconnection","170":"/dotnet/2020-08-15-kestrel-source-code#结束语","171":"/dotnet/2020-08-17-netcore-options#背景","172":"/dotnet/2020-08-17-netcore-options#示例","173":"/dotnet/2020-08-17-netcore-options#分析","174":"/dotnet/2020-08-17-netcore-options#结论","175":"/dotnet/2020-11-13-reflection-method#性能对比数据","176":"/dotnet/2020-11-13-reflection-method#如何实现","177":"/dotnet/2020-11-24-flags#并集-添加","178":"/dotnet/2020-11-24-flags#差集-去除","179":"/dotnet/2020-11-24-flags#补集对称差集","180":"/dotnet/2020-11-24-flags#交集-检查","181":"/dotnet/2020-12-11-chrome-login-fail#introduction","182":"/dotnet/2020-12-11-chrome-login-fail#how-to-solve-it","183":"/dotnet/2020-12-11-chrome-login-fail#step-1","184":"/dotnet/2020-12-11-chrome-login-fail#step-2","185":"/dotnet/2020-12-11-chrome-login-fail#step-3","186":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#why-byte-arrays","187":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#why-structures","188":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#binaryformatter","189":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#performance","190":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#binarywriterbinaryreader","191":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#performance-1","192":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#some-concerns","193":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#marshalling","194":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#performance-2","195":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#comparison","196":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays#conclusion","197":"/game/2021-01-20-perlin-map#基本原理","198":"/game/2021-01-20-perlin-map#代码实现","199":"/game/2021-01-20-perlin-map#准备工作","200":"/game/2021-01-20-perlin-map#fade函数","201":"/game/2021-01-20-perlin-map#哈希函数","202":"/game/2021-01-20-perlin-map#梯度函数","203":"/game/2021-01-20-perlin-map#插值整合","204":"/game/2021-01-20-perlin-map#利用倍频实现更自然的噪声","205":"/game/2021-01-20-perlin-map#unity","206":"/game/2021-01-21-wave-collapse-function#什么是波函数坍塌","207":"/game/2021-01-21-wave-collapse-function#基本原理","208":"/game/2021-01-21-wave-collapse-function#描述问题","209":"/game/2021-01-21-wave-collapse-function#获得约束矩阵","210":"/game/2021-01-21-wave-collapse-function#搜索算法","211":"/game/2021-01-21-wave-collapse-function#链接","212":"/game/2021-01-22-civ-map#对称性对抗游戏简介","213":"/game/2021-01-22-civ-map#地图的平衡性指标","214":"/game/2021-01-22-civ-map#地图的生成过程","215":"/game/2021-01-22-civ-map#生成地图质量的定量评估","216":"/game/2021-01-22-civ-map#","217":"/game/2021-01-23-roguelike-map#引言","218":"/game/2021-01-23-roguelike-map#这款算法的目标","219":"/game/2021-01-23-roguelike-map#计划","220":"/game/2021-01-23-roguelike-map#算法","221":"/game/2021-01-23-roguelike-map#例子","222":"/game/2021-01-23-roguelike-map#总结","223":"/game/2021-01-23-roguelike-map#代码实现","224":"/game/2021-01-23-spelunky-map#part1-创建solution-path-关卡通路","225":"/game/2021-01-23-spelunky-map#part2-创建房间-关卡生成算法的第二部分生成room我们先不考虑那些障碍物陷阱敌人和宝箱什么的","226":"/game/2021-06-12-edgar-code-read#生成类","227":"/game/2021-06-12-edgar-code-read#generate流程","228":"/game/2021-06-12-edgar-code-read#pipelinetask","229":"/game/2021-06-12-edgar-code-read#door-sockets","230":"/game/2021-06-12-edgar-code-read#对于连接处","231":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#特效","232":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#添加特效到角色","233":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#特效gameplayeffectscriptableobject本身","234":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#技能","235":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#技能释放流程","236":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#检查cost","237":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#检查cooldow","238":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#检查abilitytags","239":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#abilitytags","240":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode#checkgameplaytags被定义在每个ability下然后对其重写","241":"/game/2021-12-21-gyj-skill#释放前","242":"/game/2021-12-21-gyj-skill#释放后","243":"/game/2021-12-21-gyj-skill#攻击动作","244":"/game/2021-12-21-gyj-skill#其他动作","245":"/game/2021-12-21-gyj-skill#特效","246":"/game/2021-12-21-gyj-skill#特效动作","247":"/game/2021-12-21-gyj-skill#案例","248":"/game/2021-12-21-gyj-skill#技能词条skillterm","249":"/game/2021-12-21-gyj-skill#tag","250":"/game/2021-12-21-gyj-skill#武器技能","251":"/game/2021-12-21-gyj-skill#如果不同的职业技能都能升级到20级那就没有职业差异化了儒家也可用20级道家的技能这样是不对的","252":"/game/2022-02-19-quest-machine#npc任务指示的显示","253":"/game/2022-02-19-quest-machine#任务接受流程","254":"/game/2022-02-19-quest-machine#任务分类","255":"/game/2022-02-19-quest-machine#显示","256":"/game/2022-03-16-gyj-map#npc生成方式","257":"/game/2022-03-16-gyj-map#默认的npc","258":"/game/2022-03-16-gyj-map#运行时的npc","259":"/game/2022-03-16-gyj-map#怪物","260":"/game/2022-03-16-gyj-map#只运行ai的npc","261":"/game/2022-03-16-gyj-map#场景资源","262":"/game/2022-03-16-gyj-map#用户物品","263":"/game/2022-08-03-ecs#代码中创建实体然后绑定view","264":"/game/2022-08-03-ecs#在link的时候创建相关实体","265":"/game/2022-08-05-dia2#怪物等级","266":"/game/2022-08-05-dia2#怪物的分类","267":"/game/2022-08-05-dia2#财宝阶层","268":"/game/2022-08-05-dia2#掉落规则","269":"/game/2022-08-05-dia2#物品等级","270":"/game/2022-08-05-dia2#词缀等级","271":"/game/2022-08-05-dia2#品质等级","272":"/game/2022-08-05-dia2#财富等级","273":"/game/2022-08-05-dia2#底材","274":"/game/2022-08-05-dia2#掉落机制","275":"/game/2022-08-05-dia2#掉落过程","276":"/game/2022-08-21-behavior-tree-source-code#行为树的构建","277":"/game/2022-08-21-behavior-tree-source-code#行为树的运行","278":"/game/2022-08-21-behavior-tree-source-code#持续的任务是怎么运行的","279":"/game/2022-08-21-behavior-tree-source-code#使用","280":"/game/2022-08-21-behavior-tree-source-code#并行","281":"/game/2022-08-21-behavior-tree-source-code#序列","282":"/game/2022-08-21-behavior-tree-source-code#选择","283":"/game/2022-08-21-behavior-tree-source-code#观察者模式","284":"/game/2022-08-21-behavior-tree-source-code#条件和装饰器","285":"/gyj/2022-06-11-meishuyaoqiu#服装","286":"/gyj/2022-06-11-meishuyaoqiu#修改","287":"/gyj/2022-06-11-meishuyaoqiu#场景制作说明","288":"/gyj/2022-06-12-jichuzhishi#_1-游戏名称","289":"/gyj/2022-06-12-jichuzhishi#存档","290":"/gyj/2022-06-12-jichuzhishi#体力的回复","291":"/gyj/2022-06-12-jichuzhishi#时间与日期","292":"/gyj/2022-08-22-detufangjiandezhonglei#怪物在地图种的类型","293":"/gyj/2022-08-22-detufangjiandezhonglei#怪物在地图中的等级","294":"/gyj/2022-08-22-qiyushijian#关于奖惩","295":"/gyj/2022-08-22-qiyushijian#修仙式人生","296":"/gyj/2022-08-22-qiyushijian#阴阳师","297":"/gyj/2022-08-22-qiyushijian#外道巢穴","298":"/gyj/2022-08-22-wupinchanchubiao#物品产出表","299":"/gyj/2022-08-22-wupinchanchubiao#野外食物产出","300":"/gyj/2022-08-22-wupinchanchubiao#产出种类","301":"/gyj/2022-08-22-wupinchanchubiao#城市产出说明","302":"/gyj/2022-08-22-wupinchanchubiao#树木","303":"/gyj/2022-08-22-wupinchanchubiao#作物","304":"/gyj/2022-08-22-wupinchanchubiao#药材","305":"/gyj/2022-08-22-wupinchanchubiao#动物","306":"/gyj/2022-08-22-wupinchanchubiao#鱼类","307":"/gyj/2022-08-22-wupinchanchubiao#矿石","308":"/gyj/2022-08-22-wupinchanchubiao#宝石","309":"/gyj/2022-08-22-wupinchanchubiao#晶石","310":"/gyj/2022-08-22-wanfa#玩法","311":"/gyj/2022-08-22-wanfa#收集","312":"/gyj/2022-08-22-wanfa#收集九块令牌","313":"/gyj/2022-08-22-wanfa#收集不同的植物","314":"/gyj/2022-08-22-wanfa#收集不同的矿物","315":"/gyj/2022-08-22-wanfa#收集不同的鱼类","316":"/gyj/2022-08-22-wanfa#收集不同的草药","317":"/gyj/2022-08-22-wanfa#收集古董","318":"/gyj/2022-08-22-wanfa#帮派","319":"/gyj/2022-08-22-wanfa#经济","320":"/gyj/2022-08-22-wanfa#门派","321":"/gyj/2022-08-22-wanfa#副本","322":"/gyj/2022-08-22-wanfa#秘境","323":"/gyj/2022-08-22-wanfa#蛙岛","324":"/gyj/2022-08-22-wanfa#大逃杀","325":"/gyj/2022-08-22-wanfa#roguelike","326":"/gyj/2022-08-22-wanfa#爬塔","327":"/gyj/2022-08-22-wanfa#节日","328":"/gyj/2022-08-22-wanfa#端午划龙舟","329":"/gyj/2022-08-22-wanfa#比武大会","330":"/gyj/2022-08-22-wanfa#元宵节","331":"/gyj/2022-08-22-wanfa#猜灯谜","332":"/gyj/2022-08-22-wanfa#入侵模式","333":"/gyj/2022-08-22-wanfa#强盗王","334":"/gyj/2022-08-22-wanfa#杀了150个强盗","335":"/gyj/2022-08-22-wanfa#白莲教","336":"/gyj/2022-08-22-wanfa#魔教","337":"/gyj/2022-08-22-wanfa#谋反","338":"/gyj/2022-08-22-wanfa#蛇人入侵","339":"/gyj/2022-08-22-wanfa#僵尸王","340":"/gyj/2022-08-22-wanfa#天人入侵","341":"/gyj/2022-08-22-wanfa#四大圣兽入侵","342":"/gyj/2022-08-22-wanfa#妖族入侵","343":"/gyj/2022-08-22-wanfa#入侵模式不能售卖东西不能大地图移动","344":"/gyj/2022-08-22-wanfa#门客","345":"/gyj/2022-08-22-wanfa#护卫","346":"/gyj/2022-08-22-wanfa#跑商","347":"/gyj/2022-08-22-wanfa#种植","348":"/gyj/2022-08-22-wanfa#养殖","349":"/gyj/2022-08-22-wanfa#寻宝","350":"/gyj/2022-08-22-wanfa#探索","351":"/gyj/2022-08-22-wanfa#去不同的城市","352":"/gyj/2022-08-22-wanfa#资源有限会被采光","353":"/gyj/2022-08-22-wanfa#宝箱","354":"/gyj/2022-08-22-wanfa#利用关系解锁地块","355":"/gyj/2022-08-22-wanfa#人物","356":"/gyj/2022-08-22-wanfa#宝箱-1","357":"/gyj/2022-08-22-wanfa#故事剧情","358":"/gyj/2022-08-22-wanfa#奖励","359":"/gyj/2022-08-22-wanfa#好看的场景","360":"/gyj/2022-08-22-wanfa#隐藏地图","361":"/gyj/2022-08-22-wanfa#武学","362":"/gyj/2022-08-22-wanfa#npc互动和小游戏","363":"/gyj/2022-08-22-wanfa#打牌","364":"/gyj/2022-08-22-wanfa#三消","365":"/gyj/2022-08-22-wanfa#_24点","366":"/gyj/2022-08-22-wanfa#猜谜","367":"/gyj/2022-08-22-wanfa#切磋","368":"/gyj/2022-08-22-zhiyeyugongzuo#职业","369":"/gyj/2022-08-22-zhiyeyugongzuo#如何开酒楼和医院","370":"/gyj/2022-11-01-tianxiabatu#天下霸图2","371":"/gyj/2022-11-01-tianxiabatu#时间观念","372":"/gyj/2022-11-01-tianxiabatu#薪资","373":"/gyj/2022-11-01-tianxiabatu#弟子心情","374":"/gyj/2022-11-01-tianxiabatu#学习力","375":"/gyj/2022-11-01-tianxiabatu#工作时辰编排","376":"/gyj/2022-11-01-tianxiabatu#设施","377":"/gyj/2022-11-01-tianxiabatu#战斗","378":"/gyj/2022-11-01-tianxiabatu#职位","379":"/gyj/2022-11-01-tianxiabatu#天下霸图","380":"/gyj/2022-11-01-tianxiabatu#设施建造","381":"/gyj/2022-11-01-tianxiabatu#座次排定","382":"/gyj/2022-11-01-tianxiabatu#行程安排","383":"/gyj/2022-11-01-tianxiabatu#对外交涉","384":"/gyj/2022-11-17-liufangzhilu#属性","385":"/gyj/2022-11-17-liufangzhilu#伤害公式","386":"/gyj/2022-11-17-sect#角色属性","387":"/gyj/2022-11-17-sect#任务","388":"/gyj/2022-11-17-sect#弟子培养差事","389":"/gyj/2022-11-17-sect#门派内差事","390":"/gyj/2022-12-15-renwushuxing#初始属性","391":"/gyj/2022-12-15-renwushuxing#气质才情","392":"/gyj/2022-12-15-renwushuxing#境界属性","393":"/gyj/2022-12-15-renwushuxing#生活属性","394":"/gyj/2022-12-15-renwushuxing#战斗属性","395":"/gyj/2022-12-15-renwushuxing#一级属性","396":"/gyj/2022-12-15-renwushuxing#二级属性","397":"/js/2022-02-12-typescript-use-js#使用流程","398":"/js/2022-02-12-typescript-use-js#声明文件","399":"/js/2022-02-12-typescript-use-js#全局类库","400":"/js/2022-02-12-typescript-use-js#模块类库","401":"/js/2022-02-12-typescript-use-js#umd类库","402":"/js/2022-02-12-typescript-use-js#为类库添加插件","403":"/js/2023-05-16-nuxt3-init-fail#问题","404":"/js/2023-05-16-nuxt3-init-fail#解决方案","405":"/js/2024-03-17-flex-use#一flex-布局是什么","406":"/js/2024-03-17-flex-use#二基本概念","407":"/tool/2019-06-20-windows-send-to-ftp#右键发送到菜单位置","408":"/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows#desktopini-contents-for-various-shell-folders","409":"/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows#for-windows-7","410":"/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows#for-windows-vista","411":"/tool/2019-08-07-sourcetree-git-password#git密钥存储相关","412":"/tool/2019-08-07-sourcetree-git-password#推荐使用凭证存储模式-manager","413":"/tool/2019-08-07-sourcetree-git-password#store的使用","414":"/tool/2019-08-07-sourcetree-git-password#微软特有的git-credential-manager","415":"/tool/2019-08-07-sourcetree-git-password#安裝-git-credential-manager-for-windows解决","416":"/tool/2019-08-07-sourcetree-git-password#安裝-git-credential-manager-core解决","417":"/tool/2019-08-07-sourcetree-git-password#检查验证工具是否在path中","418":"/tool/2019-08-07-sourcetree-git-password#sourcetree删除git密码","419":"/tool/2019-08-07-sourcetree-git-password#store","420":"/tool/2019-08-07-sourcetree-git-password#manager","421":"/tool/2019-08-07-sourcetree-git-password#其他","422":"/tool/2019-08-07-sourcetree-git-password#同网站多账号的问题","423":"/tool/2019-08-07-sourcetree-git-password#相关链接","424":"/tool/2019-08-10-powershell-command#常用命令","425":"/tool/2019-08-10-powershell-command#使用c类调用powershell-命令","426":"/tool/2019-08-20-scoop-use#安装scoop前提","427":"/tool/2019-08-20-scoop-use#常用命令","428":"/tool/2019-08-20-scoop-use#安装scoop到自定义目录","429":"/tool/2019-08-20-scoop-use#快捷方式","430":"/tool/2019-08-20-scoop-use#安装应用","431":"/tool/2019-08-20-scoop-use#apache","432":"/tool/2019-08-20-scoop-use#修改配置","433":"/tool/2019-08-20-scoop-use#redis","434":"/tool/2019-08-20-scoop-use#mysql","435":"/tool/2019-08-20-scoop-use#pwsh","436":"/tool/2019-08-20-scoop-use#自制bucket","437":"/tool/2019-08-20-scoop-use#如何解压exe的程序","438":"/tool/2019-08-20-scoop-use#导出-scoop-软件列表","439":"/tool/2019-09-02-nuget-manager#相关连接","440":"/tool/2019-09-02-redis-aof-rdb#rdb优点与缺点","441":"/tool/2019-09-02-redis-aof-rdb#优点","442":"/tool/2019-09-02-redis-aof-rdb#缺点","443":"/tool/2019-09-02-redis-aof-rdb#aof-命令同步","444":"/tool/2019-09-02-redis-aof-rdb#命令传播","445":"/tool/2019-09-02-redis-aof-rdb#缓存追加","446":"/tool/2019-09-02-redis-aof-rdb#文件写入和保存","447":"/tool/2019-09-02-redis-aof-rdb#aof-保存模式","448":"/tool/2019-09-02-redis-aof-rdb#不保存","449":"/tool/2019-09-02-redis-aof-rdb#每一秒钟保存一次","450":"/tool/2019-09-02-redis-aof-rdb#每执行一个命令保存一次","451":"/tool/2019-09-02-redis-aof-rdb#aof-保存模式对性能和安全性的影响","452":"/tool/2019-09-02-redis-aof-rdb#aof-文件的读取和数据还原","453":"/tool/2019-09-02-redis-aof-rdb#aof-重写","454":"/tool/2019-09-02-redis-aof-rdb#aof-重写的实现","455":"/tool/2019-09-02-redis-aof-rdb#aof-后台重写","456":"/tool/2019-09-02-redis-aof-rdb#aof-后台重写的触发条件","457":"/tool/2019-09-02-redis-aof-rdb#小结","458":"/tool/2020-01-02-google-clound-local-login#使用普通用户登陆","459":"/tool/2020-01-02-google-clound-local-login#生成私钥","460":"/tool/2020-01-02-google-clound-local-login#添加公钥到谷歌云的实例中","461":"/tool/2020-01-02-google-clound-local-login#使用ssh工具连接到实例","462":"/tool/2020-01-02-google-clound-local-login#使用-root-账户登陆和修改root密码","463":"/tool/2020-01-02-google-clound-local-login#先选择从浏览器打开ssh连接服务器","464":"/tool/2020-01-02-google-clound-local-login#接着修改ssh配置文件etcsshsshd_config","465":"/tool/2020-01-12-centosn-ss-install#安装-pip","466":"/tool/2020-01-12-centosn-ss-install#安装配置-shadowsocks","467":"/tool/2020-01-12-centosn-ss-install#客户端","468":"/tool/2020-01-12-centosn-ss-install#前台运行","469":"/tool/2020-01-12-centosn-ss-install#后台运行","470":"/tool/2020-01-12-centosn-ss-install#method-aes-256-gcm-not-supported方法","471":"/tool/2020-01-12-centosn-ss-install#proxychains","472":"/tool/2020-01-12-centosn-ss-install#安装","473":"/tool/2020-01-12-centosn-ss-install#配置","474":"/tool/2020-01-12-centosn-ss-install#用法","475":"/tool/2020-01-12-centosn-ss-install#服务端","476":"/tool/2020-01-12-centosn-ss-install#错误","477":"/tool/2020-01-13-brew#将brew装在非系统盘","478":"/tool/2020-01-13-brew#切换国内的镜像源","479":"/tool/2020-01-13-brew#使用中科大的镜像","480":"/tool/2020-01-13-brew#使用清华大学的镜像","481":"/tool/2020-01-13-brew#使用-brewfile-完成环境迁移","482":"/tool/2020-01-13-brew#常用软件","483":"/tool/2020-01-13-brew#常用链接","484":"/tool/2020-03-25-protobuf-empty-collections#base-derived-classes","485":"/tool/2020-03-25-protobuf-empty-collections#avoid-duplicate-property-tags","486":"/tool/2020-03-25-protobuf-empty-collections#null-vs-empty-collections","487":"/tool/2020-03-25-protobuf-empty-collections#things-to-remember","488":"/tool/2020-03-25-protobuf-empty-collections#allowparseabletypes","489":"/tool/2020-03-25-protobuf-empty-collections#protobuf-net-generics-on-unity3d-il2cpp","490":"/tool/2020-06-27-linux-github-slow#_1获取github地址","491":"/tool/2020-06-27-linux-github-slow#_2获取-globalsslfastly地址","492":"/tool/2020-06-27-linux-github-slow#_3打开hosts映射","493":"/tool/2020-06-27-linux-github-slow#windows环境","494":"/tool/2020-06-27-linux-github-slow#linux环境","495":"/tool/2020-06-27-linux-github-slow#速度对比","496":"/tool/2020-07-02-win10-start-menu#添加应用到开始屏幕","497":"/tool/2020-07-02-win10-start-menu#备份与恢复","498":"/tool/2020-07-02-win10-start-menu#其他路径","499":"/tool/2020-07-02-win10-start-menu#相关链接","500":"/tool/2020-07-06-gitbook-use#使用npm安装gitbook","501":"/tool/2020-07-06-gitbook-use#编写gitbook","502":"/tool/2020-07-06-gitbook-use#创建电子书的文件夹目录","503":"/tool/2020-07-06-gitbook-use#初始化gitbook","504":"/tool/2020-07-06-gitbook-use#使用typora来编写框架内容","505":"/tool/2020-07-06-gitbook-use#重新使用gitbook根据目录初始化篇章","506":"/tool/2020-07-06-gitbook-use#启动服务预览书籍","507":"/tool/2020-07-06-gitbook-use#结合-github-pages","508":"/tool/2020-07-11-github-actions#快速开始","509":"/tool/2020-07-11-github-actions#安全相关","510":"/tool/2020-07-11-github-actions#自动创建项目release","511":"/tool/2020-07-11-github-actions#ssh命令","512":"/tool/2020-07-11-github-actions#dotfx","513":"/tool/2020-07-11-github-actions#hexo","514":"/tool/2020-07-11-github-actions#gitbook","515":"/tool/2020-07-11-github-actions#市场","516":"/tool/2020-07-12-hexo-github#使用hexo","517":"/tool/2020-07-12-hexo-github#github-actions","518":"/tool/2020-07-13-terminal-proxy#cmd","519":"/tool/2020-07-13-terminal-proxy#powershell","520":"/tool/2020-07-13-terminal-proxy#linux","521":"/tool/2020-07-13-terminal-proxy#git","522":"/tool/2020-08-30-nuget-is-big#如何发现的","523":"/tool/2020-08-30-nuget-is-big#查看c盘存储","524":"/tool/2020-08-30-nuget-is-big#如何解决","525":"/tool/2020-08-30-nuget-is-big#参考连接","526":"/tool/2020-11-15-unity-is-big#包缓存太大","527":"/tool/2020-11-15-unity-is-big#商店资源太大","528":"/tool/2021-05-06-dns#微软dns服务器可以长期信赖的稳定服务器","529":"/tool/2021-05-06-dns#国内公共dns服务提供商","530":"/tool/2021-11-07-cockpit-linux#添加nginxconf配置","531":"/tool/2021-11-07-cockpit-linux#修改cockpit","532":"/tool/2021-11-07-cockpit-linux#参考链接","533":"/tool/2021-11-15-install-windowsstore#安装","534":"/tool/2021-12-02-vscode-plugins-big#前言","535":"/tool/2021-12-02-vscode-plugins-big#原始打包","536":"/tool/2021-12-02-vscode-plugins-big#使用-webpack-进行打包","537":"/tool/2021-12-02-vscode-plugins-big#使用-externals-减少-bundle-体积","538":"/tool/2021-12-02-vscode-plugins-big#总结","539":"/tool/2021-12-11-yunxiao-liushuixian-hexo#构建","540":"/tool/2021-12-11-yunxiao-liushuixian-hexo#部署","541":"/tool/2021-12-11-yunxiao-liushuixian-hexo#注意点","542":"/tool/2021-12-12-github-sync#复刻仓库","543":"/tool/2021-12-12-github-sync#增加复刻的仓库作为上游远程仓库","544":"/tool/2022-01-30-code-server#官方文档","545":"/tool/2022-01-30-code-server#原理基础","546":"/tool/2022-01-30-code-server#安装","547":"/tool/2022-01-30-code-server#linux标准安装方式","548":"/tool/2022-01-30-code-server#fedora-centos-rhel-suse","549":"/tool/2022-01-30-code-server#windows","550":"/tool/2022-01-30-code-server#配置","551":"/tool/2022-08-09-amd-over#title-amd-超频总结","552":"/tool/2022-11-19-rider-po-jie#使用ja-netfilter激活idea-202221","553":"/tool/2022-11-19-rider-po-jie#背景","554":"/tool/2022-11-19-rider-po-jie#下载idea","555":"/tool/2022-11-19-rider-po-jie#下载ja-netfilter","556":"/tool/2022-11-19-rider-po-jie#使用ja-netfilter","557":"/tool/2022-11-19-rider-po-jie#修改dnsconf","558":"/tool/2022-11-19-rider-po-jie#修改urlconf","559":"/tool/2022-11-19-rider-po-jie#修改idea-vmoption文件","560":"/tool/2022-11-19-rider-po-jie#激活idea","561":"/tool/2022-11-19-rider-po-jie#常见问题","562":"/tool/2022-11-19-rider-po-jie#idea提示激活码无效-invalid-key","563":"/tool/2022-11-19-rider-po-jie#idea无法启动-运行无反应","564":"/tool/2023-01-20-stable-diffusion-install#硬體需求","565":"/tool/2023-01-20-stable-diffusion-install#安裝步驟","566":"/tool/2023-01-20-stable-diffusion-install#_1-下載並安裝-github-for-windows","567":"/tool/2023-01-20-stable-diffusion-install#_2-下載並安裝-python","568":"/tool/2023-01-20-stable-diffusion-install#_3-下载模型","569":"/tool/2023-01-20-stable-diffusion-install#_4-正式安裝-stable-diffusion","570":"/tool/2023-01-20-stable-diffusion-install#参数解释","571":"/tool/2023-01-20-stable-diffusion-install#当前遇到的问题","572":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#cgi","573":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#起源","574":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#工作原理","575":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#fastcgi","576":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#php-fpm","577":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#wsgi-uwsgi-uwsgi","578":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#wsgi","579":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#uwsgi","580":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#uwsgi-服务器","581":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#nginxuwgsi","582":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#总结","583":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#asgi","584":"/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi#wsgi和asgi的区别","585":"/unity/2019-06-20-unity-android-x64#导出说明","586":"/unity/2019-06-20-unity-android-x64#使用技巧","587":"/unity/2019-06-20-unity-android-x64#相关链接","588":"/unity/2019-06-20-unity-il2cpp-debugger#什么是il2cpp","589":"/unity/2019-06-20-unity-il2cpp-debugger#一个支持虚拟机的运行时库","590":"/unity/2019-06-20-unity-il2cpp-debugger#aot编译器","591":"/unity/2019-06-20-unity-il2cpp-debugger#运行时库","592":"/unity/2019-06-20-unity-il2cpp-debugger#il2cpp是如何执行的","593":"/unity/2019-06-20-unity-il2cpp-debugger#il2cpp没做的事情","594":"/unity/2019-06-20-unity-il2cpp-debugger#我们如何开发测试发布il2cpp","595":"/unity/2019-06-20-unity-il2cpp-debugger#好戏连台","596":"/unity/2019-06-20-unity-il2cpp-debugger#il2cpp-脚本限制","597":"/unity/2019-06-20-unity-il2cpp-debugger#systemreflectionemit","598":"/unity/2019-06-20-unity-il2cpp-debugger#序列化","599":"/unity/2019-06-20-unity-il2cpp-debugger#泛型","600":"/unity/2019-06-20-unity-il2cpp-debugger#泛型方法","601":"/unity/2019-06-20-unity-il2cpp-debugger#animatorcontroller-等","602":"/unity/2019-06-20-unity-il2cpp-debugger#其他","603":"/unity/2019-06-20-unity-il2cpp-debugger#托管代码剥离","604":"/unity/2019-06-20-unity-il2cpp-debugger#il2cpp限制","605":"/unity/2019-06-20-unity-il2cpp-debugger#编译速度优化","606":"/unity/2019-06-20-unity-il2cpp-debugger#相关链接","607":"/unity/2019-06-23-googlplay-pulish#问题-隐私声明","608":"/unity/2019-06-23-googlplay-pulish#问题-1002","609":"/unity/2019-06-23-googlplay-pulish#问题-此商品无法在您设备所在的国家地区安装","610":"/unity/2019-06-23-googlplay-pulish#问题-无法购买您要的商品","611":"/unity/2019-06-23-googlplay-pulish#问题-无法使用该应用此应用的测试版尚未发布或者无法通过此帐号使用","612":"/unity/2019-06-23-googlplay-pulish#问题-此版本的应用未配置为通过googleplay-结算","613":"/unity/2019-06-23-googlplay-pulish#问题-关于如何测试","614":"/unity/2019-06-23-googlplay-pulish#以下是google-iab测试的要求清单","615":"/unity/2019-06-23-googlplay-pulish#先决条件","616":"/unity/2019-06-23-googlplay-pulish#测试要求","617":"/unity/2019-06-23-googlplay-pulish#相关链接","618":"/unity/2019-08-09-unity2d-shipei#unity编辑器中只能直接调整摄像机的高度那摄像机的宽度是如何确定的呢","619":"/unity/2019-08-09-unity2d-shipei#场景适配","620":"/unity/2019-08-09-unity2d-shipei#_2d场景和3d摄像机的适配","621":"/unity/2019-08-09-unity2d-shipei#场景和ui位置的适配","622":"/unity/2019-08-09-unity2d-shipei#_3d形象如何展现在ui中","623":"/unity/2019-08-09-unity2d-shipei#根据场景位置设置ui位置","624":"/unity/2019-08-09-unity2d-shipei#ugui的适配","625":"/unity/2019-08-09-unity2d-shipei#锚点","626":"/unity/2019-08-09-unity2d-shipei#canvas-scaler","627":"/unity/2019-08-09-unity2d-shipei#固定像素-constant-pixel-size","628":"/unity/2019-08-09-unity2d-shipei#根据屏幕大小进行缩放screen-match-mode","629":"/unity/2019-08-09-unity2d-shipei#固定物理大小constant-physical-size","630":"/unity/2019-08-09-unity2d-shipei#刘海屏的适配","631":"/unity/2019-08-09-unity2d-shipei#参考链接","632":"/unity/2019-08-10-ugui-recttransform#在編輯器中快速設定-recttransform","633":"/unity/2019-08-10-ugui-recttransform#recttransform-的控制精髓錨點們-anchor-points","634":"/unity/2019-08-10-ugui-recttransform#a-當兩錨點-x-y-維度的值都相等時","635":"/unity/2019-08-10-ugui-recttransform#b-當兩錨點-x-維度的值不相等y-維度值相等時","636":"/unity/2019-08-10-ugui-recttransform#c-當兩錨點-x-維度的值相等y-維度值不相等時","637":"/unity/2019-08-10-ugui-recttransform#d-當兩錨點-x-y-維度的值都不相等時","638":"/unity/2019-08-10-ugui-recttransform#一些术语解释","639":"/unity/2019-08-10-ugui-recttransform#pivot","640":"/unity/2019-08-10-ugui-recttransform#位置","641":"/unity/2019-08-10-ugui-recttransform#offsetmin-和-offsetmax","642":"/unity/2019-08-10-ugui-recttransform#rect","643":"/unity/2019-08-10-ugui-recttransform#anchormin-和-anchormax","644":"/unity/2019-08-10-ugui-recttransform#sizedelta","645":"/unity/2019-08-10-ugui-recttransform#代码修改坐标及大小","646":"/unity/2019-08-10-ugui-recttransform#recttransform的一些其他操做","647":"/unity/2019-08-10-ugui-recttransform#blue-print-mode藍圖模式-raw-edit-mode原始编辑模式","648":"/unity/2019-08-10-ugui-recttransform#","649":"/unity/2019-08-10-ugui-recttransform#blue-print-mode-藍圖模式","650":"/unity/2019-08-10-ugui-recttransform#raw-edit-mode-原始编辑模式","651":"/unity/2019-08-10-ugui-recttransform#參考資料","652":"/unity/2019-08-11-ugui-eventmanager#onmouse事件","653":"/unity/2019-08-11-ugui-eventmanager#在update中輪詢input物件","654":"/unity/2019-08-11-ugui-eventmanager#eventsystem","655":"/unity/2019-08-11-ugui-eventmanager#eventsystem與onmouse的區別","656":"/unity/2019-08-11-ugui-eventmanager#unity-raycasters-和事件处理","657":"/unity/2019-08-11-ugui-eventmanager#unity的事件处理","658":"/unity/2019-08-11-ugui-eventmanager#阻止手动发送射线穿透ugui问题","659":"/unity/2019-08-11-ugui-eventmanager#message-system改进的消息系统","660":"/unity/2019-08-11-ugui-eventmanager#传统方式进行-message-通信","661":"/unity/2019-08-11-ugui-eventmanager#messaging-system","662":"/unity/2019-08-11-ugui-eventmanager#eventsystem-处理physics","663":"/unity/2019-08-11-ugui-eventmanager#第一步","664":"/unity/2019-08-11-ugui-eventmanager#第二步","665":"/unity/2019-08-11-ugui-eventmanager#第三步","666":"/unity/2019-08-12-ugui-eventsystem-sourcecode#为什么想看看事件系统的实现","667":"/unity/2019-08-12-ugui-eventsystem-sourcecode#入手点","668":"/unity/2019-08-12-ugui-eventsystem-sourcecode#顺藤摸瓜","669":"/unity/2019-08-12-ugui-eventsystem-sourcecode#触摸事件处理","670":"/unity/2019-08-12-ugui-eventsystem-sourcecode#首先处理点击事件-processtouchpress","671":"/unity/2019-08-12-ugui-eventsystem-sourcecode#按下的情形","672":"/unity/2019-08-12-ugui-eventsystem-sourcecode#放开的情形","673":"/unity/2019-08-12-ugui-eventsystem-sourcecode#之后处理move以及drag事件","674":"/unity/2019-08-12-ugui-eventsystem-sourcecode#点击事件处理","675":"/unity/2019-08-12-ugui-eventsystem-sourcecode#射线检测","676":"/unity/2019-08-12-ugui-eventsystem-sourcecode#graphic-raycaster","677":"/unity/2019-08-12-ugui-eventsystem-sourcecode#如何执行事件","678":"/unity/2019-08-12-ugui-eventsystem-sourcecode#直接调用事件-executeeventsexecute","679":"/unity/2019-08-12-ugui-eventsystem-sourcecode#向上查找","680":"/unity/2019-08-12-ugui-eventsystem-sourcecode#事件链","681":"/unity/2019-08-12-ugui-eventsystem-sourcecode#事件触发机制总结","682":"/unity/2019-08-12-ugui-eventsystem-sourcecode#总结","683":"/unity/2019-08-12-ugui-raycasters#baseraycaster-类","684":"/unity/2019-08-12-ugui-raycasters#physics-raycaster","685":"/unity/2019-08-12-ugui-raycasters#physics2d-raycaster","686":"/unity/2019-08-12-ugui-raycasters#graphic-raycaster","687":"/unity/2019-08-12-ugui-raycasters#属性或方法","688":"/unity/2019-08-12-ugui-raycasters#graphicraycasterraycast","689":"/unity/2019-08-12-ugui-raycasters#blocked-objects-和-blocked-mask-出场","690":"/unity/2019-08-12-ugui-raycasters#graphicraycaster-类重载了-真-raycast-方法","691":"/unity/2019-08-12-ugui-raycasters#graphicraycast","692":"/unity/2019-08-12-ugui-raycasters#graphicraycast-成功的对象深度排序","693":"/unity/2019-08-12-ugui-raycasters#reversed-graphics-过滤","694":"/unity/2019-08-12-ugui-raycasters#distance-检测是最终一道坎","695":"/unity/2019-08-12-ugui-raycasters#射线检测前后的一些操作","696":"/unity/2019-09-01-addressable#镜像资源的加载与卸载","697":"/unity/2019-09-01-addressable#资源加载","698":"/unity/2019-09-01-addressable#场景加载","699":"/unity/2019-09-01-addressable#gameobject的实例化","700":"/unity/2019-09-01-addressable#addressable分析工具","701":"/unity/2019-09-01-addressable#内存清理时机","702":"/unity/2019-09-01-addressable#一些注意点","703":"/unity/2019-09-01-spriteatlas#ugui的合图是在什么时候发生的","704":"/unity/2019-09-01-spriteatlas#include-in-build到底干了什么","705":"/unity/2019-09-01-spriteatlas#禁用include-in-build使用late-binding","706":"/unity/2019-09-01-spriteatlas#相关链接","707":"/unity/2019-09-02-ilruntime#appdomain","708":"/unity/2019-09-02-ilruntime#使用dll进行热更","709":"/unity/2019-09-02-ilruntime#ios不能基于以上热更的原因","710":"/unity/2019-09-02-ilruntime#ilruntime","711":"/unity/2019-09-02-ilruntime#借助monoceil库来读取dll的pe信息以及当中类型的所有信息","712":"/unity/2019-09-02-ilruntime#最终得到方法的il汇编码","713":"/unity/2019-09-02-ilruntime#readcliheader","714":"/unity/2019-09-02-ilruntime#基于loadedtypes来实现反射方法的调用","715":"/unity/2019-09-02-ilruntime#基于appdomain内嵌的invoke来实现反射","716":"/unity/2019-09-02-ilruntime#热更新dll和unity主工程的相互调用","717":"/unity/2019-09-02-ilruntime#热修复hotfix","718":"/unity/2019-09-02-ilruntime#注意","719":"/unity/2019-09-02-ilruntime#相关链接","720":"/unity/2019-09-02-unity-reference-dll#unity默认的defind宏变量","721":"/unity/2019-09-02-unity-reference-dll#在-net-4x-和-net-standard-20-配置文件之间进行选择","722":"/unity/2019-09-02-unity-reference-dll#使用-net-4x-api-兼容级别时添加程序集引用","723":"/unity/2019-09-02-unity-reference-dll#相关链接","724":"/unity/2019-09-13-parallax-2d#什么是视差背景","725":"/unity/2019-09-13-parallax-2d#实现单层背景的滚动","726":"/unity/2019-09-13-parallax-2d#uv-滚动方式","727":"/unity/2019-09-13-parallax-2d#精灵滚动方式","728":"/unity/2019-09-13-parallax-2d#照相机移动方式","729":"/unity/2019-09-13-parallax-2d#混合滚动方式","730":"/unity/2019-09-13-parallax-2d#四种方式的优劣","731":"/unity/2019-09-13-parallax-2d#平均性能","732":"/unity/2019-09-13-parallax-2d#对复杂背景的支持","733":"/unity/2019-09-13-parallax-2d#是否可以无限延伸","734":"/unity/2019-09-13-parallax-2d#复合多层背景的滚动实现视差效果","735":"/unity/2019-09-13-parallax-2d#unity混合模式1","736":"/unity/2019-09-13-parallax-2d#unity混合模式2","737":"/unity/2019-09-13-parallax-2d#结合透视和正交相机在unity2d游戏中制作视差效果","738":"/unity/2020-01-01-unity-entitas#entitas執行流程","739":"/unity/2020-01-01-unity-entitas#tips","740":"/unity/2020-01-01-unity-entitas#group","741":"/unity/2020-01-01-unity-entitas#collector","742":"/unity/2020-01-01-unity-entitas#reactivesystem","743":"/unity/2020-01-01-unity-entitas#事件","744":"/unity/2020-01-01-unity-entitas#关于replace都干了什么","745":"/unity/2020-01-01-unity-entitas#group和collect还有event应该在什么地方添加","746":"/unity/2020-01-01-unity-entitas#jenny","747":"/unity/2020-01-01-unity-entitas#相关链接","748":"/unity/2020-01-11-unity-attack-range-detection-type#_1利用碰撞器的触发器trigger","749":"/unity/2020-01-11-unity-attack-range-detection-type#_2利用数学判断","750":"/unity/2020-01-11-unity-attack-range-detection-type#_3利用射线raycast","751":"/unity/2020-01-11-unity-attack-range-detection-type#_4利用射线linecast","752":"/unity/2020-01-12-collision-detection#外接图形判别法","753":"/unity/2020-01-12-collision-detection#轴对称包围盒axis-aligned-bounding-box","754":"/unity/2020-01-12-collision-detection#圆形碰撞circle-collision","755":"/unity/2020-01-12-collision-detection#圆形与矩形无旋转","756":"/unity/2020-01-12-collision-detection#圆形与旋转矩形以矩形中心为旋转轴","757":"/unity/2020-01-12-collision-detection#其他","758":"/unity/2020-01-12-collision-detection#地图格子划分","759":"/unity/2020-01-12-collision-detection#像素检测","760":"/unity/2020-01-12-collision-detection#光线投射法ray-casting","761":"/unity/2020-01-12-collision-detection#分离轴定理separating-axis-theorem","762":"/unity/2020-01-12-collision-detection#投影轴","763":"/unity/2020-01-12-collision-detection#投影","764":"/unity/2020-01-12-collision-detection#圆形与多边形之间的碰撞检测","765":"/unity/2020-01-12-collision-detection#延伸最小平移向量mit","766":"/unity/2020-01-12-collision-detection#碰撞性能优化","767":"/unity/2020-01-12-collision-detection#粗略阶段broad-phase","768":"/unity/2020-01-12-collision-detection#精细阶段narrow-phase","769":"/unity/2020-01-12-collision-detection#最后","770":"/unity/2020-01-12-collision-detection#参考资料","771":"/unity/2020-01-13-unity-attack-detection#扇形攻击","772":"/unity/2020-01-13-unity-attack-detection#长方形范围攻击检测","773":"/unity/2020-01-13-unity-attack-detection#判断目标点是否在指定的矩形内两个随机点确定的矩形","774":"/unity/2020-01-13-unity-attack-detection#判断目标点是否在某一矩形区域以任一点为中心的矩形区域","775":"/unity/2020-01-13-unity-attack-detection#半圆形攻击范围检测","776":"/unity/2020-01-13-unity-attack-detection#圆形攻击范围","777":"/unity/2020-01-13-unity-attack-detection#判断一个点是否在三角形里面","778":"/unity/2020-01-13-unity-attack-detection#方法二","779":"/unity/2020-01-13-unity-attack-detection#向量","780":"/unity/2020-01-13-unity-attack-detection#向量的点乘","781":"/unity/2020-01-13-unity-attack-detection#向量的叉乘","782":"/unity/2020-01-13-unity-attack-detection#凸多边形碰撞分离轴定理算法","783":"/unity/2020-01-13-unity-attack-detection#算法简述","784":"/unity/2020-01-13-unity-attack-detection#如何在代码中实现","785":"/unity/2020-01-13-unity-attack-detection#那么如何处理圆呢","786":"/unity/2020-01-13-unity-attack-detection#优点与不足","787":"/unity/2020-01-13-unity-attack-detection#优点","788":"/unity/2020-01-13-unity-attack-detection#不足","789":"/unity/2020-01-13-unity-attack-detection#总结","790":"/unity/2020-01-13-unity-attack-detection#其他的一些参考","791":"/unity/2020-02-15-skill-system#_0技能表","792":"/unity/2020-02-15-skill-system#_1-技能信息管理","793":"/unity/2020-02-15-skill-system#_2-技能调用接口","794":"/unity/2020-02-15-skill-system#_3-技能流程管理","795":"/unity/2020-02-15-skill-system#_31-技能树","796":"/unity/2020-02-15-skill-system#_32-执行节点的技能流程","797":"/unity/2020-02-15-skill-system#_4-技能目标查找","798":"/unity/2020-02-15-skill-system#_5技能表现","799":"/unity/2020-02-15-skill-system#_6-弹道法术场和buff等技能创生体","800":"/unity/2020-02-15-skill-system#_61-buff状态","801":"/unity/2020-02-15-skill-system#_62-法术场","802":"/unity/2020-02-15-skill-system#_0-技能同步的原则","803":"/unity/2020-02-15-skill-system#_1-技能执行流程的同步","804":"/unity/2020-02-15-skill-system#使用此同步流程的表现为","805":"/unity/2020-02-15-skill-system#_2-技能树的同步","806":"/unity/2020-02-15-skill-system#_3-技能结算的同步","807":"/unity/2020-02-15-skill-system#法术场弹道的同步","808":"/unity/2020-02-15-skill-system#buff同步","809":"/unity/2020-02-15-skill-system#_4-伤害属性的同步","810":"/unity/2020-02-15-skill-system#技能说穿了只是一个流程而不该是一个实体","811":"/unity/2020-02-15-skill-system#就skill和buff的边界问题","812":"/unity/2020-02-15-skill-system#相关链接","813":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#技术细节托管堆怎样运行以及为什么它会扩张","814":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#托管堆的关键问题","815":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#临时分配","816":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#基础内存维护","817":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#容器和数组重用","818":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#闭包和匿名函数","819":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#il2cpp下的匿名函数","820":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#装箱","821":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#识别装箱","822":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#字典和枚举","823":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#foreach循环","824":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#有数组值的unity-api译者已查在unity官方文档中会明确表明这些api有临时内存分配","825":"/unity/2020-02-18-bestpracticeunderstandingperformanceinunity#空数组重用","826":"/unity/2020-02-19-understandingautomaticmemorymanagement#值类型和引用类型","827":"/unity/2020-02-19-understandingautomaticmemorymanagement#内存分配和垃圾收集","828":"/unity/2020-02-19-understandingautomaticmemorymanagement#优化","829":"/unity/2020-02-19-understandingautomaticmemorymanagement#主动请求垃圾收集","830":"/unity/2020-02-19-understandingautomaticmemorymanagement#小堆垃圾收集快速可频繁收集","831":"/unity/2020-02-19-understandingautomaticmemorymanagement#大堆垃圾收集缓慢且不可频繁收集","832":"/unity/2020-02-19-understandingautomaticmemorymanagement#可重复使用的对象池","833":"/unity/2020-02-19-understandingautomaticmemorymanagement#更多信息","834":"/unity/2020-03-01-unity-debug#vs2019-调试unity失效","835":"/unity/2020-03-01-unity-debug#unity3d-编辑器调试无响应问题","836":"/unity/2020-03-01-unity-debug#原因分析","837":"/unity/2020-03-01-unity-debug#解决办法","838":"/unity/2020-03-01-unity-debug#关于如何进行unity远程debugger","839":"/unity/2020-03-04-unity-startup#脚本编译顺序","840":"/unity/2020-07-01-unity-coordinate#一前言","841":"/unity/2020-07-01-unity-coordinate#二坐标体系","842":"/unity/2020-07-01-unity-coordinate#三总结","843":"/unity/2020-07-03-unity-mesh#title-mesh-renderer-和-mesh-和-mesh-filter","844":"/unity/2020-07-03-unity-mesh#基本概念","845":"/unity/2020-07-03-unity-mesh#texture","846":"/unity/2020-07-03-unity-mesh#mesh","847":"/unity/2020-07-03-unity-mesh#submesh","848":"/unity/2020-07-03-unity-mesh#meshcombine","849":"/unity/2020-07-03-unity-mesh#mesh合并的优缺点","850":"/unity/2020-07-03-unity-mesh#相关链接","851":"/unity/2020-08-29-notch-solution#notch-solution","852":"/unity/2020-08-29-notch-solution#原理","853":"/unity/2020-08-29-notch-solution#safepadding","854":"/unity/2020-09-05-unity-vsynccount#垂直同步","855":"/unity/2020-09-05-unity-vsynccount#省电发热优化","856":"/unity/2020-09-10-optimizing-for-performance#资源检查","857":"/unity/2020-09-10-optimizing-for-performance#代码","858":"/unity/2020-09-10-optimizing-for-performance#cpu","859":"/unity/2020-09-10-optimizing-for-performance#gpu","860":"/unity/2020-09-10-optimizing-for-performance#ui","861":"/unity/2020-09-10-optimizing-for-performance#图集整理","862":"/unity/2020-09-10-optimizing-for-performance#ugui层级合并规则与批次生成规则","863":"/unity/2020-09-10-optimizing-for-performance#ui优化参考","864":"/unity/2020-09-10-optimizing-for-performance#内存","865":"/unity/2020-09-10-optimizing-for-performance#资源","866":"/unity/2020-09-10-optimizing-for-performance#animation","867":"/unity/2020-09-10-optimizing-for-performance#audio","868":"/unity/2020-09-10-optimizing-for-performance#editorsetting","869":"/unity/2020-09-10-optimizing-for-performance#mesh","870":"/unity/2020-09-10-optimizing-for-performance#prefab","871":"/unity/2020-09-10-optimizing-for-performance#scene","872":"/unity/2020-09-10-optimizing-for-performance#texture","873":"/unity/2020-09-10-optimizing-for-performance#resources文件夹","874":"/unity/2020-09-10-optimizing-for-performance#assetbundle","875":"/unity/2020-09-10-optimizing-for-performance#工具检测","876":"/unity/2020-09-10-optimizing-for-performance#drawcall","877":"/unity/2020-09-10-optimizing-for-performance#渲染统计窗口","878":"/unity/2020-09-10-optimizing-for-performance#unity-profiler","879":"/unity/2020-09-11-stack-heap#堆与栈有什么不同","880":"/unity/2020-09-11-stack-heap#什么在堆和栈里","881":"/unity/2020-09-11-stack-heap#值类型","882":"/unity/2020-09-11-stack-heap#引用类型","883":"/unity/2020-09-11-stack-heap#指针","884":"/unity/2020-09-11-stack-heap#两个黄金规则","885":"/unity/2020-09-11-stack-heap#栈工作原理","886":"/unity/2020-09-11-stack-heap#值类型会存储在堆里","887":"/unity/2020-09-11-stack-heap#代码图例","888":"/unity/2020-09-11-stack-heap#堆栈原理对代码的影响","889":"/unity/2020-09-11-stack-heap#代码图例-1","890":"/unity/2020-09-11-stack-heap#参数大画面","891":"/unity/2020-09-11-stack-heap#值类型传递","892":"/unity/2020-09-11-stack-heap#引用类型传递","893":"/unity/2020-09-11-stack-heap#用引用的方式传递引用类型","894":"/unity/2020-09-11-stack-heap#复制不仅仅是复制","895":"/unity/2020-09-11-stack-heap#值类型测试","896":"/unity/2020-09-11-stack-heap#引用类型测试","897":"/unity/2020-09-11-stack-heap#整理我们的代码","898":"/unity/2020-09-11-stack-heap#特殊引用类型string","899":"/unity/2020-09-11-stack-heap#参考","900":"/unity/2020-09-12-addressables#addressablesinitializeasync","901":"/unity/2020-09-12-addressables#iresourcelocator","902":"/unity/2020-09-12-addressables#iresourcelocation","903":"/unity/2020-09-12-addressables#mergemode","904":"/unity/2020-10-15-unity-ecs#ecs核心概念","905":"/unity/2020-10-15-unity-ecs#原型-archetypes","906":"/unity/2020-10-15-unity-ecs#实体-entity","907":"/unity/2020-10-15-unity-ecs#创建entity","908":"/unity/2020-10-15-unity-ecs#添加删除-component","909":"/unity/2020-10-15-unity-ecs#访问实体数据","910":"/unity/2020-10-15-unity-ecs#systembaseentitiesforeach","911":"/unity/2020-10-15-unity-ecs#ijobchunk","912":"/unity/2020-10-15-unity-ecs#manual-iteration","913":"/unity/2020-10-15-unity-ecs#系统-system","914":"/unity/2020-10-15-unity-ecs#disableautocreation","915":"/unity/2020-10-15-unity-ecs#实体查询","916":"/unity/2020-10-15-unity-ecs#jobs-作业","917":"/unity/2020-10-15-unity-ecs#system的组织","918":"/unity/2020-10-15-unity-ecs#组件-component","919":"/unity/2020-10-15-unity-ecs#相关链接","920":"/unity/2020-10-16-unity-job#创建job","921":"/unity/2020-10-16-unity-job#调度job","922":"/unity/2020-10-16-unity-job#job的依赖关系","923":"/unity/2020-10-16-unity-job#jobhandle","924":"/unity/2020-10-16-unity-job#等待job执行完毕","925":"/unity/2020-10-16-unity-job#实例代码","926":"/unity/2020-10-16-unity-job#相关链接","927":"/unity/2020-10-18-unity-ecs-component#general-purpose-component普通用途组件","928":"/unity/2020-10-18-unity-ecs-component#shared-components共享组件","929":"/unity/2020-10-18-unity-ecs-component#内存结构","930":"/unity/2020-10-18-unity-ecs-component#其他要点","931":"/unity/2020-10-18-unity-ecs-component#system-state-components系统状态组件","932":"/unity/2020-10-18-unity-ecs-component#motivation诱因","933":"/unity/2020-10-18-unity-ecs-component#concept概念","934":"/unity/2020-10-18-unity-ecs-component#检测组件的添加","935":"/unity/2020-10-18-unity-ecs-component#检测组件的删除","936":"/unity/2020-10-18-unity-ecs-component#监测实体的删除","937":"/unity/2020-10-18-unity-ecs-component#dynamic-buffers动态缓冲","938":"/unity/2020-10-18-unity-ecs-component#定义缓冲","939":"/unity/2020-10-18-unity-ecs-component#关于prefab到entity","940":"/unity/2020-10-19-game-object-conversion-and-subscene#以前是如何制作游戏的","941":"/unity/2020-10-19-game-object-conversion-and-subscene#如何在-dots-的世界里做游戏","942":"/unity/2020-10-19-game-object-conversion-and-subscene#hybrid-renderer","943":"/unity/2020-10-19-game-object-conversion-and-subscene#让我们用纯数据来做个游戏吧","944":"/unity/2020-10-19-game-object-conversion-and-subscene#transform-systems","945":"/unity/2020-10-19-game-object-conversion-and-subscene#可是这样构建游戏实在是太痛苦了","946":"/unity/2020-10-19-game-object-conversion-and-subscene#conversion-workflow","947":"/unity/2020-10-19-game-object-conversion-and-subscene#conversion-world-destination-world-primary-entity","948":"/unity/2020-10-19-game-object-conversion-and-subscene#gameobjectconversionsystem","949":"/unity/2020-10-19-game-object-conversion-and-subscene#conversion-的顺序","950":"/unity/2020-10-19-game-object-conversion-and-subscene#gameobjectconversionmappingsystem","951":"/unity/2020-10-19-game-object-conversion-and-subscene#让我们使用-converttoentity-来convert吧","952":"/unity/2020-10-19-game-object-conversion-and-subscene#hierarchy-conversion","953":"/unity/2020-10-19-game-object-conversion-and-subscene#disabled-与-gameobject-conversion","954":"/unity/2020-10-19-game-object-conversion-and-subscene#convert-and-inject-模式","955":"/unity/2020-10-19-game-object-conversion-and-subscene#使用-ecs-的system-来管理传统的-monobehaviour","956":"/unity/2020-10-19-game-object-conversion-and-subscene#inject-模式的-conversion-规则","957":"/unity/2020-10-19-game-object-conversion-and-subscene#iconvertgameobjecttoentity","958":"/unity/2020-10-19-game-object-conversion-and-subscene#linkedentitygroup","959":"/unity/2020-10-19-game-object-conversion-and-subscene#从非-prefab-conversion-中获取linkedentitygroup","960":"/unity/2020-10-19-game-object-conversion-and-subscene#尺寸警告","961":"/unity/2020-10-19-game-object-conversion-and-subscene#创建额外的-entity","962":"/unity/2020-10-19-game-object-conversion-and-subscene#从单一源得到-entity","963":"/unity/2020-10-19-game-object-conversion-and-subscene#如何影响-linked-entity-group","964":"/unity/2020-10-19-game-object-conversion-and-subscene#声明-asset","965":"/unity/2020-10-19-game-object-conversion-and-subscene#prefab-asset-conversion-过程","966":"/unity/2020-10-19-game-object-conversion-and-subscene#声明和使用-prefab-asset-的示例","967":"/unity/2020-10-19-game-object-conversion-and-subscene#generateauthoringcomponent","968":"/unity/2020-10-19-game-object-conversion-and-subscene#混用converttoentity的-destroy-和-inject-模式","969":"/unity/2020-10-19-game-object-conversion-and-subscene#companion-game-object","970":"/unity/2020-10-19-game-object-conversion-and-subscene#gameobjectconversionutility","971":"/unity/2020-10-19-game-object-conversion-and-subscene#subscene","972":"/unity/2020-10-21-platform#buildconfiguration","973":"/unity/2020-10-21-platform#buildplayerstep","974":"/unity/2020-10-22-unity-render-order#關於深度緩衝-depth-buffering-or-z-buffering","975":"/unity/2020-10-22-unity-render-order#renderers-rendering-order","976":"/unity/2020-10-22-unity-render-order#补充renderqueue","977":"/unity/2020-10-22-unity-render-order#uguis-rendering-order","978":"/unity/2020-10-22-unity-render-order#使用實踐情境","979":"/unity/2020-10-23-unity-optimizing-gpu#静态批处理1","980":"/unity/2020-10-23-unity-optimizing-gpu#动态批处理4","981":"/unity/2020-10-23-unity-optimizing-gpu#gpu-instancing","982":"/unity/2020-10-23-unity-optimizing-gpu#srp-batcher8","983":"/unity/2020-10-23-unity-optimizing-gpu#_2020年2月13日-更新-更改对统一常量缓冲器的描述对srp-batcher与gpu-instancing的实现原理进行了比较大的修改","984":"/unity/2020-10-23-unity-optimizing-gpu#参考","985":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#_1-使用systemstatecomponent","986":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#原理","987":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#栗子","988":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#_2-查询componentversion","989":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#数据变化","990":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#_1-chunk检查","991":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#原理-1","992":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#举例","993":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#api","994":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#_2-query自动检查","995":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#_3-ijobforeach中使用-changefilter","996":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#示例","997":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#best-practice","998":"/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs#reference","999":"/unity/2020-11-15-ecs-parent#关于转换系统","1000":"/unity/2020-11-15-ecs-parent#parent","1001":"/unity/2020-11-15-ecs-parent#linkedentitygroup","1002":"/unity/2020-11-15-ecs-parent#从非-prefab-conversion-中获取linkedentitygroup","1003":"/unity/2020-11-15-ecs-parent#关于手动添加linkedentitygroup","1004":"/unity/2020-11-15-ecs-parent#关于parent和linkedentitygroup","1005":"/unity/2020-11-15-ecs-parent#最佳的方式去关联entity和prefab","1006":"/unity/2020-11-16-dotssample#ability","1007":"/unity/2020-11-16-dotssample#abilitycollection","1008":"/unity/2020-11-16-dotssample#item","1009":"/unity/2020-11-16-dotssample#character","1010":"/unity/2020-11-16-dotssample#part","1011":"/unity/2020-11-16-dotssample#local-player","1012":"/unity/2020-11-16-dotssample#palyer-实例化流程","1013":"/unity/2020-11-18-netcode-sourcecode#networkstreamreceivesystem","1014":"/unity/2020-11-18-netcode-sourcecode#预测","1015":"/unity/2020-11-18-netcode-sourcecode#插值","1016":"/unity/2020-11-18-netcode-sourcecode#translation和rotation的转换","1017":"/unity/2020-11-18-netcode-sourcecode#clientservertickrate","1018":"/unity/2020-11-18-netcode-sourcecode#补偿","1019":"/unity/2020-11-18-netcode-sourcecode#ghostsendsystem","1020":"/unity/2020-11-18-netcode-sourcecode#ghost","1021":"/unity/2020-12-20-collection-has-not-been-disposed#启用堆栈跟踪","1022":"/unity/2020-12-20-collection-has-not-been-disposed#关于分配器","1023":"/unity/2020-12-20-collection-has-not-been-disposed#用-using-括起来确保内存安全","1024":"/unity/2021-01-24-screentoworld#使用射线","1025":"/unity/2021-01-24-screentoworld#直接转换","1026":"/unity/2021-01-25-tilemap#b站圈毛君翻译教程","1027":"/unity/2021-01-25-tilemap#the-basichttpswwwbilibilicomvideoav48965588","1028":"/unity/2021-01-25-tilemap#rule-tilehttpswwwbilibilicomvideoav49083381","1029":"/unity/2021-01-25-tilemap#prefab-brushhttpswwwbilibilicomvideoav49098444","1030":"/unity/2021-01-25-tilemap#tilemap-colliderhttpswwwbilibilicomvideoav49115670","1031":"/unity/2021-01-25-tilemap#tilebase","1032":"/unity/2021-04-11-render-texture#_1-ugui上显示模型","1033":"/unity/2021-04-11-render-texture#_2-camera相机拍照分享保存为jpg","1034":"/unity/2021-04-11-render-texture#_3-制作小地图","1035":"/unity/2021-06-14-unity-render-order#实际测试","1036":"/unity/2021-06-14-unity-render-order#render-queue","1037":"/unity/2021-06-14-unity-render-order#cameraopaquesortmode","1038":"/unity/2021-06-14-unity-render-order#cameratransparencysortmode","1039":"/unity/2021-06-14-unity-render-order#sortinglayer","1040":"/unity/2021-06-14-unity-render-order#sortingorder","1041":"/unity/2021-06-14-unity-render-order#cameradepth","1042":"/unity/2021-08-01-ai-planner#定义实体和组件","1043":"/unity/2021-08-01-ai-planner#定义处理系统","1044":"/unity/2021-08-01-ai-planner#actions","1045":"/unity/2021-08-01-ai-planner#domain","1046":"/unity/2022-01-02-unity-hot-reload#roslyn-c-runtime-compiler","1047":"/unity/2022-01-02-unity-hot-reload#通过filesystemwatcher监控目录检查改变的文件","1048":"/unity/2022-01-02-unity-hot-reload#编译修改的文件并重新加载","1049":"/unity/2022-01-02-unity-hot-reload#替换场景中的monobehavior","1050":"/unity/2022-01-02-unity-hot-reload#et的热重载","1051":"/unity/2022-01-28-unity-editor-iteration-profiler#一些记录","1052":"/unity/2022-01-28-unity-editor-iteration-profiler#参考链接","1053":"/unity/2022-09-10-ecs-beiwang#关于parent和linkedentitygroup","1054":"/unity/2022-09-10-ecs-beiwang#关于转换"},"fieldIds":{"title":0,"content":1,"titles":2},"fieldLength":{"0":[1,19,1],"1":[2,3,1],"2":[1,6,1],"3":[1,12,1],"4":[1,1,1],"5":[1,1,1],"6":[1,1,1],"7":[2,1,2],"8":[1,4,1],"9":[1,7,1],"10":[3,16,1],"11":[2,31,1],"12":[4,103,1],"13":[2,14,1],"14":[3,17,1],"15":[2,426,1],"16":[1,4,1],"17":[1,38,1],"18":[2,19,2],"19":[2,25,2],"20":[2,24,2],"21":[1,6,1],"22":[6,172,1],"23":[3,45,1],"24":[3,57,1],"25":[3,114,1],"26":[3,122,1],"27":[3,146,1],"28":[5,93,1],"29":[1,62,1],"30":[3,50,1],"31":[3,5,1],"32":[4,34,1],"33":[2,66,4],"34":[2,30,4],"35":[1,1,1],"36":[3,27,1],"37":[2,31,1],"38":[2,26,1],"39":[2,67,2],"40":[2,21,1],"41":[3,45,1],"42":[2,33,1],"43":[2,101,1],"44":[2,26,1],"45":[2,56,1],"46":[2,161,1],"47":[2,35,1],"48":[2,76,1],"49":[2,8,1],"50":[1,111,1],"51":[1,52,1],"52":[4,1,1],"53":[1,1,4],"54":[1,7,5],"55":[1,19,5],"56":[1,5,5],"57":[2,17,4],"58":[2,6,4],"59":[2,12,4],"60":[1,8,4],"61":[3,8,1],"62":[3,23,1],"63":[3,47,1],"64":[3,61,1],"65":[3,17,1],"66":[3,21,1],"67":[3,37,1],"68":[3,38,1],"69":[3,75,1],"70":[3,23,1],"71":[3,17,1],"72":[3,17,1],"73":[5,36,1],"74":[3,35,1],"75":[3,47,1],"76":[3,47,1],"77":[3,40,1],"78":[3,22,1],"79":[3,50,1],"80":[3,8,1],"81":[1,59,3],"82":[1,78,1],"83":[1,73,1],"84":[1,58,1],"85":[1,77,1],"86":[2,80,1],"87":[1,11,1],"88":[5,125,1],"89":[4,50,1],"90":[4,110,1],"91":[1,60,1],"92":[2,46,1],"93":[2,2,1],"94":[3,10,3],"95":[3,11,3],"96":[2,50,1],"97":[2,24,1],"98":[1,1,1],"99":[1,10,1],"100":[1,5,1],"101":[1,15,1],"102":[1,35,2],"103":[1,123,2],"104":[1,87,2],"105":[1,36,1],"106":[1,34,1],"107":[1,52,1],"108":[1,22,1],"109":[1,5,1],"110":[1,14,1],"111":[1,124,1],"112":[1,1,1],"113":[2,23,1],"114":[2,6,1],"115":[2,24,2],"116":[2,37,2],"117":[2,1,2],"118":[3,24,4],"119":[4,36,4],"120":[2,49,4],"121":[2,25,4],"122":[2,25,4],"123":[1,4,2],"124":[2,41,1],"125":[1,62,1],"126":[1,52,1],"127":[2,100,1],"128":[3,16,1],"129":[3,35,4],"130":[4,80,4],"131":[1,293,1],"132":[1,21,1],"133":[1,7,1],"134":[1,6,1],"135":[1,18,1],"136":[1,6,1],"137":[2,13,1],"138":[1,7,1],"139":[1,1,1],"140":[2,16,1],"141":[1,1,1],"142":[1,21,1],"143":[1,1,1],"144":[1,5,1],"145":[1,4,1],"146":[1,6,1],"147":[4,22,1],"148":[4,1,1],"149":[1,2,1],"150":[1,2,1],"151":[1,18,1],"152":[1,23,2],"153":[1,33,2],"154":[1,3,2],"155":[1,47,1],"156":[1,5,1],"157":[1,7,2],"158":[1,20,1],"159":[1,3,1],"160":[1,2,1],"161":[1,13,1],"162":[1,10,1],"163":[3,10,1],"164":[3,22,1],"165":[2,11,1],"166":[2,18,1],"167":[4,35,1],"168":[3,4,1],"169":[2,14,3],"170":[1,17,3],"171":[1,14,1],"172":[1,24,1],"173":[1,62,1],"174":[1,49,1],"175":[1,28,1],"176":[1,43,1],"177":[3,5,1],"178":[3,1,1],"179":[3,1,1],"180":[3,8,1],"181":[1,51,1],"182":[5,1,1],"183":[2,9,5],"184":[2,18,5],"185":[2,24,5],"186":[4,95,1],"187":[3,75,1],"188":[1,128,1],"189":[1,159,1],"190":[2,75,1],"191":[1,121,3],"192":[2,74,3],"193":[1,155,1],"194":[1,29,2],"195":[1,160,1],"196":[1,90,1],"197":[2,145,1],"198":[2,16,1],"199":[2,48,2],"200":[2,8,2],"201":[2,26,2],"202":[2,24,2],"203":[2,5,2],"204":[2,56,1],"205":[1,1,1],"206":[3,40,1],"207":[1,67,1],"208":[1,31,1],"209":[1,34,1],"210":[1,77,1],"211":[1,15,1],"212":[1,22,1],"213":[1,31,1],"214":[1,103,1],"215":[1,27,1],"216":[1,1,1],"217":[1,30,1],"218":[1,22,1],"219":[1,28,1],"220":[1,101,1],"221":[1,42,1],"222":[1,5,1],"223":[1,16,1],"224":[4,118,1],"225":[8,157,1],"226":[1,3,1],"227":[2,7,1],"228":[1,30,1],"229":[2,3,2],"230":[1,4,1],"231":[1,4,1],"232":[1,1,1],"233":[3,10,1],"234":[1,5,1],"235":[1,4,2],"236":[1,5,2],"237":[1,4,2],"238":[1,1,2],"239":[1,4,3],"240":[2,6,3],"241":[1,13,1],"242":[1,13,1],"243":[1,4,1],"244":[1,17,1],"245":[1,6,1],"246":[1,17,2],"247":[1,22,2],"248":[3,6,2],"249":[1,1,1],"250":[1,7,1],"251":[5,14,1],"252":[2,12,1],"253":[1,5,2],"254":[1,44,2],"255":[1,7,2],"256":[1,1,1],"257":[1,7,1],"258":[1,5,1],"259":[1,5,1],"260":[1,8,1],"261":[1,4,1],"262":[1,3,1],"263":[2,1,1],"264":[2,16,1],"265":[1,15,1],"266":[1,59,1],"267":[1,19,1],"268":[1,1,1],"269":[1,28,2],"270":[1,188,2],"271":[1,16,2],"272":[1,9,2],"273":[1,35,2],"274":[1,12,2],"275":[1,90,3],"276":[1,4,1],"277":[1,22,1],"278":[1,10,1],"279":[1,1,1],"280":[1,10,2],"281":[1,4,2],"282":[1,16,2],"283":[1,73,2],"284":[1,6,2],"285":[1,7,1],"286":[1,5,1],"287":[1,183,1],"288":[2,2,1],"289":[1,1,1],"290":[1,42,1],"291":[1,4,1],"292":[1,6,1],"293":[1,8,1],"294":[1,1,1],"295":[1,116,1],"296":[1,154,1],"297":[1,137,1],"298":[1,1,1],"299":[1,11,1],"300":[1,26,1],"301":[1,23,1],"302":[1,32,1],"303":[1,15,1],"304":[1,20,1],"305":[1,4,1],"306":[1,4,1],"307":[1,13,1],"308":[1,4,1],"309":[1,4,1],"310":[1,1,1],"311":[1,1,1],"312":[1,1,2],"313":[1,1,2],"314":[1,1,2],"315":[1,1,2],"316":[1,1,2],"317":[1,1,2],"318":[1,1,1],"319":[1,1,2],"320":[1,1,2],"321":[1,1,1],"322":[1,1,2],"323":[1,1,2],"324":[1,1,2],"325":[1,1,2],"326":[1,1,2],"327":[1,1,1],"328":[1,1,2],"329":[1,1,2],"330":[1,1,2],"331":[1,1,3],"332":[1,1,1],"333":[1,1,2],"334":[1,1,3],"335":[1,1,2],"336":[1,1,2],"337":[1,1,2],"338":[1,1,2],"339":[1,1,2],"340":[1,1,2],"341":[1,1,2],"342":[1,1,2],"343":[3,1,2],"344":[1,1,1],"345":[1,1,2],"346":[1,1,2],"347":[1,1,2],"348":[1,1,2],"349":[1,1,2],"350":[1,1,1],"351":[1,1,2],"352":[2,1,3],"353":[1,1,3],"354":[1,1,2],"355":[1,1,3],"356":[1,1,3],"357":[1,1,2],"358":[1,1,3],"359":[2,1,2],"360":[1,1,2],"361":[1,1,1],"362":[1,1,1],"363":[1,1,2],"364":[1,1,2],"365":[1,1,2],"366":[1,1,2],"367":[1,1,2],"368":[1,44,1],"369":[1,25,1],"370":[1,1,1],"371":[1,13,1],"372":[1,55,1],"373":[1,44,1],"374":[1,35,1],"375":[1,18,1],"376":[1,41,1],"377":[1,45,1],"378":[1,87,1],"379":[1,1,2],"380":[1,137,3],"381":[1,29,3],"382":[1,33,3],"383":[1,24,3],"384":[1,65,1],"385":[1,67,1],"386":[1,1,1],"387":[1,10,1],"388":[1,8,1],"389":[1,21,1],"390":[1,25,1],"391":[1,36,1],"392":[1,22,1],"393":[1,27,1],"394":[1,21,1],"395":[1,15,1],"396":[1,1,1],"397":[1,11,1],"398":[1,36,1],"399":[1,16,1],"400":[1,6,1],"401":[1,19,1],"402":[1,6,1],"403":[1,2,1],"404":[1,17,1],"405":[4,22,1],"406":[2,26,1],"407":[1,12,1],"408":[7,1,1],"409":[3,2,7],"410":[3,10,7],"411":[1,50,1],"412":[3,30,1],"413":[1,6,3],"414":[3,4,3],"415":[6,12,5],"416":[5,9,5],"417":[1,7,5],"418":[1,1,1],"419":[1,3,1],"420":[1,16,1],"421":[1,14,1],"422":[1,8,1],"423":[1,10,1],"424":[1,53,1],"425":[3,13,1],"426":[1,1,1],"427":[1,17,1],"428":[1,6,1],"429":[1,5,1],"430":[1,4,1],"431":[1,1,1],"432":[1,1,1],"433":[1,1,1],"434":[1,5,1],"435":[1,3,1],"436":[1,6,1],"437":[1,24,1],"438":[3,15,1],"439":[1,4,1],"440":[1,1,1],"441":[1,20,1],"442":[1,17,1],"443":[2,45,1],"444":[1,36,1],"445":[1,32,1],"446":[1,25,1],"447":[2,10,1],"448":[1,20,3],"449":[1,63,3],"450":[1,16,3],"451":[2,70,1],"452":[2,64,1],"453":[2,38,1],"454":[2,41,1],"455":[2,94,1],"456":[2,39,1],"457":[1,20,1],"458":[1,1,1],"459":[1,19,1],"460":[1,11,1],"461":[1,1,1],"462":[3,1,1],"463":[1,8,3],"464":[5,5,3],"465":[2,14,1],"466":[2,3,1],"467":[1,57,1],"468":[1,1,1],"469":[1,1,1],"470":[7,1,1],"471":[1,32,1],"472":[1,10,1],"473":[1,10,1],"474":[1,4,1],"475":[1,23,1],"476":[1,11,1],"477":[1,16,1],"478":[1,8,1],"479":[1,2,1],"480":[1,2,1],"481":[3,17,2],"482":[1,1,2],"483":[1,9,2],"484":[3,22,1],"485":[4,31,1],"486":[4,53,1],"487":[3,41,1],"488":[1,42,1],"489":[7,64,1],"490":[2,11,1],"491":[5,9,1],"492":[2,1,1],"493":[1,3,2],"494":[1,3,2],"495":[2,1,2],"496":[1,1,1],"497":[1,10,1],"498":[1,12,1],"499":[1,22,1],"500":[1,20,1],"501":[1,1,1],"502":[1,12,2],"503":[1,17,2],"504":[1,11,2],"505":[2,19,2],"506":[2,18,2],"507":[3,21,1],"508":[1,9,1],"509":[1,43,1],"510":[1,113,1],"511":[1,1,1],"512":[1,9,1],"513":[1,1,1],"514":[1,1,1],"515":[1,14,1],"516":[1,1,1],"517":[2,3,1],"518":[1,1,1],"519":[1,1,1],"520":[1,1,1],"521":[1,1,1],"522":[2,1,1],"523":[1,16,2],"524":[2,38,1],"525":[1,9,1],"526":[1,23,1],"527":[1,19,1],"528":[3,7,1],"529":[2,34,1],"530":[2,1,1],"531":[1,5,1],"532":[1,16,1],"533":[1,31,1],"534":[1,27,1],"535":[1,78,1],"536":[3,53,1],"537":[5,52,1],"538":[1,13,1],"539":[1,1,1],"540":[1,1,1],"541":[1,6,1],"542":[1,15,1],"543":[1,11,1],"544":[1,15,1],"545":[1,6,1],"546":[1,1,1],"547":[1,1,1],"548":[4,1,1],"549":[1,1,1],"550":[1,6,1],"551":[4,20,1],"552":[5,1,1],"553":[1,18,5],"554":[1,7,5],"555":[2,1,5],"556":[2,12,5],"557":[2,1,6],"558":[2,1,6],"559":[2,9,5],"560":[1,15,5],"561":[1,1,5],"562":[3,5,6],"563":[2,4,6],"564":[1,26,1],"565":[1,1,1],"566":[5,18,1],"567":[3,39,1],"568":[2,19,1],"569":[4,22,1],"570":[1,18,1],"571":[1,94,1],"572":[1,21,1],"573":[1,61,1],"574":[1,42,1],"575":[1,57,1],"576":[2,60,1],"577":[3,56,1],"578":[1,46,1],"579":[1,9,1],"580":[3,33,1],"581":[1,70,1],"582":[1,7,1],"583":[1,16,1],"584":[1,7,1],"585":[1,76,1],"586":[1,26,1],"587":[1,15,1],"588":[2,12,1],"589":[1,11,1],"590":[1,22,1],"591":[1,50,1],"592":[2,103,1],"593":[1,14,1],"594":[3,47,1],"595":[1,7,1],"596":[2,1,1],"597":[3,6,2],"598":[1,22,2],"599":[1,20,2],"600":[1,11,3],"601":[2,28,2],"602":[1,3,2],"603":[1,14,1],"604":[1,51,1],"605":[1,3,1],"606":[1,36,1],"607":[2,41,1],"608":[2,4,1],"609":[2,4,1],"610":[2,27,1],"611":[5,11,1],"612":[3,9,1],"613":[2,5,1],"614":[3,1,2],"615":[2,22,5],"616":[2,12,5],"617":[1,6,2],"618":[3,23,1],"619":[1,1,1],"620":[1,15,1],"621":[1,1,1],"622":[1,11,2],"623":[2,4,2],"624":[1,7,1],"625":[1,68,1],"626":[2,16,1],"627":[5,8,3],"628":[5,51,3],"629":[5,2,3],"630":[1,1,1],"631":[1,9,1],"632":[2,5,1],"633":[5,51,1],"634":[6,20,5],"635":[7,25,5],"636":[7,25,5],"637":[6,14,5],"638":[1,1,1],"639":[1,33,1],"640":[1,32,1],"641":[3,14,1],"642":[1,17,1],"643":[3,5,1],"644":[1,58,1],"645":[1,32,1],"646":[1,1,1],"647":[8,1,1],"648":[1,1,1],"649":[5,6,2],"650":[5,12,2],"651":[1,7,2],"652":[1,43,1],"653":[1,24,1],"654":[1,31,1],"655":[1,27,1],"656":[3,28,1],"657":[1,131,3],"658":[1,15,3],"659":[4,1,1],"660":[3,16,4],"661":[2,32,4],"662":[2,30,1],"663":[1,27,2],"664":[1,11,2],"665":[1,9,2],"666":[1,11,1],"667":[1,14,1],"668":[1,18,1],"669":[1,4,1],"670":[2,1,1],"671":[1,11,1],"672":[1,6,1],"673":[1,4,1],"674":[1,5,1],"675":[1,18,1],"676":[2,14,1],"677":[1,1,1],"678":[3,19,1],"679":[1,11,1],"680":[1,12,1],"681":[1,10,1],"682":[1,7,1],"683":[2,30,1],"684":[2,76,1],"685":[2,34,1],"686":[2,9,1],"687":[1,53,2],"688":[2,42,2],"689":[5,55,4],"690":[5,15,4],"691":[2,62,4],"692":[3,6,4],"693":[3,36,4],"694":[2,28,4],"695":[1,172,4],"696":[1,13,1],"697":[1,25,1],"698":[1,13,1],"699":[1,62,1],"700":[1,19,1],"701":[1,75,1],"702":[1,3,1],"703":[2,29,1],"704":[4,11,1],"705":[5,29,1],"706":[1,7,1],"707":[1,147,1],"708":[1,33,1],"709":[1,26,1],"710":[1,5,1],"711":[2,22,1],"712":[1,9,1],"713":[1,17,1],"714":[1,60,1],"715":[1,43,1],"716":[1,20,1],"717":[1,48,1],"718":[1,33,1],"719":[1,31,1],"720":[2,106,1],"721":[9,51,2],"722":[6,68,11],"723":[1,18,2],"724":[2,37,1],"725":[1,23,1],"726":[3,86,1],"727":[2,11,1],"728":[2,14,1],"729":[2,17,1],"730":[1,1,3],"731":[2,9,3],"732":[2,8,3],"733":[2,6,3],"734":[3,15,3],"735":[1,1,3],"736":[1,12,3],"737":[1,205,1],"738":[1,27,1],"739":[1,46,1],"740":[1,15,1],"741":[1,8,1],"742":[1,31,1],"743":[1,1,1],"744":[1,15,1],"745":[3,7,1],"746":[1,19,1],"747":[1,13,1],"748":[2,36,1],"749":[2,27,1],"750":[2,51,1],"751":[2,38,1],"752":[1,1,1],"753":[6,26,1],"754":[4,15,1],"755":[3,39,1],"756":[3,94,1],"757":[1,1,1],"758":[1,18,2],"759":[1,62,2],"760":[4,23,1],"761":[5,20,1],"762":[1,21,6],"763":[1,21,6],"764":[1,30,6],"765":[4,16,6],"766":[1,10,6],"767":[4,19,6],"768":[4,6,6],"769":[1,4,6],"770":[1,31,6],"771":[1,19,1],"772":[1,1,1],"773":[3,2,1],"774":[3,1,1],"775":[1,1,1],"776":[1,12,1],"777":[1,6,1],"778":[1,1,1],"779":[1,2,1],"780":[1,24,1],"781":[1,22,1],"782":[3,32,1],"783":[1,24,1],"784":[1,33,1],"785":[2,19,1],"786":[1,4,1],"787":[1,12,1],"788":[1,13,1],"789":[1,31,1],"790":[1,1,1],"791":[1,8,1],"792":[2,10,1],"793":[2,38,1],"794":[2,24,1],"795":[3,92,2],"796":[3,22,2],"797":[2,18,2],"798":[1,19,2],"799":[3,33,2],"800":[3,50,2],"801":[3,42,5],"802":[2,18,2],"803":[2,39,2],"804":[2,17,4],"805":[2,49,2],"806":[2,5,2],"807":[2,47,3],"808":[1,10,3],"809":[3,24,2],"810":[3,25,1],"811":[2,70,3],"812":[1,6,1],"813":[2,62,1],"814":[1,27,1],"815":[1,65,1],"816":[1,3,1],"817":[1,35,1],"818":[1,51,1],"819":[1,32,1],"820":[1,32,1],"821":[1,12,2],"822":[1,58,2],"823":[1,143,2],"824":[6,55,2],"825":[1,20,2],"826":[1,30,1],"827":[1,28,1],"828":[1,56,1],"829":[1,6,1],"830":[1,20,1],"831":[1,23,1],"832":[1,12,1],"833":[1,19,1],"834":[2,6,1],"835":[2,13,1],"836":[1,21,2],"837":[1,4,2],"838":[1,4,1],"839":[1,36,1],"840":[2,53,1],"841":[2,204,1],"842":[2,12,1],"843":[6,1,1],"844":[1,21,1],"845":[1,22,1],"846":[1,88,1],"847":[1,67,1],"848":[1,42,1],"849":[1,34,1],"850":[1,34,1],"851":[2,27,1],"852":[1,7,2],"853":[1,1,2],"854":[1,113,1],"855":[1,29,1],"856":[1,3,1],"857":[1,39,1],"858":[1,81,2],"859":[1,21,2],"860":[1,65,2],"861":[1,51,3],"862":[1,119,3],"863":[1,17,3],"864":[1,66,2],"865":[1,1,1],"866":[1,16,2],"867":[1,25,2],"868":[1,46,2],"869":[1,19,2],"870":[1,1,2],"871":[1,1,2],"872":[1,21,2],"873":[1,4,2],"874":[1,1,1],"875":[1,1,1],"876":[1,108,1],"877":[1,27,1],"878":[2,55,1],"879":[3,37,1],"880":[1,7,1],"881":[2,17,1],"882":[2,8,1],"883":[2,14,1],"884":[1,6,1],"885":[1,53,1],"886":[2,9,1],"887":[1,28,1],"888":[1,6,1],"889":[1,16,2],"890":[2,32,1],"891":[1,46,1],"892":[1,21,1],"893":[1,16,1],"894":[1,3,1],"895":[1,15,2],"896":[1,62,2],"897":[1,16,2],"898":[1,168,2],"899":[1,25,1],"900":[2,2,1],"901":[1,13,1],"902":[1,1,1],"903":[1,32,1],"904":[1,13,1],"905":[2,54,1],"906":[2,24,1],"907":[1,14,3],"908":[3,22,3],"909":[1,7,3],"910":[3,32,4],"911":[1,14,4],"912":[2,15,4],"913":[2,1,1],"914":[1,10,3],"915":[1,17,3],"916":[2,22,3],"917":[1,20,3],"918":[2,1,1],"919":[1,11,1],"920":[1,31,1],"921":[1,17,1],"922":[1,5,1],"923":[1,14,1],"924":[1,27,1],"925":[1,3,1],"926":[1,14,1],"927":[5,49,1],"928":[4,23,1],"929":[1,58,4],"930":[1,52,4],"931":[5,37,4],"932":[3,17,7],"933":[3,14,7],"934":[1,16,9],"935":[1,17,9],"936":[1,28,9],"937":[4,46,4],"938":[1,20,7],"939":[1,21,4],"940":[1,94,1],"941":[3,74,1],"942":[2,79,1],"943":[1,66,1],"944":[2,89,1],"945":[1,47,1],"946":[2,58,1],"947":[5,94,1],"948":[1,30,1],"949":[2,58,1],"950":[1,39,1],"951":[3,84,1],"952":[2,143,1],"953":[4,36,1],"954":[4,82,1],"955":[5,123,1],"956":[4,45,1],"957":[1,73,1],"958":[1,52,1],"959":[4,40,1],"960":[2,97,1],"961":[2,47,1],"962":[2,29,1],"963":[4,33,1],"964":[2,206,1],"965":[4,253,1],"966":[4,128,1],"967":[2,49,1],"968":[5,87,1],"969":[3,166,1],"970":[1,87,1],"971":[1,262,1],"972":[1,10,1],"973":[1,6,1],"974":[6,53,1],"975":[4,135,1],"976":[1,79,4],"977":[4,73,4],"978":[1,61,4],"979":[3,82,1],"980":[3,117,1],"981":[2,70,1],"982":[4,71,1],"983":[10,6,1],"984":[1,57,1],"985":[2,1,1],"986":[1,7,1],"987":[1,18,1],"988":[2,3,1],"989":[1,3,2],"990":[2,1,3],"991":[1,39,3],"992":[1,24,3],"993":[1,3,3],"994":[2,6,3],"995":[4,2,3],"996":[1,1,3],"997":[2,20,2],"998":[1,43,2],"999":[1,15,1],"1000":[1,34,1],"1001":[1,52,1],"1002":[4,41,1],"1003":[2,28,1],"1004":[2,7,1],"1005":[1,24,1],"1006":[1,7,1],"1007":[1,9,1],"1008":[1,12,1],"1009":[1,1,1],"1010":[1,9,1],"1011":[2,11,1],"1012":[2,9,1],"1013":[1,76,1],"1014":[1,19,1],"1015":[1,9,1],"1016":[1,19,1],"1017":[1,4,1],"1018":[1,1,1],"1019":[1,10,1],"1020":[1,15,1],"1021":[2,16,1],"1022":[1,35,2],"1023":[4,29,3],"1024":[1,6,1],"1025":[1,45,1],"1026":[2,1,1],"1027":[9,1,1],"1028":[9,1,1],"1029":[9,1,1],"1030":[9,1,1],"1031":[1,4,1],"1032":[2,18,1],"1033":[3,13,1],"1034":[2,25,1],"1035":[1,11,1],"1036":[2,59,1],"1037":[2,35,1],"1038":[2,9,1],"1039":[1,45,1],"1040":[1,23,1],"1041":[2,21,1],"1042":[1,5,1],"1043":[1,17,1],"1044":[1,7,1],"1045":[1,4,1],"1046":[4,1,1],"1047":[1,3,4],"1048":[1,1,4],"1049":[1,1,4],"1050":[1,8,4],"1051":[1,13,1],"1052":[1,15,1],"1053":[1,20,1],"1054":[1,62,1]},"averageFieldLength":[1.7279620853080564,28.060663507109002,1.5895734597156403],"storedFields":{"0":{"title":"原理","content":"蒙版，其实就是ps运用黑、白和不同程度的灰色来控制画面显示的程度，就好像拿一块板子蒙着你的眼睛一样，黑色是完全不透光的木板，白色是一块玻璃板，灰色是一块半透明的玻璃板，黑色你完全看不到后面的情况，白色你会完全看到后面，而半透明玻璃你能看到后面，但是是不清晰的.蒙版根据黑白灰,将图片处理成透明,半透明,和不透明.所以除了渐变工具.还可以用画笔工具.只要涂抹为黑白就可以.","titles":[]},"1":{"title":"应用图层蒙版是不能执行的?","content":"因为你的图层是智能图层，你先要栅格化之后，才能执行你需要的操作~","titles":["原理"]},"2":{"title":"去色","content":"使用色彩范围或者其他东西.先去除大部分的黑色  然后周边肯定有一部分的灰色去除不掉的..然后再将这些颜色使用替换颜色..改成白色  最后再用工具将图片平滑一下","titles":[]},"3":{"title":"Daemon","content":"Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等...","titles":[]},"4":{"title":"配置文件","content":"修改配置","titles":["Daemon"]},"5":{"title":"命令","content":"","titles":["Daemon"]},"6":{"title":"jenkins","content":"","titles":["Daemon"]},"7":{"title":"efcore update","content":"不能使用sudo的解决办法","titles":["Daemon","jenkins"]},"8":{"title":"mysql","content":"从windows迁移到linux时..mysql数据库的表明可能会有大小写敏感的问题\n修改mysql配置my.ini","titles":["Daemon"]},"9":{"title":"windows下绝对路径启动问题","content":"注册成services后.他的启动目录是C:\\Windows\\System32..所以需要手动设置下contentRoot如果启动失败..先查看错误日志..最好是用文件存储","titles":[]},"10":{"title":"A full example","content":"The output of the sample is something likec# 的实现https://github.com/wangjia184/HashedWheelTimer   https://github.com/fanrice123/HashedWheelTimer.NET","titles":[]},"11":{"title":"Lock-Step","content":"我们把游戏的前进分为一帧帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。  每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。  Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都等于延迟最高的那个人。  由于大家的turn一致，以及输入固定，所以每一步所有客户端的计算结果都一致的。我们来看看具体的执行流程:上图中我们可以明显看到，这种囚徒模式的帧同步，在第二帧的时候，因为玩家1有延迟，而导致第二帧的同步时间发生延迟，从而导致所有玩家都在等待，出现卡顿现象","titles":[]},"12":{"title":"Bucket Synchronization(乐观锁)","content":"囚徒模式的帧同步，有一个致命的缺陷就是，若联网的玩家有一个网速慢了，势必会影响其他玩家的体验，因为服务器要等待所有输入达到之后再同步到所有的c端。另外如果中途有人掉线了，游戏就会无法继续或者掉线玩家无法重连，因为在严格的帧同步的情况下，中途加入游戏是从技术上来讲是非常困难的。因为你重新进来之后，你的初始状态和大家不一致，而且你的状态信息都是丢失状态的，比如，你的等级，随机种子，角色的属性信息等。 比如玩过早期的冰封王座都知道，一旦掉线基本这局就废了，需要重开，至于为何没有卡顿的现象，因为那时都是解决方案都是采用局域网的方式，所以基本是没有延迟问题的。后期为了解决这个问题，如今包括王者荣耀，服务器会保存玩家当场游戏的游戏指令以及状态信息，在玩家断线重连的时候，能够恢复到断线前的状态。不过这个还是无法解决帧同步的问题，因为严格的帧同步，是要等到所有玩家都输入之后，再去通知广播client更新，如果A服务器一直没有输入同步过来，大家是要等着的，那么如何解决这个问题？采用“定时不等待”的乐观方式在每次Interval时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新。如此帧率的时钟在由服务器控制，当客户端有操作的时候及时的发送服务器，然后服务端每秒钟20-50次向所有客户端发送更新消息。如下图:上图中，我们看到服务器不会再等到搜集完所有用户输入再进行下一帧，而是按照固定频率来同步玩家的输入信息到每一个c端，如果有玩家网络延迟，服务器的帧步进是不会等待的，比如上图中，在第二帧的时候，玩家A的网速慢，那么他这个时候，会被网速快的玩家给秒了（其他游戏也差不多）。但是网速慢的玩家不会卡到快的玩家，只会感觉自己操作延迟而已。Bucket Synchronization 是 Lock-Step 的改良算法. 算法流程可以参考下图:Bucket Synchronization 算法应用于网状网络, 网络中有一个 master 节点(也是 client).master 在启动之初, 会对所有 client 做网络对时, 计算网络包的超时时间.master 会设置一个 bucket 时间, 在每个 bucket 时间节点, master 执行收集到的所有 step 指令, 并将更新推送到所有的 client 上. (上图的例子是一个简化流程, 只有俩 client, 没有 master 推送)master 对收集到的 step 包做超时校验机制, 如果收到的 step 指令包的时间戳, 延迟超过了预设的阈值, 就当作超时包丢弃.与 Lock-Step 相比, Bucket Synchronization 改进的是: 设置了 bucket 的概念, 执行每一帧的时间是固定的 bucket 时间节点, 而不必等到收到所有的 client step 指令, 从而网络不再受最差的 client 限制.","titles":[]},"13":{"title":"TimeWrap Synchronization","content":"它是一个基于某些状态支持回滚(rollback)的同步算法。有点类似HL的做法。\n简言之，就是对每个操作指令的执行后保存一个状态快照(snapshot)，\n各个peer按照自己的预测先行显示，但在发生一致性冲突的情况下，\n回滚到上一个状态，并重新将指令序列在基于回滚后的快照的基础上再\n执行一次，以获得正确的当前状态。","titles":[]},"14":{"title":"Trailing State Synchronization","content":"对TimeWrap Synchronization的一种改进。TimeWrap方案中建立snapshot是\n以指令数量(1或少量几个指令)间隔为单位；而TSS方案则以某种延迟值(100ms)\n间隔为单位对游戏做snapshot(比如100ms前做一个，200ms前做一个...)。\n当发生一致性冲突时，寻找最远需要开始计算的snapshot，并将该snapshot到\n现在为止的时间内的指令重新执行，得到正确的最新状态。","titles":[]},"15":{"title":"State Hash","content":"在实现中客户端需要计算一些关键信息的hash值，提供给服务器以便发现游戏中的同步问题，例如玩家的位置信息，各个客户端计算结果是否一致等等。客户端执行完每个逻辑帧后，会根据游戏的状态计算出一个Hash值，用其标定一个具体的游戏状态。不同客户端通过对比这个值，即可判断客户端之间是否保持同步，平常也可用于不同步Debug。游戏外挂的种类有很多，这里所谈的外挂仅指会更改游戏逻辑执行或数值的外挂，应该也是题主最关心的类型。对于帧同步防外挂，因为游戏逻辑执行在本地，假如某个客户端使用了外挂的话，那么必然会导致其计算出的State Hash与其他客户端不一致。1、 客户端自验证（PVP 3人及以上）PVP3人及以上的战斗中，客户端上报服务器各自计算的State Hash，服务器可以通过对比State Hash判断具体哪一个客户端发生了不同步。当然，不同步也可能是客户端BUG，不同步也不一定就结算不一致。根绝不同的需求，你也可以在发现不同步后马上中断游戏。这个方法的缺点主要在于3人以下或者单机模式的话就没法使用了。2、客户端分布式验证假如客户端的核心逻辑写得足够干净和独立的话，服务器可以将某一场战斗的数据下发给一个空闲客户端，令其新起一个线程慢慢地计算验证，再将结果上报至服务器。能做到这一点的话，任何战斗模式都可以进行验证了。3、服务器验证与客户端分布式验证相同，客户端逻辑如果足够干净和独立，那么服务器也可以自己验算战斗结果。4、服务器统计与运营策略非单机模式下，服务器都根据客户端的State Hash对战斗的同步情况进行记录。将经常发生不同步的客户端标记出来，然后进一步处理。运营可以为玩家每日不同步可结算的次数设定一个阈值，超过则当日之后的战斗结算均无效。1和4是任何帧同步游戏都可以做的，2与3对游戏的框架要求比较高。我们的游戏因为是从单机版改造过来的，所以也只做了1和4。游戏逻辑的回滚回滚逻辑，就是我们解决问题的方案。可以这样理解，客户端的时间，领先服务器，客户端不需要服务器确认帧返回才执行指令，而是玩家输入，立刻执行（其他玩家的输入，按照其最近一个输入做预测，或者其他更优化的预测方案），然后将指令发送给服务器，服务器收到后给客户端确认，客户端收到确认后，如果服务确认的操作，和之前执行的一样（自己和其他玩家预测的操作），将不做任何改变，如果不一样（预测错误），就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧，然后再追上当前客户端的帧。此处逻辑较为复杂，我尝试举个例子说明下。当前客户端（A，B）执行到100帧，服务器执行到97帧。在100帧的时候，A执行了移动，B执行了攻击，A和B都通知服务器：我已经执行到100帧，我的操作是移动（A），攻击（B）。服务器在自己的98帧或99帧收到了A，B的消息，存在对应帧的操作数据中，等服务器执行到100帧的时候（或提前），将这个数据广播给AB。然后A和B立刻开始执行100帧，A执行移动，预测B不执行操作。而B执行攻击，预测A执行攻击（可能A的99帧也是攻击），A和B各自预测对方的操作。在A和B执行完100帧后，他们会各自保存100帧的状态快照，以及100帧各自的操作（包括预测的操作），以备万一预测错误，做逻辑回滚。执行几帧后，A，B来到了103帧，服务器到了100帧，他开始广播数据给AB，在一定延迟后，AB收到了服务器确认的100帧的数据，这时候，AB可能已经执行到104了。A和B各自去核对服务器的数据和自己预测的数据是否相同。例如A核对后，100帧的操作，和自己预测的一样，A不做任何处理，继续往前。而B核对后，发现在100帧，B对A的预测，和服务器确认的A的操作，是不一样的（B预测的是攻击，而实际A的操作是移动），B就回滚到上一个确认一样的帧，即99帧，然后根据确认的100帧操作去执行100帧，然后快速执行101  103的帧逻辑，之后继续执行104帧，其中（101 104）还是预测的逻辑帧。因为客户端对当前操作的立刻执行，这个操作手感，是完全和pve（不联网状态）是一样的，不存在任何delay。所以，能做到绝佳的操作手感。当预测不一样的时候，做逻辑回滚，快速追回当前操作。这样，对于网络好的玩家，和网络不好的玩家，都不会互相影响，不会像lockstep一样，网络好的玩家，会被网络不好的玩家lock住。也不会被网络延迟lock住，客户端可以一直往前预测。对于网络好的玩家（A），可以动态调整（根据动态的latency），让客户端领先服务器少一些，尽量减少预测量，就会尽量减少回滚，例如网络好的，可能客户端只领先2~3帧。对于网络不好的玩家（B），动态调整，领先服务器多一些，根据latency调整，例如领先5帧。那么，A可能预测错的情况，只有2~3帧，而网络不好的B，可能预测错误的帧有5帧。通过优化的预测技术，和消息通知的优化，可以进一步减少A和B的预测错误率。对于A而言，战斗是顺畅的，手感很好，少数情况的回滚，优化好了，并不会带来卡顿和延迟感。重点优化的是B，即网络不好的玩家，他的操作体验。因为客户端不等待服务器确认，就执行操作，所以B的操作手感，和A是一致的，区别只在于，B因为延迟，预测了比较多的帧，可能导致预测错，回滚会多一些。比如按照B的预测，应该在100帧击中A，但是因为预测错误A的操作，回滚重新执行后，B可能在100帧不会击中A。这对于B来说，通过插值和一些平滑方式，B的感受是不会有太大区别的，因为B看自己，操作自己都是及时反馈的，他感觉自己是平滑的。这种方式，保证了网络不好的B的操作手感，和A一致。回滚导致的一些轻微的抖动，都是B看A的抖动，通过优化（插值，平滑等），进一步减少这些后，B的感受是很好的。我们测试在200~300毫秒随机延迟的情况下，B的操作手感良好。这里，客户端提前服务器的方式，并且在延迟增大的情况下，客户端将加速，和  守望先锋的处理方式 是一样的。当然，他们肯定比我做得好很多。希望我已经大致讲清楚了这个逻辑，大家参看几篇链接的文章，能体会更深。这里，我要强调的一点是，我们这里的预测执行，是真实逻辑的预测，和很多介绍帧同步文章提到的预测是不同的。有些文章介绍的预测执行，只是view层面的预测，例如前摇动作和位移，但是逻辑是不会提前执行的，还是要等服务器的返回。这两种预测执行（View的预测执行，和真实逻辑的预测执行）是完全不是一个概念的，这里需要仔细地区分。这里有很多的可以优化的点，我就不一一介绍了，以后可能零散地再谈。游戏逻辑的快照（snapshot）我们的逻辑之所以能回滚，都是基于对每一帧状态可以处理快照，存储下每一帧的状态，并可以回滚到任何一帧的状态。在  Understanding Fighting Game Networking  文章和  守望先锋网络  文章中，都一笔带过了快照的说明。他们说的快照，可能略有不同，但是思路，都是能保存下每一帧的状态。如果去处理快照（Understanding那篇文章做的是模拟器游戏，可以方便地以内存快照的方式来做），是一个难点，这也是我  前面文章 提到ECS在这个方式下的应用，云风的解释：云风博客截图，地址  https://blog.codingnow.com/2017/06/overwatch_ecs.htmlECS是一个好的处理方式，并且我找到  一篇文章 ，也这样做了（我看过他开源的demo，做得还不够好，应该还是demo阶段，不太像是一个成型的项目）。这篇文章的思路是很清晰的，并且也点到了一些实实在在的痛点，解决思路也基本是正确的，可以参看。这块，我做得比较早了，当时守望先锋的文章还没出，我的战斗也没有基于ECS，所以，在处理快照上，只有自己理顺逻辑来做了。我的思路是，通过一个回滚接口，需要数据回滚的部分，实现接口，各自处理自己的保存快照和回滚。就像我们序列化一个复杂的配置，每个配置各自序列化自己的部分，最终合并成一个序列化好的文件。首先，定义接口，和快照数据的reader和writer然后，就是每个模块，自己去处理自己的takeSnapshot和rollback，例如：简单的数值回滚复制的列表回滚和调用子模块回滚思路理顺以后，就可以很方便地处理了，注意write和read的顺序，注意处理好list，就解决了大部分问题。当然，在实现逻辑的过程中，时刻要注意，一个模块如何回滚（例如获取随机数也需要回滚）。有一个更简单的方式，就是给属性打Attribute，然后写通用的方法。例如，我早  期的实现方案 ：给属性打标签根据标签，通用的读写方法，通过反射来读写，就不需要每个模块自己去实现自己的方法了：部分代码这种方法，能很好地解决大部分问题，甚至前面提到的  Truesync ，也是用的这种方式来做。但是这种方法有个难以回避的问题，就是GC，因为基于反射，当我们调用field的GetValue和SetValue的时候，GC难以避免。并且，因为全自动，不方便处理一些特殊逻辑，调试优化也不方便，最后改成了现有的方式，虽然看起来笨重一些，但是可控性更强，我后续做的很多优化，都方便很多。关于快照，也有很多可以优化的点，无论是GC内存上的，还是运行效率上的，都需要优化好，否则，可能带来性能问题。这块优化，有空另辟文章再细谈吧。当我们有了快照，就可以支持回滚，甚至跳转。例如我们要看战斗录像，如果没有快照，我们要跳到1000帧，就需要从第一帧，根据保存的操作指令，一直快速执行到1000帧，而有了快照，可以直接跳到1000帧，不需要执行中间的过程，如果需要在不同的帧之间切换，只需要跳转即可，这将带来巨大的帮助。参考文章：Minimization of Latency in Cheat-Proof Real-Time Gaming by Trusting Time-Stamp Servers  End-to-end transmission control mechanisms for multiparty interactive applicatins on the Internet  Dead Reckoning: Latency Hiding for Networked Games  An Efficient Synchronization Mechanism for Mirrored Game Architectures   https://gameinstitute.qq.com/community/detail/117819   https://zhuanlan.zhihu.com/p/38468615","titles":[]},"16":{"title":"怪物状态同步","content":"在一个地图当中，玩家的状态同步之后，则需要同步地图中怪物的位置信息，怪物的位置信息同步方式一般有两种实现方式","titles":[]},"17":{"title":"基于客户端的状态同步","content":"一个地图中的怪物状态，实际上是由地图中玩家所决定的，当玩家施加攻击、使用技能，都会改变怪物的状态。在MapleStroy的设计当中，怪物的位置计算是属于离线计算，这也就是说，服务器不参与怪物的状态，这样的好处是节约流量、减缓服务器压力，但是坏处是，会出现怪物静止、吸怪等外挂手段。在移植MapleStroy的过程中，为了同步官方和考虑移动平台流量问题，因此采用此种手段。实现策略：怪物的位置由第一个进入该地图的玩家决定。这也就是说，当第一个玩家进入该地图之后，控制着当前地图中所有怪物的移动状态。当第二个玩家进入该地图之后，第一个玩家会广播当前所有怪物的状态，第二个玩家根据这些数据包进行改变。当然其他玩家发生了攻击，或者激怒怪物的操作后，也会广播这个消息。同时怪物的移动也是采用基于预言的状态同步，大体实现和玩家移动相似。怪物的同步在传统的端游里，是完全由服务器的怪物AI系统触发，客户端只是纯粹的接受服务器下发的怪物状态数据。对于手机游戏里，由于手机上很难出现像PC里那样的外挂，所以怪物的AI可以考虑放在客户端触发，同时减少怪物的状态同步。详细说明如下：","titles":["怪物状态同步"]},"18":{"title":"a) 怪物的随机移动不同步","content":"在地图上，怪物都会有一个固定的位置。怪物没有进入战斗状态时，就会在这个固定位置的周围走来走去，随机的移动。这个随机的移动设定由每个客户端自己控制，这样怪物的随机移动，就不用消息广播进行同步了。由于客户端自己控制怪物的随机走动，所以会出现不同客户端里，怪物位置不一样的问题。但由于怪物随机移动的范围较小，所以这个问题不是很明显，在手机上是可以接受的。角色打怪时，是扇形的伤害范围，所以即使怪物坐标在不同的客户端有点不一致，打怪的效果也可以接受。","titles":["怪物状态同步","基于客户端的状态同步"]},"19":{"title":"b) 怪物的行为同步","content":"当有角色攻击被动怪物，或者进入主动怪物的视野范围内时，怪物的AI就被这个角色所在的客户端锁定了，同时怪物进入攻击状态。攻击的判断完全由锁定怪物AI的客户端进行处理，同时这个客户端会将这个怪物的行为上发到服务器，由服务器广播给周围的其他玩家。怪物的AI锁定，使用抢占式，即谁最先发消息给服务器申请怪物的AI锁定，谁就获得了怪物的控制权，直到怪物死亡或脱离战斗状态。怪物可以每进行一次攻击，客户端就发一个消息给服务器。这样做，消息还是有点多，特别是一群怪围着几个角色进行攻击时，消息广播还是有点多。所以可以将状态的概念向上扩大，只同步怪物在攻击哪个玩家，而不同步每一次的攻击，然后由每个客户端根据怪物固定的攻击速度各自去表现。这样一个怪去攻击一个玩家，就只会有一次消息广播了。","titles":["怪物状态同步","基于客户端的状态同步"]},"20":{"title":"c) 精英怪和BOSS怪的AI","content":"精英怪和BOSS怪由于数量较少，而且比较重要，所以不能由客户端来申请AI控制权，而是服务器根据某种策略来控制。所使用的策略可以考虑角色的伤害值、防御值、角色与BOSS的距离远近等，根据这些因素，服务器计算出BOSS怪当前最适合攻击的对象（比如血量最少的玩家，最脆弱的法师等），然后将AI控制权发给那个客户端，由那个客户端控制攻击行为，同时通过消息让服务器同步给其他玩家。总结：怪物的同步方式的选择，就是尽量减少消息的广播，同时让游戏效果在可接受的范围内。怪物AI的这个处理方式，实际上是同时省去了游戏服务器的怪物AI模块（端游一般是专门用的一个进程或者另外一台物理服务器来进行怪物AI的计算），从而简化了MMO游戏的开发难度，同时保证了较好的游戏体验。","titles":["怪物状态同步","基于客户端的状态同步"]},"21":{"title":"相关链接","content":"https://www.jianshu.com/p/5dbdf81c4e69","titles":[]},"22":{"title":"Introduction - what is Quartz.NET?","content":"As per   their website :Quartz.NET is a full-featured, open source job scheduling system that can be used from smallest apps to large scale enterprise systems.It's an old staple of many ASP.NET developers, used as a way of running background tasks on a timer, in a reliable, clustered, way. Using Quartz.NET with ASP.NET Core is pretty similar - Quartz.NET supports .NET Standard 2.0, so you can easily use it in your applications.Quartz.NET has two main concepts:A   job . This is the background tasks that you want to run on some sort of schedule.  A   scheduler . This is responsible for running jobs based on triggers, on a time-based schedule.ASP.NET Core has good support for running \"background tasks\" via way of   hosted services . Hosted services are started when your ASP.NET Core app starts, and run in the background for the lifetime of the application. By creating a Quartz.NET hosted service, you can use a standard ASP.NET Core application for running your tasks in the background.This sort of non-HTTP scenario is also possible with the \"generic host\",   but for various reasons  I generally don't use those at the moment. This should hopefully improve in ASP.NET Core 3.0 with the extra investment going into these non-HTTP scenarios.While it's possible to create   a \"timed\" background service , (that runs a tasks every 10 minutes, for example), Quartz.NET provides a far more robust solution. You can ensure tasks only run at specific times of the day (e.g. 2:30am), or only on specific days, or any combination by using a   Cron trigger . It also allows you to run multiple instances of your application in a clustered fashion, so that only a single instance can run a given task at any one time.In this post I'll show the basics of creating a Quartz.NET job and scheduling it to run on a timer in a hosted service.","titles":[]},"23":{"title":"Installing Quartz.NET","content":"Quartz.NET is a .NET Standard 2.0 NuGet package, so it should be easy to install in your application. For this test I created an ASP.NET Core project and chose the Empty template. You can install the Quartz.NET package using   . If you view the   .csproj  for the project, it should look something like this:","titles":[]},"24":{"title":"Creating an IJob","content":"For the actual background work we are scheduling, we're just going to use a \"hello world\" implementation that writes to an    (and hence to the console). You should implement the Quartz interface    which contains a single asynchronous    method. Note that we're using dependency injection here to inject the logger into the constructor.I also decorated the job with the    attribute. This attribute   prevents Quartz.NET from trying to run the same job concurrently .","titles":[]},"25":{"title":"Creating an IJobFactory","content":"Next, we need to tell Quartz how it should create instances of   . By default, Quartz will try and \"new-up\" instances of the job using   , effectively calling   . Unfortunately, as we're using constructor injection, that won't work. Instead, we can provide a custom    that hooks into the ASP.NET Core dependency injection container (  ):This factory takes an    in the constructor, and implements the    interface. The important method is the    method, in which the factory has to return the    requested by the Quartz scheduler. In this implementation we delegate directly to the   , and let the DI container find the required instance. The cast to    at the end is required because the non-generic version of    returns an   .The    method is where the scheduler tries to return (i.e. destroy) a job that was created by the factory. Unfortunately, there's no mechanism for doing so with the built-in   . We can't create a new    that fits into the required Quartz API, so we're stuck only being able to create singleton jobs.This is important. With the above implementation, it is only safe to create    implementations that are   Singletons  (or transient).","titles":[]},"26":{"title":"Configuring the Job","content":"I'm only showing a single    implementation here, but we want the Quartz hosted service to be a generic implementation that works for any number of jobs. To help with that, we create a simple DTO called    that we'll use to define the timer schedule for a given job type:The    is the .NET type of the job (   for our example), and    is a   Quartz.NET Cron expression . Cron expressions allow complex timer scheduling so you can set rules like \"fire every half hour between the hours of 8 am and 10 am, on the 5th and 20th of every month\". Just be sure to   check the documentation  for examples as not all Cron expressions used by different systems are interchangeable.We'll add the job to DI and configure its schedule in   :This code adds four things as singletons to the DI container:The    shown earlier, used for creating the job instances.  An implementation of   , the built-in   , which handles scheduling and managing jobs  The    job itself  An instance of    for the    with a Cron expression to run every 5 seconds.There's only one piece missing now that brings them all together, the   .","titles":[]},"27":{"title":"Creating the QuartzHostedService","content":"The    is an implementation of    that sets up the Quartz scheduler, and starts it running in the background. Due to the design of Quartz, we can implement    directly, instead of the   more common approach of deriving from the base    class. The full code for the service is listed below, and I'll discuss it afterwards.The    has three dependencies: the    and    we configured in   , and an   . We only added a single    to the DI container (for the   ), but if you register more job schedules with the DI container they'll all be injected here.is called when the application starts up and is where we configure Quartz. We start by creating an instance of   , assigning it to a property for use later, and setting the    for the scheduler to the injected instance:Next, we loop through the injected job schedules, and create a Quartz    and    for each one using the    and    helper methods at the end of the class. If you don't like how this part works, or need more control over the configuration, you can easily customise it by extending the    DTO as you see fit.Finally, once all the jobs are scheduled, you call    to actually start the Quartz.NET scheduler processing in the background. When the app shuts down, the framework will call   , at which point you can call    to safely shut down the scheduler process.You can register the hosted service using the    extension method in   :If you run the application, you should see the background task running every 5 seconds and writing to the Console (or wherever you have logging configured)","titles":[]},"28":{"title":"Using scoped services in jobs","content":"There's one big problem with the implementation as described in this post: you can only create Singleton or Transient jobs. That means you can't use any dependencies that are registered as Scoped services. For example, you can't inject an EF Core    into your    implementation, as you'll have a   captive dependency  problem.Working around this isn't a big issue: you can inject an    and create your own scope,   similar to the solution for a similar problem in a previous post . For example, if you need to use a scoped service in your   , you could use something like the following:This ensures a new scope is created every time the job runs, so you can retrieve (and dispose) scoped services inside the   . Unfortunately things do get a little messy. In the next post I'll show a variation on this approach that is a little cleaner.","titles":[]},"29":{"title":"Summary","content":"In this post I introduced Quartz.NET and showed how you could use it to schedule background jobs to run in ASP.NET Core using   . The example shown in this post is best for singleton or transient jobs, which isn't ideal, as consuming scoped services is clumsy. In the next post, I'll show a variation on this approach that makes using scoped services easier.Example source code for this post   https://github.com/HangfireIO/Cronos   https://github.com/HangfireIO/Hangfire   https://github.com/quartznet/quartznet","titles":[]},"30":{"title":"Hangfire 与quartz.net对比","content":"在项目没有引入Hangfire之前，一直使用的是Quartz.net。个人认为Quartz.net在定时任务处理方面优势如下：支持秒级单位的定时任务处理，但是Hangfire只能支持分钟及以上的定时任务处理原因在于Hangfire用的是开源的  NCrontab 组件，跟linux上的crontab指令相似。更加复杂的触发器，日历以及任务调度处理  可配置的定时任务但是为什么要换Hangfire? 很大的原因在于项目需要一个后台可监控的应用，不用每次都要从服务器拉取日志查看，在没有ELK的时候相当不方便。Hangfire控制面板不仅提供监控，也可以手动的触发执行定时任务。如果在定时任务处理方面没有很高的要求，比如一定要5s定时执行，Hangfire值得拥有。抛开这些，Hangfire优势太明显了：持久化保存任务、队列、统计信息  重试机制  多语言支持  支持任务取消  支持按指定  处理任务  服务器端工作线程可控，即job执行并发数控制  分布式部署，支持高可用  良好的扩展性，如支持IOC、Hangfire Dashboard授权控制、Asp.net Core、持久化存储等说了这么多的优点，我们可以有个案例，例如秒杀场景：用户下单->订单生成->扣减库存，Hangfire对于这种分布式的应用处理也是适用的，最后会给出实现。","titles":["Summary"]},"31":{"title":"还有就是不要混用..不要将datetime当成datetimeoffset使用,","content":"当需要使用DateTimeOffset的Date等字段的时候,要及时转成DateTimeOffset,需要使用new方法并设置时区转成datetimeoffset  直接赋值,会出现时区问题","titles":[]},"32":{"title":"那么何为字节序（Endia）呢？","content":"Big Endian是指低地址存放最高有效字节（MSB），而Little Endian则是低地址存放最低有效字节（LSB）。大端模式所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；例子：在大端模式下，前32位应该这样读:   ( 假设int占4个字节)记忆方法:小端模式所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。例子：在小端模式下，前32位应该这样读:   ( 假设int占4个字节)记忆方法:有图有真相，举个例子，数字   0x12345678  在两种不同字节序CPU中的存储顺序如下图","titles":[]},"33":{"title":"为什么会有这样的情况呢？","content":"这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。Motorola的  PowerPC 系列CPU采用Big Endian方式存储数据。  Intel的  x86 系列CPU采用Little Endian方式存储数据。  ARM既可以工作在大端模式，也可以工作在小端模式。再来说说，一些我所收集到的情况吧。Windos(x86,x64)和Linux(x86,x64)都是  Little Endian 操作系统  在ARM上，我见到的都是用  Little Endian 方式存储数据。  C/C++语言编写的程序里数据存储顺序是跟编译平台  所在的CPU相关 的。  JAVA编写的程序则唯一采用  Big Endian 方式来存储数据。  所有网络协议也都是采用  Big Endian 的方式来传输数据的。所以有时我们也会把  Big Endian 方式称之为  网络字节序 。","titles":["那么何为字节序（Endia）呢？"]},"34":{"title":"为什么要注意字节序的问题呢？","content":"你可能这么问。当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？尤其是当你把你在微机上运算的结果运用到计算机群上去的话。在这里我想说说两种语言。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的 0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。什么？竟然变成另外一个数字了？是的，就是这种后果。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。","titles":["那么何为字节序（Endia）呢？"]},"35":{"title":"网络字节序","content":"","titles":[]},"36":{"title":"一、在进行网络通信时是否需要进行字节序转换？","content":"相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。原因如下：网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。","titles":["网络字节序"]},"37":{"title":"二、网络字节序","content":"​    网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;","titles":["网络字节序"]},"38":{"title":"c# 大端转换","content":"c#在windows平台上是小端字节序(Windos(x86,x64)和Linux(x86,x64)都是  Little Endian 操作系统,不止是c#)。网络发送字节流是按大端序发送，也就是从左到右发送，和c#的小端序相反，造成网关不能正常识别协议。所以需要转换大小端转换C# 判断数据在此计算机结构中存储时的字节顺序（“Endian”性质），即大端还是小端一些封装另外c#直接提供了网络字节序转换方法。（本机到网络转换）(网络字节转成本机)推荐使用这种方法，简单有效。","titles":[]},"39":{"title":"对于字符串型：","content":"使用 System.Text.Encoding.Default.GetBytes();直接取字串对应字节数组。不知道为什么这个方法取到的直接就是大端字节数组。不用转换。后来查了一下，关于字串的字节序问题，因为gbk和utf-8都是以单个字节表示数字的，所以不存在字节序问题，在多个不同系统架构都用。对于utf-16，则是以双字节表示一个整数，所以为会有字节序问题，分大小端unicode。System.Text.Encoding.Default.GetBytes();在我的简体中文系统上是以gb2312的编码，也就是单个字来进行编码的，所以也不会有字节序问题。补充：“**对于任何字符编码，编码单元的顺序是由编码方案指定的，与endian无关。**例如GBK的编码单元是字节，用两个字节表示一个汉字。这两个字节的顺序是固定的，不受CPU字节序的影响。UTF-16的编码单元是word（双字节），word之间的顺序是编码方案指定的，word内部的字节排列才会受到endian的影响。”，所以utf-8也没有字节序的问题。字节序问题之存在于需要使用两个字节以上来表示整数。而UTF-8只是一串字节流，不存在字节序问题，不过将这些字节流翻译成Unicode比其他的传输方式复杂。以字节为单位编码的，无论一个汉字是多少个字节，都无字节序问题。你注意，字节序问题不是指多个字节传输的先后，这个是固定的无异议的。而是指一个多字节编码在机器中的表示方式问题。这个无字节序问题。但就有字节序问题了。因为str[0]同样数值不同机器中表示不同。而剩下的， 就是字符编码内部的字节序了。比如UTF-16是用两个字节表示一个字符，但是这两个字节内部如何排序，系统并不知道，所以必须指定字节序。但是UTF-8由于几个字节表示并不相同，一定要从那个表示长度的字节开始读，相当于一开始就知道该从哪里是队头队尾，所以不存在字节序问题。","titles":["c# 大端转换"]},"40":{"title":"1.综述","content":"第一人称角色网络游戏的设计是一项很有挑战性的工作。网络环境下的健壮性，是动作游戏能否成功的一个重要因素。另外，PC上面的开发者需要考虑到玩家层次不齐的机器配置以及网络状况，很多用户的硬件配置跟网络跟当前最好的配置跟网络有一定差距。宽带网络的出现有利于在线游戏开发，但是开发者还是需要考虑网络延迟和其它网络特性。而且宽带网络在美国被广泛采用还需要一段时间，在世界上其它国家可能需要更长的一段时间。另外，很多宽带网络质量很差，用户虽然偶尔能够享受到高带宽，但更多的时候他们不得不面对高延迟和高丢包率。我们应该提供给玩家良好的游戏。本篇文章讨论了如何提供给玩家顶尖的操作体验；介绍了很多在线动作游戏中采用的C/S架构背景。此外，我们还讨论了如何通过一个预测模型来掩饰延迟带来的影响。文章的最后描述了一个叫做延迟补偿的机制，弥补了因为网络质量不好带来的负面影响","titles":[]},"41":{"title":"2.C/S游戏的基本架构","content":"网络上可玩的大部分动作游戏都是C/S结构游戏基础上修改完成的，比如半条命以及其修改版反恐精英、军团要塞，以及一些基于quake3引擎和虚幻引擎的游戏。这类游戏都有一个用来执行游戏逻辑的服务器以及连接到这个服务器的多个客户端。客户端仅仅是用来接收玩家的操作并发给服务器，服务器对这些操作作出响应，移动玩家周围物体，并将游戏世界的信息发给客户端显示出来。当然世界的游戏系统有更多组件，我们这样简化有利于分析预测和延迟补偿。基于这种考虑，典型的C/S游戏引擎通常看起来是这样的为了便于讨论，我们假定客户端跟服务器之间已经建立连接；客户端的每一帧循环如下：获取帧开始时间  采集用户输入  根据模拟时间将移动命令打包发送给服务器  获取处理服务器传过来的数据包  根据服务器数据包的内容决定可见物体及其状态  渲染场景  获取帧结束时间  结束时间减去开始时间就是下一帧的模拟时间客户端每完成一个帧循环，就用“frametime”来决定下一帧需要多少时间，如果帧率恒定，“frametime”就是准确的，否则就没办法获得准确的“frametime”（因为在没一帧开始你不可能知道这一帧需要多长时间）服务器的循环大同小异：获取帧开始时间  读取客户端发过来的操作信息  根据客户端操作执行逻辑运算  采用上一个循环得到的模拟时间来模拟服务器控制的物体移动状态  对每一个连接的客户端，发送打包相应的物体/世界状态  获取帧结束时间  结束时间减去开始时间就是下一帧的模拟时间在这个模型中，非玩家物体完全由服务器控制其状态，每个玩家根据服务器发过来的数据包控制自己的移动。这是一种很自然的方法，当然还有其它的方法也可以完成这个功能。","titles":[]},"42":{"title":"3.用户消息的内容","content":"基于half-life引擎的游戏用户消息都很简单，只需要封装在一个包含几个关键成员的结构中：结构中最关键的变量时msec,viewangles,forward,side,upmove和buttons。msec表示这个命令执行对应的毫秒数（也就是上面提到的“frametime”）。viewangles是一个三维向量，表示玩家的朝向。forward,side和upmove表示玩家是否通过键盘、鼠标或控制杆控制移动。最后，buttons这个字段包含一个或多个比特，标志玩家是否按着某些按键。基于C/S架构的游戏采用以上数据结构运行如下：客户端创建命令并发送到服务器，服务器响应这些命令并把更新了的世界和物体位置信息发回客户端，客户端收到以后进行渲染。这种方式非常简单，但是在实际应用中效果差强人意，用户会感觉到网络连接带来的明显延迟。这主要是由于客户端完全没有逻辑操作，发出消息以后就等待服务器响应。如果客户端跟服务器有500ms的延迟，客户端执行了操作到看到操作的结果就需要500ms，这种延迟在局域网通常可以接受（因为通常延迟比较小），但在因特网上是没法接受的","titles":[]},"43":{"title":"4.客户端预测","content":"有一种方法可以改善这种情况：客户端本地即时执行移动操作，假定服务器即时通知客户端可以执行操作，这种方法可以称为客户端预测。采用客户端运动预测以后，客户端就不再是一个“小型客户端”，不再单单响应服务器命令；但也不是说客户端可以像没有中央服务器的p2p游戏完全自治。服务器仍然在运行并保证在客户端跟服务器运行结果不一致的情况下纠正客户端错误的模拟。由于网络延迟，修正在一个网络传输周期以后才会执行，这个时候纠正信息通常已经过期，这样会导致明显的位置漂移，因为客户端收到的修正信息是过去某个时间的。为了使客户端运动预测有效，我们采用以下方法：还是客户端采样并生成命令发送到服务器，但是每个包含生成时间的命令在客户端本地存起来并在预测算法中使用。预测的过程中，我们把服务器确认的移动信息作为开始，这样客户端就可以确定服务器执行上次命令以后游戏中玩家的准确信息（比如位置）。如果网络有延迟，这个确认命令也会有一定延迟。假设客户端运行帧率为50fps，网络延时为100ms，这样在客户端收到服务器的确认命令的时候，本地命令队列中已经有5条信息，这5条信息被用来执行客户端预测。假设执行完全预测【1】客户端在收到来自服务器的最新信息后，就开始按照与服务器相同的逻辑执行本地消息队列中的5个命令。这些命令执行以后得到当前状态（最重要的是位置），然后根据玩家的状态信息渲染当前帧。在半条命这个游戏中，客户端跟服务器采用相同的代码来计算移动，这样可以减小客户端预测跟服务器之间的误差。这些代码位于HLSDK中的pm_shared/（意思是“player movement shared”）。这段代码的输入是玩家操作和客户端的初始状态，输出是玩家操作以后的状态。客户端算法大致如下：玩家的初始状态和预测结果用来渲染场景。命令的执行过程就是：将玩家状态复制到共享数据结构中，执行玩家操作（执行hlsdk中pm_shared中的共用代码），然后将结果复制到目标状态（to state）这个系统中有几个需要注意的地方，首先，由于网络延迟，客户端又在不停地以一定速度（客户端帧率）生成命令，一个命令通常会被客户端多次执行，知道得到服务器的确定以后将其从命令列表中删除（这就是半条命中的滑动窗口）。首先要考虑的是如何处理共享代码中生成的声效和动画效果。因为命令可能会被多次执行，预测位置的过程被多次执行的时候要注意避免重声等不正确的效果。另外，服务器也要避免客户端意见预测的效果。然而，客户端必须重新运行旧的命令，否则就没法根据服务器来纠正客户端的预测错误。解决方法很简单：客户端将没有执行的客户端命令进行标记，如果这些命令在客户端第一次执行，则播放相应的效果。另外需要注意的是服务器不处理，只有客户端才有的一些数据；如果没有这种类型的数据，我们可以如上面所述，以服务器第一条消息作为起点进行预测得到下一帧状态（包括用来渲染的位置信息）。然而，如果有些逻辑是纯客户端的，服务器不会处理（比如玩家蹲下来眼睛的位置-然而这也不是纯客户端信息，因为服务器也会处理这个数据），这种情况下我们需要将预测的中间结果存起来。可以用一个滑动窗口完成这项工作，其中“开始状态”是开始，以后每次执行一个玩家命令预测完成后，填写窗口中的下一个状态；当服务器通知某个命令被接受并执行以后，从窗口中查找服务器处理的是哪条命令并将相应的数据传到下一个帧的“起始状态”到此为止，我们描述了客户端的运动预测。quakeworld2中采用了这种类型的预测","titles":[]},"44":{"title":"5.开火过程中的客户端预测","content":"上面描述的系统可以很自然地用于武器开火效果预测。客户端玩家需要记录一些状态，比如身上有哪些武器，正在使用的是哪一个，每把武器都还剩多少弹药。有了这些信息，开火逻辑可以建立在运动逻辑上面，只需要在客户端和服务器使用的命令里面加上玩家开火的按键信息。在半条命中，为了简单，武器开火逻辑代码也跟运动代码一样也作为“共享代码”。所有会影响到武器状态的变量，比如弹药、下次可开火时间、正在播放那个武器动画，都作为服务器的状态，这些状态会通知给客户端用来预测武器状态。客户端武器开火预测包括预测武器切换、部署、手枪皮套。这样，玩家会感觉游戏中的移动和武器状态100%受他控制。这在减小网络延迟给玩家带来的不爽上面迈出了一大步。","titles":[]},"45":{"title":"6.一些工作","content":"服务器需要将必要的字段发给客户端，并且处理很多中间状态，有人可能有这样的疑问，为什么不把服务器逻辑取消，让客户端广播自己的位置，也就是将所有的移动、开火逻辑放在客户端。这样，客户端就会给服务器发送类似这样的结果报告：“我在X位置，我爆了玩家2的脑袋”。如果客户端可信的话，这样做是可以的，很多军方仿真系统就是这样做的（他们是一个封闭系统，所有客户端都可信）。点对点的游戏也是这么做的。对于半条命来说不可以这样做，因为客户端可能“欺骗”服务器。如果我们以这种方法封装状态数据，就会诱导玩家破解客户端【3】。对于我们的游戏来说这样做奉献太大，我们还是选择采用服务器模式来做校验。客户端进行运动和武器效果预测是非常可行的。例如quake3就支持这样的预测。这个系统需要注意一点，在判断目标的时候需要考虑到延迟（比如即时射击武器）。换句话说，虽然你看到自己用\\即时\\武器进行了射击，你自己的位置也是最新的，射击结果仍然跟延迟有关。例如，如果你射击一个玩家，这个玩家沿与你实现垂直的方向奔跑，假设你客户端延迟为100ms，玩家奔跑速度是500单位每秒，这样你需要瞄准玩家前方50单位才能准确击中。延迟越大，就需要更大的提前量。靠感觉弥补延迟太困难了。为了减轻这种效果，quake3对你的射击播放一个短音来进行确定。这样，玩家可以算出快速发射武器的时候需要多大的提前量，同时调整提前量直到听到稳定的音调串。如果延迟比较大，而你的对手又在不断躲避，就很难获得足够的反馈判断。如果延迟也不断变化，就更难了。","titles":[]},"46":{"title":"7.目标的显示","content":"影响玩家游戏体验的另一个重要方面是客户端如何渲染其它玩家。两种基本的判断机制是：外推法和内插法【4】外推法把其它玩家/物体看作一个点，这个点开始的位置、方向、速度已知，沿着自己的弹道向前移动。因此，假设延时是100ms，最新的协议通知客户端这个玩家奔跑速度是500单位每秒，方向垂直于玩家视线，客户端就可以假设事实上这个玩家当前实际的位置已经向前移动了50个单位。客户端可以在这个外推的位置渲染这个玩家，这样本地玩家就差不多可以正确瞄准。外推法的最大缺点是玩家的移动并不是完全弹道的，而是不确定的并且高\"jerk\"【5】。大部分FPS游戏采用非现实的玩家系统，玩家可以随时转弯，可以在任意角度作用不现实的加速度，因此外推法得到的结果经常是错误地。开发者可以通过限制外推时间来减轻外推误差（比如quake限制不能超过100ms）。这种限制使得在客户端收到玩家正确位置以后，纠错不至于太大。当前大部分玩家的网络延迟高于150ms，玩家必须对游戏中的其他玩家进行外推以便正确击中。如果别的玩家因为外推错误，被服务器拉回，游戏体验将非常差。另一种方法叫插值法。插值法可以这样理解：客户端物体实际移动位置总是滞后一段时间。举个例子，如果服务器每秒同步10次世界信息，客户端渲染的时候会有100ms滞后。这样，每一帧渲染的时候，我们通过最新收到的位置信息和前100ms的位置信息（或者上一帧渲染位置）进行差值得到结果。我们每收到一个物体位置的更新信息，（每秒10个更新意味着每100ms收到一个更新）接下来的100ms我们就可以朝这个新的位置移动。如果一个更新包没有收到，有2种处理方法：第一、用上面介绍的外推法（有可能产生较大误差）；第二、保持玩家位于当前位置直到收到下一个更新包（会导致玩家移动顿挫）内插法的大致过程如下：每个更新包包含生成的服务器时间戳【6】  根据客户端当前时间，客户端通过减去时间差（100ms）计算 一个目标时间  如果计算得到的目标时间在上一个更新时间和上上个更新时间之间，这些时间戳可以决定目标时间在过去的时间间隙中的情况  目标时间情况用来通过插值计算结果（如位置、角度）上面提到的插值法，本质上是客户端缓存了接下来100ms的数据。对于每一个周围的玩家，他们都位于过去某个时间的位置，根据每一个具体的时间点进行插值。如果偶尔发生丢包，我们就将插值时间延长到200ms。这样我们就可以忽略一次更新（假设同步频率还是10次每秒），玩家还可以移动到合理的目标位置，这样进行插值通常不会有什么问题。当然，插值多少时间需要权衡，因为这种方法是用延时（玩家更难击中）来换取平滑。另外，上述插值方法（客户端通过2个更新信息插值并且朝最新更新位置移动）需要服务器更新信息间隔固定。对于所谓的“视觉效果因素”，这种方式很难处理，“视觉效果因素”是这样的：假设我们插值的物体是弹球（这种模型可以准确描述某些玩家）。极端情况下，球或者在空中，或者正在碰地板。然而，通常情况下球在这两种状态之间。如果我们只插值上一个位置，这个位置可能既不在地面上，也不是最高点，这样，弹球弹的效果就被平滑掉了，好像永远没有弹到地面一样。这是一个经典问题，增加采样率可以减轻这种影响，但是仍然有可能我们采样不到球在地面的点跟最高点，这些点会给平滑掉。另外，不同用户网络状况不同，强迫每个用户都以固定速度更新（比如每秒10次）效果不是很好，在半条命中，用户每秒可以请求任意数量的更新包（没有限制）。这样，高速网络用户可以每秒更新50次，只要用户愿意。半条命的默认设置是每秒每个用户（以及游戏中其它物体）发送20次更新，以100ms为时间窗口进行插值。【7】为了避免“反弹球\"平滑问题，我们在插值的过程中采用了一个不同的算法，这种算法中我们对每一个可能插值的物体记录了一个完整的“历史位置”信息。历史位置信息记录了物体的时间戳、远点、角度（以及其它我们需要插值计算的数据）。我们每收到一个服务器的更新，我们就创建一条包含时间戳的记录，其中包含原始位置、角度信息。在插值过程中，我们用上面的方法计算目标时间，然后搜索位置历史信息，找到包含目标时间的记录区间。然后用找到的信息插值计算当前帧的位置。这样我们就可以平滑跟踪到包含所有采样点的曲线。如果客户端帧率比服务器更新频率大，我们就可以将采样点平滑处理，减小上面提到的平滑处理带来的问题（当然没法避免，因为采用频率限制，而世界本身是连续的）。需要注意的是，上面提到的插值方法使用的时候，物体有时候会被服务器拉回，而不是快速移动。当然我们也可以平滑地将物体移动一段较长的距离，这样看起来物体移动很快。更新的过程中我们可以设一个标志表示不插值或清除历史记录，或者如果起始点与目标点距离过长，我们就认为数据不正常。这种情况我们就将物体直接拉过去。并以这个位置为起始点进行插值。","titles":[]},"47":{"title":"8.延迟补偿","content":"插值也会带来延迟，所以考虑延迟补偿的过程中需要理解插值过程。玩家看到的别的物体是经过插值计算出来的，所以插值过程中需要考虑在服务器上玩家的目标是否正确。延迟补偿是服务器执行的一种策略，当服务器收到客户端命令并执行的过程中，根据客户端的具体情况进行归一。延迟补偿可以看做服务器处理用户命令的时候回退一段时间，退到客户端发送命令时候的准确时间。算法流程如下：服务器执行客户端命令之前执行以下操作：   计算玩家正确的延迟  对每个玩家，从服务器历史信息中找到发送给玩家信息和收到玩家响应的信息。  对于每一个玩家，将其拉回到这个更新时间（插值得到的精确时间）中执行用户命令。这个回退时间需要考虑到命令执行的时候的网络延时和插值量【8】  执行玩家命令（包括武器开火等。）  将所有移动的、错位的玩家移动到他们当前正确位置。注意：我们把时间往后推算的时候，需要考虑那个时候玩家的状态，比如玩家是或者还是已经已经死掉，玩家是否处于躲避状态。执行运动补偿以后，玩家就可以直接瞄准目标进行设计，而不需要计算一个提前量。当然，这种方案是游戏中的权衡设计。","titles":[]},"48":{"title":"9.游戏涉及中延迟补偿的使用","content":"采用延迟补偿以后，每个玩家游戏的过程中感觉不到明显延迟。在这里需要理解可能会产生一些矛盾和不一致。当然，验证服务器和无逻辑的客户端老系统也会有自相矛盾的情况。最后，这个这种事游戏设计决定的。对于半条命，我们相信采用延迟补偿是正确的游戏决定。老系统的一个问题是，由于网络延迟，目标需要有一个提前量。瞄准敌人进行射击几乎总是不能击中。这种不一致导致射击很不真实，响应也不可控制。采用延迟补偿以后带来的是另一种形式的不一致。对于大部分玩家，他们只需要专注于得到更多的射击技能来武装他们（当然他们也是需要瞄准的）。延时补偿使得玩家只需要直接瞄准他的目标并按下开火按钮即可（对于即时击中武器【9】）。不一致也时有发生，但是是在击中以后。例如，如果一个延时比较大的玩家击中一个延时比较小的玩家并且得到一分，低延时的玩家会感觉高延时玩家“在角落里被击中”【10】。这种情况下，低延迟玩家可能已经从角落里冲出，而高延时玩家看到的是过去的信息。每一个有延迟的玩家都有一个朝向别的玩家的直的视线，直的视线指向一个瞄准点然后开火。这个时候，低延时的玩家可能已经跑到角落里并且蹲在一个箱子后面，如果高延迟玩家延迟比较大，比如500ms，这是经常发生的；这样当高延时玩家的命令传到服务器的时候，已经隐藏起来的玩家需要取一个历史位置并计算是否击中，在这种极端情况下，低延时玩家会觉得他再角落里被击中了。然而，对于高延时玩家来说，他是正对着别的玩家开火的。从游戏设计的角度来讲，我们需要这样决定：让每个玩家即时与世界交互并开火。此外，在正常战斗中，上面提到的不一致并不明显。对于第一人称射击游戏，有两种典型情况。第一、考虑两个玩家直线跑向对方并且开火；这种情况下，延时补偿只会把玩家在移动直线上往后拉。被击中的玩家看他的射击者在前方，这样就不会有“子弹拐到角落里”的情况发生。第二种情况是两个玩家中的一个射击，另外一个玩家在垂直于第一个玩家视线的方向冲锋。这种情况下的解决问题的原理与刚才不同。刚才提到的冲锋的玩家视野差不多是90°（至少第一人称射击游戏是这样），因此，这个玩家看不到正在射击他的那个人。因此他被击中也不会感觉奇怪或者错误（谁让你在空旷区域狂奔呢，活该）。当然，如果你开发的是一个坦克游戏，或者在你的游戏中玩家朝一个方向跑的时候可以看到别的方向，错误可能就会比较明显，你可能发现玩家设计方向不对。","titles":[]},"49":{"title":"10.总结","content":"延迟补偿是当前动作游戏改善延迟影响的一种方法。是否采用这种方法取决于游戏设计者，因为如何设计直接影响到游戏的体验。对于把那条命、军团要塞、cs这样的游戏，延迟补偿所带来的效果提升显著大于其带来的错误。","titles":[]},"50":{"title":"脚注","content":"【1】在半条命引擎中，预测的过程中允许一定的延迟，但不能容忍实际网络延迟这么大的延迟。通过调整参数，我们可以控制预测过程中的延迟，这个参数pushlatency是一个负数，以毫秒为单位表示预测过程中的延迟。如果这个值大于（绝对值）实际网络延迟，这时预测就是完全的预测（译注：客户端服务器完全同步）。这种情况下玩家感觉不到任何延迟。实际应用中，一些人错误地认为参数pushlatency应该设为实际网络延迟的一半，这种情况下玩家移动仍然有网络延迟一半的延迟（感觉类似于冰面移动）。基于这个原因，实际应用总应该总是采用完全预测，pushlatency这个变量应该从半条命引擎中移除【2】  http://www.quakeforge.net/files/q1source.zip  (Return)【3】关于作弊和反作弊的问题超出了本篇文章讨论的范围【4】虽然混合纠正方法也可以使用【5】“jerk”用来度量使玩家改变加速度的作用的快慢【6】本文假设计算连接延时的时候客户端与服务器完全同步，也就是说，每次更新的时候客户端收到服务器发过来的时间被直接当做客户端的时间使用。这样，客户端跟服务器完全匹配，只是客户端稍微晚一点（晚多少取决于延时多少）。平滑客户端时钟差值可以有很多方法。【7】更新时间间隔没必要是固定的。因为对于剧烈运动的游戏，如果带宽不够，很有可能客户端发过来的数据超过了处理能力。如果采用固定更新间隔，在发完一个更新包以后就需要等待一个固定更新周期时间以后再发下一个包。这种逻辑不能很好地使用带宽。因此，服务器发给每个客户端数据包以后，应该自己决定下一个包什么时候发，决定的依据是用户的带宽、用户设置的每秒更新频率。如果用户要求更新20次每秒，那么需要等待50ms以后下个更新包才能发送。如果激活了带宽限制（而服务器帧率又足够高），我们可能就需要等待比如61ms（或其他值）以后发送下一个更新包。因此，半条命游戏数据包发送间隔是随机的。基于服务器的这种情况，将启动点作为一个变量，移动到最新目标点进行插值这种方法效果欠佳。【8】半条命代码中usercmd_t结构中变量lerp_msec前面描述过。【9】对于发射导弹的武器，延迟补偿有更多需要解决的问题。假如\\导弹是由服务器处理的，那么导弹应该位于哪个时间区间？每次导弹准备发射的时候，是否需要把每个玩家往后拉一段时间的？如果是这样，那么需要往后拉多少？这些问题是需要考虑的。在半条命中，为了避免这种问题，我们对导弹不进行延迟补偿（这并不意味着客户端不进行声音预测，只是实际的导弹不进行延迟补偿）。【10】用户社区通常采用这种情况来描述不一致性。https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization","titles":[]},"51":{"title":"网络对时","content":"大部分的强交互网游会做对时, 使 client 和 server 保持时间基本一致.client 带上本地时间 t0 向 server 发送对时请求.  server 回复当前自己的系统时间 t1.  client ack 收到 server 回复时的本地时间 t2.如果只有 client 关心对时结果, 这时可以优化到  只做1,2步甚至只做第2步 , 相当于 client 主动发起 ping;同样, 如果只有 server 关心对时结果, sever 主动发起 ping (第2,3步)即可.单次对时往往会受到网络波动的影响, 所以一般还需要做多次统计一个比较合理的时间偏移.网络对时, 一般在进游戏之初做. 如果在游戏过程中发现有网络波动过大的情况(在下行协议包中带上 server 的时间, 很容易检查到提前或者滞后), 也需要重新发起对时.考虑到反外挂(比如加速齿轮, 或者减速器)的因素, server 端需要对主动发起的client对时请求做一些安全校验, 例如时间递增, 是否满足阈值等等.光从对时的角度来看, UDP 协议比 TCP 更合适一些, 不过取决于项目需要.","titles":[]},"52":{"title":"服务器和客户端时间差算法   (st0+st2-2ct1)/2","content":"","titles":[]},"53":{"title":"两种理解方式","content":"","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2"]},"54":{"title":"第一种方式","content":"延迟+ 时间差(同一时刻下客户端减去服务端的时间差)延迟+ 时间差(同一时刻下服务端减去客户端的时间差)我们需要的就是   由上可以转换为现假设   同时假设延迟相等","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2","两种理解方式"]},"55":{"title":"第二种方式","content":"我们知道  是单次延迟 即延迟+ 时间差(同一时刻下服务端减去客户端的时间差)https://patents.google.com/patent/CN101577715A/zh服务器获得服务器与客户端的时间差值后，与服务器接收到来自客户端的数据包的时间做差值可以获得客户端在游 戏过程中实际向服务器发送数据包的时间，  并通过客户端在游戏过程 中实际向服务器发送数据包的时间来判定在游戏时间中事件发生的实际顺序 ， 从而较好的保持了游戏的公平性，提高了游戏玩家的游戏体验。","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2","两种理解方式"]},"56":{"title":"检查安全性","content":"第一次连接的对时..时差不该查过三分钟.  校验包客户端有没有修改时间,能够求得发包的时间,对比服务器接收到包的时间以及延迟","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2","两种理解方式"]},"57":{"title":"移动的延迟补偿.","content":"使用了客户端预测的话,客户端的移动位置要优先于服务端的,因为有来回两次延迟..由于状态同步以服务端为准,使用服务器校对不会出什么问题.所以这里的补偿是补偿从客户端到服务端这段延迟.如果使用了服务器校对不补偿也并没有什么太大的问题,因为最终仍然是以服务器为准的.但是补偿了之后减少了延迟,会更平缓一点.https://patents.google.com/patent/CN102404279A/zh","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2"]},"58":{"title":"boss攻击的延迟补偿.","content":"玩家ct2的时候开始移动,但是服务器收到的时候已经是st4而服务器st2的时候boss发动了攻击.这个时候.玩家在服务器的位置是在ct3需要boss把攻击作为关键事件...直到客户端有ct4事件出来时再执行st2,可以使用时间轮算法触发关键事件","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2"]},"59":{"title":"玩家 的延迟补偿","content":"这是由于客户端使用了插值算法造成的比如fps游戏,玩家看到的敌人的位置永远是过去的,当你开枪的时候,那个人其实已不在那个位置所以需要记录游戏的世界状态..找到子弹打出时那一刻的世界状态.然后判定https://patents.google.com/patent/CN102739608A/zh","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2"]},"60":{"title":"一些模拟恶劣网络环境工具","content":"http://jagt.github.io/clumsy/cn/index.html","titles":["服务器和客户端时间差算法   (st0+st2-2ct1)/2"]},"61":{"title":"PART 1 概述","content":"本文是关于探索快节奏多人游戏的技术和算法系列的第一篇，因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论。。。任何类型的游戏开发都是某种挑战，然而在多人游戏中我们还有更多全新的问题函待解决～最最 Interesting 的地方在于其核心问题其实是人类和物理！- - 好吧其实是作弊和地理限制造成的网络延时。。","titles":[]},"62":{"title":"PART 2 反作弊","content":"所有的一切的起源都是作弊。作为一个游戏开发者，你一般不会去担心有人在你的单人游戏中去作弊 - 因为他的行为不会给其他人带来影响，一个作弊的玩家可能并不会按你设计的套路去进行游戏，但是游戏是他的，他们有权利去选择怎么去玩。多人游戏则不同。在任何的有竞争关系的游戏中，一个作弊玩家不仅仅给自己带来了更好的体验，他也毁了其他的玩家的游戏。作为开发者，你可能希望避免出现这样的情况，因为这会让玩家流失。为了防止作弊，有很多事可以去做，但是最重要最（可能也是唯一有意义的）的事非常简单：不要相信玩家。就做最坏的打算：所有玩家都想要作弊。","titles":[]},"63":{"title":"PART 3 权威服务器和静默客户端","content":"有一个非常简单的解决方案 - 你将游戏中所有的逻辑都放在你控制的服务器来做，而客户端只是游戏的旁观者，换句话说，你游戏的客户端把输入（按键，命令）发送到服务器，服务器来运行这个游戏，然后你把结果返回给客户端。这就是常说的权威服务器，因为游戏世界中发生的一切都在服务器中进行。当然，你的服务器还是可能被发现漏洞，但是这就不属于我们要谈论的范围了。使用权威服务器可以防止很多的漏洞，比如，服务器不信任玩家的在客户端的血量，客户端想要作弊，把本地的血量调到10000%，但服务器知道血量只有10% - 当玩家被攻击的时候它还是会死掉，不管客户端的血量是多少。服务器同样不信任玩家的位置。你可能会这样做，在这一秒你告诉服务器“我在（10，10）”，然而下一秒你告诉服务器“我在（20，10）”，这样就可以穿过一堵墙或者超快速的移动。但是，权威服务器知道玩家在（10，10），当客户端告知服务器他要往右动一格的时候，客户端的位置会由服务器来处理，将位置更新为（11，10），然后告知玩家“你在（11，10）”。如下图所示:总的来说，游戏的状态由服务器独自管理。客户端将动作发送给服务器，服务器来周期性地更新游戏状态，然后将新的游戏状态发送给客户端，客户端对结果进行渲染呈现。。","titles":[]},"64":{"title":"PART 4 考虑网络问题","content":"上面的处理方式对于回合制的游戏非常适合，比如策略游戏或者棋牌类的游戏。它在LAN中也能工作的很好，在这种情况下，通信是瞬发的。但是对于一些对实时性要求很高的游戏，而且在internet环境中，这种解决方案就会出问题了。下面来谈一些物理的问题。假如你在旧金山，连接了一个在纽约的服务器，两地相距4000km或者2500英里（大概是里斯本到莫斯科的距离）。任何东西都不能比光快吧，即使是Internet上的数据（数据传播的底层可能是光的脉冲，线缆中的电子，或者是电磁波），光传播的速度大概是300000km/s，所以传播4000km需要13ms。这听起来可能很快，但这实际是最乐观的情况 - 假设数据传播的速度是光速，沿着直线传播，这些通常是不可能的。在真实情况下，数据是由无数个路由经过一系列的跳（在计算机网络里的属于叫做hops）进行传播的，而且大部分的传播速度都达不到光速；路由在传播的时候也会产生一些延迟，因为包必须被打包，检查和分发。所以保险起见，我们假设数据从客户端到服务器需要50ms，这接近最好的场景了 - 当你在纽约而服务器在东京呢？假设网络因为什么原因发生阻塞了呢？100ms，200ms，500ms的延迟也是有可能的。回到我们的例子，你的客户端将输入“我按下了向右的按键”发给服务器，服务器在50ms之后获取了数据，现在假设服务器能够立即响应并且将结果返回，那么客户端在50ms之后获得新的游戏状态“你现在在（1，0）”。从你的视角来看，情况是这样的：你按下了向右的按键，但是什么事都没发生，直到一百年后你的角色向右移动了一格。这样的延迟是显而易见的，当然延迟半秒不仅仅是显而易见，它让整个游戏没法玩了。","titles":[]},"65":{"title":"PART 5 总结","content":"通过网络连接的多人游戏是超级有趣的，但是引入了一系列的难题和挑战。权威服务器架构能够防止很多的作弊，但是直接用这种方法会让游戏的响应变得迟缓。在下面的文章，我们会介绍我们怎么围绕权威服务器来建立一个系统，能够最小的减少玩家的延迟体验，就像在玩单机游戏一样顺畅。http://www.gabrielgambetta.com/client-server-game-architecture.html","titles":[]},"66":{"title":"PART 1 概述","content":"在第一篇文章中，我们介绍了一种权威服务器的C-S模型，在这种模型中，客户端只将输入发送到服务器中，当收到来自服务器的游戏状态更新的时候再将结果渲染出来。单纯地依赖这种模型会导致玩家输入命令和画面更新之间的延迟感，比如，当玩家按下向右的按钮，然后玩家等了半秒钟才开始移动，因为首先客户端需要把输入传给服务器，然后服务器处理了出入之后计算出新的游戏状态，然后再将新的游戏状态传回给客户端。在实际的网络环境中，延迟可能会达到零点几秒，这时游戏就有点感觉延迟了，最坏的情况是直接没法玩了。在这篇文章中，我们将找到减小这种延迟感的方法，甚至能够消除这种延迟。","titles":[]},"67":{"title":"PART 2 客户端预测","content":"虽然存在着作弊的玩家，但是大部分时候服务器是处理有效访问的（来自非作弊玩家的），这也意味着服务器收到大部分的输入都是有效的，而且游戏状态的更新也是按照预期的，也即是说：如果你的角色在（10，10），然后方向键右被按下了，那么你的角色就会移动到（11，10）。我们可以利用这一点，如果游戏世界的确定性足够（给定一个游戏状态和一些列的输入，得到的结果是完全可预测的）。现在假设有100ms的延迟，角色移动一格需要花费100ms，使用之前说的实现方式，那么整个动作完成需要花费200ms:因为游戏世界是确定的，我们假设传送到服务器的输入都能够成功执行。在这种假设下，客户端能够预测游戏世界在接受输入后的状态，并且绝大部分情况下，结果是正确的。与之前说的将客户端的输入发送到客户端然后等待服务器的响应再在客户端做出反应，我们可以将两者同时进行，即当在发送输入信息的时候，就当作它们已经正确执行，通常服务器返回的结果和客户端的执行的结果是一致的:现在玩家输入和运行结果之间就没有任何延迟存在了，同时服务器还是权威服务器。（如果有作弊的客户端发送无用的消息，他可以把角色放在他想要的任何地方，但这并不会影响到服务器，也就是其他玩家也不会受到他的影响）。","titles":[]},"68":{"title":"PART 3 同步问题","content":"在上面的例子里，我选用了一些比较特例的数字来让所有事情看起都很完美，现在假设另一种情况，假设现在服务器延时250ms，移动一格花费100ms，现在玩家按了两下方向键右，想要往右移动两格。使用之前我们说的技术，情况如下图所示于是我们在   t = 250 ms  的时候就会面临一个非常 interesting 的问题，当接收到新的游戏状态时，客户端预测的位置已经到达   x = 12 ，但是服务器认为最新的坐标是   x = 11 ，因为权威服务器的缘故，客户端必须将角色移回   x = 11 ，但是紧接着，新的   x = 12  的状态在   t = 350  的时间到达，因此角色的位置又顺移回去了。。从玩家的角度来看，他按下两次向右按钮后，角色向右移动两格，原地停留50ms后，向左顺移一格，又原地停留100ms再向右顺移一格，很明显这种情况令人难以接受。","titles":[]},"69":{"title":"PART 4 服务器校对","content":"解决上面说的问题的办法就是你得意识到，客户端所看到的世界是当前的，但是因为延迟，客户端得到的游戏状态都是过去的，当服务器在发送更新的时候，它并没有把客户端发来的所有的命令都处理掉。这并不是一个非常严重的问题，首先，客户端在每次请求的时候加上一个编号，在我们的例子中，第一次按键请求编号为 #1，第二次按键的请求编号为 #2。服务器回复的时候将其处理过最后一个请求的编号包含在消息中。当t = 250的时候，服务器说“基于#1的输入请求，你的位置是11”.因为服务器是权威的，所以角色的位置是x=11， 现在假设客户端保存了一份发送到服务器的请求，基于新的游戏状态，它知道服务器已经处理了请求 #1，所以他将这个备份丢弃掉，但是客户端知道服务器还需要将#2请求的回复发过来，所以再一次进行客户端预测，客户端可以基于上次服务器发来的状态和#2输入来计算当前的状态。所以当t=250ms的时候，客户端得到“经过#1的输入之后，x=11”，它将#1输入的拷贝丢弃掉，但是还有一份并没有得到服务器返回的#2的拷贝，客户端将内部游戏状态更新为服务器所发来的游戏状态，也就是x=11，然后将所有未收到回复但已经发送给服务器的输入用于预测，在上面的例子，输入就是向右移动，最终状态就是x=12，这是正确的。当t=350的时候，一个新的游戏状态从服务器获得；这种情况它说“基于#2输入，x=12”。在这是，客户端将#2请求之前的请求都丢弃，然后将游戏状态更新为x=12，没有需要预测的输入，所以不需要预测，现在得到的结果都是正确的。客户端具体如何处理，这里有一个统一的处理方式：根据server的new state更新#1里的缓存状态  回滚input到#1，将#1之后的所有缓存的操作都应用到#1的new state中进行计算，得到最新的结果  客户端根据最新的结果进行更新  将#1的状态和input 从缓存buffer里删除","titles":[]},"70":{"title":"PART 5 误差","content":"上面讨论的例子里只讨论了移动，但是这个方法在其他方面也可以使用。比如，在一个回合制的游戏里，当玩家攻击其他玩家的时候，你可以播放飙血的特效和伤害值，但是你不应该在收到服务器回复之前直接更新玩家的血量。因为游戏状态的复杂性，它并不能保证是绝对可逆的，你也许希望只有再收到服务器确认的时候才将一个玩家杀死，即使这个玩家的血量降到负的了。（但假象一种情况，一个玩家实际上已经死了，但是在没有收到服务器确认之前他使用了药包，这个时候你该怎么处理？）这又带来了一个有趣的问题，即使世界是绝对的确定的，并且没有玩家在作弊，还是有客户端的预测和服务器不吻合的情况。上面说的情况在单人游戏中不会出现，但是在多人接入同一个服务器的时候就会发生，这个问题会在下面的文章中进行讨论。","titles":[]},"71":{"title":"PART 6 总结","content":"当使用权威服务器的时候，你需要给玩家即时的响应，即使是当在等待服务器处理出入。为了达到这样的目的，客户端模拟出输入的结果，当收到服务器的回复时，客户端的游戏状态需要通过服务器的回复和还未处理的输入进行重新计算。http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html","titles":[]},"72":{"title":"PART 1 概述","content":"在本系列的「第一篇文章」中，我们介绍了关于权威服务器及其反作弊特性，然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题。在「第二篇文章」中，我们提出了「客户端预测」的方案来克服这个困难。以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下，可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术。在本文中，我们将会讨论在在同一台服务器上有「其他玩家控制的角色」的情况。","titles":[]},"73":{"title":"PART 2 服务器 time step","content":"在之前的文章中，我们的服务器的实现非常简单，它负责处理客户端的输入并更新游戏状态，最后将结果发送回客户端。如果有多个玩家在一起玩，那服务端主循环的逻辑有所不同了。\n在接下来的场景中，几个客户端玩家会同时发送数据，玩家发出操作指令会非常频繁（高APM的玩家，一秒钟可能发出10个以上的操作指令），如果服务端每收到某个玩家的一条指令，就去执行input逻辑，然后广播游戏状态，这样的性能是非常差的，会消耗很多的cpu和bandwidth。\n一个更好的办法是，利用一个queue，将客户端的输入信息缓存起来，在服务端，游戏状态以一定的频率(例如100ms一次)进行更新，每次更新的时间间隔(100ms)，就被称之为time step。\n在每个更新循环迭代中，服务端处理queue里面所有的input，然后逐个进行计算，将最后计算的结果更新到所有客户端。\n总体来说，整个游戏世界的更新和客户端的输入频率、数量是相对独立的，它的更新频率也是可控的。","titles":[]},"74":{"title":"PART 3 低频更新处理","content":"从客户端来看，这个方法运行的很平滑，客户端的预测行为独立于服务端的更新，所以它依然可以使用预测技术。不过，由于真个游戏世界的状态以一个比较低的频率进行更新，那么本地客户端对其他玩家知道的信息就很少了，信息越少的话，其他玩家的行为动作要模拟的话，就不会很准确。\n本地客户端收到其他玩家更新坐标的消息，如何进行处理呢，有一个最简单的办法就是，每次直接使用收到的坐标进行更新，但这样看起来会有抖动，每100ms更新一次坐标，就得抖动一次，如下图所示：对Client2来说，Client1的位置最开始再p(10,10)，不一会直接跳到p(11,10)，100ms后又跳到(12,0)，这样的体验是很差的。那么，如何改善游戏体验呢？ 针对不同的游戏，有不同的处理方式，一般来说，客户端的行为越方便预测，就越容易做平滑处理。","titles":[]},"75":{"title":"PART 4 航位推测法","content":"假设你在玩赛车游戏。一辆速度非常快的汽车是可以预测的——例如，如果它以每秒100米的速度行驶，一秒钟后，它将比它开始行驶的地方提前大约100米。为什么是大约呢？在那一秒内，汽车可能加速或减速了一点，或者向右或向左转了一点——这里的关键词是“一点”。汽车的机动性是这样的：在高速行驶时，无论玩家实际做什么，其在任何时间点的位置都高度依赖于其先前的位置、速度和方向。换句话说，赛车不能立即进行180度转弯。对于每100毫秒发送一次更新的服务器，这是如何工作的？客户端接收到服务器发送来的每个其他车的速度和行驶方向；在接下来的100毫秒内，它不会接收到任何新信息，但仍需要显示它们的运行情况。要做的最简单的事情是假设汽车的航向和加速度在100毫秒内保持不变，并使用该参数在本地运行汽车物理。然后，100毫秒后，当服务器更新到达时，汽车的位置被修正。根据许多因素，校正可以是大的或相对小的。如果玩家把车保持在直线上，并且不改变车速，那么预测的位置将与修正的位置完全相同。另一方面，如果玩家撞到什么东西，预测的位置将是非常错误的。请注意，推算定位可以应用于低速情况，例如战列舰。实际上，“dead reckoning”一词起源于航海。","titles":[]},"76":{"title":"PART 5 实体插值","content":"有许多情况航位推是没法处理的 - 对于玩家的方向和速度可以瞬间改变的都不行，比如3D射击，玩家经常快速跑动，停下，快速转向等，在这种情况下，航位推算法就非常无力了。因为位置和速度和前面的数据无关。你可以选择在接到服务器的请求的时候直接更新玩家的位置，而客户端看到的就是网上其他的玩家每100ms跳一下，感觉会非常奇怪。你现在拥有的是每100ms由服务器传送过来的权威数据，现在要做的是如何在这100ms内让网络角色看起来非常自然，解决问题的关键就是将网络玩家显示在过去的某个时刻。假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。用来插值的t=900和t=1000的数据依赖于游戏。插值通常都可以处理得很好。如果不是这种方法，你可能需要服务器发送更加详细的移动信息了 - 比如更多的位置采样点，或者每10ms发送一次(你不必发十倍的数据 - 因为你发的微小的位移数据，在这种情况下数据的格式可以很好的优化一下)。当使用这种技术的时候，每一个玩家都和游戏世界有一点点不同步，因为每个玩家看到自己的世界是当前的，但是其他的玩家都是过去的。但即使是快速的游戏，这100ms的延迟都不是那么明显。有一种情况除外 - 当你需要时间和空间的准确性的时候，比如一个玩家射击另一个玩家的时候，因为其他的玩家都是存在于过去的某个时候，你的瞄准其实是有100ms的延迟的 - 也就是说，你设计的目标是100ms的某个目标！ 这个问题我们下一篇会进行讨论。","titles":[]},"77":{"title":"PART 6 总结","content":"在权威服务器的环境中，有着不确定的服务器更新和网络延迟，在这种情况下你还要给玩家平滑的移动。在第二篇中，我们展示了一种客户端预测和服务器调和的技术，来实现实时的角色控制，这样的方案让玩家能够得到即时的反馈，移除了致命的延迟。其他玩家的同步还是一个问题，但是，在这篇文章中，我们提出了两种解决方案。第一种是航位推技术，这种模拟需要entity的位置能够通过前一个时候的位置，速度，加速度来推算出来，当不满足这种情况的时候，航位推就没用了。第二种是插值技术，不预测将来的位置，只是使用服务器传来的数据，这种就会造成显示的entity总是过去的某个时刻。最后的结果就是玩家的角色总是当前时刻，而其他看到的entity都是过去的某个时刻，这种情况可以产生一种难以置信的无缝体验。但是，当游戏需要高速离散的准确性的时候，比如射击或者移动物体，美景就破灭了：你看其他玩家的位置和服务器的位置不一致，别的玩家看你的位置也不是正确的，这样爆头就不可能发生了！很多游戏都有爆头这一说，我们将在下面的文章中来讨论这个问题。http://www.gabrielgambetta.com/entity-interpolation.html","titles":[]},"78":{"title":"PART 1 概述","content":"之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些：服务器从客户端收到带有时间戳的输入信息；  服务器处理输入并且更新世界状态；  服务器向所有客户端发送游戏世界的快照  客户端发送输入并且模拟游戏的结果；  客户端获取世界更新   将自身预测的状态和服务器发送来的状态进行同步；  将其他客户端控制的实体插值到过去的状态从玩家的角度来看，以上行为会导致两个重要的结果：玩家看到   自己  处于   现在  玩家看到   其他玩家  处于   过去这其实并没有什么大不了的问题，但是对于时间和空间非常敏感的事件就会造成很大的问题；比如在射击游戏中爆掉敌人的头！","titles":[]},"79":{"title":"PART 2 延时补偿","content":"假设你正用狙击枪完美的瞄准目标的头部，此时射击绝对万无一失。然而却没打到。。。为什么会发生这种事情。。因为我们之前解释过的 client-server 架构，你瞄准的是 100ms 之前的玩家的头，而不是开枪的时候的玩家的头。。。在某种程度上相当于你在一个光速非常非常慢的宇宙中进行游戏，你瞄准的是敌人过去的位置，当你扣下扳机的时候他早就走远了。。比较幸运的是有一个相对简单的解决方案，对几乎所有的玩家都是友好的，下面来解释一下它的工作流程：开火的时候，客户端发送开火指令到服务器，同时包含开火的一瞬间确切的时间和方向。  这是关键的一步。由于服务器获取所有带有时间戳的输入，因此它可以在过去的任何时刻重构世界。特别是，它可以在任何时间点按照任何客户端眼中的样子重建世界。  这意味着服务器可以准确地知道你开枪的那一刻你的武器瞄准了什么。这是你的敌人过去的头部位置，但服务器知道这是他的头部在你当前客户端所在的位置。  服务器在该时间点处理快照，并更新客户端。于是皆大欢喜～服务器很开心是因为他是服务器，他永远都很开心。。。哦好冷啊你很开心是因为你瞄准目标头部并射击，完成了一记漂亮的爆头你的敌人可能是唯一不完全开心的哪个，如果他站在原地被你爆头那就是他的问题，但是如果他在移动的话，只能说明你是特别厉害的狙击手。但是如果他在掩体附近，然后移动到掩体内部的安全位置后才被命中了呢？好吧这的确有可能发生，但这就是你要为此付出的代价，因为你可以射击「过去的他」，他可能在进入掩体后几毫秒被射击。从某种程度上来说这是不公平的，但这是大家接受程度最高的解决方案了，明明瞄准开枪最后却 miss 问题更大～","titles":[]},"80":{"title":"PART 3 总结","content":"这篇文章是快节奏多人游戏同步这个系列的最后一篇了，虽然这类问题很难得到完美解答，但是对相关概念有了清晰理解以后再看也并不是那么困难。虽然本文的读者都是游戏开发者，但依然有着另一部分读者对此很感兴趣，那就是玩家们。对玩家来说去理解诸如此类问题依然是一件很有趣的事情。","titles":[]},"81":{"title":"扩展阅读","content":"以下是一些参考资料包括文章和源码之类的，可以帮助大家更方便的理解相关概念。与本文相关性最高的文章如下http://www.gabrielgambetta.com/lag-compensation.htmlhttp://www.gabrielgambetta.com/client-side-prediction-live-demo.htmlWhat Every Programmer Needs to Know About Game NetworkingLatency Compensating Methods in Client/Server In-game Protocol Design and Optimization .https://link.springer.com/article/10.1007/s00530-012-0271-3#Sec17https://github.com/search?l=C%23&q=lag+compensation&type=Repositorieshttps://github.com/search?l=C%23&p=1&q=Fast-Paced+Multiplayer&type=Repositorieshttps://github.com/JoaoBorks/unity-fastpacedmultiplayerhttps://github.com/gamestdio/timeline","titles":["PART 3 总结"]},"82":{"title":"基本网络模型","content":"服务器以一个固定的时间间隔更新模拟游戏世界。默认情况下，时间步长为15ms，以66.66次每秒的频率更新模拟游戏世界，但不同游戏可以指定更新频率。在每个更新周期内服务器处理传入的用户命令，运行物理模拟步，检查游戏规则，并更新所有的对象状态。每一次模拟更新tick之后服务器会决定是否更新当前时间快照以及每个客户端当前是否需更新。较高的tickrate增加了模拟精度，需要服务器和客户端都有更多可用的CPU和带宽资源。客户通常只能提供有限的带宽。在最坏的情况下，玩家的调制解调器连接不能获得超过5-7KB /秒的流量。如果服务器的数据更新发送频率超过了客户端的带宽处理限制，丢包是不可避免的。因此客户端可以通过在控制台设置接受带宽限制，以告诉服务器其收到的带宽容量。这是客户最重要的网络参数，想要获得最佳的游戏体验的话必须正确的设置此参数。客户端可以通过设置cl_updaterate（默认20）来改变获得快照平的频率，但服务器永远不会发送比tickerate更多的更新或超过请求的客户端带宽限制。服务器管理员可以通过sv_minrate和sv_maxrate(byte/s)限制客户端的上行请求频率。当然快照更新同步频率都受到sv_minupdaterate和sv_maxupdaterate（快照/秒）的限制。客户端使用与服务端tickrate一样的频率采样操作输入创建用户命令。用户命令基本上是当前的键盘和鼠标状态的快照。客户端不会把每个用户命令都立即发送到服务器而是以每秒（通常是30）的速率发送命令包。这意味着两个或更多个用户的命令在同一包内传输。客户可以增加与的cl_cmdrate命令速率。这可以提高响应速度，但需要更多的出口带宽。游戏数据使用增量更新压缩来减少网络传输。服务器不会每次都发送一个完整的世界快照，而只会更新自上次确认更新(通过ACK确认)之后所发生的变化（增量快照)。客户端和服务器之间发送的每个包都会带有ACK序列号来跟踪网络数据流。当游戏开始时或客户端在发生非常严重的数据包丢失时, 客户可以要求全额快照同步。用户操作的响应速度(操作到游戏世界中的可视反馈之间的时间)是由很多因素决定的，包括服务器/客户端的CPU负载，更新频率，网络速率和快照更新设置，但主要是由网络包的传输时间确定。从客户端发送命令到服务器响应, 再到客户端接收此命令对应的服务器响应被称为延迟或ping（或RTT）。低延迟在玩多人在线游戏时有显著的优势。客户端本地预测和服务器的延迟补偿技术可以尽量为网络较差的游戏玩家提供相对公平的体验。如果有良好的带宽和CPU可用，可以通过调整网络设置以获得更好的体验, 反之我们建议保持默认设置，因为不正确的更改可能导致负面影响大于实际效益。","titles":[]},"83":{"title":"Enitiy插值平滑","content":"通常情况下客户端接收每秒约20个快照更新。如果世界中的对象（实体）直接由服务器同步的位置呈现，物体移动和动画会看起来很诡异。网络通信的丢包也将导致明显的毛刺。解决这个问题的关键是要延迟渲染，玩家位置和动画可以在两个最近收到快照之间的连续插值。以每秒20快照为例，一个新的快照更新到达时大约每50毫秒。如果客户端渲染延迟50毫秒，客户端收到一个快照，并在此之前的快照之间内插(Source默认为100毫秒的插补周期)；这样一来，即使一个快照丢失，总是可以在两个有效快照之间进行平滑插值。如下图显示传入世界快照的到达时间：在客户端接收到的最后一个快照是在tick 344或10.30秒。客户的时间将继续在此快照的基础上基于客户端的帧率增加。下一个视图帧渲染时间是当前客户端的时间10.32减去0.1秒的画面插值延迟10.20。在我们的例子下一个渲染帧的时间是10.22和所有实体及其动画都可以基于快照340和342做正确的插值处理。既然我们有一个100毫秒的延迟插值，如果快照342由于丢包缺失，插值可以使用快照340和344来进行平滑处理。如果连续多个快照丢失，插值处理可能表现不会很好，因为插值是基于缓冲区的历史快照进行的。在这种情况下，渲染器会使用外推法（cl_extrapolate 1），并尝试基于其已知的历史，为实体做一个基于目前为止的一个简单线性外推。外推只会快照更新包连续丢失（cl_extrapolate_amount）0.25秒才会触发，因为该预测之后误差将变得太大。实体内会插导致100毫秒默认（cl_interp 0.1）的恒定视图“滞后”，就算你在listenserver（服务器和客户端在同一台机器上）上玩游戏。这并不是说你必须提前预判动画去瞄准射击，因为服务器端的滞后补偿知道客户端实体插值并纠正这个误差。最近Source引擎的游戏有cl_interp_ratioCVaR的。有了这个，你可以轻松，安全地通过设置cl_interp为0，那么增加的cl_updaterate的值（这同时也会受限于服务器tickrate）来减少插补周期。你可以用net_graph 1检查您的最终线性插值。如果打开sv_showhitboxes，你会看到在服务器时间绘制的玩家包围盒，这意味着他们在前进的线性插值时期所呈现的播放器模式。","titles":[]},"84":{"title":"输入预测","content":"让我们假设一个玩家有150毫秒的网络延迟，并开始前进。前进键被按下的信息被存储在用户命令，并发送至服务器。用户命令是由移动代码逻辑处理，玩家的角色将在游戏世界中向前行走。这个世界状态的变化传送到所有客户端的下一个快照的更新。因此玩家看到自己开始行动的响应会有150毫秒延迟，这种延迟对于高频动作游戏(体育，设计类游戏)会有明显的延迟感。玩家输入和相应的视觉反馈之间的延迟会产生一种奇怪的，不自然的感觉，使得玩家很难移动或精确瞄准。客户端的输入预测（cl_predict 1）执行是一种消除这种延迟的方法，让玩家的行动感到更即时。与其等待服务器来更新自己的位置，在本地客户端只是预测自己的用户命令的结果。因此，客户端准确运行相同的代码和规则服务器将使用来处理用户命令。预测完成后，当地的玩家会移动到新位置，而服务器仍然可以看到他在老地方。150毫秒后，客户会收到包含基于他早期预测用户命令更改服务器的快照。客户端会将预测位置同服务器的位置对比。如果它们是不同的，则发生了预测误差。这表明，在客户端没有关于其他实体的正确信息和环境时，它处理用户命令。然后，客户端必须纠正自己的位置，因为服务器拥有客户端预测最终决定权。如果cl_showerror 1开启，客户端可以看到，当预测误差发生。预测误差校正可以是相当明显的，并且可能导致客户端的视图不规则跳动。通过在一定时间（cl_smoothtime）逐渐纠正这个错误，错误可以顺利解决。预测误差平滑处理可以通过设置cl_smooth 0来关闭。预测只对本地玩家以及那些只收它影响的实体有效，因为预测的工作原理是使用客户端的操作来预测的。对于其他玩家没法做有效预测, 因为没有办法立即从他们身上得到操作信息。","titles":[]},"85":{"title":"延迟补偿","content":"​    比方说，一个玩家在10.5s的时刻射击了一个目标。射击信息被打包到用户命令，该命令通过网络的方式发送至服务器。服务器持续模拟游戏世界，目标可能已经移动到一个不同的位置。用户命令到达服务器时间10.6时服务器就无法检测到射击命中，即使玩家已经在目标准确瞄准。这个错误需要由服务器侧进行延迟补偿校正。延迟补偿系统使所有玩家最近位置的历史一秒。如果在执行用户的命令，服务器预计在命令创建什么时间如下：命令执行时间=当前服务器时间 - 数据包延迟 - 客户端查看插值然后服务器会将所有其他玩家回溯到命令执行时的位置，他们在命令执行时间。用户指令被执行，并正确地检测命中。用户命令处理完成后，玩家将会恢复到原来的位置。由于实体插值包含在公式中，可能会导致意外的结果。服务器端可以启用sv_showimpacts 1，显示服务器和客户端射击包围盒位置差异：该画面在主机上设置延迟200毫秒(net_fakelag设置)时获取的，射击真实命中玩家。红色命中包围盒显示了客户端那里是100毫秒+插补周期前的目标位置。此后，目标继续向左移动，而用户命令被行进到服务器。用户命令到达后，服务器恢复基于所述估计的命令执行时间目标位置（蓝色击中盒）。服务器回溯演绎，并确认命中（客户端看到流血效果）。因为在时间测量精度的误差客户端和服务器命中包围盒不完全匹配。对于快速移动的物体甚至几毫秒的误差也会导致几英寸的误差。多人游戏击中检测不是基于像素的完美匹配，此外基于tickrate模拟的运动物体的速度也有精度的限制。既然击中检测服务器上的逻辑如此复杂为什么不把命中检查放在客户端呢？如果在客户端进行命中检查, 玩家位置和像素命中处理检测都可以精准的进行。客户端将只告诉服务器用“打”的消息一直打到什么样的玩家。因为游戏服务器不能信任客户端这种重要决定。因为即使客户端是“干净”的，并通过了Valve反作弊保护，但是报文可以被截获修改然后发送到游戏服务器。这些“作弊代理”可以注入“打”的消息到网络数据包而不被VAC被检测。网络延迟和滞后补偿可能会引起真实的世界不可能的逻辑。例如，您可能被你看不到的目标所击中。服务器移到你的命中包围盒时光倒流，你仍然暴露给了攻击者。这种不一致问题不能通过一般化的防范解决，因为相对网络包传输的速度。在现实世界中，因为光传播如此之快，你，每个人都在你身边看到同一个世界，所以你才你没有注意到这个问题。","titles":[]},"86":{"title":"网络视图NET_Graph","content":"Source引擎提供了一些工具来检查您的客户端连接速度和质量。使用net_graph 2可以启用相关的视图。下面的曲线图中，第一行显示每秒当前的渲染的帧，您的平均延迟时间，以及的cl_updaterate的当前值。第二行显示在最后进来的数据包（快照），平均传入带宽和每秒接收的数据包的字节大小。第三行显示刚刚传出的数据包（用户命令）相同的数据。默认的网络设置是专门为通过互联网连接的游戏服务器设计的。可以适用大多数客户机/服务器的硬件和网络配置工作。对于网络游戏，应该在客户端上进行调整，唯一的控制台变量是“rate”，它定义客户端可用的字节/网络连接带宽。在一个良好的网络环境中，服务器和所有客户端都具有必要的硬件资源可用，可以调整带宽和更新频率设置，来获得更多的游戏精度。增加tickrate通常可以提高运动和射击精度，但会消耗更多的服务器CPU资源。tickrate 100运行的服务器的负载大概是tickrate 66运行时的约1.5倍, 因此如果CPU性能不足可能会导致严重的计算滞后，尤其是在玩家数量比较多的时候。建议对具有更高tickrate超的游戏服务器预留必要的CPU资源。如果游戏服务器使用较高tickrate运行时，客户端可以在带宽可用的情况下增加他们的快照更新率（的cl_updaterate）和用户命令速率（的cl_cmdrate）。快照更新速率由服务器tickrate限制，一台服务器无法发送每个时钟周期的一个以上的更新。因此，对于一个tickrate66服务器，为的cl_updaterate最高的客户价值，将是66。如果你增加快照率遇到，你必须再次打开它。与增加的cl_updaterate你也可以降低画面插值延迟（cl_interp）。默认的插值延迟为0.1秒(默认的cl_updaterate为20) 视图内插延迟会导致移动的玩家会比静止不动的玩家更早发现对方。这种效果是不可避免的，但可以通过减小视图内插值延迟来减小。如果双方玩家正在移动，画面滞后会延迟影响双方玩家,双方玩家都不能获利。快照速率和视图延迟插值之间的关系如下：插补周期= MAX(cl_interp，cl_interp_ratio /cl_updaterate)可以设置cl_interp为0，仍然有插值的安全量。也可以把cl_updaterate增加，进一步降低你的插补周期，但不会超过更新tickrate(66)或客户端的网络处理能力。","titles":[]},"87":{"title":"Tips","content":"不要瞎改终端配置除非你完全确定你在干嘛​    如果客户端和服务器没有足够CPU和网络资源，绝大多数所所谓高性能优化都是起负面作用不要关闭画面插值和延迟补偿​    这样并不能代理移动和设计精准度提升优化设置可能不会对每个客户端都有效如果是你是在游戏里或者SourceTv里第一视角观看你看到的画面和玩家可能不一样观战者的画面没有延迟补偿https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking","titles":[]},"88":{"title":"蓝绿部署（Blue/Green Deployment）","content":"过去的 10 年里，很多公司都在使用蓝绿部署（发布）来实现热部署，这种部署方式具有安全、可靠的特点。蓝绿部署虽然算不上“ Sliver Bullet”，但确实很实用。\n蓝绿部署是最常见的一种0 downtime部署的方式，是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。蓝绿部署原理上很简单，就是通过冗余来解决问题。通常生产环境需要两组配置（蓝绿配置），一组是active的生产环境的配置（绿配置），一组是inactive的配置（蓝绿配置）。用户访问的时候，只会让用户访问active的服务器集群。在绿色环境（active）运行当前生产环境中的应用，也就是旧版本应用version1。当你想要升级到version2 ，在蓝色环境（inactive）中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。随后需要监测新版本应用，也就是version2 是否有故障和异常。如果运行良好，就可以删除version1 使用的资源。如果运行出现了问题，可以通过负载均衡器指向快速回滚到绿色环境。\n蓝绿部署的优点：\n这种方式的好处在你可以始终很放心的去部署inactive环境，如果出错并不影响生产环境的服务，如果切换后出现问题，也可以在非常短的时间内把再做一次切换，就完成了回滚。而且同时在线的只有一个版本。蓝绿部署无需停机，并且风险较小。\n(1) 部署版本1的应用（一开始的状态），所有外部请求的流量都打到这个版本上。\n(2) 部署版本2的应用，版本2的代码与版本1不同(新功能、Bug修复等)。\n(3) 将流量从版本1切换到版本2。\n(4) 如版本2测试正常，就删除版本1正在使用的资源（例如实例），从此正式用版本2。\n从过程不难发现，在部署的过程中，应用始终在线。并且，新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响。这样风险很小，并且，只要老版本的资源不被删除，理论上，可以在任何时间回滚到老版本。\n蓝绿部署的弱点：\n使用蓝绿部署需要注意的一些细节包括：\n1、当切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果数据库后端无法处理，会是一个比较麻烦的问题。\n2、有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止；\n3、需要提前考虑数据库与应用部署同步迁移/回滚的问题。\n4、蓝绿部署需要有基础设施支持。\n5、在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。\n6、另外，这种方式不好的地方还在于冗余产生的额外维护、配置的成本，以及服务器本身运行的开销。\n蓝绿部署适用的场景：\n1、不停止老版本，额外搞一套新版本，等测试发现新版本OK后，删除老版本。\n2、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。\n3、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。","titles":[]},"89":{"title":"滚动发布（rolling update）","content":"滚动发布，一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。\n这种方式也有很多缺点，例如：\n(1) 没有一个确定OK的环境。使用蓝绿部署，我们能够清晰地知道老版本是OK的，而使用滚动发布，我们无法确定。\n(2) 修改了现有的环境。\n(3) 如果需要回滚，很困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚。此时，脾气不好的程序猿很可能想掀桌子，因为回滚是一个痛苦，并且漫长的过程。\n(4) 有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容/缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。\n并不是说滚动发布不好，滚动发布也有它非常合适的场景。","titles":[]},"90":{"title":"orleans支持   蓝绿部署模型 以及  滚动部署模型","content":"ClusterId：这是Orleans集群的唯一ID。使用此ID的所有客户端和Silo将能够直接相互通信。但是，您可以选择ClusterId对不同的部署使用不同的名称。  ServiceId：这是您的应用程序的唯一ID，将由某些提供程序（例如持久性提供程序）使用。此ID应该保持稳定，并且在整个部署中都不应更改。Orleans has both    &    to support the   blue/green deployment model .In this model, each deployment slot will have a distinct    (eg, the values could be \"blue-slot\" & \"green-slot\") but they will always have the same    (eg, \"my-service\"). The \"blue-slot\" silos will only talk to other \"blue-slot\" silos.However    Grain A  in the blue cluster and   Grain A  in the green cluster will still share the same storage - if they are both active then one will see a conflict when writing to the state if the other activation has already written it.This allows for the state in the database to remain consistent when multiple clusters are active (which is usually a short period of time - during the upgrade).If you do not use blue/green deployments then you can set    &    to the same value.To say this in a different way:+    are used for cluster membership    is used for storagehttps://github.com/dotnet/orleans/issues/5696#issuecomment-503595998","titles":[]},"91":{"title":"应用场景","content":"和随着业务的扩展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常使用的数据，我们可以使用Redis作为缓存机制，减少数据层的压力。因此，重构后的系统架构如下图所示：优化最简单的策略就是，把常用的数据保存到Redis中，为了实现高可用使用了3台Redis（没有设置集群，集群至少要6台）。每次Redis请求会随机发送到其中一台，但是这种策略会引发如下两个问题：同一份数据可能在多个Redis数据库，造成数据冗余  某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中要解决上述的问题，我们需要稍稍改变一些key存入Redis的规则：  使用hash算法 \n例如，有三台Redis，对于每次的访问都可以通过计算hash来求得hash值。\n如公式 h=hash(key)%3，我们把Redis编号设置成0,1,2来保存对应hash计算出来的值，h的值等于Redis对应的编号。\n但是hash算法也会面临容错性和扩展性的问题。容错性是指当系统中的某个服务出现问题时，不能影响其他系统。扩展性是指当加入新的服务器后，整个系统能正确高效运行。现假设有一台Redis服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个key就要按h = Hash(key) % 2重新计算。同样，如果新增一台服务器，规则也同样需要重新计算，h = Hash(key) % 4。因此，系统中如果有服务器更变，会直接影响到Hash值，大量的key会重定向到其他服务器中，造成缓存命中率降低，而这种情况在分布式系统中是十分糟糕的。一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的变更不会造成大量的哈希重定位。一致性哈希算法由此而生~","titles":[]},"92":{"title":"2 一致性哈希算法","content":"一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。简单的说，一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环如下：整个空间按顺时针方向组织，0和2^32-1在零点中方向重合。接下来，把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。\n  \n然后，我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性哈希算法，数据A会被定为到Server 1上，数据B被定为到Server 2上，而C、D被定为到Server 3上。","titles":["应用场景"]},"93":{"title":"3 容错性和扩展性","content":"那么使用一致性哈希算法的容错性和扩展性如何呢？","titles":["应用场景"]},"94":{"title":"3.1 容错性","content":"假如RedisService2宕机了，那么会怎样呢？那么，数据B对应的节点保存到RedisService3中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。","titles":["应用场景","3 容错性和扩展性"]},"95":{"title":"3.2 扩展性","content":"下面考虑另一种情况，假如增加一台服务器Redis4，具体位置如下图所示：原本数据C是保存到Redis3中，但由于增加了Redis4，数据C被保存到Redis4中。干扰的也只有Redis3而已，其他数据不会受到影响。因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性","titles":["应用场景","3 容错性和扩展性"]},"96":{"title":"4 虚拟节点","content":"前面部分都是讲述到Redis节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。例如，我们的的系统有两台Redis，分布的环位置如下图所示：这会产生一种情况，Redis4的hash范围比Redis3的hash范围大，导致数据大部分都存储在Redis4中，数据存储不平衡。为了解决这种数据存储不平衡的问题，一致性哈希算法引入了  虚拟节点机制 ，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点  称为虚拟节点 。具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、 RedisService1#2、 RedisService1#3、 RedisService2#1、 RedisService2#2、 RedisService2#3，具体位置如下图所示：对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为  32甚至更大 ，因此即使  很少的服务节点 也能做到相对  均匀的数据分布 。https://github.com/tg123/ConsistentSharp   https://en.wikipedia.org/wiki/Consistent_hashing","titles":["应用场景"]},"97":{"title":"为什么要进行视野管理？","content":"1.如果不进行视野管理，流量上来看，假设平均每秒5个移动包（80字节），1个技能包（160字节），单人每秒多少？500kb。2.客户端表现来看，客户端受屏幕大小影响，离得远的玩家看不见，没有必要发给客户端。客户端性能所限，玩家多，放各种 技能，当然会看。3.从性能上考虑，服务端不用遍历全场景对象…也会大大减少性能消耗。","titles":[]},"98":{"title":"格子","content":"","titles":[]},"99":{"title":"Land","content":"IncServer将每个场景看做是由n个land（块）组成，每个land就是一个大小固定的正方形，默认512 * 512。比如一个scene的尺寸为1200 * 700：则需要6个land来表示:","titles":["格子"]},"100":{"title":"Patch","content":"Land进一步被划分为若干个Patch（格子）。以patch为单位，land的边长是2的整数次幂。","titles":["格子"]},"101":{"title":"分块管理","content":"World对游戏对象的管理以patch为单位，  每个patch都对应有一个对象链表 。整个world中所有的对象链表的链表头可依次存储于一个一维数组中，这样根据对象的世界坐标，即可方便的计算出其所属的patch以及对应的对象链表。假设对象的坐标为(x, z)，patch的边长为patch_size，land的边长为land_size，整个场景在x方向上有land_x个land，则对象所属的对象链表的索引计算方式为：","titles":["格子"]},"102":{"title":"IncServer的AOI","content":"与常见的九宫格不同，IncServer支持NEAR、MIDDLE、FAR、FULL四种视野范围：NEAR：当前对象所位于的patch  MIDDLE：与NEAR相邻的patch  FAR：与MID相邻的patch（NEAR除外）  FULL：NEAR + MIDDILE + FAR不过在实际开发中，所有对象的视野都是FULL，即每个对象都能看到以自己所在patch为中心前后左右各两个patch（总计25个patch）内的其他对象。之后的讨论均假设  所有游戏对象的视野范围均为FULL 。如果对象B进入对象A的视野范围，则根据A对象类型，可能会触发不同的逻辑，比如：对象A是玩家：将B对象  序列化 到对象A的客户端。  对象B是怪物：执行对象进入怪物视野的逻辑，比如激活AI等。后文将以上情况称之为在对象A的视野中加载对象B，简称为  视野加载 。","titles":["格子","分块管理"]},"103":{"title":"九宫格","content":"让我们首先绘制一个2D的地图我们给这个地图定义一些数值：场景相关数值计算场景大小： 250*250 ， w(x轴宽度) = 250，l(y轴长度) = 250  x轴格子数量：nx = 5  y轴格子数量：ny = 5  格子宽度: dx = w / nx = 250 / 5 = 50  格子长度: dy = l / ny = 250 / 5 = 50  格子的x轴坐标：idx  格子的y轴坐标：idy  格子编号：id = idy *nx + idx (利用格子坐标得到格子编号)  格子坐标：idx = id % nx , idy = id / nx (利用格子id得到格子坐标)  格子的x轴坐标: idx = id % nx (利用格子id得到x轴坐标编号)  格子的y轴坐标: idy = id / nx (利用格子id得到y轴坐标编号)以上几个数值，请参考图，简单过一下，就可以理解的，初中的几何计算而已。九宫格也是打格子的方式之一，把地图划分为很多小格子，每个格子记录格子内的玩家，每个玩家的aoi范围是以自己为中心范围内的九个格子，九个格子的大小略大于屏幕大小，同样的有三个主要的操作：enter,move,leaveenter:根据玩家坐标，加入到所属的格子中，通过计算以这个格子的为中心的九个格子，这九个格子内的玩家就要被通知有新玩家初始化，同时这个新玩家初始化九个格子内的所有玩家。move:根据移动前位置的格子，计算出移动前的oldaoi集合，根据当前位置的格子，计算出当前的curaoi集合，如果oldaoi, curaoi为同一个格子，则通知格子内的所有玩家该玩家在移动。如果oldaoi,curaoi不是同一个格子，即发生了跨格子的操作，那么要将该玩家从旧格子移除，同时加入新格子。同时分别遍历oldaoi,curaoi,计算出需要通知玩家消失的格子集合，通知玩家出生的格子集合，以及通知玩家移动的格子集合。leave:玩家离开地图，将玩家从对应的格子里面删除，同时通知aoi集合有玩家离开。服务器大格子的大小，以3*3的格子要总比客户端显示范围要大一点为原则。比客户端大一点，是为了预留资源加载的时间。\n　　如下图所示，绿色表示手机客户端的显示区域，当角色A在格子6中时，他可以看到1,2,3,5,6,7,9,10,11这9个格子里的内容，那么当他的状态发生变化时，就需要同步给在这9个格子里的所有玩家；同样，当这9个格子里的有玩家或者怪物的状态改变时，也需要都同步给角色A。当角色A移动到角色B所在的格子(7)，则他将不再看到1,5,9这三个格子里的内容，同时他将新看到4,8,12这三个格子里的地图内容（玩家和怪物）。所以这个过程中，服务器要下发消息，删除角色A所在的客户端里的1,5,9这三个格子里的地图内容，同时下发消息新增4,8,12这三个格子里的地图内容（类型一）。\n　　推荐大格子具体的大小，按客户端iPhone4S的960  640分辨来制定，取屏幕长宽的1/2大一些，可以定为640 360。https://github.com/artasccope/GameFW.AOI   https://www.bookstack.cn/read/zinx/78aa012966213643.md","titles":["格子","分块管理"]},"104":{"title":"灯塔法","content":"所谓灯塔法，即将大地图划分成有限的小格子，在每个小格子中间放一个灯塔，这个灯塔管理两个队列：一个是本格子内所有的对象集合，另一个是对本灯塔感兴趣的对象集合（简称观察者）。而地图上的每个对象，维护一个视野队列：该队列为其视野范围内的所有对象，即自身感兴趣的所有对象。一个对象在地图上面运动：分为三个操作：enter，move，leave.enter:当对象进入地图的时候，根据对象的当前位置和对象的感知距离，可以获取到该对象能观察到的所有灯塔，遍历这些灯塔，将该对象添加为其观察者。同时将这些对象添加到自己的视野队列中。move:当对象开始移动的时候，对象从一个点到另一个店，那么视野范围必然发生变化。此刻需要将对象从老的灯塔的观察者列表移除，同时将对象添加进新的灯塔的观察者列表。此外，还需要跟新玩家的视野队列，因为视野范围变化，视野内的对象也相应变化。leave:当对象离开的时候，将自身从附近灯塔的观察者队列中移除。通过灯塔法，每当物体发生变化，我们能马上根据其当前位置，定位到他的所在的灯塔，同时找到它视野范围内相关联的物体。这样避免了遍历地图上所有玩家进行处理的方式。当然灯塔的格子大小划分要因地制宜，格子越小，消耗内存越大，同时计算量变大。https://github.com/Bestpoker/AOI   https://github.com/NetEase/pomelo-aoi   https://github.com/ahuangege/tower-aoi前几天把pomelo中的tower aoi的js实现看了一遍，总结如下：js代码写得不是很好，发现了几个小问题；  “对象(包括观察者)出现”“对象(包括观察者)消失”“对象(包括观察者)位置变化”“观察者位置变化”的回调通知(前三者通知对应灯塔区域的观察者，第四个通知观察者本身)没有可测试的样例，采用的话需要自己实现和测试；  只考虑了起点和终点，移动路径上的玩家被忽视了，路径短的话也可能不是问题(长路径切分成多个短路径做位置更新)；  观察者可能收到超出自己视野范围的消息；  优点是可处理视野不同的观察者，相对于普通扫格子的实现在代码层面耦合度降低、效率提升不明显(把扫格子实现的地格看做一个灯塔区域，在地格上记录观察者就可以模拟这种灯塔模型，削去了遍历周边地格所有对象的逻辑)  这里做的是四边形灯塔区域，云风提的那种六边形灯塔区域减少查询灯塔个数是特指视野半径<=六边形边长的一半这种情况  tower aoi其实就是处理地图视野的一个设计，类似于订阅-发布，我订阅某一块区域表示对这一块区域感兴趣，那么有对象在这一块区域出现消失移动你就通知我","titles":["格子","分块管理"]},"105":{"title":"十字链表法","content":"这里以2d游戏为例，3d游戏顺势扩展即可。所谓十字链表法，即维护两天链表，一条根据地图上所有物体的x坐标从小到大依次插入链表，一条根据地图上所有物体的y坐标从小到大依次插入链表，可以想象成一个十字架。这样便把地图上的所有对象按序分配到了x,y链表上。这里的链表为双向链表，双向链表的好处是，获取到链表中的一个节点，便可以向前和向后遍历。这样，当我们拿到一个对象时，要获取该对象的视野范围就变得非常简单。避免了从头到尾遍历所有对象。首先根据x坐标，在x链表上找到该节点，然后从该节点向前和向后遍历，根据x方向的视野范围找出需要识别的对象。然后根据y坐标，在y链表上找到该节点，然后从该节点向前和向后遍历，根据y方向的视野范围找出需要识别的对象。拿到x,y链表上需要关注的对象，然后取他们的交集，这便是玩家视野范围内的对象。对于对象在地图上的enter,move,leave 。根据前面的思路就变得非常简单https://github.com/zhepama/AOI","titles":[]},"106":{"title":"十字链表基本原理","content":"根据二维地图，将其分成x轴和y轴两个链表。如果是三维地图，则还需要维护多一个z轴的链表。将对象的坐标值按照从小到大相应的排列在相应的坐标轴上面。添加到AOI（ADD）: 根据新增对象的X,Y坐标,依次遍历X,Y轴坐标链表,这里有两个目的,一个是获得这个新增对象的坐标在X,Y轴坐标的位置,另一方面获得该通知哪些结点.通知的范围,每个对象可以自己定制自己的通知范围。必须X,Y坐标同时都在通知范围内才可以进入通知集合，我们要按照从小到大进行插入。例如X轴坐标为:假设新增一个对象z,它最终所在的位置是c和d之间,需要重新在链表的头部开始遍历寻找z的位置，比如z的X轴位置是5：但是这样会发现一个问题，如果需要管理的坐标少还可以。但如果有很多个坐标比如1W个坐标，那这个链表会很长，如果每次都需要从头部开始查找效率就很低。针对这样的插入方法目前大家常用的有快速排序、分治、按区域划分格子等方式。","titles":["十字链表法"]},"107":{"title":"目前常用的排序算法","content":"快速排序（Quicksort）是对  冒泡排序 的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以  递归 进行，以此达到整个数据变成有序  序列 。分治算法分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。按区域划分格子该方法是把区域划分成多个格子，比如X坐标1到X坐标4为一个格子我们（暂时称之为A格子），坐标5到X坐标9为一个格子（暂时称之为B格子）。这样做的好处是，当你插入的坐标是2的时候，我们只需要遍历A格子里面的数据找到自己位置就可以了。综合以上三种方法，大家一眼就看出来了。是的，按区域划分格子的方式是目前最佳的方式。从时间复杂度等等所有方便都是这个最佳，但是这个方法也有一个很大的问题，用这样的方式插入是很快了，但查找范围内的坐标就变的很困难了。大家可以仔细考虑一下或者自己写一个DEMO。你马上会发现，当我知道我的位置的情况下，我该如何查找周围玩家呢，是的。这样的话十字链就没有什么用了。当然会有人说我在每个格子之间用链表进行连接就可以了，那么问题又来了。该如何连接，肯定有很复杂的代码才可以完成这样逻辑。就算是你能完成这个链表的连接，但这些逻辑会提升了时间复杂度。","titles":["十字链表法"]},"108":{"title":"快慢针","content":"所谓快慢针就是，总有一个指针快于一个指针。实现方式是，插入的时候把链表分成多份、比如链表长度为10，快的指针每次移动4个，然后对比当前节点如果位置小于的话，把慢指针指向快指针的位置，快指针继续向后面4个格子移动，直到找到大于的节点为止，这时候慢指针开始向前移动一个一个的对比位置就可以了。如果一直没有找到大于的节点，那就表示要插入的位置是当前链表最后的位置。相信大家已经看明白了，是的。这样的情况下效率就很高了，唯一的问题就是这个时间复杂度不稳定。使用这个方式，查找周围玩家直接前后查找移动就可以了。效率也非常高。快慢针实现：","titles":["十字链表法"]},"109":{"title":"实现方式","content":"Move（当角色移动后通知AOI）：查找周围（按照指定的范围查找自己周围玩家）：","titles":["十字链表法"]},"110":{"title":"优缺点","content":"九宫格   优点: cpu消耗小  缺点: 内存开销大,内存消耗不仅和实体数有关,还和场景大小成正比  十字链表   优点: 内存开销小,内存消耗仅和实体数有关,和场景大小无关  缺点: cpu消耗高,每次移动都需要计算视野差,当实体在小区域堆积严重时效率更差","titles":["十字链表法"]},"111":{"title":"ICloneable接口","content":"ICloneable接口包含一个Clone方法，可以用来创建当前对象的拷贝。ICloneable的问题是Clone方法并不会显式地指定是执行浅拷贝或深拷贝，因此调用者将无法确定实际情况。因此，有一些关于把ICloneable从.NET框架中淘汰的讨论。MSDN文档似乎暗示Clone方法是进行的深拷贝，但是文档没有明确的说明：ICloneable接口包含一个成员方法，Clone，意在支持超过MemberWiseClone所提供的功能... MemberWiseClone进行的是浅拷贝...类型安全的克隆ICloneable的另一个缺点是Clone方法返回的是一个对象，因此每次调用Clone都要进行一次强制类型转换。一种可以避免进行强制类型转换的方式是提供你自己的类型安全的Clone方法。注意，你依然要提供ICloneable.Clone方法的以满足iCloneable接口的要求。手工克隆一个能够保证对象完全按照你所想的那样进行克隆的方式是手工克隆对象的每一个域（field）。这种方式的缺点是麻烦而且容易出错：如果你在类中增 加了一个域，你很可能会忘记更新Clone方法。还要在克隆引用对象指向原始对象的时候，注意避免无限循环引用。下面是一个进行深拷贝的简单例子：使用MemberWiseClone方法MemberWiseClone是Object类的受保护方法，能够通过创建一个新对象，并把所有当前对象中的非静态域复制到新对象中，从而创建一 个浅拷贝。对于值类型的域，进行的是按位拷贝。对于引用类型的域，引用会被赋值而引用的对象则不会。因此，原始对象及其克隆都会引用同一个对象。注意，这 种方法对派生类都是有效的，也就是说，你只需在基类中定义一次Clone方法。下面是一个简单的例子：用反射进行克隆用反射进行克隆是使用Activator.CreateInstance方法来创建一个相同类型的新对象，然后用反射对所有域进行浅拷贝。这种方法 的优点是它是全自动的，不需要在对象中添加或删除成员的时候修改克隆方法。另外它也能被写成提供深拷贝的方法。缺点是使用了反射，因此会比较慢，而且在部 分受信任的环境中是不可用的。示例代码调用一百万次耗时：2464毫秒使用序列化进行克隆克隆一个对象的最简单的方法是将它序列化并立刻反序列化为一个新对象。和反射方法一样，序列化方法是自动的，无需在对对象成员进行增删的时候做出修 改。缺点是序列化比其他方法慢，甚至比用反射还慢，所有引用的对象都必须是可序列化的（Serializable）。另外，取决于你所使用的序列化的类型 （XML，SOAP，二进制）的不同，私有成员可能不能像期望的那样被克隆。示例代码在这里，这里和这里。**调用一百万次耗时：**2984毫秒http://wiki.unity3d.com/index.php/ObjectCopier使用IL进行克隆一种罕见的解决方案是使用IL（中间语言）来进行对象克隆。这种方式创建一个动态方法（DynamicMethod），获取中间语言生成器 （ILGenerator），向方法中注入代码，把它编译成一个委托，然后执行这个委托。委托会被缓存，因此中间语言只在初次克隆的时候才会生成，后续的 克隆都不会重新生成一遍。尽管这种方法比使用反射快，但是这种方法难以理解和维护。示例代码调用：  StudentSecond ss= TransExpV2.Trans(s);*  调用一百万次耗时：107毫秒*使用扩展方法进行克隆Havard Stranden用扩展方法（extention method）创建了一个自定义的克隆框架。这个框架能够创建对象及其引用的对象的深拷贝，不管对象结构有多复杂。缺点是，这是一个不提供源代码的自定义 框架（更新：现在已经包括源代码了，参见本文评论），并且它不能在不使用无参数构造器的时候，拷贝由私有方法创建的对象。另一个问题，也是所有自动化的深 克隆方法共有的问题是，深拷贝通常需要灵活地处理不能进行简单自动化特殊情况（例如未受管理的资源）。","titles":[]},"112":{"title":"一个测试类","content":"","titles":["ICloneable接口"]},"113":{"title":"一、GC的工作区域","content":"1、不是GC的工作区域(1)程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭；(2)栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作，每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具有确定性。在这几个区域不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。2、GC的工作区域（哪些内存需要GC回收？）(1)垃圾回收重点关注的是堆和方法区部分的内存。​    因为一个接口中的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，所以垃圾回收器所关注的主要是这部分的内存。","titles":[]},"114":{"title":"二、垃圾对象的判定","content":"Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，哪些还活着。对象死去的时候才需要回收。","titles":[]},"115":{"title":"1、引用计数法","content":"引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。优点1)可即刻回收垃圾，每个对象都知道自己的被引用数，当counter为0时，对象就会把自己作为空闲空间连接到空闲链表，也就是在对象变成垃圾的同时就会被回收.2）最大暂停时间短，每次通过指向mutator生成垃圾时，这部分垃圾都会被回收，大幅削减了mutator的最大暂停时间。缺点1)引用和去引用伴随加法和减法，影响性能2)很难处理循环引用","titles":["二、垃圾对象的判定"]},"116":{"title":"2、可达性分析算法","content":"这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。Java语言是通过可达性分析算法来判断对象是否存活的。C#与Java中，  GC采用的是GC Root 的链路可达性分析算法解决的GC标记问题 。原理就是一个对象只要有GC Root引用，就不会释放.NET中可以当作GC Root的对象有如下几种：1、全局变量2、静态变量3、栈上的所有局部变量(JIT)4、栈上传入的参数变量5、寄存器中的变量在Java中，可以当做GC Root的对象有以下几种：1、虚拟机（JVM）栈中的引用的对象2、方法区中的类静态属性引用的对象3、方法区中的常量引用的对象（主要指声明为final的常量值）4、本地方法栈中JNI的引用的对象","titles":["二、垃圾对象的判定"]},"117":{"title":"三、垃圾回收算法","content":"","titles":["二、垃圾对象的判定"]},"118":{"title":"1、标记-清除算法","content":"简单来说有两个步骤：标记、清除。(1). 标记阶段：找到所有可访问的对象，做个标记(2). 清除阶段：遍历堆，把未被标记的对象回收缺 点(1)因为涉及大量的内存遍历工作，所以执行性能较低，这也会导致“stop the world”时间较长，java程序吞吐量降低；(2)对象被清除之后，被清除的对象留下内存的空缺位置会造成内存不连续，空间浪费。","titles":["二、垃圾对象的判定","三、垃圾回收算法"]},"119":{"title":"2、标记整理(压缩)算法","content":"标记-整理算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。(1)、标记阶段：它的第一个阶段与标记/清除算法是一模一样的。(2)、整理阶段：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。​    上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。优点标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。缺点标记/整理算法唯一的缺点就是效率也不高。不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。","titles":["二、垃圾对象的判定","三、垃圾回收算法"]},"120":{"title":"3、复制算法","content":"复制算法简单来说就是把内存一分为二，但只使用其中一份，在垃圾回收时，将正在使用的那份内存中存活的对象复制到另一份空白的内存中，最后将正在使用的内存空间的对象清除，完成垃圾回收。优点\n复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。\n缺点\n复制算法的代价是将内存缩小为原来的一半，这个太要命了。注意（重要）​    现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一块为Eden（伊面区）和两块较小的Survivor（幸存区）空间(默认比例->8:1:1)。每次使用Eden和其中的一块Survivor，垃圾回收时候将上述两块中存活的对象复制到另外一块Survivor上，同时清理上述Eden和Survivor。所以每次新生代就可以使用90%的内存。只有10%的内存是浪费的。(不能保证每次新生代都少于10%的对象存活，当在垃圾回收复制时候如果一块Survivor不够时候，需要老年代来分担，大对象直接进入老年代)总的来讲：复制算法不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）","titles":["二、垃圾对象的判定","三、垃圾回收算法"]},"121":{"title":"4、三种算法总结","content":"相同点(1)三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。(2)在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。区别三种算法比较：​    效率：复制算法>标记-整理算法>标记-清除算法；​    内存整齐度：复制算法=标记-整理算法>标记-清除算法​    内存利用率：标记-整理算法=标记-清除算法>复制算法","titles":["二、垃圾对象的判定","三、垃圾回收算法"]},"122":{"title":"5、分代收集算法","content":"首先这不是一种新算法，它是一种思想。现在使用的Java虚拟机并不是只是使用一种内存回收机制，而是分代收集的算法。就是将内存根据对象存活的周期划分为几块。一般是把堆分为新生代、和老年代。短命对象存放在新生代中，长命对象放在老年代中。这个图是我拷贝来的，但要记住java8以后，已经没有永久区了，之前永久区存放的东西基本上放到了元空间中。对于不同的代，采用不同的收集算法：​    新生代：由于存活的对象相对比较少，因此可以采用复制算法该算法效率比较快。​    老年代：由于存活的对象比较多哈，可以采用标记-清除算法或是标记-整理算法。","titles":["二、垃圾对象的判定","三、垃圾回收算法"]},"123":{"title":"各平台GC算法","content":"关于Mono和unity ，集成的是开源项目BOEHM ，BOEHM算法采用标记清除法,il2cpp也是实现了boehm算法","titles":["二、垃圾对象的判定"]},"124":{"title":"关于c#和java中的循环引用","content":"循环引用指的是A引用了B，而B又引用了A。在写代码的时候，都难免会这样写：地图引用了战斗单位，战斗单位又引用了地图。。如图：（来源于国外大神的解释）当A没有再被其他类引用，则A，B，C都应该被垃圾回收。如果判断该对象是否需要被回收的依据是基于引用计数的，那上面代码就会是这样：B被C和A引了，引用计数为2，C被B引了，引用计数为1，这样内存就泄露了。所以C#的GC并没有用引用计数。GC有一些“根”，对象都挂在上面。从“根”往其子结点进行遍历，就可以标注出哪些对象是被使用的。A对象没有被其他引用，A作为B，C的入口，所以A,B,C都变成了被回收的对象。只要是涉及到的对象不能从GC Roots  强引用 可到达，垃圾回收器都会进行清理来释放内存。综上，C#在做循环引用的时候是不会出现垃圾回收问题的。","titles":[]},"125":{"title":"编译器","content":"CSC.exe 是C＃编译器，可以编译您的C＃代码并生成可执行（.exe）文件，动态链接库（.dll）或代码模块（.netmodule）。MSBuild 是Microsoft Build Engine，可用于从Visual Studio生成  项目和解决方案  。 此外，即使我编写了一些.cs文件和一个自定义项目文件（.xxproj）来构建它们，我们也可以使用msbuild.exe并使用  类的命令来构建它们。 请参阅  本文档  。它们之间的关系：如果我只有几个.cs文件，并且想要编译它们以输出.exe及其它内容，那么csc.exe就足够了。   在命令行中  （    ） 使用它来编译代码。  如果创建项目文件（.xxproj）以更好地控制资源，.cs文件和其他文件，则可以  在命令行中使用msbuild 来构建它们以输出.exe或其他内容。 我们应该知道的一点是，msbuild.exe不仅可以构建C＃代码，而且还可以构建   ...当我使用msbuild使用  类的命令来构建C＃代码时，它将   。  尽管msbuild是Visual Studio中的构建系统，但它并不依赖于Visual Studio。您可能想知道msbuild传递给特定构建的csc的信息。 在这种情况下，只需使用msbuild的详细程度开关即可：请参阅  使用MSBuild获取构建日志  。","titles":[]},"126":{"title":"mono系列","content":"Mono C＃编译器被认为是C＃1.0，C＃2.0，C＃3.0，C＃4.0，C＃5.0和C＃6.0（ECMA）的完整功能，并且部分支持C＃7。  https://www.mono-project.com/docs/about-mono/languages/csharp/从历史上看，存在相同编译器的各种版本。gmcs：编译器以2.0 mscorlib为目标。引用2.0概要文件库（在.NET 2.0和.NET 3.5中定义的API）并公开完整的C＃3.0语言。  smcs：以2.1 mscorlib为目标的编译器，以构建Moonlight应用程序。 引用2.1概要文件库（为Silverlight定义的API）并公开完整的C＃3.0语言。这是用于创建Silverlight / Moonlight应用程序的编译器。  dmcs：编译器针对4.0 mscorlib。引用4.0概要文件库（.NET 4.0中定义的API）并支持C＃4.0。","titles":["编译器"]},"127":{"title":"编译为 MSIL","content":"编译为托管代码时，编译器将源代码转换为 Microsoft 中间语言 (MSIL)，这是一组独立于 CPU 且可以有效地转换为本机代码的说明。 MSIL 包括有关加载、存储、初始化和调用对象方法的说明，以及有关算术和逻辑运算、控制流、直接内存访问、异常处理和其他操作的说明。 代码可以运行之前，必须将 MSIL 转换为特定于 CPU 的代码，通常通过   实时 (JIT) 编译器 实现。 由于公共语言运行时为其支持的每个计算机基础结构提供一个或多个 JIT 编译器，同一组的 MSIL 可以在任何受支持的基础结构上进行 JIT 编译和运行。当编译器生成 MSIL 时，它还生成元数据。 元数据描述代码中的类型，包括每种类型的定义、每种类型的成员的签名、代码引用的成员以及运行时在执行时间使用的其他数据。 MSIL 和元数据包含在一个可移植的可执行 (PE) 文件中，该文件基于且扩展已发布的 Microsoft PE 和历来用于可执行内容的通用对象文件格式 (COFF)。 容纳 MSIL 或本机代码以及元数据的这种文件格式使操作系统能够识别公共语言运行时映像。 文件中元数据的存在以及 MSIL 使代码能够描述自身，这意味着将不需要类型库或接口定义语言 (IDL)。 运行时在执行期间会根据需要从文件中查找并提取元数据。什么是非托管代码(unmanaged code)？   非托管代码，直接编译成目标计算机码，在   公共语言运行库  环境的外部，由操作系统直接执行的代码，代码必须自己提供垃圾回收，类型检查，安全支持等服务。如需要内存管理等服务，必须显示调用操作系统的接口，通常调用Windows SDK所提供的API来实现内存管理。  当项目选择名字以MFC，ATL，Win32开头的项目类型，那么这个项目所产生的就是非托管程序。  非托管代码就是在Visual Studio .NET 2002发布之前所创建的代码。例如Visual Basic 6, Visual C++ 6, 最糟糕的是，连那些依然残存在你的硬盘中、拥有超过15年历史的陈旧C编译器所产生的代码都是非托管代码。托管代码直接编译成目标计算机的机械码，这些代码只能运行在编译出它们的计算机上，或者是其它相同处理器或者几乎一样处理器的计算机上。非托管代码不能享受一些运行库所提供的服务，例如安全和内存管理等。如果非托管代码需要进行内存管理等服务，就必须显式地调用操作系统的接口，通常来说，它们会调用Windows SDK所提供的API来实现。就最近的情况来看，非托管程序会通过COM接口来获取操作系统服务。  跟Visual Studio平台的其他编程语言不一样，Visual C++可以创建非托管程序。当你创建一个项目，并且选择名字以M FC，ATL或者Win32开头的项目类型，那么这个项目所产生的就是非托管程序。","titles":["编译器"]},"128":{"title":"将 MSIL 编译为本机代码","content":"运行 Microsoft 中间语言 (MSIL) 前，必须根据CLR公共语言运行时将其编译为目标计算机基础结构的本机代码。 .NET Framework 提供两种方法来执行此转换：.NET Framework 实时 (JIT) 编译器。  .NET Framework   Ngen.exe（本机映像生成器） 。","titles":["编译器"]},"129":{"title":"由 JIT 编译器编译","content":"在加载和执行程序集的内容时，JIT 编译在应用程序运行时按需将 MSIL 转换为本机代码。 由于公共语言运行时为每个受支持的 CPU 基础结构提供 JIT 编译器，开发人员可以构建一组 MSIL 程序集，这些程序集可以进行 JIT 编译并可在具有不同计算机基础结构的不同计算机上运行。 但是，如果你的托管代码调用特定于平台的本机 API 或特定于平台的类库，它将仅在该操作系统上运行。JIT 编译将执行期间可能永远不会调用的某些代码的可能性考虑在内。 它根据需要在执行期间转换 MSIL，而不是使用时间和内存来将 PE 文件中所有 MSIL 转换为本机代码，并在内存中存储生成的本机代码，以便该进程上下文中的后续调用可以对其进行访问。 加载类型并将其初始化时，加载程序创建并将存根附加到类型中的每个方法。 第一次调用某个方法时，存根将控件传递给 JIT 编译器，后者将该方法的 MSIL 转换为本机代码，并将存根修改为直接指向生成的本机代码。 因此，对 JIT 编译的方法的后续调用会直接转到本机代码。","titles":["编译器","将 MSIL 编译为本机代码"]},"130":{"title":"使用 NGen.exe 的安装时代码生成","content":"由于在调用该程序集中定义的各个方法时，JIT 编译器将程序集的 MSIL 转换为本机代码，因此它在运行时中对性能产生负面影响。 在大多数情况下，这种性能降低的程度是可以接受的。 更为重要的是，由 JIT 编译器生成的代码会绑定到触发编译的进程上。 它无法在多个进程之间进行共享。 若要允许生成的代码跨应用程序的多个调用或跨共享一组程序集的多个进程进行共享，则公共语言运行时支持预编译模式。 这种预编译模式使用   Ngen.exe（本机映像生成器） 将 MSIL 程序集转换为本机代码，非常类似 JIT 编译器执行的操作。 但是，Ngen.exe 的操作在三个方面不同于 JIT 编译器的操作：它在运行应用程序之前而非运行该应用程序时，将 MSIL 转换为本机代码。  它一次编译整个程序集，而不是一次编译一种方法。  它将本机映像缓存中生成的代码作为磁盘上的文件保存。基本上每个人都知道的是，所有.Net语言都将被编译成为一个叫做IL汇编的中间语言。但是计算机是如何执行这个中间代码的，却是很多人不知道，甚至理解错误了的。JIT是.NET程序运行的重要部件之一，全称是即时编译器。很多人都以为JIT其实就是跟Java VM差不多的东西，是一个Interpreter，在运行时读取IL汇编代码，然后模拟成x86代码（也就是俗称的虚拟机）。但是事实上，.NET使用的是更为高级的技术。 .Net程序被加载入内存以后，当某段IL代码被第一次运行的时候，JIT编译器就会将这段IL代码，全部编译成本地代码，然后再执行。这也就是为什么.NET程序第一次运行都启动很慢的原因！ 随.NET库，微软还附带了一个工具，可以事先将.NET程序所有的IL代码都编译成本地代码并保存在缓存区中，这样一来，这个程序就跟c++编译的一模一样了，没有任何区别，运行时也可以脱离JIT了（这里不要混淆了，这里不是说可以脱离.NET库，而是说不需要在进行即时编译这个过程了）。所以，请不要将.NET和Java混为一谈，两个的运行效率根本不是一个等级的！  JIT的优化指的是可以针对本地CPU，在编译时进行优化。传统程序在编译时，为了保证兼容性，通常使用最通用的指令集（比如古老的386指令集）来编译。而JIT知道CPU的具体类型，可以充分利用这些附加指令集进行编译，这样的性能提升是很可观的。","titles":["编译器","将 MSIL 编译为本机代码"]},"131":{"title":"运行","content":"PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。那Windows是怎么区分可执行文件和非可执行文件的呢？我们调用LoadLibrary传递了一个文件名，系统是如何判断这个文件是一个合法的动态库呢？这就涉及到PE文件结构了C#生成的exe既然是window下可执行文件，那也就是标准的PE文件，和普通win32的exe文件格式一样。我们来看下exe文件的格式：dll文件本质上和exe一样，只是少了入口函数。MS-DOC MZ Header和MS-DOS Stub是为了兼容DOS系统存在的，目的是使这个exe在DOS下执行时弹出一个提示\"This program cannot be run in DOS mode\"。PE Header包含了这个文件的一些信息，如：文件创建日期，文件类型，Section的数量，Optional Header的大小等等。详细可以参考Winnt.h里的结构_IMAGE_FILE_HEADER。PE Optional Header则包含了文件的版本号以及重要的基地址和AddressOfEntryPoint（RVA-Relative Virtual Address)，这是程序执行的入口地址，双击exe后就从这里开始执行。对C#程序来说，这里指向的是.net的核心库MsCorEE.dll的_CorExeMain()函数。当然这是针对XP系统的，XP以后的系统，OS Loader已经可以判断出这个PE是否包含CLR头来决定是否运行MsCorEE.dll的_CorExeMain()函数。Section有很多，包括代码节，数据节等，C#程序会把CLR头，元数据，IL放在这里面。CLR是什么呢，全称Common Language Runtime，公共语言运行时，CLR主要是管理程序集，托管堆内存，异常处理和线程同步等等。CLR头具体可以参考CorHdr.h中的IMAGE_COR20_HEADER结构，如下：元数据很重要，验证代码类型安全，GC的对象引用跟踪还有我们常用的反射都需要用到元数据。元数据主要由定义表，引用表，清单表组成。定义表包括应用所有的类型，方法，字段，属性，参数，事件的定义,代码里任何的定义项都可以在这个表里找到，反射就是靠这个表只要一个名字就能得到属性或函数。运行时的类型安全检查也离不开它。引用表包括程序集，类型和成员的引用，我们知道GC在回收内存时先默认认为所有对象都是垃圾，然后通过线程栈上的根（cpu寄存器，局部变量，参数，静态变量）找引用的对象，能找到的说明还在使用就去掉垃圾标记，这个表可以让GC在回收内存时方便从根找到所有引用。清单表主要是程序集，文件，资源的定义。现在来看看双击后是怎样运行的：双击文件后OS Loader加载PE文件并解析，在PE Optional Header里找到基地址和RVA，通过这两个确定了程序的入口地址，这个地址指向MsCorEE.dll的_CorExeMain()，执行它。_CorExeMain()开始执行，选择加载合适版本的CLR，CLR开始运行，CLR运行时会分配一个连续的地址空间用作托管堆，并用一个指针NextObjPtr指到开始位置，下次分配内存时就从指针指的位置开始。CLR运行后从CLR头里找到应用程序入口标识，也就是Main()方法的MethodDefToken，通过这个标识在元数据表MethodDef里找到Main方法的偏移位置，这样就可以找到Main()的IL代码。CLR检查Main方法里面是否有没加载的类型，没有的话就加载进来并在托管堆上建一个类型对象，类型对象包含静态字段，方法，基类的引用。然后给类型的方法表里每个方法一个存根，存根是用于标识是否被JIT编译过。JIT: just-in-time Compiler，即时编译器。JIT编译之前CLR会对Main方法的代码进行验证，确保类型安全且元数据正确，一切没问题后先检查类型方法表里这个方法的存根，不为空的话表示已经编译过就不需要再次编译，没有的话JIT把这段IL代码编译成本地代码保存到内存中并方法表的存根做上标记，然后JIT返回编译前的位置并把原来CLR指向JIT的地址修改为指向本地代码的地址，这样函数的本地代码开始执行。程序执行到哪里就编译到哪里，没有执行到的就不会加载和编译，同样的代码再次执行的话就直接在内存里拿了，这也是为什么第一次运行C#时比较慢而后面就快的原因。这样就开始陆续执行所有的代码，程序也就跑起来了。在内存上，运行线程会把函数的参数和局部变量压入线程栈上，栈上的空间默认是1M，方法的参数和局部变量都会压到函数的栈帧上，方法里的对象在托管堆NextObjPtr指向的位置分配内存并把内存地址存到栈上的局部变量里。CLR会给托管堆上的每个对象包括对象类型都添加两个字段，一个对象类型指针，一个同步块索引。说起栈帧，大家在调试代码时应该都喜欢用CallStack吧，这可以通过看调用栈很方便来定位出问题的具体原因，这个CallStack也就是方法的栈帧的具体显示，一级一级的。对象类型指针从字面上就很容易知道跟类型有关。CLR刚开始运行时就分配了一个Type的对象类型，他的对象类型指针指向自己，后面创建的对象类型的对象类型指针指针就指向这个Type，而new出来的对象的对象类型指针就指向它的类型，这样所有对象都能找到自己的类型使CLR在运行时能确保类型安全。同步块索引的格式是前6个标志位加后面26位内容（32位系统），作用则有好几个。\\1. 调用对象的gethashcode()后标志位改变一位，后26位会存储对象的hashcode，保证对象生命周期内hashcode的唯一；\\2. lock时用到，CLR会维护一个同步块数组，每项由一个指向同步块的指针和对象指针组成，lock时同样改变标识位，然后去同步块数组找一个闲置项，后26则变成这项在数组中的索引，有人要问了，刚才hashcode不是用了这26位吗，现在变了，hashcode岂不是丢了。确实，hashcode在lock之后不能直接存到索引了，不过同步块中专门准备了一个字段用来存hashcode，所以可以转移到同步块中，这样设计是为了节省内存，因为大部分情况下是不用lock的，也就不需要增加多余的同步块。另外为什么是索引而不是地址呢，因为同步块数组的大小不是固定的，随着对象的增多而变大，在内存上的位置可能会发生变化，所以用索引就不用管数组在哪个位置了。当线程进入lock后检查同步块的m_motion，发现没有标识则进入lock区域并把标识改变，如果已经有同一个线程进去则把计数器加1，如果已经有其他线程则等待。\\3. 垃圾回收时的标识，GC触发时首先认为所有的对象都是垃圾，由局部变量，寄存器，静态变量这些根向上找，凡是包含的对象都认为还有引用，在同步块索引上修改一位标识，当所有对象都遍历过后没有标识的对象就会被清掉，然后再是整理内存、修改引用地址等。看个简单的例子，只用于演示，不考虑合理性：*  图片不清楚可以放大看首先判断类型是否都加载，用到了int，bool，string，这些是在mscorlib.dll程序集的system命名空间下，所以先加载mscorlib.dll程序集，再把int，bool，string加到类型对象里。另外还有我们自己定义的Developer和People，也把类型对象创建好，另外也别忘了基类object，也要加载进来。（实际上还有double啊，这里就没画了）另外继承类的类型对象里面都有个字段指向基类，所以才能往上执行到基类方法表里的方法。局部变量都在线程栈上，Find()方法是静态方法，直接去People类型对象的方法表里去找，找到后看是否有存根标识，没有的话做JIT编译，有的话直接运行。developer的实例化虽然是用People定义的，但实例还是Developer，所以developer的类型对象指针指向Developer，对象里除了类型对象指针还有实例字段，包括基类的。内存分配在托管堆上，并把地址给到线程栈上的变量中。虚函数也一样，在运行时已经确定是Developer，所以会调用Developer方法表里的IsRich方法，一样先JIT，再运行。以上就是一个简单的C#程序的运行过程和在内存上的表现，本篇主要内容来自CLR via C#这本书https://www.cnblogs.com/brookshi/p/5273281.html   https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_to_msil   https://docs.microsoft.com/zh-cn/dotnet/standard/clr   https://www.cnblogs.com/qtiger/p/11176575.html","titles":[]},"132":{"title":"替换数据库为mysql","content":"替换mysql,Dothass.Blog.EntityFrameworkCore项目中删除之前的迁移目录  修改连接字符串 项目  和  ..生成新的迁移,nuget包管理器.默认项目设置为相关链接:   https://docs.abp.io/zh-Hans/abp/latest/Entity-Framework-Core-MySQL","titles":[]},"133":{"title":"初始化项目","content":"将三个项目copy到程序中.然后在web项目中添加依赖  即可  修改migrationservice,  项目下执行项目Dothass.Blog.DbMigrator初始化数据","titles":[]},"134":{"title":"关于客户端js","content":"执行 yarn & gulp 将所有包都会将自己的资源复制到wwwroot/libs文件夹中. 否则一些模块例如博客的js时不会起作用的","titles":[]},"135":{"title":"错误","content":"可以看出来这些问题是和SSL证书有关，经过排查，发现IdentityServer4配置中：使用了  IP 的形式配置的授权地址，但是SSL证书是以域名形式申请的，这就造成了SSL证书不能验证通过。解决方法：  将授权地址配置为域名:端口的形式 ，完美解决上述问题。注意域名为SSL证书申请时用到的域名。localhost使用的是开发证书,也是类似域名,127.0.0.1也是有问题的","titles":[]},"136":{"title":"数据迁移上下文","content":"abp的dbcontext是分成两种的,一个是程序运行的dbcontext,一个是数据迁移的dbcontext我们看到他们共同执行了 builder.ConfigurePlayGround();","titles":[]},"137":{"title":"为什么这样设计?","content":"为了模块间不产生依赖,例如用户表,迁移dbcontext中使用了IdentityUser,而运行的dbcontext使用了appuser进行了对其的映射,  https://github.com/abpframework/abp/issues/1998  如何为user添加属性.  https://github.com/abpframework/abp/issues/2453","titles":["数据迁移上下文"]},"138":{"title":"如何共用user","content":"我们来看下定义的Iuser接口dbcontext中的配置字段dbcontext中的user表是如何创建,更新和使用的..先看下查找,其中根据上面代码可见,如果找不到该用户..会自动创建一个,如何继承了IUpdateUserData则会更新更新还可以通过eventbus","titles":[]},"139":{"title":"如何给IdentityUser添加额外的属性","content":"","titles":[]},"140":{"title":"Extra Properties","content":"首先IdentityUser已经被定义,虽然我们可以通过dbcontext配置修改数据表的字段,,但是不能被映射,所以有了Extra Propertieshttps://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities","titles":["如何给IdentityUser添加额外的属性"]},"141":{"title":"映射","content":"会在数据库中创建字段我们来看看生成的迁移表它时如何被添加到迁移dbcontext中的","titles":["如何给IdentityUser添加额外的属性"]},"142":{"title":"同步","content":"你可以创建  自己的表 来存储属性,而不是创建新实体并映射到同一表. 你通常复制原始实体的一些值. 例如可以将    字段添加到你自己的表中,它是原表中    字段的副本.在这种情况下你不需要处理迁移问题,但是需要处理数据复制问题. 当重复的值发生变化时,你应该在表中同步相同的变化. 你可以使用本地或分布式  事件总线 订阅原始实体的更改事件. 这是根据来自另一个微服务的数据推荐的方法,特别是如果它们有单独的物理数据库(你可以在网络中搜索关于微服务设计的数据共享,这是一个广泛的主题).","titles":["如何给IdentityUser添加额外的属性"]},"143":{"title":"配置","content":"","titles":[]},"144":{"title":"原理","content":"abp 使用拉的方式从github直接请求,然后存储到数据库作为缓存注意开发环境下,他会从github直接拉取而不会经过数据库缓存,所以会很慢","titles":[]},"145":{"title":"关于版本","content":"当你写完书的时候.打个tag,然后把tag的版本号填入上方的..最新版本的分支名称即可","titles":[]},"146":{"title":"关于多语言","content":"注意多语言abp使用了缓存..所以如果你更改了docs-langs.json,需要重启服务器,或者清空缓存","titles":[]},"147":{"title":"关于参数[doc-params]","content":"abp使用了scriban文本模板语言引擎.https://github.com/lunet-io/scriban具体的示例参见:https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&DB=EF&Tiered=No   https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.mdmarkdow中使用生成的html当切换ui的值后的显示,我们看到字符发生了改变","titles":[]},"148":{"title":"关于[doc-template]","content":"还没看到如何用","titles":[]},"149":{"title":"404","content":"因为访问github如果超时就会出现404.所以建议控制台设置代理然后运行","titles":[]},"150":{"title":"abp默认语言规则","content":"abp是依托与aspnetcore的.我们先来看看aspnetcore是怎么实现的","titles":[]},"151":{"title":"中间件request的语言判断","content":"在每次请求里   RequestLocalizationOptions  的   RequestCultureProvider  列表会被遍历，第一个provider 会被使用来判断请求使用的文化。默认的 provider 来自   类,如果没有非空的 provider，   被使用。所以如果发现语言不是按照逻辑顺序显示,先检查请求网址,再检查  (很难注意到),最后检查acceptlanguage","titles":["abp默认语言规则"]},"152":{"title":"QueryStringRequestCultureProvider","content":"下面的例子指定了具体的区域性（语言和区域）设置为西班牙语/墨西哥：http://localhost:5000/?culture=es-MX&ui-culture=es-MX如果你仅仅使用（culture 或者 ui-culture）中的一个参数进行传递，查询字符串 provider 将使用你传递一个值来设置这两个参数。例如，仅设置culture，将会同样设置 Culture 和 UICulture：http://localhost:5000/?culture=es-MX","titles":["abp默认语言规则","中间件request的语言判断"]},"153":{"title":"CookieRequestCultureProvider","content":"CookieRequestCultureProvider 的 DefaultCookieName 返回用于跟踪用户的首选区域性信息默认的 Cookie 名称。默认的 Cookie 名称是 “.AspNetCore.Culture”。cookie 的格式是 c=%LANGCODE%|uic=%LANGCODE%, c 为区域信息 和 uic 为 UI 区域信息，例如：c=’en-UK’|uic=’en-US’如果仅指定 culture 或 UI culture中的一个，指定的区域性信息将同时用于 culture和 UI culture。","titles":["abp默认语言规则","中间件request的语言判断"]},"154":{"title":"AcceptLanguageHeaderRequestCultureProvider","content":"这个一般是根据浏览器的设置进行访问的\n  \n不同的浏览器默认语言不同,chrome浏览器可以再语言里设置","titles":["abp默认语言规则","中间件request的语言判断"]},"155":{"title":"Cultures","content":"的   CultureInfo  对象决定了和文化相关的函数，如日期，时间，数字和货币格式的结果。同时决定了文字如何排序，大小写转换以及字符串比较。参考  CultureInfo.CurrentCulture  获取更多关于服务器如何获取文化的信息。    决定如何通过   ResourceManager  查找翻译字符串（从   .resx  文件）。   ResourceManager  只是通过 CurrentUICulture 简单的查找指定文化的字符串。.NET 的每个线程都会拥有    和   对象。当 ASP.NET Core 在渲染与文化相关的函数的时候会检视这些对象值。例如，如果当前线程的区域性设置为 “en-US” （英语、美国），    ，但如果 CurrentCulture 设置为 “es-ES”（西班牙语、西班牙），输出将会是 “jueves, 18 de febrero de 2016”。","titles":["abp默认语言规则"]},"156":{"title":"abp的实现","content":"Volo.Abp.AspNetCore项目中DefaultAbpRequestLocalizationOptionsProvider.cs然后中间件是中间件使用的是AbpRequestLocalizationMiddleware,其实它只是对aspnetcore的RequestLocalizationMiddleware进行了一层包装","titles":["abp默认语言规则"]},"157":{"title":"如何修改默认语言","content":"首先注意浏览器发送的中文的  的值与ABP值是不一样的:浏览器(如Chrome)的值为   而ABP的简体中文的值为首先修改配置文件appsettings.json然后在中间件中删除AcceptLanguageHeaderRequestCultureProvider","titles":["abp默认语言规则","abp的实现"]},"158":{"title":"重入","content":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。因为访问grain一般是需要跨服务器的，所以可重入是很有必要的。。","titles":[]},"159":{"title":"无状态Grain","content":"grain永远是运行在服务端的,包括无状态的.","titles":[]},"160":{"title":"time","content":"time是单线程的..","titles":[]},"161":{"title":"错误","content":"以上代码当duetime设置为0的时候,会有类型的错误原因猜测,grain未激活完成的时候,如果为0的时候,这个时候time的callback(SaveChanges)还没有加入到任务队列,就调用了state,而之后也立即同时调用了state这个时候就会报错.解决方案:不要设置duetime为0  或者不要在OnActivateAsync中RegisterTimer,在Activate后再RegisterTimer","titles":["time"]},"162":{"title":"相关链接","content":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html","titles":[]},"163":{"title":"定义 -   IServer 、  IHttpApplication<TContext>","content":"http://ASP.NET  Core定义了两个基本的接口  ，及  ，  接口定义了Web Server的基本功能，  则定义了处理HTTP协议的应用程序的基本功能，我们首先来看下这两个定义:","titles":[]},"164":{"title":"Web 服务器 -   IServer","content":"是一个功能集合，其中可以包含所有应用程序需要的，用以处理HTTP协议各个阶段和组成部分的功能集，以接口的形式注入到  中。方法可以启动IServer对象，用来接受用户请求。包含两个参数：  和  。   是最终处理HTTP请求的应用程序入口点，在ASP.NET Core应用程序中，默认的  实现是：  ，我们会在稍后的部分进行详细的介绍。 而  用来响应中断应用程序启动的请求。方法用来处理停止服务的请求，接受一个参数  ，用来响应中断停止应用程序的请求。","titles":[]},"165":{"title":"Http应用程序 -   IHttpApplication<TContext>","content":"接口的定义包含了三个方法：   方法用来创建处理请求的上下文中所需要的所有相关数据，组成  对象，由接口的实现自己定义类型，   方法使用  方法创建的  对象处理本次请求。   方法在完成请求的处理后，负责释放  对象。","titles":[]},"166":{"title":"实现 -   KestrelServer","content":"http://ASP.NET  Core提供了默认的  ：  ，下面我们就来看看  具体都做了些什么。定义在dotnet/aspnetcore项目中（  GITHUB REPO ）。 项目名称为：Microsoft.AspNetCore.Server.Kestrel.Core 名称空间.AspNetCore.Server.Kestrel.Core   源代码","titles":[]},"167":{"title":"服务器启动：端口监听，协议解析及请求处理。","content":"我们先看一下  .  方法的代码实现：首先会检查服务器的  字节序 ，目前是不支持大端序的。 然后检查最大请求长度限制的设置项，以及服务器是否已经启动。最后，通过  对预先配置的IP地址或终结点(EndPoint)名称进行监听，开始接受客户端的请求。当每有一个新的HTTP请求通过TCP协议或其他协议和服务器成功简历连接后，AddressBinder使用  方法将  方法添加到线程池中，等待线程池的调度。如果此时进程有可用的线程，就会调用  方法，处理用户的HTTP请求。方法默认使用  中间件，处理新接入的用户请求，当设置了  值为  时，则会默认使用  中间件，限制最大可用连接数，如果当前请求数已经达到最大可接受连接数，则拒绝用户的请求并断开连接，否则调用  中间件，继续处理用户的请求。","titles":[]},"168":{"title":"处理HTTP请求 -   HttpConnectionMiddleware<ServiceContext> 、  HttpConnection","content":"中间件负责组装连接相关的上下文数据  ，并使用  类处理用户请求。","titles":[]},"169":{"title":"HTTP版本控制 -   HttpConnection","content":"当用户创建  类时，在初始化过程中，会根据用户请求声明的HTTP协议版本，分别创建对应版本的Connection类，并使用该类处理用户请求：HTTP1和HTTP2处理HTTP协议的方式有所不同，HTTP1协议解析完成后，会立即调用  处理请求，HTTP2协议解析完成后，会再次调用  方法等待线程池可用线程。","titles":["处理HTTP请求 -   HttpConnectionMiddleware<ServiceContext> 、  HttpConnection"]},"170":{"title":"结束语","content":"服务的代码量并不下，其中主要是辅助接受用户请求和解析HTTP协议的代码，在这里不做详细的介绍，各位读者有兴趣的，可以详细阅读源代码。我们看到，  服务在接受和处理请求时，都用到了线程池，可以极大的提高服务器的吞吐量。后面，我们还会详细介绍系统默认的  实现，看看ASP.NET Core是如何将HTTP转发到Controller和Action，其中又有哪些精妙的代码呢。","titles":["处理HTTP请求 -   HttpConnectionMiddleware<ServiceContext> 、  HttpConnection"]},"171":{"title":"背景","content":"ASP.NET Core引入了Options模式，使用类来表示相关的设置组。简单的来说，就是用强类型的类来表达配置项，这带来了很多好处。\n初学者会发现这个框架有3个主要的面向消费者的接口：IOptions、IOptionsMonitor以及IOptionsSnapshot。\n这三个接口初看起来很类似，所以很容易引起困惑，什么场景下该用哪个接口呢？","titles":[]},"172":{"title":"示例","content":"我们先从一小段代码着手（TestOptions类只有一个字符串属性Name，代码略）：appsettings.json文件：上面的代码，首先从appsettings.json文件读取配置，然后向容器注册依赖配置文件的TestOptions，接着分别打印IOptions<>,IOptionsMonitor<>和IOptionsSnapshot<>的值。接着通过代码来修改TestOptions的值，打印。\n然后通过修改appsettings.json文件来修改TestOptions的值，打印。注意，  我们仅注册了一次TestOptions，却可以分别通过IOptions<>,IOptionsMonitor<>和IOptionsSnapshot<>接口来获取TestOptions的值。如果我们把appsettings.json文件中Name的值修改为Test 2，那么上面这段代码的输出是这样的：","titles":[]},"173":{"title":"分析","content":"我们可以看到第一次通过代码修改IOptions<>和IOptionsMonitor<>的值后，再次打印都被更新了，但是IOptionsSnapshot<>没有，为什么呢？\n让我们从Options框架的源代码着手，理解为什么会这样。\n当我们需要使用Options模式时，我们都会调用定义在OptionsServiceCollectionExtensions类上的扩展方法AddOptions(this IServiceCollection services)。我们观察AddOptions方法的实现：从上面的代码我们可以得知，IOptions<>和IOptionsMonitor<>被注册为单例服务，而IOptionsSnapshot<>被注册为范围服务。\n由于IOptions<>和IOptionsMonitor<>都被注册为单例服务，因此每次获取的都是同一个实例，所以更改了以后的值是保留的。\n而IOptionsSnapshot<>被注册为范围服务，所以每次创建新范围时获取的都是一个新的值，外部的更改只对当次有效，不会保留到下次（不能跨范围，对于ASP.NET Core来说不能跨请求）。我们继续看第二次修改，第二次修改配置文件后IOptionsMonitor<>和IOptionsSnapshot<>的值更新了，而IOptions<>的值没有更新。\nIOptions<>好理解，它被注册为单例服务，第一次访问的时候生成实例并加载配置文件中的值，此后再也不会读取配置文件，所以它的值不会更新。\nIOptionsSnapshot<>被注册为范围服务，每次重新生成一个新的范围时，它都会从配置文件中获取值，因此它的值会更新。\n但是，IOptionsMonitor<>呢，它被注册为单例，为什么也会更新呢？\n让我们回到AddOptions的源代码，我们留意到IOptionsMonitor<>的实现是OptionsManager<>。\n当我们打开OptionsManager的源代码时，一切都很清楚了。\n它的构造函数如下：原来OptionsMonitor的更新能力是从IOptionsChangeTokenSource而来，但是这个接口的实例又是谁呢？\n我们回到最开始的代码的第10行：这是一个定义在Microsoft.Extensions.Options.ConfigurationExtensions.dll的扩展方法，最后实际调用的是它的一个重载方法，代码如下：秘密就在上面的第15行，ConfigurationChangeTokenSource，它引用了代表配置文件的对象config，所以配置文件更新，IOptionsMonitor就会跟着更新。","titles":[]},"174":{"title":"结论","content":"IOptions<>是单例，因此一旦生成了，除非通过代码的方式更改，它的值是不会更新的。\nIOptionsMonitor<>也是单例，但是它通过IOptionsChangeTokenSource<> 能够和配置文件一起更新，也能通过代码的方式更改值。\nIOptionsSnapshot<>是范围，所以在配置文件更新的下一次访问，它的值会更新，但是它不能跨范围通过代码的方式更改值，只能在当前范围（请求）内有效。官方文档是这样介绍的：\nIOptionsMonitor用于检索选项和管理TOptions实例的选项通知，它支持下面的场景：实例更新通知。  命名实例。  重新加载配置。  选择性的让实例失效。IOptionsSnapshot在需要对每个请求重新计算选项的场景中非常有用。\nIOptions可以用来支持Options模式，但是它不支持前面两者所支持的场景，如果你不需要支持上面的场景，你可以继续使用IOptions。所以你应该根据你的实际使用场景来选择到底是用这三者中的哪一个。\n  一般来说，如果你依赖配置文件，那么首先考虑IOptionsMonitor<>，如果不合适接着考虑IOptionsSnapshot<>，最后考虑IOptions<>。* \n***有一点需要注意，在ASP.NET Core应用中IOptionsMonitor可能会导致同一个请求中选项的值不一致——当你正在修改配置文件的时候——这可能会引发一些奇怪的bug。\n如果这个对你很重要，请使用IOptionsSnapshot，它可以保证同一个请求中的一致性，但是它可能会带来轻微的性能上的损失。\n如果你是在app启动的时候自己构造Options（比如在Startup类中）：IOptions<>最简单，也许是一个不错的选择，Configure扩展方法还有其他重载可以满足你的更多需求。","titles":[]},"175":{"title":"性能对比数据","content":"▲ 没有什么能够比数据更有说服力（注意后面两行是有秒数的）可能我还需要解释一下那五行数据的含义：直接调用（��  应该没有什么比直接调用函数本身更有性能优势的吧 ）  做一个跟直接调用的方法功能一模一样的委托（��  目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小 ）   本文重点  将反射出来的方法创建一个委托，然后调用这个委托（��  看看吧，性能跟直接调差别也不大嘛 ）  先反射得到方法，然后一直调用这个方法（��  终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊 ）  缓存都不用，从头开始反射然后调用得到的方法（��  100 多倍的性能损失了 ）以下是测试代码，可以更好地理解上图数据的含义：","titles":[]},"176":{"title":"如何实现","content":"实现的关键就在于    方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。此方法有两个重载：要求传入一个类型，而这个类型就是应该转成的委托的类型  要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。拿上面的    来说明会更直观一些：前者得到的委托相当于    方法，后者得到的委托相当于    方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）单独使用    方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。泛型的多参数版本可以使用泛型类型生成器生成，我在   生成代码，从    —— 自动生成多个类型的泛型 - 吕毅 一文中写了一个泛型生成器，可以稍加修改以便适应这种泛型类。","titles":[]},"177":{"title":"并集 (添加)","content":"a|b: 并集(所有的和,相同部分只算一次);","titles":[]},"178":{"title":"差集 (去除)","content":"","titles":[]},"179":{"title":"补集(对称差集)","content":"","titles":[]},"180":{"title":"交集  (检查)","content":"或者从性能上看通过    的性能会比 HasFlag 高，但是从可读性上 HasFlag 更友好，如果你的代码没有性能问题推荐使用 HasFlag 方法","titles":[]},"181":{"title":"Introduction","content":"When you use HTTP on your Identity Server 4 enabled website, users may not login because of the changes made by Chrome in the version 8x. This occurs when you use HTTP schema in your website. The issue is explained here   https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication","titles":[]},"182":{"title":"How to solve it?","content":"","titles":[]},"183":{"title":"Step-1","content":"Create the below extension in your *  .Web  project.","titles":["How to solve it?"]},"184":{"title":"Step-2","content":"Assume that your project name is   Acme.BookStore . Then open    class.Add the following line to    method.","titles":["How to solve it?"]},"185":{"title":"Step-3","content":"Go to   method in    addIt's all! You are ready to go!Referenced from   https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/","titles":["How to solve it?"]},"186":{"title":"Why byte arrays?","content":"The reason we will be looking into serialising our data into byte arrays is because these are essentially the most fundamental data storage format. We can easily write them to a network buffer or stream, or to a file.There are many alternatives and none of them will be right for every single use case. For example, I like to use JSON files to store settings, scripts, and text-based assets, as well as asset meta data.In those cases performance is not the most important consideration. Instead it is more valuable to be able to edit and review files easily inside a text editor.In situations where performance is important however – such as the mentioned networking or compact file storage – serialising only the relevant data itself and skipping the encoding and formatting inherent to clear text files can be key.","titles":[]},"187":{"title":"Why structures?","content":"There are several reasons for why we are talking about structures specifically.First, I want to make a clear distinction between data and behaviour, by using a type that contains exactly the data we are interested in serialising.Secondly, structures are much more reliable and controllable when it comes to binary data layout. We will see how this is important for our last method of serialisation.Overall, we can use structures to directly represent the data that will be written into our byte array. For our example of networking this means that we have a clear one to one correspondence between our structures and our network messages.","titles":[]},"188":{"title":"BinaryFormatter","content":"In our first method of converting between structs and byte arrays, we will make use of .NET’s   BinaryFormatter  class.The entire purpose of that class is to serialise an object into binary format (i.e. a byte array) – as well as deserialising the same back into objects.The class offers a lot of functionality – most of which we are not interested in here. Of interest to us are only two methods:    and   .These methods allow us to read/write our data to any stream. In many cases we could use this to write to a network – or file – buffer or stream directly. For our purpose – and for ease of testing, we will use the    class which is little more than a stream wrapper around a byte array in the first place.Here are two generic methods that do exactly this:These methods can now be easily used like this:This looks great!It seems that we have found a solution that is both easy to use, and requires almost no work if we want to expand it. Allowing for the conversion of new structs simple requires the addition of the    attribute, while we have to do nothing at all if we modify our structures to include more, less, or different data.","titles":[]},"189":{"title":"Performance","content":"How about performance?I wrote a little test that both serialises and deserialises hundreds of thousands of times, and repeats that process several times to make sure we get accurate results. You can find the full code of it   on my GitHubHere are the results:Using   ,\n– converting a 16 byte structs to an array one million times takes 4.86 seconds;\n– converting an array to a 16 byte struct one million times takes 3.85 seconds.This means that a single call to either of our methods takes less than 5 microseconds.That is pretty good!With this performance we can easily write and read thousands of networking messages per second before we will notice the performance impact. That is easily enough for most games and other real-time applications.There is another kind of performance measurement that is important however – and especially so when it comes to networking: Bandwidth.The struct I ran the tests with consisted of exactly 16 bytes. That means that in principle we should be able to write it into a byte array with length 16. The BinaryFormatter however – and this is related to the other features it has – writes a total of 218 bytes to the array.Suffice it to say: That is a whole lot more.The advantage of this is, that the object that is deserialised will actually be of the correct type. I merely made the method generic so that we could perform the cast and return the structure boxed in the result of   .There are cases were we care less about the amount of data, and prefer to handle our data in this way. For this post however, I want to find a method that results in an array as small as possible.","titles":["BinaryFormatter"]},"190":{"title":"BinaryWriter /  BinaryReader","content":"Our second case study will be two other .NET classes:   BinaryWriter  and   BinaryReaderThese classes are much simpler. They do little more than allowing us to write and read primitive types like integers and booleans to and from an arbitrary stream.This means that we cannot write the entire structure to our stream with just a single line of code any more. Instead we need to write and read all fields manually:Using these methods is similarly easy to the ones above:In this case, the returned array is indeed exactly 16 bytes long.","titles":["BinaryFormatter"]},"191":{"title":"Performance","content":"But how does this manual approach measure up in performance?Very well!In my test, the times for serialising and deserialising went from 4.86 and 3.85 down to 0.50 and 0.20 seconds respectively (again for one million conversions each).It turns out this approach is not only space efficient, but it is also around ten times faster than the previous one – seemingly no reason to look back!In fact, there is an optimisation we can make to increase performance even further: We do not have to create new   s and   /  s for each method call. Instead we can reuse them – either by having static ones (watch out for thread-safety!) or by keeping them in whatever object manages for example our network traffic.Doing so drops my measured time down to 0.14 and 0.11 seconds respectively.Note that the same optimisation can be applied to the first method. However – while positive – the performance increase is much less than in this case, relative to the overall much worse time.","titles":["BinaryFormatter","BinaryWriter /  BinaryReader"]},"192":{"title":"Some concerns","content":"If we do look back to the code however, note how if we add another structure that we would like to serialise, we have to add the two methods to it, and adapt them to its fields.Further, if we change one of our structures, we have to make sure to reflect that change in both of these methods. We are bound to forget – especially when adding a new field – which could easily result in a small debugging nightmare.Ideally we can find a solution that is fast, uses little space, and does not require us to continuously maintain our serialisation code.","titles":["BinaryFormatter","BinaryWriter /  BinaryReader"]},"193":{"title":"Marshalling","content":"The last approach we will take a look at is that of marshalling.Marshalling refers to using both managed and unmanaged data and the transfer between them. By default, any object created in C# lives in managed memory, which has a lot of advantages – such as automatic garbage collection. Using unmanaged memory on the other hand is more difficult in C#, and requires us to allocate and free space manually. If we forget to do so, we may cause memory leaks that will eventually cause our application to crash.All of the functionality we are interested in can be found in the static   Marshal  class.Specifically, we will use:to determine the byte size of our structs;   \nto allocate unmanaged memory;   \nto marshal (copy) our structure to the allocated unmanaged memory;   \nto marshal (copy) from unmanaged memory back to our structure;   \nto copy between the unmanaged memory and our byte array;   \nto free the allocated memory;Using these methods we can construct the following methods:Note that due to the unsafety of using unmanaged memory, we may want to use a   try – finally  block to make sure the memory will always be freed, even if something goes wrong. For brevity, this is left out here.When testing our code, which again is as easy to use as before – in fact the method signatures are exactly the same as our first pair – we see that it indeed works as we hope.Without any code inside our structures and completely generic methods there is no need to write or maintain any code when adding or modifying structures.Further the resulting array is the expected 16 bytes long.","titles":["BinaryFormatter"]},"194":{"title":"Performance","content":"When running these methods through the tests, converting structs to byte arrays and vice versa takes a mere 0.47 and 0.60 seconds respectively (again for one million calls).","titles":["BinaryFormatter","Marshalling"]},"195":{"title":"Comparison","content":"Here is a table with the results from the performance tests:16 byte struct  struct to array  array to struct    binary formatter (218 byte array!)  4.86s  3.85s   binary writer/reader  0.50s  0.20s    binary w/r (singleton)   0.14s   0.11s   marshalling  0.47s  0.60sClearly, if what we care about most is performance, writing and reading our data manually, using shared    and    objects is the fastest method.On the other hand, the    and    methods allow for much easier reuse and make our code significantly more robust to change since there is no code to update and maintain.To provide some more data, here are the results from the same test, but this time with a 128 byte structure:128 byte struct  struct to array  array to struct    binary formatter (218 byte array!)  17.32s  14.47s   binary writer/reader  1.48s  0.66s    binary w/r (singleton)   0.78s   0.56s   marshalling  0.84s  0.75sWe can see that the relative ordering of the different measurements is still the same. However, note how the    and    measurements are getting significantly closer to the    ones.While I would not necessarily encourage structures of this size, I would argue that marshalling is the best approach for large structures in almost every case. The slightly slower performance is easily justified by the much more maintainable code.In fact, I would go as far and say that even for small structures the ease of using marshalling is still top advantageous despite the lower performance.In the end, binary serialization is unlikely to ever be a bottleneck, and unless it is, we should choose the option that fulfils our requirements of small array size and ease of use.","titles":["BinaryFormatter"]},"196":{"title":"Conclusion","content":"We took a look at three – and a half – different ways of converting between structs and byte arrays.Judging by memory usage, performance, and ease of use, there is no clear winner – only a clear loser unless we specifically need the additional functionality of   .However, in marshalling we found a method that is reasonably fast, while acing our other requirements.While in extremely performance critical code we may want to write our data manually, marshalling is likely the best alternative in the vast majority of cases.Feel free to let me know if you agree with this analysis, or if you have other methods of achieving the same result that may be worth looking into.Enjoy the pixels!","titles":["BinaryFormatter"]},"197":{"title":"基本原理#","content":"注意：事先声明，本节内容大多源于  this wonderful article by Matt Zucker ，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。让我们从最基本的柏林噪声函数看起：函数接收  三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值  的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示：图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。举个例子来理解伪随机，比如我们从圆周率π（3.14159...）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。图2：各顶点上的梯度向量随机选取结果请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成：采用这些特殊梯度向量的原因在  Ken Perlin's SIGGRAPH 2002 paper: Improving Noise 这篇文章里有具体讲解。注意：许多介绍柏林噪声算法的文章都是根据最初版柏林噪声算法来讲解的，预定义的梯度表不是本文所说的这12个向量。如图2所示的梯度向量就是最初版算法所随机出来的梯度向量，不过这两种算法的原理都是一样的。接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子：图3:各个距离向量接着，对每个顶点的梯度向量和距离向量做  点积 运算，我们就可以得出每个顶点的影响值：这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦：复制代码换句话说，如果两向量指向同一方向，点积结果为：复制代码如果两向量指向相反方向，则点积结果为：复制代码如果两向量互相垂直，则点积结果为0。复制代码点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。下面通过一副彩色图，直观地看下各顶点的影响值：图4：2D柏林噪声的影响值下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）：复制代码至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数：  fade函数 ，通常也被称为  ease curve (也作为缓动函数在游戏中广泛使用)：图5：ease curveease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式：基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。","titles":[]},"198":{"title":"代码实现#","content":"在本节开始前我需要重申一遍，代码实现是C#版本。相比  Ken Perlin的Java版本实现 做了小小的改动，主要是增加了代码的整洁性和可读性，支持噪声重复（瓦片重复）特性。代码完全开源，可免费使用（考虑到这毕竟不是我原创发明的算法 - Ken Perlin才是！）","titles":[]},"199":{"title":"准备工作##","content":"第一步，我们需要先声明一个排列表（permutation table），或者直接缩写为  数组就行了。数组长度为256，分别随机、无重复地存放了0-255这些数值。为了避免缓存溢出，我们再重复填充一次数组的值，所以数组最终长度为512：复制代码数组会在算法后续的哈希计算中使用到，用于确定一组输入最终挑选哪个梯度向量（从前面所列出的12个梯度向量中挑选）。后续代码会详细展示  数组的用法。接着，我们开始编写柏林噪声函数：复制代码上面的代码很直观。首先，对输入坐标使用求余运算符%，求出[0,repeat)范围内的余数。紧接着声明  三个变量。它们代表了输入坐标落在了哪个单元正方形里。我们还要限制坐标在[0,255]这个范围内，避免访问数组  时，出现数组越界错误。这也产生了一个副作用：柏林噪声每隔256个整数就会再次重复。但这不是太大的问题，因为算法不仅能处理整数，还能处理小数。最后，我们通过  三个变量（也就是  的小数部分值），确定了输入坐标在单元正方形里的空间位置（就是前面所示的小蓝点）。","titles":["代码实现#"]},"200":{"title":"Fade函数##","content":"现在我们需要用代码表示前面所提到的fade函数（图5）。正如上文所提，函数的数学表示：代码实现如下：复制代码代码所计算得出的  变量将在后面的插值计算中使用到。","titles":["代码实现#"]},"201":{"title":"哈希函数##","content":"柏林噪声哈希函数用于给每组输入计算返回一个唯一、确定值。哈希函数在维基百科的定义如下：哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法，输入数据有任何细微的不同，都会令输出结果完全不一样下面代码就是柏林噪声算法所使用的哈希函数。它使用了早前我们声明的  数组：复制代码代码的哈希函数，对包围着输入坐标（小蓝点）的周围8个单元正方形的索引坐标进行了哈希计算。  函数用于将输入值增加1，同时保证范围在[0,repeat)内。如果不需要噪声重复，  函数可以简化成单纯将输入值增加1。由于哈希结果值是从  数组中得到的，所以哈希函数的返回值范围限定在[0,255]内。","titles":["代码实现#"]},"202":{"title":"梯度函数##","content":"我时常认为Ken Perlin的最初版算法里的  函数写法过于复杂，令人费解。我们只要明白  函数的作用在于计算随机选取的梯度向量以及顶点位置向量的点积。Ken Perlin巧妙地使用了位翻转(bit-flipping)技巧来实现：复制代码下面代码则是以另一种令人容易理解的方式完成了这个任务（而且在很多语言版本的运行效率都优于前面一种）：复制代码以上的源码可以  点击这里 查看。无论如何，上面的两种实现并没有实质差别。他们都是从以下12个向量里随机挑选一个作为梯度向量：随机挑选结果其实取决于前一步所计算得出的哈希值（  函数的第一个参数）。后面3个参数则代表由输入点指向顶点的距离向量（最终拿来与梯度向量进行点积）。","titles":["代码实现#"]},"203":{"title":"插值整合##","content":"经过前面的几步计算，我们得出了8个顶点的影响值，并将它们进行平滑插值，得出了最终结果：复制代码","titles":["代码实现#"]},"204":{"title":"利用倍频实现更自然的噪声#","content":"最后让我们再思考下，除了前面所讲的计算，还有其他办法可以令噪声结果更加自然吗？虽然柏林噪声算法一定程度上模拟了自然噪声，但仍没有完全表现出自然噪声的不规律性。举个现实例子，现实地形会有大段连绵、高耸的山地，也会有丘陵和蚀坑，更小点的有大块岩石，甚至更小的鹅卵石块，这都属于地形的一部分。那如何让柏林噪声算法模拟出这样的自然噪声特性，解决方法也很简单：我们可以使用不同的频率（frequencies）和振幅（amplitudes）参数进行多几次柏林噪声计算，然后将结果叠加在一起。频率是指采样数据的间隔，振幅是指返回值的幅度范围。图6：不同频率和振幅参数下的柏林噪声结果将所有结果叠加在一起，我们就能得到以下结果：图7：图6所有噪声的叠加结果很明显，这样的噪声结果更加令人信服。上面的6组噪声被称之为噪声的不同  倍频(Octave) 。随着倍频增大，噪声对于最终叠加噪声的影响程度变小。当然，倍频组数的增加，会线性地增加代码执行时间，在游戏运行时使用噪声算法，再好不要使用超过几组倍频（比如，当你想在60fps下模拟火焰特效时，最好不要这么干）。然而，做数据预处理时，就很适合使用多组倍频叠加来模拟更自然的噪声（比如用于提前生成游戏地形等）。那我们应该分别挑选多大的频率和振幅来进行噪声计算呢？这个可以通过  persistence 参数确定。  Hugo Elias 对persistence的定义使用如下：以上公式  的值取决于倍频数量，代码实现也很简单：复制代码","titles":[]},"205":{"title":"UNITY","content":"","titles":[]},"206":{"title":"什么是“波函数坍塌”？","content":"这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才有了一个比较霸气的名字而已。开发这些模型或者贴图合成技术是为了能使用一块很小的由人工制作的贴图或者模型来生成大量相似的贴图或者模型。这样可以有效的减少人工作业，提升效率。当然可能有人会有这样的疑问，现在基于GAN的AI看起来能够生成又是动画又是图片的，还有这种技术存在的必要吗? 答案当然是有存在的必要，首先GAN需要海量的样本去训练，有生成这么多样本的劲，大概早就做完游戏了，其次是AI生成的不一定能满足业务需求，而且使用者并没有调教的可能性，而在做贴图或者模型合成时，实际上只需要一个样本就可以完成所有的工作了。接下来要简要介绍下基本的原理。","titles":[]},"207":{"title":"基本原理","content":"“波函数坍塌“主要是依赖于样本相邻各点的布局结构，以这些结构作为特征，在一个更大的空间上生成满足样本结构约束的新数据。以贴图合成为例，假设在输入贴图中有且仅有一点坐标是 x,y，颜色为   ，上下左右四个点的颜色分别是    。那么在输出贴图中，如果存在一点颜色为    ，那么它的上下左右四个点的颜色必须是    。实际上我们可以建立更复杂的相邻布局约束，比如说以贴图中某个点周围的不仅上下左右，还有对角线上的4个点，总共八个点建立约束条件，甚至是上下左右四个点的上下左右总共12个点。不过本文只会探讨受上下左右四个点约束的情况。所以我们的算法就是根据输入贴图提供的这种约束关系来生成输出贴图。这是一个搜索的过程，实际上是一个np hard问题，也就是说，只有当我们搜索了所有的可能性时，才一定能获得一个结果，当然这个结果可能是成功合成贴图，也可能是失败了，当对最终生成图片存在外界约束时，会有更大的可能性失败。虽然以贴图为例来说明，但是本文的初衷是为了能够生2d游戏的地图，所以接下来将仅介绍2d下的离散模型合成技术。在2d游戏开发中，一般会用瓦片（tiles）贴图来构成地图，其中瓦片会有特定的几何形状，然后通过瓦片的放置来完成地图。本文以及提供的代码只会考虑正方形的瓦片，对于正方形瓦片来说就和上面的解释完全一致了。最后不得不列一下我觉得还蛮重要的公式，该公式描述了上文中提及的一致性约束。设输入模型为 E，输出模型为 M ，那么当 M与 E 一致时，则对于 M中任意一点 x ，存在    ，且    属于 E ，满足：其中， x 是 M中一点，而    是 E中一点，    则是几何纬度上正负向的单位向量，3维下是    ，2维下则是    。接下来当然是要介绍具体的算法了。但是首先还是需要将问题重新描述一下。","titles":[]},"208":{"title":"描述问题","content":"我们需要通过一个样例模型，然后给予一个种子来生成一个更大的模型。在2d情况下，模型会被描述为一个二维矩阵，矩阵中的每个点都是一个非负整数，不同的整数代表一个瓦片的种类，0表示空瓦片。我们需要设定输出模型的大小比如一个10*10的矩阵，然后通过一个特定的种子来生成随机数，根据这个随机数去遍历所有的可能性并找到一个合适的解。所以我们的程序至少需要做下面几件事：载入瓦片信息，种类编号和瓦片的图片。  载入输入模型信息，即输入模型矩阵，矩阵的值为瓦片种类id，然后分析输入模型，得到约束条件矩阵。  根据约束矩阵，以及随机数去搜索输出模型。  输出（可视化）输出模型。显然，第三步是最为麻烦的，也是最困难的，其次是第二步，我们需要得到一个约束矩阵，然后第一和第四步都是常规操作。","titles":[]},"209":{"title":"获得约束矩阵","content":"约束矩阵描述了在输入模型中，相邻点的布局关系。当我们为输出模型布局时，我们可以在某一点填入一个特定的瓦片id，然后当填充这个瓦片相邻的四个瓦片时，通过查询约束矩阵，我们可以知道在当前瓦片id下，它上方的位置只能是特定的几个id。同理就可以推导出其他三个瓦片能够选择的id。所以当生成一个2d模型时，需要4个约束矩阵，分别代表x轴正向，负向，和y轴正向，负向的约束。每个约束矩阵的长度为总的瓦片id数，宽度也是总的瓦片id数，其值为bool或者是0或1，用来表示当当前点上的瓦片id是某个值时，其相邻对应位置瓦片允许的值。写个简单的例子，对于输入模型矩阵    的正的右侧，也就是x轴正方向，可以得到如下的约束规则：0-1，1-2，2-3，2-1，1-0，0-0。整理成矩阵也就是    ，这个矩阵等于它的转置矩阵，然后我们会有4个类似这样的约束矩阵对应不同方向的邻居，我们使用当前的瓦片id去查询就可以得到相邻瓦片允许填入的瓦片id了。","titles":[]},"210":{"title":"搜索算法","content":"搜索算法部分是最为困难的部分了。我们需要保存一个记录矩阵（catalog），该矩阵与最终输出模型大小相同，比如输出模型是10  10的这个记录矩阵也是10 10的。在这个记录矩阵中，每个元素会是一个集合，表示当前该点可以填入的瓦片id的集合，当该点可填入瓦片id集合为空集时，说明走了一条错误的路径，需要回退。然后我们的搜索算法会按照之前走过来的路径回退到上一个操作点，同时这个记录矩阵也需要回退相应的步数。对于记录矩阵的回退，需要记录一个类似数据库的ahead log的东西，来记录所有对记录矩阵的操作，当产生回退时，只需要沿着这log向前恢复就可以。对于搜索算法的前进和回退，在我参考的论文里没有提及具体的方式，经过一段时间的尝试，我建立了一颗树来记录搜索的路径，当产生回退时，树的当前节点会被标记为不可通行，便不会向这片树枝搜索了。如上图所示，灰色的节点表示还没探索到，实际上还不在树里，红色的节点表示需要回退的节点。蓝色的节点表示已探索或者待探索的节点，绿色的箭头表示已经探索的路径。五边形节点表示根节点，一旦在根节点发生回退说明，搜索失败，并没有找到合适的输出模型。正方形节点表示选择点操作，当游标在正方形节点上时，等于选取该节点记录的点为当前点。圆形节点则表示，为当前点选择了一个特定的瓦片，该瓦片的种类取决于记录矩阵在该点允许的选择，然后会根据约束矩阵，更新记录矩阵，当发现更新后记录矩阵存在空集便会回退。最终会有如下的搜索过程：建立搜索树，找到所有的点，并将其放在根节点下边，随机选一个节点，将游标移动到该节点，设定该节点对应的点为当前节点，然后根据记录矩阵中的值，随机选择一个瓦片填入，并根据约束矩阵更新记录矩阵。  找到剩余所有没有瓦片的点，将这些节点加入当前节点后面，然后将根据这些点与当前所选中的点的距离，计算一个权重，离得最近的会被最先搜索，如果没有新的节点可以选择，则生成成功。  根据权重和生成的随机数以及选择一个节点，根据记录矩阵在该点的瓦片集合以及随机数为该节点选择一个瓦片，然后根据约束矩阵以及当前选择去更新记录矩阵中相邻点的记录：  如果更新中发现某相邻点可选瓦片为空，则需要回退到上一个圆形节点，与此同时记录矩阵也要回退上一个圆形节点之后的操作，并将该节点标为禁止通行，并返回第2步，如果发现当前节点在根节点，则生成失败。  如果不为空，则根据随机数选择一个瓦片填入，并根据约束矩阵更新记录矩阵，然后返回第2步。","titles":[]},"211":{"title":"链接","content":"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian\\_docid=0M2y2bvM   https://zhuanlan.zhihu.com/p/65495333   https://github.com/mxgmn/WaveFunctionCollapse   https://github.com/BorisTheBrave/DeBroglie","titles":[]},"212":{"title":"对称性对抗游戏简介","content":"对称性对抗游戏是指参与游戏的玩家所拥有的资源、交互方式、受制规则、最终目标是相同或相近的，是一种公平、对称的零和游戏。如《英雄无敌》《文明》《卡坦岛》等游戏。我们参考文明的4X要素[  1] 搭建了一个多人回合制战略游戏，如下图所示：地图开始被“战争迷雾”所覆盖。玩家必须派遣探险者进入这片迷雾中，以揭露要扩张的土地，要开发的资源以及要消灭的对手。","titles":[]},"213":{"title":"地图的平衡性指标","content":"我们参考[  2] [  3] 两篇参考文献制定出评估对称性对抗游戏地图平衡性的两点指标。1. 战略特征（Strategic Feature）战略特征是指玩家在游戏中可以利用的战略资源。 战略特征的平衡是指每一名玩家在一定时间内获得基本相同的资源（包括类型和数量）。下面两张图显示了两名玩家战略特征不平衡的情况，蓝色玩家初始时可以获得更多的矿产资源，而黄色玩家的出生点附近几乎没有矿产资源，这会导致游戏初期黄色玩家的发展受限。2. 玩家占位符（player placeholder）玩家初始的出生点占位的分布也会影响游戏的平衡性。下面两张图显示了玩家初始占位符分布密度不同导致游戏性不平衡的情况。左图的玩家初始分布密集，这会导致这个地区的玩家在游戏前期相互碾压、发展受限；而右图中的黄色玩家在游戏前期缺少竞争，能够更好地发展自身建设。除了以上两点对游戏平衡性的影响之外，战略游戏地图的随机地图还要考虑到：地图的美观性、根据玩家的偏好定制参数、生成地图的效率等要求。","titles":[]},"214":{"title":"地图的生成过程","content":"1. 根据玩家的偏好定制地图参数在新建游戏之前，我们会让玩家根据自己的喜好定制地图参数，包括地图的尺寸、玩家的总数量、地图的类型（盘古大陆、大洲、海岛群）、水体比例、植被比例、岩石比例与资源的比例等。2. 生成地图的轮廓：柏林噪声柏林噪声（Perlin noise）指由Ken Perlin发明的自然噪声生成算法[  4] 。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。如下图所示：与椒盐噪声相比，柏林噪声有较好的连续性分布，可以更好的模拟自然界中的地形分布与地表装饰物分布。利用柏林噪声生成自然地图可以参考B站视频：  柏林噪声程序化生成随机地图 [  5] 。柏林噪声的生成采用伪随机数的生成方式，相同的“随机数种子”会生成相同的地貌。这也是很多随机地图生成器中会暴露“种子”让玩家根据种子生成地图的原因。如果想跟好朋友分享某个生成结果比较好的地图，只需要共享“种子”字符串，就能在随机地图生成器中还原出所生成的地形，而不需要把整个地图文件保存到本地再分享。Unity官方自带生成柏林函数的函数。我们引用了柏林噪声js库来进行地形的实现。我们利用柏林噪声的采样尺度来决定地图的类型是连续的大陆型地图还是离散的大洲型地图；将随机取到的连续噪声均衡化作为地图的高度图，根据用户设置的水体占比来制定海平面高度，最终生成的地形结果如下图所示：3. 玩家出生点的选择：米切尔最佳候选算法为了保证每位玩家两两之间的初始分布不会过近，我们在生成游戏地形后，在陆地上对玩家初始占位符进行均匀采样。为了兼顾效果与效率，我们最终选用米切尔最佳候选 算法（best candidate）。米切尔最佳候选算法是一种渐进、增量式的均匀采样方法。它每一轮采样都是从多个随机采样点中，保留与之前轮的所有采样点中最小距离最大的点作为本轮的采样结果。更加具体直观的算法解释可以参考:  算法可视化 [  6] 中有关米切尔候选算法的部分如下图所示：黑色点是之前轮已经确定的采样点，灰色点是本轮随机采样的候选点，每个候选点都选出与之前轮采样点中距离最近的距离，再从中选出最小距离最大的红色点作为本轮采样的结果。利用这种采样方式采样出玩家的初始占位符，可以避免任意两个玩家之间的距离过近导致游戏平衡性被破坏，如下图所示：4. 战略资源的分布采样出玩家的分布之后，我们将地图单元格分为两种类型：每个玩家占位符附近距离N以内的单元格为玩家区域（Player Zones），不隶属于任何玩家区域的单元格被称为隔离区或自然区（Natural Zones）。为了让每名玩家在游戏初始时具有公平的战略特征，我们对每位玩家的玩家区域内定额分配植被、岩石与矿产资源。根据用户设定的植被、岩石与资源占比分别计算出每位玩家区应当分配到的植被、岩石与资源数量，然后在每个玩家区域内不重不漏地采样出相等数量的植被、岩石与资源单元格。对于自然区，我们按照玩家设置的参数，采用米切尔候选算法均匀采样每一种资源。这样可以保证每位玩家在游戏初始时能够得到数量一致的战略特征。如下图所示：5. 边界情况处理用以上方式生成的地图在某些情况下会产生不好的结果，例如当水体比例过低时生成海岛地形，会导致水体不够划分不出海岛地形；当水体比例过高时，会由于陆地单元格分布不均导致出生在不同规模大小的岛屿上的玩家能够得到的战略资源再度失衡。对于这些边界情况，我们利用种子生长与泛洪填充等启发式生成方法生成地图，优先保证地图类型能够满足用户的需求，并尽可能保证水体与各种战略特征的资源逼近用户的设定。以下是我们在水体占比过低与水体占比过高时生成的地图，可以看出在这两种情况下依然能够保证所生成地图的平衡性：","titles":[]},"215":{"title":"生成地图质量的定量评估","content":"为了判断我们的生成随机地图算法是否具有良好的平衡性指标，我们设计了一套地图自动扩张算法：每个玩家以出生点占位符为种子，轮流从目前领土所毗邻的无人单元格中抽取一个进行占领以扩张势力范围，直到地图中所有的单元格都被有且只有一个玩家占领；然后我们统计每个玩家占领到的资源数量、距离最近的敌人距离，以及每个玩家与多少数量的玩家领土相邻。如下图所示：实验组是我们的算法生成的地图，对照组是根据水体与各种资源的比例随机采样地形、随机采样玩家分布得到的地图。如下方左侧是实验组生成的地图，右侧是对照组生成的地图：实验组与对照组各生成100次地图，统计每个玩家与其他势力最小距离的均值与方差、扩张完成后各资源占有量的均值与方差以及每位玩家潜在冲突势力的均值与方差，统计的结果如下所示：通过定量的统计结果可以看出，我们的方法生成的地图，玩家之间有更大的平均极小距离，这说明每位玩家的出生点占位符设置更加平衡；各种资源的分布方差均比对照组小，说明我们的战略特征分配与朴素的随机生成的地图相比更加均衡。综上所述，我们的地图生成结果能够保证对称性多人对抗战略游戏的平衡性。","titles":[]},"216":{"title":"","content":"","titles":[]},"217":{"title":"引言","content":"文章作者：  Mike Anderson随机生成的地图是   Roguelike  类游戏最独特的一点，它让游戏变得很有乐趣，因为玩家永远要面对新的挑战。但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。在这篇文章里，我会将自己在开发一款名为   Tyrant  的 Roguelike 游戏中使用的方法记录下来。我怀疑这可能只能算是一个原型，但是我之前也没有见过什么一本正经讲述生成 Roguelike 地图算法的文章。而且，它工作得还是比较令人满意的，所以，我愿意将它分享给大家。","titles":[]},"218":{"title":"这款算法的目标","content":"在写任何代码之前，了解自己的目标总是很重要的，这对编程很有帮助，哪怕你随后会做无数的修改。一个地牢（  Dungeon ）应该包含以下要点：一组相互连通的房间、门和通道  一个入口（向上走的楼梯）  一个出口（向下走的楼梯）  所有的空间必须能够到达最后一点尤其重要。要知道，你的玩家在契而不舍的努力之后，应该能够顺利通过这一层，不要让他们失望。另外，如果放了某个物品到地图上的某个空间，它应该不会被藏在无法到达的地方。","titles":[]},"219":{"title":"计划","content":"在我写 Tyrant 的时候，我尝试了很多种不同的算法来生成地图，这里所讲的是我能做到的最好的一个，也是目前游戏中使用的那个。我的灵感来自于此：“如果我是地下城的一个居民，那么我该怎么去建设我的地牢呢？”显然，我并不会将我的地下城建造成一个一个看起来不错的小房间，然后在中间用长长的通道连接起来。所以，当我需要为我的小怪物们提供更多空间的时候，我应该是拿起我的斧头，挖一个更大一些的洞。这样当他们有所需要的时候就会增加一些新房间——尽管它们看起来可能杂乱无章。有些地下城主可能想要用吊桥呀、陷阱呀什么的来守护比较“有趣”的房间，但是这些需求都异曲同工。由一个小的地牢开始，慢慢向四周扩散，直到整个地牢形成。这就是我们的计划。","titles":[]},"220":{"title":"算法","content":"在这个算法里面，“元素”代表着某种地图元素，比如：大房间、小房间、通道、圆形竞技场、保险柜等等。将整个地图填满土  在地图中间挖一个房间出来  选中某一房间（如果有多个的话）的墙壁  确定要修建某种新元素  查看从选中的墙延伸出去是否有足够的空间承载新的元素  如果有的话继续，不然就返回第 3 步  从选中的墙处增加新的元素  返回第 3 步，直到地牢建设完成  在地图的随机点上安排上楼和下楼的楼梯  最后，放进去怪兽和物品第 1、2 步很简单。只要你创建好地图就可以去做到。我发现，写一个    指令用来填充一个区域是比较有效的做法。第 3 步麻烦一些。你不能随意的寻找一个方块区域去添加你的元素，因为规则是要将元素添加到当前的地牢当中。这样会使得连接看起来比较不错，也确保了所有的区域都可以到达。Tyrant 的做法是：在地图上随机选择一个方块，直到找到横向或者纵向毗邻一个干净的方块那个。这样做的好处是：它给了你一个近乎公平的方式去选择某一面墙。第 4 步不太困难。我自己写了一个随机方法来决定建造哪一种元素。你可以自己定义它们，调整某些元素出现的权重，这会让你的地牢有自己的特点和侧重点。一个规划比较好的地牢会有很多规矩的房间，中间有长而且直的走廊连接。而洞穴则可能有一堆打洞以及曲折的小道等等。第 5 步更复杂一些，而且也是整个算法的核心。针对每一种元素，你需要知道它会占用的空间大小。然后你要去判断它是否和已经有的元素相交。Tyrant 使用了相对简单的一种方法：它会先得到要创建的元素所占用的空间大小，得到这个空间的数据，然后检查是否这个空间由土填满。第 6 步决定是否创建这个元素。如果这个待确定的空间包含有除了土之外的内容，那么就回到第 3 步继续。注意，大部分元素在这步都会被打回。不过这不是个问题，因为处理时间可以忽略。Tyrant 尝试着将某个元素加入 300 次左右到地牢中去，一般只有 40 次左右会通过这步。第 7 步会将新元素添加到地图上去。在这步，你还可以增加一些有趣的元素，比如动物、居民、秘道门和财宝什么的。第 8 步返回去创建更多的房间。确切的次数跟你地牢的尺寸以及其它参数有关。第 9 步要看个人喜好了。最简单的方法就是随机的去查找方块，直到找到一个空的位置去放置楼梯。第 10 步就是随机的创建怪兽。Tyrant 在这一步才加入游戏中大多数的怪兽，由少量的特殊怪兽或者生物会在生成房间的时候添加进去。就这样啦，这里所说的只是算法的规则，具体还要您自己去实现啦。","titles":[]},"221":{"title":"例子","content":"好了，在看了半天算法之后，我们来一个例子吧：Key:\\1. 第一个房间\\2. 随机选择一面墙\\3. 为新的通道元素进行区域搜索（包括两边的空间）\\4. 是空的，可以添加元素\\5. 选择另外一面墙\\6. 扫描寻找新的房间所占用空间：\\7. 这个地区也可以，那就添加一个新房间，再往里面扔一个宝箱 C（Chest）：\\8. 跟前面做法一样，我们增加一个新的通道元素\\9. 这一次，我们试着为第二个房间增加一个通道元素\\10. 扫描失败了，已经被占用\\11. 比较特别的元素，一个菱形的房间\\12. 添加一个隐藏的暗门，以及充满陷阱的通道：\\13. 继续……","titles":[]},"222":{"title":"总结","content":"好了，这就是我的算法，我希望它对你有用，或者从一个有趣的角度去看如何解决一个问题。","titles":[]},"223":{"title":"代码实现","content":"Java 代码实现  Java 代码实现 \n你可以通过   Open Processing  在浏览器里面运行它（需要做一些小修改）。它会创建一个图形化的地牢。Python Curses 代码实现  Python Curses 代码实现C++ 代码实现  C++ 代码实现C# 代码实现  C# 代码实现原文地址：  链接","titles":[]},"224":{"title":"Part1. 创建Solution path - 关卡通路","content":"关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。算法的第一部分是生成关卡的 Critical Path（通路），关卡由 16 个房间按照 4x4 的网格组成。方法是先在第一排随机找到一个起始房间，然后随机使相邻的房间成为通路的一部分，一直到最后一排，生成出口。找到通路之后，连接这些房间，然后再随机补充上非通路部分的房间，打通这些房间。如图顺序所示：然后为这些房间随机选取对应的预定义好的关卡模块。根据 Spelunky 的教学文章[  3] ，这里有 4 种不同的房间类型：这个关卡由16个房间按照4x4的网格方式组成，这里有4种不同的房间类型：0：不在critical path上，不会产生任何出口（可被忽略的）次要房间 (感谢洋芋君指出之前的翻译问题)  1：左右一定有出口  2：左右下一定有出口，如果有2号room在上方，也一定有上方出口  3：左右上一定有出口第一步在最顶部这行随机选取一格创建一个Start Room，房间类型对开始的房间来说没太大影响。一般来说，Start Room类型我们会选1或者2。每当一个Room被创建，首先总是类型1(左右)。然后要决定往哪边走。取一个均匀分布的随机数，从1到5。当1或2时，critical path向左；当3或4时，critical path向右；当5时，path向下。（当critical path碰到屏幕边缘，立即向下移动并同时切换左右方向。）这有个问题，如果我们向左或右移动，是OK的，因为我们创建的Room是一定有左右出口的。但我们要向下走，我们就得改变我们当前所在的房间了。所以生成器重写房间类型为2，覆盖当前的房间，现在我们可以向下移动了。当生成器移到下一个房间，会问我们最后创建的那个房间（也就是刚才我们头顶上那个）类型是不是2（底部有出口）。 如果是2，那么当前这个房间类型一定要是2或3（上方有出口）。因为2、3类型都有左右出口，启动算法从头再来一次。如果到了底部这一行，我们要尝试向下，那肯定不行了，我们放置一个Exit Room来取代向下的房间。现在我们已经生成了整个critical path（关卡通路，即图中那些暗红色的格子，游戏中是不显示的，这里只是为了举例）。接下来要做的最后一件事，我们要把4x4的网格中的空余部分放上类型为0的房间，这些房间并不在critical path上。这些房间在任何方向都不一定有出口，所以有时候会生成一些围墙。如果一列中有3或者4个Room 0，那这一列房间有几率成为一个蛇窝。如果我们要生成蛇窝的话，从上到下，放一列房间，类型为7 8 9，或者7 8 8 9，取决于我们希望这个蛇窝有多深。(这里的蛇和宝石并不像其他敌人那样随机生成，因为它们是这种地形的一部分，所以位置基本是固定出现。）蛇窝","titles":[]},"225":{"title":"Part2. 创建房间 关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。","content":"Spelunky并不像其他大部分游戏（平台游戏，platformer）在传统的2D tile-base的平台游戏中，你用关卡编辑器做出的地图可能看起来像这样：在这种类型编辑器里，是这样的，比如，在（64,128）这个位置是草的tile。但Spelunky完全不是这样。\n上一部分我们了解了Spelunky有4种基本房间类型（types）。这每个房间类型有8-16个模板。这些模板具备一个房间的基本布局，包括一些静态和概率tile的组合。\nRoom Templates（房间模板）\n每个房间类型都有一堆不同的模板。\n  译注：Derek Yu使用不同的布局，做了一系列的房间设计。比如你掉出去的房间（DROP）、掉入的房间（LANDING）、可以穿过的走廊（CORRIDOR）、不在关卡通路上的房间（NON-CRITICAL）。房间模板，嗯……看起来就像下面这样：1100000000   40L6000000   11P0000000   11L0000000   11L5000000   1100000000   1100000000   1111111111每个模板由10x8 的tile网格组成。\"0\"表示空，\"1\"表示100%是砖块，\"L\"是梯子，\"P\"是爬梯子上去的平台(platform)。现在你在看这个模板， 嗯，下面一排是地面，左边是2个tile宽的墙，上面有个小缺口，有个梯子可以爬到那。Static and Probabilistic Tiles( 静态和概率Tile )static tile就像传统关卡编辑器里一样，你让这里有个砖块，那这就永远是砖块了。上面模板里的\"4\" tile，就是probabilistic tile。\"4\"表示那有25%的几率会是一个能推动的障碍物，出现在梯子的顶部旁边。有经验的Spelunky玩家会一下认出这个：有时你爬到一个梯子顶部，旁边有个障碍物，你得推它，就可以进到下一个房间。有时候爬到梯子顶上旁边就没有这玩意。还有比如“这有33%的几率会出现个尖刺”，或者“这有一半的几率是空的，或者是砖块”。Obstacle Block( 障碍块）\"5\"和\"6\"就是所谓的Obstacle Block。Obstacle Block由 5x3 的tile网格组成，是个有趣的小结构，会让玩家针对这个障碍来思考自己的策略。Obstacle block本身也会由一些概率tile组成。下面是\"5\" 这个模板，表示放置在地上（\"6\"表示放置在空中）:00000   00102   71177规则和之前的一样，0是空，1是砖块。你能看出来，这是个小台阶。\"7\"有33%的几率是个尖刺，或者为空。如果运气不好，这里就得跳到那个台阶上面避开尖刺。\"2\"表示有一半的几率味空，或者是砖块。这就有意思了，有可能有个小砖块让你落脚不用踩到尖刺，也有可能除了小台阶，旁边都是空的，玩家得跳到上面去。你可以看出，这么个小障碍块，如果设计的好的话，游戏自己就会随机生成很多很多有意思的场景。译于2018-Jan-20原文链接最好用chrome打开，对，要科学，你懂了http://tinysubversions.com/spelunkyGen/http://tinysubversions.com/spelunkyGen2/https://indienova.com/u/root/blogread/5454   https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/","titles":[]},"226":{"title":"生成类","content":"最基本的生成方法类包括  和     一般都会继承于该类","titles":[]},"227":{"title":"Generate 流程","content":"创建playload,即IPipelineTask的上下文  创建pipelineTask,包括三个  ,  ,   PipelineRunner执行管道任务,将playload赋值给各个pipelineTask然后执行pipelinetask的  函数","titles":["生成类"]},"228":{"title":"pipelineTask","content":"你可以继承    然后分别覆盖  和  ,还有一般来说是FixedLevelGraphInputTask,主要是用来设置Payload.LevelDescription      主要是通过GraphBasedGeneratorGrid2D来设置Payload.GeneratedLevel 和 Payload.GeneratorStats,还有会实例化  以及下面的房间,参见      主要是根据PriorityCallbacks按照优先顺序执行回调函数,默认的回调函数,通过配置有以下   InitializeSharedTilemaps 即实例化   CopyTilesToSharedTilemaps 将rooms下的tile复制到SharedTilemaps 下  CenterGrid 将Generated Level下的子对象设置为0,0  DisableRoomTemplatesRenderers    禁用roomtemapltes下的显示  DisableRoomTemplatesColliders  禁用roomtemplates下的碰撞  还可以通过继承DungeonGeneratorPostProcessBase写你自己的后处理函数","titles":["生成类"]},"229":{"title":"Door sockets","content":"门锁..就是走廊和房间选中同一个锁,就能匹配的上","titles":["生成类","pipelineTask"]},"230":{"title":"对于连接处","content":"他会按照顺序copy到sharedtilemaps.所以,位于连接处的tile,如果后面的会覆盖前面的最终的合成则是下图","titles":["生成类"]},"231":{"title":"特效","content":"GameplayEffectSpec 是特效的runtime包含了特效的双方和target  包含了其他数据等级,持续时间等创建方法","titles":[]},"232":{"title":"添加特效到角色","content":"检查特效tag是否能够添加到角色身上","titles":["特效"]},"233":{"title":"特效  GameplayEffectScriptableObject 本身","content":"GameplayEffectDefinitionContainer  定义了特效的使用效果与条件   DurationPolicy和DurationModifier和DurationMultiplier构成了该特效的持续时间,以及是否立即使用   Modifiers 该特效对属性的修改  ConditionalGameplayEffects  暂时没看到使用的地方??GameplayEffectTags   定义处理特效之间的关系","titles":["特效"]},"234":{"title":"技能","content":"AbstractAbilitySpec是技能的runtime,包含了ability的scriptobject  ability的其他数据例如等级,词条等  角色字段","titles":["特效"]},"235":{"title":"技能释放流程","content":"ability的cost和cooldown都使用了GameplayEffectScriptableObject,这也是这个系统比较蛋疼的地方,就是每个ability都需要建立cost和cooldown的object.","titles":["特效","技能"]},"236":{"title":"检查cost","content":"检查cost特效身上的Modifiers字段,并计算最终值  然后和角色属性进行对比  Modifiers可以有多条,且有计算公式","titles":["特效","技能"]},"237":{"title":"检查cooldow","content":"冷却时间特效最终会被添加到人物的身上  该函数,主要是比对并找到人身上同tag的特效.然后检查该特效的TotalDuration","titles":["特效","技能"]},"238":{"title":"检查abilitytags","content":"","titles":["特效","技能"]},"239":{"title":"abilitytags","content":"定义了一些tag用来释放前进行检查是否能释放该技能例如检查自身是否能够匹配   如果是指定目标则检查目标身上是否能够匹配   SourceTags?暂时没有好的理解","titles":["特效","技能","检查abilitytags"]},"240":{"title":"CheckGameplayTags()被定义在每个ability下然后对其重写","content":"AscHasAllTags  用来检查   ,检查人身上特效的tags是否包含这些,如果没有包含则检查失败  AscHasNoneTags 用来检查   ,检查人身上特效的tags是否包含这些,如果包含则检查失败","titles":["特效","技能","检查abilitytags"]},"241":{"title":"释放前","content":"检查Tag   常用tag写死,比如眩晕等  自定义tag,通过判断   和   技能是否能够执行  检查释放消耗  检查冷却时间  检查其他自定义条件   是否装备指定武器  是否变身  是否隐身","titles":[]},"242":{"title":"释放后","content":"激活阶段   animalAction(角色动画)  waitAction(等待动作)  释放阶段   触发释放特效  前摇  执行阶段   释放project  其他爆炸物的释放  完成阶段   后摇角色动画","titles":[]},"243":{"title":"攻击动作","content":"投射物  子弹  弹幕攻击  特效","titles":["释放后"]},"244":{"title":"其他动作","content":"角色动作  等待时间技能  说明  动作    跳跃攻击  跳跃离开危险或跳入战斗之中  跳跃动画,并且使用抛物线落到指定点的一个特殊动作   旋风  旋转的死亡之舞挥砍所有在旋转路径上的敌人  旋转动画并且移动的一个特殊动作   双手挥击  当装备两把武器时可在一次攻击中击中两个敌人或者攻击一个敌人两次  检查附近敌人是否多个,是多个则击中两个,不然击中一个两次.特殊动作","titles":["释放后"]},"245":{"title":"特效","content":"释放特效(不需要碰撞触发的特效)   全体加血  召唤怪物  击中特效  击杀特效","titles":["释放后"]},"246":{"title":"特效动作","content":"伤害   伤害类型 毒,冰冻,火焰  自己附加状态 附加属性(力量,智力),附加伤害,附加伤害百分比,附加暴击等  敌人附加状态 扣除属性等  召唤   召唤object  召唤物的属性","titles":["释放后","特效"]},"247":{"title":"案例","content":"技能  说明  特效1  特效2    重击  强力打击增加造成的伤害并震退敌人  伤害特效(附加伤害,附加伤害百分比)  击退特效   击晕  成功的攻击将使敌人晕眩并提高你的命中率  普通伤害  击晕特效,有一定的时间   狂暴  威力强大但不计后果的攻击可以增加伤害和命中率但忽视防御  伤害特效(提高属性)  降低自身防御为0有一定的时间   大叫  警告队友迫近的危险并提升他们的防御力  增加防御 有一定的时间","titles":["释放后","特效"]},"248":{"title":"技能词条(skillterm)","content":"技能根据等级分为入门,小成,大成,巅峰,圆满,每个等级可以解锁额外的词条","titles":["释放后","特效"]},"249":{"title":"TAG","content":"每个特效可以授予角色tag","titles":["释放后"]},"250":{"title":"武器技能","content":"为了解决攻击使用什么技能,且装备的打造问题..武器可有技能\n武器决定了有哪些技能,比如火系弓箭技能..\n武器没有等级概念???","titles":["释放后"]},"251":{"title":"如果不同的职业技能都能升级到20级.那就没有职业差异化了,儒家,也可用20级道家的技能.这样是不对的","content":"方法一,等级提升添加境界限制..  方法二, 技能书分为初级,中级,上级,顶级..然后境界限制学习的条件..书的等级限制能炼到的等级  ...略麻烦升级可以解锁一条额外属性...  一个招式洗练可以修改额外属性.以及招式将qe的提示改成左右键,并去除????","titles":["释放后"]},"252":{"title":"npc任务指示的显示?","content":"进入地图后.拉取该地图所有npc的任务  然后实例化任务  则进行开始检查   是否自动开始?如果条件满足直接触发任务,添加到玩家任务列表,或者发送邮件提示之类的  是否有接取条件,如果有的话检查是否变成可接状态QuestIndicatorManager不是单例相当于控制器.每个npc身上都有,主要是控制npc的指示显示","titles":[]},"253":{"title":"任务接受流程","content":"组件Targetable中执行Interact(),会触发QuestGiver.StartDialogueWithPlayer  打开对话框QuestGiver.GiveQuestToQuester","titles":["npc任务指示的显示?"]},"254":{"title":"任务分类","content":"MoveTo型任务（移动）   触发剧情  新功能开放   Farm型任务（重复）   杀狼,动物  搜集特殊物品,怪物掉落或者采集物品的时候偶尔采集到  木材采集,钓鱼,制作料理  地图内找寻物品,地图内传话,送礼物,酒  追杀人物(地图内,地图外)  杀人(地图内,地图外)  镖局任务,跨地图送货,送信   Collect型任务（收集）   收集包(星露谷)  图书馆(星露谷)  藏经阁   Hunt型任务（狩猎）   Boss   Puzzle型任务（解谜）   Challenge型任务（挑战）   暗黑3 大秘境 xxx层   附加类：Storytelling型任务（叙事）","titles":["npc任务指示的显示?"]},"255":{"title":"显示","content":"对话   一条随机话语  如果有任务,任务按钮  如果有对话,显示对话按钮  更多","titles":["npc任务指示的显示?"]},"256":{"title":"npc生成方式","content":"","titles":[]},"257":{"title":"默认的npc","content":"会存储必要数据,比如状态,位置等   中从  加载数据,位置一般是固定的,从land中读取","titles":["npc生成方式"]},"258":{"title":"运行时的npc","content":"会存储   中从  加载数据,根据land或者house,随机位置","titles":["npc生成方式"]},"259":{"title":"怪物","content":"不存储  加载land后,则会转换  进行转换生成的点,然后进行生成","titles":["npc生成方式"]},"260":{"title":"只运行AI的npc","content":"初始化的时候加载,影响局势的(君主,帮派)和与角色由关系的npc  处理ai事件.如果进入地图.则实例化","titles":["npc生成方式"]},"261":{"title":"场景资源","content":"会存储   创建的时候,则会根据地图id从  中加载数据","titles":["npc生成方式"]},"262":{"title":"用户物品","content":"会存储   创建的时候,则会根据地图id从CharacterSpaceProxy中加载用户数据","titles":["npc生成方式"]},"263":{"title":"代码中创建实体,然后绑定view","content":"","titles":[]},"264":{"title":"在link的时候,创建相关实体","content":"SpaceWaterList.cs中,这种注意创建的实体和parent没有关系..如果是在land中,需要在销毁land的时候,同时销毁该实体.则不能使用该方法..SpaceNPCList.cs中,通过ConverEntitys.ConvertGameObejct对游戏对象进行转换..注意其上的  组件转换目标设置为   ,在这里   可以继承   就可以设置parent.","titles":[]},"265":{"title":"怪物等级","content":"在普通难度上，怪物的等级由怪物的种类决定，不受场景等级的制约。  在噩梦和地狱的难度中，怪物的等级由场景等级决定。普通怪物的等级为场景等级，场景的蓝色精英怪物等级为场景等级加2，金色怪物等级为场景等级加3.例如:85级的场景中会出现普通怪物85级、boss怪物87级、精英金怪兽88级3种等级的怪物   关底boss等级固定 ，与场景等级无太大关系。","titles":[]},"266":{"title":"怪物的分类","content":"要研究暗黑2的物品掉落系统，首先要了解暗黑世界中的怪物。暗黑中怪物分为如下几个种类等级：  \n1.（eBoss）：中文中我们一般称之为.【关底BOSS】，如安达里尔、督瑞尔、墨菲斯托等  \n2.（Boss）：即【普通BOSS】，这些怪物有且仅有6个：  \n☆血乌 格里斯瓦得 罗达门特 召唤者 衣卒尔 尼拉塞克  \n3.（Unique）：中文中我们一般称之为【精英怪】，游戏中表现为其名字为暗金色。分为固定精英怪（Super Unique）和随机精英怪（Random Unique）。固定精英怪拥有固定的名字和固定的出现地点，拥有固定属性以及可能出现的随机属性。如“毕须博须”、“暴躁外皮”等。随机精英怪则是在游戏中随机出现，名字由词缀“XXX之XXX的”的随机构成，并随机获得一些特殊属性。  \n4.（Minion）：中文中我们称之为【随从】，即精英怪身边的与其同类的喽啰怪物。在游戏中外观和普通怪一样，但隐藏有带领它的精英怪的部分特殊属性。  \n5.（Champion）：中文中我们称之为【头目】。游戏中表现为其名字为蓝色。有时候它们能从其名字的前缀（如果有的话）中获得特殊属性。  \n6.（Normal）：普通小怪。游戏中表现为其名字为白色。","titles":["怪物等级"]},"267":{"title":"财宝阶层","content":"TC是一个包含了众多物品清单的多层目录，一个大TC目录中可能包含有多个子TC目录。 怪物死亡后掉落的物品就是从其TC目录的物品清单中按照一定规则随机取出物品。\n但我们玩家在日常口头交流时，常常只讨论武器和防具的掉落，并将TC目录简化为一个数字等级，简称为怪物的TC。比如我们常说的墨菲斯托的TC=78，暴躁外皮的TC=87等等。☆TC由3到87，按3递增（3、6、9…81、84、87），共有29个递增的TC阶层。","titles":["怪物等级"]},"268":{"title":"掉落规则","content":"","titles":["怪物等级"]},"269":{"title":"物品等级","content":"物品等级常用术语为ilvl，注意这个等级不是使用装备需要的等级，而是一个内在的等级数据，一定程度上决定了装备可能的质量。打怪掉落  打怪刷到的装备等级=掉装备怪物的等级   翻箱子掉落 开箱子掉落的装备等级=场景等级   在NPC那里买到 商店买的装备等级=人物等级+5   在NPC那里通过赌博得到  赌博得的装备等级=人物等级+4或-5**物品等级最大99。**物品等级最大的作用有两个：决定了该物品的最大出孔数,比如，同样是灰幕寿衣，如果是25级以下怪物掉落的，它的物品等级就是25以下，它最大的打孔数就是3孔；如果是高于25级怪物掉落的，它的物品等级也就高于25，这件衣服最大孔数就是4孔。  物品等级决定了装备的词缀，物品等级越高，可能出现的词缀就越好。","titles":["怪物等级","掉落规则"]},"270":{"title":"词缀等级","content":"物品的属性来源于物品所具有的词缀。游戏中每一种词缀都代表了某一种特定的属性，一旦物品拥有了某个词缀，那么就一定具有这个词缀所代表的属性。所有的词缀总共分为2类：前缀和后缀。前缀和后缀又分别按照所代表属性的不同分成组。比如图中的绿框内是前缀，红框内是后缀，它们对应下面蓝色字体的“属性”，珠宝匠对应4孔，偏向对应格档速度和格档机率。词缀种类非常多，蓝色装备最多可以从词缀中选择不同的两个，黄色最多选择6个。而不同词缀又是有不同等级的，  高等级词缀当然只能出现在物品等级和品质等级更高的装备上。   \n前缀共分为三个系26个小组：  \n第一系是进攻型前缀共计14小组：  \n编号110组加准确率；编号105组增强伤害；编号111组同时加准确和伤害 或者 按等级加准确；编号123组加对恶魔的准确和伤害；编号142组加对不死的准确和伤害；编号137组加冰伤害；编号138组加火伤害；编号139组加电伤害；编号140组加毒伤害；编号113组吓跑怪物；编号121组杀死敌人加法力；编号107组所受伤害转为法力；编号114组加mf；编号112组加照亮范围  \n第二系是防御型前缀共计11小组：  \n编号117组加抗冰；编号118组加抗火；编号119组加抗电；编号120组加抗毒；编号116组加全抗；编号115组加法力；编号101组加防御；编号108组加耐力；编号109组按百分比加耐力；编号122组增加凹槽；编号141组增加投掷物数量；  \n第三系是技能前缀有1个小组：  \n编号125小组：加人物技能；加亚马逊单系技能；加野蛮人单系技能；加圣骑士单系技能；加死灵法师单系技能；加法师单系技能；加德鲁伊单系技能；加刺客单系技能；   \n后缀共分为四个系35个小组：  \n第一系是进攻型后缀共计16小组：  \n编号15组加最小伤害值；编号14组加最大伤害值；编号10组加冰伤害；编号12组加火伤害；编号13组加电伤害；编号16组加毒伤害；编号27组偷取生命；编号28组偷取法力；编号24组；编号20组阻止怪物；编号4组忽略目标防御；编号7组加攻击速度；编号9组加施法速度；编号21组加额外金币；编号22组加mf；编号25组同时加照亮范围和准确；  \n第二系是防御型后缀共计11小组：  \n编号1组物理伤害减少；编号2组魔法伤害减少；编号29组减少中毒时间；编号11组冰冻时间减半；编号35组加快速奔跑；编号18组加快速打击恢复；编号8组加格挡；编号6组反弹伤害；编号39组投掷物恢复数量；编号37组装备自动修复；编号39组永不磨损  \n第三系是技能后缀有1个小组：  \n编号44组：加亚马逊单个技能(包括聚气)；加野蛮人单个技能(包括聚气)；加德鲁伊单个技能(包括聚气)；加死灵法师单个技能(包括聚气)；加圣骑士单个技能(包括聚气)；加法师单个技能(包括聚气)；  \n第四系是属性后缀共计7个小组：  \n编号31组加力量；编号17组加敏捷；编号23组加能量；编号41组按等级加法力、按等级加生命或按等级同时加法力和生命(仅限蓝色装备)；编号26组加生命；编号19组自动恢复生命；编号30组减需求；    当装备从怪物身上掉落时，或是当人物离开城镇导致商店里的商品更新时，或是当人物把物品从商人那里买下来时，或是当你用赫拉迪克方块合成新的物品时，物品的属性就在那一瞬间随机生成了。生成时系统将会随机挑选一些词缀安排给这个物品，于是物品就有了变化莫测的属性取最高 qlvl or ilvl 为X 当｛ X < (99-Q/2) ｝时，则该物品是低等物品,词缀等级（A）按照  { A = X - Q/2 } 计算词缀等级。举个栗子：我有一件地狱A1冰冷之原掉的装备，由于它是68场景等级（M），所以怪物是68-71级之间，掉落的装备就是68级-71级物等。比如按最低的68白怪掉的一个战帽，他的品质等级（Q）是34级，那么，带入公式 68 < [ (99-34/2) = 82 ]，满足公式一。词缀等级按照 {A= 68 - 34/2 = 51}计算，他的词缀就是51级。当｛ X > (99-Q/2) ｝时则是高等物品 按照 {A=2*X-99} 计算词缀等级。举个栗子：超市金怪出了一个君主盾（统盾），85+3，物等（I）88级，大于品质（Q）72级，带入公式 { A=2*88-99 } = 77级词缀等级（A）以上情况之外，还有一种特殊情况，游戏内有7种自带 “魔法等级” （ML）的物品，按照 A= X + ML 计算举个栗子：3c瘸子掉了一个头环，他的最低物等（I）至少是82级。他的魔法等级是3，那么公式计算，他的词缀等级应该是 A = 82 + 3，85级。那么问题来了，他会鉴定出+2职业技能么？答案是，不能。 因为+2全技能的词缀是90级的。","titles":["怪物等级","掉落规则"]},"271":{"title":"品质等级","content":"品质等级（qlvl）：  每个装备固有的一个品质等级 ，对于非绿色非暗金装备，qlvl和其底材一样，比如一件执政官铠甲，无论是蓝色还是黄色，其qlvl都是84。品质等级是玩家无法左右的，但是需要了解。因为它会与财宝等级（TC）一起决定掉落的。品质等级决定具体是哪件装备（是镰刀还是执政官甲）；","titles":["怪物等级","掉落规则"]},"272":{"title":"财富等级","content":"财宝等级决定物品的品质等级怪物是否能掉落对应装备必须满足两个条件：怪物的“财宝等级”（TC）大于或等于装备所在的“财宝等级”（TC），  同时怪物自身的等级要大于或等于装备自身的“品质等级”（qlvl）。","titles":["怪物等级","掉落规则"]},"273":{"title":"底材","content":"首先我们要提前介绍“底材”这个概念。其实在之前的内容已经提到过很多次“底材”，不过基本上都局限于制作符文之语的白色物品。但严格地说，“底材”实际上是所有魔法装备的衍生基础。你可以简单地理解为，一件白色的“军帽”经过“上色”变成了带有1-2条额外属性的蓝色“军帽”，或者经过另一种“上色”就变成了暗金物品“谐角之冠”，但他们的底材都是“军帽”。而底材也分为了普通级、扩展级和精英级三类，三类底材拥有同样的模型，后一级比前一级的基础属性更高，“军帽”就属于“精英级”底材：同一底材的暗金/绿色物品还会有自己的专属qlvl，一般叫做“成品qlvl”，如果我们打到了一个白色“军帽”，那它的qlvl显然就是58，而暗金军帽“谐角之冠”还会有自己专属的成品qlvl：69(见上上图的左下角)。","titles":["怪物等级","掉落规则"]},"274":{"title":"掉落机制","content":"怪物会掉落特定的物品么?不,不过金色怪物和头目会有更高的概率掉落魔法物品,头目会掉落魔法物品或更多的黄金.不过,怪物的种类与掉落的物品没有关系.人物的等级与掉落的物品有关么?不,掉落的物品只与怪物等级与场景等级有关.锁住的箱子会掉更好的东西么?不,但它会掉出更多的东西,一般来说是没上锁的两倍.","titles":["怪物等级","掉落规则"]},"275":{"title":"掉落过程","content":"底材判定过程（TC判定过程）  \n怪物的TC值代表了怪物能掉落的物品底材的最高Qlvl。  \n☆也就是说，当怪物TC ≥ 物品底材Qlvl时，则怪物能掉落该物品底材。  成色判定过程（Mlvl判定过程）  \n确定了物品的底材后，系统将按照暗金 - 绿色 - 黄色 - 蓝色 - 白色的顺序来判定成色。当判定为暗金或者绿色时，系统会检查怪物等级是否满足物品的成品Qlvl。  \n如果物品成色被判定为暗金，而怪物等级Mlvl不足以掉落该物品的暗金形态或者该物品暗金形态不存在，则会掉落该物品的黄色形态并拥有3倍的耐久度；如果物品成色被判定为绿色，而怪物等级Mlvl不足以掉落该物品的绿色形态或者该物品绿色形态不存在，则会掉落该物品的蓝色形态并拥有2倍的耐久度。☆ 也就是说，当怪物等级Qlvl≥物品成品Qlvl时，怪物才能掉落该物品的暗金/绿色形态。  \n☆ MF值会分别增加暗金、绿色、黄色、蓝色判定的几率，但不影响超强、普通、劣质的判定。现在我们回过头来看看“谐角之冠”的掉落过程：1、击杀怪物A，假设它的财宝等级(TC)为59，怪物等级(mlvl)为65，那么就可以掉落qlvl为58的底材“军帽”(因为此时TC>底材qlvl)2、MF值开始介入(在这之前TC表还有一系列的pick过程，较为复杂，暂不介绍)，游戏进入“暗金 - 绿色 - 黄色 - 蓝色 - 白色”的掉落判定顺序，假设此时可以掉落该底材的暗金品质装备“谐角之冠”，但是由于怪物等级mlvl 65<“谐角之冠”的成品qlvl 69，则无法掉落，改为掉落黄色品质的“军帽”，且具有3倍耐久度。3、如果怪物B的TC为57，那么根本不会掉落底材“军帽”，后续的“上色”流程无从谈起。4、如果怪物C的TC为67，mlvl为70，其余流程与前面一致，那么可以成功掉落“谐角之冠”。(因为TC>底材qlvl，可以进入掉落判定阶段，当判定为“谐角之冠”时，检查怪物mlvl>“谐角之冠”的成品qlvl，符合要求)前面已经提到过，MF只和“上色”有关，无法影响装备的品质等级qlvl，所以就算是把MF堆到10000，你在普通难度下也无法获得“统治者大盾”。","titles":["怪物等级","掉落规则","掉落机制"]},"276":{"title":"行为树的构建","content":"首先行为树会有个根节点   ,当构建行为树的时候,会将节点添加到该root下行为树的构建如下:","titles":[]},"277":{"title":"行为树的运行","content":"每一帧都执行update(),且如果根节点返回的是成功或者失败,则清空所有任务并  ,累计tick(所有子节点都会执行Reset())  如果子节点中有  的任务时,则该任务会被认为时激活的.添加到行为树中让我们看看任务的子类有哪些:一般来说只有一个子节点    ,会在每一次循环中同步tick,如果tick和行为树不一样,则会  ,如果onUpdate()返回的时成功或者失败,也会会在每一次循环中同步tick,如果tick和行为树不一样,则会  ,如果GetUpdate()返回的时成功或者失败,则会   (Exit时会Reset)且如果自己的状态曾经为  会从行为树的激活任务中移除,否则会将自身添加到行为树的激活任务中.","titles":[]},"278":{"title":"持续的任务是怎么运行的","content":"Sequence会记录自己循环过哪些task. 当taskb持续状态时,则会进入下一个循环,但不会进入下一tick,走到Sequence后,他不会执行已经执行过的任务,所以进入Sequence后会直接执行TaskB;只有当有任务失败或者成功,才会执行下一个tick,下一个tick所有task都会reset","titles":["行为树的运行"]},"279":{"title":"使用","content":"","titles":["行为树的运行"]},"280":{"title":"并行","content":"如果使用.,注意子节点,要么是持续的,要么是成功的..如果有任何失败了将会reset并行需要等待子节点全部完成,再根据子节点的返回状态判断该并行节点的状态  并不是说并行,就是两个不想干的node不断的执行  同时执行下面所有子节点的start(),然后等待所有子节点的反馈是成功还是失败","titles":["行为树的运行","使用"]},"281":{"title":"序列","content":"一般把Sequence-->Condition  当作if  就可以","titles":["行为树的运行","使用"]},"282":{"title":"选择","content":"由下图可以看出..Selector --> Sequence--> Condition  相当于if else把select,当成 if not来看select-->Inverter -->Condition  可以当作if来看..和Sequence的区别就是,select在执行b前返回的是true.","titles":["行为树的运行","使用"]},"283":{"title":"观察者模式","content":"观察者装饰器...就是观察某个变量..然后决定低优先级节点,自身节点,的执行(重启等)方式分为两种状况\n1.在当前节点未激活的时候,观察某个变量 生效的方式:Stops.LOWER_PRIORITY,Stops.BOTH,Stops.LOWER_PRIORITY_IMMEDIATE_RESTART,Stops.IMMEDIATE_RESTART\n2.在当前节点激活的时候,观察某个变量Stops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART\n所以会有三种节点出现IsConditionMet()永远返回true,子节点永远返回false,保证该装饰器节点是inactive状态  IsConditionMet()永远返回false,子节点永远返回true,保证该装饰器节点是active状态  IsConditionMet()根据情况返回true和false,比如如果玩家在附近,则执行该装饰器下代码.如果玩家不在附近则stop,执行低优先级代码Stops.NONE：装饰器只会在启动时检查一次它的状态，并且永远不会停止任何正在运行的节点。\nStops.SELF：装饰器将在启动时检查一次它的条件状态，如果满足，它将继续观察黑板的变化。一旦不再满足该条件，它将终止自身，并让父组合继续处理它的下一个节点。\nStops.LOWER_PRIORITY：装饰器将在启动时检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止比此结点优先级较低的节点，允许父组合继续处理下一个节点\nStops.BOTH：装饰器将同时停止:self和优先级较低的节点。\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启此装饰器。\nStops.IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启装饰器。正如在这两种情况下，一旦不再满足条件，它也将停止自己。说人话..就是\n在当前节点未激活的时候,观察某个变量\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART和Stops.IMMEDIATE_RESTART这个会停止低优先级(就是该节点后面的)的节点,然后会立即重新开始当前节点\nStops.LOWER_PRIORITY和Stops.BOTH 会先停止优先级较低的节点,然后再停止父节点在当前节点激活的时候,观察某个变量\nStops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART 这三个,都会先停止子节点.然后停止自身,最后会影响到停止父节点","titles":["行为树的运行","使用"]},"284":{"title":"条件和装饰器","content":"RepeatUntilSuccess --> ConditionBase 可以构成一个新动作ConditionBase 在返回失败的时候被RepeatUntilSuccess 转换为持续","titles":["行为树的运行","使用"]},"285":{"title":"服装","content":"先看下一套衣服是如何组成的,分为  +  +  .  能盖住  ,  能盖住  ,  和  可以同时存在,也可以单独存在点我下载服装制作模板衣服到时候我们一个一个商讨着画","titles":[]},"286":{"title":"修改","content":"所画  ,  请参考之前所画的  ,  或者说  ,需要  .占近似一个格子","titles":["服装"]},"287":{"title":"场景制作说明","content":"总结,横版常用背景大概有三种:   [点我下载 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/demo.zip)多层组合,每层的图片宽高480*96 或者 480*128 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%83%8C%E6%99%AF%E6%BC%94%E7%A4%BA1.psd)  单背景   图片宽高 864*192 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%83%8C%E6%99%AF%E6%BC%94%E7%A4%BA3.psd)  多层和单背景混合   [点我下载 (/images/2022-06-11-%E7%BE%8E%E6%9C%AF%E8%A6%81%E6%B1%82/%E8%83%8C%E6%99%AF%E6%BC%94%E7%A4%BA2.psd)关于地形,一般画地形的时候都会像下面几种方式设计,仅供参考,不需要一定向下面这样:QQ三国 和彩虹岛的地图都可以参考....................以下的参考图只是表达概念................下面的图都是西方游戏的设计..............画风都不符合国内游戏的感觉........仅作参考矿洞场景   可能包括的其他物品  ,  ,  ,  ,  ,         树林场景 可能包括的其他物品  ,   ,   ,  ,       海滩场景   有大海,        江湖场景 ---- 或者有瀑布,或者底部有水,或者背景有水        山谷场景  ---背景类似这种崖壁或者之类的东西..    丛林场景  --- 茂密高大的森林背景          背景为连绵不觉的山,山林中既有矿石,也有树木,也有草药  竹林场景--茂密高大的竹林背景    家园场景          门派场景 --- 背景浮空岛或者是遥远的建筑..或者可以自己想象..没特别的想法.   背景是一些远的建筑之类的    城市场景---房屋和树的结合..可以拿之前的房屋和树进行组合    村庄背景---有田地,有山,有村庄      遗迹(废墟)    这个有点西式..不知道中式的遗迹啥样的      沙漠场景--- 注意植物可能是仙人掌,之类的        冰雪场景  注意背景植物可能是松树或者这种桦树      地牢(副本)        旅途(奇遇)场景   当我从一个城市到另一个城市时,会进入该场景,人物会在该场景移动,然后触发一个个事件. 为了便于理解,参看视频 (直接跳到15:20)    归家异途2.    旅途的场景,地图的两边是各自的城门,然后中间就是道路和风景一些道具图标以及工具, 服装  (待定) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n     内容      工具  锄头,水壶,镰刀,斧头,矿锄,鱼竿,剪刀,锤子  各个等级的   种子(图标)  袋装的种子    果实(图标)  包含变异品下面等游戏一测做完再做吧.洞窟  地形:暗色的砖石,其他物品.可能包括  ,  ,  ,  ,  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n     必要物品  功用  说明    绳索  上下爬动    桥  玩家可以从上面跳下去,或者作为连续跳的点    门     机关   突起在地面上玩家可以搬箱子放置触发.或者是一个能左右扳动的开关      不同的城市该如何进行区分,不然移动到另一个城市,感觉没啥变化   背景的不同      ,  ,  ,  ,  ,   地面砖块的不同  已画建筑的简单变形?????   比如屋顶瓦片的颜色...  不同城市的装饰树木不同  ?????  还有其他?????  总共20个城市,需要8-10套,有难度吗  \n参考图,有看到能用的我再补上:    房屋内部  是否要做?? \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n     必要建筑  功用  说明    药店室内:  ,  ,   随意画点东西吧,画不出也没关系  以下随意画.画不出也没关系,本来不打算房间能进的,主要是为了丰富游戏多样性   酒店室内:  ,  ,  ,   随意画点东西吧,画不出也没关系    客栈室内:   .  ,   随意画点东西吧,画不出也没关系    杂货店内:  随意画点东西吧,画不出也没关系    礼品店  随意画点东西吧,画不出也没关系    养殖店  随意画点东西吧,画不出也没关系    种植店  随意画点东西吧,画不出也没关系    商行  随意画点东西吧,画不出也没关系    镖局  随意画点东西吧,画不出也没关系    铁匠铺  随意画点东西吧,画不出也没关系    书院  随意画点东西吧,画不出也没关系    赌场  随意画点东西吧,画不出也没关系    衙门  随意画点东西吧,画不出也没关系    大牢  随意画点东西吧,画不出也没关系    普通民居  随意画点东西吧,画不出也没关系   一些室内参考图:","titles":["服装"]},"288":{"title":"1. 游戏名称","content":"苟与剑  我有一块地","titles":[]},"289":{"title":"存档","content":"每天晚上睡觉会自动存档","titles":[]},"290":{"title":"体力的回复","content":"体力会随着使用道具和工具等减少,体力为0后不能继续工作\n雨雪天气再室外使用道具:每次使用+1\n下午10:00-12:00使用道具:每次使用+2\n晚上0:00-6:00 使用道具:每次使用+4\n6:00 未入睡,第二天增加buff,每次使用+3主要回复方法:睡觉 回复30点+睡眠事件*每小时7点,睡的越多回复的越多  吃东西 回复量因物品而异  泡温泉 每分钟回复体力1点  再旅馆吃饭  装备女神的秘宝 每分钟回复体力1点增加体力总值:体力果实:增加15点耕地有1.2%几率出现一次  向女神献上贡品10次.将物品扔进女神之泉即可  春季或秋季赛马获胜  采矿场100层锄地,有19.5%概率出现  杂货店花费10000g购买  冬天,在海边钓鱼1%概率获取","titles":[]},"291":{"title":"时间与日期","content":"主角在AM6:00~AM5:59期间可以活动.\n每天6点会触发新的一天的事件","titles":[]},"292":{"title":"怪物在地图种的类型","content":"地牢有很多种美术不同的地图:  地牢的地图种类.决定了这个地图里是生成什么类型的怪物  生成什么类型的怪物,和城市地块以及城市等级没有关系...","titles":[]},"293":{"title":"怪物在地图中的等级","content":"由游戏难度和地图难度决定  地图难度越高..怪物等级越高  游戏难度决定..比如普通...四级装备就能过九级地牢...而噩梦..九级装备才能过九级地牢","titles":[]},"294":{"title":"关于奖惩","content":"100次负面效果会有一次极大的正面效果","titles":[]},"295":{"title":"修仙式人生","content":"1、前辈拜访：避而不见-少量道德、传功-修为、打架-大量道德2、灵石矿脉：表面挖增加修为、在深处挖一无所得3、仇敌：教训一番声明大涨、好言相劝-战力4、生死搏斗：帮助获得宠物5、锻造师：同意-体魄+战力6、应邀做客：运功调息躲过一劫、怀疑好友-大量心态7、跛足乞丐：治疗腿溃→给他酒+随机属性8、论道大会：旁听论道+悟性、参加论道+名气9、炼妖塔：放出宠物+宠物战斗力10、道侣：与其同游+修为11、天仙下凡：假扮渔贩施舍得丹药12、灵石市场：平平无奇的石料+修为、古怪的石料看人品±修为(大概率-修为)13、白衣公子：详细解答+悟性、高谈阔论-名气14、门派大比：下场比武+名气、场外观战+战力15、山下来妖：放入炼妖塔16、遗迹：勇闯遗迹→制造临时分身-修为+战力17、追债：帮助书生抵债-修为+随机的物品，继续追债则会扣道德18、落难母子：帮被偷东西、拒绝啥都不扣19、子嗣传功：无视不扣属性20、仙岛：进入深处被打伤-体魄、21、府库失火：继续盘点大概率啥都没有(小概率被烧几件东西)、救火有可能库存被清空22、碧水寒潭：潜到潭底概率±修为(加的比减得多)23、判官雕像：据为己有+修为-道德24、灵宝殿：选半价拍卖得随机的半价东西或者灵兽25、无名仙岛：进入深处看人品+修为或者-体魄26、宝藏：邀请好友→假装不敌-道德+修为、联手反击-名气-修为27、天梯：登上天梯得功法28、恶人：前往助拳+名气+道德29、寻仇：选安抚失去一个功法30、求丹：给他丹药+道德、不给-道德-修为31、帮助店主：教训流氓得随机物品32、拍卖：选择不要的功法和丹药换修为33、魔修者：寻求救援-心态+名气、袭击魔修者+道德-体魄合体期事件1、仙树吸引妖兽：用妖兽错过神兽大会、用阵法成长时间加十年2、仙树叶子枯黄：得浇水3、仙树叶子发蔫：得施肥4、蟠桃大会：参加固定+100万修为和20名气","titles":[]},"296":{"title":"阴阳师","content":"1、路上遇到了形迹可疑的路人，跟上去看看。选项A -像是非常渴，一直在不停喝水的男子。结局A -饮水水过量的男子晕倒了，送男子就医，来到了另一条街道。选项B -踏过的地面会留下红色印记的女子。结局B -好奇地现祭红色印记，弄脏了鞋子，购买一双新鞋穿着很舒服。2、木偶商人有新的剧目了，椐说根椐真事改编。选项A -听奇鬼王怒杀恶兽扩疆域。结局A -剧情精彩老套无聊不小心睡着了，恢复了一些体力。选项B -听俏人鱼力斩冰海收珍宝。结局B -剧本新颖，前所未闻，很多观众都打赏了勾玉。3、京都热闹非凡，弥助的身影也出现在銜上。选项A -邀他一同游玩京都吧。结局A -弥助灵感迸发，当场作画，得到弥助大作太鼓。选项B -劝他回去安心作画吧。结局B -弥助闷闷不乐，回去画画，弥助不知道画了一张什么玩意。4、街边店铺门口出现了一道熟悉的身影。选项A -是一只壮硕的橘色大猫。结局A -花费了一个时辰陪猫玩耍，最后猫的主送你了一些礼物。选项B -是一只灵活的白色小狗。结局B -迫狗玩耍，不料反被狗追，不小心闯入了其他街区。5、店铺老板正在向过往行人兜售锦鲤。选项A -更想要红白配色的锦鲤。结局A -获得一只红白配色的锦鲤，但是运气并没有变好。选项B -更想要紫白配色的锦鲤。结局B -获得一只紫白配色的锦鲤，但是运气并没有变好。6、在路边检到了勾玉袋和一盆丸子串，突然罕见地遇到了镰鼬三兄弟之一。选项A -是任性妄为的一太郎。结局A - —太郎抢走了你裝勾玉的钱袋，但丸子真好吃。选项B -是不想再呆在最下面的三太郎。结局B -三太郎抡走了你的丸子串，但是留下了勾玉袋。7、偶然捡到一只小猫。选项A -猫掌柜似乎正在找着什么。结局A -问猫掌柜丟了什么，小猫安全回家了。选项B -小猫贪吃的模样神似伊吹。结局B - 习惯性喂了小猫几串小鱼干，居然真的收到了礼物。8、街边店铺在卖各或各样的面具。选项A -买个般若面具戴。结局A -戴上后变得十分可爱，被神秘男子搭讪了。选项B -买个天狗面具戴。结局B -戴上后身体变得轻盈了，被当成了大义的追求者。9、宫廷周围闪烁着忽明忽暗的蓝绿色灯火，隐约传来不祥的气息。选项A -走近用火暖暖手。结局A -火焰突然变旺了，不得不修补被烧坏的衣服。选项B -在附近设下结界。结局B -结界阻拦了宫廷附近的跃怪，皇室送来了一些珠宝作为谢礼。10、京都郊外突然盛开了大片的红色曼珠沙华。选项A -带一株回到庭院里种。结局A -曼珠沙华水土不服，第二天就枯萎了，伤心了一个早晨，上集市购买了一束纸花。选项B -不必在意。结居洛-京都居民结伴赏花，一时间曼珠沙华成为潮流，曼曼珠沙华价格暴涨，为了跟上潮流上集市高价购买了一株。11、竹林里传来悠杨的笛声，令人十分愉悦。选项A -跟着笛声在庭院里跳一支舞。结局A -被路过的博雅看见了，顺势邀请博雅喝酒，将他灌醉。选项B -在庭院廊下安静听完。结局B -和着笛声沉沉睡去，不幸着凉感冒。12、突然刮起了狂风，庭院门前被人提前贴了风符，幸亏风符保护才安然无事。选项A -揭下风符并妥善保管。结局A -第二天风符消失了，大天狗飞过庭院，吹坏了庭院的大门。选项B -派小纸人去风神神社回一份小礼。结局B -风神接受了礼物，获得了一张新的风符。13、看到一只有灵力的纸鹤在到处飞舞。选项A -击落一只看看。结局A -击落失败，被突然出现的一群纸鹤追着跑了两条銜。选项B -派出小纸人跟踪它们。结局B -纸鹤飞到了小纸人看不见的高度，跟丟了纸鹤，什么收获也没有。14、退治妖物后收集到了一些金色的鱗片。选项A -塞进嘴里咬一下，看看是不是真的。结局A -崩坏了门牙，不得不学着使用阴阳术来补牙。选项B -妥善保管。结居B -鱗片的妖力引来了奇怪的妖怪在附近徘徊，妖怪退治持续了整整一周。15、—个柔弱的小女孩扛着一只巨大的蒲公英。选项A -主动帮她一起扛。结局A -完全搬不幼，被小女孩无情嘲笑了。选项B -笑着鼓励她要继续加油。结局B -小女孩冲你露出一个可爱的笑容，收获了一整天的好心情。鬼谷八荒全奇遇任务攻略   全奇遇事件选择及奖励 3DM单机 (  3dmgame.com  )","titles":["修仙式人生"]},"297":{"title":"外道巢穴","content":"名称  难度  转盘检定  ^[1]^  区域    恶丐窝  1-1  毒术 杂学（10、20、30、40、50）  乡村1 废墟2   一伙恶丐群聚于此地，他们不仅时常骚扰附近的百姓与旅人，还向周边散播着恶毒与疾病……      贼人营寨  1-1  巧匠 杂学（10、20、30、40、50）  营寨1 洞穴2   一伙狡猾的贼人隐匿于此地，他们总在夜间行动，专门窃夺无辜百姓的财物……      悍匪砦  2-2  锻造 杂学（20、40、60、80、100）  沙漠2 营寨3   大批气焰嚣张的匪类于此地占路夺桥，拉帮结派，方圆数百里内，受其欺凌者不计其数……      叛徒结伙  3-3  制木 杂学（30、60、90、120、150）  乡村2 树林3   此地聚集了许多来自不同门派的弃徒，他们或为复仇，或为奸恶目的，最终结成一伙，为害江湖……      恶人谷  4-4  术数 杂学（40、80、120、160、200）  山岭2 营寨2 峡谷3   许多同时身负正邪两道数笔血债的亡命之徒盘踞于此地，因为过着刀口舔血、朝不保夕的日子，故而异常的凶恶……      迷香阵  4-4  织锦 音律（40、80、120、160、200）  洞穴2 树林2 花海3   迷香阵笼罩在一片红雾之内，伴随着其中的细细笑语和靡靡乐音，阵阵异香不断地飘送出来……      乱葬岗  5-5  医术 毒术（50、100、150、200、250）  庙宇2 废墟3 古墓3   弃置着众多枉死者尸身的不祥之地，随着一些江湖上的诡怪术士在此地频繁出入，更为此地蒙上了一层可怖的阴影……      异士居  6-6  音律 弈棋 诗书 绘画 品鉴（60、120、180、240、300）  湖泊2 茅庐3 古迹3   一些左道异士结庐居于此地，这些异士虽身怀绝技，但性情乖戾，善恶不分，行事只凭一时之兴……      邪人死地  7-7  道法（70、140、210、280、350）  洞穴2 潭泽2 林野3 古迹3   大批异疆邪教中人群聚于此，他们设坛祭鬼，施烟布瘴，每日杀人取乐，闻者无不色变……      修罗场  7-7  医术 杂学（70、140、210、280、350）  荒野2 沙漠2 营寨3 废墟3   发生过极多可怕杀戮的凶恶之地，许多曾在杀戮中失却心智的疯子与狂人受到炼心师的操弄，仍不断游荡在此地附近……      群魔乱舞  8-8  佛学（80、160、240、320、400）  洞穴3 庙宇3 废墟3 古墓3   一支无名魔教的教众占据着此地，他们为了壮大自身的声势，不断以骇人的手段残害着武林正道的人士……      弃世绝境  9-9  术数 佛学 道法（90、180、270、360、450）    此地曾是某处世外绝境的屏障，直到无休止的江湖纷争蔓延至此，那些原本隐居于绝境中的人满怀着仇恨被迫重返尘世…","titles":["修仙式人生"]},"298":{"title":"物品产出表","content":"","titles":[]},"299":{"title":"野外食物产出","content":"作物 浆果 甜菜 出现少，加体力少树木掉落 蜂蜜，松果。。水果动物掉落 肉。不掉落皮毛，因为要养殖鱼","titles":["物品产出表"]},"300":{"title":"产出种类","content":"树木   制作家具和装备  作物   制作食物,增加体力和非战斗相关的buff  卖钱  药材   制作药品,增加血和蓝,以及战斗相关的buff  动物   皮毛用来制造衣服  肉用来制作食物  鱼类   用来制作食物  矿石   可以用来进行武器的制造和升级  宝石   宝石可以用来制作物品  通常是最爱的礼物或喜欢的礼物。  偶尔会出现宝石洞  固定日期会产出持续三到五天  翡翠   价格非常昂贵,除了卖钱别无他用  翡翠原石鉴定而得","titles":["物品产出表"]},"301":{"title":"城市产出说明","content":"一些城市有特殊产出,固定的  除特殊产出,其他的都随机分布  地块应该有一些标记,标记这个地方是否可以生成矿,是否可以有药材,是否可以有食材,是否可以有木头  玩家出生地的产物,一定是低级的产物,不然没法进行初级制作  物依稀为贵,产量越少,等级越高  食物可以补充体力,晚上睡觉可以补充体力  晚上十点到早上六点,每小时额外扣除体力,以及心情  送礼好感度=====获取的难度,衡量产出时间,以及掉落概率","titles":["物品产出表"]},"302":{"title":"树木","content":"售价和稀有度有关,稀有度越高,价格越高树木  掉落  等级  售价    砂树  木头  0    松树  木头,松木  1    冷杉  木头,铁力木  2    柏树  木头,乌木  3    杨树  木头,黄杨木  4    榉树  木头,榉木  5    楠树  木头,楠木  6    白桦  木头,桦木  7    望天树   8","titles":["物品产出表"]},"303":{"title":"作物","content":"根据素材决定会有哪些作物  一般的计算公式为 [( 最多收获次数 x 单位售价 ) - 种子购买价格 ] / 生产周期  生产周期 = 成熟所需天数 +（最多收获次数 - 1）x 重新生长天数作物  掉落  等级  环境","titles":["物品产出表"]},"304":{"title":"药材","content":"药材的素材只有一种,分等级.然后产出药材  掉落  等级  环境    草药   1    草药   2    草药   3    草药   4    草药   天麻,藏红花,雪莲花,冬虫夏草,人参,天冬,贝母,肉苁蓉  5","titles":["物品产出表"]},"305":{"title":"动物","content":"动物  掉落  等级  环境","titles":["物品产出表"]},"306":{"title":"鱼类","content":"鱼类  掉落  等级  环境","titles":["物品产出表"]},"307":{"title":"矿石","content":"矿石  掉落  等级  环境    石头      铜矿      锡矿      铁矿      铅矿      银矿      钨矿      金矿      铂金矿","titles":["物品产出表"]},"308":{"title":"宝石","content":"宝石  掉落  等级  环境","titles":["物品产出表"]},"309":{"title":"晶石","content":"晶石  掉落  等级  环境","titles":["物品产出表"]},"310":{"title":"玩法","content":"","titles":[]},"311":{"title":"收集","content":"","titles":["玩法"]},"312":{"title":"收集九块令牌","content":"","titles":["玩法","收集"]},"313":{"title":"收集不同的植物","content":"","titles":["玩法","收集"]},"314":{"title":"收集不同的矿物","content":"","titles":["玩法","收集"]},"315":{"title":"收集不同的鱼类","content":"","titles":["玩法","收集"]},"316":{"title":"收集不同的草药","content":"","titles":["玩法","收集"]},"317":{"title":"收集古董","content":"","titles":["玩法","收集"]},"318":{"title":"帮派","content":"","titles":["玩法"]},"319":{"title":"经济","content":"","titles":["玩法","帮派"]},"320":{"title":"门派","content":"","titles":["玩法","帮派"]},"321":{"title":"副本","content":"","titles":["玩法"]},"322":{"title":"秘境","content":"","titles":["玩法","副本"]},"323":{"title":"蛙岛","content":"","titles":["玩法","副本"]},"324":{"title":"大逃杀","content":"","titles":["玩法","副本"]},"325":{"title":"Roguelike","content":"","titles":["玩法","副本"]},"326":{"title":"爬塔","content":"","titles":["玩法","副本"]},"327":{"title":"节日","content":"","titles":["玩法"]},"328":{"title":"端午划龙舟","content":"","titles":["玩法","节日"]},"329":{"title":"比武大会","content":"","titles":["玩法","节日"]},"330":{"title":"元宵节","content":"","titles":["玩法","节日"]},"331":{"title":"猜灯谜","content":"","titles":["玩法","节日","元宵节"]},"332":{"title":"入侵模式","content":"","titles":["玩法"]},"333":{"title":"强盗王","content":"","titles":["玩法","入侵模式"]},"334":{"title":"杀了150个强盗","content":"","titles":["玩法","入侵模式","强盗王"]},"335":{"title":"白莲教","content":"","titles":["玩法","入侵模式"]},"336":{"title":"魔教","content":"","titles":["玩法","入侵模式"]},"337":{"title":"谋反","content":"","titles":["玩法","入侵模式"]},"338":{"title":"蛇人入侵","content":"","titles":["玩法","入侵模式"]},"339":{"title":"僵尸王","content":"","titles":["玩法","入侵模式"]},"340":{"title":"天人入侵","content":"","titles":["玩法","入侵模式"]},"341":{"title":"四大圣兽入侵","content":"","titles":["玩法","入侵模式"]},"342":{"title":"妖族入侵","content":"","titles":["玩法","入侵模式"]},"343":{"title":"入侵模式.不能售卖东西..不能大地图移动","content":"","titles":["玩法","入侵模式"]},"344":{"title":"门客","content":"","titles":["玩法"]},"345":{"title":"护卫","content":"","titles":["玩法","门客"]},"346":{"title":"跑商","content":"","titles":["玩法","门客"]},"347":{"title":"种植","content":"","titles":["玩法","门客"]},"348":{"title":"养殖","content":"","titles":["玩法","门客"]},"349":{"title":"寻宝","content":"","titles":["玩法","门客"]},"350":{"title":"探索","content":"","titles":["玩法"]},"351":{"title":"去不同的城市","content":"","titles":["玩法","探索"]},"352":{"title":"资源有限,会被采光","content":"","titles":["玩法","探索","去不同的城市"]},"353":{"title":"宝箱","content":"","titles":["玩法","探索","去不同的城市"]},"354":{"title":"利用关系解锁地块","content":"","titles":["玩法","探索"]},"355":{"title":"人物","content":"","titles":["玩法","探索","利用关系解锁地块"]},"356":{"title":"宝箱","content":"","titles":["玩法","探索","利用关系解锁地块"]},"357":{"title":"故事剧情","content":"","titles":["玩法","探索"]},"358":{"title":"奖励","content":"","titles":["玩法","探索","故事剧情"]},"359":{"title":"好看的场景???","content":"","titles":["玩法","探索"]},"360":{"title":"隐藏地图","content":"","titles":["玩法","探索"]},"361":{"title":"武学","content":"","titles":["玩法"]},"362":{"title":"npc互动和小游戏","content":"","titles":["玩法"]},"363":{"title":"打牌","content":"","titles":["玩法","npc互动和小游戏"]},"364":{"title":"三消","content":"","titles":["玩法","npc互动和小游戏"]},"365":{"title":"24点","content":"","titles":["玩法","npc互动和小游戏"]},"366":{"title":"猜谜","content":"","titles":["玩法","npc互动和小游戏"]},"367":{"title":"切磋","content":"","titles":["玩法","npc互动和小游戏"]},"368":{"title":"职业","content":"采集   采集的时候增加经验  扶农.每提升一点则减少消耗体力0.1点  农夫  砍伐   砍树增加经验  斫(zhuo)木每提升一点则减少消耗体力0.1点  樵夫  养殖   收获农产品增加经验  庖丁,.每提升一点则减少消耗体力0.1点  屠夫  采矿   采矿增加经验  开山 每提升一点则减少消耗体力0.1点  矿工  钓鱼   钓鱼增加经验  渔获每提升一点则减少消耗体力0.1点  渔夫  制作   制作家具和武器增加经验  机巧减少制作时间,制作时消耗的燃料???  铁匠----制作订单牌..接受订单  医术   制药和行医的时候增加经验  悬壶--每提升一点则减少消耗体力0.1点  药师  烹饪   做饭和招呼客人的时候增加经验  食肆--每提升一点则减少消耗体力0.1点  掌柜  经商???   购买物品的时候  生财--交易时获得的金钱???  商人","titles":[]},"369":{"title":"如何开酒楼和医院","content":"购买许可证  悬挂在屋内,(只准悬挂一种许可证)  许可证有个按钮..营业或者行医,,点击提示消耗一天  经营   酒馆   需要柜台,和桌子,柜台可以让npc有个等候区,如果等候区满了...npc没有在固定时间接待,则会走出房屋  医院  需要床,如果没有床npc固定时间没有接待则走人.诊断失败扣除经验  npc的AI   每隔一段时间生成客人  客人走进屋子内,检查是否有等候区..如果等候时间到了,则离开..  npc会说话","titles":[]},"370":{"title":"天下霸图2","content":"","titles":[]},"371":{"title":"时间观念","content":"一个月分4天，1日、10日、20日、30日，并不是天30，一个月份结算薪资4次，例如你的门派介面设定支薪10，总支薪是310元的 话，一个月的支出就是支薪1240元，也就是你必须在48个时辰内凑到1240元来维持支出。","titles":["天下霸图2"]},"372":{"title":"薪资","content":"门派的薪资调整其实是在设定弟子心情的基准底限，建议以原本设定支薪10就好，因为移动到别的地方的时候各定的基本设定都 是10，也不用调来调去，以5张脸来说，10只是中间普通的而已，这关系到什麼呢？关系到练武经验的最大上限，基准调越高，弟子能在武场练 的经验值能撑越高，但是投资比率太不敷出，所以还是建议10就好，学习力（後面会解说）3支蜡烛大约最高经验值上限可以学到7000才会喊不 爽，但是6000就开始变脸了，如果收学费制的话，这适用在快攻，因为没打算让原本的弟子打通关，後面新加入的弟子资质几乎都比原本的人 好，六力很快就能超过原本的人物，因为他们一出来只有长拳1XX多经验，等到他长拳练到3XXX经验值时臂力应该破400其他都破200，轻功要另 外练，收学费2块钱的话大约最高练武上限能到4000而已，想当然必须比较快换下一招练，六力提升比较正常，但是会有弟子一喊不爽就马上跑 掉的问题，比较之下，支薪10块钱一开始即使你没排练武行程给他他都不会不高兴，你调再高的薪资给他也都只是普通心情，心情在於练武成 效，最高效率就是领悟，只要给他领悟後，经验值从0到最高上限都是普通心情，超过最高上限他就会不爽，而你绝对有时间帮他换秘笈；好处 在於不怕讨伐受伤休息太久而不高兴，不怕没练到武不高兴，不怕有分舵後忘记调薪资而管理不方便，支薪10元练武所需成效最低底限50。   \n重点：10元起手，再借不难；先学会支薪10元，玩熟了之後再去研究调整薪资。","titles":["天下霸图2"]},"373":{"title":"弟子心情","content":"门派介面的脸和弟子个别人物情报的脸是不一样的，门派介面的脸是代表弟子基准心情底限及平均变化量（以月份为单位），弟 子心情代表其个人的该日心情（已日为单位），算是较细部的观察；主要是门派介面的基准底限不要太低的话，弟子不爽的缓冲时间就比较充 足，如果很在意想让弟子每天绿脸的话，不是加高他的练武成效（效果不好），而是加多他的领悟时间，在领悟室里所得练武经验值非常高， 但是领悟期间所得经验值没加六力，所以不要让他领悟出来，他快领悟出来的时候就帮他换掉，不要小看拿秘笈领悟，时间很短，可是那短短 几个时辰加的六力是最高的；弟子最快乐的绿脸时期大多是在刚拿到秘笈至领悟出来这短短的期间，因为很容易让该日练武成效破千，之後就 很难了，如果用收学费的，要让每日练武成效破2千甚至3千以上，就几乎都浸在练舞场和领悟室了，收入就要靠其他弟子来分担，所以就要另 外开个分舵了。   \n重点：心情不是看脸色的；常利用门派的情报介面看各人物的工作成效，是否保持练武成效50以上，如果没有，看蓝色条，如果都是蓝的就表 示他练武有成，想换别的秘笈了（10元很好起手，这之前他就会开始提示了）。","titles":["天下霸图2"]},"374":{"title":"学习力","content":"收人的时候除了看属性和特技，还要看他的学习力，他这是以六力为表示，臂力和腰力高的就表示拳法学习力高，不过这只是大 概，最准确的就是看他写秘笈有几根蜡烛（不是真的叫他去写秘笈），越少根表示所花时间越少，该项学习力越高，同理也可用领悟的方式查 看；其实这关系到基础武学和六力，基础武学越扎稳该项六力（如拳法要臂力和腰力）越高他的学习力就会越高，所以此代的学习力是可以成 长的。   \n重点：基础武学要扎稳啊；扎稳了自然该项所需六力就会相对提高，就方便练下一阶武功，也可提高下一阶武功的最高上限经验值；腿法最重 要，没铁矿产的第2要先著手掌法，因为没铁矿或许也没卖武器的民房，所以都只练腿掌法，等到有分舵才在分舵主攻兵器场，徒手武功在兵器场和兵器武功在徒手武场，所得练武经验值及练武意愿（最高练武经验上限）都会只剩1/4。","titles":["天下霸图2"]},"375":{"title":"工作时辰编排","content":"起初都是每个人各项设施一点，大约武场有3个的时候（只有6个人的话）才特别编排武场2点，等到有5个武场的时候才4练武3种 田3工作补强六力，或是练武3领悟2种田3工作2，尽量不要让弟子发呆就是了，先看哪些设施会卡人先补足；其实我觉得这地方最有学问，要靠 自己慢慢摸索才能领悟......   \n重点：每日情报资料更新後都要看弟子工作效率，白色色条表示发呆，空白色条表示行走，腿力过低的就增加他的行程点数比例以减少他的行走时间或是只让他在主殿附近工作。 \\","titles":["天下霸图2"]},"376":{"title":"设施","content":"一开场绝对要各项生产设施都建设（农田至少2，其他牧场、药园都要有，然後原料店要盖出来），不要急著建设武场，这边的重点 主要在原料店，每个产物每样工作都1点的话会比较平均，原料店要设定下一个预见设施的储存量，例如我下一个设施想盖武场需要500肉和200 药，那就要设定卖的储存量肉3000药3000,这样他会保留1000肉和1000药，如果是分舵主殿要12000肉8000木，那就设定肉15000木11000，其实 到了要开分舵的时候不只要这些啦，最少要4万现金和各2万资源再过去比较好；只有自己产地没有生产的才不打开设定，其他都要打开并且设 定好，我当初就是没看中这个，才都玩不起来，对了，一次交易量是1000，物资尽量平均卖，自己特产什麼该样物资就可以减少人手去挖，主 要是卖米肉药，其他贵重材料慢慢卖或是不卖，有需要再去开采，不过最好还是慢慢卖。   \n重点：原料店很重要，一定要尽早盖起来并且设定好，装备生产设施（冶锻场、织造房）等稳定後才开始盖并且才派人员工作。","titles":["天下霸图2"]},"377":{"title":"战斗","content":"基础腿法长拳掌招防御（要练防3盘并且闪躲率高的）轻功都要练完才出战，掌门的左右护法要一个专练呐喊和防守自补血方针开 保护，一个帮补专掌法腿法消耗对方敏捷的方针开补血，掌门就让他变态攻击型吧，因为掌门大多是专武的特技，保护的那个要全身封印装 备......，不然即使是胖子一样备摸两下就趴，如果有练防3盘防守招（主要减免3盘伤害，只有两盘的话封印会有一盘没效用，就是致命破绽 了），全身穿封印，即使是瘦子也可挡，甚至不会失血......不知道是不是BUG，胖子跟瘦子好像是看损血比率，被打到一样都只剩两成血；为 什麼要基础武功都会了才出战？因为一开始低等盗匪不值得花时间去打，那等於偶而救济一下浪费时间（采集时间）毫无作用，等到都练好了 再开打声望要一下子满很简单，不管怎样最後还是会武功迟滞，回来练功导致声望降回还要重新打声望的。   \n重点：等到可以开打的时候，等累积3个同样任务（运标、救济、劫标那些都不用看，只看红剑图示），然後在白天看一下任务内容，等到晚上 再一次连续接，最後一场战斗如果有人失血过多的话要退一下补血，保持完好状态收场才不用花费休息时间。","titles":["天下霸图2"]},"378":{"title":"职位","content":"舵主的忠诚度和智慧影响该分舵(以下⼀样)弟⼦的忠诚度,健康和智慧影响⽣产,智慧和四⼤武功属性(攻击,防御,青⼯,暗器)影响练功,智慧和四⼒(内,臂,腰,腿)影响采集左堂主的智慧和四⼤武功属性(攻击,防御,青⼯,暗器)影响练功右堂主的智慧和四⼒(内,臂,腰,腿)影响采集被选为舵主忠诚+20左右堂主+10,取消则减之.|                       天下霸图2弟子特性一览表|\n|生产类特性|\n|深耕|产粮食腿力计算*3|\n|肥田|农田跟药铺等级+1(计算时)|\n|剥皮|皮革产能*2|\n|耐力|精力减少除以2|\n|工艺|铸造时内力计算*3|\n|快逢|织造时指力属性*3|\n|炼金|丹药产量*2|\n|辩矿|金矿、铁矿、木材产量*2|\n|探勘|金矿、铁矿、木材资源等级+1|\n|铁臂|挖金矿铁矿时计算臂力属性*3|\n|铁人|在厢房精力回覆加倍|\n|识药|计算药草时腰力属性*3|\n|活力|每天早上所有精力回复|\n|神笔|悟招跟写秘籍速度*200%|\n|聚财|有他在该分舵所有物品买价-20%卖价+50%|\n|战斗类特性|\n|狂奔|轻功受地形影响减少|延命|生命低于5%时恢复到最大生命的60%|\n|慧根|练武经验增加*2|色诱|都受到异性攻击时伤害力减少25%|\n|寻路|队伍移动+100|惩戒|当重击对手时下一招伤害*2|\n|养生|战斗中将康回复率*4|热血|受到伤害可以累加增加出招速度|\n|体健|战斗中六力回复率*2|金身|对所有负面状态免疫|\n|开窍|战斗的道的经验成以1.5|虐杀|击中对手时有30%机会瞬间减少对手25%健康|\n|刀敏|以更快的速度施展刀法|焚身|击中对手时有20%机会烧掉对手的6力|\n|剑灵|以更快的速度施展剑法|忍术|施展轻功无视高度影响|\n|棍通|以更快的速度施展棍法|羽化|施展轻功无须任何消耗|\n|快腿|以更快速度施展腿法|毒胆|对所有中毒免疫|\n|速拳|以更快的速度施展拳法|毒杀|当对手楚于异常状态时武功攻击力*1.5|\n|劲掌|以更快的速度施展掌法|自暴|当生命低于150时销号生命100点事下一招攻击+300|\n|武痴|所有武功重击率*2|魔身|除非发生重击否则不会受到任何伤害|\n|坚毅|对所有恐惧免疫|神打|除非受到大于最大健康10%的伤害否则不会受到任何伤害|\n|意志|对昏迷效果免疫| | |\n|反击|当被对手重击石会快速发出下一招武功| | |\n|求生|当生命低于20%时生命会以最大生命的5%回复持续6秒| | |\n|复仇|当生命小于30%时武功招是攻击力*3| | |\n|备注：红字为稀有特性或特有特性，游戏前期一般情况下很难招收到，特有特性是特殊人物才有的特性，比如聚财是特殊人物钱广进的特性，其他人还没发现有过，特殊人物的特性有些是鸡肋但是特殊人物学习力也是一般弟子望尘莫及的。|","titles":["天下霸图2"]},"379":{"title":"天下霸图","content":"","titles":["天下霸图2","职位"]},"380":{"title":"设施建造","content":"在江湖上开帮立派，少不了规划一番，这可不是随随便便找几个人胡乱演练一下就能成功。趁着现下各大门派防守松懈之机，还是让我们一同来偷师一下，看看成立一个门派需要配置些怎样的家什。总舵（开帮立派）：总舵是门派中的门主所在地，一旦总舵被人攻占，而门主恰恰在总舵中，那么整个门派都将随着门主的死去而马上灭亡。因此挑选总舵时最好找那些地图够大，建造面积够宽、资源丰富的地点，这样不仅发展潜力很大，而且在早期就可迅速完成门派核心设施的建设。分舵（控制当地）：当攻下对手门派的地盘或到了一个尚未被人控制的地点，都可将它变为自己的分舵。分舵可在当地招收门徒并进行与主舵内容完全一致的各类练习和工作。分舵被人占领，不会影响门派的存亡，唯一要提醒各位的是，和总舵一样，每个分舵都必须最少任命一位舵主，假如需要还可以任命左右堂主。正殿（门派标志）：正殿是门派内一切设施建造的前提，其代表了门派的存在，在这里可进行人事方面的任免，同时安排门徒在此听训，可以增加他们对门派的忠诚度。看板（招募弟子）：只要找好地点，开帮立派建好正殿之后，看板就会自动开始使用，天天看板上都会登出本门本派拉人入伙的公告。假如你的门派声望够高，就会有应征者前来此处报道。点选看板之后就可查看到应征者的资料，假如感觉满足，即可批准入门，让应征者正式成为门派一员，门派的声望越高，前来应征的人属性也就越强。但要提醒一下的是，天天最多只会有一名应征者前来应征，因此当需要很多弟子加入时，不妨多设一些分舵来扩大招人数量。厢房（提供门徒弟子休息）：每一位门徒弟子感到疲惫时，都需要到厢房进行休息，否则将无法恢复体力和精神，并会因过度劳累而病到。由于一间厢房只能让一位门徒弟子休息，所以要想在总舵或分舵中招收更多的门徒弟子，就必须建造相应数量的厢房供他们休息。需要注重的是，在有空厢房时，招收进入的弟子会自动获得房间分配，但假如你进行过厢房拆除或房主指定等改变，那就必须手动为门徒弟子安排房间。徒手武场（练习各种拳脚功夫）：当门徒弟子安排有徒手方面的武功练习时，将会前往徒手武场进行练习。同一徒手武场在同一时刻只能安排一位门徒弟子进行练习，因此假如想同时练习很多徒手武功的弟子，就必须建造多个徒手武场才能满足需要。徒手武场是门派中最基本的练武之地，必不可缺，一般以5个为宜。兵器武场（练习各类兵器刀棍暗器）：和徒手武场一样，同一兵器武场在同一时刻只能安排一位门徒弟子进行练习，因此假如需要练习的门徒弟子很多，就必须建造多个兵器武场才能满足需要。兵器武场也是门派中最基本的练武之地，一般以3个为宜。修炼室（闭关修炼武功）：武功是靠悟出来的，当门徒弟子的某项武功经验值较高时，安排他到修炼室闭关修炼将有可能悟出更加厉害的新武功来，或是撰写出武功秘籍。前者可让门徒弟子学会新的武功，并以此为下一次悟出更强的武功作为基础；后者则是可将武功秘籍交由其他同门师兄弟阅读，以迅速提升阅读者该武功的经验值。修炼室也是门派中最基本的练武之地，一般建2座就够了。药圃（采集药材之地）：当总舵或分舵建造在有药材资源的地点时，就可以建造药圃进行采药。当地土壤的好坏会影响到药材的数量与品质，可依据炼丹所需药材进行建造。铸造房（打造武器暗器之地）：游戏中的大部分武器、暗器都需要自己生产才能获得，而铸造房正是为此而设，根据采集资源的不同生产出来的武器、暗器种类也不尽相同。铸造房有等级的设定，一共7级，每升1级，能够生产的物品等级也就越高，产品的价值也越高。所以要想获得强力的高等级武器，就需要不断进行铸造，以提高铸造房的等级。织造房（生产服饰之地）：可以生产衣服、鞋子、饰品等物品，但必须有足够的原料资源。和铸造房一样，织造房也有7个等级的设定，随着等级的提高，能够生产的物品等级也会越来越高，产品价值也就越高。炼丹房（炼丹制药之地）：负责进行丹药的生产炼制。同样有着7个等级的设定，等级越高，所能炼制的丹药效果越好，因此也是游戏中必须建造的设施之一。","titles":["天下霸图2","职位","天下霸图"]},"381":{"title":"座次排定","content":"江湖有江湖自己的规则，而这个规则之一就是座次的排定。虽说职位的选择相对少了很多，但不同的职位对门派的发展却有着不小的影响，因此绝对不能轻视。门派掌门人就是总舵的舵主，而分舵的就需要自己来指定了。舵主的忠诚、聪明、健康会影响分舵弟子的生产效率，聪明和四大武功属性（攻击、防御、轻功、暗器）将影响弟子的练功效率，聪明和四力会影响弟子的采集效率；左堂主的聪明和四大武功属性会影响弟子的练功效率；右堂主的聪明和四大武功属性影响弟子的采集效率。在3种职位中，舵主必须指定，左、右堂主则可根据需要选择是否指定。但要提醒大家的是，职位的变更会影响到弟子的忠诚，被选为舵主的弟子可以增加20的忠诚度，选为左、右堂主的弟子则可增加10的忠诚度。","titles":["天下霸图2","职位","天下霸图"]},"382":{"title":"行程安排","content":"身为门派掌门人，在风光的背后天天进行着怎样的工作呢？原来每位门人弟子都有12个小铜人，每个小铜人代表1个时辰，在进行行程安排时，在不同的任务栏内放入对应数量的小铜人，就代表这位门人弟子所需要进行这项工作的时间要求。和现实中的人一样，门人弟子在工作之后精力会下降，为了保证他们的状态，必须先留出4个小铜人（4个时辰）作为休息睡眠之用。这样可进行分配的小铜人还有8个，8个小铜人可根据苦力弟子、练功弟子等不同的修行需要放入对应栏目。但非凡要注重，受到任务场地空间的限制（门派设施同一时间内只答应一位弟子进入工作或练习），因而当弟子被安排了某项任务，却因场地没有空间而无法进入时，  门人弟子就会在一旁发呆 （头上有问号），  发呆同样会损耗精力，但对忠诚没有影响 。但考虑到生产或练功的需要，当可以进行分舵扩张时，应根据功用的不同，把不同的分舵分为练功分舵、制造分舵或是采集分舵，这样才能在方便治理的同时，最大限度提高门派发展的效率。","titles":["天下霸图2","职位","天下霸图"]},"383":{"title":"对外交涉","content":"与人为善本是处事之道，面对不同势力把持形成的江湖，怎样在发展中求生存？除去刀劈剑砍之外，广结善缘也不失为一种求存之道。在大多数时间里（第7式除外），江湖上其他门派的发展速度都要远超我们。面对来势汹汹的对手，假如你没有完全把握应对，那么不妨找一名聪明较高的门人弟子，带着金钱或原料资源前去交涉疏通，只要能让双方的友好度保持在40以上，那么得了好处的他也就不会再时刻想着前来对你展开武力行动了。虽然江湖中的十二大门派可分为正邪两道，但实际上无论是正是邪，彼此之间都不存在任何友谊，少林寺同样可能在一夜之间发动对武当山的偷袭，魔教也说不准转眼就杀进了洞庭帮的总舵。正是因此，不要幻想名门正派就一定会光明正大，广撒银钱，自求多福方是活命之选。","titles":["天下霸图2","职位","天下霸图"]},"384":{"title":"属性","content":"流放之路中，升级你能得到什么？所有人物升级所获得的都是一样的A每级+12最大生命B每级+2命中值C每级+3闪避值D每级+6最大魔力E每级+1天赋点人物有三大基础属性：力量，敏捷，智慧每10力量=5生命每5力量=1%近战攻击伤害每10敏捷=1%闪避值每1敏捷=2命中值每5智力=1%增加最大能量护盾每2智力=1魔力a)基本属性i.每秒1.75%最大魔力上限回复速度ii.每秒20%最大能量护盾的充能速度iii.拥有基础的53闪避值iv.基础爆击伤害：150%b)双持（双持的定义在于同时持有2把单手武器，仅限于单手剑，细剑，单手锤，单手斧，匕首，爪，魔杖。其中魔杖属于远程武器，无法跟其他武器同时持有）i.10%更多攻击速度ii.15%格挡iii.20%更多物理攻击伤害c)能量球（看图）d)基础最大值（以下数值都可能被一些暗金装备，天赋，进阶所改变）i.每秒20%最大生命偷取速率ii.每秒20%最大魔力偷取速率iii.75%最大格挡值iv.75%最大混沌抗性上限v.75%最大冰霜抗性上限vi.75%最大火焰抗性上限vii.75%最大闪电抗性上限viii.最多叠加20层腐化之血状态ix.最多5层爆炸箭矢x.最多75%攻击躲避几率xi.最多75%法术躲避几率xii.闪避几率不会低于5%，也不会高于95%（闪避不同于躲避）xiii.最大90%物理伤害减免xiv.可拥有3个陷阱xv.可拥有5个地雷xvi.可召唤1个图腾","titles":[]},"385":{"title":"伤害公式","content":"闪避是角色在受到攻击前的第一层防御形式，闪避会增加角色完全避免受到攻击的几率。与护甲和能量护盾一样，闪避是流放之路的三大基本防御形式之一。所有人物的基础闪避将以53点为开始，每级额外获得3点闪避。人物在一级时，将具有56点闪避，在100级时有353点闪避的基础值。敏捷也能够提供闪避奖励。每增加5点敏捷，闪避将提高1%。5的非整数将四舍五入到最接近的5的整数。闪避除了可以规避伤害，也可以规避其他有害影响，比如异常状态和眩晕。但是只能闪避近战和远程攻击，而法术则会自动命中。而闪避攻击的几率是根据防御者的闪避与攻击者的命中相比得出的。机制公式：命中率的范围：5%—95%。法术没有命中的机制，不受命中的影响，因为闪避不是对应法术对应的防御措施，也因为不会对法术产生影响，所以法术是默认必中的。（但也有办法: 躲避法术。请注意躲避和闪避的区别！）公式一：公式二：实际命中率 = min{ max( 理论命中率 , 0.05) , 1 }。流放之路伤害机制介绍 伤害怎么计算-《流放之路》s13新的诅咒机制有什么 s13新诅咒机制介绍 - DB游戏网 (  thisisdb.com  )   流放之路技能伤害计算公式一览 流放之路技能伤害怎么计算 法术类-游侠网 (  ali213.net  )   《流放之路》暴击和暴击伤害解析 - 哔哩哔哩 (  bilibili.com  )   流放之路POE丨各类防御机制，浅谈各类防御机制的作用 (  qq.com  )   流放之路伤害机制介绍_18183.com   流放之路攻击伤害和物理伤害(流放之路伤害类型)-金芒果软件网 (  ahjmgzs.com  )","titles":[]},"386":{"title":"角色属性","content":"","titles":[]},"387":{"title":"任务","content":"任务类型  内容  效果    押镖送货   增加声望,增加金钱   战斗   增加声望,装备材料   求助  索要物资  增加声望","titles":[]},"388":{"title":"弟子培养差事","content":"任务名称  花费时间  效果    促进思辨   人物经验+5%     学习新技能     技能经验+5%","titles":[]},"389":{"title":"门派内差事","content":"任务名称  花费时间  效果    招募     助工   工坊产值+30%   助医   炼丹产值+30%   助农   粮食产值+30%     采集药材+10%     采集木材+10%     采集矿产+10%   开发黑市   贸易影响+50%   街市繁荣   售卖收入+50%   举孝廉   满意度+10   运权   公共秩序+8","titles":[]},"390":{"title":"初始属性","content":"属性  说明     元气,身法,力道  初始自由分配点60    最大生命值  64    内力值  32    体力  100    心情  100        命中值  2    暴击几率   5%   爆击伤害   50%   魔力回复速度   每秒1.75%   格挡率   15%","titles":[]},"391":{"title":"气质才情","content":"属性  说明     悟性  习武的时候提高的领悟力  用来升级技能   魅力  影响他人的好感，在游戏中需要魅力高的内门弟子去各大门派攻破长老心防；需要魅力高的外门去代理点当主持    机缘  影响角色幸运。同时很多地图事件对机缘有要求，历练时获得物品的概率也和机缘有关。    童趣  当角色  情绪过低 ，会引发一系列的问题：①外门怠工，外门弟子心情低于50，会导致怠工，自动不受控制的闲逛，得到休息后可恢复。②内门心魔，内门弟子长期心情过差（低于100），会导致修炼严重受挫，产生心魔，难以寸进。③弟子叛逃，长期遭受虐待而得不到改善时，弟子会选择叛逃。  角色的情绪稳定标准：最低限度为50，上限为200   正义     邪恶","titles":[]},"392":{"title":"境界属性","content":"属性  说明  说明    武道  用来提高武道境界  每次升级力道+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点   佛法  用来提高佛法境界  每次升级力道身法+5,力道+5,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点   道法   每次升级元气+5,身法+5,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点   儒学   每次升级元气+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点   巫术   每次升级元气+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点   墨家   每次升级身法+10,最大生命值+12,最大魔力+6,命中值+2,闪避值+3,+1天赋点","titles":[]},"393":{"title":"生活属性","content":"属性   最大值    开山  采集矿物  20   扶农  收集粮食  20   本草  采集药品  20   斫木  砍伐木材  20   悬壶  炼制丹药  20   生财  贩卖商品  20   铸造  锻造装备  20   巧匠  制作工艺品  20   威望  可以当门派帮主之类的有额外加成  20   谋略  策略府  20   处世  处理任务  20   学识  书写秘籍  20","titles":[]},"394":{"title":"战斗属性","content":"技能标签 :力道 身法 元气  (力量 敏捷 智力)  火焰 冰冷 闪电 混沌  物理  (伤害类型)  攻击加成  近战加成    元素加成   投射物加成 范围效果  光环   诅咒  持续时间","titles":[]},"395":{"title":"一级属性","content":"属性   说明    元气   增加元气伤害的1%   增加1点护甲   力道   增加力道伤害的1%   增加1点护甲   身法   增加身法伤害的1%   增加0.1全抗   体质   10点气血值   根骨   5点内力值","titles":["战斗属性"]},"396":{"title":"二级属性","content":"","titles":["战斗属性"]},"397":{"title":"使用流程","content":"首先要清楚类库是什么类型，不同的类库有不同的使用方式  寻找声明文件JS类库一般有三类：全局类库、模块类库、UMD库。例如，jQuery是一种UMD库，既可以通过全局方式来引用，也可以模块化引用。","titles":[]},"398":{"title":"声明文件","content":"当我们要使用一个类库时，需要ts声明文件，对外暴露API，有时候声明文件在源码中，大部分是单独提供额外安装。比如jQuery需要额外安装类型声明包。幸运的是，大部分的类库，TS社区都有声明文件。名称为@types/类库名，需要去这个网站搜一下  http://  microsoft.github.io/TypeSearch/如果没有，需要自己去写一个，这也是为社区贡献的好机会。  http://definitelytyped.org/guides/contributing.html 这里提供了一些写声明文件的方法。在写ts声明文件的时候，暂时用不到的API可以可以不写。>下面我将演示，如何在ts文件中使用三种类库。首先准备三个js文件，分别表示全局类库、模块类库、UMD库。","titles":["使用流程"]},"399":{"title":"全局类库","content":"在HTML文件标签中引入该库  将写好的声明文件与js库放在同一文件夹下，命名相同，后缀名为.d.ts  此时可以在ts文件中使用全局API如果此时编译器未报错，而浏览器报错not defined，可能是html中引入的路径是相对路径，改成绝对路径即可（以项目目录为根目录）。声明文件global-lib.d.ts在ts文件中使用该库：","titles":["使用流程"]},"400":{"title":"模块类库","content":"将声明文件放在相同的目录下  在ts中引入声明文件 module-lib.d.tsts中使用类库","titles":["使用流程"]},"401":{"title":"UMD类库","content":"UMD库有两种使用方式：引入全局类库的方式  模块类库引入的方式其中，在使用全局类库的引入方式时，编译器会提示，不建议这样做，需要在tsconfig.json中打开allUmdGlobalAccess配置项可以消除提示。声明文件 umd-lib.d.tsts中使用UMD库（不再演示全局使用方式）例：在ts中使用jQuery（不演示全局引入方式）先安装jquery及其声明文件使用：","titles":["使用流程"]},"402":{"title":"为类库添加插件","content":"即为类库添加自定义的方法其中UMD库和模块类库的添加插件方法一致。例如，为类库moment增添自定义方法（jQuery不可以，需要使用官方提供的API）","titles":["使用流程"]},"403":{"title":"问题","content":"执行  报错","titles":[]},"404":{"title":"解决方案","content":"官方初始化链接：  v3.nuxtjs.org/getting-sta…执行后报错解决：先  是否连通如果不通，访问然后添加host，mac下host配置路径：新增一行，添加完host后，再ping一下    是否连通ping通后，再重新执行成功显示：","titles":[]},"405":{"title":"一、Flex 布局是什么？","content":"Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。Webkit 内核的浏览器，必须加上  前缀。注意，设为 Flex 布局以后，子元素的  、  和  属性将失效。","titles":[]},"406":{"title":"二、基本概念","content":"采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做  ，结束位置叫做  ；交叉轴的开始位置叫做  ，结束位置叫做  。项目默认沿主轴排列。单个项目占据的主轴空间叫做  ，占据的交叉轴空间叫做  。","titles":[]},"407":{"title":"右键发送到菜单位置","content":"右键点击系统桌面左下角的【开始】，在开始菜单中点击【运行】，  在运行对话框中输入：  命令,点击确定或者回车，打开SendTo（发送到）窗口；  或者直接打开 目录","titles":[]},"408":{"title":"Desktop.ini Contents for Various Shell Folders","content":"","titles":[]},"409":{"title":"For Windows 7","content":"ContactsDocumentsDesktopDownloadsFavoritesLinksMusicPicturesRecentSaved GamesSearches","titles":["Desktop.ini Contents for Various Shell Folders"]},"410":{"title":"For Windows Vista","content":"DocumentsPicturesMusicVideosSearches report this adDownloadsFavoritesContactsDesktopLinksSaved GamesPublic DesktopPublic DocumentsPublic MusicPublic PicturesPublic Videos","titles":["Desktop.ini Contents for Various Shell Folders"]},"411":{"title":"Git密钥存储相关","content":"幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：默认所有都不缓存。 每一次连接都会询问你的用户名和密码。  “cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。  “store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。  如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。  如果你使用的是 Windows，你可以安装一个叫做 “winstore” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。 可以在   https://gitcredentialstore.codeplex.com  下载。","titles":[]},"412":{"title":"推荐使用凭证存储模式 \"manager\"","content":"在这里对比 \"wincred\" 和 \"manager\"的区别很明显，在  用户信息暴露 的情况下，其他人很容易通过   https://用户名@[http://github.com](https://link.zhihu.com/?target=http%3A//github.com)  访问到路径对应的项目，为了避免这种  风险 的存在，我们可以安装 “Git Credential Manager for Windows” 的辅助工具。","titles":[]},"413":{"title":"store的使用","content":"“store” 模式可以接受一个    参数，可以自定义存放密码的文件路径（默认是    ）","titles":["推荐使用凭证存储模式 \"manager\""]},"414":{"title":"微软特有的Git Credential Manager","content":"WINDOS部分版本的GIT会提示实际上是缺少微软的 Git Credential Manager","titles":["推荐使用凭证存储模式 \"manager\""]},"415":{"title":"安裝 Git Credential Manager for Windows解决","content":"最新的下载地址为：https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest下载安装完后可以通过命令进行查看是否生效","titles":["推荐使用凭证存储模式 \"manager\"","微软特有的Git Credential Manager"]},"416":{"title":"安裝 Git-Credential-Manager-Core解决","content":"最新的下载地址为：https://github.com/microsoft/Git-Credential-Manager-Core下载安装完后可以通过命令进行查看是否生效","titles":["推荐使用凭证存储模式 \"manager\"","微软特有的Git Credential Manager"]},"417":{"title":"检查验证工具是否在path中","content":"如果提交的时候仍有问题,提示xxxxcommad不可用.查看下你现在使用的credential.helper是否在path中.如果不在则进行手动添加如果使用的是sourcetree 还得查看,他默认使用的git是不是全局的","titles":["推荐使用凭证存储模式 \"manager\"","微软特有的Git Credential Manager"]},"418":{"title":"SourceTree删除GIT密码","content":"","titles":[]},"419":{"title":"store","content":"删除~/.git-credentials","titles":["SourceTree删除GIT密码"]},"420":{"title":"manager","content":"windows存储的初始密码账号不对，导致每次请求远程url都会报错，我们要到控制面板\\用户帐户\\凭据管理器中手动更改我们的credential凭证;如下，是我的凭证配置；只需要编辑下即可，当然你也可以删除你要请求的远程的凭证,我没试过，当你git pull，GIT会让你输入一次用户明和密码，以后每次请求，GIT会从windows凭证中查找；","titles":["SourceTree删除GIT密码"]},"421":{"title":"其他","content":"当GIT服务器修改密码后，sourcetree本地记住的密码，会导致提交代码失败。\n本地删除当前用户目录下保存密码的文件，文件路径：\nC:\\Users\\wuxiaoyuan\\AppData\\Local\\Atlassian\\SourceTree\\passwd\n清空文件内容即可","titles":["SourceTree删除GIT密码"]},"422":{"title":"同网站多账号的问题","content":"如果同一个网站有多个账号..查看->选项->验证编辑那个网站的账号,就会新建一个用户名@xxx.com的账号  然后把那个公用的删除","titles":[]},"423":{"title":"相关链接","content":"https://git-scm.com/book/zh/v2/Git-工具-凭证存储","titles":["同网站多账号的问题"]},"424":{"title":"常用命令","content":"Get-PSDrive  Windows PowerShell 驱动器是一个数据存储位置，你可以像访问 Windows PowerShell 中的文件系统驱动器那样访问它。  Get-Alias 和   ls Alias:(驱动器)     列出所有alias  ls Env:(驱动器)    列出所有的环境变量  ls Variable:(驱动器) 和 Get-Variable 列出所有的变量  ls Function:(驱动器)  列出所有的函数  get-command   查看命令信息 可以查看某个命令的path  get-command mysqldump  invoke-item  向windows桌面双击操作一样打开某个文件或者目录  $env -split \";\"  以列表形式列出所有path  ls env:    列出env驱动器中的内容void NoError()\n{\nvar command = @\"pwd\";\nvar startInfo = new ProcessStartInfo()\n{\nFileName = \"powershell.exe\",\nArguments = $\"-NoProfile -ExecutionPolicy unrestricted -Command \"{command}\"\",\nUseShellExecute = false\n};\nProcess.Start(startInfo);\n}先编码执行一个复杂的命令:","titles":[]},"425":{"title":"使用c#类调用powershell 命令","content":"接著我們在 Program.cs 檔案引用兩個命名空間如下：大功告成，現在你可以將 PowerShell 指令整合到你的 C# 應用程式中了！返回字符窜:捕捉错误:","titles":[]},"426":{"title":"安装scoop前提","content":"版本大于等于3的powershell确保您已允许PowerShell执行本地脚本","titles":[]},"427":{"title":"常用命令","content":"这里是一个按照 Github score（由 Star 数量、Fork 数量和 App 数量综合决定的 Github score）排列的 bucket 列表：  Scoop buckets by Github score 。","titles":[]},"428":{"title":"安装scoop到自定义目录","content":"如果重新安装系统.只需要将shime路径添加到环境变量path中使用第二种方法:一个脚本重置应用以解决冲突,会重置环境变量,快捷方式等..","titles":[]},"429":{"title":"快捷方式","content":"将Scoop安装到自定义目录 \n假设目标目录是  ,在PowerShell命令控制台中运行：将全局应用安装到自定义目录,假设目标目录是  ,在PowerShell命令控制台中运行：","titles":["安装scoop到自定义目录"]},"430":{"title":"安装应用","content":"以我常用应用为例(可作为脚本文件,后缀ps1)","titles":["安装scoop到自定义目录"]},"431":{"title":"apache","content":"","titles":[]},"432":{"title":"修改配置","content":"文件路径","titles":["apache"]},"433":{"title":"Redis","content":"","titles":[]},"434":{"title":"MySQL","content":"注册MySQL服务,(因为scoop是低污染的,所以要自己做):注意mysql8密码可能认证有错误my.ini中需要设置","titles":[]},"435":{"title":"pwsh","content":"将pwsh添加到terminal中,配置默认路径:","titles":[]},"436":{"title":"自制bucket","content":"最佳方式是使用模板   https://github.com/Ash258/GenericBucket","titles":[]},"437":{"title":"如何解压exe的程序","content":"首先下载的时候后面加上#/dl.7z类似的后缀..然后scoop保存的时候.会把他存在7z格式的文件夹例如上面旧会被存在scoop/cache/wnr#1.17.1#https_github.com_RoderickQiu_wnr_releases_download_v1.17.1_wnr-1.17.1-Setup-64.exe_dl.7z然后旧可以解压了安装脚本都是执行在Scoop\\apps\\wnr\\11.XXX\\下面","titles":["自制bucket"]},"438":{"title":"导出 Scoop 软件列表","content":"备份 Scoop 的方式为：可以对 Scoop 的导出列表进行额外处理，以方便后续安装。使用 VSCode 打开    文件，以正则表达式搜索：并全部替换成：注意正则式中包含空格，请完整复制。","titles":["自制bucket"]},"439":{"title":"相关连接","content":"包的版本号   Directory.Build.props的说明","titles":[]},"440":{"title":"RDB优点与缺点","content":"","titles":[]},"441":{"title":"优点","content":"如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。  RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。  RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。","titles":["RDB优点与缺点"]},"442":{"title":"缺点","content":"RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。  每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。","titles":["RDB优点与缺点"]},"443":{"title":"AOF 命令同步","content":"Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的， 为了方便起见， 我们称呼这种记录过程为同步。举个例子， 如果执行以下命令：那么其中四条对数据库有修改的写入命令就会被同步到 AOF 文件中：为了处理的方便， AOF 文件使用网络通讯协议的格式来保存这些命令。比如说， 上面列举的四个命令在 AOF 文件中就实际保存如下：除了   SELECT  命令是 AOF 程序自己加上去的之外， 其他命令都是之前我们在终端里执行的命令。同步命令到 AOF 文件的整个过程可以分为三个阶段：命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。  缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。  文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话，    函数或者    函数会被调用，将写入的内容真正地保存到磁盘中。以下几个小节将详细地介绍这三个步骤。","titles":["RDB优点与缺点"]},"444":{"title":"命令传播","content":"当一个 Redis 客户端需要执行命令时， 它通过网络连接， 将协议文本发送给 Redis 服务器。比如说， 要执行命令    ， 客户端将向服务器发送文本    。服务器在接到客户端的请求之后， 它会根据协议文本的内容， 选择适当的命令函数， 并将各个参数从字符串文本转换为 Redis 字符串对象（  ）。比如说， 针对上面的   SET  命令例子， Redis 将客户端的命令指针指向实现   SET  命令的    函数， 并创建三个 Redis 字符串对象， 分别保存    、    和    三个参数（命令也算作参数）。每当命令函数成功执行之后， 命令参数都会被传播到 AOF 程序， 以及 REPLICATION 程序（本节不讨论这个，列在这里只是为了完整性的考虑）。这个执行并传播命令的过程可以用以下伪代码表示：以下是该过程的流程图：","titles":["RDB优点与缺点"]},"445":{"title":"缓存追加","content":"当命令被传播到 AOF 程序之后， 程序会根据命令以及命令的参数， 将命令从字符串对象转换回原来的协议文本。比如说， 如果 AOF 程序接受到的三个参数分别保存着    、    和    三个字符串， 那么它将生成协议文本    。协议文本生成之后， 它会被追加到    结构的    末尾。结构维持着 Redis 服务器的状态，    域则保存着所有等待写入到 AOF 文件的协议文本：至此， 追加命令到缓存的步骤执行完毕。综合起来，整个缓存追加过程可以分为以下三步：接受命令、命令的参数、以及参数的个数、所使用的数据库等信息。  将命令还原成 Redis 网络通讯协议。  将协议文本追加到    末尾。","titles":["RDB优点与缺点"]},"446":{"title":"文件写入和保存","content":"每当服务器常规任务函数被执行、 或者事件处理器被执行时，    函数都会被调用， 这个函数执行以下两个工作：WRITE：根据条件，将    中的缓存写入到 AOF 文件。SAVE：根据条件，调用    或    函数，将 AOF 文件保存到磁盘中。两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。","titles":["RDB优点与缺点"]},"447":{"title":"AOF 保存模式","content":"Redis 目前支持三种 AOF 保存模式，它们分别是：：不保存。    ：每一秒钟保存一次。    ：每执行一个命令保存一次。以下三个小节将分别讨论这三种保存模式。","titles":["RDB优点与缺点"]},"448":{"title":"不保存","content":"在这种模式下， 每次调用    函数， WRITE 都会被执行， 但 SAVE 会被略过。在这种模式下， SAVE 只会在以下任意一种情况中被执行：Redis 被关闭  AOF 功能被关闭  系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。","titles":["RDB优点与缺点","AOF 保存模式"]},"449":{"title":"每一秒钟保存一次","content":"在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对    或    的调用并不是每秒一次， 它和调用    函数时 Redis 所处的状态有关。每当    函数被调用时， 可能会出现以下四种情况：子线程正在执行 SAVE ，并且：    这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。  这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。  子线程没有在执行 SAVE ，并且：    上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。  上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。可以用流程图表示这四种情况：根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。","titles":["RDB优点与缺点","AOF 保存模式"]},"450":{"title":"每执行一个命令保存一次","content":"在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。","titles":["RDB优点与缺点","AOF 保存模式"]},"451":{"title":"AOF 保存模式对性能和安全性的影响","content":"在上一个小节， 我们简短地描述了三种 AOF 保存模式的工作方式， 现在， 是时候研究一下这三个模式在安全性和性能方面的区别了。对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下：不保存（  ）：写入和保存都由主进程执行，两个操作都会阻塞主进程。  每一秒钟保存一次（  ）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。  每执行一个命令保存一次（  ）：和模式 1 一样。因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。综合起来，三种 AOF 模式的操作特性可以总结如下：模式  WRITE 是否阻塞？  SAVE 是否阻塞？  停机时丢失的数据量      阻塞  阻塞  操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。     阻塞  不阻塞  一般情况下不超过 2 秒钟的数据。     阻塞  阻塞  最多只丢失一个命令的数据。","titles":["RDB优点与缺点"]},"452":{"title":"AOF 文件的读取和数据还原","content":"AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本。这也就是说， 只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。Redis 读取 AOF 文件并还原数据库的详细步骤如下：创建一个不带网络连接的伪客户端（fake client）。  读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。  根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。  执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。完成第 4 步之后， AOF 文件所保存的数据库就会被完整地还原出来。注意， 因为 Redis 的命令只能在客户端的上下文中被执行， 而 AOF 还原时所使用的命令来自于 AOF 文件， 而不是网络， 所以程序使用了一个没有网络连接的伪客户端来执行命令。 伪客户端执行命令的效果， 和带网络连接的客户端执行命令的效果， 完全一样。整个读取和还原过程可以用以下伪代码表示：作为例子， 以下是一个简短的 AOF 文件的内容：当程序读入这个 AOF 文件时， 它首先执行    命令 —— 这个    命令是由 AOF 写入程序自动生成的， 它确保程序可以将数据还原到正确的数据库上。然后执行后面的    和    命令， 还原    和    两个键的数据。为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。","titles":["RDB优点与缺点"]},"453":{"title":"AOF 重写","content":"AOF 文件通过同步 Redis 服务器所执行的命令， 从而实现了数据库状态的记录， 但是， 这种同步方式会造成一个问题： 随着运行时间的流逝， AOF 文件会变得越来越大。举个例子， 如果服务器执行了以下命令：那么光是记录    键的状态， AOF 文件就需要保存四条命令。另一方面， 有些被频繁操作的键， 对它们所调用的命令可能有成百上千、甚至上万条， 如果这样被频繁操作的键有很多的话， AOF 文件的体积就会急速膨胀， 对 Redis 、甚至整个系统的造成影响。为了解决以上的问题， Redis 需要对 AOF 文件进行重写（rewrite）： 创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积。以下就来介绍 AOF 重写的实现方式。","titles":["RDB优点与缺点"]},"454":{"title":"AOF 重写的实现","content":"所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。考虑这样一个情况， 如果服务器对键    执行了以下四条命令：那么当前列表键    在数据库中的值就为    。如果我们要保存这个列表的当前状态， 并且尽量减少所使用的命令数， 那么最简单的方式不是去 AOF 文件上分析前面执行的四条命令， 而是直接读取    键在数据库的当前值， 然后用一条    命令来代替前面的四条命令。再考虑这样一个例子， 如果服务器对集合键    执行了以下命令：那么使用一条    命令， 就可以还原    集合的状态， 这比之前的四条命令调用要大大减少。除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。 整个重写过程可以用伪代码表示如下：","titles":["RDB优点与缺点"]},"455":{"title":"AOF 后台重写","content":"上一节展示的 AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：子进程进行 AOF 重写期间，主进程可以继续处理命令请求。  子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中：换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作：处理命令请求。  将写命令追加到现有的 AOF 文件中。  将写命令追加到 AOF 重写缓存中。这样一来可以保证：现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。  所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。  对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。当步骤 1 执行完毕之后， 现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。当步骤 2 执行完毕之后， 程序就完成了新旧两个 AOF 文件的交替。这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。以上就是 AOF 后台重写， 也即是   BGREWRITEAOF  命令的工作原理。","titles":["RDB优点与缺点"]},"456":{"title":"AOF 后台重写的触发条件","content":"AOF 重写可以由用户通过调用   BGREWRITEAOF  手动触发。另外， 服务器在 AOF 功能开启的情况下， 会维持以下三个变量：记录当前 AOF 文件大小的变量    。  记录最后一次 AOF 重写之后， AOF 文件大小的变量    。  增长百分比变量    。每次当    函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：没有   BGSAVE  命令在进行。  没有   BGREWRITEAOF  在进行。  当前 AOF 文件大小大于    （默认值为 1 MB）。  当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。默认情况下， 增长百分比为    ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。","titles":["RDB优点与缺点"]},"457":{"title":"小结","content":"AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。  AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。  不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。  AOF 重写的目的是用更小的体积来保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求。  AOF 重写是一个有歧义的名字，实际的重写工作是针对数据库的当前值来进行的，程序既不读写、也不使用原有的 AOF 文件。  AOF 可以由用户手动触发，也可以由服务器自动触发。","titles":["RDB优点与缺点"]},"458":{"title":"使用普通用户登陆","content":"","titles":[]},"459":{"title":"生成私钥","content":"生成后可以把 Key comment 改为你想要的名称, 这样下面你在连接的时候可以使用比较熟悉的Username 作为登录名, 然后使用 Ctrl + C 把上面显示的那串 ssh-rsa.. 开头的公钥复制下来. 待会要用到这个.然后保存好你的私钥和公钥到本地目录中..私钥是  用的,公钥是  用的","titles":["使用普通用户登陆"]},"460":{"title":"添加公钥到谷歌云的实例中","content":"点击实例的名称进入实例的详情后. 进入页面后点击上方的修改, 然后拉到下方找到如下图的地方点击添加一项, 把刚刚复制的公钥粘贴进去, 记得, 正确的公钥是在结尾会有一个空格加上你的 Username , 例如: “…== qian”","titles":[]},"461":{"title":"使用SSH工具连接到实例","content":"","titles":[]},"462":{"title":"使用 root 账户登陆和修改root密码","content":"","titles":[]},"463":{"title":"先选择从浏览器打开ssh连接服务器","content":"连接登录成功后，输入以下命令然后会要求输入新密码，然后再重复一次密码，输入密码的时候不会显示出来，所以直接输入密码，然后回车，再然后重复输入密码回车。修改root密码完成","titles":["使用 root 账户登陆和修改root密码"]},"464":{"title":"接着修改SSH配置文件/etc/ssh/sshd_config","content":"然后再输找到以下内容并修改修改完成后，再下按 esc 键，然后再输入最后重启下服务器即可","titles":["使用 root 账户登陆和修改root密码"]},"465":{"title":"安装 pip","content":"pip 是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。在控制台执行以下命令安装 pip：或者","titles":[]},"466":{"title":"安装配置 shadowsocks","content":"在控制台执行以下命令安装 shadowsocks：","titles":[]},"467":{"title":"客户端","content":"需要创建配置文件  ，内容如下：配置说明：server：Shadowsocks服务器地址  server_port：Shadowsocks服务器端口  local_address：本地IP，本地使用的 sock5 代理 ip  local_port：本地端口，本地使用的 sock5 代理端口  password：Shadowsocks连接密码  timeout：等待超时时间  method：加密方式  workers:工作线程数  fast_open：true或false。开启fast_open以降低延迟，但要求Linux内核在3.7+。开启方法 echo 3 > /proc/sys/net/ipv4/tcp_fastopen上述配置需要根据情况进行修改，接下来需要启动服务，就可以通过 local_address 和 local_port 来使用 sock5 代理，流量就可以走 ss 了配置启动脚本文件 /etc/systemd/system/shadowsocks.service启用启动脚本，启动 ss 服务验证安装至此就完成了 ss 客户端的安装配置。","titles":[]},"468":{"title":"前台运行","content":"","titles":["客户端"]},"469":{"title":"后台运行","content":"","titles":["客户端"]},"470":{"title":"method aes-256-gcm not supported 方法","content":"","titles":["客户端"]},"471":{"title":"proxychains","content":"proxychains 的官方介绍：proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies.proxychains 是一种访问代理的方式，用法如下：这样可以使得 curl 走代理来访问网络。","titles":[]},"472":{"title":"安装","content":"首先去   proxychains 官网  下载代码进行编译安装，常规的 configure && make 方式，没啥特别之处。","titles":["proxychains"]},"473":{"title":"配置","content":"创建配置文件proxychains.conf 配置如下：ProxyList 的配置要与上面的 ss 配置一致，即可通过代理访问网络，使用起来还是很方便的。","titles":["proxychains"]},"474":{"title":"用法","content":"proxychains 可以通过启动一个 bash 来使得当前终端全局走代理","titles":["proxychains"]},"475":{"title":"服务端","content":"需要创建配置文件  ，内容如下：说明：为加密方法，可选    为服务监听端口   为密码，可使用  密码生成工具 生成一个随机密码以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。新建启动脚本文件  ，内容如下：执行以下命令启动 shadowsocks 服务：为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：如果服务启动成功，则控制台显示的信息可能类似这样：","titles":["proxychains"]},"476":{"title":"错误","content":"以前在openssl，有  函数.1.1.0版本中替换成为解决办法：找到报错的文件(注意:根据你的python版本修改,看报错信息中使用的openssl文件)全文搜索cleanup将所有  替换成为","titles":[]},"477":{"title":"将brew装在非系统盘","content":"重新安装您在 Mac 上安装过的最新 macOS，但不会升级到更高的版本。    升级到与您的 Mac 兼容的最新 macOS。    需要安装   macOS Sierra 10.12.4  或更高版本重新安装 Mac 随附的 macOS 或仍有提供的最接近版本。","titles":[]},"478":{"title":"切换国内的镜像源","content":"Homebrew 默认使用的是国外的源，在下载时速度可能会比较慢。好在国内的清华大学和中科大提供了 Homebrew 的镜像源，我们可以很轻松的切换源，从而提升我们的下载速度。","titles":[]},"479":{"title":"使用中科大的镜像","content":"执行如下命令，即可切换为中科大的镜像","titles":["切换国内的镜像源"]},"480":{"title":"使用清华大学的镜像","content":"执行如下命令，即可切换为清华大学的镜像","titles":["切换国内的镜像源"]},"481":{"title":"使用 Brewfile 完成环境迁移","content":"设备永久了，我们的电脑中会有大量的软件，如果你需要迁移环境，重新安装会是一个大麻烦，好在 Homebrew 本身为我们提供了一个非常好用的环境迁移的工具 —— Homebrew Bundle你首先需要在之前的电脑中执行    来完成当前环境的导出,导出完成后，你会得到一个   Brewfile 。然后将   Brewfile  复制到新的电脑中，并执行    来开始安装的过程。","titles":["切换国内的镜像源","使用清华大学的镜像"]},"482":{"title":"常用软件","content":"","titles":["切换国内的镜像源","使用清华大学的镜像"]},"483":{"title":"常用链接","content":"https://github.com/Homebrew/homebrew-serviceshttps://sspai.com/post/56009","titles":["切换国内的镜像源","使用清华大学的镜像"]},"484":{"title":"Base / Derived Classes","content":"Each derived class must have its base class marked with [ProtoInclude(, typeof(ProtoBuff-Derived-Class))]. If not, all values will be NULL.","titles":[]},"485":{"title":"Avoid duplicate property tags","content":"Using the same number for ProtoInclude and ProtoMember will generate an error about duplicate property tags. The example below is   NOT  correct.So you need to use a different number for ProtoInclude. Corrected example:","titles":[]},"486":{"title":"Null vs. Empty Collections","content":"ProtoBuf does not understand the difference between a collection (List, IEnumerable etc) being null versus empty (zero count). For example, if you put these objects into the cache,after deserialization, both the lists will have the same value—that is NULL. There are two ways to solve this:Using a private field (we are using this):    Using the OnDeserialized attribute:","titles":[]},"487":{"title":"Things to Remember","content":"ProtoBuf ignores properties if the class inherits from a collection and the Items property for that collection is null. Example:After deserialization, the value of the Folders object will be NULL, because the count of items on is 0.Classes that inherit from special collections are also not supported.","titles":[]},"488":{"title":"AllowParseableTypes","content":"AllowParseableTypes is a global switch that determines whether types with “.ToString()” and “Parse(string)” methods should be serialized as strings. We can use this setting for types that can’t be marked in the ProtoContract but can be parseable.For example, to solve the serialization problem with the Version type:","titles":[]},"489":{"title":"Protobuf-net Generics on Unity3D IL2CPP.","content":"So basically there are two methods that are defined.__PreSerialize – Converts the collection in to a byte array which becomes the proto member.  __PostDeserialize – Converts the byte array back to the collection.We can completely avoid defining run time types for this generic type. Instead of protobuf-net being responsible of creating the type, we create the type by ourselves using the same protobuf Serializer.This kind of technique can be used for other generic types as well. Please comment your ideas about this approach.","titles":[]},"490":{"title":"1、获取github地址","content":"访问   http://github.com.ipaddress.com/  获取cdn域名以及ip地址..或者打开   http://tool.chinaz.com/dns  ,这是一个查询域名映射关系的工具","titles":[]},"491":{"title":"2、获取 global.ssl.fastly地址","content":"http://github.global.ssl.fastly.net.ipaddress.com/  获取cdn域名以及ip地址","titles":[]},"492":{"title":"3、打开hosts映射","content":"","titles":[]},"493":{"title":"Windows环境","content":"最末尾添加两句话保存:打开CMD刷新一下DNS就好了。","titles":["3、打开hosts映射"]},"494":{"title":"Linux环境","content":"添加保存,退出,并重启网络","titles":["3、打开hosts映射"]},"495":{"title":"速度对比:","content":"配置前配置后","titles":["3、打开hosts映射"]},"496":{"title":"添加应用到开始屏幕","content":"右键默认就有添加到开始屏幕","titles":[]},"497":{"title":"备份与恢复","content":"默认布局位于 C:\\Users\\username\\AppData\\Local\\Microsoft\\Windows\\Shell\\ ..注意这是默认布局真实的布局是存在与注册表中","titles":[]},"498":{"title":"其他路径","content":"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\ProgramsC:\\Users\\zhepama\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs","titles":["备份与恢复"]},"499":{"title":"相关链接","content":"https://docs.microsoft.com/zh-cn/windows/configuration/customize-and-export-start-layout#export-the-start-layout   https://docs.microsoft.com/en-us/powershell/module/startlayout/import-startlayout?view=win10-ps","titles":["备份与恢复"]},"500":{"title":"使用npm安装gitbook","content":"现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm，打开命令行，执行以下命令安装 GitBook：使用  Git Bash 操作如下图：好了，准备好了三件套工具之后，就是来看看怎么编写  GitBook 了。","titles":[]},"501":{"title":"编写GitBook","content":"","titles":["使用npm安装gitbook"]},"502":{"title":"创建电子书的文件夹目录","content":"想象一下，现在你准备构建一本书籍，你在硬盘上新建了一个叫 mybook 的文件夹，按照以前的做法，你会新建一个 Word 文档，写上标题，然后开始巴滋巴滋地笔耕。","titles":["使用npm安装gitbook","编写GitBook"]},"503":{"title":"初始化Gitbook","content":"但是现在有了 GitBook，你首先要做的是在 mybook 文件夹下执行以下命令：使用  初始化gitbook，操作如下：执行完后，你会看到多了两个文件 —— README.md 和 SUMMARY.md，它们的作用如下：README.md —— 书籍的介绍写在这个文件里  SUMMARY.md —— 书籍的目录结构在这里配置","titles":["使用npm安装gitbook","编写GitBook"]},"504":{"title":"使用Typora来编写框架内容","content":"这时候，我们启动恭候多时的 Typora 来编辑这两个文件了：编辑 SUMMARY.md 文件，内容修改为：显示如下：","titles":["使用npm安装gitbook","编写GitBook"]},"505":{"title":"重新使用gitbook根据目录，初始化篇章","content":"然后我们回到命令行，在 mybook 文件夹中再次执行    命令。GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。Typora 是所见即所得（实时渲染）的 Markdown 编辑器，这时候它是这样的：","titles":["使用npm安装gitbook","编写GitBook"]},"506":{"title":"启动服务，预览书籍","content":"接着我们执行    来预览这本书籍，执行命令后会对 Markdown 格式的文档进行转换，默认转换为 html 格式，最后提示 “Serving book on   http://localhost:4000 ”。嗯，打开浏览器看一下吧：","titles":["使用npm安装gitbook","编写GitBook"]},"507":{"title":"结合 GitHub Pages","content":"GitHub Pages 是 GitHub 提供的静态网站托管服务。GitHub 上的每个仓库都可以拥有一个 GitHub Pages，对应的 URL 如下：GitHub Pages 的静态资源支持下面 3 个来源：分支    分支的    目录    分支执行下面命令，将    目录推送到 GitHub 仓库的    分支。或者在生成静态网页时，将保存的目录指定为然后直接推送到 GitHub 仓库的。","titles":["使用npm安装gitbook"]},"508":{"title":"快速开始","content":"如果你是一个前端项目，可以使用    的模板，点击此时生成了一个文件   ，修改内容如下执行    操作，此时可以在    的    标签页看到执行结果","titles":[]},"509":{"title":"安全相关","content":"如何在    上访问敏感数据？如使用    登录时如何维护密码。我们可以在 github repo 上依次点击    ->    设置这里的    就是一种   ，描述 CI/CD 一个    中的上下文信息，使用    语法表示。除了   ，还有:    的信息，如    可以获取当前的   ，我们可以利用它为    或者    打入版本号   : 环境变量   : 当前执行    的信息，如    表示当前    的执行状态   : 描述一些构建信息，如    以及    版本号更多    信息可以参考官方文档   Contexts and expression syntax for GitHub Actions[4]","titles":[]},"510":{"title":"自动创建项目Release","content":"有些项目在发布新版本时，一般都会创建一个  ，并且把对应编译好之后的文件上传到  的资源列表中，例如：如果这个使用手动操作的话，不仅步骤重复又繁琐(每次都要编译出各个操作系统对应的发行包再进行上传)，而且最蛋疼的是对于国内的网络环境来说，上传文件速度简直不能忍，好不容易上传了一大半搞不好就因为网络原因又要重新上传，相信用过的人都深有体会。我就在想如果能用  来创建  ,并且做对应的编译和上传，那上面的问题都可以迎刃而解了，于是在官方市场搜索了一下  关键字，果然已经有提供对应的  了：create-release : 用于创建 release   upload-release-asset : 用于上传资源到对应的 release 中接着创建一个  ，我测试的仓库地址是  https://github.com/monkeyWie/github-actions-demo ，项目用 go 语言写的，代码非常简单就是两个 hello world 级别的代码，里面包含了普通的 go 程序和 cgo 程序。项目的构建流程是在项目  的时候，触发 workflow，通过  编译出来  三个操作系统对应的 64 位可执行文件，再根据  和  来创建对应的  ，并将编译好的文件上传。同样的创建一个  文件，内容如下：构建流程如下：监听 tag name 为  开头的 push  运行一个 job，在  虚拟机环境下  拉取源码，安装  环境  使用  交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩  使用  交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩  使用  创建 Release，其中会用到  ，这是  内置的一个  秘钥 ，用于授权访问你自己的 github 存储库，原理就是使用这个  调用  来进行创建 release，还有一个  也是  内置的一个  变量 ，然后通过 action 的  进行参数传递。  使用  上传文件，这里使用了两个表达式  和  ，可以获取到指定  的输出，第一个是获取创建好的 release 对应的上传地址，第二个是获取对应的 tag(例如：v1.0.0)，这样就可以在把上传的文件带上版本号。因为这个  不支持多个文件上传，所以就写了多个 action 进行上传。","titles":[]},"511":{"title":"ssh命令","content":"","titles":[]},"512":{"title":"dotFx","content":"https://dotnet.github.io/docfx/tutorial/docfx_getting_started.html","titles":[]},"513":{"title":"Hexo","content":"","titles":[]},"514":{"title":"gitbook","content":"","titles":[]},"515":{"title":"市场","content":"https://github.com/marketplacehttps://docs.github.com/cn/actions/configuring-and-managing-workflows/using-environment-variables","titles":[]},"516":{"title":"使用hexo","content":"","titles":[]},"517":{"title":"GITHUB ACTIONS","content":"添加此action前记得先添加分支gh-pages,并设置github的pages为该分支","titles":["使用hexo"]},"518":{"title":"cmd","content":"","titles":[]},"519":{"title":"powershell","content":"","titles":[]},"520":{"title":"linux","content":"","titles":[]},"521":{"title":"GIT","content":"","titles":[]},"522":{"title":"如何发现的？","content":"","titles":[]},"523":{"title":"查看C盘存储","content":"打开所有设置->系统->存储->选择C盘\n   查看C盘使用情况，可以查看“其他”中情况\n   发现.nuget文件夹占用的空间很大，这是由于VS的默认nuget包路径：C:\\Users{UserName}.nuget\\packages","titles":["如何发现的？"]},"524":{"title":"如何解决？","content":"NuGet 的行为由一个或多个 NuGet.Config (XML) 文件（可存在于项目范围、用户范围和计算机范围的级别）中的累积设置驱动。在解决方案文件夹中，设置应用于子文件夹中的所有项目。 请注意，如果配置文件位于项目文件夹中，则对该项目没有任何影响  设置应用于所有操作，但可被任何项目级的设置替代。\nWindows：  \nMac/Linux：   或    设置虽然适用于计算机上的所有操作，但会被任何用户级或项目级设置覆盖。\nWindows：  \nMac/Linux：  。 Mac/Linux:   . 如果    的值是 null 或为空，将使用    或   （因 OS 版本而异）发现占用空间资源比较大的时用户级别的nuget包..我们只要把这个文件夹移动到其他驱动器就可以.以下两种方法都行,建议第二种.因为nuget.exe还需要安装1.可以直接使用命令行2.直接修改配置文件  添加globalPackagesFolder节点","titles":[]},"525":{"title":"参考连接","content":"常见的 NuGet 配置 | Microsoft Docs   nuget.config 文件引用 | Microsoft Docs","titles":[]},"526":{"title":"包缓存太大","content":"每次运行Unity都会发现自己的C盘空间在急剧缩小，查了一下发现是C:\\Users\\Username\\AppData\\Local\\Unity\\cache这个文件夹特别大，它主要是存储一些Unity常用的packages，默认都是存在C盘下。\n为了拯救C盘空间，可以通过设置环境变量的方式解决，具体请参考  Global Cache ，或  Configure Unity Package Manager global cache location 。添加环境变量","titles":[]},"527":{"title":"商店资源太大","content":"使用cmd,注意powershell是不支持mklink的https://forum.unity.com/threads/asset-store-download-folder.83620/page-2Customizing the shared cache locations - Unity 手册","titles":[]},"528":{"title":"微软DNS服务器——可以长期信赖的稳定服务器。","content":"主用：4.2.2.1备用：4.2.2.2如果你使用win10,且要经常登录微软账号.一定要设置一个","titles":[]},"529":{"title":"国内公共DNS服务提供商：","content":"百度DNS服务器——延迟很小，毕竟是大品牌，响应速度也不错，口碑不错。  ​\t主用：180.76.76.76  腾讯DNS服务器——延迟小，响应快，口碑不错。  ​\t主用：119.29.29.29  ​\t备用：182.254.116.116  阿里DNS服务器——延迟小，响应快，口碑不错。  ​\t主用：223.5.5.5  ​\t备用：223.6.6.6  CNNIC中国互联网络信息中心 DNS服务器——国家队产品，地址好记，经常用来做网络连通性测试的。  ​\t主用：1.2.4.8  ​\t备用：202.98.0.68","titles":[]},"530":{"title":"添加Nginx.conf配置","content":"","titles":[]},"531":{"title":"修改Cockpit","content":"这时输入域名，能看到登录页面，但登录后，显示不出内容，页面全白","titles":[]},"532":{"title":"参考链接","content":"Proxying Cockpit over nginx · cockpit-project/cockpit Wiki (github.com)   https://cloud.tencent.com/document/product/400/35244","titles":[]},"533":{"title":"安装","content":"在下载目录按住 shift 键，然后鼠标右键，打开 Powershell执行安装命令，此处只安装了 64 位安装包，建议在安装时把 32 位也一并下载安装此时点击开始菜单应该就能看到应用商店了清空应用商店缓存 WSReset.exe应用商店 ID 为 9WZDNCRFJBMP应用安装器 ID 为 9NBLGGH4NNS1https://github.com/dragonflylee/WimHelperhttps://github.com/kkkgo/LTSB-Add-MicrosoftStorehttps://www.microsoft.com/zh-cn/store","titles":[]},"534":{"title":"前言","content":"最近在打包 VS Code 插件时，发现打包后的插件体积非常大，而且插件在 VS Code 中的启动速度非常慢，对用户的体验不太友好了。对此做了一些研究，并更改了打包策略，终于把插件的体积从 35M 减少到 3M，并提高了插件的启动速度。本文将带你分析插件体积过大和启动速度过慢的原因，并讲解如何通过使用 webpack 进行打包来减少插件体积。最后将讲解如何配置 externals 剥离一些依赖模块，减少 bundle 的体积，避免出现打包失败的问题。","titles":[]},"535":{"title":"原始打包","content":"首先，我们会以 iceworks-page-builder VS Code 插件为例子进行分析，具体的代码可以点击  此链接 查看。其中，部分目录结构说明如下：打包插件需要使用   vsce  这个工具。 首先确认已安装    ；若未安装，则执行以下的命令安装    ：在项目的根目录下执行以下命令，即开始对插件进行打包：它会先执行 scripts 中的    命令。从上面可以看出，会先对 Webview 相关的代码进行构建（本质是 CLI 提供的构建能力），得到 js 、html 、css 代码，然后使用    对插件源代码（./src/**）进行编译。等待    执行完成后，    将执行剩下的插件打包操作，最后会在项目根目录下出现一个 .vsix 文件，也就是我们成功打包出来的插件。现在，整个插件的体积是   35M ，在 VS Code 中启动速度大概为   8s 。插件启动效果图如下：那我们有办法知道究竟是哪些文件导致这个 .vsix 文件这么大的吗？答案是有的。我们只需要把 .vsix 的后缀改成 .zip，然后把这个 zip 文件进行解压，即可看到整个插件是由哪些文件构成了。可以看出其中的 node_modules 目录的体积是最大的，这是导致插件体积过大的问题。另外，build 目录和node_modules 目录下有很多模块，正是如此，VS Code 在加载我们的插件的过程中，会加载很多小模块，这就是加载过慢的原因。","titles":[]},"536":{"title":"使用 webpack 进行打包","content":"相信大部分的前端开发者都知道，现在的模块化的前端开发范式非常流行，与此同时出现了很多模块构建工具，比如 Rollup、webpack 等。这些模块构建工具的出发点之一是，把多个模块打包成一个模块，解决加载多个模块速度过慢的问题。那我们能不能用这些构建工具，把多个小的源文件打包成单个入口文件，从而解决上述的问题呢？答案是肯定的。首先我们需要安装一下    和    ，其中，    是 Webpack 的核心模块，    是    的 CLI 程序，用来在命令行中调用    。另外还需要安装    ，用于加载    代码并编译成    代码。安装完成以后，我们需要在根目录下新建一个    ，并增加以下的内容：修改    中    的内容，以使用    进行打包：由于经过    打包后， bundle 中都已经包括了需要的模块。我们可以修改    的内容，把插件打包中不需要的文件忽略掉，当然我们的    也可以忽略掉：以上的相关配置可以点击  此链接 进行查看。在官方文档中，有一个章节专门讲解了如何使用 webpack 对插件进行打包。更详细的步骤可以参考  文档 。**","titles":[]},"537":{"title":"使用 externals 减少 bundle 体积","content":"当配制好 webpack 相关配置，使用 webpack 打包构建插件时，出现以下的错误：大概的问题是，使用 webpack 在生产环境下进行打包时，会使用   terser  对源码进行压缩。但是我们的 bundle 太大了（预计 bundle 的大小超过10M的时候），导致在压缩的过程中出现内存溢出的问题。我们使用    来分析 bundle 的组成。 bundle 的依赖模块组成具体如下图：可以看出我们项目依赖的    占用了 bundle 中非常大的体积。那我们现在需要借助 webpack 中的 externals，不要把该依赖打包到 bundle 中，而是作为一个外部扩展，在运行时再去从外部获取依赖。我们可以先在 webpack.config.js 中配置 externals :确保插件在打包的时候，相关依赖也存在于插件中，需要在    文件中加入以下内容（这里真的踩了坑了）：配置完成后，再进行打包，最后打包的插件体积为   3.6M ，在 VS Code 中启动速度降到了   1s  ，效果图如下：","titles":[]},"538":{"title":"总结","content":"如果大家在打包 VS Code 插件时，如果打包出来的插件的体积过大，不妨可以考虑使用 webpack 对你的 VS Code 插件进行打包，会让你的插件有更小的体积，更快的启动速度，更好的用户体验。","titles":[]},"539":{"title":"构建","content":"设置构建命令设置构建物","titles":[]},"540":{"title":"部署","content":"设置下载路径设置部署脚本","titles":[]},"541":{"title":"注意点","content":"仓库的名称不要例如igiven.github.io.不然部署时拉取仓库会失败  添加主机时必须使用python2.7","titles":[]},"542":{"title":"复刻仓库","content":"On GitHub.com, navigate to the   octocat/Spoon-Knife  repository.  在页面的右上角，单击   Fork（复刻） 。","titles":[]},"543":{"title":"增加复刻的仓库作为上游远程仓库","content":"后续就可以进行合并操作了https://docs.github.com/cn/get-started/quickstart/fork-a-repo","titles":[]},"544":{"title":"官方文档","content":"code-server v4.0.2 docs (  coder.com  )   coder/code-server: VS Code in the browser (  github.com  )","titles":[]},"545":{"title":"原理基础","content":"code-server是一款基于VScode的在线编辑器,主要用于在Linux服务器环境下,实现任何设备通过浏览器即可访问VScode, 进而实现在远程编程.","titles":[]},"546":{"title":"安装","content":"","titles":[]},"547":{"title":"linux标准安装方式","content":"","titles":["安装"]},"548":{"title":"Fedora, CentOS, RHEL, SUSE","content":"","titles":["安装"]},"549":{"title":"windows","content":"推荐使用yarn或者npm进行安装","titles":["安装"]},"550":{"title":"配置","content":"配置文件一般在  ,可以将ip配置成  ,然后将域名解析到该服务器安装nginx,并且配置https,否则很多插件不能使用nginx.配置文件","titles":["安装"]},"551":{"title":"title : \"amd 超频总结\"","content":"先超cpu再超内存..内存超频问题会影响cpu超频.内存超频的问题也会导致黑屏  pbo中的温度墙以及负压,对于定频定压没有效果  进入系统后立即黑屏.可以打开防掉压,或者继续加电压,电压过低也会导致黑屏  定压定频的功率会高与pbo的功率  定压定频,由于没有温度墙等限制..一定要注意温度..基本上黑屏重启都是cpu的温度造成的..cpu核心温度超过100就会黑屏  所以如果定压定频的话,一定要确保你有一个好的散热风扇,因为多开应用或者持续高使用率,由于没有温度墙会升高温度,造成黑屏","titles":[]},"552":{"title":"使用ja-netfilter激活IDEA 2022.2.1","content":"","titles":[]},"553":{"title":"背景","content":"截止至2022年9月4日，最新的IDEA版本为2022.2.1，对于某些想体验最新版IDEA却暂时没法入正的开发者来说，不能体验新版非常遗憾。  \n重置IDEA体验版的插件  已经失效了，不过开发此插件的作者又开发出另一款工具  ja-netfilter ，但是文档中使用方法写的有些模糊，我就以我自己的使用经验分享给大家。此方法目前适用于IDEA 2022.2.1，更高的版本不保证适用，请注意时效。","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"554":{"title":"下载IDEA","content":"如果你已经安装了任意版本的IDEA，那么建议你先卸载并清除数据再安装，否则激活可能无效。官网下载IDEA 2022.2.1","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"555":{"title":"下载ja-netfilter","content":"作者博客找最新版本的release下载即可下载地址","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"556":{"title":"使用ja-netfilter","content":"将下载好的  解压到磁盘，最好不要有空格，注意文件后期不能删除，所以请放在自己不会清理的位置。解压后是这样：解压后在ja-netfilter.jar同目录下应该会有一个  文件夹，找到里面的几个配置文件进行修改。","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"557":{"title":"修改dns.conf","content":"","titles":["使用ja-netfilter激活IDEA 2022.2.1","使用ja-netfilter"]},"558":{"title":"修改url.conf","content":"","titles":["使用ja-netfilter激活IDEA 2022.2.1","使用ja-netfilter"]},"559":{"title":"修改IDEA VMOPTION文件","content":"找到IDEA安装目录,再进入bin目录，找到  文件，在最后一行添加此处需要根据你自己解压的路径去修改，路径中的斜杠使用  或者  ，建议路径中不要包含空格。完整的文件内容应该是这样的","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"560":{"title":"激活IDEA","content":"打开IDEA，IDEA会提示你激活，选择输入激活码。打开这个网站   https://3.jetbra.in/  等待片刻，选择一个可以访问的网站，然后找到IDEA的卡片选择复制激活码。填入到IDEA中，点击激活就完成了，不需要关心激活到期时间。","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"561":{"title":"常见问题","content":"","titles":["使用ja-netfilter激活IDEA 2022.2.1"]},"562":{"title":"IDEA提示激活码无效 Invalid key","content":"如果有登录账号，可以先退出账号试试，再不行就重装IDEA，我就是这么做的。","titles":["使用ja-netfilter激活IDEA 2022.2.1","常见问题"]},"563":{"title":"IDEA无法启动 运行无反应","content":"看看任务管理器有没有  这个进程，有就把它关了。","titles":["使用ja-netfilter激活IDEA 2022.2.1","常见问题"]},"564":{"title":"硬體需求","content":"根據   StableDiffusion 官網  所寫，只要有 6G 以上 RAM 的 NVidia 顯卡都可以跑。不過根據 jimmy 實測，4G 的 1050ti 就可以順利運行了。(在我們這次使用的網頁介面實作項目   AUTOMATIC1111/stable-diffusion-webui  裡提到，2G 也有成功運行的報告)","titles":[]},"565":{"title":"安裝步驟","content":"","titles":[]},"566":{"title":"1. 下載並安裝 github for windows","content":"這裡我們用 Windows 平台為範例來說明。  \n首先到   https://gitforwindows.org  下載 git for windows，並安裝。 ( 安裝過程中可取消與 Windows Exploer 整合 )安裝前可以取消 Windows Explorer integration","titles":["安裝步驟"]},"567":{"title":"2. 下載並安裝 Python","content":"a. 到   https://www.python.org/downloads/release/python-3106  下載 Windows installer (64-bit) 版本   (這兩天 Python 的版本更新到了 3.11.0，但 AUTOMATIC1111 表示這個程式是基於 3.10.6 版開發的，除非你想給自己找麻煩，否則請不要使用其他版本 )  \nb. 安裝時記得勾選 Add Python.exe to PATH記得要把    打勾设置pip源（一定要设置清华大学的，阿里的有点问题）更新pip","titles":["安裝步驟"]},"568":{"title":"3. 下载模型","content":"经过测试目前sd2.0只有以下两种模型可以用 ，其他模型加载都会报错，github上看了issue上大家都有遇到这个问题768-v-ema.ckpt这个模型需要生成的图片在768  768的时候效果比较好，如果是生成512 512的，图片有点拉垮；512-base-ema.ckpt如果显存不够的，比较小的，可以使用这个模型；比较推荐768，效果比512的好；安装模型","titles":["安裝步驟"]},"569":{"title":"4. 正式安裝 Stable Diffusion","content":"在国外，安装Stable Diffusion比较简单，但是由于国内的网络环境，安装过程中可能会遇上不少麻烦。编辑“launch.py”（此处我是用的是Visual Studio Code，Linux则需要用到特定的文本编辑器）。替换前替换所有的“  https://github.com”为“https://ghproxy.com/https://github.com”。这里也是利用Ghproxy进行代理，加速国内Git。替换完成后注意保存。","titles":["安裝步驟"]},"570":{"title":"参数解释","content":"xformers：优化显存占用情况的插件  precision full和no-half：完全精度和非半精度，也就是使用32位浮点运算而不是使用16位浮点运算，开启这两个参数会让显存占用增加，但图的质量会更好，但是cpu和16XX显卡必须开启，不然黑图或者绿图  lowvram和medvram  低内存和中内存  share 会生成一个供外部访问的链接  api 启动api,主要是供插件使用","titles":["安裝步驟"]},"571":{"title":"当前遇到的问题","content":"modules.devices.NansException: A tensor with all NaNs was produced in Unet. This could be either because there's not enough precision to represent the picture, or because your video card does not support half type. Try setting the \"Upcast cross attention layer to float32\" option in Settings > Stable Diffusion or using the --no-half commandline argument to fix this. Use --disable-nan-check commandline argument to disable this check.if you plan to use SD 2.1 models, you go to Settings -> User Interface and set Quicksettings list to    then click Apply settings and Reload UI. This adds a checkbox (Upcast cross attention layer to float32) next to the model dropdown that should be checked whenever using SD 2.1 models. Uncheck it after you load a model that is not SD 2.1 based.","titles":["安裝步驟"]},"572":{"title":"CGI","content":"CGI（Common Gateway Interface）通用网关接口，是一个协议，是外部应用程序（CGI 程序）与 Web 服务器之间的接口标准，该协议定义了 Web 服务器调用外部应用程序的时候需要输入的参数，和给 Web 服务器的返回结果。通俗来说，它规定一个程序该如何与 Web 服务器程序之间通信，从而可以让这个程序跑在 Web 服务器上。","titles":[]},"573":{"title":"起源","content":"最早的 Web 服务器简单地响应浏览器发来的 HTTP 请求，并将存储在服务器上的 HTML 文件返回给浏览器，也就是静态 HTML。这个场景下的服务器一般被称为 HTTP 服务器，常见的有 Apache 的 httpd 和 Nginx。事物总是不 断发展，网站也越来越复杂，所以出现动态技术。但是服务器并不能直接运行 php、asp这样的文件，自己不能做，外包给别人吧，但是要与第三做个约定，我给你什么，然后你给我什么，就是握把请求参数发送给你，然后我接收你的处 理结果给客户端。那这个约定就是 Common Gateway Interface，简称 CGI。这个协议可以用 VB、C、PHP、Python 来实现。CGI只是接口协议，根本不是什么语言。引入 CGI 以便客户端请求能够触发 Web 服务器运行另一个外部程序，客户端所输入的数据也会传给这个外部程序，该程序运行结束后会将生成的 HTML 和其他数据通过 Web 服务器再返回给客户端（即动态请求，比如基于 PHP、Python、Java 实现的应用）。利用 CGI 可以针对用户请求，动态返回给客户端各种各样动态变化的信息。","titles":[]},"574":{"title":"工作原理","content":"Web 服务器与 CGI 程序的交互Web 服务器将根据 CGI 程序的类型决定数据向 CGI 程序的传送方式，一般是通过标准输入/输出流和环境变量来与 CGI 程序间传递数据。如下图所示：CGI 程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外 CGI 程序还通过环境变量来得到输入，操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。Web 服务器和 CGI 接口又另外设置了一些环境变量，用来向 CGI 程序传递一些重要的参数。常用 CGI 环境变量：每当客户请求 CGI 的时候，WEB服务器就请求操作系统生成一个新的CGI解释器进程（如 php-cgi.exe），CGI 的一个进程则处理完一个请求后退出，下一个请求来时再创建新进程。当然，这样在访问量很少没有并发的情况也行。但当访问量增大，并发存在，这种方式就不适合了，于是就有了FastCGI","titles":[]},"575":{"title":"FastCGI","content":"FASTCGI 是 Web 服务器（ex:Nginx）和语言解释器（ex:uWsgi）两者底层的通信协议的规范，是对CGI的开放的扩展。CGI的一个扩展，像是一个常驻（long-live）型的CGI ，废除了 CGI fork-and-execute （来一个请求 fork 一个新进程处理，处理完再把进程 kill 掉）的工作方式，转而使用一种长生存期的方法，减少了进程消耗，提升了性能。而FastCGI 则会先 fork 一个 master 进程，解析配置文件，初始化执行环境，然后再 fork 多个 worker 进程（与 Nginx 有点像），当 HTTP 请求过来时，master 进程将其会传递给一个 worker 进程，然后立即可以接受下一个请求，这样就避免了重复的初始化操作，效率自然也就提高了。而且当 worker 进程不够用时，master 进程还可以根据配置预先启动几个 worker 进程等着；当空闲 worker 进程太多时，也会关掉一些，这样不仅提高了性能，还节约了系统资源","titles":[]},"576":{"title":"php-fpm","content":"FastCGI 只是一个协议规范，需要每个语言具体去实现，  PHP-FPM 就是 PHP 版本的 FastCGI 协议实现 ，有了它，就是实现 PHP 脚本与 Web 服务器（通常是 Nginx）之间的通信，同时它也是一个 PHP SAPI，从而构建起 PHP 解释器与 Web 服务器之间的桥梁。Php-fpm全称是php fastcgi process manager即php fastcgi进程管理器，相比fastcgi静态的唤起cgi，fpm能根据访问的压力动态的唤起cgi进程和销毁以到达动态的调整cgi数量，这样可以有效的使用内存。除此之外还有其它的一些优点，比如，fpm还可以平滑的重载php配置；由于fpm是使用Unix-Socket来和服务器通讯，所以也不用再配置cgi端口；fpm有更好的状态输出和slowlog日志，502的时候能给出更多的错误细节。PHP-FPM 负责管理一个进程池来处理来自 Web 服务器的 HTTP 动态请求，在 PHP-FPM 中，master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程进行处理，worker 进程主要负责动态执行 PHP 代码，处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。这就是 PHP-FPM 的基本工作原理","titles":[]},"577":{"title":"WSGI / uwsgi / uWSGI","content":"在 Python Web 开发中，我们经常使用 Uwsgi 配合 Nginx 部署一个 Web 框架，如 Django 或 flask。同时我们又会说，框架和 Web 服务器之间要符合 WSGI 协议。那就来厘清一下这几个概念。Web 服务器和 Web框架在讲 uWSGI 和 WSGI 之前，先要弄清楚 Web 开发的两大块，Web服务器和Web框架。Web服务器即用来接受客户端请求，建立连接，转发响应的程序。至于转发的内容是什么，交由Web框架来处理，即处理这些业务逻辑。如查询数据库、生成实时信息等。Nginx就是一个Web服务器，Django或flask就是Web框架。那么如何实现uWSGI和WSGI的配合呢？如何做到任意一个Web服务器，都能搭配任意一个框架呢？这就产生了WSGI协议。只要Web服务器和Web框架满足WSGI协议，它们就能相互搭配。所以WSGI只是一个协议，一个约定。而不是Python的模块、框架等具体的功能。而uWSGI，则是实现了WSGI协议的一个Web服务器。即用来接受客户端请求，转发响应的程序。实际上，一个uWSGI的Web服务器，再加上Django这样的Web框架，就已经可以实现网站的功能了。","titles":[]},"578":{"title":"WSGI","content":"WSGI，（WEB SERVER GATEWAY INTERFACE），Web服务器网关接口，是一种Web服务器网关接口，它是一个Web服务器（如Nginx，uWSGI等服务器）与Web应用（如Flask框架写的程序）通信的一种规范。  当前运行在WSGI协议之上的Web框架有Bottle，Flask，Django实现了Python Web程序与服务器之间交互的通用性。有了这个东西，web.py或者bottle或者django等等的Python Web开发框架，就可以轻松地部署在不同的Web server上了，不需要做任何特殊配置（也需要一些小小的配置调整）WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和application组合实现自己的Web应用。例如 uWSGI和 Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的Web框架，可以根据项目实际情况搭配使用。像Django，Flask框架都有自己实现的简单的WSGI server，一般用于服务器调试，生产环境下建议用其他WSGI server，WSGI服务器的选择很多，包括uWSGI和gunicorn","titles":[]},"579":{"title":"uwsgi","content":"同WSGI一样是一种通信协议uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。","titles":[]},"580":{"title":"uWSGI (服务器)","content":"它是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。用于接收前端服务器转发的动态请求并处理后发给 Web 应用程序。因为apache也好，Nginx也罢，它们自己都没有解析动态语言如php的功能，而是分派给其他模块来做，比如apache就可以说内置了php模块，支持的非常爽，让人感觉好像apache就支持php一样。uwsgi实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。uWSGI是使用C编写的，显示了自有的uwsgi协议的Web服务器。它自带丰富的组件，其中核心组件包含进程管理、监控、IPC等功能，实现应用服务器接口的请求插件支持多种语言和平台，比如WSGI、Rack、Lua WSAPI，网管组件实现了负载均衡、代理和理由功能uWSGI也可以当做中间件。如果是Nginx+uWSGI+App，那uWSGI就是一个中间件  如果是uWSGI+App，那它就是服务器","titles":[]},"581":{"title":"Nginx+uWGSI","content":"假设我们使用 Python 的 Django 框架写了一个网站，现在要将它挂在网上运行，我们一般需要：Nginx 做为代理服务器：负责静态资源发送（js、css、图片等）、动态请求转发以及结果的回复。  uWSGI 做为后端服务器：负责接收 Nginx 转发的请求并处理后发给 Django 应用以及接收 Django 应用返回信息转发给 Nginx。  Django 应用收到请求后处理数据并渲染相应的返回页面给 uWSGI 服务器。一个Django应用，通过WSGI协议连接uWSGI服务器，uWSGI服务器实现WSGI、http等协议，通过uwsgi协议和Nginx服务器实现http的动态请求和转发以及结果问题：有 uWGSI 了，Django 为什么还需要 Nginx？一个普通的个人网站，访问量不大的话，当然可以由 uWSGI 和 Django 构成。但是一旦访问量过大，客户端请求连接就要进行长时间的等待。这个时候就出来了分布式服务器，我们可以多来几台 Web 服务器，都能处理请求。但是谁来分配客户端的请求连接和 Web 服务器呢？Nginx 就是这样一个管家的存在，由它来分配。这也就是由 Nginx 实现反向代理，即代理服务器。Nginx 是一个 HTTP 和反向代理服务器正向代理：正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器  反向代理：反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器使用Nginx作为反向代理服务器的好处：安全不管什么请求都要经过代理服务器，可以避免外部程序直接攻击Web服务器负载均衡根据请求情况和服务器负载情况，将请求分配给不同的Web服务器，保证服务器性能提高Web服务器的IO性能请求从客户端传到Web服务器是需要时间的，传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以由反向代理完整接受该请求，然后再传给Web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过Web服务器","titles":[]},"582":{"title":"总结","content":"WSGI是一种通信协议  uwsgi是一种通信协议，常用于在uWSGI服务器与其他网络服务器的数据通信  而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器百度百科上说uwsgi是一种线路协议而不是通信协议，个人更倾向于uwsgi是类似WSGI的通信协议的说法，uwsgi和WSGI都是基于CGI扩展出来的。","titles":[]},"583":{"title":"ASGI","content":"异步网关协议接口 ，一个介于网络协议服务和Python应用之间的标准接口，能够处理多种通用的协议类型，包括HTTP，HTTP2和WebSocket。然而目前的常用的WSGI主要是针对HTTP风格的请求响应模型做的设计，并且越来越多的不遵循这种模式的协议逐渐成为Web变成的标准之一，例如WebSocket。ASGI尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意的时候、被任意应用进程发送和接受的抽象。并且同样描述了一个新的，兼容HTTP请求响应以及WebSocket数据帧的序列格式。允许这些协议能通过网络或本地socket进行传输，以及让不同的协议被分配到不同的进程中。","titles":[]},"584":{"title":"WSGI和ASGI的区别","content":"WSGI是基于HTTP协议模式的，不支持WebSocket，而ASGI的诞生则是为了解决Python常用的WSGI不支持当前Web开发中的一些新的协议标准。同时，ASGI对于WSGI原有的模式的支持和WebSocket的扩展，即ASGI是WSGI的扩展。","titles":[]},"585":{"title":"导出说明","content":"Unity supports x64 since 2017 LTS. To enable it you can go to File > Build Settings > Player Settings.There under \"Other Settings\" you have to change your Script Backend to IL2CPP, and you will have the ARM64 checkbox active. Check it.And then you can either select to generate Split APKs by Target Architectureor in your Build Settings dialog choose to Build App Bundle (Google Play)Hope it helps, you will need to have the Android NDK for this.如果选择Build ，Unity会生成AAB文件，该文件可以直接发布到Google Play。如果选择Build and Run，Unity会生成AAB文件，该文件会为关联设备生成临时APK文件，然后安装APK文件到设备并运行应用程序。如果选择Build 并希望手动安装应用程序到设备上，可以使用Google提供的bundletool utility ,你可在Unity安装目录中的  目录下找到它。请注意，当构建应用程序包时，菜单  下的   会被禁用，因为生成的应用程序包应包含所有支持目标的库。","titles":[]},"586":{"title":"使用技巧","content":"在开发期间，为了减少使用构建和运行时的迭代次数，可以禁用应用程序包的生成功能，并使用常规的APK文件，因为从应用程序包生成APK需要额外时间，之后才会部署到设备上。应用程序包还可以从Android Studio生成，它使用从Unity导出的Gradle项目。为此，你需要使用Android Studio 3.2或更高版本，并选择  。如果目标商店不支持Android App Bundles，你可以使用Player settings中的  选项，从而根据终端用户设备的CPU架构提供APK文件，或使用bundletool，该工具可以构建支持运行在任何环境的“通用APK”文件","titles":[]},"587":{"title":"相关链接","content":"https://connect.unity.com/p/unity-2018-3-betazhong-de-android-app-bundle-aab-zhi-chi","titles":[]},"588":{"title":"什么是IL2CPP？","content":"从技术层面上来说，我们说的IL2CPP包含了两部分：一个进行 预先编译（译注：ahead-of-time，又叫AOT，以下一律使用AOT缩写）的编译器。","titles":[]},"589":{"title":"一个支持虚拟机的运行时库","content":"AOT编译器将由.NET 输出的中间语言(IL)代码生成为C++代码。运行时库则提供诸如垃圾回收，与平台无关的线程，IO以及内部调用（C++原生代码直接访问托管代码结构）这样的服务和抽象层。","titles":[]},"590":{"title":"AOT编译器","content":"IL2CPP AOT编译器实际的执行文件是il2cpp.exe。在Windows平台你可以在Unity安装路径的Editor\\Data\\il2cpp目录下找到。对于OSX平台，它位于Unity安装路径的Contents/Frameworks/il2cpp/build目录内。 il2cpp.exe这个工具是一个托管代码可执行文件，其完全由C#写成。在开发IL2CPP的过程中，我们同时使用.NET和Mono编译器对其进行编译。il2cpp 接受来自Unity自带的或者由Mono编译器产生的托管程序集，将这些程序集转换成C++代码。这些转换出的C++代码最终由部署目标平台上的C++编译器进行编译。你可以参照下图理解IL2CPP工具链的作用：","titles":[]},"591":{"title":"运行时库","content":"IL2CPP的另外一个部分就是对虚拟机提供支持的运行时库。我们基本上是用C++代码来实现整个运行时库的（好吧，其实里面还是有一些和平台相关的代码使用了程序集，这个只要你知我知便好，不要告诉别人 ）。我们把运行时库称之为libli2cpp，它是作为一个静态库被连接到最终的游戏可执行文件中。这么做的一个主要的好处是可以使得整个IL2CPP技术是简单并且是可移植的。你能通过查看随Unity一起发布的libil2cpp头文件来窥探其代码组织方式（Windows平台，头文件在Editor\\Data\\PlaybackEngines\\webglsupport\\BuildTools\\Libraries\\libil2cpp\\include目录中。OSX平台，头文件在Contents/Frameworks/il2cpp/libil2cpp目录中）。举个例子，由il2cpp产生的C++代码和libil2cpp之间的接口API，存在于codegen/il2cpp-codegen.h这个文件中。运行时的另外一个重要的部分，就是垃圾收集器。在Unity 5中，我们使用libgc垃圾收集器。它是一个典型的贝姆垃圾收集器（Boehm-Demers-Weiser garbage collector）。（译注：相对使用保守垃圾回收策略）。然而我们的libil2cpp被设计成可以方便使用其他垃圾回收器。因此我们现在也在研究集成微软开源的垃圾回收器（Microsoft GC）。对于垃圾回收器这一点，我们会在后续的一篇中专门的讨论，这里就不多说了。","titles":[]},"592":{"title":"il2cpp是如何执行的？","content":"让我们从一个简单的例子入手。这里使用Unity的版本是5.0.1，在Windows环境并且建立一个全新的空项目。然后创建一个带MonoBehaviour的脚本文件，将其作为组件加入到Main Camera上。代码也是非常的简单，输出Hello World：当我切换到WebGL平台进行项目生成的时候，我们可以用Process Explorer来对il2cpp的命令行进行观察，得到以下内容：嗯，这个真是老太太的裹脚布 - 又臭又长......，所以让我们把命令分拆一下，Unity运行的是这个可执行文件：下一个参数是il2cpp.exe工具本身：请注意剩下的参数其实都是传递给il2cpp.exe的而不是mono.exe。上面的例子里传递了5个参数给il2cpp.exe：指明il2cpp.exe不对生成的C++文件进行copy操作\n  \n告诉IL2CPP如果可以，对通用方法进行共享。这个可以减少代码并降低最后二进制文件的尺寸确保和Unity events相关的，通过反射机制来运作的代码，能够正确生成。在生成C++代码时为里面的类型和方法使用更短的名字。这会使得C++代码难以阅读，因为原来在IL中的名字被更短的取代了。但好处是可以让C++编译器运行的更快。使用默认的（也是空的）额外类型文件。il2cpp.exe会将在这个文件中出现的基本类型或者数组类型看作是在运行时生成的而不是一开始出现在IL代码中来对待。需要注意的是这些参数可能会在以后的Unity版本中有所变化。我们现在还没有稳定到把il2cpp.exe的命令行参数整理固定下来的阶段。最后，我们有由两个文件组成的一个列表和一个目录在这个长长的命令行中：il2cpp.exe工具可以接收一个由IL程序集组成的列表。在上面这个例子中，程序集包含了项目中的简单脚本程序集：Assembly-CSharp.dll，和GUI程序集：UnityEngine.UI.dll。大家可能会注意到这里面明显少了什么：UnityEngine.dll到哪去了？系统底层的mscorlib.dll也不见了踪影。实际上，il2cpp.exe会在内部自动引用这些程序集。你当然也可以把这些放入列表中，但他们不是必须的。你只需要提及那些根程序集（那些没有被其他任何程序集引用到的程序集），剩下的il2cpp.exe会根据引用关系自动加入。裹脚布的最后一块是一个目录，il2cpp.exe会将最终的C++代码生成到这里。如果你还保持着一颗好奇的心，可以看看这个目录中产生的文件。这些文件是我们下一个讨论的主题。在你审视这些代码前，可以考虑将WebGL构建设置中的“Development Player”选项勾上。这么做会移除–output-format=Compact命令行参数从而让C++代码中的类型和方法的名字更加可读。尝试在WebGL或者iOS构建设置中进行些改变。这样你会发现传递给il2cpp.exe的参数也会相应的发生变化。例如，将“Enable Exceptions” 设置成“Full” 会将–emit-null-checks，–enable-stacktrace，和 –enable-array-bounds-check这三个参数加入il2cpp.exe命令行。","titles":[]},"593":{"title":"IL2CPP没做的事情","content":"我想指出IL2CPP有一向挑战我们没有接受,而且我们也高兴我们忽略了它。我们没有尝试重写整个C#标准库。当你使用IL2CPP后端构建Unity项目的时候，所有在mscorlib.dll，System.dll等中的C#标准库和原来使用Mono编译时候的一模一样。我们可以依赖健壮的且久经考验的C#标准库，所以当处理有关IL2CPP的bug的时候，我们可以很肯定的说问题出在AOT编译器或者运行时库这两个地方而不是在其他地方。","titles":[]},"594":{"title":"我们如何开发，测试，发布IL2CPP","content":"自从我们在一月份的4.6.1 p5版本中首次引入IL2CPP以来，我们已经连续发布了6个Unity版本和7个补丁（Unity版本号跨越4.6和5.0）。在这些发布中我们修正了超过100个bug。为了确保持续的改进得以实施，我们内部只保留一份最新的开发代码在主干分之（trunk branch）上，在发布各个版本之前，我们会将IL2CPP的改动挂到一个特定的分之下，然后进行测试，确保所有的bug已经正确的修正了。我们的QA和维护工作组为此付出了惊人的努力才得以保证发布版本的快速迭代。（译注：感觉是版本管理的标准的开发流程）提供高质量Bug的用户社区被证明是一个无价之宝。我们非常感谢用户的反馈来帮助我们改进IL2CPP，并且希望这类反馈越多越好。我们的IL2CPP研发组有很强烈的“测试优先”意识。我们时常使用“Test Driven Design”方法，在没有进行足够全面的测试的情况下，几乎不会进行代码的合并工作。这个策略用在IL2CPP项目上非常的棒。我们现在所面对的大部分bug并不是意想不到的行为产生的，而是由意想不到的特殊情况产生的。（例如在一个32位的索引数组中使用了64位的指针从而导致C++编译器失败）面对这种类型的bug我们可以快速的并且很自信的进行修正。有了社区的帮助，我们非常努力的让IL2CPP既快又稳定。顺便说一句，如果你对我刚才说的这些有兴趣，我们正在招人（嗯.....我只是这么一说）","titles":[]},"595":{"title":"好戏连台","content":"关于IL2CPP我们还有很多可以说的。下一次我们会深入到il2cpp.exe代码生成的细节中。看看对于C++编译器来说，由il2cpp.exe生成的代码会是个什么样子。","titles":[]},"596":{"title":"IL2CPP 脚本限制","content":"","titles":[]},"597":{"title":"System.Reflection.Emit","content":"AOT 平台无法实现    命名空间中的任何方法。   的其余部分是可接受的，只要编译器可以推断通过反射使用的代码需要在运行时存在。","titles":["IL2CPP 脚本限制"]},"598":{"title":"序列化","content":"AOT 平台可能会由于使用了反射而遇到序列化和反序列化问题。如果仅通过反射将某个类型或方法作为序列化或反序列化的一部分使用，则 AOT 编译器无法检测到需要为该类型或方法生成代码。这是我们常遇到的问题..一个是scriptobject的asset,一个是网络协议都是序列化数据odin,最佳模式新建一个aot场景,将需要的scriptobject放在该场景.或者声明序列化字段网络协议Json,使用字段,而不是使用属性(get,set),il2cpp 在运行时会剥离去除Get属性，  网络协议protobuf,虽然protobuf本身是支持Dictionary的,但是aot就不能使用了..未找到解决办法 ,用class代替","titles":["IL2CPP 脚本限制"]},"599":{"title":"泛型","content":"每个泛型实例实际上都是一个独立的类型，   和   是两个完全没有关系的类型，这意味着，如果在运行时无法通过JIT来创建新类型的话，代码中没有直接使用过的泛型实例都会在运行时出现问题。在ILRuntime中解决这个问题有两种方式，一个是使用CLR绑定，把用到的泛型实例都进行CLR绑定。另外一个方式是在Unity主工程中，建立一个类，然后在里面定义用到的那些泛型实例的public变量。这两种方式都可以告诉IL2CPP保留这个类型的代码供运行中使用。因此建议大家在实际开发中，尽量使用热更DLL内部的类作为泛型参数，因为DLL内部的类型都是ILTypeInstance，只需处理一个就行了。此外如果泛型模版类就是在DLL里定义的的话，那就完全不需要进行任何处理。","titles":["IL2CPP 脚本限制"]},"600":{"title":"泛型方法","content":"跟泛型实例一样，   和  是两个完全不同的方法，需要在主工程中显式调用过，IL2CPP才能够完整保留，因此需要尽量避免在热更DLL中调用Unity主工程的泛型方法。如果在iOS上实际运行遇到报错，可以尝试在Unity的主工程中随便写一个static的方法，然后对这个泛型方法调用一下即可，这个方法无需被调用，只是用来告诉IL2CPP我们需要这个方法","titles":["IL2CPP 脚本限制","泛型"]},"601":{"title":"AnimatorController 等","content":"如果提示的ID的是Editor的，比如 AnimatorController(ID 91)属于Editor包里的，不能用link.xm加回来，可以在  Resource 下建一个空的prefab,在上面挂一个AnimatorController，打包时留下这个prefab就可以确保这个类不被strip掉了。参考 :Could not produce class with ID 91 - iOS - Unity Forum   YAML 类 ID 参考 - Unity 手册 (unity3d.com)","titles":["IL2CPP 脚本限制"]},"602":{"title":"其他","content":"不要用dynamic关键字  没有使用的字段都不会被编译..","titles":["IL2CPP 脚本限制"]},"603":{"title":"托管代码剥离","content":"IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后ipa包的尺寸的目的。然而在实际使用过程中，很多类型有可能会被意外剪裁掉，造成运行时抛出找不到某个类型的异常。特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题。Unity提供了一个方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的。具体做法就是在Unity工程的Assets目录中建立一个叫link.xml的XML文件，然后按照下面的格式指定你需要保留的类型：","titles":[]},"604":{"title":"IL2CPP限制","content":"将游戏导出到 iOS 等平台时，Unity 将使用其 IL2CPP 引擎将 IL“转换”为 C++ 代码，然后使用目标平台的本机编译器进行编译。 在此方案中，有几个不支持的 .NET 功能，例如反射的部分内容和使用    关键字。 虽然可在自己的代码中使用这些功能，但使用第三方 DLL 和 SDK 时可能会遇到问题，这些 DLL 和 SDK 并非使用 Unity 和 IL2CPP 编写。 有关此主题的详细信息，请参阅 Unity 站点上的  脚本限制 文档。此外，如之前 Json.NET 示例中所述，Unity 将尝试在 IL2CPP 导出过程中裁剪掉未使用的代码。 虽然这通常不是问题，但对于使用反射的库，它可能会意外地删除在导出时无法确定是否被调用而在运行时可能被调用的属性或方法。 若要解决这些问题，请添加一个 link.xml 文件到项目中，该文件中包含的程序集和命名空间列表不会执行裁剪过程。 有关完整详细信息，请参阅  有关字节码裁剪的 Unity 文档 。","titles":["托管代码剥离"]},"605":{"title":"编译速度优化","content":"增量编译  关闭实时保护  使用ssd","titles":["托管代码剥离"]},"606":{"title":"相关链接","content":"https://docs.microsoft.com/en-us/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019   https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html   https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html   https://docs.unity3d.com/Manual/ScriptingRestrictions.html   https://www.jianshu.com/p/7cfcb7b0cfe7   https://blogs.unity3d.com/cn/2015/05/06/an-introduction-to-ilcpp-internals/","titles":["托管代码剥离"]},"607":{"title":"问题 隐私声明","content":"使用这个站点  https://app-privacy-policy-generator.firebaseapp.com/  根据app的名称，类型，平台等等，选择对应的选项，右边按钮还包含对应的第三方隐私服务链接，如果你用到的话，比如google play service, firebase等等，那么就勾选上。最后点击GENERATE，就会生成一个适合你自己app的privacy-policy页面了。\n最后的最后，记得将这个url输入到google play后台的隐私设置区域，点击保存，重新发布app等候google play团队的审核。一两个小时就好了。https://blog.usejournal.com/how-to-fix-advertising-id-policy-violation-in-google-play-store-6d9cf92d335d","titles":[]},"608":{"title":"问题 -1002","content":"Google Play应用需要授予\"允许后台弹窗\"的权限","titles":[]},"609":{"title":"问题  此商品无法在您设备所在的国家地区安装","content":"删除家庭内容..  使用vpn切换到指定国家  googleplay--账号里切换地区","titles":[]},"610":{"title":"问题 无法购买您要的商品","content":"做Google Play 支付， 遇到“无法购买您要的商品”的问题，在网上搜了些答案，下面罗列了一些保证 versionCode 和版本号与你上传的apk的包的一样。  保证后台和你传入的购买商品的 id 一致。  确保你所使用的账号是在测试人员里。在\"APK\"页面里，有一个“选择使用网址”，把这个网址给你的测试人员，让你的测试人员用他的google账号点进去，点那个“成为测试人员”（前提是你把他加进了测试人员列表），还需要把连接地址发送给测试人员，必须要测试人员点击同意参加测试才行！！","titles":[]},"611":{"title":"问题 无法使用该应用,此应用的测试版尚未发布，或者无法通过此帐号使用。","content":"https://play.google.com/apps/testing/com.zhepama.gyj   发给测试人员激活..记住..登录的用户一定是测试人员","titles":[]},"612":{"title":"问题 此版本的应用未配置为通过googleplay 结算","content":"造成这个错误的原因有两个:第一个是打包的时候，versionCode的值比提交到google play后台的版本要高。  第二个就是：打包的时候，和google play后台上的包的签名不一致。","titles":[]},"613":{"title":"问题  关于如何测试","content":"先使用release版本发布到googleplay.测试的时候可以使用debug版本,先测试下基本功能..查看哪里报错..apk可以使用谷歌提供的测试地址下载","titles":[]},"614":{"title":"以下是Google IAB测试的要求清单。","content":"","titles":["问题  关于如何测试"]},"615":{"title":"先决条件：","content":"AndroidManifest必须包含“com.android.vending.BILLING”权限 。  APK内置于发行模式 。  APK已使用发行证书进行 签名 。  至少一次将APK上传到Alpha / Beta版本的渠道（以前 - 作为草稿）到开发者控制台。 （需要一段时间〜2h-24h ）。  IAB 产品已发布 ，其状态设置为活动 。  测试帐户被添加到开发者控制台中。","titles":["问题  关于如何测试","以下是Google IAB测试的要求清单。"]},"616":{"title":"测试要求：","content":"测试APK 与上传到开发者控制台的版本号相同 。  测试APK的签名与上传到dev.console的证书相同 。  测试帐户 （不是开发人员） - 是设备上的主要帐户 。  测试帐户作为测试者选择加入，并与有效的付款方式相关联 。 （ @Kyone ）  PS： 使用发行证书进行调试","titles":["问题  关于如何测试","以下是Google IAB测试的要求清单。"]},"617":{"title":"相关链接","content":"https : //stackoverflow.com/a/15754187/1321401","titles":["问题  关于如何测试"]},"618":{"title":"Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？","content":"答案就是我们最前面提到的屏幕宽高比。Unity会根据当前屏幕实际的宽高比和摄像机的orthographicSize值来计算出摄像机的宽度值，即：摄像机实际宽度 = 摄像机orthographicSize * 2 * 屏幕宽高比也即是摄像机实际宽度 = 摄像机高度 * 屏幕宽高比我举个例子说明一下，iPhone4的屏幕像素为640*960，宽高比为2:3，假设Pixels To Units值为100，那么如果设摄像机高度size值为4.8，那么摄像机实际宽度按照公式算出6.4，刚好就是屏幕的单位宽度。","titles":[]},"619":{"title":"场景适配","content":"","titles":[]},"620":{"title":"2d场景和3d摄像机的适配","content":"因为需要引入3d的内容所以 worldcamera,使用了透视摄像机  透视摄像机旋转了15度使其可以看到地面..因为是透视相机,这就造成了2d角色在相机移动后会发生偏移的问题..这个时候需要将2d角色始终面向相机.所以2d单位的容器也需要旋转15度  为什么不单独使用一个正交摄像机看角色?因为这样的画,地面和角色不是用一个相机,且其中一个使用的是透视,会造成人物移动后,地面和角色形成视差,造成其他角色看起来不像站在地面上一样","titles":["场景适配"]},"621":{"title":"场景和ui位置的适配","content":"","titles":["场景适配"]},"622":{"title":"3d形象如何展现在ui中","content":"直接将3d物品拖到ui中然后添加rect transform属性,3d物品会根据ui的位置改变而改变然后可能会出现看不到3d对象的问题.这个可能和canvas的plane distance有关,即摄像机和canvas的z的距离用3d视图看下这个时候是看不到cube的注意: 想用canvas中的ui去遮挡3d物品是做不到的,sortingGroup也不会有用处..如下图想用绿色盖住cube,是做不到的.因为他们在摄像机的显示是按照z去排的","titles":["场景适配","场景和ui位置的适配"]},"623":{"title":"根据场景位置设置ui位置..","content":"比如竖屏游戏.有一半是场景一半是ui,如何让ui去准确的盖住场景使用:","titles":["场景适配","场景和ui位置的适配"]},"624":{"title":"UGUI的适配","content":"锚点是解决ui控件在canvas里面位置的问题.而Canvas Scaler主要是设置canvas(ui控件)显示的大小(缩放)问题","titles":[]},"625":{"title":"锚点","content":"锚点这个概念在Unity文档的多分辨率适配中被明确的提到其作用。简单的说，就是定位。如果一个物体相对于屏幕位置左上角，那么无论屏幕分辨率怎么变化，它始终位于左上角。同理，如果是在（0,0）原点，那么也始终在中心原点。我对锚点定义为，锚点，是相对于父节点的偏移量，这个偏移量随屏幕分辨率变化而按比例变化，如果将分辨率的宽，高，看做归一化的数值（即0~1，实际UGUI就是这么做的），那么锚点是指一个偏移百分比。所以有了锚点，子节点在相对于父节点的位置上保持不变的。如图，参考分辨率960  640，我改变GameView的分辨率为800 468，图中绿色背景大小960  640，红色Image大小100 100，红色图片的锚点为左上，轴点为左上，在参考分辨率下，红色正方形的左上顶点距离Canvas左上顶点距离（50，-150）​    当我将屏幕分辨率切换为800*468后，​    因为我选的Screen Match Mode为Weight = 0，所以在800 * 468分辨率下的实际屏幕高度为 960 * （468/800）= 561.6。​    又因为我的UI Scale Mode选的是Scale with Screen Size随屏幕尺寸变化，这个时候的缩放比是由宽度决定的，960/800 = 1.2 ,所以红色正方形此时的高度为100 / 1.2= 83.333​    红色正方向锚点y轴坐标 = 参考锚点位置 * 缩放比 = 150 * 1.2 = 125，","titles":["UGUI的适配"]},"626":{"title":"Canvas Scaler","content":"看名字就知道..是设置canvas如何根据屏幕进行缩放UGUI的屏幕自适应，是通过Canvas Scaler来做的，根据屏幕的分辨率，计算出canvas的大小，同时计算ScaleXY,通过Size + Scale来控制Canvas的变换，UI作为canvas的子物体，也会跟随着一起变化；为了保证UI的位置，需要在设计UI的时候，利用锚点来保证UI与边缘或角落的距离，","titles":["UGUI的适配"]},"627":{"title":"固定像素 (Constant Pixel Size)","content":"忽略屏幕的大小根据UI元素的实际像素显示 ,像素大小始终不变，即一个100  100的图片在任何的分辨率下都占用100 100的像素。一般PC上会使用这种方式，因为PC端分辨率差异并不大。","titles":["UGUI的适配","Canvas Scaler"]},"628":{"title":"根据屏幕大小进行缩放(Screen Match Mode)","content":"此项会根据设备真实分辨率与设计分辨率来对Canvas进行缩放。有三种模式：Match Width or Height根据宽或者高来对Canvas进行缩放，比如设备分辨率为1920  900，设计分辨率为1280 720，此时，如果采用宽进行匹配那么可以通过公式计算出此时应该缩放多少倍，公式如下：缩放因子：1920/1280 = 1.5缩放后的Canvas的宽为：1920（刚好能够完全显示）缩放后的Canvas的高为：720*1.5 = 1080由于设备的高为900所以会导致高度上的一部分不会被显示出来2.Expand适配的计算公式同上，只是在此模式下会保证设计分辨率下的东西能够全部显示出来，及选择设备分辨率和设计分辨率的宽、高比中选择最小值作为缩放因子。3.Shrink和Expand恰好相反，在此模式下不会留黑边但是会导致显示不完全。及选择设备分辨率和设计分辨率的宽、高比中选择最大值作为缩放因子。UiScaleMode一般选择Scale With Screen Size，并设置好设计分辨率。其他两个选项都是固定像素大小。Screen Match Mode中一般选择Expand，它可以保证ui中的所有元素都在屏幕内部。 相对比的一个选项是Shrink，它可以保证不留空白边。3、多分辨率的思路是Scaler中选择Expand保证所有ui元素在屏幕内部。少部分界面，如主界面、战斗界面等根据需要设置Anchors中的全屏拉伸。注意，这里的拉伸的含义仅仅是设置Panel的宽、高，并不影响子控件的缩放，但是会影响其布局。","titles":["UGUI的适配","Canvas Scaler"]},"629":{"title":"固定物理大小(Constant Physical Size)","content":"忽略屏幕大小和分辨率根据UI的实际物理大小来显示。","titles":["UGUI的适配","Canvas Scaler"]},"630":{"title":"刘海屏的适配","content":"待续","titles":[]},"631":{"title":"参考链接","content":"Unity记录-UGUI的屏幕自适应原理和应用_shitangdejiaozi的博客-CSDN博客   Android刘海屏适配方案总结 - 简书 (jianshu.com)","titles":[]},"632":{"title":"在編輯器中快速設定 RectTransform","content":"快速控制器的基本操作我們就不在這裡贅述，基本上都可以在 Unity 網站裡找到很好的教學文件與影片。","titles":[]},"633":{"title":"RectTransform 的控制精髓：錨點們 Anchor Points","content":"在透過快速設定器修改 RectTransform 的過程中，你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖：Pos X 與 Left、Pos Y 與 Top、Width 與 Right、Height 與 Bottom 這四對屬性個別不會同時出現，有 Pos X 就沒有 Left，有 Width 就沒有 Right，那麼他們出現的規則是什麼呢？簡單來說其實就是：「當兩個錨點的某一維度值相等時，該維度的尺寸則是固定的（跟 Parent 尺寸無關），反之該維度的尺寸則是相對於 Parent 的尺寸而變化。」其實全部都取決於控制   RectTransform  型態最重要的屬性「最大與最小錨點們（Min / Max Anchors）」，而快速設定器其實也只是在幫你快速的調整這兩個錨點的值，所以只要了解這兩個設定值關係與行為，其實你已經完全掌握了   RectTransform  ，而依照上述邏輯，透過兩個錨點所產生出的配置型態總共有四種：A. 當兩錨點 x, y 維度的值都相等時。\nB. 當兩錨點 x 維度的值不相等、y 維度值相等時。\nC. 當兩錨點 x 維度的值相等、y 維度值不相等時。\nD. 當兩錨點 x, y 維度的值都不相等時。","titles":[]},"634":{"title":"A. 當兩錨點 x, y 維度的值都相等時：","content":"當兩錨點 x, y 值都相等時，代表此物件的寬高尺寸都是固定值，所以我們會透過 PosX、PosY、Width 以及 Height 來定義此物件的顯示方式，PosX 與 PosY 則分別表示錨點到物件 Pivot 點的位移，而此物件的實際顯示區域則會受到 Pivot 的 x, y 值設定所影響。","titles":["RectTransform 的控制精髓：錨點們 Anchor Points"]},"635":{"title":"B. 當兩錨點 x 維度的值不相等、y 維度值相等時：","content":"當兩錨點 x 維度的值不相等、y 維度值相等時，代表 x 維度的尺寸會受到 Parent 的尺寸影響，在 x 維度上則是使用間距（Padding）的概念來排版，所以會用到 Left、PosY、Right 以及 Height，實際的 Width 是由 Left 與 Right 來控制。","titles":["RectTransform 的控制精髓：錨點們 Anchor Points"]},"636":{"title":"C. 當兩錨點 x 維度的值相等、y 維度值不相等時：","content":"當兩錨點 x 維度的值相等、y 維度值不相等時，代表 y 維度的尺寸會受到 Parent 的尺寸影響，在 y 維度上則是使用間距（Padding）的概念來排版，所以會用到 PosX、Top、Width 以及 Bottom，實際的 Height 是由 Top 與 Bottom 來控制。","titles":["RectTransform 的控制精髓：錨點們 Anchor Points"]},"637":{"title":"D. 當兩錨點 x, y 維度的值都不相等時：","content":"當兩錨點 x, y 維度的值都不相等時，代表物件的寬高尺寸都會受到 Parent 的影響，完全是使用四個方向的間距來定義此物件的顯示區域 Left、Top、Right 以及 Bottom。","titles":["RectTransform 的控制精髓：錨點們 Anchor Points"]},"638":{"title":"一些术语解释","content":"","titles":[]},"639":{"title":"pivot","content":"物體自身的支點，影響物體的旋轉、縮放、位置，改變 UI Pivot 必須先開啟控制面板的 Pivot 按鈕，如下圖，Pivot (0.5, 0.5)Pivot (0, 1)它是一个X,Y值范围是0到1的点，这个点的会在  Anchor （锚点）计算位置的时候会使用到，下面用一张图来解释  Pivot 点的位置pivot和text的填充当pivot为0.5和0.5时数字的填充时以中心点向上下方向扩展rect一般来讲,动态改变文本,为了使其按照从上到下,可以把pivot设置在左上角  0,1点击上方的pivot可以切换pivot的所在位置center 的中心点pivot的点所在位置这同样适用于layout,下图设置成0,1.在中间位置添加panel,他会向下扩充,加上verticallayoutgroup和contentsizefitter两个组件设置成0.5,0.5.他会向上下扩充","titles":["一些术语解释"]},"640":{"title":"位置","content":"世界坐标是三维的全局坐标,一般作为基准坐标    相对于父级物体的相对位置    相对位置，但是相对的是自身的Anchor     相对位置，但是相对的是自身的Anchor关于  和  ，它们的值根其所属的Canvas的渲染模式有关。在Screen Space——Overlay的模式下，由于Canvas的世界尺寸与其像素尺寸在数值上相等，因此其rectTransform的position与其在屏幕空间的坐标在数值上也相等。这种模式下，要获取某个RectTransform的屏幕坐标，直接使用position就可以。  在Screen Space——Camera的模式和World Space下，RectTransform的渲染与摄像机有关，在获取其屏幕坐标时，需要利用canvas.worldCamera，或者transform.TransformPoint等坐标转换函数进行坐标转换。关于  和  都可以认为是以像素为单位。当锚点全部重合时，  代表的就是自身Pivot到Anchor的向量。当Anchor不重合时,Pivot相对于四个锚点  中点 的坐标","titles":["一些术语解释"]},"641":{"title":"offsetMin 和 offsetMax","content":"是  RectTransform右上角 相对于  右上Anchor 的距离；  是  RectTransform左下角 相对于  左下Anchor 的距离。  這就是為什麼 offsetMax 的值跟編輯器中 Top、Right 值剛好正負相反的原因。","titles":["一些术语解释"]},"642":{"title":"rect","content":"如果想要获取一个RectTransform的矩形信息，应该使用rectTransform.rect属性。rect属性同样是一个计算出来的值，但是它表示的是该rectTransform对应的矩形的相关信息。rect 的 x 和 y 返回左下角相对于pivot的距离,w 和 h 返回本身的宽高.注意:  Awake中Rectangle还没有初始化出来,所以不要在awake中获取rect","titles":["一些术语解释"]},"643":{"title":"anchorMin 和 anchorMax","content":"这个是针对锚点的,锚点时相对于父容器定义的,所以这两个属性也是相对于父容器的.分别指锚点占父容器尺寸的百分比位置.","titles":["一些术语解释"]},"644":{"title":"sizeDelta","content":"sizeDelta是个由引擎计算出来的值，这个值很容易被错误地使用。要正确地使用sizeDelta，就要先理解它是怎么算出来的。The size of this RectTransform relative to the distances between the anchors.\nIf the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent.sizeDelta 是  的结果。在锚点全部重合的情况下，它的值就是面板上的*（Width，Height）*。在锚点完全不重合的情况下，它是相对于父矩形的尺寸。一个常见的错误是，当  RectTransform 的锚点并非全部重合时，使用  sizeDelta 作为这个  RectTransform 的尺寸。此时拿到的结果一般来说并非预期的结果。所以   RectTransform  宽和高真正的計算方法是:意思就是 sizeDelta 個別維度的值是跟兩錨點個別維度的差值相關，所以只有當兩錨點某的維度的值相等的時候，sizeDelta 在此維度的值才會剛好等於最後顯示的 size 大小。","titles":["一些术语解释"]},"645":{"title":"代码修改坐标及大小","content":"1.改变RectTransform的top  注意offsetMax`是  RectTransform右上角 相对于  右上Anchor 的距离,所以top的值应该是一个负值2.改变RectTransform的bottom3.改变RectTransform的width，height  ,会根据上面的计算公式重新计算得出width和height,所以如果锚点不是在同一个点的情况下,你设置的值和实际的值是有很大区别的例如:当使用脚本直接改变大小后他的宽和高经过了运算使其分别为1500,15344.改变RectTransform的pos  注意anchoredPosition是相对于锚点的位置**5.使用SetSizeWithCurrentAnchors函数来进行设定，其中Horizontal和Vertical分别对应宽和高。此函数受当前锚点和中心点的影响。**由于会受到  的影响设置的高度是根据povit进行上下缩小的上面同样的示例:可以看到它围绕着  上下都缩减了1806.使用SetInsetAndSizeFromParentEdge函数来进行设定。此函数不受锚点和中心的影响，其中第一个参数代表对齐方式，第二个参数为距离边界的距离，第三个参数为宽度。","titles":[]},"646":{"title":"recttransform的一些其他操做","content":"","titles":[]},"647":{"title":"Blue Print Mode(藍圖模式) 、 Raw Edit Mode(原始编辑模式)","content":"","titles":["recttransform的一些其他操做"]},"648":{"title":"","content":"","titles":["recttransform的一些其他操做"]},"649":{"title":"Blue Print Mode (藍圖模式)","content":"忽略了物體的 Local Rotation 和 Local Scale，方便以原來的旋轉與大小調整物體","titles":["recttransform的一些其他操做",""]},"650":{"title":"Raw Edit Mode (原始编辑模式)","content":"在 Inspector 中調整 Pivot 和 Anchor 時，物體會維持目前的位置與大小(Inspector 中數值部分)，調整情形如下，請注意數值部分Inspector 中調整  PivotInspector 中調整  Anchor","titles":["recttransform的一些其他操做",""]},"651":{"title":"參考資料","content":"Unity – Manual: Basic Layout   UnityのuGUIのレイアウト調整機能について解説してみる（RectTransform入門）","titles":["recttransform的一些其他操做",""]},"652":{"title":"OnMouse事件","content":"我们先来看看eventmanager之前unity处理事件的方法,首当其冲的就是MonoBehavior上的事件回调，可以参看  MonoBehaviour 文档。这是一系列的OnMouse开头的回调函数。这个处理方式有以下几个特点：MonoBehavior所在的GameObject需要有Collider碰撞组件，并且Physics.queriesHitTriggers设置为True，这个在Edit -> Physics Settings -> Physics or Physics2D中设置。  或者MonoBehavior所在的GameObject存在GUIElement。  OnMouse处理函数可以是协程。  GameObject所有MonoBehavior实现OnMouse的函数都会调用。  Collider或GUIElement的层级顺序，会遮挡事件的传递。按照官方的解释，这是GUI事件的一部分，参看  EventFunctions 。设计的初衷也是为了GUI服务的。参看  ExecutionOrder 最后的unity执行流程图，会发现OnMouse事件是一个独立的Input Event。可以看到，OnMouse事件在，Physics事件之后，Update之前，记住这个顺序，后面会用到。并且，这是引擎本身回调的，就引擎使用而言可以看成是，消息驱动。至于引擎的实现，可是轮询也可以是消息驱动。","titles":[]},"653":{"title":"在Update中輪詢Input物件","content":"这是官方的例子，Input拥有各种输入设备的数据信息。每一帧不断的检测，查看有没有需要处理的输入信息，利用GameObject本身的层级顺序来控制Update的调用顺序，从而控制了Input的处理顺序。Input的信息由引擎自己设置的，明显Unity需要实现不同平台的事件处理，然后对Input进行设置。另外有一个InputManager面板用来配置Input相关属性的，在Edit -> Physics Settings -> Input中。由前面的执行流程图可知，OnMouse事件会在Update之前调用，当然我们也可以在OnMouse中使用Input，这样就变成了消息驱动，而不是轮询了。但这样的缺点是，事件必须由touch或pointer碰撞触发，比如键盘或控制器按钮的事件就没有办法捕获了。","titles":["OnMouse事件"]},"654":{"title":"EventSystem","content":"EventSystem组件主要负责处理输入、射线投射以及发送事件。一个场景中只能有一个EventSystem组件，并且需要BaseInputModule类型组件的协助才能工作。EventSystem在一开始的时候会把自己所属对象下的BaseInputModule类型组件加到一个内部列表，并且在每个Update周期通过接口UpdateModules接口调用这些基本输入模块的UpdateModule接口，然后BaseInputModule会在UpdateModule接口中将自己的状态修改成'Updated'，之后BaseInputModule的Process接口才会被调用。BaseInputModule是一个基类模块，负责发送输入事件（点击、拖拽、选中等）到具体对象。EventSystem下的所有输入模块都必须继承自BaseInputModule组件。StandaloneInputModule和TouchInputModule组件是系统提供的标准输入模块和触摸输入模块，我们可以通过继承BaseInputModule实现自己的输入模块。BaseRaycaster也是一个基类，前面说的输入模块要检测到鼠标事件必须有射线投射组件才能确定目标对象。系统实现的射线投射类组件有PhysicsRaycaster, Physics2DRaycaster, GraphicRaycaster。这个模块也是可以自己继承BaseRaycaster实现个性化定制。总的来说，EventSystem负责管理，BaseInputModule负责输入，BaseRaycaster负责确定目标对象，目标对象负责接收事件并处理，然后一个完整的事件系统就有了。","titles":[]},"655":{"title":"EventSystem與OnMouse的區別","content":"OnMouse 会先于 EventSystem 触发。因为EventSystem的源码显示，其在Update中去轮询检测处理Input的输入。而OnMouse事件先于Update调用。  OnMouse脚本需要在同一个GameObject上挂载Collider才能检测。EventSystem的脚本会根据子节点的Collider来触发(平行节点不行)。  Rigidbody有个特点，会把子节点所有的Collider统一检测和处理。也就是说，OnMouse脚本与RigidBody在一起就可以检测所有的子节点Collider，而不再需要同级的Collider。而EventSystem的脚本则不依赖于Rigidbody，都可以检测子节点的Collider。  OnMouse依赖于Tag为MainCamera相机的Culling Mask来过滤射线。EventSystem则是依赖挂载Physics Raycaster的相机。另外，当在有Collider的子节点都挂载OnMouse或EventSystem事件的时候，只会触发一次事件。但在同一个GameObject上挂载多个脚本，就会触发多次。","titles":[]},"656":{"title":"Unity Raycasters 和事件处理","content":"Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。在 Unity Raycasters 中有三种类型的 Raycasters:Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体  Physics 2D Raycaster - 用于检测 2D 物体  Physics Raycaster - 用于检测 3D 物体接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。Raycast 在 Event System 流程中所处的位置大致如下图:","titles":[]},"657":{"title":"unity的事件处理","content":"当 Event System 处理输入事件并找到合适的接收者，将该接收者作为参数执行 ExecuteEvents 类中的    或    方法；如果此时该接收对象 GameObject 绑定了 EventTrigger 组件，由于 EventTrigger 类实现了所有常用的 UI 事件接口(即实现了    接口)，因此会执行 EventTrigger 类中相应事件接口对应的方法，转而执行 EventTrigger 类的    方法，最终回调在编辑器中设定的方法。所以如果当一个点击事件被触发,首先会拿到射线检测返回的gameobject，然后搜索当前的  gameobejct以及其父节点 上面是否有实现了IPointerDownHandler的接口的控件，如果有实现了的就把newPressed赋值为这个控件的gameobject，如果没有，就去搜索实现了IPointerClickHandler这个接口的控件，如果没有在自身上找到的话，会依次地向父节点层层搜索，直到找到为止，然后依然是把newPressed赋值为这个控件的gameobject。接着会按照类似的方式去搜索自身以及父节点上是否有实现了IDragHandler的组件，如果有的话紧接着便会去触发OnPointerDown和OnDrag方法。当鼠标按下并抬起的时候，首先会触发IPointerUpHandler接口中的函数OnPointerUp()，然后会再次搜索当前gameobject以及其父节点上是否有实现了IPointerClickHandler接口的控件，如果有的的话，会和之前存下来的newPressd进行比较，看两者是否为同一个gameobject。如果两者为同一个gameobject的话就会触发Click事件。因此我们需要注意，如果一个物体没有父节点的话，那么只实现IPointerClickHandler接口便是可以接收到点击事件的。如果他有父节点，父节点挂载的脚本也是只实现IPointerClickHandler接口的话，点击事件也是可以接收到的。但是如果父节点实现了IPointerDownHandler和IPointerClickHandler接口，子节点只实现IPointerClickHandler接口的话，两者便会都接收不到点击事件，需要子节点也实现IPointerDownHandler这个接口才行。事件透传如果事件被接收后,就不会再被父节点的监听处理,如果需要,则得使用message手动触发事件忽略如果需要当前节点及子节点都不响应UI事件勾选Raycast Targe  在当前节点上添加一个组件CanvasGroup，然后取消其Interactable和Blocks Raycasts的勾选  添加脚本事件阻止父子之间阻止向父级传递事件,只要在该对象加上一个EventTrigger起就可以了,代表这个事件已经被处理了.比如一个案例,点击最顶级的遮罩(白色部分)窗口关闭,但是点击到窗口内部(红色部分)不做处理ugui事件和射线穿透的问题eventsystem也是向场景发送射线,然后找到  第一个 触碰的有  Raycast Target 的game object.然后在向这个gameobject的父级去找.所有如果ui即使全屏了,但是没有设置Raycast Target,仍然会穿透ui.射线会检测到下面的立方体,如图:事件和handler的连接触发方式对于某些ui组件，可以直接设置其对自己产生的事件的handler，如button的onpointerclick  对于任何ui组件，都可以使用eventtrigger这个component，这个trigger放置在产生事件的UI组件上，里面包含了一个事件的类型，以及这个类型关联的处理函数，处理函数可以使用两种函数参数，一种是使用int string简单类型，一种是使用BaseEventData类型，因为当event发生时，会跟随者把这个事件包装成一个PointerEventData类型的参数送进来，里面包含ui事件的详细信息，包括鼠标在哪，而对于前一种简单类型，在编辑器上可以填写当事件发生时传什么参数，这就好比qt的signal和slot连接。  强制让某个事件发生在某个handler上（也就是强制某个handler执行）：调用ExecuteEvents.Execute<  ICustomMessageTarget >(target, null, (x,y)=>x.Message1());  这个调用将执行target身上所有继承 了ICustomMessageTarget接口的mono的Message1函数，个人认为这个和给target发送Message1 的sendmessage没什么区别，可能是我还没有立即好这个接口。自定义事件处理建立一個 Script，繼承 Event Interfaces，這裡是IPointerDownHandler(點下事件)，  看更多 Event 請點我","titles":["Unity Raycasters 和事件处理"]},"658":{"title":"阻止手动发送射线穿透ugui问题","content":"UGUI 提供了一个检测是否点击在UI上的方法\nEventSystem.current.IsPointerOverGameObject();\n在EventSystem的标准输入Standalone Input Model下是正常的，但是在Touch Input Module输入模式下不正常参考网络资料，解决办法(直接上  源码 ):网友解决办法：","titles":["Unity Raycasters 和事件处理"]},"659":{"title":"Message System（改进的消息系统）","content":"","titles":[]},"660":{"title":"传统方式进行 Message 通信","content":"传统消息通信，通常我们会使用 GameObject 类中的   、   和    方法SendMessage  SendMessageUpwards  BroadcastMessage    自身节点  √  √  √   兄弟节点  ×  ×  ×   父/祖先节点  ×  √  ×   子/孙节点  ×  ×  √","titles":["Message System（改进的消息系统）"]},"661":{"title":"Messaging System","content":"在 UGUI 的 Event System 中，所有的事件通信都是用了 Messaging System 来实现，它也解决了传统方式进行 Message 通信中可能会遇到的一些问题。下面就来让我们好好看看这套 Messaging System。首先，要想让 Component 能够从 Messaging System 接收消息，Component 要实现    这个接口。  等都继承了   接口实现这个接口 , 把这个脚本挂在某个物体上，这里假设为物体AAA在任何脚本中使用ExecuteEvents静态类发送Message，来执行接口中定义的方法Excute泛型方法，有3个参数，第一个参数是发送message的gameobject对象，只有当对象上有  实现类的时候才可以，这个例子中自然就是AAA物体。ExecuteEvents静态类还有其他方法：","titles":["Message System（改进的消息系统）"]},"662":{"title":"eventsystem 处理Physics","content":"首先，我们看一个官方文档的说明   Raycasters 。If multiple Raycasters are used then they will all have casting happen against them and the results will be sorted based on distance to the elements.当多个Raycaster被使用的时候，结果会按照元素之间的距离排序，然后事件就会按照这个顺序被传递。","titles":[]},"663":{"title":"第一步","content":"在相机上添加Physics2DRaycaster，我这里只需要对Physics2D检测，如果是3D就用Physics3DRaycaster。Physics Raycaster 依赖一个相机，如果没有会自动添加。我挂载在相机上，射线检测就会依赖这个相机。这里我用在GameCamera上面，当然也可以放在UICamera上面，Physics Raycaster挂载在哪个相机上面，射线就依赖这个相机的Culling Mask。另外需要注意的是，Physics Raycaster所在的相机层级，也就是Depth，会影响到事件传递的顺序。比如，UI Camera层级高于Game Camera，就会永远先出发UI上的事件。同样，OnMouse事件会默认依赖Main Camera的层级。","titles":["eventsystem 处理Physics"]},"664":{"title":"第二步","content":"给需要碰撞检测的GameObject，添加Collider和EventSystem的事件处理回调接口。注意GameObject的Layer也要与Camera和Raycaster一致，才能正确被检测到。事件接口实现脚本(图中的Test)需要Collider，事件才能正确回调，并且GameObject和相机的距离决定了Collider的层级，也就是事件阻挡关系。","titles":["eventsystem 处理Physics"]},"665":{"title":"第三步","content":"这样一来，EventSystem的SupportEvents的接口全部被应用到了Physics上面。也就不再需要自己手动去调用射线去检测Physics碰撞了。那么，还隐含着一个事情就是，EventSystem的IsPointerOverGameObject()就无法在判断对UI的点击了。因为现在点击到Physics也会让这个函数返回True。","titles":["eventsystem 处理Physics"]},"666":{"title":"为什么想看看事件系统的实现","content":"很简单，策划又提奇奇怪怪的需求了！比如这些事件要穿透啦，那些事件要做特殊处理啦！之类的……依旧先贴出源码地址：Unity-Technologies / UI - Bitbucketbitbucket.org","titles":[]},"667":{"title":"入手点","content":"好那么我们从何处入手呢？当然是我们的EventTrigger了！我们都知道，我们可以通过实现以下接口来实现事件捕捉：大家都爱用的EventTrigger具体怎么做我想大家已经明白了，也就是实现上线的接口中的函数，例如我要监听点击事件我就实现一下IPointerClickHandler然后挂在物体上就好了。这个技巧在很早的时候我在雨松的文章第一次看到，那时候也是4.6时期UGUI刚出来的时候发现的。由于和当初的NGUI很像所以被大家广泛使用，但是也会发现如果全部实现了接口但是不实现的话可能会影响上层例如ScrollView的监听，下面我们看下去也可以知道到底是为啥。","titles":[]},"668":{"title":"顺藤摸瓜","content":"既然我们已经找到了这个宝贝，那我们就可以通过查找引用大法，顺藤摸瓜看看到底是什么地方在调用我们实现的接口。最后理出来所有事件的入口其实都是放在  EventSystem 当中，而具体处理则是放在了  InputModule 里面。在刚刚Enable的时候会更新输入模块列表，也就是我们可以看到的StandaloneInputModule以及TouchInputModule：初始化InputModuleUnity自己提供的各种InputModule在EventSystem的Update当中就会分别调用这些InputModuleEventSystem主循环首先Tick所有的输入模块，然后选出一个当前在使用的输入模块中的Process进行处理。EventSystem处理函数最前面是判断是否处于聚焦状态，其实也就只是应用程序的聚焦状态。其中中间是针对Navigation也就是类似于通过键盘上下左右或者手柄进行UI位置切换的操作。最下面两句才是针对所有的Touch以及Mouse的操作的处理。","titles":[]},"669":{"title":"触摸事件处理","content":"处理输入事件首先看看，首先获取Pointer数据，然后对该数据进行处理。","titles":[]},"670":{"title":"首先处理点击事件 ProcessTouchPress","content":"首先判断是为按下事件还是释放事件处理点击事件","titles":[]},"671":{"title":"按下的情形","content":"首先找到Raycast找到的对象如果为按下事件，如果按下的对象并不是之前Hover的对象，则触发进入事件。然后就处理PointerDown事件，如果找不到该事件的话就触发PointerClick事件。如果多次点击的话还会增加PointerEventData的clickTime，双击间隔是固定为0.3秒钟。同时保存下拖拽初始状态，如果有相对应的处理方法IInitializePotentialDragHandler的话就一起触发。","titles":[]},"672":{"title":"放开的情形","content":"首先触发PointUp事件。之后寻找PointClick事件，并且触发。如果不存在的话那就查看是否存在Drag事件并且执行，最后再执行PointerExit事件。","titles":[]},"673":{"title":"之后处理Move以及Drag事件","content":"主要还是触发Enter、Exit以及BeginDrag还有Drag等逻辑，比较业务向也就不再写了。","titles":[]},"674":{"title":"点击事件处理","content":"写得比Touch更加紧凑，左键中建以及右键的处理都是分开的。而且实现方式与Touch也太像了，所以也就不再赘述了。","titles":[]},"675":{"title":"射线检测","content":"射线检测绝对是其中非常重要的一个东西，在NGUI中我们都知道事件触发靠射线检测，同样在UGUI中射线检测也是同样的存在。我们在上面的Touch事件处理的地方会看到这么一段代码：通过射线raycast来检测我们的射线数据中包含哪些东西。并且取其中的第一个并且进行事件触发。这个数据我们可以具体看RaycastResult这个类：射线检测的结果而具体cast的步骤则在下面这个函数中，其实是依次调用所有的Raycaster中的射线检测。我们会去Raycaster Manager中寻找所有的Raycaster。所有Raycast在Enable的时候就会自动注册到Raycaster Manager中现在就明白Graphic Raycaster是用来做什么的了吧。当然除了Graphic Raycaster以外还有各种各样的Raycaster:Unity内部提供的各类Raycaster我们这里就只着重看一下Graphic Raycaster","titles":[]},"676":{"title":"Graphic Raycaster","content":"核心方法就是经过重写的Raycaster，这个函数帮助我们检测画布上被射线触发的地方并且返回结果。其实就是普通的射线检测，无非需要针对多屏幕、以及不同的Block模式进行判断，最终调用的是另外一个Raycast。找到被射线穿过的Graphic获得射线所穿过的Graphic，将这些结果逐一加入到Result当中。在放入到Result之前会将这些Graphic根据深度进行排序。当然最终结果的筛选规则会有更多，例如是否在摄像机后面、是否大于最大射线距离等等。最终得到的就是我们最终射线结果。","titles":[]},"677":{"title":"如何执行事件","content":"","titles":[]},"678":{"title":"直接调用事件 ExecuteEvents.Execute","content":"核心方法为ExecuteEvents.Execute，如果需要触发事件就调用该方法吧！我们需要向其中传3个参数：一个是传递的GameObject，也就是挂载事件的对象。  第二个参数则是PointEventData，这个参数最终会传给事件处理函数，通常是UGUI自己对输入进行处理并且输出的。  最后一个参数就是一个传入的delegate，用于接收各种EventData，最后经由一个验证函数来获得具体的EventData。接下来我们就看一下具体是如何针对一个GameObject进行事件调用的：首先调用GetEventList然后获得具体有哪些Handler，然后逐一进行调用。如果handler的数量大于0则返回true。我们看一下获取EventList的规则：其实也只是判断了一下是否为IEventSystemHandler这么简单。","titles":[]},"679":{"title":"向上查找","content":"在很多地方例如Click事件触发的时候往往不是在该射线检测到的GameObject上，而是会向上查找Handler:其中核心方法就是  GetEventHandler ，我们看看其中的实现：获得UGUI会从射线检测到的GameObject开始，不断向上查找，直到根为止，如果找到则返回，如果找不到可以处理的相应事件则直接返回Null。","titles":[]},"680":{"title":"事件链","content":"除了获取EventHandler这种情形之外，还有触发GameObject树结构中所有挂载事件的物体。这个时候就有了我们上面看到的  ExecuteHierarchy ，它的作用就是调用Hierarchy中所有挂载事件的GameObject。我们看到，该函数首先获取事件链，然后逐个进行触发，比较重要的就是获取事件链的过程：从下往上进行遍历，将所有拥有事件的对象通通都调用一遍就是这个事件链的本质。","titles":[]},"681":{"title":"事件触发机制总结","content":"不同的组件触发事件的方法都不一样，比如我们上面 看到的OnPointDown是用事件链，而PointClick则是使用的向上查找。我们要防止类似于PointClick这类事件，因为如果下层已经实现了该回调则上层回调则再也无法被调用到，因为已经被下层拦截，所以也不要一口气把所有的事件全给重载了，要用的时候再加呗。","titles":[]},"682":{"title":"总结","content":"总的来说UGUI的事件系统并不复杂，各个部分还是较为清晰的，如果我们的UI编写当中遇到了问题，或者我们要自己魔改一个组件出来都可以通过看源码来进行解决。了解了其中原理之后就算是事件穿透之类的也完全可以通过源码实现来倒推解决方案，不用到处搜索解决方案了！","titles":[]},"683":{"title":"BaseRaycaster 类","content":"Unity Raycasters 中的三个 Raycaster 类都继承自 BaseRaycaster。首先就来看看 BaseRaycaster 类。BaseRaycaster 类很简单，它包含一个抽象方法   ，定义如下:这个方法供子类覆写以实现对不同类别的物体进行射线检测。BaseRaycaster 类还继承自 UIBehaviour 类，因此它还覆写了    和    方法，在    方法中向 RaycasterManager 类注册了自己，在    方法中从 RaycasterManager 类移除了自己的注册。另外该类中还包含了 eventCamera、sortOrderPriority、renderOrderPriority 等属性，在射线检测物体时会用到。","titles":[]},"684":{"title":"Physics Raycaster","content":"Physics Raycaster 用于检测场景中的 3D 物体对象。PhysicsRaycaster 类继承自 BaseRaycaster，既然是射线检测那么最重要的方法莫过于   ，接下来就一起看看这个方法。在    方法中，首先使用传入的 PointerEventData 参数调用    方法，计算得到从当前射线检测使用的 Camera 的近裁剪面处出发，穿过屏幕事件发生处位置的一条射线；这个方法还会计算一个射线检测使用的最大距离   。内部使用了 Camera 类的    方法将某点转换成一条射线，根据得到的射线的方向以及 Camera 的 farClipPlane 和 nearClipPlane 求得检测最大距离   。具体代码如下:接下来就是进行射线检测了，代码如下:这里的    类里面缓存了一些通过反射得到的射线检测相关的类方法。在上面的代码中使用了    这个代理，最终执行的是 Physics 类的    方法。传入的三个参数就是射线 ray，最大检测距离 distanceToClipPlane 以及需要检测的层 finalEventMask，返回结果就是检测成功得到的 RaycastHit 数组。第三个参数 finalEventMask 定义如下:我们知道，射线检测的时候可以设置哪些 layer 可以接收检测碰撞。上面定义的 finalEventMask 就是需要检测的 layer，如果当前 raycaster 所在的对象有 Camera 组件，那么 finalEventMask 就是摄像机设置的渲染的所有层(  )，否则就是默认所有的层(  )都可以接收射线碰撞检测。然后对检测得到的 RaycastHit 数组按照 distance 由小到大排序。最后将这些射线检测结果依次拼装成 RaycastResult 并返回给 Event System，这里的 RaycastResult 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。","titles":[]},"685":{"title":"Physics2D Raycaster","content":"Physics2DRaycaster 类继承自 PhysicsRaycaster，主要就是    方法中的一点点细小的区别。第一，在进行射线检测的时候，Physics2DRaycaster 中最后调用的是 Physics2D 的    方法。第二处同 PhysicsRaycaster 的不同之处是在返回构造 RaycastResult 时，填充的部分值不一样，包括以下几个:distance，这个值是摄像机到射线检测碰撞点的距离，而在 PhysicsRaycaster 中是 RaycastHit 的    值(射线起点在近裁剪面发出到碰撞点的距离)。  sortingLayer，这个值是当前对象 SpriteRenderer 组件中的    值，在 PhysicsRaycaster 为 0。  sortingOrder，这个同样为当前对象 SpriteRenderer 组件中的    值，在 PhysicsRaycaster 为 0。","titles":[]},"686":{"title":"Graphic Raycaster","content":"Graphic Raycaster 用于射线检测 Canvas 中的 Graphic 对象物体，通常绑定在 Canvas 所在的对象身上。","titles":[]},"687":{"title":"属性或方法","content":"GraphicRaycaster 类的成员属性很少，除了继承 BaseRaycaster 类的一些属性和方法外，它还拥有以下一些常用的属性或方法:属性  描述      射线检测时是否忽略背向的 Graphics     哪些类型的对象会阻挡 Graphic raycasts     哪些 Layer 会阻挡 Graphic raycasts(对    指定的对象生效)不同于 PhysicsRaycaster 和 Physics2DRaycaster 类中直接使用父类的    方法和   ，GraphicRaycaster 覆写了这两个方法，并且当 Canvas 的 render mode 设置为    时，上面两个方法分别返回 canvas 的 sortingOrder 以及 rootCanvas 的 renderOrder。对于 eventCamera 的 get 方法，如果 Canvas 的 render mode 设置为    或者    并且 Canvas 的 worldCamera 未设置时，返回 null，否则返回 Canvas 的 worldCamera 或者 Main Camera。","titles":["Graphic Raycaster"]},"688":{"title":"GraphicRaycaster.Raycast","content":"接下来就来到最重要的覆写的    方法。首先调用    方法获取当前 Canvas 下所有的 Graphic(canvasGraphics，这些 Graphics 在进行射线检测的时候会用到)。紧接着就是 MultiDisplay 的一些检测，代码如下:可以看出，当平台支持 MultiDisplay 时，如果用户操作的不是当前的 Display，那么所有的其他 Display 上产生的事件都会被舍弃。然后将屏幕坐标转换到 Camera 视窗坐标下。如果 eventCamera 不为空，则使用    方法转换坐标，否则直接使用当前 Display 的宽高除以 eventPosition 转换为视窗坐标([0,1]之间)。转换后的坐标若超出 Cmera 的范围(0 - 1)，则舍弃该事件。","titles":["Graphic Raycaster"]},"689":{"title":"Blocked Objects 和 Blocked Mask 出场","content":"前面讲到 GraphicRaycaster 可以设置 Blocked Objects 和 Blocked Mask 来指定射线检测阻挡，下面一步就到了使用这两个属性来阻断射线检测部分。当 Canvas renderMode 不为    并且设置了 blockingObjects，此时就会 Blocked Objects 和 Blocked Mask 就会生效。如果 blockingObjects 包含了    那么则会使用    方法计算 hitDistance(PhysicsRaycaster 中也使用的该方法进行射线检测)。  如果 blockingObjects 也包含了   ，那么会使用    方法(Physics2DRaycaster 射线检测使用)再计算 hitDistance。具体的计算过程大致是: 这上面的代码中 raycast3DAll 时指定了射线检测层   ，这个参数就是自定义设定的   ，属于 block mask 的对象在这里就会就行射线检测，并得到最小的一个 hitDistance；  后面对所有的 Graphics 进行射线检测时，如果检测结果 distance 大于 hitDistance，那么那个结果会被舍弃 。如此一来，   就起到了阻挡的作用，属于这个 layer 的所有对象的一旦被射线检测成功并得到 hitDistance，PhysicsRaycaster 最后的射线检测结果都只会包含这个 hitDistance 距离以内的对象。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"690":{"title":"GraphicRaycaster 类重载了 “真” Raycast 方法","content":"终于可以进行真真切切的 Graphic Raycast 了。在循环中对每一个 Graphic 首先进行了初步的筛选，满足条件的 Graphic 才会调用其    方法，这里的条件筛选包括 deth、raycastTarget 设置、位置信息是否满足等。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"691":{"title":"Graphic.Raycast","content":"对 Canvas 下所有的 graphic 遍历，满足条件则进行射线检测。Graphic 射线检测过程如下:整个检测过程是在一个循环中实现的，从当前 Graphic 节点开始不断向上  递归 ，直至向上再没有节点或者节点绑定的组件中有被射线检测出来结果而返回。对于节点对象，首先获取其绑定的所有组件，依次  遍历 判断组件:当组件是    并且其 overrideSorting 为    则指定: 若在当前节点绑定的一系列的组件中都未能成功唤起检测，则当前节点组件  遍历 结束后将跳出节点  递归 并默认返回   。  如果组件是实现了    接口，则判断组件是否是   。若是    且设置了 ignoreParentGroups 为   ，那么对于接下来的所有 CanvasGroup 组件将不会调用    方法检测；若 CanvasGroup 都未设置   或者不包含 CanvasGroup 组件，则直接调用组件实现的    方法计算是否射线检测成功。从整个 Graphic.Raycast 检测过程可以看出，检测是自当前 graphic 节点开始，一旦检测到某个节点添加实现了    接口且    方法返回    则此 graphic 检测失败并结束检测；否则还会继续向上递归检测父节点，当所有节点(绑定了 Canvas 组件并设置了    为   的节点会截止此次检测)都射线检测成功或是不需要使用    方法进行检测，则此次 Graphic.Raycast 成功。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"692":{"title":"Graphic.Raycast 成功的对象深度排序","content":"对所有射线检测成功的 graphics 按照深度 depth 从小到大排序。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"693":{"title":"Reversed Graphics 过滤","content":"最后对检测结果再过滤。如果设置了    为 true，则将背向 Camera 的对象过滤掉，这里面又分为两种情况:Camera 为空，直接判断当前 Graphic 方向与正方向    是否相交，如下:    首先将    绕着当前 Graphic 的 rotation 旋转得到 Graphic 的正方向，然后通过点积判断 Graphic 正方向是否与默认正方向(没有 Camera 所以默认正方向为   )相交。点积大于 0 则相交，说明当前 Graphic 可以加入射线加测结果中。  当 Camera 不为空，就使用 Camera 的正方向与 Graphic 的正方向比较是否相交。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"694":{"title":"distance 检测是最终一道坎","content":"检测完，对结果进行 distance 计算:Render Mode 为    或者 Camera 为 null，distance 为 0；否则就计算 Graphic 和 Camera 之间的向量在 Graphic 正方向上的投影以及计算射线方向在 Graphic 正方向上的投影，两者相除就得到最终的 distance。如果 distance 小于 hitDistance(设置的 Blocked Objects 和 Blocked Mask 产生)，则结果通过最终的测试可被用作事件的接收者之一。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"695":{"title":"射线检测前后的一些操作","content":"首先来看看这些 Raycaster 被唤起的部分，也就是最开始的流程图中的第三步。Input Module 中使用 Raycaster 处理射线检测，真正的 Raycaster 实施代码又回到了 EventSystem 类中的    方法，具体代码如下:场景中可以存在一个或多个 Raycaster。当存在多个时，如果需要发起射线检测，那么每个处于 Active 状态的 Raycaster 都会工作，所有 Raycaster 检测得到的结果都会存放在    中(这些 RaycastResult 都是在各自射线检测器中根据 distance 从小到大排过序的)。方法最后使用自定义 Comparer 对所有的 RaycastResult 排序。   有以下几种比较流程:两个 RaycastResult 检测所在的 Raycaster 不同首先比较两个对象的 Camera 的 depth。在渲染中，Camera depth 越小会越先渲染，越大越往后渲染，因此对于射线检测来说，Camera 的 depth 越大，它对应的物体应该先于 Camera depth 小的物体进行射线检测，检测得到的结果也应排在前面。代码如下:当 Camera depth 相等的时候，使用    进行比较。优先级数值越大，越先被射线检测选中，所以这里的    方法使用的是右边的参数去比较左边的参数，最终的结果就是按照从大到小(降序)的顺序排列。在 PhysicsRaycaster 和 Physics2DRaycaster 类中没有覆写    方法，因此都返回基类的   ；但在 GraphicRaycaster 类中覆写了此方法，当对应的 Canvas 的 renderMode 设置为    时，此时的    返回 Canvas 的 sortingOrder(Sort Order越大越在上层)，否则同样也是返回基类设置的   ，这是因为在    模式下，所有的 distance 都将是 0。当 sortOrderPriority 相同，再使用 renderOrderPriority 比较。renderOrderPriority 和 sortOrderPriority 类似，仅在 GraphicRaycaster 类中被覆写，也只有在 Canvas 的 renderMode 设置为    时才返回   ，这是因为 Canvas 在其他几种 renderMode 下，渲染的先后顺序都和距离摄像机的距离有关。所以 renderOrderPriority 比较也是按照从大到小的顺序得到最终的结果。同属于一个 Raycaster 检测得到，但是它们的 sortingLayer 不一样对于 PhysicsRaycaster 检测得到的对象，sortingLayer 都为 0。对于 Physics2DRaycaster 检测得到的对象，如果对象上挂载有 SpriteRenderer 组件，那么 sortingLayer 对应的 sortingLayerID，否则也为 0。对于 GraphicRaycaster 检测所得，sortingLayer 就是所在 Canvas 的 sortingLayerID。通过    方法计算 sortingLayer 最终的 sorting layer 值，同样是按照降序排列，因此计算得到的 sorting layer 值越大越先排在前面。sortingLayer 也相同，使用 sortingOrder 比较sortingOrder 和 sortingLayer 类似，PhysicsRaycaster 检测得到的对象 sortingOrder 为 0；Physics2DRaycaster 检测得到的对象是 SpriteRenderer 中的 sortingOrder；GraphicRaycaster 检测所得是所在 Canvas 的 sortingOrder。最终 sortingOrder 越大的对象越排前面。代码如下:sortingOrder 相同，使用 depth 比较PhysicsRaycaster 和 Physics2DRaycaster 中 depth 都被设置为了 0；GraphicRaycaster 检测所得的对象的 depth 就是继承自 Graphic 类的对象所在的 Graphic 的 depth，即 Canvas 下所有 Graphic 深度遍历的顺序。比较同样也是按照降序进行的，因此越嵌套在靠近 Canvas 的对象越排在前面。depth 相同，使用 distance 比较PhysicsRaycaster 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。Physics2DRaycaster 类中返回的是 Camera 的位置和射线碰撞点之间的距离。GraphicRaycaster 类中 distance   计算 如下:距离 distance 越小越靠前。最后如果上述情况都不能满足，使用 index 比较。先被射线检测到的对象排在前面。Raycaster 后段部分的流程: 取排过序的 RaycastResult 中第一个结果作为响应事件的输入事件的 pointerCurrentRaycast，根据它来在 Messaging System 中分发事件，大致代码如下:Raycaster 在 Event System 中的作用和流程基本就是上述的内容。","titles":["Graphic Raycaster","GraphicRaycaster.Raycast"]},"696":{"title":"镜像资源的加载与卸载","content":"Addressables是否能够正确的清理内存主要的取决于是否正确的进行镜像资源的加载与卸载，而如何做到这点又取决于加载的资源的类型与使用加载的方法。  方法可以接受加载到的对象，也可以接受加载时返回的操作句柄(  ).比如，进行场景创建时，加载后返回一个  ，你可以通过返回的句柄或者  (在这种情况下返回的Result为  对象)进行场景的的释放。接下来将详细的描述一下不同资源的释放方式及规则。","titles":[]},"697":{"title":"资源加载","content":"此处的资源指的是使用   或者   加载的资源。\n使用上述的两个方法会将资源加载到内存中，但是并不实例化它，每次调用后对应的资源的引用记数都会增加1。如果您使用  对同一个“地址”的资源调用了3次，您将会得到三个不同的  的实例，同时这些实例均引用相同的底层操作，对就应的底层操作的引用记数会变成3。如果资源加载成功，加载到的资源将会被存储到  中，您可以使用Unity的方法进行实例化  ，但是这种操作方式不会造成Adressables的引用记数发生变化。使用  方法可以进行卸载，调用后引用记数会减1，一旦资源的引用记数为0，那么它会被彻底的卸载掉。","titles":[]},"698":{"title":"场景加载","content":"可以使用  进行场景的加载，同时可以在参数中指定使用  或者  模式，如果指定使用  模式，那么当前所在打开的场景都会被关闭。可以使用  进行场景的卸载，或者打开新场景时使用  模式。当想要打开一个新场景时可以使用上述Addressables提供的方法或者使用   /  ，一个新场景的打开会关闭当前的场景，那么对应的引用记数也会正确的减少。","titles":[]},"699":{"title":"GameObject的实例化","content":"GameObject的实例化相对其它的资源有些特殊，在Unity中使用  其实只是将Prefab的数据加载到了内存中，并未真正的实例化，所以需要再次调用  才能正确的得到需要的GameObject，在Addressables中也是这样的，不过Addressable提供了一些便利的方法  可以直接得到对应的GameObject。当使用  加载一个Prefab时，Addressable会自动实例化，同时在加载的过程中Addressable在加载Prefab的同时也会加载其依赖，将所有的引用记数全部增加。对同一“地址”的资源调用  三次，将会使其依赖的所有资源的引用记数均增加为3.但是与三次调用  不同的是每次调用  将会得到一个指向同一个操作的  ,这是因为每一个  都将得到一个唯一的实例。与其它调用方法的另外一个区别在于  有一个可选参数  ，如果将其设置为false，在  释放前，您必须自己保管着此对象，在此期间您可以执行一些操作。这种方法可以提高效率但是需要更多格外的代码来实现。关闭实例所在场景或者使用  可以卸载掉实例化的对象。如果您在加载时将  设置为false,那么您只能通过调用  并将返回的句柄做为参数，而不能再使用真实的GameObject做为参数进行释放了。关于  格外的说明：如果调用  方法来释放一个实例,但是此实例不是由Addressable创建或者说在使用Addressable创建时设置了  ，此方法调用后将会返回false，以表示Addressable无法释放此实例使用  方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，使用此方法就不再合适，可以考虑使用  进行资源的加载，同时自己保存返回的结果，然后再使用  进行实例化，同时当所有的GameObject不再使用后，再通过  方法将保存的结果进行释放。使用此种方法虽然可以提高部分性能，但是需要对其增加格外的管理。使用  方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，可以考虑使用Addressable进行资源的加载","titles":[]},"700":{"title":"Addressable分析工具","content":"通过  Window->Asset Management->Addressable Profiler 可以打开Addressable的分析工具，在使用此工具前需要将配置中的  Send Profiler Events 打开（默认情况下配置文件为Assets/AddressableAssetsData/AddressableAssetSettings)窗口中显示了Addressable操作的引用记数，包括加载的AssetBundle及加载的资源等等。白色的竖线表示选择的当前的帧  蓝色的背景当前加载的资源  绿色的部分表示引用记数","titles":[]},"701":{"title":"内存清理时机","content":"即使一个资源的不再被引用也不代表此资源被卸载了，因为一个AssetBundle中可能包含有多个资源，比如：一个名称\"stuff\"的AssetBundle中包含有三个资源\"tree\",“tank”,“cow”，当资源\"tree”被加载后，能够看到\"tree\"的引用记录会是1，同时\"stuff\"的引用记数也是1，接着如果加载了\"tank\"资源，此时\"tree\"与\"tank\"的引用记数均为1，同时\"stuff\"的记数会是2。接下来卸载资源\"tree\"，则\"tree\"的引用记数将会减少为0，在\"Addressable Profiler\"中对应于\"tree\"的记录将会被删除，但是此时由于AssetBundle对应的\"stuff\"并未被卸载，因为还有其它的在使用此AssetBundle。使用AssetBundle时可以从AssetBundle中加载部分内容，但是不能部分卸载AssetBundle，只有AssetBundle中的任何资源都不再被使用时，此AssetBundle才会被卸载当使用Unity的   (查看  https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)时，上述描述中的\"tree\"将会被卸载掉，但是由于我们无法检测到此操作，所以我们只能反映引用记数的变化，而不是真正内存中内容的变化。需要注意的是：使用  是一个很费时的操作，一般情况下不建议频繁使用，只有在场景切换时进行调用此段文字有些绕口，简单来说就是由于一个AssetBundle中包含有多个资源，其中的多个资源被加载出来后，只有所有的资源均不再使用时才会正确的卸载掉AssetBundle，同时对于加载出来的资源一般情况下，即使不再使用后也不是立即卸载的，依赖于引擎底层的实现。在Unity中通过使用  可以将不再使用的资源给卸载掉，但是由于此接口过于耗时，并不推荐频繁使用。可以使用的情况一般有：1 进行场景切换时，2 在某些大资源被销毁时，比如说：某此UI界面占用资源特别多，当此UI界面关闭时可以调用。","titles":[]},"702":{"title":"一些注意点","content":"不要想着用异步加载ui..那会很卡..会出现莫名其妙的事情","titles":["内存清理时机"]},"703":{"title":"UGUI的合图是在什么时候发生的？","content":"Unity合大图的时机是根据设置来的。  Edit->ProjectSetting->Editor如上图，可以在打包的时候合，也可以编辑器运行的时候就合。Editor中合成的大图是放在缓存目录里：  。Enabled For Builds  （Unity将精灵打包到Sprite Atlas中，仅用于已发布的版本。Editor和Play模式引用原始源纹理而不是Sprite Atlas中的纹理。）。  Always Enabled   （默认情况下启用此选项。Unity将选定的纹理打包到Sprite Atlases中，Sprite在运行时引用打包的Textures。但是，Sprites将在Editor模式期间引用原始未压缩的纹理。）。简单的说:如果想测试spritepacker是否生效以及代码相关..这时候选择Always Enabled..可以理解为生产模式  如果平时开发Enabled For Builds,只有打包的时候才构建..可以理解为开发模式","titles":[]},"704":{"title":"Include in Build到底干了什么？","content":"勾选了Include in Build后，图集资源会被打进App包体里（不是AssetBundle包）。如果图集是AssetBundle包管理的，最好不要勾选它，会造成资源双份。至于哪些资源会双份，需要实验下看看。","titles":[]},"705":{"title":"禁用Include in Build,使用Late Binding","content":"只要精灵打包到任何精灵图集内，但精灵图集未绑定为默认图集（例如未选中“Include in build”选项），精灵便会在场景中不可见。  用户可以监听回调 SpriteAtlas.atlasRequested。  此委托方法将提供一个要绑定的图集标签和一个接受 SpriteAtlas 资源的 System.Action。用户应按任意方式（脚本引用、Resources.load、资源包）加载该资源，并将该资源提供给 System.Action。注意:SpriteAtlas.atlasRequested只会请求一次无论成功还是失败,所以要确保你的atlasRequested回调一定能返回正确的值  当使用addressable异步加载spriteatlas的时候,也会触发SpriteAtlas.atlasRequested,这个时候内存中可能会存在两份资源的引用..记得释放其中的一份","titles":[]},"706":{"title":"相关链接","content":"https://connect.unity.com/doc/Manual/SpriteAtlas","titles":[]},"707":{"title":"AppDomain","content":"我们运行一个.NET应用程序或者一个运行库宿主时，OS会首先建立一个进程，然后会在进程中加载CLR(这个加载一般是通过调用_CorExeMain或者_CorBindToRuntimeEx方法来实现)，在加载CLR时会创建一个默认的AppDomain，它是CLR的运行单元，程序的Main方法就是在这里执行，这个默认的AppDomain是唯一且不能被卸载的，当该进程消灭时，默认AppDomain才会随之消失。一个进程中可以有多个AppDomain，且它们直接是相互隔离的，我们的Assembly是不能单独执行的，它必须被加载到某个AppDomain中，要想  卸载一个Assembly 就只能卸载其AppDomain。无法删除WindowsApplication1: 访问被拒绝\n请确定磁盘末被写保护\n而且文件末被使用除非你关掉作业管理服务器，然后再操作，显然这样做是很不合理的。并且默认AppDomain是不能被卸载的，那么我们该怎么办呢，我想到的方法是动态的加载Assembly，新建一个AppDomain，让Assembly加载到这个新AppDomain中然后执行，当执行完后卸载这个新的AppDomain即可。核心思想就是：  如果程序集被加载到默认应用程序域中，则当进程运行时将无法从内存中卸载该程序集。但是，如果打开另一个应用程序域来加载和执行程序集，则卸载该应用程序域时也会同时卸载程序集。使用此技术最小化长时间运行的进程的工作集 。AppDomain vs 进程\nAppDomain被创建在进程中，一个进程内可以有多个AppDomain。一个AppDomain只能属于一个进程。  AppDomain vs 线程\n其实两者本来没什么好对比的。AppDomain是个静态概念，只是限定了对象的边界；线程是个动态概念，它可以运行在不同的AppDomain。一个AppDomain内可以创建多个线程，但是不能限定这些线程只能在本AppDomain内执行代码。CLR中的System.Threading.Thread对象其实是个soft thread，它并不能被操作系统识别；操作系统能识别的是hard thread。一个soft thread只属于一个AppDomain，穿越AppDomain的是hard thread。当hard thread访问到某个AppDomain时,一个AppDomain就会为之产生一个soft thread。\nhard thread有thread local storage(TLS)，这个存储区被CLR用来存储这个hard thread当前对应AppDomain引用以及softthread引用。当一个hard thread穿越到另外一个AppDomain时，TLS中的这些引用也会改变。\n当然这个说法很可能是和CLR的实现相关的。  AppDomain vs Assembly\nAssembly是.Net程序的基本部署单元，它可以为CLR提供用于识别类型的元数据等等。Assembly不能单独执行，它必须被加载到AppDomain中，然后由AppDomain创建程序集中的对象。一个Assembly可以被多个AppDomain加载，一个AppDomain可以加载多个Assembly。每个AppDomain引用到某个类型的时候需要把相应的assembly在各自的AppDomain中初始化。因此，每个AppDomain会单独保持一个类的静态变量。  AppDomain vs 对象\n任何对象只能属于一个AppDomain。AppDomain用来隔离对象，不同AppDomain之间的对象必须通过Proxy(reference type)或者Clone(value type)通信。引用类型需要继承System.MarshalByRefObject才能被Marshal/UnMarshal(Proxy)。值类型需要设置Serializable属性才能被Marshal/UnMarshal(Clone)。  AppDomain vs Assembly Code\nAppDomain和程序集的源代码是什么关系呢？每个程序集的代码会分别装载到各个AppDomain中？\n首先我们要把程序集分3类\n1.mscorlib，这是每个.net程序都要引用到的程序集。\n2.GAC，这个是强命名的公用程序集，可以被所有的.net程序引用。\n3.Assembly not in GAC，这是普通的assembly，可以不是强命名，不放到GAC中。\n启动CLR，进入entry point时可以设置LoaderOptimization属性：      LoaderOptimization属性可以设置三个不同的枚举值，来设置针对前面说的三种程序集的代码存放以及访问方式。   SingleDomain，由于只启动一个AppDomain，那么code就被直接装载到了AppDomain中，访问静态变量更快捷。  MultiDomain，所有的Assembly代码是进程级别的，因此所有的AppDomain只访问一份代码。这大大减少了程序占用的内存，但是由于程序集的静态变量仍然在各个AppDomain中，因此代码访问静态变量需要先得到AppDomain的引用再进行转换，速度会受到影响。  MultiDomainHost，只有GAC代码是共享的，非GAC的Assembly依然会加载到被使用的AppDomain中，这样提高了静态变量的访问速度，当然也增加了程序占用的内存。  不管是哪种方式，mscorlib始终是process级别的，即只有一份mscorlib代码在内存中。","titles":[]},"708":{"title":"使用dll进行热更","content":"文章并不是完全的实现热更新,实现的是windows和android平台下，对于dll文件的热更新。对于IOS为什么不能热更新，我们后续会讨论到，先看看安卓和windows下 dll的热更新步骤。新建一个ClassLibrary（类库）的工程，在其中实现对应的类和方法；  将该工程导出为DLL；  将DLL改为bytes文件，存入Unity工程中的StreamingAssets文件夹下；  在工程运行的时候，读取StreamingAssets下的Dll文件，用Assembly.Load(byte[] bytes )的方法，将DLL文件读取出来，进而执行相关的操作。这一步的代码为：unity工程在执行的时候，会构建一个默认的appDomain，Assembly.Load，其实就是在这个程序域上加载Dll,所以相关的实质和前面一个部分相差不大，这就是c#热更新在unity中的应用(IOS不包括)。","titles":[]},"709":{"title":"ios不能基于以上热更的原因","content":"只要我们设定mono的编译模式为full-aot（比如打IOS安装包的时候），则在运行时试图使用JIT编译时，mono自身的JIT编译器就会禁止   生成新的代码 (不要混淆Reflection.Emit和反射)这种行为进而报告这个异常。JIT编译的过程根本还没开始，就被自己扼杀了。JIT——just in time，即时编译。一个程序在它运行的时候创建并且运行了全新的代码，而并非那些最初作为这个程序的一部分保存在硬盘上的固有的代码。就叫JIT。IOS并非把JIT禁止了。或者换个句式讲，IOS封了内存（或者堆）的可执行权限，相当于变相的封锁了JIT这种编译方式。","titles":["使用dll进行热更"]},"710":{"title":"ILRuntime","content":"ILRuntime借助Mono.Cecil库来读取DLL的PE信息，以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解译执行虚拟机来执行DLL中的代码","titles":[]},"711":{"title":"借助Mono.Ceil库来读取DLL的PE信息以及当中类型的所有信息","content":"这一步是如何实现的，跟随源代码做一个详细的跟踪。首先，是构建一个全局的appDomain(这儿不是程序域的意思，只是取其名字意思来表示)基于WWW的方式加载AssetBundle或者DLL/PDB后，接下来是将其封入到MemoryStream中，将dll和pdb的bytes都存入到内存流中后，执行其内部实现的LoadAssembly方法。关键的是第一行，从Mono中加载模块：进一步跟踪：ReadImageFrom的操作：其中ImageReader最终来自BinaryReader:那么接下来的ReadImage操作：这四个操作，是最核心的操作，分别读取DLL的PE的各个信息，这样我们就进入下一个步骤。","titles":["ILRuntime"]},"712":{"title":"最终得到方法的IL汇编码","content":"让我们分拆来看看这几个读取函数的实现1）ReadOptionalHeaders主要读取PE的相关信息，不做过多解释，可以参看源码阅读理解；2）ReadSections读取分块数据封装一个Section，然后去执行读取，然后赋值给section的Data，注意回退了Index","titles":["ILRuntime"]},"713":{"title":"ReadCLIHeader","content":"这步比较简单ReadMetadata核心是两个操作，一个是ReadMetadataStream，就是根据不同的标识符来新建不同的存储结构；一个是ReadTableHeap:初始化heap中的Table后，进行一次Compute，获取size:然后填充size:基于这四步操作，我们可以将IL的汇编码存储到Image中，然后进一步执行后续的CreateModule操作:具体到，就是：其中的ReadModule为：具体的读取manifest和Module内部数据，可以参看源码。","titles":["ILRuntime"]},"714":{"title":"基于LoadedTypes来实现反射方法的调用","content":"在ILRuntime中，不能基于System.Type来直接获取热更新DLL中的类，只有基于唯一的appDomain实例，基于LoadedTypes这种来获取热更新中的DLL，基于代码来分析，更为详细：首先，加载获取该DLL中的指定类：跟踪LoadedTypes：跟踪看mapType.InnerDictionary:这个mapType是什么时候装配的？来自于文章二中的LoadAssembly的后续操作：那么这个module.GetTypes是如何操作的？分别基于协程来return type以及其nestedTypes，关键是看Types是怎么获取的：关键是read操作：继续跟进Read操作：关键是：后续都是对其的封装和填充，对于metadata的填充，来自于InitializeTypeDefinitions这个操作：关键操作是ReadType这个操作：构建一个内部定义的类，然后做数据填充，看看关键的几个属性的设置：BaseType ,设置其父类型，fields  range/methods_range  是对属性范围和方法范围的设置：所以基本方法还是ReadListRange:在这儿，我们最终回到了文章二中对于IL虚拟机中的tableHeap的引用，最后实现了和文章二的首尾呼应。好了，收起思绪，回到最开始的，获取类，这样获得的一个类，这样得到的一个类，继承自IType，在Unity主工程中，则需要System.Type才能继续使用反射接口，其对于的封装来自昱这个ILType封装的ReflectionType， 其中的ILRuntimeType继承自Type类：基于其，可以直接调用System.Type的GetConstructor方法，构建实例，归并几个代码，可以表示为（直接使用的实例源代码）：对应可以得到DLL中该类的构造函数的调用：","titles":["ILRuntime"]},"715":{"title":"基于appDomain内嵌的Invoke来实现反射","content":"在ILRuntime中，在appDomain中内嵌了一套Invoke的实现，可以在Unity工程中直接调用来实现对热更新DLL中类的方法的调用：关键操作就是2步： GetType和 GetMethod，获取类型的过程，和前面有点类似，就是对mapType中存储的获取，如果没有，则进行查找和填充，这儿重点说说方法是如何获取的：粗看就是从methods中取出来，做相应的检查，如果通过则返回，那么初始化操作看看：最后还是从definition.Methods中取出，逐个遍历其中的方法做一个分类存储，如果有静态构造函数，且满足对于的参数条件，则执行一次静态构造。回到开始，在获取到类和方法的相关信息后，就可以执行对于的参数检验，然后执行反射：可见，就是获取到一个IL的解释器，然后执行相应的反射，具体Run怎么执行，就不继续深入贴图了，有兴趣的可以持续跟踪（基本思路就是对stack的操作，塞入各个参数，然后执行一次操作，塞入结果，然后退回）对于ILRuntime的反射基本就先研究到这儿，如果要应用到自己的项目中，可以继续深入研究一下代码，看看实现的具体细节。这儿附上开源的相关文档：ILRuntime中的反射","titles":["ILRuntime"]},"716":{"title":"热更新DLL和Unity主工程的相互调用","content":"基于前面的反射，我们可以基本理出热更DLL和unity主工程的交互本质: 基于IL虚拟机或者.net本身反射来实现交互，对于热更新DLL，其调用unity主工程，则主要是在热更新工程中添加对于unity工程的Assembly-CSharp的引用：基于这个引用，可以调用其中类的各自方法，举两个类来测试：一个不继承自MonoBehaviour：一个继承自MonoBehaviour:这两个Unity主工程中的类以及其中的方法，在热更新DLL中调用：可以在Unity主工程中得到输出：看一下track可以大概了解整个反射的执行过程。对于Unity执行热更DLL中的调用，就是第一部分的反射实例。","titles":["ILRuntime"]},"717":{"title":"热修复HOTFIX","content":"腾讯开源的Unity热更解决方案xLua有一个非常吸引人的特性就是Hotfix，其原理是使用Mono.Cecil库对进行C#层编译出来的dll程序集进行IL代码注入。其作者也在知乎的回答中简单说明了原理：  如何评价腾讯在Unity下的xLua（开源）热更方案？ - 车雄生的回答 - 知乎Mono.Ceil  一个可加载并浏览现有程序集并进行动态修改并保存的.NET框架。可以静态注入程序集（注入后生成新的程序集）和动态注入程序集（注入后不改变目标程序集，只在运行时改变程序集行为。可以通过其实现AOP等高级功能Unity的代码在修改之后会自动编译到Library\\ScriptAssemblies下的两个Assembly中，所以我会尝试着将代码注入到其中。将Test绑定到场景物体上，运行后我们会发现输出  ，就像我们预期的一样。 然后我们尝试着将代码注入到该函数中。我们首先看  ,这是我们在编辑器下进行注入的函数，这里我们需要注意的是，每当我们修改代码之后我们注入的结果会被覆盖掉，所以我们在每次修改代码之后都需要进行注入，所以我们这里添加了标签：  这个标签的意思是，当初始化的时候都进行执行，所以编译完成之后就会自动执行。然后我们看前面两个函数，这两个函数是为了在打包时进行注入而存在的，其中hasGen是为了防止重复注入而定义的flag。然后我们查看一下我们的注入方法  ,在这个函数中我们可以看到，我们首先将我们所需要的函数导入，然后插入到方法的最前端：等待编译完成，并且运行程序，我们发现在输出原来的语句之前多了一句“Inject”\n可是我们在查看代码的时候并没有发生任何改变，这是因为我们只修改了dll而并非修改源代码。","titles":[]},"718":{"title":"注意","content":"ILRuntime并没有创建一个Appdomain,只是取其名字意思.始终工作在默认的AppDomain  ILRuntime中使用Unity项目的委托,需要创建  DelegateAdapter  ILRuntime中继承Unity项目中的类,需要实现  继承适配器  通常情况下，如果要从热更DLL中调用Unity主工程或者Unity的接口，是需要通过反射接口来调用的，包括市面上不少其他热更方案，也是通过这种方式来对CLR方接口进行调用的。(反射一个类,然后创建对象,然后保存到runtime中,调用方法也是通过反射)  但是这种方式有着明显的弊端，最突出的一点就是通过反射来调用接口调用效率会比直接调用低很多，再加上反射传递函数参数时需要使用  数组，这样不可避免的每次调用都会产生不少GC Alloc。众所周知GC Alloc高意味着在Unity中执行会存在较大的性能问题。  ILRuntime通过CLR方法绑定机制，可以  的对经常使用的CLR接口进行直接调用，从而尽可能的消除反射调用开销以及额外的   CLR绑定借助了ILRuntime的CLR重定向机制来实现，因为实质上也是将对CLR方法的反射调用重定向到我们自己定义的方法里面来。","titles":[]},"719":{"title":"相关链接","content":"https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/use   https://www.cnblogs.com/murongxiaopifu/p/4278947.html   https://www.cnblogs.com/murongxiaopifu/p/4211964.html   https://www.cnblogs.com/zblade/p/9100146.html   http://ourpalm.github.io/ILRuntime/public/v1/guide/bind.html   https://www.jianshu.com/p/4bef7f66aefd","titles":[]},"720":{"title":"unity默认的#defind宏变量","content":"Property:   Function:     UNITY_EDITOR  #define directive for calling Unity Editor scripts from your game code.    UNITY_EDITOR_WIN  #define directive for Editor code on Windows.    UNITY_EDITOR_OSX  #define directive for Editor code on Mac OS X.    UNITY_STANDALONE_OSX  #define directive for compiling/executing code specifically for Mac OS X (including Universal, PPC and Intel architectures).    UNITY_STANDALONE_WIN  #define directive for compiling/executing code specifically for Windows standalone applications.    UNITY_STANDALONE_LINUX  #define directive for compiling/executing code specifically for Linux standalone applications.    UNITY_STANDALONE  #define directive for compiling/executing code for any standalone platform (Mac OS X, Windows or Linux).    UNITY_WII  #define directive for compiling/executing code for the Wii console.    UNITY_IOS  #define directive for compiling/executing code for the iOS platform.    UNITY_IPHONE  Deprecated. Use   UNITY_IOS  instead.    UNITY_ANDROID  #define directive for the Android platform.    UNITY_PS4  #define directive for running   PlayStation 4   code.    UNITY_XBOXONE  #define directive for executing   Xbox One   code.    UNITY_TIZEN  #define directive for the Tizen platform.    UNITY_TVOS  #define directive for the Apple TV platform.    UNITY_WSA  #define directive for   Universal Windows Platform  . Additionally,   NETFX_CORE  is defined when compiling C# files against .NET Core and using .NET   scripting backend  .    UNITY_WSA_10_0  #define directive for Universal Windows Platform. Additionally   WINDOWS_UWP  is defined when compiling C# files against .NET Core.    UNITY_WINRT  Same as   UNITY_WSA .    UNITY_WINRT_10_0  Equivalent to   UNITY_WSA_10_0    UNITY_WEBGL  #define directive for   WebGL  .    UNITY_FACEBOOK  #define directive for the Facebook platform (WebGL or Windows standalone).    UNITY_ADS  #define directive for calling Unity Ads methods from your game code. Version 5.2 and above.    UNITY_ANALYTICS  #define directive for calling Unity   Analytics   methods from your game code. Version 5.2 and above.    UNITY_ASSERTIONS  #define directive for assertions control process.","titles":[]},"721":{"title":"在 .NET 4.x 和 .NET Standard 2.0 配置文件之间进行选择","content":"一旦切换到 .NET 4.x 等效脚本运行时，可使用 PlayerSettings 中的下拉菜单指定“Api Compatibility Level”（“Edit > Project Settings > Player”）。 有两种选项：.NET Standard 2.0 。 此配置文件与 .NET Foundation 发布的   .NET Standard 2.0 配置文件 匹配。 Unity 建议新项目使用 .NET Standard 2.0。 它比 .NET 4.x 小，有利于尺寸受限的平台。 此外，Unity 承诺在 Unity 支持的所有平台上支持此配置文件。   .NET 4.x 。 此配置文件提供对最新 .NET 4 API 的访问权限。 它包括 .NET Framework 类库中提供的所有代码，并且支持 .NET Standard 2.0 配置文件。 如果 .NET Standard 2.0 配置文件中未包含项目所需的部分 API，请使用 .NET 4.x 配置文件。 但此 API 的某些部分并非在所有 Unity 平台上均受支持。可在 Unity 的  博客文章 中阅读有关这些选项的更多信息。","titles":["unity默认的#defind宏变量"]},"722":{"title":"使用 .NET 4.x API 兼容级别时添加程序集引用","content":"在“API 兼容级别”下拉列表中使用 .NET Standard 2.0 设置时，将引用和使用 API 配置文件中的所有程序集。 但是，在使用较大的 .NET 4.x 配置文件时，默认情况下不会引用 Unity 附带的某些程序集。 若要使用这些 API，必须手动添加程序集引用。 可在 Unity 编辑器安装的 MonoBleedingEdge/lib/mono 目录中查看 Unity 附带的程序集：例如，如果使用的是 .NET 4.x 配置文件且希望使用   ，则必须为 System.Net.Http.dll 添加程序集引用。 如果没有它，编译器将报错，指示缺少程序集引用：每次打开 Unity 项目时 Visual Studio 都会为其重新生成 .csproj 和 .sln 文件。 因此，无法直接在 Visual Studio 中添加程序集引用，因为它们将在重新打开项目时丢失。 相反，必须使用名为 mcs.rsp 的特殊文本文件：在 Unity 项目的根Assets目录中创建名为 mcs.rsp 的新文本文件。  在空文本文件的第一行，输入：  ，然后保存文件。 可将“System.Net.Http.dll”替换为可能缺少引用的任何包含的程序集。  重启 Unity 编辑器。","titles":["unity默认的#defind宏变量","在 .NET 4.x 和 .NET Standard 2.0 配置文件之间进行选择"]},"723":{"title":"相关链接","content":"https://docs.microsoft.com/zh-cn/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019   https://docs.unity3d.com/Manual/PlatformDependentCompilation.html","titles":["unity默认的#defind宏变量"]},"724":{"title":"什么是视差背景？","content":"视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。简单地说，视差背景其实就是通过多层次的背景来模拟透视视差效果：就是当发生移动时，离照相机越近的背景移动越快；反之越慢。这样，我们的背景就会形成类似于透视视差的效果。那么，既然需要透视效果，为何不直接使用透视投影来做呢？这个原因是如果使用透视投影来产生视差的话，我们的远景必须真的是一个非常大的背景，你如果想模拟出一百倍于近景的远景，那么可能就需要相应尺寸的背景贴图。这种做法显然是做不到的。当然，如果是3D 背景的话有其他方式，不过对于2D 游戏而言，最直接有效的还是多层次背景模拟出视差效果。我们这里也主要聊聊如果通过多层次背景滚动的方式实现视差效果。在整个视差背景实现过程中，需要完成两个主要工作：实现单层背景的滚动；  复合多层背景的滚动，实现视差效果；","titles":[]},"725":{"title":"实现单层背景的滚动","content":"背景滚动是实现视差效果的核心也是最重要的问题。背景滚动存在横向和纵向两种。所有使用视差背景的游戏都会有横向滚动的情况，而纵向滚动则未必都会有。我们这里以横向滚动来介绍背景滚动。我们有四种常规方式可以实现背景的滚动：通过移动一个四边形顶点的 UV 移动形成滚动，之后就称之为 UV 滚动方式；  通过滚动移动多个连续的背景精灵形成滚动，之后就称之为精灵滚动方式；  添加背景层照相机，移动照相机形成滚动，之后就称之为照相机移动方式；  精灵滚动方式和照相机移动方式混合使用，之后就称之为混合滚动方式；为了更好地解释这几种实现方式，需要几张图片用于介绍：我们使用一个黄框精灵代表屏幕取景区域：接下来是三张可拼接的背景精灵：","titles":[]},"726":{"title":"UV 滚动方式：","content":"使用 UV 坐标移动形成滚动的效果看起来是这样的：在 UV 坐标移动的方法中，我们只是用一个和照相机取景区域一样大的精灵作为背景渲染区域。然后通过调整它的 UV 坐标和采样方式实现平铺背景以及背景滚动。具体实现步骤：准备一个覆盖整个屏幕的四边形顶点，并使用它显示背景贴图；  调整 UV 坐标和纹理之间的采样方式，以实现纹理连续显示；  移动时，修改四个顶点的 UV 坐标形成滚动；因为我们只使用一张精灵，我们区域采样的方式就是通过 UV 坐标。因此此方式下 UV 坐标存在两个作用：UV 坐标的整数部分标记了当前采样位置使用哪一张背景贴图；  UV 坐标小数部分为选中背景贴图的采样 UV 坐标；因此，此精灵的 UV 坐标必定会大于[0,1]区间。如果背景使用的背景贴图只有一张的话，这个问题很容易解决。我们只要设置图形 API（OpenGL 或 DirectX，这里以 OpenGL 为例）的纹理包装类型（即所谓的 wrapping 类型）即可。所谓的包装类型即指定了当 UV 坐标值在[ 0,1 ]区间之外时，如何获取纹理。那么这里，我们需要让一张纹理重复出现。在 OpenGL 中，我们需要调用此函数来完成包装类型的设置：glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );稍微解释一下此函数：glTexParameteri 函数会对指定的纹理的参数进行设置。我们这里针对2D 纹理（第一参数 GL_TEXTURE_2D）的 x 方向即横向（第二参数 GL_TEXTURE_WRAP_S）的包装模式设置为重复出现的方式（第三参数 GL_REPEAT）。不过如果背景是多张不同的纹理连续出现的话，就不能使用上面的方法解决了。这个时候我们需要编写一个简单的 shader 在 shader 中完成 UV 坐标映射。这里截取出演示 demo 中，获取纹理相关的 shader 代码（GLSL 代码）提供大家参考：UV 方式有着非常良好的性能，但是缺点就是只能处理简单的平铺背景，对于有着复杂结构或是效果的滚动背景没有办法使用。","titles":["实现单层背景的滚动"]},"727":{"title":"精灵滚动方式：","content":"使用精灵滚动形成滚动的效果看起来是这样的：这种方式应该是比较直接的。我们首先使用背景精灵拼接出背景取景区域覆盖到的背景区域。然后在发生背景移动时，我们依然不需要移动背景取景区域，而是通过滚动移动所有的背景精灵来实现背景移动的效果。这种方式实现简单直接，但缺点是发生背景移动时，需要对所有的背景精灵进行移动。对于结构复杂元素较多的背景需要占用更多的性能。","titles":["实现单层背景的滚动"]},"728":{"title":"照相机移动方式：","content":"使用照相机移动形成滚动的效果看起来是这样的：这种方式与精灵滚动方式正好相反。在这种方式下，我们需要使用背景精灵拼接出完整的背景。同时在背景移动时，不移动背景精灵转而移动背景取景区域来实现背景移动效果。这种方式在移动过程中由于只需要移动背景照相机，所以有种很好的移动性能。但是为了使用此方法。我们需要预先将整个背景全部拼接。这样导致同时存在过多的背景精灵在场景中。如果使用的游戏引擎没有场景管理器或是场景管理器性能不佳的情况下，此方式反而会带来额外的性能消耗。","titles":["实现单层背景的滚动"]},"729":{"title":"混合滚动方式：","content":"使用混合滚动方式形成的滚动效果看起来是这样的：顾名思义，混合移动混合了精灵移动和照相机移动两种方式。我们在移动背景取景区域的同时，适时地滚动背景精灵。使得背景取景区域内的背景正确。这种方式结合了精灵滚动方式和照相机移动方式。避免了精灵滚动方式移动过程中，因为需要移动所有背景精灵带来的额外性能开销；也避免了照相机移动方式中，需要预先构建完整的背景而导致场景中存在过多的背景精灵带来的额外性能开销。当然，和照相机移动方式一样，避免不了每一层背景都需要有一个独立的背景照相机。同时在代码实现良好的情况下，性能比前两者都要好。","titles":["实现单层背景的滚动"]},"730":{"title":"四种方式的优劣","content":"","titles":["实现单层背景的滚动","混合滚动方式："]},"731":{"title":"平均性能：","content":"UV 滚动方式只使用了一个四边形并且移动时也只是单纯改变了 UV 采样方式。它的性能是最好的；其次是混合滚动方式；照相机移动方式有更多的空间开销，同时此开销对性能的影响与游戏引擎的场景管理模块密切关联；精灵方式则有最大的移动性能消耗。","titles":["实现单层背景的滚动","混合滚动方式：","四种方式的优劣"]},"732":{"title":"对复杂背景的支持：","content":"即四种方式所实现的背景可以有多复杂。UV 滚动方式碍于实现只能做简单的平铺背景的滚动效果；精灵滚动方式和混合滚动方式可以实现更为复杂一点的背景，可以在简单的平铺背景之上加入一些其他背景精灵元素；而照相机移动方式对背景的构建没有要求，它可以支持非常复杂的背景。","titles":["实现单层背景的滚动","混合滚动方式：","四种方式的优劣"]},"733":{"title":"是否可以无限延伸：","content":"理论上四种方式都可以实现无限延伸。但是对于照相机移动方式来说，实现起来会比较麻烦。而另外三种方式都是循环利用同一个背景，所以天然支持无限延伸的背景。","titles":["实现单层背景的滚动","混合滚动方式：","四种方式的优劣"]},"734":{"title":"复合多层背景的滚动，实现视差效果：","content":"有了上面的工作，这一步也是顺其自然就可以完成：我们首先要构建多层背景，多层背景可以同时只是用一种滚动方式；也可以不同层背景使用不同的滚动方式。比如最远的背景由于基本上都是简单的平铺可以使用 UV 滚动方式构建；而再近一点细节较多的背景层可以考虑后几种滚动方式构建背景。之后是移动，我们需要根据每一层背景的距离决定其在移动过程中的移动速度。速度如何决定并没有统一的方法或是模式。总之，这一点听听美术们的意见是比较合适的。","titles":["实现单层背景的滚动","混合滚动方式：","四种方式的优劣"]},"735":{"title":"Unity混合模式1","content":"","titles":["实现单层背景的滚动","混合滚动方式："]},"736":{"title":"Unity混合模式2","content":"在Unity官方2D游戏Demo中已使用到了视差滚动技术，笔者对此 Demo 中的视差滚动技术进行了研究，Demo 中使用 BackgroundParallax 脚本实现了视差功能，笔者编写此脚本代码说明。官方 demo   链接BackgroundParallax脚本代码说明：","titles":["实现单层背景的滚动","混合滚动方式："]},"737":{"title":"结合透视和正交相机在Unity2D游戏中制作视差效果","content":"在开发MimpiDreams时，我们知道我们想用背景和前景做丰富的视差层。在Steam版本中，有几个图层来管理。所以我们想出了一个可能并不是独一无二的方法，不过在这里还是想概括一下。在unity中有好多使用一个正交相机并用脚本移动图层来设置视差层级的教程。还有一些建议用透视相机和对象的Z轴深度。如果这么做了，设置合适的精灵排序就会变的困难，并且还不能使用优化技术和其他想在MimpiDreams中使用的透视相机的特性。经典的 Mimpi 只用了透视相机来创建，对此我们还有一些  问题 。为了节省填充率我们使用了不透明的对象，不过不得不用Z轴偏移来放置它们以免Z方向有冲突。然而，由于对它们应用了透视视角，它们就以不同的速度移动了。最好的方法是获得两者的优势。设置透视相机来渲染视差层，用正交相机来渲染有角色，平台，拼图等的主平面。当为视差使用透视相机时，就很容易设置它们了。在正交视差中，需要基于相机的距离来缩放每一个对象并放在适当的位置。Toby: The SecretMine的作者Lukáš Navrátil告诉我他差不多会花掉一半的工作时间来设置正交视差层。随着我们技术的结合，他可以做的更快。我和我的同事Jaroslav Stehlík一起开发了这种技术。现在让我们看一下如何设置。Camera and Scene Setup    相机和场景设置 \n层级视图很简单。将视差相机放在主相机的下边，这样它们会一起移动。Main Camera主相机Clear Flags: Don’tclearCulling Mask except parallax layerProjectionDepth: -1Parallax Camera Near近距离视差相机Clear Flags: DepthonlyCulling MaskProjectionClipping PlanesNear: 0.01Far: 10Depth: 0Parallax Camera Far远距离视差相机Clear Flags: SolidColor (or whatever else you want to use as a background)Culling MaskProjectionClipping PlanesNear: 10Far: 500Depth: -2主相机会渲染除正交模式中视差层级之外的所有东西。这需要熟练使用“CullingMask”。“Clipping Planes”解决基于Z轴方向哪个视差对象被哪个视差相机渲染的问题，因此前景在正交平面之前，背景则在它的后边。相机放在Z轴-10的位置，所以在Z < 0的视差中的所有东西都会被近处的相机渲染，在Z > 0位置的对象就会被远处的相机渲染。“Depth”决定相机被渲染的正确顺序。现在在编辑器中需要把所有的视差对象放入视差层中，并将其他所有对象移出该层。你需要考虑正交相机的尺寸和视角设置的透视区域。尤其想在游戏中使用变焦的时候，需要基于主相机的正交尺寸来设置视差的相机视角区域。关键是通常有一个特殊的平面（这个案例中为Z = 0），即视差层会和正交透视有同样的移动速度。这点很重要，因为稍后可以移动和缩放相机并且它会表现的很自然。在Mimpi Dreams开发初期，我们没有意识到那些并在视差设置中出现一些错误。我们不可以稍后更改它，因为它会复位所有的视差层。最后，由于我们没有过多的使用缩放，所以并没有产生多大影响。在下一个工程中，我们肯定会用这个设置。这里有一段可以设置缩放的代码。如果想在Z轴移动相机，则需要更新视差相机的裁剪平面。如何变焦相机有两个选择。可以在Z轴移动主相机（并重新计算裁剪平面），或者可以改变主相机的正交尺寸（并重新计算视差相机的视角区域）。两个选择给出不同的效果，改变正交尺寸是更自然的选择。或者，可以结合这两种技术，看下边的视频。unity 实例Jaroslav准备并给出了你们可以尝试并学习的unity工程。感谢unity提供精选案例的免费资源！可以从Github下载案例工程。工程是用Unity 5.3.3f1制作的。还要看一下展示案例的视频。编辑工作流程 \n在视差层设置对象最好的方法是在编辑模式下去播放游戏。可以移动角色（和相机）让玩家看到它并调整对象至实际视口。唯一的问题是播放模式下在unity中做出的更改不会保存。然而可以在播放模式下拷贝编辑过的对象并粘贴到编辑器中然后保存。我们创建一个有子集的“content”。这个content是在播放模式下编辑和复制过的。退出播放模式后，这个原始的content会被删除，新的content从剪切板粘贴过来，然后预制件就可以使用了。还有，不要忘记将新的对象放到视差层中。还可以编写或者使用一些编辑器工具来帮助你保存和自动完成对象层级设置。上边的案例实在编辑模式下执行的，所以可以在编辑器中用它来设置。不过我们在MimpiDreams中使用了这个工作流程，因为这对于美术设计在场景中移动很容易，并且他可以自己调整层级。Summary    总结Some advantages of this solution    这种解决方案的优势：本地基本设置（脚本仅仅为了变焦）案例中更好的表现静态批处理，因为层级不会移动简单的编辑工作流程Disadvantages    劣势:会产生更多的draw calls我们介绍了和Mimpi Dreams中制作视差效果不同的制作方法。你可能需要自定义一些东西。例如，我们显示所有摄像机的渲染纹理，不过在这边文章中，我想介绍最简单的设置。原文链接：http://www.gamasutra.com/blogs/MichalBerlinger/20160323/268657/Combining_Perspective_and_Orthographic_Camera_for_Parallax_Effect_in_2D_Game.php   https://github.com/MichalBerlinger/ParallaxDemo","titles":["实现单层背景的滚动"]},"738":{"title":"Entitas執行流程","content":"​      也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。\n​      在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。\n  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），只有第一次会遍历所有的Entity生成这个Group，之后再获取该类型Entity的复杂度就只有O(1)。\n  但是也有一定的隐患，当Group和Collector比较少时，这不是一个高消耗操作，但是Group、Collector很多，且在每一帧对Entity进行频繁修改的时候。这可能会成为一个高消耗操作。","titles":[]},"739":{"title":"Tips","content":"1. 在销毁一个Entity时，会移除Entity身上所有的Component，然后再进行回收。在移除Component时可能会通过Group把这个移除事件发送到监听Remove行为的Collector中，Collector会持有这个被销毁的Entity。所以在filter、或execute时不能直接依赖Collector的收集条件，还需要对Entity的Component做独立的判断。\n  其实任何时候filter都需要对Entity的Component做判断，因为Collector收集的Entity很可能在其他地方被改变。2. Entity不应该被ECS系统外的模块持有，因为系统外对Entity的持有不会被自动引用计数（可以自己添加）。可能会导致一个Entity被销毁然后又从池子中重新取出来， 外部模块对这个Entity的引用没有改变，但已经可能不是自己持有的那个Entity了。\n  需要避免在外界持有Entity或通过持有uuid间接从context中持有这个Entity。3. 在replaceComponent时，发送了Remove、Add、Update三个事件，而不是只发送了Update事件。4. 在代码生成时，对单Componet的Matcher进行了缓存，如游戏中常用的Postion和Name等Component，但是对组合Component的Matcher没有进行缓存。所在在两个不同的ReactiveSystem中使用Matcher相同的Collector时，如：这样会生成两个Matcher相同的Group实例。\n如果在意这一点的话可以自己对Matcher进行缓存。在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用  （immutable）component的感觉。","titles":[]},"740":{"title":"Group","content":"在Context中可以对Entity进行快速过滤，它能不断的更新以保持当前的组中的Entity是最新的。假设Context有上千个Entities，但只有两个Entities拥有PositionComponent，那只要向Context询问特定的组就能立刻获取到所有符合的Entity。Group和Group所过滤到的entities会被缓存下来，所以即使多次调用GetGroup方法，也是非常高效的。内部也是通过Groups的方式来实现。Groups 拥有以下事件OnEntityAdded, OnEntityRemoved 和 OnEntityUpdated来直接响应Entity的变化。","titles":[]},"741":{"title":"Collector","content":"Collector是Group的一个观察者类,Collector提供了一种简单的方法来处理Group中Entity变化的反应。假设你需要收集和处理所有entities，他们的PositionComponent被添加或替换：之后：我们还可以注销这个Collectorcollector.Deactivate();","titles":[]},"742":{"title":"ReactiveSystem","content":"响应式的系统就像执行式系统一样，会每隔一段时间或是在每一个  中被触发  响应式系统的   方法只会在收集器距离上一次  收集到新的Entity才会被执行。  gettrigger使用Collector根据event建立一个group的entity列表如上代码:我们在  方法中返回了一个监测了  Entity的Collector。在   中，我们不需要指定当一个Entity何时应当被收集的事件，因为默认就是会收集在  情况下被通知到的Entity。所以当我们增加一个  组件到一个Entity上时，这个Entity会  到  的group里面，并因此被对应的collector收集到对应的reactive system里面。如下面的代码,AddDebugMessage就会被DebugMessageSystem收集了...执行RemoveDebugMessage()但是DebugMessageSystem仍然收集着呢,但是该实体已经没有了组件DebugMessage.所以需要过滤下Filter(GameEntity entity)否则收集的数据会报错","titles":[]},"743":{"title":"事件","content":"","titles":[]},"744":{"title":"关于replace都干了什么","content":"Group具有事件   ,    and    可以直接对组的更改做出反应。看源码在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用  （immutable）component的感觉。","titles":["事件"]},"745":{"title":"group和collect,还有event应该在什么地方添加.","content":"在系统中的构造函数中  在entitan的system初始化Initialize前因为初始化系统大多会有add,remove等动作.为了保持你的group,还有collect,还有event能够监听到.所以最好在Initialize前","titles":["事件"]},"746":{"title":"Jenny","content":"jenny使用了roslyn, DataProviders需要更改下,否则会报错..一般来说.先运行Jenny-Auto-Import.bat.再运行Jenny-Server.bat就可以了查看所有命令:以VStudio为例，创建一个外部工具：再之后，想要生成代码只需要保持运行   然后在VS中运行   就可以了，这个方法可以让你专注于VS而无需切换回Unity。需要服务器才能使用不开服务器直接可以使用","titles":[]},"747":{"title":"相关链接","content":"https://www.jianshu.com/c/e8e4c3f4280c   https://github.com/OneYoungMean/Entitas-CSharp-OYM/wiki   https://github.com/sschmid/Entitas-CSharp","titles":["Jenny"]},"748":{"title":"1.利用碰撞器的触发器Trigger","content":"这种是比较基础的做法，利用OnTriggerEntry函数，当目标进入触发器时触发。例如玩家有一把剑，我要做攻击判定的话，我就可以在剑上挂一个触发器，设定好大小，当播放动画时，随着剑的挥动，目标会进入Trigger的范围，此时就会调用OnTriggerEntry函数。但是这样做有个弊端，如果挥舞速度太快，检测会有问题；还有就是必须满足“进入”这个条件，也就是说如果原来目标就在触发器范围内，或者触发器在目标内，是不会触发函数的。所以这种方法不太适用于3D游戏。不过这种方法也不是不能用，只是适用条件有限，在2D游戏上，结合上Animation的录制功能，通过动画来改变Trigger的大小，这样就可以触发OnTriggerEntry函数一次或者多次，这样也是可以做出不错效果的。在3D游戏中，可以在人物前面放置一个大小合适Trigger当做攻击范围，再结合动画事件进行攻击判定，不过这样做的缺点是攻击范围大小恒定，如果人物的攻击范围大小不一，就要创建很多空子物体来设定Trigger范围，脚本也不好管理。","titles":[]},"749":{"title":"2.利用数学判断","content":"可以定义两个向量作为攻击范围，向量有方向也有长度，攻击范围是可以确定的。例如设定两个向量，向量1为Transform.forward的左偏45度，向量2为Transform.forward的右偏45度，长度均为5。此时攻击范围为半径为5，度数为90°的扇形。此时就可以计算敌人是不是在攻击范围内，可以通过Vector3.Angle来计算（角度制），Vector3.Distance来计算距离。这种方法的局限在于1.如何获取到敌人的游戏物体，可以通过触发器也可以遍历你的敌人列表。2.当敌人体积过大时，有可能身体的一部分已经进入攻击范围，但是postion没有进入攻击范围，此时判定就会出现错误。看情况使用。","titles":[]},"750":{"title":"3.利用射线Raycast","content":"使用Physics.Raycast()这个方法来发射射线，当射线碰到物体，或者碰到指定Laymask层的物体，或者一定距离后就会返回，返回值是Bool类型。通过out关键字来输出碰撞到的物体的信息，变量类型为RaycastHit。例如我定义一个射线Ray ray =new Ray(), 一个射线返回RaycastHit hit，那么就应该这么使用Physics.Raycast(ray,out hit),表示碰到物体，就会返回ture，物体信息储存在hit中。没有碰到，就会范围false，hit为null。这个方法还有很多重载，可以自己查阅API，根据情况使用。这种方法是射击游戏的常用判断方法，可以结合lineRender来渲染子弹飞过的特效。不过这种方法也不是万能的，它的局限在于射出射线的点只有一个，用来做射击游戏的攻击判定是非常合适的，但是不能用来做判定比较严格的游戏。为什么呢，因为射击游戏的发射方向是可以根据准星调整的，视觉上的判定也是准星方向，如果是动作游戏，rpg游戏之类的，攻击类型多样，就会出现差错。例如一个从上至下的斩击，攻击范围应该是竖着的一条线，那么射线应该怎发射呢？如果直直的往前发射，那么当敌人蹲下的时候，就会检测不到。你或许会想做成动作模式不就完了吗？（就是类似于龙之谷的操作方式），也是不行的，判定始终在攻击轨迹中央，和攻击动画和攻击特效有出入。","titles":[]},"751":{"title":"4.利用射线Linecast","content":"这也是Physics的一个方法， Physics.Linecast（）。连接两个点形成线段，如果线段中间有物体，就返回true,否则返回flase，同样，这个方法需要定义一个RaycastHit类型的变量来接收返回数据，具体方法为Physics.Linecast（Vector3 point1, Vector3 point2，out hit）。这种方法需要在武器或者拳头或者其他的需要攻击判定的地方设定一个点，当动画播放时，这个点的世界坐标就会变化，此时我们可以选择记录某几个时间点上判定点的世界坐标，再用Linecast进行判定。一般取判定点的坐标的话我们同样可以利用动画事件。这种方法调试的时候最好用lineRender把攻击轨迹渲染出来，或者用Debug.DrawLine()画出来（记得设定存在时间，不然一瞬间就消失了看不到），这样可以方便调整我们取判定点的时间节点，不然可能会疑惑，明明我设定好了，怎么检测不到。这种方法适合于动作游戏，以及一些判定比较精细的游戏。需要注意的一点是，Linecast每一帧都会进行判定，一般我们只需要一个动作判定一次，那么还需要在代码里进行约束。","titles":[]},"752":{"title":"外接图形判别法","content":"","titles":[]},"753":{"title":"轴对称包围盒（Axis-Aligned Bounding Box）","content":"概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。算法：两矩形间碰撞的各种情况：在线运行示例（先点击运行示例以获取焦点，下同）：缺点：相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。  对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。  物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。适用案例：（类）矩形物体间的碰撞。","titles":["外接图形判别法"]},"754":{"title":"圆形碰撞（Circle Collision）","content":"概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。两点之间的距离由以下公式可得：判断两圆心距离是否小于两半径之和：图例：在线运行示例：缺点：与『轴对称包围盒』类似适用案例：（类）圆形的物体，如各种球类碰撞。","titles":["外接图形判别法"]},"755":{"title":"圆形与矩形（无旋转）","content":"概念：通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。那如何找出矩形上离圆心最近的点呢？下面我们从 x 轴、y 轴两个方向分别进行寻找。为了方便描述，我们先约定以下变量：首先是 x 轴：如果圆心在矩形的左侧（  ），那么   。如果圆心在矩形的右侧（  ），那么   。如果圆心在矩形的正上下方（  ），那么   。同理，对于 y 轴（此处不列举图例）：如果圆心在矩形的上方（  ），那么   。如果圆心在矩形的下方（  ），那么   。如果圆心在矩形的正左右两侧（  ），那么   。因此，通过上述方法即可找出矩形上离圆心最近的点了，然后通过『两点之间的距离公式』得出『最近点』与『圆心』的距离，最后将其与圆的半径相比，即可判断是否发生碰撞。在线运行示例：缺点：矩形需是轴对称的，即不能旋转。","titles":["外接图形判别法"]},"756":{"title":"圆形与旋转矩形（以矩形中心为旋转轴）","content":"概念：即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。对于旋转后的矩形，要找出其离圆心最近的点，视乎有些困难。其实，我们可以将我们思想的范围进行扩大：将矩形的旋转看作是整个画布的旋转。那么我们将画布（即 Canvas）反向旋转『矩形旋转的角度』后，所看到的结果就是上一个方法“圆形与矩形（无旋转）”的情形。因此，我们只需求出画布旋转后的圆心位置，即可使用『圆形与矩形（无旋转）』的判断方法了。先给出可直接套用的公式，从而得出旋转后的圆心坐标：下面给出该公式的推导过程：根据下图，计算某个点绕另外一个点旋转一定角度后的坐标。我们设 A(x,y) 绕 B(a,b) 旋转 β 度后的位置为 C(c,d)。设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)  由于 |AB| 与 |CB| 相等（即长度），且   |AB| = y/sin(δ) = x / cos(δ)  |CB| = d/sin(δ + β) = c / cos(δ + β)  半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)  由以下三角函数两角和差公式：   sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)  cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)  可得出旋转后的坐标：   c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)  d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)由上述公式推导后可得：旋转后的坐标 (c,d) 只与旋转前的坐标 (x,y) 及旋转的角度 β 有关。当然，(c,d) 是旋转一定角度后『相对于旋转点（轴）的坐标』。因此，前面提到的『可直接套用的公式』中加上了矩形的中心点的坐标值。从图中也可以得出以下结论：A 点旋转后的 C 点总是在圆周（半径为 |AB|）上运动，利用这点可让物体绕旋转点（轴）做圆周运动。得到旋转后的圆心坐标值后，即可使用『圆形与矩形（无旋转）』方法进行碰撞检测了。在线运行案例：优点：相对于圆形与矩形（未旋转）的方法，适用范围更广。","titles":["外接图形判别法"]},"757":{"title":"其他","content":"","titles":["外接图形判别法"]},"758":{"title":"地图格子划分","content":"概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。为障碍物：实现方法：在线运行示例：缺点：适用场景局限。适用案例：推箱子、踩地雷等","titles":["外接图形判别法","其他"]},"759":{"title":"像素检测","content":"概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。实现方法有多种，下面列举在 Canvas 中的两种实现方式：如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。  利用 canvas 的    属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是  内存 。渲染到内存比渲染到屏幕更快。——   Offscreen Rendering当然，我们这里并不是利用    的性能优势，而是利用    保存独立物体的像素。换句话说：  onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行 。另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者  相交区域 ，然后只对该区域内的像素进行检测即可。图例：下面示例展示了第一种实现方式：缺点：因为需要检查每一像素来判定是否碰撞，性能要求比较高。适用案例：需要以像素级别检测物体是否碰撞。","titles":["外接图形判别法","其他"]},"760":{"title":"光线投射法（Ray Casting）","content":"概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线(  )，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线(  )，根据两条线的交点位置来判定是否发生碰撞。抛球进桶图例：在小球飞行的过程中，需要不断计算两直线的交点。当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中：两直线交点在桶口的左右边沿间  小球位于第二条线（  ）下方在线运行示例：优点：适合运动速度快的物体缺点：适用范围相对局限。适用案例：抛球运动进桶。","titles":["外接图形判别法"]},"761":{"title":"分离轴定理（Separating Axis Theorem）","content":"概念：通过判断任意两个    在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。图例：在程序中，遍历所有角度是不现实的。那如何确定    呢？其实  投影轴的数量与多边形的边数相等即可。以较高抽象层次判断两个凸多边形是否碰撞：上述代码有几个需要解决的地方：如何确定多边形的各个投影轴  如何将多边形投射到某条投影轴上  如何检测两段投影是否发生重叠","titles":["外接图形判别法"]},"762":{"title":"投影轴","content":"如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为  边缘向量 。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“  边缘法向量 ”。投影轴 平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。以下是向量对象的部分实现，具体可看源码。向量相减更多关于向量的知识可通过其它渠道学习。","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"763":{"title":"投影","content":"投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。判断两多边形的投影是否重合：为了易于理解，示例图将坐标轴  放置于三角形  投影轴的适当位置。由上述可得投影对象：如何得到向量在投影轴上的长度？\n向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n由于  投影轴 是单位向量（长度为  ），投影的长度为","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"764":{"title":"圆形与多边形之间的碰撞检测","content":"由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示：因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。分离轴定理的整体代码实现，可查看以下案例：优点：精确缺点：不适用于凹多边形适用案例：任意凸多边形和圆形。更多关于分离轴定理的资料：Separating Axis Theorem (SAT) explanation   Collision detection and response   Collision detection Using the Separating Axis Theorem   SAT (Separating Axis Theorem)   Separation of Axis Theorem (SAT) for Collision Detection","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"765":{"title":"延伸：最小平移向量（MIT）","content":"通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"766":{"title":"碰撞性能优化","content":"若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"767":{"title":"粗略阶段（Broad Phase）","content":"Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供这些信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。读者若感兴趣，可以自行查阅相关信息。","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）","碰撞性能优化"]},"768":{"title":"精细阶段（Narrow Phase）","content":"当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）","碰撞性能优化"]},"769":{"title":"最后","content":"碰撞检测有多种，选择合适最重要。完！","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"770":{"title":"参考资料","content":"MDN：2D collision detection   《HTML5 Canvas 核心技术：图形、动画与游戏开发》   Circular Collision Detection   Circle and Rotated Rectangle Collision Detection   推导坐标旋转公式感谢您的阅读，本文由   凹凸实验室  版权所有。如若转载，请注明出处：凹凸实验室（  https://aotu.io/notes/2017/02/16/2d-collision-detection/）","titles":["外接图形判别法","分离轴定理（Separating Axis Theorem）"]},"771":{"title":"扇形攻击","content":"其实这个分为两部分，是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离  是扇形角度范围内计算怪物是否在你的视野范围内其实可以这么看Avatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。这样就能判断是否在视线范围内。所以现在的问题就是这么计算这个夹角计算的方式是，获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量  Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量  调用Vector3.Angle(a, b)计算夹角","titles":[]},"772":{"title":"长方形范围攻击检测","content":"","titles":[]},"773":{"title":"判断目标点是否在指定的矩形内（两个随机点确定的矩形）","content":"测试   脚本","titles":[]},"774":{"title":"判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）","content":"测试脚本","titles":[]},"775":{"title":"半圆形攻击范围检测","content":"","titles":[]},"776":{"title":"圆形攻击范围","content":"圆形攻击范围有两种，以玩着荣耀的王昭君大招为例子，第一种是制定位置施法：新版本的王昭君的大招是指定位置施法的，也就是说在玩家固定施法半径以内可随意放一个圆形的技能。在半径之内的敌人受伤。第二种是固定位置施法：老版本的王昭君大招是在自身一定半径以内，敌人在这个范围内受伤。其实两种判断都很简单，只需要判断敌人和SkillPosition之间的距离是否小于半径即可。方法2","titles":[]},"777":{"title":"判断一个点是否在三角形里面","content":"原理：通过向量之间的对比，利用点乘和差乘实现判断一个点是否在三角形里面。叉乘： 叉乘结果用右手判断法则。","titles":[]},"778":{"title":"方法二","content":"测试脚本","titles":["判断一个点是否在三角形里面"]},"779":{"title":"向量","content":"其实这些小算法基本上用的全是向量的计算,向量的计算有两种","titles":[]},"780":{"title":"向量的点乘","content":"–>A . B = |A| * |B| * cos θ\n–>点乘应用如果 让 A 等于单位向量 |A| ==1 c点积 等于 B 在 A 上的投影  如果 让 A B等于单位向量 arccos(a.b) == 夹角","titles":["向量"]},"781":{"title":"向量的叉乘","content":"–>A* B = C C就是A和B的法向量\n–>叉乘应用c 是有方向 。 通过 左手 定则 可以知道 C 的方向  所以叉乘一般是用来计算方向的  A 和 B 都是单位向量 arcsin(|A*B|) 等于 夹角","titles":["向量"]},"782":{"title":"凸多边形碰撞(分离轴定理算法)","content":"*  正文如下：*分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：）当我发现我需要在flash中检测多边形碰撞时，我碰巧地遇到了一个叫“分离轴定理”的方法。但唯一的问题是，为了真正地掌握它，我可费了不少功夫。在阅读了大量有关碰撞检测的资料，并参看了一些代码示例后，这个方法总算被我领悟了。为了帮助其他那些不精通数学的开发者，我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍。我还在下文引入了一个使用分离轴定理实现的demo，以及供大家下载并使用的ActionScript 3源代码。  （译者：demo和源代码请到原文中查看和下载）注意：分离轴定理需要一点数学向量的知识，所以在深究这个算法前，你最好复习一下这方面的内容。","titles":[]},"783":{"title":"算法简述","content":"从根本上来讲，分离轴定理（以及其他碰撞算法）的用途就是去检测并判断两个图形之间是否有间隙。分离轴定理中用到的方法使算法本身显得十分独特。我所听到过分离轴定理的最好类比方式是这样的：假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。从编程的角度来讲，从每个可能的角度上去检测会使处理变得十分密集。不过幸运的是，由于多边形的性质，你只需要检测其中几个关键的角度。你需要检测的角度数量就正是这个多边形的边数。也就是说，你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和。举个例子，两个五边形就需要检测10个角度。","titles":[]},"784":{"title":"如何在代码中实现","content":"这是一个简易但比较啰嗦的方法，以下是基本的步骤：**步骤一：**从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。**步骤二：**循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点）**步骤三：**对第二个多边形做同样的处理。**步骤四：**分别得到这两个多边形的投影，并检测这两段投影是否重叠。如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。这个算法基本就是如此的。顺带提一下，如果你记录了哪个轴上的投影重叠值最小（以及重叠了多少），那么你就能用这个值来分开这两个图形。","titles":[]},"785":{"title":"那么如何处理圆呢？","content":"在分离轴定理中，检测圆与检测多边形相比，会有点点奇异，但仍然是可以实现的。最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。在这以后就是按套路遍历另一个多边形的每条投影轴，并检测是否有投影重叠。噢，对了，万一你想知道如何把圆投影到轴上，那你只用简单地把圆心投影上去，然后加上和减去半径就能得到投影长度了。","titles":["如何在代码中实现"]},"786":{"title":"优点与不足","content":"和其他的碰撞检测技术一样，分离轴定理算法有它自己的优点和不足。以下是其一些优点和不足的简要概述：","titles":[]},"787":{"title":"优点","content":"（译者：原来老外也喜欢先谈优点啊～>～）分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。  分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……）","titles":["优点与不足"]},"788":{"title":"不足","content":"分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。  分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。可能这个算法会有更多优点和不足之处，但是我想这应该是最主要的几个了。","titles":["优点与不足"]},"789":{"title":"总结","content":"我希望这篇文章能帮助你了解到分离轴定理算法。我已经尽可能地不提供过多的信息并讲解得十分简明了。（我绝不是数学方面的专家，所以如果我遗漏了什么，我深表歉意）以下是一些帮助我理解分离轴定理算法的页面：harverycartel.org ——有更多详细的表述以及很多很酷的示例。我在这个页面上学到了很多。   GPWiki.org ——有不错的讲解和代码示例，我用这些代码作为编写自己代码的基础。   Tony Pa ——向量教程，学习向量的不错资源。   GameDev.net forum ——一个论坛成员写的分离轴定理碰撞检测系统，带给了我一些计算方面的想法。本文翻译自   @sevenson  的文章   Separating Axis Theorem (SAT) Explanation ** 。**","titles":[]},"790":{"title":"其他的一些参考","content":"","titles":[]},"791":{"title":"0技能表","content":"首先说下实现技能的基本思路。实现技能的基本思路就是通过策划填写表格，来配制成某些技能，在执行某个技能的时候，分别去根据这些表格中的内容，确定技能如何表现。基本的逻辑是：","titles":[]},"792":{"title":"1 技能信息管理","content":"unit创建时，此模块管理unit可使用哪些技能，比如游戏中玩家可以选择使用哪些技能。游戏中技能的升级、技能加点、技能池管理都在这个模块。此模块还需要管理技能等级／符文／装备等外部模块对技能参数的修改。","titles":[]},"793":{"title":"2 技能调用接口","content":"提供技能调用的接口供AI或玩家操作调用，调用时可以提供一个目标unit，也可以不提供让技能自己查找。提供三个接口：技能开始skill_enter：开始执行技能，若技能不循环进行，则技能可以自动结束。  技能结束skill_exit：有的技能不能自己结束，比如某些循环技能，对于循环技能玩家可以按住按钮一直释放。当玩家松开按钮，调用技能结束接口，告诉当前技能使其结束，此时技能到达后摇点时，技能不再继续执行。  技能停止skill_stop：当技能被强制打断时，如被攻击、晕眩、蓝不足等，技能会被强制停止。此外，当前一个技能正在执行时新的技能调用启动，此时新的技能调用信息会被保存。一般来说，并不会把所有新的技能调用信息保存下来，那样就成了一个技能执行的序列。我们游戏仅保存一个新的技能调用信息。总的来说，技能模块提供尽量少的接口供AI/UI等上层逻辑使用，这样可以有效的与AI和UI进行解耦。","titles":[]},"794":{"title":"3 技能流程管理","content":"技能流程这里分两点讨论：一个技能可能由多个子技能以一定的模式组合起来。\n一个技能常常由多个子技能以一定的模式组合而成，比如三段击、比如冲锋斩（先冲锋、后斩）等，甚至还存在根据不同的环境选择执行不同的子技能。分析策划需求发现，技能可以分成一个树形结构，这个树形结构非常类似行为树，同样可以将节点分为控制节点和执行节点，甚至可以包括condition节点。为此，我们项目引入一个技能树概念来描述这种数据结构。  一个具体的技能（技能树执行节点）也有一个固定的执行流程。这个流程一般为：前摇过程、前摇过程结束=技能结算时间点、后摇时间点。","titles":[]},"795":{"title":"3.1 技能树","content":"技能树参考传统行为树的设计，使用树形结构控制技能的执行流程。技能树和行为树在结构上比较类似，但是在运行逻辑上有很大的不同。首先，技能树的重点并不是根据上下文选择一个合适的节点执行，而是以一定的策略将技能树从头到尾遍历执行一遍。其次，技能树没有tick的概念，而是基于回调的，比如一个顺序节点，顺序节点中一个子节点执行完毕后，马上通知顺序节点，顺序节点执行下一个子节点，直至顺序节点的最后一个子节点执行完毕，顺序节点就会通知父节点（如果有）它已经执行完毕。此外，为了完成技能的一些需求，控制节点往往存储更多的控制信息来控制子节点的执行流程。具体的信息根据策划需求设置，比如顺序结点包括原子属性和循环属性。如果一个顺序节点具有原子属性，则这个顺树节点在执行的过程中并不会被end，只有全部子节点执行结束才可以end。以我们游戏中战士普攻三段击为例：Paste_Image.png三段击本身是一个顺序节点，当技能开始时，此节点顺序执行三个子节点。对于第一个子节点，它依然是一个顺序节点，首先冲锋至目标单位身前，然后对目标单位进行挥砍。但是冲锋节点还包括了一个condition，若和目标的距离很近，则跳过冲锋节点，直接挥砍。普攻是一个循环技能，这个技能只要玩家点着按钮不放开，技能就会一直执行，因此根节点（普攻）是一个具有循环属性的顺序节点。而对于子技能1（控制节点），他是一个具有原子属性的顺序技能，即当单位正在冲锋时，玩家松开按钮，单位也会执行完挥砍后才会推出技能。！关于技能树的使用和思考技能树开始的设计思路是，有些技能的执行流程和行为树类似，比如以一定的顺序执行一系列子技能，比如根据不同的上下文确定技能的执行流程。简单的说，技能树的引入有以下好处：1.使技能模块可以获得部分AI的能力，从而将和技能强相关的AI逻辑放在技能模块使技能模块和AI模块降低耦合，2.可以清晰的描述技能流程，3.使用树增加拓展性，策划可以设计出各种各样复杂的技能。关于好处1，举个例子：屠夫boss的勾子技能可以将玩家拉过来，若成功的拉过来，boss会执行一个攻击子技能，否则不执行。通过这样可以将勾人和攻击作为两个子技能构成技能树，攻击子技能有一个condition过程，即判断上一个子技能是否成功。技能树在使用后慢慢发现一些问题，首先，技能树的同步要求每个树节点都进行同步，增加同步负担，其次，技能本身并不会有太复杂的控制结构。为此，后来我们对技能树进行了优化：\n1.简化同步信息，不再同步所有节点的enter/exit信息（具体参考文章《技能模块的同步》）。\n2.取消并行节点，通过拓展表头实现一个技能同时执行多件事情。最终的技能树基本上是只有顺序／随机两种控制类型节点，节点拥有较轻度的condition功能。","titles":["3 技能流程管理"]},"796":{"title":"3.2 执行节点的技能流程","content":"一般来说，技能的执行流程包括：前摇时间：技能开始，但是技能真正的结算流程还没开始。技能开始以后，机能相关的特效和动作就开始播放。  前摇时间结束：技能前摇结束时技能开始真正的释放以及结算，等技能前摇结束以后，技能真正的释放并结算。释放包括创建相应的弹道／法术场和buff。  技能后摇点：技能播放到后摇点时间时，技能真正的结束。这时，技能对应的特效以及人物动作可能还会继续播放，但是技能流程已经正式结束了。也就是说，下一个技能可以执行。","titles":["3 技能流程管理"]},"797":{"title":"4 技能目标查找","content":"技能释放时，目标可能已经由AI传给了技能模块，也有可能没有一个目标，如玩家控制单位。技能在释放法术场、弹道的时候，重要的是技能的方向而不是技能目标一般来说，技能获得一个目标对象以后，技能的方向就是释法者到目标的方向。此外，技能方向可能需要一些配置，如前摇锁定（前摇过程中目标移动，技能方向不变），UI可控制（技能释放过程中，玩家可以通过控制UI控制技能的释放方向）。","titles":["3 技能流程管理"]},"798":{"title":"5技能表现","content":"技能的表现包括动作、特效、shader、音效等。其中，特效比较复杂，需要配置的内容也比较多。比如，有些特效挂在模型上，有的特效挂在场景里。对于法术场的特效，分别可以分为法术场开始、结算、结束特效，分别在法术场开始时、结算时、结束时显示。对于buff也类似。","titles":["3 技能流程管理"]},"799":{"title":"6 弹道、法术场和buff等技能创生体","content":"狭义的来说，技能只是负责技能的执行流程（技能树管理以及技能流程管理），而技能真正的结算主要是由其创生体结算的。当技能前摇结束开始生效时，技能创建相应的弹道和法术场，法术场弹道击中敌人时又有可能产生相应的buff。一般来说，法术场是一个场景的某块检测区域，每隔一段时间法术场检测此区域的敌人，并对其攻击结算。\n弹道是一类子弹移动路径的抽象，创建一个弹道就表示一个子弹特效沿这个弹道移动并检测路径上的敌人。\nbuff就是挂在单位身上的一个具有持续时间的状态，状态对单位产生一些正面或者负面的影响，并且在此段时间内，每隔一段时间进行一次伤害结算 。对于技能、法术场、buff之间的功能界定并不是很固定，比如技能能否直接对单位造成伤害，法术场能否对单位造成伤害，甚至技能只能创建法术场，法术场只能检测目标不能造成伤害，只能挂buff，而所有的伤害都是通过buff来结算。当然，这样并不一定好，一般来说，技能和法术场都可以对单位造成伤害。总之，创生体功能的界定需要根据策划需求、效率考虑等因素调整。","titles":["3 技能流程管理"]},"800":{"title":"6.1 Buff状态","content":"Buff就是挂在单位身上持续一定时间的有益或者有害的状态，这里状态＝buff。Buff模块有个需要注意的是Buff之间的相互关系，如排斥（A状态在，B状态挂不上去），清除（A状态挂上去同时导致B状态消失）等。为了实现以上功能，最简单的方式是在状态A中直接填写状态关系状态字段，如状态A排斥状态B/C/D/E...，A状态清除状态X/Y/Z...。以上的实现方式有个问题，等游戏做到后期，我们有成千上万个buff状态，那么一个魔法免疫状态，策划需要填表的排斥状态可能成千上万。为了解决这个问题，可以使用分类的思想解决。定义某类状态和另一类状态之间的规则。\n基于以上思想，引入一个叫buff原子状态的概念，原子状态表示一类状态，如减速、禁魔、魔免、悬空、晕眩、变羊等等等。在给单位挂一个新的buff的之前，查询此buff持有的原子状态和单位身上已经有的原子状态之间的关系，根据单位身上已有的原子状态判定新的原子状态应该使用何种行为处理。此处的何种行为，代表的就是原子状态之间的规则，如排斥等。这些规则可以让策划填一个名字叫“原子状态关系”的表，此表是一个n*n的二维数组，n为游戏中所有的原子状态的数量。原子状态的数量远远小于buff的数量，所以可以很容易的定义这些规则。","titles":["3 技能流程管理"]},"801":{"title":"6.2 法术场","content":"法术场描述对一块区域的影响，这块区域可以每隔一段时间进行一次检测，检测这块区域内的单位并且对单位进行结算。法术场需要注意一个问题，就是一个法术场每次结算可能使用不同的参数进行结算，比如一个技能，第一次结算对每个单位进行晕眩，第二次结算对单位进行伤害。解决这种问题比较直接的方式是技能直接创建两个法术场，每个法术场结算一次，第二个法术场创建具有延迟时间。但是这种方式有个问题，有可能策划需求做一个结算十次而且每次结算的参数都不同的法术场。那么，一个技能以一定的时间间隔创建是个法术场，同时法术场的管理具有一定的成本，从而导致效率的降低。为解决这个问题，我们优化了法术场结算的实现机制，增加了一种新的法术场：序列法术场。这类法术场策划可以配置法术场每次结算之间的时间间隔以及每次结算所使用的法术场参数。这里所说的技能模块包括：技能流程、法术场、弹道和buff。首先介绍authority和proxy的概念，这两个概念是基于单位unit的基础上进行的区分。\nauthority表示单位的主控端，即此单位是由客户端和还是服务端控制。对于玩家avatar，玩家本地的客户端就是主控端。而对于怪物，他们的行为由服务端控制，主控端就是服务端。\nproxy表示代理端，表示被主控端控制。如对于怪物来说，所有的客户端都是proxy；对于玩家A来说，服务端和其他玩家的客户端都是proxy。","titles":["3 技能流程管理","6.1 Buff状态"]},"802":{"title":"0 技能同步的原则","content":"1.客户端先行\n对于玩家控制的单位来说，玩家点击按钮释放一个技能，客户端首先响应，单位播放动作以及相应的技能特效。2.技能流程以authority为发起端\n玩家单位技能发起是由她的客户端，怪物的技能发起是由AI也就是服务端。\n3.技能结算在服务端发起。\n技能真正的结算，比如法术场检测、buff结算、伤害结算等，统一在服务端处理。","titles":["3 技能流程管理"]},"803":{"title":"1 技能执行流程的同步","content":"这里所说的技能执行流程指的是技能树的一个执行节点的流程。技能流程负责动作、特效以及技能结算，其中技能结算包括：释放法术场、弹道或buff。一个技能执行节点的执行流程中，需要同步的有两个时间点：技能开始：技能开始播放动作  技能结算：前摇结束，即能进入结算逻辑。这类同步消息往往并不是由技能本身去同步，而是技能生成了法术场、弹道等，他们去做相应的同步。以玩家点击技能按钮开始释放技能为例介绍技能同步流程，如图所示：Paste_Image.png1.主控端点击技能按钮，技能开始播放动作，主控端告诉服务端技能开始。\n2.服务端广播给所有的客户端(多玩家场景)，告知其他所有的客户端此玩家开始执行技能。其他客户端收到指令后可是播放技能表现。\n3.服务端延迟一段时间后，服务端开始进行技能结算，并且将结算结果通知客户端。延迟时间=技能前摇时间-上行-下行，下行一半不能确定，所以默认为上行=下行另一种中庸的计算方式是：延迟时间=技能前摇时间-上行，防止要求技能前摇时间过长","titles":["3 技能流程管理"]},"804":{"title":"使用此同步流程的表现为：","content":"1.要求技能前摇时间>2*网络延迟，若前摇时间短，则延迟时间=0，效果可能差一些\n2.authority客户端表现完美。\n3.proxy client表现一般，即玩家A看玩家B的效果为：玩家B刚开始执行技能动作，没到前摇时间就进行了技能结算。但是因为玩家一般也不会过分关注其他玩家的动作，所以是可以接受的。","titles":["3 技能流程管理","1 技能执行流程的同步"]},"805":{"title":"2 技能树的同步","content":"我上篇文章  技能系统 已经介绍，我们游戏使用的是技能树来管理技能流程。那么就面临一个问题，技能树如何同步。最简单最暴力的方式，是客户端和服务端同时管理技能树，并且将其状态同步。这样，客户端和服务端的技能树状态统一、完备。后来发现，对于proxy端，并不需要完备的技能树信息，最节省的方式是proxy根本不接受技能树同步信息，只是接受播放动作、技能结算等信息。但这样需要告诉其他proxy播放什么动作、特效等。在我们系统中，技能同步包括三类同步消息:技能根节点enter (root_enter): 表示一个大技能的进入  技能叶子节点enter(action_enter): 表示一个技能树的执行节点的进入。  根节点exit(root_exit) ：表示大技能结束根节点保存一个完整技能的信息，需要和技能模块外部交互，因此需要知道技能的开始和结束。\n叶子节点的执行代表着技能真正的执行逻辑，也需要同步。\n而对于其他节点，作为流程控制节点，只需要在主端确保技能流程无误即可后来这里进行了进一步的优化，对于纯根节点，主控端（玩家控制的客户端）将信息同步给服务端，服务端不再同步给其他客户端。有的技能树只有一个节点，那么按照叶子节点的策略，主控端同步给服务端，服务端广播给所有的其他客户端。","titles":["3 技能流程管理"]},"806":{"title":"3 技能结算的同步","content":"技能结算包括创建法术场、buff、弹道、技能直接伤害等。","titles":["3 技能流程管理"]},"807":{"title":"法术场、弹道的同步","content":"法术场、弹道的同步比较类似，他们都作为一个entity（网络同步单元）在服务端创建，创建以后使用entity管理机制服务端通知客户端他们的创建和销毁。以法术场为例，法术场的执行和同步流程：服务端发起创建一个法术场，并且通知客户端  法术场每隔一段时间结算一次，注意，法术场结算并不需要同步，每隔一段时间服务端执行检测逻辑，客户端播放结算特效等。两个逻辑互不依赖，也不要求时间一致。  当法术场结算时检测到攻击目标时，服务端计算攻击伤害等信息，并将攻击信息发给客户端。  客户端收到伤害信息，客户端播放相应的表现，如法术场受击特效等。此处还包括属于通用模块的跳字等。  当服务端的法术场时间到了进行destroy时，使用entity的管理机制通知所有客户端destroy法术场。弹道的同步类似，唯一的区别就是法术场在某一位置使用攻击盒检测目标，而弹道是一个移动的子弹，客户端表现是一个特效在飞，而服务端每隔一段时间根据飞行速度等使用胶囊攻击盒去检测目标碰撞。由以上可以发现，法术场作为一个entity他的管理成本是比较高的，所以若策划想出一些需求需要使用多个法术场实现，一般通过拓展法术场功能使用一个法术场来实现。比如，策划要做一个冰火两重天法术场，即法术场在每次结算时使用不同的参数，第一次结算使用火焰，第二次结算是冰霜。若这种需求较少，可以使用两个法术场，但是如果要冰火雷毒水电风魔奥术神圣***N重天，则代价太大。一般可以让法术场支持每次使用不同的结算参数来结算即可。","titles":["3 技能流程管理","3 技能结算的同步"]},"808":{"title":"buff同步","content":"buff是附加在unit身上的东西（没有unit就没有buff，但是没有unit可能有法术场），所以不需要使用entity来同步。服务端确定buff是否可以挂在unit上面。  客户端和服务端都维护一个buff管理器，挂buff的消息通知所有客户端，客户端负责表现，服务端负责结算即可。","titles":["3 技能流程管理","3 技能结算的同步"]},"809":{"title":"4 伤害、属性的同步","content":"主要介绍下伤害的同步，顺便附带介绍下属性同步。对于伤害结算来说，技能、buff、法术场和弹道都可能造成伤害，当服务端发现造成伤害时，服务端首先根据技能信息计算伤害值，计算以后将信息通过技能模块发送给所有客户端，所有客户端接到信息后首先播放技能伤害相关的表现，如受击特效等，然后播放跳字等通用伤害客户端表现。buff可能修改单位属性，如攻击力、攻击速度等。单位的属性由基础成长属性+装备属性+buff属性构成，前两个属性为面板属性，属于玩家信息。而buff属性只在战斗中有效，在面板中并没有表现。\n因此装备属性的同步需要通知逻辑服务器（真正的服务器），而buff并不需要通知逻辑服务器。","titles":["3 技能流程管理"]},"810":{"title":"技能，说穿了只是一个流程，而不该是一个实体","content":"1、表的作用实际不是定义流程，而是提供流程中需要的数据。因此不管流程需要数据的是前端还是后端，他们都应该从一个表中调用。\n2、并不是因为把技能作为实体才导致它的混乱，真正导致混乱是的技能实体的范围扩大化了（从这个意义上说，把技能做为一个流程也没什么错，技能的承载内容应该仅仅是这个流程本身），把后续效果剥离出来会好很多。我个人的经验，不评价好坏，大概是这样的：技能的表象数据必须要有，技能效果相应的数据应该仅限于这个技能释放条件和它的直接效果（这个与表象共享技能id，所以最好也放在一起）；直接效果之外的触发效果，单独建立BUFF表，为此建立一套单独的流程，供技能调用（也就是技能效果应该是触发了某个buff）","titles":[]},"811":{"title":"就skill和buff的边界问题，","content":"恰好新的项目里里面我进行了一个比较新的尝试，就是抹除这个边界。 在这次的项目中，因为技能需求足够复杂，所以采用了以前一直只想没实践的想法，就是取消技能在逻辑中的的概念，或者说在基础逻辑中没有技能的设计，技能只在数据层和讨论的概念中出现。 具体的描述也很简单，所谓的技能我们都理解为 施法者一组行为和数据的组合，它包含了技能的icon，类型，动作等一系列和战斗逻辑有直接关系但没有本质关系的概念与数据的总和，用来在游戏概念中定义一个技能的所有特征。 但是在战斗中，真正发挥作用的是buff，在新的设计中，所有的参与战斗逻辑的实体都是buff。 比如 如果要实现一个火球，那么实现方式是技能数据告诉我会播放什么样的施法动画，同时丢出一个弹道，而这个弹道上附着一个buff，叫做燃烧，该buff附带特效火焰和200点的碰撞伤害（在弹道命中敌人时候）。 而这个一整个流程，在概念里，被定义为 施法者释放了一个技能，映射到现实逻辑，就是某人拿起一个石头，点燃，然后把石头丢出去砸到了某人。 至此，核心的技能结算逻辑里，彻底干掉了skill这个类，技能变成了只在概念讨论里才出现的词汇。战斗结算中，不再存在skill的概念。表与脚本混合.又有两种分支,**分支一:主表副脚本,**脚本作为字段绑定于表里.表的某个字段就是技能的脚本路径.技能的主流程,框架逻辑有表的字段来决定.分支二:主脚本副表 ,主逻辑,流程都是有脚本实现.技能的主流程由脚本实现.脚本读表获取数据,进行技能的操作.优点:增加奇怪技能,很方便,直接写脚本就可以了.缺点:批量处理工作量大,既要改表,又要改技能.每个技能对应独立的脚本,技能越多,脚本越多.批量处理的时候,工作量大.","titles":["技能，说穿了只是一个流程，而不该是一个实体"]},"812":{"title":"相关链接","content":"https://zhuanlan.zhihu.com/p/147681650","titles":[]},"813":{"title":"技术细节：托管堆怎样运行以及为什么它会扩张","content":"​    托管堆是内存中被项目脚本运行时（Mono或者IL2CPP）的内存管理器自动管理的部分。在托管代码中创造的所有对象必须被分配在托管堆上（请注意：严格的说，所有非空引用类型的对象和所有被装箱的值类型对象都必须被分配到托管堆上）。​    在上面的图表中，白色的方块表示分配到托管堆的内存量，它里面有颜色的方块表示托管堆内存空间中存储的数据值。当另外的值被需要时，将会从托管堆中分配更多空间。​    垃圾收集器周期运行（请注意：具体时间取决于不同的平台）。会清扫堆上的所有对象，检查那些不再被引用的对象并标记。然后删除没有被引用的对象，释放内存。​    至关重要的是，Unity的垃圾收集是，采用  Boehm GC算法 ，是非世代和非压缩的。非世代意味着当执行一次收集的时候，GC必须清扫全部的托管堆，并且性能会随着堆的扩张而降低。非压缩意味着内存中的对象不会重新移动位置来使对象间的空隙关闭。​    上面的图显示了一个内存片段的例子。当一个对象被释放时，其内存也会被清空。但是被释放的空间不会变成一个大的可用内存池的一部分。被释放对象两边的对象仍然被使用。由于这个原因，被释放的内存变成了其他内存段中间的空隙（这个空隙在上图中由红圈标明）。这个新释放的空间只能用于存储与它完全相同或者更小大小的对象。​    当分配一个对象时，请记住在内存中对象必须总是占用一段连续的空间。​    这导致了内存碎片的核心问题，虽然堆中的总可用空间是非常大的，但是可能一部分或者所有这些可用空间是被分配对象间的小空隙。在这种情况下，尽管可能会有足够的总空间来容纳一个确定大小的分配，但是托管堆找不到一块足够大的连续内存来适配这次分配。​    然而，如果一个大的对象被分配，并且没有足够的连续空间来容纳这个对象，如同上图所示，那么Unity的内存管理器将执行两个操作。​    首先，如果垃圾收集器还没有运行，那么它就会运行。尝试释放足够的空间来填充内存分配的需求。​    如果，GC运行完毕，仍然没有可以满足需求的连续内存空间，那么托管堆将会被扩大。托管堆扩大的具体大小由平台决定；然而，大多数Unity平台将托管堆扩大一倍。","titles":[]},"814":{"title":"托管堆的关键问题","content":"​    托管堆的核心问题是其扩张是以两倍进行的：​    ·当托管堆扩张时，Unity并不总是释放分配到托管堆的内存页，它采取一个优化策略，保持扩张的托管堆，即使托管堆大部分是空的。这用来避免当有更大的内存分配发生时需要重新扩大托管堆。​    ·在大多数平台上，Unity最终会将托管堆上那部分空的内存页释放回操作系统。这个发生的间隔时间是不能保证的，并且也不能被依靠。​    ·用于托管堆的地址空间（栈）不再会被返还给操作系统。​    ·对于32位程序来说，如果托管堆扩张收缩多次，这会导致地址空间（栈）耗尽。如果一个程序可用内存的地址空间（栈）被耗尽，操作系统将会终止这个程序。​    ·对于64位程序来说，地址空间（栈）足够大，这对于运行时间不超过人类平均寿命的程序来说基本不会发生。","titles":[]},"815":{"title":"临时分配","content":"​    许多Unity项目都发现每帧有几十或几百kb的临时数据分配到托管堆处理。这通常对项目性能是非常有害的。考虑下面的计算：​    如果一个程序每帧分配1kb的临时内存，运行在每秒60帧的情况下，那么它每秒就会分配60kb的内存。在一分钟之内，这在内存中增加了3.6mb的垃圾。每秒执行一次垃圾回收器会降低性能，但是尝试在低内存设备上运行时每分钟分配3.6mb内存是有问题的。​    进一步说，考虑到加载操作。如果在一个繁重的资源加载过程中生成了大量的临时对象，并且这些对象被引用到该操作完成，那么垃圾回收器则不能释放这些临时对象并且托管堆需要扩张——即使托管堆中包含的许多这些对象马上就会被释放。​    保持对托管内存分配的追踪非常简单。在Unity的CPU Profiler中，概述写着“GC Alloc”那一列。这一行显示着在某一帧分配到托管堆的比特数。（请注意：这个数字与在制定帧分配的临时比特数不相同。分析器显示的事在特定帧被分配的比特数量，即使这些被分配内存的一些或全部在随后的帧中被复用。）将“Deep Profiling”选项打开，这就可以追踪这些内存分配是在哪些函数中发生的。​    Unity Profiler不会追踪那些没有发生在主线程的内存分配。因此，“GC Alloc”列就不能用来测量在用户自己创建的线程中的托管内存分配。可以把其他线程中的代码切换到主线程中执行来进行调试，或使用BeginThreadProfiling这个API来在Profiler的TimeLine选项卡中来显示样本。​    在目标设备上使用开发模式构建可以分析托管内存分配。​    请注意：一些脚本函数在Editor中运行会导致内存分配，但是当项目构建后就不会再产生内存分配。GetComponent就是最普遍的例子，这个函数在Editor中运行时总是会产生内存分配，但是在构建好的项目中就不会。​    总体来说，我们强烈的建议所有开发者当项目在交互状态时最小化托管堆内存分配。如果内存分配发生在没有交互操作的时候，比如说场景加载时，问题较少。​    Jetbrains Resharper这个Visual Studio插件可以帮助定位代码中的内存分配。​    使用Unity的深度分析模式来定位托管内存分配的特定原因。在深度分析模式，所有的函数的调用都被独立记录，在函数调用树中提供一个清晰界面来显示托管内存分配是在哪里发生的。请注意，深度分析模式不止在编辑器中，也可以使用命令行参数-deepprofiling在安卓和桌面上使用。在分析过程中深度分析器按钮保持灰色。","titles":[]},"816":{"title":"基础内存维护","content":"​    有一些相对简单的技术来使托管堆内存分配降低。","titles":[]},"817":{"title":"容器和数组重用","content":"​    当使用C#的容器类或者数组时，如果可能考虑重用或者缓存分配的容器或者数组。容器类暴露了一个Clear函数，当清除容器的值时不会释放分配给容器的内存。void Update() {  List nearestNeighbors = new List();  findDistancesToNearestNeighbors(nearestNeighbors);  nearestNeighbors.Sort();  // … use the sorted list somehow …  }​    当给一个复杂计算分配临时的“帮助性”容器时尤其好用。下面的代码是一个非常简单的例子：​    在这个例子中，nearestNeighbors列表每帧被分配一次，用于存储一些数据点。可以把这个列表非常简单的从这个函数中提出来放入函数所在的类中，这避免了每帧分配一个新的列表：List m_NearestNeighbors = new List();  void Update() {  m_NearestNeighbors.Clear();  findDistancesToNearestNeighbors(NearestNeighbors);  m_NearestNeighbors.Sort();  // … use the sorted list somehow …  }​    在这个版本中，每帧列表的内存会被保持和重用。只有当列表需要被扩大时内存才会被分配。","titles":["基础内存维护"]},"818":{"title":"闭包和匿名函数","content":"​    当使用闭包和匿名函数时，有两点需要考虑。​    首先，所有函数引用在C#中都是引用类型，因此分配到了托管堆。临时内存分配可以通过作为一个参数传递函数引用很简单的创建。这个内存分配不管是使用匿名函数或者是预先定义好的函数来传递都会发生。​    其次，转换一个匿名函数为闭包显著增加了需要传递闭包到函数接收的内存量。​    考虑下面的代码：List listOfNumbers = createListOfRandomNumbers();  listOfNumbers.Sort( (x, y) =>  (int)x.CompareTo((int)(y/2))  );​    这段代码使用了一个简单的匿名函数来控制第一行创建的列表成员的排序方式。可是，如果一个程序员想要重用这段代码，可以考虑使用一个局部变量来代替常量2，像下面这样：List listOfNumbers = createListOfRandomNumbers();  int desiredDivisor = getDesiredDivisor();  listOfNumbers.Sort( (x, y) =>  (int)x.CompareTo((int)(y/desiredDivisor))  );​    现在匿名函数需要在此函数作用范围之外获取一个变量的状态，所以变成了一个闭包。desiredDivisor变量必须通过某种方式传进闭包中，以便被闭包中的实际代码所使用。​    为了实现这个需求，C#生成了一个匿名类，用来保存闭包需要的超过作用范围的对象。当闭包被传入Sort函数时，将生成一个此类的副本，并且这个类的副本通过整数desiredDivisor的值来初始化。​    由于执行闭包需要实例化一个生成它的类的拷贝，在C#中所有类都是引用类型，那么执行一个闭包需要在托管堆中分配一个对象。​    总体来说，如果可能最好避免在C#中使用闭包。在性能敏感的代码中应该尽量最小化使用匿名函数和函数引用，尤其是在基于每帧执行的代码中。","titles":["基础内存维护"]},"819":{"title":"IL2CPP下的匿名函数","content":"​    目前，检查通过IL2CPP生成的代码，显示简单的声明以及指定一个System.Function类型的变量会分配一个新的对象。无论这个变量是显式（在一个函数或类中声明）或是隐式（作为一个函数的参数声明）都会这样。​    所以，在IL2CPP脚本后端下所有使用匿名函数的情况都会分配托管堆内存。Mono脚本后端不是这种情况。​    进一步说，在IL2CPP中，由于函数参数声明方式的不同，会有显著不同的托管堆内存分配量级的不同。正如预期的那样，闭包在每次调用中分配最多的内存。​    不直观的说，在IL2CPP脚本后端下，当作为一个参数传递预定义的函数时，分配近似于闭包的内存量。匿名函数在托管堆上生成最少量的暂时垃圾，这是通过一个或多个量级的指令实现的。​    所以，如果一个项目想要在IL2CPP脚本后端上发布，有三的关键点需要注意：​    ·采取不需要传递函数作为参数的的编码风格​    ·当这种情况不可避免时，采用匿名函数而不是预定义函数​    ·避免闭包，不管用什么脚本后端","titles":["基础内存维护"]},"820":{"title":"装箱","content":"​    装箱是Unity项目中最普遍的意识不到的临时内存分配的原。它发生在当一个值类型被当做引用类型使用时；这通常发生在传递原始的值类型变量（比如int和float）到对象类型的函数中。​    在这个极度简单的例子中，为了要传递到object.Equals函数中，整数x被装箱，由于object的Equals函数要求传入的是一个object作为参数。int x = 1;  object y = new object();  y.Equals(x);​    C#的IDE和编译器通常不会对装箱发出警告，即使其导致了无意识的内存分配。这是因为C#语言是在小的临时内存分配会被世代的垃圾回收器和分配大小敏感的内存池有效率处理的假设下开发的。​    由于Unity的内存分配器使用不区分内存分配大小的内存池，并且Unity的垃圾回收器也不是世代的，因此其不能有效率的清除由装箱带来的小的，频率的临时内存分配。​    在Unity运行时使用C#编码时，应该尽量避免装箱。","titles":["基础内存维护"]},"821":{"title":"识别装箱","content":"​    基于正在使用的脚本后端，装箱在CPU跟踪数据中显示为一些函数的调用。它们通常采用下面的这些形式之一，是一些其他类或者结构体的名字，...是一些参数的数量：​    ·::Box(…)​    ·Box(…)​    ·_Box(…)​    它可以通过搜索反编译器或者IL查看器的输出来定位，例如ReSharper中内置的IL查看器或者dotPeek反编译器，IL指令是“box”。","titles":["基础内存维护","装箱"]},"822":{"title":"字典和枚举","content":"​    一个普遍的造成装箱的问题是使用枚举类型来作为字典的键。声明一个枚举创建了一个新的值类型，在后台被作为像一个整数来对待，但是在编译时强制执行类型安全原则。​    默认情况下，调用Dictionary.add(key, value)的结果是调用Object.getHashCode(Object)。这个函数用于为字典的键获得合适的散列码，并且用于所有接受key的函数：Dictionary.tryGetValue, Dictionary.remove等等。​    Object.getHashCode函数是一个引用类型，但是枚举值始终是一个值类型。因此，对于枚举作为键的字典来说，每次函数调用都会至少一次对键进行装箱。​    下面的代码片段举出了一个简单的例子展示了装箱的问题：enum MyEnum { a, b, c };  var myDictionary = new Dictionary<MyEnum, object>();  myDictionary.Add(MyEnum.a, new object());​    要解决这个问题，有必要写一个自定义的类实现IEqualityComparer接口，并且传递这个类的实例到字典的比较器中（请注意：这个对象通常是无状态的，所里可以被不同的字典重用以节省内存）。​    下面的是一个对上面代片段实现IEqualityComparer的简单例子。public class MyEnumComparer : IEqualityComparer {  public bool Equals(MyEnum x, MyEnum y) {  ​    return x == y;  }  public int GetHashCode(MyEnum x) {  ​    return (int)x;  }  }​    可以将上面类的实例传递给字典的构造函数。","titles":["基础内存维护","装箱"]},"823":{"title":"Foreach循环","content":"​    在Unity版本的Mono的C#编译器中，使用foreach循环会在每次循环结束时强制Unity去装箱一个值（请注意：在每次循环整个结束的时候这个值会被装箱一次。在这个循环中每次迭代不会装箱，所以不论循环两次还是两百次内存使用都是相同的）。这是因为通过Unity的C#编译器生成的IL构造了一个通用的值类型枚举器以迭代值类型的容器。​    这个枚举器实现的IDisposable接口，其肯定会在循环终止时被调用。然而，在值类型对象（比如结构体和枚举器）上调用接口函数需要把它们装箱。​    检查下面非常简单的代码例子：int accum = 0;  foreach(int x in myList) {  accum += x;  }​    上面的代码，当通过Unity的C#编译器运行时，产生下面的中间语言：.method private hidebysig instance void  ILForeach() cil managed  {  .maxstack 8  .locals init (  [0] int32 num,  [1] int32 current,  [2] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator V_2  )  // [67 5 - 67 16]  IL_0000: ldc.i4.0  IL_0001: stloc.0   // num  // [68 5 - 68 74]  IL_0002: ldarg.0   // this  IL_0003: ldfld    class [mscorlib]System.Collections.Generic.List`1 test::myList  IL_0008: callvirt   instance valuetype [mscorlib]System.Collections.Generic.List  1::GetEnumerator()  IL_000d: stloc.2   // V_2  .try  {  IL_000e: br      IL_001f  // [72 9 - 72 41]  IL_0013: ldloca.s   V_2  IL_0015: call     instance !0/  int32 / valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator::get_Current()  IL_001a: stloc.1   // current  // [73 9 - 73 23]  IL_001b: ldloc.0   // num  IL_001c: ldloc.1   // current  IL_001d: add  IL_001e: stloc.0   // num  // [70 7 - 70 36]  IL_001f: ldloca.s   V_2  IL_0021: call     instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator::MoveNext()  IL_0026: brtrue    IL_0013  IL_002b: leave    IL_003c  } // end of .try  finally  {  IL_0030: ldloc.2   // V_2  IL_0031: box     valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator  IL_0036: callvirt   instance void [mscorlib]System.IDisposable::Dispose()  IL_003b: endfinally  } // end of finally  IL_003c: ret  } // end of method test::ILForeach  } // end of class test​    最有关系的代码是靠近最后的__finally { … }__语句块。callvirt指令在执行这个函数前在内存中发现IDisposable.Dispose方法的定位，并且要求这个枚举器被装箱。​    总体来说，在Unity中应该避免使用foreach循环。不全是因为装箱，还有是通过枚举器实现的容器迭代的函数调用消耗比常规的for或者while循环的迭代要慢的多。​    请注意在Unity5.5中C#编译器有了重大升级，增强了Unity生成IL的能力。特别是，装箱操作已经从foreach循环中消除。然而，由于函数调用的开销，与基于数组的等价代码相比CPU性能差距依旧存在。","titles":["基础内存维护","装箱"]},"824":{"title":"有数组值的Unity API(  译者已查，在Unity官方文档中，会明确表明这些API有临时内存分配 )","content":"​    一个更有害且难于发现的是由于重复使用Unity返回数组的API造成的虚拟的数组内存分配。所有返回数组的Unity的API都会在每次它们被访问时返回一个该数组新的拷贝。在没有必要的情况下经常访问有数组值的Unity的API效果非常不理想。​    举个例子，下面的代码在vertices数组的每次迭代中虚拟的创造了四份拷贝。内存分配在每次.vertices属性被访问时发生。for(int i = 0; i < mesh.vertices.Length; i++)  {  float x, y, z;  x = mesh.vertices[i].x;  y = mesh.vertices[i].y;  z = mesh.vertices[i].z;  // ...  DoSomething(x, y, z);  }​    这可以通过普通的重构来使其只有一次数组内存分配，不论循环迭代多少次。这是通过在进入循环前存储vertices数组来实现的。var vertices = mesh.vertices;  for(int i = 0; i < vertices.Length; i++)  {  float x, y, z;  x = vertices[i].x;  y = vertices[i].y;  z = vertices[i].z;  // ...  DoSomething(x, y, z);  }​    虽然CPU的消耗在访问一个属性一次时并不是非常高，在持续的循环中重复的访问它们会导致性能热点。进一步来讲，没必要的重复访问会导致托管堆的扩张。​    这个问题再移动设备上非常普遍，因为Input.touches这个API的行为与上述类似。这在包含下面的类似代码的项目中也非常普遍，内存分配发生在每次访问.touches属性时。for ( int i = 0; i < Input.touches.Length; i++ )  {  Touch touch = Input.touches[i];  // …  }​    然而，现在有很多Unity的API有不会造成内存分配的新版本。当使用这些时，应该是更有利的。int touchCount = Input.touchCount;  for ( int i = 0; i < touchCount; i++ )  {  Touch touch = Input.GetTouch(i);  // …  }​    转换上面的例子到Touch API 无内存分配的版本是非常简单的：​    请注意：这个属性的访问(Input.touchCount)仍旧要放在循环条件的外面，这是为了节省CPU在执行属性get方法时的消耗。","titles":["基础内存维护","装箱"]},"825":{"title":"空数组重用","content":"​    一些团队在一个数组返回值的函数需要返回一个空值时，倾向于用返回一个空数组来代替null。这种编码模式在许多托管语言中非常常见，尤其是C#和Java。​    总体来说，当一个函数返回一个长度为0的数组时，返回一个预先分配好的长度为0的数组的单例实例比重复创造空数组被认为更有效率。（请注意：当然，一个例外情况要考虑那就是当返回的数组需要改变长度时）https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html","titles":["基础内存维护","装箱"]},"826":{"title":"值类型和引用类型","content":"当调用一个函数时，它的参数值将被复制到一个保留特定调用的内存区域。只占用几个字节的数据类型可以非常快速方便地复制。然而，对象、字符串和数组要大得多，如果这些类型的数据被定期复制，那将是非常低效的。幸运的是，这是不必要的；大项目的实际存储空间是从堆中分配的，一个小的“指针”值用来记住它的位置。从那时起，只有指针在参数传递过程中需要被复制。只要运行时系统能够定位指针标识的项，就可以经常使用数据的一个副本。\n在参数传递期间直接存储和复制的类型称为值类型。这些包括整数，浮点数，布尔和Unity的结构类型（例如Color和Vector3）。分配在堆上然后通过指针访问的类型称为引用类型，因为存储在变量中的值仅仅是“引用”到真实数据。引用类型的示例包括对象，字符串和数组。","titles":[]},"827":{"title":"内存分配和垃圾收集","content":"内存管理器跟踪它知道未被使用的堆中的区域。当请求一个新的内存块时（例如当一个对象被实例化时），管理器选择一个未使用的区域，从中分配该块，然后从已知的未使用的空间中移除分配的内存。后续请求以相同的方式处理，直到没有足够大的空闲区域分配所需的块大小。在这一点上，从堆中分配的所有内存仍然在使用中是非常不可能的。只要还存在可以找到它的引用变量，就只能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则它占用的内存可以安全地重新分配。\n为了确定哪些堆块不再被使用，内存管理器会搜索所有当前活动的引用变量，并将它们所指的块标记为  。在搜索结束时，内存管理器认为这些  块之间的任何空间都是空的，并且可用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程被称为垃圾回收（或简称GC）。","titles":[]},"828":{"title":"优化","content":"垃圾收集对程序员来说是自动的、不可见的，但是收集过程实际上需要大量的CPU时间。如果正确使用，自动内存管理通常会等于或击败手动分配的整体性能。但是，对于程序员来说，重要的是要避免那些比实际需要触发更多次收集器和在执行中引入暂停的错误。有一些臭名昭著的算法，可能是GC噩梦，尽管他们乍一看是无辜的。重复字符串连接是一个典型的例子：这里的关键细节是，新的部分不会被一个接一个地添加到字符串中。实际情况是，每次循环  变量的前一个内容都会变死——一个完整的新字符串被分配到包含原来的部分，再在最后加上新的部分。由于字符串随着  值的增加而变得更长，所以所消耗的堆空间数量也增加了，因此每次调用这个函数时都很容易消耗数百字节的空闲堆空间。如果你需要连接多个字符串，那么一个更好的选择是Mono库的  System.Text.StringBuilder 类。然而，即使反复连接也不会引起太多麻烦，除非它被频繁调用，而在Unity中通常意味着帧更新。就像是：...每次调用Update将分配新字符串，并不断生成的新垃圾。大多数情况下，只有当分数变化时才更新文本：当函数返回数组值时，会发生另一个潜在的问题：当创建一个充满值的新数组时，这种函数非常优雅和方便。但是，如果反复调用，那么每次都会分配新的内存。由于数组可能非常大，可用空间可能会迅速消耗，从而导致垃圾收集频繁。避免这个问题的一个方法是利用数组是引用类型的事实。作为参数传递给函数的数组可以在该函数内修改，结果将在函数返回后保留。\n像上面这样的功能通常可以被替换成：这只是用新值替换数组的现有内容。虽然这需要在调用代码中完成数组的初始分配（这似乎有些不雅），但是在调用该函数时不会产生任何新的垃圾。","titles":[]},"829":{"title":"主动请求垃圾收集","content":"如上所述，最好尽量避免分配。然而，鉴于它们不能被完全消除，您可以使用两种主要策略来最大限度地减少其入侵游戏：","titles":[]},"830":{"title":"小堆垃圾收集快速可频繁收集","content":"这个策略通常最适合长期游戏的游戏，其中平滑的帧速率是主要的关注点。这样的游戏通常会频繁地分配小块，但这些块将仅在短时间内使用。在iOS上使用此策略时，典型的堆大小约为200KB，iPhone 3G上的垃圾收集大约需要5ms。如果堆增加到1MB，则收集大约需要7ms。因此，有时候可以以规则的帧间隔请求垃圾回收。这通常会使垃圾收集发生的次数比严格的需要的更多，但是它们将被快速处理，对游戏的影响最小：但是，您应该谨慎使用此技术，并检查profiler统计信息，以确保它真正减少了游戏的收集时间。","titles":["主动请求垃圾收集"]},"831":{"title":"大堆垃圾收集缓慢且不可频繁收集","content":"这个策略对于分配（和因此收集）相对不频繁并可以在游戏暂停期间处理的游戏最适用。对于堆来说，尽可能大，而不是因为系统内存太少而导致操作系统杀死你的应用程序。但是，如果可能，Mono运行时会自动避免扩展堆。您可以通过在启动期间预先分配一些占位符空间来手动扩展堆（即，您实例化一个纯粹用于对内存管理器产生影响的“无用”对象）：一个足够大的堆不应该在游戏中的暂停期间完全被填满，这样可以容纳一次收集。当发生这样的暂停时，您可以显式地请求垃圾收集：同样，在使用此策略时应该小心，并注意Profiler统计数据，而不是仅仅假定它具有所期望的效果。","titles":["主动请求垃圾收集"]},"832":{"title":"可重复使用的对象池","content":"很多情况下，只要减少创建和销毁对象的数量，就可以避免生成垃圾。游戏中存在着某些类型的物体，如抛射体，尽管一次只会有少量的物体在游戏中，但它们可能会被反复地遇到。在这种情况下，常常可以重用对象，而不是破坏旧对象，并用新的对象替换它们。","titles":["主动请求垃圾收集"]},"833":{"title":"更多信息","content":"内存管理是一个微妙而复杂的课题，它已经投入了大量的学术研究。如果您有兴趣了解更多信息，那么  memorymanagement.org 是一个很好的资源，列出了许多出版物和在线文章。有关对象池的更多信息可以在  维基百科页面 和  Sourcemaking.com 上找到。原文链接：  Understanding Automatic Memory Management","titles":["主动请求垃圾收集"]},"834":{"title":"vs2019 调试unity失效","content":"s怎么启动调试都无法关联到unity，后来发现自己应该是不小心把attach editor勾选掉了，注意这里要重启unity才会生效。勾选上之后就可以调试了。","titles":[]},"835":{"title":"Unity3D 编辑器调试无响应问题","content":"使用 VS 在 Unity 编辑器中调试代码，点击 VS 的   ，Unity 编辑器按下    之后，就会一直等待并且无其他响应，只能结束 Unity 进程。","titles":[]},"836":{"title":"原因分析","content":"经过分析与测试，发现去掉代码中一个单例类的析构方法中的断点即可调试了，具体原因未知。再测试了一下，在那个单例类的构造、析构方法中分别打断点，如下表：测试  构造  析构  结果    1    可调试   2  *   可调试   3   *  无响应   4  *  *  无响应表中    代表打断点可发现只要在那个单例类的析构中打断点就会造成 Unity 无响应。","titles":["Unity3D 编辑器调试无响应问题"]},"837":{"title":"解决办法","content":"删除析构方法中的断点，或者所有断点，再调试。","titles":["Unity3D 编辑器调试无响应问题"]},"838":{"title":"关于如何进行unity远程debugger","content":"首先打开unity的debug模式开启visual sudio中找到attach unity debugger","titles":[]},"839":{"title":"脚本编译顺序","content":"对于大型项目来说，这确实是大家经常遇到的情况。一般来说，Unity Editor会按照脚本的依赖关系编译代码，其主要分为以下四个步骤：\n编译Standard Assets、Pro Standard Assets和Plugins文件夹中的Runtime Script；\n编译以上三个文件夹中Editor文件夹下的Script；\n编译项目中所有剩余的Runtime Script（Editor文件夹以外Script；\n编译剩余Script（即Editor文件夹中Script）。\n知道了Unity编辑器的脚本编译特性后，我们则建议研发团队可以将一些长时间不需要改动的脚本代码（比如各种插件代码）放入到Standard Assets、Pro Standard Assets或Plugins文件夹中，这样这些代码只需要编译一次，后续的时间就都能节省下来。有朋友做过测试，在他们的项目中经过上面的改动，原来项目每次的编译时间从23s下降到7s。想想看，这将节省你和你的团队多少时间！https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html","titles":[]},"840":{"title":"一、前言","content":"刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了：区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y 轴就是左手坐标系，如果是右手 90 度握紧后到了 y 轴就是右手坐标系。除了 3D 世界中的坐标系，还有其他的几个坐标系也非常常用，比如我们经常要把世界三维坐标系转换成我们最终屏幕中的二维坐标系，或者把手机屏幕的二维坐标系转化成游戏世界中的三维坐标系等，各个坐标系各有特别，不能混用，为了更好的学习 Unity 游戏开发，自己在此总结一下 Unity 当中的坐标系和相关用法，以作备忘和学习。","titles":[]},"841":{"title":"二、坐标体系","content":"Unity3D 当中基本的坐标体系主要有下面这四种：世界坐标系 (World Space)  屏幕坐标系 (Screen Space)  视口坐标系 (Viewport Space)  GUI界面坐标系 (GUI System)这四种坐标系可以说没有一个是完全相同的，各个坐标系所代表的意思也可以从字面含义中理解出来，它们之间都是可以相互转换的，不过 GUI 坐标体系除外，它比较特殊，也相对来说是最简单的，那么我们就从最简单的说起吧。1. 绘制 GUI 界面的坐标体系我们在做 Unity 游戏开发的时候，经常会使用内置的 GUI 来做一些测试，比如显示一个按钮控制游戏，画一个文本显示相关信息等。它的代码全部控制在    函数中：这个按钮    所在的坐标系就是 GUI 绘制坐标系。大家稍微测试一下就知道了，它的原点    在最左上角，因为屏幕宽度是    ，高度是    ，所以 GUI 体系右下角的坐标为：    , 这是一个二维的坐标体系，坐标    的值都为 0 。大家可以看下图加深理解：2. 视口 Viewport 坐标体系当我们使用多个相机，在同一个场景中显示多个视口的时候，我们就需要用上视口坐标系了。视口坐标系对于场景的显示非常重要，对于新手来说我们经常使用一个相机就够了，但是当需要使用到多个视口的时候，我们就必须关注视口坐标体系了，大家可以在相机    的属性中看到    就是视口坐标系的设置：一个相机对应一个视口，视口预览（ Camera Preview ）展示了相机所看到的所有物体，很显然，它默认大小是    ，位置也是从 0 到 1 ，这个位置就是我们所讨论的坐标系：左下角为    ，右上角是    ，一般视口坐标系主要用在相机显示中，我们简单的进行    的设置就可以了。另外，新手朋友们可以记住这么一个快捷键：    ，可以快速设置相机视口到当前场景窗口的视口位置。下图是视口坐标系和鼠标在屏幕上的坐标系的转换结果：3. 屏幕 Screen 坐标体系嗯，非常重要！不管怎样，最终我们所有的成果都会发布到各个平台（屏幕）上，所以，任何坐标系的坐标和屏幕坐标系的转换都是非常重要的。比如我们经常需要处理鼠标的相关事件（鼠标位置、单击、双击事件等），或者手机上的触摸反馈，这些原始数据都是屏幕坐标系相关的。虽然重要，其实屏幕坐标系处理起来很简单直接，    获取的就是鼠标在屏幕中的位置坐标。大家可以测试一下，屏幕坐标系中原点    位于左下角，那么右上角必然就是    ，对了，还有一个    呢？都为 0 吗？答案是肯定的，既然是二维坐标系那么    肯定是 0 了，和 GUI 坐标系一样，但是话又说回来，屏幕坐标系转换成世界坐标系    还是 0 吗？其实不然，屏幕坐标转换成世界坐标后物体的    值是取决于相机的，因此：    ，其实在上面视口坐标系介绍中的图中我已经把    鼠标位置转换成世界坐标（    ）了，大家应该注意到了吧。那么，除了坐标系的转换，还有什么值得注意的呢？这里我要告诉大家的是，我们在控制相机的时候，因为屏幕显示的就是相机所看到的内容，而  屏幕的宽高比直接影响了相机的显示 ，也就是    的值，大家可以在 Game 面板中轻松地设置    宽高比，查看对游戏画面的影响：如下图，相机的宽高比和屏幕宽高比一致，显示结果也一致：如果相机的宽高比设置的和屏幕宽高比不一样的话，显示结果就有点不同了：所以，在游戏开发中，**我们要重视相机的宽高比 **   的值，一般我们会保持相机宽高比不变，然后通过改变相机的视口尺寸    来显示场景中需要显示的物体，关于这个主题我会在我的下一篇文章中提到，大家可以关注我的博客。如何通过宽高比获取摄像机视口尺寸呢？首先可以从上图中知道宽高比的计算方法：    ，当你同时获取到    和    的时候，你通过    来得出最终的尺寸大小（  注意这个结果是 2 倍视口尺寸哦 ）。这个在游戏场景中应用的还是比较多的，比如你有这么个需求：两个玩家移动对战，你的相机要把两个移动的玩家随时放置在屏幕显示中。4. 世界 World 三维坐标系最后，世界坐标系！世界坐标系不是最简单的，但却是我们最常用的坐标系。记住一点，任何情况下：    都是返回物体的世界坐标值，及时你所使用的是子物体！另外，从上面所讲的屏幕坐标系转换成世界坐标系也是非常简单的，它以当前相机为参考：另一方面，我们在游戏开发过程中，经常要处理  子物体 的相对    值，这个时候我们就需要稍微动点脑子了，当然如何转变 Unity 已经帮我们预制好相应的函数方法了，你只要  把父物体当做世界，子物体当做世界中的物体 ，使用这些函数，换一下坐标就和处理绝对坐标一样了，不知道大家理解没有。我举个例子，我们在游戏开发中会遇到这种情况，你的相机如果直接放到世界中那么必然会需要调整它的旋转角度才能达到满意的视口位置，如何不让相机产生任何旋转就能把世界中的游戏物体放到合适的视口位置呢？办法就是：我们  把相机放到一个产生了合适旋转角度的父物体当中！这样做的效果就是：相机就相当于子物体，父物体旋转了，子物体就不需要额外旋转了，这时候相机的 局部旋转就为 0 。这在有些场景中使用起来很方便，相机已经是父物体世界中的子物体了。怎么计算相对坐标呢？在 Unity 中都有相应的函数，使用比较简单：","titles":[]},"842":{"title":"三、总结","content":"当然，在使用坐标系过程中我们还要关注其他方方面面，比如欧拉角的旋转，万向锁，平滑过渡视野等等，这些我想我会在后面的文章总结中写道吧。这次就总结介绍了这几个坐标系，看上去有点复杂，总体来说还是挺很好理解的，有什么不对的或者可以加强的请给我留言，谢谢！","titles":[]},"843":{"title":"title : \"Mesh renderer 和 Mesh 和 Mesh Filter\"","content":"","titles":[]},"844":{"title":"基本概念","content":"Meshes  是Unity的主要图形基元。 它们定义对象的形状。   Materials  通过包含对所用纹理的引用、平铺信息、颜色色调等来定义表面应使用的渲染方式。材质的可用选项取决于材质使用的着色器。   Shaders  是一些包含数学计算和算法的小脚本，根据光照输入和材质配置来计算每个像素渲染的颜色。   Textures  是位图图像。材质可包含对纹理的引用，因此材质的着色器可在计算游戏对象的表面颜色时使用纹理。除了游戏对象表面的基本颜色（反照率）之外，纹理还可表示材质表面的许多其他方面，例如其反射率或粗糙度。","titles":[]},"845":{"title":"Texture","content":"Default   Normal Map  法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向，你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面   Editor GUI and Legacy   Sprite (2D and UI)   Cursor   光标文件   Cookie  聚光灯贴图   Lightmap   光照贴图   Single Channel","titles":["基本概念"]},"846":{"title":"Mesh","content":"顶点坐标（vertex） 顶点坐标数组存放Mesh的每个顶点的空间坐标，假设某mesh有n个顶点，则vertex的size为n  三角形序列（triangle） 每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，三角形的数组的size = 三角形个数 * 3.  法线（normal） 法线数组存放mesh每个顶点的法线，大小与顶点坐标对应，normal[i]对应顶点vertex[i]的法线.它不仅说明了  。  次法线 (subnormal)  纹理坐标（uv） 它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的, 以决定表面纹理贴图的位置. UV就是将  图像 上每一个点精确对应到模型物体的表面. uv[i]对应vertex[i]  切线 (tangent) 切线是垂直于法线的一条向量，由于垂直于法线的向量有无数条，所以切线最终规定为由UV坐标来决定朝向。例如：左图利用三个点绘制了一个三角形，而右图则通过两个三角形得到了一个四边形：注：这里需要注意的是，很明显从左图中给定的三个点，有两种方式可以得到三角图元，即顺时针旋转（也称左手螺旋）：p0->p1->p2  逆时针旋转（右手螺旋）：p0->p2->p1它们的区别在哪里呢？类似于物理中左右手判断法则，拇指指示了三角图元的法线方向。法线其中一个作用是指明了三角图元的方向，如果从反方向看的话，这个图元是不可见的。而unity3d是左手坐标系在渲染时默认只渲染正面，背面是看不见的。那么要绘制上图中的三角形，即问题在于表达三个点的坐标，也就可以表示为下面的代码：而如果要绘制四边形，也就需要六个点的坐标，如下面所示：如果单纯使用顶点来表示（绘制）图形，是非常直观的——因为我们知道每一个顶点的位置信息，并且知道每三个点构成一个三角图元。然而从上面绘制四边形的数据中可以发现，三角图元1中有两个顶点的位置信息（p1和p3）和三角图元0是一样的。这也就增加了一些开销。总而言之，这个额外的存储开销是完全可以去除的，方法就是使用索引（Indices）。没错，indices就是这么一回事，原来是vertices数组中，每三个顶点表示一个三角图元，现在是indices数组中，每三个整型表示一个图元。这些整形不存储真正的数据，  。","titles":[]},"847":{"title":"SubMesh","content":"面提到过，MeshRenderer负责对MeshFilter中的Mesh进行绘制，而绘制依赖于着色器，或者说着色器生成的材质（Material）。简单来说，材质具体描述了Mesh中的数据如何进行绘制。\nMaterial只负责一个Mesh的一次绘制，但是现在有一个要求是，Mesh的不同部分，要求使用不同的材质。例如上面所绘制的四边形，两个三角面片要求绘制出不同的颜色。这个时候就需要使用SubMesh了。\n从名字也能看出，SubMesh类似于Mesh，并且Mesh包含SubMesh。但是和Mesh不一样的是，SubMesh只有triangles信息，也就是说SubMesh使用自身的 triangles信息，索引找到 Mesh上的顶点信息（如vertices、 uv、normal等）后进行三角面片的绘制。它们的关系如下图所示：这个设置的过程依赖于Mesh中的API是 SetTriangles，其函数原型为：用法如下：将上述代码挂载到一个空节点上运行，可以得到以下结果：嗯？！难不成笔者在骗人，这里明明只有一个三角面片。莫慌，之前不是说过，要求两个三角面片使用不同的材质吗？如果运行时，将MeshRenderer的Material的Size设为2的话，你会发现另外一个三角图元也出现了：也就是说，有多少个SubMesh，就需要有多少个Material，并且它们的绘制关系是一一对应的。即第一个SubMesh使用第一个\nMaterial绘制，第二个SubMesh使用第二个Material绘制，以此类推。为了验证这个，接下来创建两个默认的Material，将它们的Albedo分别设置为红色和绿色，接着运行时将这两个 Material赋给MeshRenderer，将会得到如下图所示的运行结果：另外，如果双击 MeshFilter的 Mesh属性，从下面的预览窗口，也能看到这个Mesh有两个SubMesh：如何在unity显示线框图\n选择场景视图在其工具栏左侧的显示模式。前三个选项是阴影线框和阴影线框。","titles":[]},"848":{"title":"MeshCombine","content":"MeshCombine，就是合并网格。为什么好好的模型要进行网格的合并呢？如果从应用的角度来看的话，通过网格合并可以实现游戏中的换装，你可能会说，更换的服装例如帽子好好的，为什么要合并到人物模型上？问题在于，如果游戏中不是所有人物模型都是标准的人型呢？例如魔兽世界中，不同种族的头部模型大小是不一致的，很容易出现穿模。当然可以同一顶帽子制作适配于不同种族的模型，反正这个工作是美术做的（溜）。但是从整体出发的话，这样做无疑增加了游戏容量的大小，也会减慢游戏开发的进度，同时一定程度上影响代码的简洁性。但是通过网格合并，将帽子的网格合并到人物模型上，并且蒙皮至人物头部的骨骼上。这样以后，由于骨骼的大小、旋转、位移信息会影响顶点，因此一旦这个帽子戴到别的人物模型身上时，由于它们头部骨骼的大小不一样，那么帽子也会自动变大。也就达到了同一个模型，适用于多个人物模型的目的。\n（关于骨骼、蒙皮、骨骼蒙皮动画，可以参考下面的扩展资料）关于网格合并，同样Unity在 Mesh提供了相关的API：要使用它也很简单，如下面的代码所示：","titles":[]},"849":{"title":"mesh合并的优缺点","content":"静态批处理后，对内存的增加是非常大的，动则就是几十兆的内存  动态批处理，对于合批要求挺多的，同时可能存在，动态合批消耗过大，得不偿失  自己在逻辑代码里面进行动态合批，对于mesh的readwrite属性是要求开启的，这无疑也增大了内存的占用，复杂的合批处理可能会消耗更多的cpu时间  GPU Instancing可以一次渲染(render)相同网格的多个副本，仅使用少量  DrawCalls 。在渲染诸如建筑、树木、草等在场景中重复出现的事物时，GPU Instancing很有用。将这些静态的物件如植被等全部从场景中剔除，而保存其位置、缩放、uv偏移、  lightmapindex 等相关信息，在需要渲染的时候，根据其保存的信息，通过   Instance 来渲染，这能够减少那些因为内存原因而不能合批的大批量相同物件的渲染时间","titles":["MeshCombine"]},"850":{"title":"相关链接","content":"https://zhuanlan.zhihu.com/p/96084686   https://docs.unity.cn/cn/2018.4/Manual/class-Mesh.html   https://docs.unity.cn/cn/2020.1/Manual/Shaders.html   https://learnopengl-cn.github.io/   https://blog.csdn.net/Arkish/article/details/98482430   https://blog.csdn.net/tw_345/article/details/79771454   https://zhuanlan.zhihu.com/p/96084686   https://blog.csdn.net/ecidevilin/category_9266800.html","titles":[]},"851":{"title":"notch solution","content":"首先分为两个component.SafePadding Works with    tree of the uGUI component system.   SafeAdaptation They are based on using   Playables API  to control    with animation playables, therefore utilizing    and    instead of   .","titles":[]},"852":{"title":"原理","content":"我们看这句,如果是使用了模拟器,则使用simulatedSafeAreaRelative在Editor代码中如果改变了模拟器的环境.则会更改该值而生产环境中则会使用NotchSolutionUtility.ScreenSafeAreaRelative,他也是通过Screen.safeArea进行判断的","titles":["notch solution"]},"853":{"title":"safepadding","content":"","titles":["notch solution"]},"854":{"title":"垂直同步","content":"在显示一帧画面时，显卡先从显示缓冲取数据刷新到显示器存储器上，然后，显示器从左上到右下，逐行显示到屏幕上。显示器每画完一行发出一个水平同步信号，画完所有行发出一个垂直同步信号。若显示器刷新率是75，那么发出一个垂直同步信号后会等待1/75秒，然后重新执行上述步骤。游戏中的开启垂直同步，意思是指显卡等待到一个垂直同步信号后才开始工作，向显示缓冲绘制数据。如果我们选择等待垂直同步信号（也就是我们平时所说的垂直同步打开），那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，显卡无法绘制下一屏，只有等75单位的信号到达，才可以绘制。这样FPS自然要受到操作系统刷新率运行值的制约。而如果我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），那么游戏中作完一屏画面，显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。取消了垂直同步信号，固然可以换来更快的速度，但是在图像的连续性上势必打折扣。这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因。开启垂直同步时若游戏的实际显示帧速大于60，显卡就可以在显示器等待的1/60内完成绘制，显示一个无撕裂的画面。此时，游戏的帧速被限制为60。若游戏的实际显示帧速小于60，显卡无法在在显示器等待的1/60内完成绘制，假如游戏帧速50，那么显卡每2个显示器帧才向显示器刷新一次数据，此时，游戏帧速掉为30。关闭垂直同步时若游戏的实际显示帧速大于60，显卡刷新显示缓冲的速度比显示器快，出现跳帧以及撕裂。（1）画面撕裂假设游戏中有一面黑白相间的栅栏墙高速向左运动，显示器设定的刷新率是100Hz，游戏运行速度为200FPS，则显示器扫描第1帧图像至屏幕垂直方向中点时，显卡已经将第2帧图像送了过来，由于栅栏墙高速向左运动，第2帧图像已经左移了一段距离，最终显示的图像如图（图01）。![获得完美游戏效果解析显卡垂直同步设置(/images/2020-09-05-unity-vSyncCount/1520729748.JPG)    图1CS 1.5、Quake等大多数PC游戏在关闭垂直同步后都会有这种现象产生。如果你的电脑上装有CS 1.5游戏，不妨自己证实一下：关闭垂直同步后进入游戏，按下键盘上的左箭头\"←\"让视角匀速转动，是不是看到了\"画面撕裂\"的现象？打开垂直同步后做相同的测试，画面是不是清爽了许多？（2）跳帧假如显示器设定的刷新率是80Hz，显卡以100FPS循环显示0-9数字，那么，在开始的0.1秒内，显卡显示了10个数字而显示器只刷新了8次，最终你看到的图像很可能是这样的：（表格如图02）\n可见，由于显示器刷新率跟不上游戏的FPS，只能舍弃一部分画面，这种现象表现在游戏里就是跳帧。鬼武者3等一些移植到PC上的游戏在关闭垂直同步时通常会出现这种问题。![获得完美游戏效果解析显卡垂直同步设置(/images/2020-09-05-unity-vSyncCount/1536901270.JPG)    图2通过以上的了解，我们认识到，要想在游戏中获得更好的画质，垂直同步一定要开！正是由于垂直同步的存在，游戏才会有完整、稳速、不跳帧的画面。套用一句广告语来说：\"自从开了垂直同步后，画不破了，帧不跳了，头也不眩晕了。\"","titles":[]},"855":{"title":"省电发热优化","content":"如果你的游戏跑到60帧,手机很热..这个时候首先想到的是降低帧率,安卓上:iOS:iOS忽略  QualitySettings .vSyncCount,ios是根据vblank(垂直同步)显示帧(如果有的话)..他的意思就是如果ios的垂直同步是每秒60帧...在刷新垂直同步的时候,如果存在显卡的帧的时候则会显示帧..不存在.则不显示...所以 Application.targetFrameRate是起作用的以上仅参考文档推测...未进行验证....如有意外概不负责Unity - Scripting API: Application.targetFrameRate (unity3d.com)   Unity - Scripting API: QualitySettings.vSyncCount (unity3d.com)","titles":[]},"856":{"title":"资源检查","content":"首先第一部分.我们要注意在平时工作中需要注意哪些地方养成一套流程规范.避免出现已经被总结出来的问题","titles":[]},"857":{"title":"代码","content":"Unity 的垃圾收集（使用   Boehm GC 算法 ）是非分代的，也是非压缩的。“非分代”意味着 GC 在执行每遍收集时必须扫描整个堆，因此随着堆的扩展，其性能会下降。“非压缩”意味着不会为内存中的对象重新分配内存地址来消除对象之间的间隙。上图为内存碎片化示例。释放对象时，将释放其内存。但是，释放的空间  不会 整合成为整个“可用内存”池的一部分。位于释放的对象两侧的对象可能仍在使用中。因此，释放的空间成为其他内存段之间的“间隙”（该间隙由上图中的红色圆圈指示）。因此，新释放的空间仅可用于存储与释放相同大小或更小的对象的数据。分配对象时，请注意对象在内存空间中的分配地址必须始终为连续空间块。这导致了内存碎片化这个核心问题：虽然堆中的可用空间总量可能很大，但是可能其中的部分或全部的可分配空间对象之间存在小的“间隙”。这种情况下，即使可用空间总量高于要分配的空间量，托管堆可能也找不到足够大的连续内存块来满足该分配需求。","titles":["资源检查"]},"858":{"title":"CPU","content":"Unity 不使用字符串名称对 Animator、Material 和 Shader 属性进行内部寻址。为了加快速度，所有属性名称都经过哈希处理为属性 ID，实际上正是这些 ID 用于寻址属性。  Animator.StringToHash  是用于 Animator 属性名称的对应 API，  Shader.PropertyToID  是用于 Material 和 Shader 属性名称的对应 API。  将   RaycastAll  调用替换为   RaycastNonAlloc ，将   SphereCastAll  调用替换为   SphereCastNonAlloc ，以此类推。对于 2D 应用程序，也存在所有 Physics2D 查询 API 的非分配版本。  请避免在紧凑循环中或每帧运行的代码中进行UnityEngine.Object 子类和 Null 比较。Il2cpp中此过程必须执行查找和验证以便将脚本引用转换为对原生代码的引用。  整数数学比浮点数学更快，而浮点数学比矢量、矩阵或四元数运算更快。每当交换或关联算术允许时，请尝试最小化单个数学运算的成本  最好完全避免在生产代码中使用    和   。还有  也使用了  ,由于此类 API 要求 Unity 遍历内存中的所有游戏对象和组件，因此它们会随着项目规模的扩大而产生性能问题。(除了单例,因为有缓存)  在紧凑循环中尽量少用  和  ,调用的每个方法都必须在内存中找到该方法的地址，并将另一个帧推入栈。所有这些操作都是有成本的，但在大多数代码中，它们都小到可以忽略不计.但是，在紧凑循环中运行较小的方法时，因引入额外方法调用而增加的开销可能会变得非常显著，甚至占主导地位。.例如    移除空的MonoBehaviour方法start update awake..理由同上  不要在运行时使用AddComponent将组件添加到GameObjects可能是一项非常昂贵的操作。因为他会先看组件有没有DisallowMultipleComponent的设置,然后又重复上述的检查一次最后还需要调用所有被加入的monobehaviour的awake方法,这些所有步骤都发生在堆内存上  不要使用Texture2D.SetPixels() ,使用Texture2D.SetPixels32() 或者 GetRawTextureData()/Apply() 代替  尽量避免调用Object.Instantiate再经常更新的代码。这里可以使用poolmanager代替","titles":["资源检查","代码"]},"859":{"title":"GPU","content":"meshreander->lighting -> cast shadows关闭阴影投射  尽可能少的light,然后只对特定曾有用  过高的分辨率会造成手机发热..可以使用Screen.SetResolution(width,height,false)  启用GPU实例化,  GPU 实例化 - Unity 手册 (unity3d.com)","titles":["资源检查","代码"]},"860":{"title":"UI","content":"将对象隐藏起来,而不是移动到屏幕外边..因为摄像机依然能看到这些对象,依然会被渲染  如果UI元素改变数值或是位置,会影响批次处理,造成对Gpu发送更多drawcall,所以将更新频率不同的ui分再不同的画布上  同张画布中的ui元素要有一样的z值  ui元素必须拥有一样的材质和纹理  对象拥有一样的clipping rect(矩形裁剪范围)  去掉不需要的Graphic Raycaster,每次当用户点击触发事件时,系统就会遍历所有可能接收输入事件的ui元素,这会造成多次\"点落再矩形中\"检查,来判断对象是否该做出反应  如果打开了全屏ui,把渲染3d场景的摄像机关掉  如果打开了全屏ui,隐藏其他被遮蔽的ui,如果可以,建议你关闭canvas组件,而不是游戏对象本身,这样能减少画布再次出现的时间.禁用canvase组件会阻止画布向Gpu发起绘图调用,所以该画布不再可见,然后,此时该画布不会丢弃它的顶点缓冲区,它会保留所有网格和顶点,当重新启用时,不会触发重构过程,它只会重新绘制画布内容.此外禁用canvas组件不会触发canvas层级上性能消耗较大的ondisable/onenable回调,禁用子组件时要小心,注意它是否运行性能消耗较大的每帧代码.  尽可能的降低帧率,如果有个静态的ui,就没有必要设置帧率到60  如果texture是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw。  使用Empty4Raycast代替空的image  不要使用ugui的outline和shadow,他时把原来的顶点copy多份进行实现的..可以使用shader进行实现  mask会增加一个drawcall,并且mask里面的图片不会和外面的图片合批,  Scroll Rect 组件对应的Content填加 Canvas 组件 ，因为对应的Mask 子元素依然参与全局的Depth排序，避免因拖动打乱原有的Depth排序，造成合批失败  尽量不要使用layout,因为会从变动节点递归向上调用GetComponents","titles":["资源检查","代码"]},"861":{"title":"图集整理","content":"为什么使用图集?图片尺寸为2的次幂时，GPU处理起来会快很多，小图自己是做不到每张图都是2的次幂的，但打成一张大图就可以（浪费一点也无所谓）；  CPU在传送资源信息给GPU时，只需要传一张大图就可以了，因为GPU可以在这张图中的不同区域进行采样，然后拼出对应的界面。注意，这就是为什么需要用同一个Source Image图集的原因，是Batch的关键，因为一个Drawcall就把所有原材料传过去了，GPU你画去吧但是显然把所有图片打成一张图集是不合理的，因为这张图可能非常大，所以就要按照一定规则将图片进行分类。在分类思路上，我们希望做到Drawcall尽可能少，同时资源量也尽可能少（多些重用），但这两者某种程度上是互斥的，所以折衷一下，可以遵循以下思路：设计UI时要考虑重用性，如一些边框、按钮等，这些作为共享资源，放在1~3张大图集中，称为  重用图集 ；  其它非重用UI按照功能模块进行划分，每个模块使用1~2张图集，为  功能图集 ；  对于一些UI，如果同时用到  功能图集 与  重用图集 ，但是其  功能图集 剩下的“空位”较多，则可以考虑将用到的  重用图集 中的元素单独拎出来，合入  功能图集 中，从而做到让UI只依赖于  功能图集 。也就是通过一定的冗余，来达到性能的提升。","titles":["资源检查","代码","UI"]},"862":{"title":"UGUI层级合并规则与批次生成规则","content":"UGUI的层叠顺序是按照Hierarchy中的顺序从上往下进行的，也就是越靠上的组件，就会被画在越底部。所以UI就是这样一层一层地叠上去画出来的。当然这样一个一个地画效率肯定是不能接受的，所以要合并，要Batch，Unity自身就提供了一个算法去决定哪些层应该合并到一起，并以什么样的顺序进行绘制。  所有相邻层的可Batch的UI元素将会在一个Drawcall完成 。接下来就来讨论一下Unity的层级合并与计算算法。Unity的UI渲染顺序的确定有2个步骤，第一步计算每个UI元素的  层级号 ；第二步合并相同  层级号 中可以Batch的元素作为一个  批次 ，并对  批次 进行排序；先从直观的角度来解释  计算层级号的算法 ：如果有一个UI元素，它所占的屏幕范围内（通常是矩形），  如果没有任何UI在它的底下，那么它的  层级号 就是0（最底下）；  如果有一个UI在其底下且该UI可以和它Batch，那它的  层级号 与底下的UI层级一样；  如果有一个UI在其底下但是无法与它Batch，那它的  层级号 为底下的UI的层级+1；  如果有多个UI都在其下面，那么按前两种方式遍历计算所有的  层级号 ，其中最大的那个作为自己的  层级号 。这里也给一下伪代码，假设所有UI元素（抛弃层级关系）都按从上往下的顺序被装在一个list中，那么每个UI元素对应的  层级号 计算可以参考以下：有了层级号之后，就要  合并批次 了，此时，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个  批次 ，目前已知的排序规则是，Text组件会排在Image组件之前渲染 ，而同一类组件的情况下排序规则未知（好像并没什么规则）。经过以上排序，就可以得到一个有序的批次序列了 。这时，  Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch 。举个栗子，一个层级为0的ImageA，一个层级为1的ImageB（2个Image可Batch）和一个层级为0的TextC，Unity排序后的批次为TextC->ImageA->ImageB，后两个批次可以合并，所以是2个Drawcall。再举个栗子，一个层级为0的TextD，一个层级为1的TextE（2个Text可Batch）和一个层级为0的ImageF，Unity排序后的批次为TextD->ImageF->TextE，这时就需要3个Drawcall了！（是不是有点晕，再回顾下黑体字）以下的伪代码有些偷懒，实在懒得写排序、合并之类的，一长串也不好读，几个步骤列一下，其它诸位看上面那段文字脑补下吧...根据以上规则，就可以得出一些“摆UI”的技巧：有相同材质和纹理的UI元素是可以Batch的，可以Batch的UI上下叠在一块不会影响性能，但是如果不能Batch的UI元素叠在一块，就会增加Drawcall开销。  要注意UI元素间的层叠关系，建议用“T”工具查看其矩形大小，因为有些图片透明，但是却叠在其它UI上面了，然后又无法Batch的话，就会无故多许多Drawcall；  UI中出现最多的就是Image与Text组件，当Text叠在Image上面（如Button)，然后Text上又叠了一个图片时，就会至少多2个Drawcall，可以考虑将字体直接印在下面的图片上；  有些情况可以考虑人为增加层级从而减少Drawcall，比如一个Text的层级为0，另一个可Batch的Text叠在一个图片A上，层级为1，那此时2个Text因为层级不同会安排2个Drawcall，但如果在第一个Text下放一个透明的图片（与图片A可Batch），那两个Text的层级就一致了，Drawcall就可以减少一个。","titles":["资源检查","代码","UI"]},"863":{"title":"UI优化参考","content":"Unity GUI(uGUI)使用心得与性能总结 - 简书 (jianshu.com)   Some of the best optimization tips for Unity UI - Unity (unity3d.com)","titles":["资源检查","代码","UI"]},"864":{"title":"内存","content":"不要再update中重复实例化对象,使用了ecs同样注意,因为他也是执行在update中  不要使用闭包和匿名方法,因为闭包和匿名方法都会都是引用类型(c#将生成一个匿名类)会在堆上进行分配  避免装箱..虽然 Unity 的分配器实际会使用不同的内存池进行小型和大型分配，但 Unity 的垃圾回收器“不是”分代的，因此无法有效清除由装箱生成的小型、频繁的临时分配。  不要用foreach, Unity 的 C# 编译器生成的 IL 会构造一个通用值类型的枚举器来遍历值集合,而且通过枚举器遍历集合的方法调用成本更高，通常比通过    或    循环进行的手动迭代慢得多。  unityapi.. mesh.vertices和 Input.touches,每次访问    这些属性时都会发生分配。所以不要在循环和update中使用  避免使用  ,  ,而是使用GetComponentsInChildren(bool includeInactive, List result);前者会分配托管内存,后者可以传入一个你保存的数组避免重新分配  不要使用linq因为会分配大量的托管内存  不要使用Texture2D.GetPixels() ,使用  代替此方法返回像素数据的NativeArray,前者会有大量的托管内存参考 :了解托管堆 - Unity 手册 (unity3d.com)   了解自动内存管理 - Unity 手册 (unity3d.com)   一般优化 - Unity 手册 (unity3d.com)   Unite Now - （中文字幕）性能优化技巧（上）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili","titles":["资源检查","代码"]},"865":{"title":"资源","content":"","titles":["资源检查"]},"866":{"title":"Animation","content":"动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度Custom Parameters: precision : 5  用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调小。  场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。","titles":["资源检查","资源"]},"867":{"title":"Audio","content":"如果不需要立体声,将音频文件设置为 Force To Mono,这样能省下一半的磁盘和内存  降低文件比特率  ios下使用adpcm和mp3格式  安卓下使用vorbis格式  如果小型文件<200kb,load type设置成Decompress on Load,  如果中型文件>=200kb,load type 设置成Compressed in Memory  大型文件,如背景音乐,load type设置成streaming  如果时静音模式则销毁audiosourceComponent组件,如果设置成0的话,其实还是会造成不必要的内存与cpu占用","titles":["资源检查","资源"]},"868":{"title":"EditorSetting","content":"禁用 Accelerometer Frequency 陀螺仪  尝试开启graphicJobs并测试 检查Editor -> Project Settings -> PlayerSettings -> Graphic Jobs(Experimental)*的设置  如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项 检查Editor -> Project Settings -> PlayerSettings -> PreBake Collision Meshes的设置,这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积  在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上,这会增加CPU的负担, 应该取消勾选那些没有必要的格子 检查Editor -> Project Settings -> Physics -> Layer Collision Matrix的设置  在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上 同上  检查Graphics中StandardShaderQuality设置,这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备,检查Editor -> Project Settings -> Graphics -> Tiers -> Standard Shader Quality的设置,StandardShaderQuality选项在所有Graphics Tier中应相同  检查Android的ManagedStrippingLevel设置 检查Editor -> Project Settings -> PlayerSettings -> Managed Stripping Level的设置,Android设置中的ManagedStrippingLevel选项应为Medium或者High","titles":["资源检查","资源"]},"869":{"title":"Mesh","content":"开启mesh compression,来减少磁盘容量  尽量关闭read/write enabled 选项,如果开启unity会存储两份mesh  如果没有使用动画,关闭Rigs,如石头或者房子  如果没有用到Blendshapes,ye关闭  Normals and Tangents..法向量和切线信息,如果材质没用到.也关闭","titles":["资源检查","资源"]},"870":{"title":"Prefab","content":"","titles":["资源检查","资源"]},"871":{"title":"Scene","content":"","titles":["资源检查","资源"]},"872":{"title":"Texture","content":"导入大小需要设置maxsize和compression,否则将导致文件过大.打包的时候会占体积max size 尽可能的设置到最小  pot(大小为2的幂次方) or atlas  移除背景纹理和其他不透明纹理的alpha通道  关闭read/write,以减少内存使用  如果16bit color足够用了就不要使用 32bit  如果不需要使用mipmaps 则禁用,例如 ui和sprites,或者相对于z值不会又任何变化的元素","titles":["资源检查","资源"]},"873":{"title":"Resources文件夹","content":"尽量不要使用resources文件夹.它会打包到包体中.且在启动时会全部加载..","titles":["资源检查","资源"]},"874":{"title":"AssetBundle","content":"资源包冗余检测","titles":["资源检查"]},"875":{"title":"工具检测","content":"","titles":[]},"876":{"title":"DrawCall","content":"一、什么是DrawCall？​    在unity中，每次CPU准备数据并通知GPU的过程就称之为一个DrawCall。​    具体过程就是：设置颜色-->绘图方式-->顶点坐标-->绘制-->结束，所以在绘制过程中，如果能在一次DrawCall完成所有绘制就会大大提高运行效率，进而达到优化的目的。二、DrawCall为什么会影响游戏运行效率？说道为什么会影响效率，就首先要了解一下他的工作原理：为了CPU和GPU可以进行并行工作，就需要一个命令缓冲区，就是由CPU向其中添加命令，然后又GPU从中读取命令，这样就实现了通过CPU准备数据，通知GPU进行渲染。在每次调用DrawCall之前，CPU需要向GPU发送很多内容，主要是包括数据，渲染状态（就是设置对象需要的材质纹理等），命令等。CPU进行的操作具体就是：准备渲染对象，然后将渲染对象从硬盘加载到内存，然后从内存加载到显存，进而方便GPU高速处理  设置每个对象的渲染状态，也就是设置对象的材质、纹理、着色器等  输出渲染图元，然后向GPU发送DrawCall命令，并将渲染图元传递给GPU所以如果DrawCall数量过多就会导致CPU进行大量计算，进而导致CPU的过载，影响游戏运行效率。三、批处理批处理的目的就是为了减少DrawCall。DrawCall即CPU命令GPU去绘制。  如果我们需要渲染一千个三角形，那么把它们按一千个单独的网格进行渲染所花费的时间要远大于直接渲染一个包含了一千个三角形的网格。  要想使用批处理，需要物体有相同的材质。这是因为，对于使用同一个材质的物体，它们的不同仅仅在于顶点数据的差别，我们可以把这些顶点数据合并在一起，再一起发送给GPU，就可以完成一次批处理。  在unity中，有两种批处理：一是动态批处理，二是静态批处理。对于动态批处理，unity会自动完成，不需要我们进行操作，而且物体是可以移动的，但是动态批处理有许多限制条件。\n对于静态批处理，物体不可移动，但是限制条件很少。四、动态批处理原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给GPU，然后使用同一个材质对其渲染。限制：顶点属性要小于900。例如，如果shader中需要使用顶点位置、法线和纹理坐标这三个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。因此，优化策略就是shader的优化，少使用顶点属性，或者模型顶点数要尽可能少。  多Pass的shader会中断批处理。  在unity5中，动态批处理对于模型缩放的限制已经不存在了。  使用光照纹理的物体需要小心处理。为了让这些物体可以被动态批处理，需要保证它们指向光照纹理中的同一位置。五、静态批处理原理：只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格中，这意味着这些模型数据不可以在运行时刻被移动。优点：因为它只需要进行一次合并操作，因此比动态批处理更加高效。缺点：需要占用更多的内存来存储合并后的几何结构。操作：将Inspector面板右上角的Static勾选(实际上只需要勾选Batching Static即可)参考链接:动态合批原理及如何成功合批 - Unity Connect","titles":["工具检测"]},"877":{"title":"渲染统计窗口","content":"Batches：相当于DrawCallSaved by batching：通过批处理节省的DrawCallSetPass calls：跟Shader中Pass的数量有关，Pass越多这个越大...它大致代表的是摄像机照射范围内，所有GameObject所包含的Material种类数量。（不完全准确，但是这样说易于理解）。假如有30种material，那这个SetpassCall的数值也会离这个30比较接近。这个值越大，肯定会使draw call 越来越大。影响DrawCall的因素：Pass越多DrawCall越大。可以通过FrameDebugger来查看DrawCall，当然也可以用Profiler，但后者不能查看DrawCall的具体情况。  不同材质的物体，无法通过静态批处理减少DC。但是静态批处理可以通过合并网格来提高性能。","titles":["工具检测"]},"878":{"title":"Unity Profiler","content":"在面板的下半部分显示了我们选中的profilers当前帧的详细内容，我们可以通过选择列标题，通过这一列的信息值来排序。\n在CPU usage profiler中的列表题分别为：\nTotal:当前任务的时间消耗占当前帧cpu消耗的时间比例。\nSelf:任务自身时间消耗占当前帧cpu消耗的时间比例。\nCalls:当前任务在当前帧内被调用的次数。\nGC Alloc:当前任务在当前帧内进行过内存回收和分配的次数。     注意每帧都具有20B以上内存分配的选项 。 \nTime ms:当前任务在当前帧内的耗时总时间。     注意占用5ms以上的选项 \nSelf ms:当前任务自身(不包含内部的子任务)时间消耗。在 Unity 的 CPU 性能分析器中，Overview 表有一个“GC Alloc”列。此列显示了在特定帧中的托管堆上分配的字节数(4)（__注意：__这与给定帧期间临时分配的字节数不同。性能分析器会显示特定帧中分配的字节数，不考虑在后续帧中是否重用了部分/全部已分配的内存）。启用“Deep Profiling”选项后，可以跟踪执行这些分配的方法。**Unity Profiler 不会跟踪在主线程之外发生的分配。**因此，“GC Alloc”列不能用于统计用户创建的线程中发生的托管分配。请将代码执行从单独线程切换到主线程以进行调试，或使用   BeginThreadProfiling  API 在时间轴性能分析器 (Timeline Profiler) 中显示例程。","titles":["工具检测"]},"879":{"title":"堆与栈：有什么不同？","content":"栈 ，或多或少负责跟踪正在程序中运行的代码。堆 ，或多或少负责跟踪程序对象或数据。栈，把它想像成叠在一起的盒子(像搭积木一样)。每一次调用一个方法就会在最上面叠一个盒子，用来跟踪程序运行情况。我们只能使用栈中叠在最上面的盒子里的东西。当某一最上面的盒子里的代码执行完毕（如方法执行完成），就把它扔掉并继续去使用下一个盒子。堆，与栈类似，只是它是用来保存信息而不是跟踪执行。所以，堆里的任何信息都可以在任何时间被访问。有了堆，访问信息没有约束，而不像栈只能访问最上面的盒子。堆的情况就像你把一堆刚洗完的衣服放在床上还没有时间来的及收走，你可以迅速拿到你想要拿的衣服。栈的情况就像你叠在一起的鞋盒子，你需要拿走最上面的盒子才能拿到下一个盒子。上图并不上真正的内存运行情况，只是为了让大家区分堆和栈。栈，会自我管理，它有自己的内存管理机制。当最上面的盒子不再使用时，会自动被扔掉。堆，相反，我们要控制它的垃圾回收(GC)。我们要去管理堆是否干净，就像管理床上的脏衣服。你不手动扔掉它，就会在床上变臭。","titles":[]},"880":{"title":"什么在堆和栈里","content":"当程序执行时，我们主要有4种类型的东西放进堆和栈里：值类型，引用类型，指针，指令。","titles":[]},"881":{"title":"值类型:","content":"bool  byte  char  decimal  double  enum  float  int  long  sbyte  short  struct  uint  ulong  ushort它们都衍生于System.ValueType。","titles":["什么在堆和栈里"]},"882":{"title":"引用类型:","content":"class  interface  delegate  object  string它们都衍生于System.Object。当然object就是System.Object。","titles":["什么在堆和栈里"]},"883":{"title":"指针:","content":"第三种被放于内存管理体制中的是类型的引用。这个引用通常被叫作指针。我们并不具体的使用指针，它们由CLR管理。一个指针（引用）是不同于引用类型的。我们定义它是一个引用类型，意味着我们可以通过指针访问它。一个指针占有一小块内存，这块内存指向另一块内存。指针占用在内存中的存储和其它的相同，只是存放的值既不是内存地址也不是空null。","titles":["什么在堆和栈里"]},"884":{"title":"两个黄金规则","content":"引用类型永远存储在堆里。   和  永远存储在它们声明时所在的  或  里。","titles":["什么在堆和栈里"]},"885":{"title":"栈工作原理","content":"栈，如第一节所说，在代码运行时负责跟踪每一个线程的所在(什么被调用了)。你可以把它想像成一个线程“状态”，而每一个线程都有它自己的栈。当我们的代码执行一次方法调用，线程开始执行寄存在方法(Method)表里的JIT编译过的指令，并且把该方法的参数存放到当前线程栈里。然后，随着代码的执行每遇见方法中的变量，该变量都会被放到栈的最上面，如此重复把所有变量都放到栈上(当然引用类型只存放指针)。为了方便理解，让我们看代码与图例。执行下面的方法：下面是栈里发生的情况.  有必要提醒的是，我们现在假设当前代码产生的栈存储会放到所有既有项(栈里已经存储的数据)之上。一旦我们开始执行该方法，方法参数pValue会被放到栈上（以后的文章里会介绍参数传递）。注意：方法并不存在栈里，图只是为了阐述原理而放的引用。下一步，控制(线程执行方法)被传递到寄存在方法类型表里的AddFive()方法对应的指令集中。如果方法是第一次被触发，会执行JIT编译。随着方法的执行，栈会分配一块内存给变量result存放。方法执行完成，返回result。该次任务在栈里所占的所有内存将被清理，仅一个指针被移动到AddFive()开始时所在的可用内存地址上。接着会执行栈里AddFive()下面一个方法（图里看不到）。在这个例子当中，变量result被放到了栈里。事实上，方法体内每次定义的值类型变量都会被放到栈里。","titles":["什么在堆和栈里"]},"886":{"title":"值类型会存储在堆里？","content":"是的，值类型有时候就是会存储在堆里。上一节中介绍的  黄金规则2:值类型和指针永远存储在它们声明时所在的堆或栈里 。如果一个值类型不是在方法中定义的，而是在一个引用类型里，那么此值类型将会被放在这个引用类型里并存储在堆上。","titles":["什么在堆和栈里"]},"887":{"title":"代码图例","content":"我们定义一个引用类型：里面包含一个值类型MyValue。执行下面的方法：就像上一节介绍的一样，线程开始执行此方法，参数pValue将会被放到当前线程栈上。接下来不同于上一节所介绍的是MyInt是一个引用类型，它将被放到堆上并在栈上放一个指针指向它在堆里的存储。当AddFive()执行完成后，如上一节所讲栈开始清理。现在是需要C#垃圾回收GC的时候了。当我们的程序所占内存到达临界值时(即将溢出)，我们会需要更多的堆空间，GC就会开始运行。GC停止所有当前运行线程(整体停止)，找到堆里所有主程序不会访问到的对象并删除它们。然后，GC会识别所有堆里剩下的对象并分配内存空间给它们，同时调整堆和栈里指向它们的指针。你可以想像这是非常耗资源的，这会影响到程序的性能。这就是为什么我们需要理解和注意堆栈的使用，进而写出高性能代码。","titles":["什么在堆和栈里"]},"888":{"title":"堆栈原理对代码的影响","content":"当我们使用引用类型时，我们在和指向引用类型的指针打交道，而不是引用类型本身。当我们使用值类型时，我们就是在和值类型本身打交道。","titles":["什么在堆和栈里"]},"889":{"title":"代码图例","content":"假设执行方法：我们会得到值   3 。使用引用类型：如果执行方法：我们得到的值是４而不是３！（译外话：这是很简单，但相信还是有很多人不知道原理的）第一个示例中：x就是3，y就是4。操作两个不同对象。第二个示例：得到的值是4不是3是因为我们操作栈里两个指针并且它们指向堆里同一个对象。","titles":["什么在堆和栈里","堆栈原理对代码的影响"]},"890":{"title":"参数，大画面","content":"下面是当代码运行时会产生的一个详细过程。上几节已经介绍过当一个方法被调用时会产生的基本情况，让我们来看一下更加详细的内容。当我们调用一个方法时会发生以下情形：栈会分配一块内存空间给程序执行所需要的信息(我们叫它栈结构Stack Frame)。一个栈结构包含方法调用地址(指针)，它以一个GOTO指令的形式存在栈里。因此，当程序执行完方法(method)时，它会知道怎么样返回进而曳继续执行代码。  方法的所有参数将被复制到栈里，这是我们将要更加详细介绍的部分。  控制被传递到JIT编译过的方法里，同时线程开始执行代码。此时，我们将有另一个方法呈现在栈结构的“回调栈”里。栈像下图所示：注意：ReturnValue方法不会存在栈上，图中把ReturnValue作为此栈结构的开始只是为了解释栈原理。像前几节介绍的，值类型和引用类型在栈里的存储是不同的。栈为任何值类型创建副本，栈也为任何引用类型的指针创建副本。","titles":["什么在堆和栈里"]},"891":{"title":"值类型传递","content":"下面是值类型传递在栈里的内幕。首先，当我们传递一个值类型变量时，栈会为它分配一块内存空间并把值类型变量的值存储进去。看下面的代码：当代码执行时，栈为x分配一块内存空间并存储值5然后，AddFive()被放到栈上，同时栈分配内存空间给参数pValue并复制x的值给它。当AddFive()执行完成，线程被传递回Go()。同时因为AddFive()执行完，它的参数pValue也实质上被移除。所以结果是5是合理的。关键点是任何被传递的值类型参数仅是一个碳复制，因为我们希望保护原始变量的值。有一点要记住的是，如果我们有一个非常庞大的值类型(如，庞大的struct类型)传递到栈里，当处理器循环复制它并循环占有栈空间时将会非常耗资源。栈没有无限的空间去使用，就像用水杯不断的接水早晚会溢出一样。Struct类型可以变得非常庞大，我们要小心并清醒的使用它。下面是一个比较大的struct结构类型：让我们看看执行下面代码Go()方法时再到DoSomething()方法会发生的情况：这可能会非常低效。想像一下如果我们传递MyStruct几千次，它会怎么样让程序死掉。那么，我们怎么才能回避这样的问题呢？那就是仅传递原始值类型的引用。这样就能节省内存并提升内存使用效率唯一需要注意的是传递引用时我们在访问原始变量x的值，任可对pValue的改变都会影响到x。下面的代码会将x改变成\"12345\"，因为pValue.a实际上指向原始x声明时所在的内存地址。","titles":["什么在堆和栈里"]},"892":{"title":"引用类型传递","content":"传递引用类型跟上一节所示例中用引用的方式传递值类型相似。如果使用引用类型（原文可能笔误，写的是值类型）：然后调用Go()方法，MyInt会被放到堆里因为它是一个引用类型。如果执行下面代码中的Go()：会发生这种情况：开始调用Go()，栈分配一块内存空间给x。  执行行到DoSomething()，栈分配一块内在空间给pValue。  x的值是堆中MyInt对应在栈里的内存地址，复制x给pValue。因此，我们用pValue改变MyInt的MyValue的值时，x最终也会获得这个改变的值\"12345“。如果我们用引用的方式传递一个引用类型变量呢？","titles":["什么在堆和栈里"]},"893":{"title":"用引用的方式传递引用类型","content":"我们有一个类Thing, 类Animal和Vegetables衍生于Thing：执行下面的Go()方法：x最终变成Vegetable。打印结果：让我们看看堆栈里到底发生了什么情况调用Go()方法，栈分配一块内存空间给x。  堆分配一块内存空间给Animal。  开始执行Switcharoo()方法，栈分配一块内存空间给pValue并指向x。    栈分配一块内存空间给Vegetable。  pValue改变了x的值使其指向Vegetable的内在地址。如果我们不是用ref传递的，打印结果正相反。","titles":["什么在堆和栈里"]},"894":{"title":"复制不仅仅是复制","content":"为了更清晰的阐述这个问题，让我们测试一下在堆中存储值类型变量和引用类型变量时会产生的不同情况。","titles":["什么在堆和栈里"]},"895":{"title":"值类型测试","content":"首先，我们看一下值类型。下面是一个类和一个结构类型(值类型)，Dude类包含一个Name元素和两个Shoe元素。我们有一个CopyDude()方法用来复制生成新Dude。Dude类是一个复杂类型，因为值 类型结构Shoe是它的成员， 它们都将存储在堆中。当我们执行下面的方法时：我们得到了期望的结果：如果我们把Shoe换成引用类型呢？","titles":["什么在堆和栈里","复制不仅仅是复制"]},"896":{"title":"引用类型测试","content":"当我们把Shoe改成引用类型时，问题就产生了。执行同样上面的Main()方法，结果改变了，如下：这并不是我们期望的结果。很明显，出错了！看下面的图解：因为现在Shoe是引用类型而不是值类型，当我们进行复制时仅是复制了指针，我们并没有复制指针真正对应的对象。这就需要我们做一些额外的工作使引用类型Shoe像值类型一样工作。很幸运，我们有一个接口可以帮我们实现：ICloneable。当Dude类实现它时，我们会声明一个Clone()方法用来产生新的Dude复制类。（译外话：复制类及其成员跟原始类不产生任何重叠，即我们所说的深复制)  看下面代码：\nICloneable consists of one method: Clone()Here's how we'll implement it in the Shoe class:在Clone()方法里，我们创建了一个新的Shoe，克隆所有引用类型变量，复制所有值类型变量，最后返回新的对象Shoe。有些既有类已经实现了ICloneable，我们直接使用即可，如String。因此，我们直接使用Color.Clone()。因为Clone()返回object对象，我们需要进行一下类型转换。下一步，我们在CopyDude()方法里，用克隆Clone()代替复制：再次执行主方法Main()：我们得到了期望的结果：下面是图解：","titles":["什么在堆和栈里","复制不仅仅是复制"]},"897":{"title":"整理我们的代码","content":"在实践中，我们是希望克隆引用类型并复制值类型的。这会让你回避很多不易察觉的错误，就像上面演示的一样。这种错误有时不易被调试出来，会让你很头疼。因此，为了减轻头疼，让我们更进一步清理上面的代码。我们让Dude类实现IConeable代替使用CopyDude()方法：在主方法Main()使用Dude.Clone()：最后得到期望的结果：","titles":["什么在堆和栈里","复制不仅仅是复制"]},"898":{"title":"特殊引用类型String","content":"在C#中有趣的是，当System.String 使用操作符“=”时，实际上是进行了克隆(深复制)。你不必担心你只是在操作一个指针，它会在内存中创建一个新的对象。但是，你一定要注意内存的占用问题(  译外话：比如为什么在一定情况下我们使用StringBuilder代替String+String+String+String...前者速度稍慢初始化耗多点内存但在大字符串操作上节省内存，后者速度稍快初始化简单但在大字符串操作上耗内存 )。如果我们回头去看上面的图解中，你会发现Stirng类型在图中并不是一个针指向另一个内存对象，而是为了尽可能的简单，把它当成值类型来演示了。绘图Graphing让我们站在GC的角度研究一下。如果我们负责“扔垃圾”，我们需要制定一个有效的“扔垃圾”计划。显然，我们需要判断哪些是垃圾，哪些不是。为了决定哪些需要保留，我们假设任何没有正在被使用的东西都是垃圾（如角落里堆积的破旧纸张，阁楼里一箱箱没有用的过时产品,柜子里不用的衣服）。想像一下我们跟两个好朋友生活在一起：JIT 和CLR。  JIT和CLR 不断的跟踪他们正在使用的东西，并给我们一个他们需要保留的东西列表。这个初始列表我们叫它“根(root)”列表。因为我们用它做起点。我们将保持一个主列表去绘制一张图，图中分布着所有我们在房子中需要保留东西。任何与主列表中有关联的东西也被画入图中。如，我们保留电视就不要扔掉电视遥控器，所以电视遥控器也会被画入图中。我们保留电脑就不能扔掉显示器键盘鼠标，同样也把它们画入图中。这就是GC怎么决定去保留对象的。  GC会保留从JIT和CLR那收到的一个根(root)对象引用列表，然后递归搜索对象引用并决定什么需要保留。这个根的构成如下：全局/静态 指针。通过以静态变量的方式保持对象的引用，来确保对象不会被GC回收。  栈里的指针。为了程序的执行，我们不想扔掉那些程序线程始终需要的对象。  CPU寄存器指针。托管堆里任何被CPU内存地址指向的对象都需要被保留。在上面的图中，托管堆中的对象1，5被根Roots引用，3被1引用。对象1，5是被直接引用，3是通过递归查询找到。如果关联到我们之前的假设，对象1是我们的电视，对象3则是电视遥控器。当所有对象画完后，我们开始进行下一阶段：垃圾清理。GC垃圾清理Compacting现在我们有了一张需要保留对象的关系图，接下来进行GC的清理。\n  \n图中对象2和4被认定为垃圾将被清理。清理对象2，复制（memcpy ）对象3到2的位置。\n  \n由于对象3的地址变了，GC需要修复指针（红色箭头）。然后清理对象4，复制（memcpy ）对象5到原来3的位置（译外话：GC原则：堆中对象之间是没有间隙的，以后会有文章专门介绍GC原理）。\n   \n最后清理完毕，新对象将被放到对象5的上面(译外话：GC对一直管理一个指针指向新对象将被放置的地址，如黄色箭头，以后会有文章专门介绍)。了解GC原理可以帮助我们理解GC清理(复制memcpy ，指针修复等)是怎么消耗掉很多资源的。很明显，减少托管堆里对象的移动（复制memcpy ）可以提高GC清理的效率。托管堆之外的终止化队列Finalization Queue和终止化-可达队列Freachable Queue有些情况下，GC需要执行特定代码去清理非托管资源，如文件操作，数据库连接，网络连接等。一种可行性方案是使用析构函数（终结器）：\n  \n译外话：析构函数会被内部转换成终结器override Finializer()有终结器的对象在创建时，同时在Finalization Queue里创建指向它们的指针（更正原文说的把对象放到Finalization Queue里）：上图对象1,4,5实现了终结器，因此在Finalization Queue里创建指向它们的指针。让我们看一下，当对象2和4没有被程序引用要被GC清理时会发生什么情况。\n对象2会被以常规模式清理掉(见文章开始部分)。GC发现对象4有终结器，则会把Finalization Queue里指向它的指针移到Freachable Queue中，如下图：\n  \n但是对象4并不被清理掉。有一个专门处理Freachable Queue的线程，当它处理完对象4在Freachable Queue里的指针后，会把它移除。这时对象4可以被清理了。当下次GC清理时会把它移除掉。换句话说，至少执行两次GC清理才能把对象4清理掉，显然会影响程序性能。创建终结器，意味着创建了更多的工作给GC，也就会消耗更多资源影响程序性能。因此，当你使用终结器时一定要确保你确实需要使用它。\n更好的方法是使用IDisposable接口。实现IDisposable接口的对象可以使用using关键字：\n  \n变量rec的作用域是大括号内，大括号外不可访问。静态变量如果你初始化了TryoutRunners，那么它将永远不会被GC清理，因为有静态指针一直指向初始化的对象。一旦调用了Runner里GetStats()方法，因为GetStats()里面没有文件关闭操作，它将永远被打开也不会被GC清理。我们可以看到程序的崩溃即将来临。","titles":["什么在堆和栈里","复制不仅仅是复制"]},"899":{"title":"参考","content":"C# Heap(ing) Vs Stack(ing) In .NET - Part One (c-sharpcorner.com)   C# Heap(ing) Vs Stack(ing) In .NET - Part Two (c-sharpcorner.com)   C# Heap(ing) Vs Stack(ing) In .NET - Part Three (c-sharpcorner.com)   C# Heap(ing) Vs Stack(ing) In .NET - Part Four (c-sharpcorner.com)   Unite Now - （中文字幕）性能优化技巧（上）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili","titles":[]},"900":{"title":"Addressables.InitializeAsync","content":"初始化并填充Addressables.ResourceLocators","titles":[]},"901":{"title":"IResourceLocator","content":"资源目录,可以通过 代码加载额外的locator存储了一个IResourceLocation列表..根据不同的key(label,path)进行存储比如: 有个资源是ui.prefab,同时又lable  ,  可能就会有三个IResourceLocationenter为key的IResourceLocation  main为key的IResourceLocation   为key的IResourceLocation","titles":[]},"902":{"title":"IResourceLocation","content":"","titles":[]},"903":{"title":"MergeMode","content":"MergeMode 是什么呢？翻译过来是合并模式。会去先查询每一个地址/标签对应的资源，然后再根据MergeMode进行最终结果的计算。举个栗子：比如传入的参数是  ，根据cube查询出来的资源有A、B、D，根据red查询出来的资源有C、D、E。那么MergeMode是Node或UseFirst时，会取第一个key查询到的资源：A、B、D；MergeMode是Union时，会取所有key查询到的资源的  并集 ：A、B、C、D、E；MergeMode是Intersection时，会取所有key查询到的资源的  交集 ：D。Addressables.LoadAsset(s)Async | Addressables | 1.15.1 (unity3d.com)","titles":["IResourceLocation"]},"904":{"title":"ECS核心概念","content":"这个图中，System读取了多个实体的  和  组件，然后经过计算处理，将结果更新到  组件中。从图中你可以看到，实体A和B还有Renderer组件，但是C并没有。不过这并不会影响System的计算逻辑，因为这个系统不关心  组件。","titles":[]},"905":{"title":"原型 Archetypes","content":"多个组件的组合叫做一个原型。比如一个3D物体可能会包含用于transform的组件，包括移动、旋转、渲染，每个3D物体对应一个实体，但是他们都有同样的组件，所以ECS会把他们分类成是一类原型。在上图中，实体A和B的原型都是M，实体C的原型是N。你也可以通过在运行时添加或者移除component来改变一个实体的原型。例如：如果将实体B的Renderer组件移除，实体B的原型就会变成N。一个实体的原型是什么，决定了ECS会将实体的components也就是数据存在什么地方。  ECS按块分配内存，每块用一个  对象表示。一个块只包含一种原型，可以包含的多个实体的数据。如果一个块的内存满了，ECS会分配一个新的块来存储新的实体的components。如果你修改了实体的组件，那就相当于修改了实体的原型，这时候ECS会将实体的组件数据移到另外一个块中。原型和内存块的关系是一对多的关系。这就意味着，如果想查询给定的一组component类型的所有实体，只需要在这些原型中搜索即可。这样会比在所有的实体中查找效率高很多。ECS在存储实体到内存块中没有特殊的排序，当创建一个实体或者实体的原型发生变化时，ECS会将它放到对应原型的第一个还有空间的内存块中。内存块中的数据会紧密排列。如果一个实体要被移出当前原型的内存块，这时候会有个空位，ECS会把这个内存块最后的实体数据移动到这个空位中。注意 ：原型中的  共享组件 （后面会具体说这是个什么东东）的数据也会影响实体会被存在哪个内存块。同一个内存块中的所有实体的共享组件中的数据值都是相同的。如果你修改了共享组件中的数据，这个实体会被移到另外一个块中，有点类似修改了实体的原型。将共享组件的实体分到一个内存块中会提高处理他们的速度。比如Hybird Renderer（混合渲染）定义了RenderMesh组件来达成这个目的。","titles":["ECS核心概念"]},"906":{"title":"实体 Entity","content":"在代码层面，你就可以了解到，实体非常非常的简单。它的核心部分：Index表示这个实体的ID，和身份证一样用于实体与实体之间区分。Version用于描述这个实体的生命周期，由于实体是可以重用的，那么就需要用Version来区分这个Entity是新生实体，还是即将销毁的实体。ECS中有一个  类来管理一个World中的所有实体。  使用列表维护所有实体以及和实体关联的数据，以便达到最优的性能。虽然entity没有类型，但是可以根据entity关联的component将他们分组，也就是上一节讲的实体原型（EntityArchetype），EntityManager会持续跟踪这些实体原型。你可以使用已有的  来创建entity，也可以提前创建  ，以便后面的使用。","titles":["ECS核心概念"]},"907":{"title":"创建Entity","content":"通过以下方法可以一次创建一个Entity：使用ComponentType的数组来创建一个entity使用EntityArchetype来创建一个entity通过  复制一个已有的entity，包括它里面的数据也可以创建一个空的Entity，在需要的时候在加上components。(您可以立即添加组件，也可以根据需要添加其他组件。)你也可以通过下面的方法一次创建多个Entity：使用  方法一次性填充多个新的Entity到一个NativeArry中，这些entity用同样的原型使用  方法一次性复制多个entity，包含数据显式创建使用指定数量的实体填充的块，并使用CreateChunk创建给定原型","titles":["ECS核心概念","实体 Entity"]},"908":{"title":"添加/删除 component","content":"创建完Entity后，你可以添加或者移除component。注意添加或移除component时，entity的原型会发生变化，这时候EntityManager需要将entity移到其他内存块，并将当前内存块的空位补上。对实体的更改导致结构性更改-会造成Entity原型变化的操作不能在Job里面执行，比如添加移除component、修改  中的值、销毁entity。你可以将前面说的这几种操作放进  中，在job执行完成后执行这个command buffer。后面还会具体讲解CommandBuffer。EntityManager也提供了方法用来添加、移除单个entity中的组件，也可以移除一个entity的NativeArray中的组件。后面组件部分会详细说明。","titles":["ECS核心概念","实体 Entity"]},"909":{"title":"访问实体数据","content":"遍历实体和组件最有效的方式时在一个并行化的Job中按顺序处理组件 . 这利用了CPU的多核性能，并避免CPU的缓存丢失ECS API提供了多种遍历的方式，每个都有自己的性能影响和限制. 下面是方法:","titles":["ECS核心概念","实体 Entity"]},"910":{"title":"SystemBase.Entities.ForEach","content":"使用一个job结构来有效的遍历实体.实体查询— 一个实体必须具有所有这些组件类型 (除了在lambda参数列表中找到所有组件类型之外)    — 一个实体必须有一个或多个这样的组件类型.注意，允许使用WithAny指定单个组件类型;但是，由于实体必须有一个或多个这样的“可选”组件类型供查询选择，因此使用带有单个类型的WithAny等同于将该类型放在WithAll语句中。    — 实体不能具有任何这些组件类型    — 只选择子上次   JobComponentSystem  更新以来，特性组件发生变化的实体    — 只选择拥有特定值的share component的块    — 把Entities.ForEach生成的   EntityQuery  对象存储在一个 EntityQuery 字段里. 您可以使用这个EntityQuery对象用于获取符合条件的实体的数量.注意，这个函数在创建JobComponentSystem时将EntityQuery实例分配给您的字段. 这意味着您可以在第一次执行lambda函数之前使用查询。不要使用WithAny<T、U>或WithNone向查询添加参数列表中的组件。所有添加到lambda函数参数列表中的组件都会自动添加到实体查询的WithAll列表中;向WithAll列表和WithAny或WithNone列表添加组件会创建一个不合逻辑的查询。","titles":["ECS核心概念","实体 Entity","访问实体数据"]},"911":{"title":"IJobChunk","content":"遍历所有符合条件的内存块(called a   Chunk )，其中包含的是符合条件的实体 . Job Execute() 方法可以用for循环遍历所有的块中的元素，你可以使用 IJobChunk 来执行比 IJobForEach更复杂的操作,同时保持最高效率.","titles":["ECS核心概念","实体 Entity","访问实体数据"]},"912":{"title":"Manual iteration","content":"如果以前的方法不足, 您可以手动遍历实体或块.例如，您可以获得一个包含实体的  ，或者您想要处理的实体的块，使用Job(比如  )对它们进行遍历。EntityQuery  类提供了一个构造一个你数据的视图方法，这个视图仅仅包含你算法或者程序中需要的特定的数据. 上面列表中的许多遍历方法都使用EntityQuery，无论是显式的还是内部的。就是可以通过   EntityQuery  来只遍历符合条件的实体或组件","titles":["ECS核心概念","实体 Entity","访问实体数据"]},"913":{"title":"系统 System","content":"","titles":["ECS核心概念"]},"914":{"title":"DisableAutoCreation","content":"如果只是单纯的createsystem,不会执行  ,  ,  ..但是会执行  ,     且 Entities.ForEach中的query有结果才会执行  ,  ,所以可以使用  ,但不  添加到循环列表中,把一个system当作工具类使用","titles":["ECS核心概念","系统 System"]},"915":{"title":"实体查询","content":"一个System根据什么来决定处理哪些实体呢？这时候会用到一个叫实体查询(Entity Query)的东西。实体查询首先需要一些组件类型，然后根据你传入的组件类型的组合，在包含这些组件的原型中查询符合要求的实体。查询时可以指定下面三种类型：All  必须包含All中所有的组件类型   Any  必须包含Any中至少一个组件类型   None  不能包含None中任意一个组件类型一次实体查询的结果会返回所有符合查询要求的内存块，你可以使用  来迭代遍历所有的组件","titles":["ECS核心概念","系统 System"]},"916":{"title":"Jobs 作业","content":"之前说过，ECS配合Job使用才能发挥多线程的威力。ECS提供了  类，其中包含  方法，还包含了  的  和  方法，可以在子线程中处理数据。  是最简单的方法，只需要几行代码就能实现。  可以用来处理比较复杂的情况。ECS会在主线程调度Job，根据System的顺序。当job调度后，ECS会追踪哪些job在读写哪些组件。需要读权限的job需要等待前面写权限的job执行完，反之亦然。Job调度器会使用job依赖来决定哪些job可以并行，哪些必须串行。","titles":["ECS核心概念","系统 System"]},"917":{"title":"System的组织","content":"ECS通过  和  来组织system。默认情况下，ECS会创建一个默认的World，包含一些预定义的group组。它会找到工程中所有的System，实例化他们，并添加到预定义的group中。你可以指定同一个group中system的Update的执行顺序。Group也是一种system，所以你可以将一个group添加到另外一个group中。如果你没有指定顺序，system的执行顺序会不太确定，并不会按照它们创建的顺序。不过，同一个group中的所有system都会比下一个group中的system先执行。System的Update是在主线程中执行的，不过可以使用Job将工作分配到子线程中。","titles":["ECS核心概念","系统 System"]},"918":{"title":"组件 Component","content":"","titles":["ECS核心概念"]},"919":{"title":"相关链接","content":"Entity Component System 官方文档   DOTS从原理到应用   Unity DOTS技术详解   Unity ECS简单示例   Unity中的ECS编程   Unity ECS_翻译","titles":[]},"920":{"title":"创建Job","content":"创建Job需要定义一个结构体，实现  接口。实现了  接口之后，就可以让这个Job和其他Job并行运行了。到这呢，就可以给Job一个真正的定义了：Job是一个统称，任何实现了  接口的结构体，都可以成为一个Job。创建Job的步骤如下：\n1、创建一个实现  接口的结构体\n2、给结构体添加所需的成员变量，可以使用blittable类型或者NativeContainer类型。\n3、在结构体中添加一个Execute方法，具体执行的任务在这个方法里实现。当执行Job时，Execute方法会在一个内核上执行完毕。注意：设计job时，记住job操作的是数据的拷贝，除非使用  。所以，在主线程访问job数据的唯一方法就是写入  。实例代码如下：","titles":[]},"921":{"title":"调度Job","content":"创建Job后，如何执行一个Job呢？这时候需要调度Job，调度Job的步骤如下：\n1、实例化Job\n2、构造Job的数据\n3、调用  方法。调用  方法会将Job放到Job执行队列的适当位置。一旦安排了Job后，就不能再中断job执行了。注意 ：只能在主线程中调用  方法。","titles":[]},"922":{"title":"Job的依赖关系","content":"很多时候，Job并不是独立运行的，需要依赖前一个Job的结果，这时候如何调度呢？","titles":[]},"923":{"title":"JobHandle","content":"当调用  方法时，会返回一个  。你可以使用这个  作为其他job的依赖项。具体方法就是将第一个job的  传给第二个job调用  时的参数，例如：那如果一个job有多个依赖项怎么办呢？这时候可以用  方法合并他们。具体如下：","titles":["Job的依赖关系"]},"924":{"title":"等待Job执行完毕","content":"在主线程中如何等待Job执行完毕呢？可以调用  中的  方法强制等待。  方法执行过后，你就可以在主线程中安全地访问job中使用的  了。注意 \n当你调用job的Schedule方法后，job并不会立即开始执行。如果你在主线程中等待job执行完毕，并且你需要访问job使用的NativeContainer中的数据时，你可以调用  方法。这个方法会启动job的执行。调用JobHandle的Complete方法后，会将job的NativeContainer所有权还给主线程。所以只有调用过JobHandle上的Complete方法后，主线程才能安全的访问NativeContainer中的数据。同理，也可以调用依赖此job的JobHandle上的Complete方法。例如，你可以调用jobA的Complete方法，也可以调用依赖jobA的JobB的Complete方法。这两种情况下，主线程都可以安全访问jobA使用的NativeContainer。","titles":[]},"925":{"title":"实例代码","content":"Job代码：主线程代码：","titles":["等待Job执行完毕"]},"926":{"title":"相关链接","content":"C# 作业系统 - Unity 手册 (unity3d.com)   Job System介绍   深入解读Job System（1）    深入解读Job system（2）","titles":[]},"927":{"title":"General Purpose Component（普通用途组件）","content":"这里指的是最普通的组件，可以通过实现    接口来创建。不存储行为，只储存数据。   还是一个结构体（Struct）而不是一个类（Class），这意味着被复制时默认是通过值而不是通过引用。通常我们会用下面的  模式 来修改组件数据：结构不包含托管对象（managed objects）的引用，所有   被存在无垃圾回收的  块内存（chunk memory） 中。你可能还听过一种组件是不包含数据、只用来标记的“Tag”组件（Tag component），其用途也很广，例如我们可以轻易地给实体加标记来区分玩家和敌人，这样系统中能更容易通过组件的类型来筛选我们想要的实体。如果我们给一个内存块（Chunk）中的所有实体都添加\"Tag“组件的话，只有内存块中对应的原型会修改，不添加数据，因此官方也推荐利用好”Tag“组件。See file: /Packages/com.unity.entities/Unity.Entities/IComponentData.cs.","titles":[]},"928":{"title":"Shared components（共享组件）","content":"Shared components 是一种特殊的组件，你可以把某些特殊的需要共享的值放到 shared component 中，从而在实体中与其他组件划分开。例如有时候我们的实体需要共享一套材质，我们可以为需要共享的材质创建   ，再放到 shared components 中。原型中也可以定义 shared components，这一点和其他组件是一样的。当你为一个实体添加一个 shared components 时，    会把所有带有同样 shared components 的实体放到一个同样的内存块中（Chunks）。shared components 允许我们的系统去一并处理相似的（有同样 shared components 的）实体。","titles":[]},"929":{"title":"内存结构","content":"每个内存块（Chunk）会有一个存放 shared components 索引的数组。这句话包含了几个要点：对于实体来说，有同样    的实体会被一起放到同样的内存块（Chunk）中。  如果我们有两个存储在同样的内存块中的两个实体，它们有同样的    类型和值。我们修改其中一个实体的    的值，这样会导致这个实体会被移动到一个新的内存块中，因为一个内存块共享同一个数组的    索引。事实上，从一个实体中增加或者移除一个组件，或者改变 shared components 的值都会导致这种操作的发生。  其索引存储在内存块而非实体中，因此    对实体来说是低开销的。  因为内存块只需要存其索引，   的内存消耗几乎可以忽略不计。因为上面的第二个要点，我们不能滥用 shared components。滥用 shared components 将让 Unity 不能利用好内存块（Chunk），因此我们要避免添加不必要的数据或修改数据到 shared components 中。我们可以通过 Entity Debugger 来监测内存块的利用。拿上一段 RenderMesh 的例子来说，共享材质会更有效率，因为 shared components 有其自己的    和哈希表。其中    带有一个存储 shared components 数据的自由列表（  freelist ），哈希表可以快速地找到相应的值。内存块里面存的是索引数组，需要找数据的时候就会从 Shared Component Manager 中找。","titles":["Shared components（共享组件）"]},"930":{"title":"其他要点","content":"可以迭代所有拥有相同    的实体  我们可以用    来迭代所有拥有某个特定    的实体。这种操作开销十分低，因为    内部筛选的只是 int 的索引。前面说了每个内存块都有一个   索引数组，因此对于每个内存块来说，筛选（filtering）的消耗都是可以忽略不计的。  怎么样获取    的值呢？   可以得到在存活的实体中（alive entities）的所有的泛型 T 类型的   值，结果以参数中的列表返回，你也可以通过其重载的方法获得所有值的索引。其他获取值的方法可以参考 /Packages/com.unity.entities/Unity.Entities/EntityManagerAccessComponentData.cs。    是自动引用计数的，例如在没有任何内存块拥有某个   索引的时候，引用计数会置零，从而知道要删除   的数据 。这一点就能看出其在 ECS 的世界中是非常独特的存在，想要深入了解可以看这篇文章  《Everything about ISharedComponentData》 。    应该尽量不去更改，因为更改    会导致实体的组件数据需要复制到其他的内存块中。你也可以读读这篇更深入的文章  《Everything about ISharedComponentData》 。","titles":["Shared components（共享组件）"]},"931":{"title":"System state components（系统状态组件）","content":"允许你跟踪系统（System）的资源，并允许你合适地创建和删除某些资源，这些过程中不依赖独立的回调（individual callback）。假设有一个网络同步 System State，其监控一个 Component A 的同步，则我只需要定义一个 SystemStateComponent SA。当 Entity [有 A，无 SA] 时，表示 A 刚添加，此时添加 SA。等到 Entity [无 A，有 SA] 时,表示 A 被删除（尝试销毁Entity 时也会删除 A）。\n  《浅入浅出Unity ECS》  BenzzZX和    这两个类型与    和    十分相似，不同的是前者两个类型都是系统级别的，不会在实体删除的时候被删除。","titles":["Shared components（共享组件）"]},"932":{"title":"Motivation（诱因）","content":"System state components 有这样特殊的行为，是因为：系统可能需要保持一个基于    的内部状态。例如已经被分配的资源。  系统需要通过值来管理这些状态，也需要管理其他系统所造成的的状态改变。例如在组件中的值改变的时候，或者在相关组件被添加或者被删除的时候。  “没有回调”是 ECS 设计规则的重要元素。","titles":["Shared components（共享组件）","System state components（系统状态组件）"]},"933":{"title":"Concept（概念）","content":"普遍用法是镜像一个用户组件，并提供内部状态。上面引用的网络同步的例子中，A 就是用户分配的   ，SA 就是系统分配的   。下面以 FooComponent （  ）和 FooStateComponent（  ）做主要用途的示例。前两个用途已经在前面的网络同步例子中呈现过。","titles":["Shared components（共享组件）","System state components（系统状态组件）"]},"934":{"title":"检测组件的添加","content":"如果用户添加 FooComponent 时，FooStateComponent 还不存在。FooSystem 会在 update 中查询，如果实体只有 FooComponent 而没有 FooStateComponent,，则可以判断这个实体是新添加的。这时候 FooSystem 会加上 FooStateComponent 组件和其他需要的内部状态。","titles":["Shared components（共享组件）","System state components（系统状态组件）","Concept（概念）"]},"935":{"title":"检测组件的删除","content":"如果用户删除 FooComponent 后，FooStateComponent 仍然存在。FooSystem 会在 update 中查询，如果实体没有 FooComponent 而有 FooStateComponent,，则可以判断 FooComponent 已经被删除了。这时候 FooSystem 会给删除 FooStateComponent 组件和修改其他需要的内部状态。","titles":["Shared components（共享组件）","System state components（系统状态组件）","Concept（概念）"]},"936":{"title":"监测实体的删除","content":"通常    这个方法可以用来：找到所有由某个实体 ID 标记的所有组件  删除那些组件  回收实体 ID 以作重用然而，   无法删除    。在你删除实体时，     不会 移除任何 system state components，在它们没被删除的时候，   也不会回收其实体的 ID 。这样允许系统（System）在一个实体被删除的时候，去整理内部的状态（internal state），也能清理关联着实体 ID 的相关的资源和状态。实体 ID 只会在所有    被删除的时候才被重用。","titles":["Shared components（共享组件）","System state components（系统状态组件）","Concept（概念）"]},"937":{"title":"Dynamic Buffers（动态缓冲）","content":"也是组件的一种类型，它能把一个变量内存空间大小的弹性的缓冲（variable-sized, “stretchy” buffer）和一个实体关联起来。它内部存储着一定数量的元素，但如果内部所占内存空间太大，会额外划分一个堆内存（heap memory）来存储。动态缓冲的内存管理是全自动的。与    关联的内存由    来管理，这样当   组件被删除的时候，所关联的堆内存空间也会自动释放掉。上面的解释可能略显苍白，实际上    可以看成一个有默认大小的数组，其行为和性能都和   （在 ECS 中常用的无 GC 容器类型）差不多，但是存储数据超过默认大小也没关系，上文提到了会创建一个堆内存来存储多的数据。   可以通过    转成    类型，其中只是把指针重新指向缓冲，不会复制数据。【Unity】ECSで配列を格納する Dynamic Buffers  这篇文章中，作者用   来储存临近的圆柱体实体，从而更方便地与这些实体交互。","titles":["Shared components（共享组件）"]},"938":{"title":"定义缓冲","content":"可能有点奇怪，我们要定义缓冲中元素的结构而不是    缓冲本身，其实这样在 ECS 中有两个好处：对于    或者其他常见的值类型来说，这样能支持多种    。我们可以重用已有的缓冲元素的结构，来定义其他的   。  我们可以将    的元素类型包含在    中，这样它会表现得像拥有一个组件一样。例如用    方法，可以通过    来添加缓冲。","titles":["Shared components（共享组件）","Dynamic Buffers（动态缓冲）"]},"939":{"title":"关于prefab到entity","content":"： 将prefab引用添加到Conversion World。在  中可以通过GameObjectConversionSystem根据prefab获取entity：自动生成一个新的entity，然后自定义对entity的操作。Knightmore/MultiWorldBootstrap: Unity ICustomBootstrap extension for multiple custom world creation in ECS (github.com)","titles":["Shared components（共享组件）"]},"940":{"title":"以前是如何制作游戏的","content":"如上图, 首先想想为什么方块能在每帧都被正确绘制到屏幕上? 在传统的 GameObject 里, 引擎会编译并排序整个 hierarchy 树, 同时按顺序调用绘制函数(draw call). 每次 Draw call 调用之间引擎需要初始化 material 和 mesh (也即 set pass call, 如果和前一次调用一样则无需初始化). 在内部 Unity 可能尝试合并 mesh 来减少 draw call (dynamic batching 和 static batching), 如果是 Dynamic 对象这步操作会增加一些 CPU 开销, 如果是 static 则会在build 时预先合并.换句话说, 我们使用 Unity 构建的游戏保存在 YAML格式的 Scene文件中. 尽管游戏并非在 YAML 基础上运行, 在加载 Scene 并解析了方块 .prefab 文件后, 引起会准备一些 C++ 的内存用来存储 Transform, 相应代码则基于此来绘制.在同一帧中这是同一块操作. 并取决于  数据 本身, 每个方块的  和    告知了我们绘制什么. 不幸的是, 绘制都关注于什么样draw call 顺序能得到的正确的结果, 而所有这些绘制都来自于对于数据某些形式的迭代. (在C++中如果数据排布不佳依然不一定能高效迭代). 大家知道 ECS 擅长数据迭代. 而 Burst 加 ECS 则能帮助数据容易多线程处理, 这是我们为什么要用 ECS 来开发游戏的原因.另一块操作则是逻辑. 在绘制之前, 比如方块可能有个 Bouncing 组件在持续地改变它的    (好让你的游戏变得更有趣). 在改变用于绘制的数据这方面, ECS 依然能帮到你.游戏基本上就这些了, 你有一些数据, 然后可能根据玩家的输入等因素来改变, 最后在每一帧中绘制出来.结合改变数据和对数据的绘制, 玩家应该开始能感受到乐趣了! 事实上这一过程也常常使人放松(比如看着一个球在屏幕上下移动). 从纯数据的角度来审视游戏非常重要, 否则你无法接受基于 DOTS 来开发游戏的方式.","titles":[]},"941":{"title":"如何在 DOTS 的世界里做游戏","content":"和  不同, 数据在ECS里类似数据库, 设想一下, 因为我们可以使用Jobs或者 SIMD指令来更快地迭代数据, 所以不仅改变数据的逻辑非常高效而且绘制本身也是高效的.接下来我们直接跳到最后. 我现在已经在使用ECS并且我有3个 transform 矩阵需要绘制(以  形式, 所以迭代是线性且快速的) , 外加对应的    和   .使用 Unity 的 Graphics Api 我们可以直接绘制这些数据而无需    这个数据容器! 参考   Unity - Scripting API: Graphics  以及支持    的   (  https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html ). 这时你已经可以直接从数据来绘制了. 只需要用 ECS 的  等方法来获取数据并绘制它们.参考这篇日文博客(  https://virtualcast.jp/blog/2019/10/batchrenderergroup/ ), 描述了 BatchRendererGroup 的优势. 尽管 \"batches\" 数量巨大, 性能依然优异. 要注意 batching 实际上是合并 mesh 的操作, 因此有一定的计算量. 绘制就是重复地调用没有改变的数据,只要你将 NativeArray 的内存留在    里面, 1000+的 \"batches\" 一点也不可怕.(较低的\"set pass call\"展示了在帧间绘制时并没有太多了 material 切换)","titles":[]},"942":{"title":"Hybrid Renderer","content":"Unity 开发了 Hybrid Renderer (  https://docs.unity3d.com/Packages/com.unity.rendering.hybrid@latest ) 来完成上文提到的绘制工作. 如果你有一个关联    组件(也即Transform矩阵)的 Entity , 且Entity 所在 Chunk 关联了是    的    组件 (   和    不在 ECS 框架下), 那么它就会使用    来绘制数据.整个 Chunk 基于    的数量来绘制的是同样数量的 mesh 和 material. 这已经类似于CPU版本的 GPU instancing 了, 只使用 draw call 是非常快的, 这种粗暴的绘制方式甚至可能比花费 CPU 来每帧合并 mesh 的方式还要快. 由于同一 chunk 使用同样的    和    , 并非100%无需 set pass call. 如果你的 Material 开启了 GPU instancing,    可以批量绘制可不是快速的重绘.之所以这种方式称之为 Hybrid 是因为    是普通的 Unity API 而不是 ECS API. 但是这并不意味着这不是 Data-Oriented. 事实上    工作的方式非常地 Data-Oriented: 就是由    和 Transform 矩阵构成的    数据. 所以别害怕使用它(Hybrid Renderer) 除非你知道如何使用 Graphics API 或者使用   构建你自己的渲染模式. (或许可以去掉非必须的步骤比如 culling).","titles":[]},"943":{"title":"让我们用纯数据来做个游戏吧","content":"既然已经接受了游戏就是改变数据和展示数据, 使用 Hybrid Renderer 我们就可以来做游戏了. 我们假设这就是关于一个上下弹跳的方块的游戏, 按住空格的时候让它跳的更疯狂, 这可能对于小孩子来讲非常有趣.首先要解决的问题, 如何获取到我们需要的    和   . 我想我会使用   来加载一个引用了相关 asset 的 prefab:下面的 System 用来创建Hybrid Renderer 要使用的数据.瞧, 我的 data-oriented 方块坐标位于 (1, 2, 3)!可以看到 Hierarchy 窗口里什么都没有, 但是方块却出现了. 编辑器窗口里也无法选中它, 它仅仅是被绘制了而已. 事实上编辑器里之所以可以选中是因为    容器连接了绘制的内容和其他编辑的内容.如果现在检查 Entity Debugger, 你会注意到 Hybrid Renderer 又添加了一些别的东西. 它会在提交数据到    之前剔除掉无法被看到的东西.以上意味着: \"你拥有 1 个chunk, 该 chunk 能容纳 128 个 Entity ( 1 个 Entity占用 125 字节, 1 个 chunk 16kb), 你已经使用了该 chunk 其中 1 个位置, 你还能添加 127 个方块. Hybrid Renderer 把方块    数据喂给    时, 这些数据在内存中都是连续排列的.","titles":[]},"944":{"title":"Transform systems","content":"现在你有一个数据并且绘制了, 接下来我们加点玩法.如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:使用  ,  ,  /  组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个    组件指向了父 Entity, 那么最终该 Entity 的    值将会和父 Entity的 LocalToWorld 一样.接下来我们添加 Translation 给方块. 玩法系统现在就可以通过修改 Translation 而不是 LocalToWorld了. 我同时添加了 Cube 组件作为 Tag, 这样子代码会更加清晰:接下来实现弹跳. 我们使用    作为余弦函数的输入, 会返回一个从 0 到 1来回的值.注意, ECS 妙的一点在于你可以不断地添加新系统来实现代码的\"横向地\"以构建更多玩法. 模式则是从 ECS 快速的数据库里查询数据, 然后修改, 再存回去. 你可能对这种每次都查询-修改都要增加新 System 的模式觉得有些不安, 但这种模式提升了代码的扩展性. 而 Unity ECS 则确保了重复的数据查询是高效的, 因此在代码中有大量逻辑简单的 System 是完全可行的.我们的弹跳系统先在主线程检查空格是否按下, 并声明相关变量, 最后在 Lambda jobs 中捕获这些变量, 并根据此并行修改查询到的 Cube 的    值, 其中每一个线程会运行时会使用 1 个 chunk 的 Cube 和    数据.    是由 ECS 库维护的一个属性, 它每帧都会从传统的    获取相应的数据Worker 线程现在已经在工作了. 当你用这种方式构建游戏, 最终几乎每个 Worker 线程都会来回使用以避免闲置:","titles":[]},"945":{"title":"可是这样构建游戏实在是太痛苦了","content":"你应该已经注意到, 正儿八经的游戏要改成 data-oriented 并不容易. (除了上文的弹跳球这样的简单场景). 甚至现在你都没法使用所见即所得的编辑器了. 整个游戏如果按照这种方式获取 LTW + Mesh + Material 将会是噩梦般的开发旅程. 虽然整个游戏按照这样的方式构建非常恐怖, 但性能确实是会非常好. 有点倒退回 Cocos2D 时代的感觉. 自然你是想要在编辑器中快速地迭代玩法/美术相关内容.但记住这个方块绘制效率极高, 如果你添加更多的方块, 它们都会打包喂给   因为在同一个 chunk 内存里    已经被连续排列好了. 而复制一个方块也不再是复制  这样昂贵的操作, 只需要添加更多 Entity 以及相应的组件.同样的, 一个 Entity 将数据转存回    也不是什么好主意 (   就做了这样的事儿), 我们想要运行时的 pure ECS , 而不是桥接回    的 ECS.简言之, 你想要 ECS 的高性能, 但不想要按这样的方式来开发游戏.","titles":[]},"946":{"title":"Conversion workflow","content":"所以 Unity 团队采用了常规的 GameObject 来仅实现  编辑操作(authoring),  而在运行时, 则将这些 GameObject **转换(convert)**为纯粹的 ECS data.我之所以之前介绍 renderer 和 transform, 是因为转换过程实际上是将编辑时方便的 GameObject 对象转换为高性能 transform 和 renderring 系统支持的 entity.Component object在进阶之前, 我假设你已经知道了 component objects. 这不仅是可以添加到 Entity 上的    组件, 你甚至可以使用    类型.只不过你无法在 jobs 使用这些类型, 很多有    约束的泛型 API 也无法被使用. 但是这种类型的组件确实是关联到 Entity 上的, 也有相关的 API 可以使用. 以下是一些支持 component objects API 例子::  ,  . 如果添加不存在的组件, 你在获取时会得到一个 null.   : 你可以创建    (如  )类型的     ,  : 因此你可以使用  类型的    来创建组件的查询.   :  会返回   . 这会返回以托管数组方式存储托管组件的结果, 而不是  那样返回","titles":[]},"947":{"title":"Conversion world, destination world, primary entity","content":"在内部, 转换过程是创建特定目的的 World, 并在其中运行特定的   conversion systems  (这样你会得到一个新的   , 以及存储entities 的数据库). 这被称为   conversion world . conversion world 同时也知晓用于存储转换结果的   destination world.因为conversion world is一个 ECS World, 我们可以从 Entity 出发来而不是仅仅是 Hierarchy 中的   . 由于前文所提到的 component object 的存在, 从     importing  的过程也非常容易, 所以你也可以得到一堆完整复刻   原有层级关系和组件的 Entity (使用 class 类型组件). 也就是说, 让每个 entity 也拥有 Unity 传统的   ,   ,    或者    组件.这些拥有component object 的 entity 并不优秀, 我们更希望得到更优的基于    的组件.通过  单次调用  conversion world 的    方法, 其中的特定 system 也会 update 单次, 这会导入 component object entity 并将结果存入 destination world. 至少, 这会为每一个conversion world 中找到的    组件创建一个空的 Entity.上图中, destination world 的 Entity A 被成为   的 \"primary entity\". 之所以没有被称为 \"resulting entity\", 是因为这转换过程并非是一对一的过程. 比如 A 可能在 destination world 中构建出 A1 和 A2 两个 entity, 这种情况, 其中一个将成为 primary entity.另一个  在 conversion world 工作时 的特点是你可以通过原始的    获取 primary entity(当然也可以传入任一    来获取, 内部将会调用  的   来替代). 比如上图 A 的   也可以用于获取 primary entity, 这在更复杂的转换过程中可能有用.最后, 包含那些并不高效的 Entity 的 conversion world 将会被   destroy  掉.","titles":[]},"948":{"title":"GameObjectConversionSystem","content":"被标记了如下 attribute 的 system 将在 conversion world 中被调用:这个 attribute 是可继承的, 因此更推荐的方法是直接继承ECS库里已提供的  .拿    system 为例. 它会在 conversion world 里面寻找    组件, 依此来构建 destination world 中 entity 的  和  /  /  组件, 它甚至知道在  的 scale 为  时不添加  !另一个值得看的例子是   . 这是  和  转换为   加    和    的地方","titles":[]},"949":{"title":"Conversion 的顺序","content":"conversion systems 都是被扫描以及归集到一起的, 因此顺序并没有被清晰地定义. 假设你想要转换过程中 \"get primary entity\" 并获取到    组件, 执行顺序就变得很重要了, 因为你要确保你的 conversion system 在 Unity 的   之后执行.依然排得上用场. 在 conversion world, 有如下一些 groups:如非特别指定, 你的 system 将运行在   中. 因此如果你想要在Unity内置的 conversion system 之后做事情, 你得确保你的 system 运行在其后. 要注意的是你不能使用  因为  不是  的. 从前文截图你可以看到它运行在 before group 中, 因此你的默认运行在   中的 system 是可以获取到   等组件的.    则运行在    中, 因此如果你想要获取到 RenderMesh, 则需要将你的 system 放在其后.declare 和 export Group 很特殊, 因为它们运行在特定的过程的前后, 而中间三个 Group则是一紧挨着运行, 因此, 你如果要放在这两个 Group 内运行, 一定得明白它们前后都做了些什么事儿(后文会讲).","titles":[]},"950":{"title":"GameObjectConversionMappingSystem","content":"conversion world 还有一个非常特别的系统附加在所有可用的    里, 就是  . (下文称之为 mapping system). 该系统是所有 conversion world 的 boss, 奇迹发生之地.首先这是一个纯粹的 \"tooling system\", 意思是它只有一个空的    函数, 完全是用来被其他系统获取, 并在它们的  中使用的工具.(这种设计也适用于你自己的游戏.)这里你可以执行   来与 destination world 沟通, 或者创建更多的 entity. 当你想执行 conversion, 你需要显式地指定 destination world. 这个 world 用来当作 mapping system 的 constructor.在你的 conversion system 里面, 你可以    来获取 mapping system, 但如果你继承了  , 则可以直接通过相应的   方法获取到.","titles":[]},"951":{"title":"让我们使用 ConvertToEntity 来convert吧","content":"现在已经有足够的知识来执行转换过程了. 目前我们仅仅使用 Unity 内置的 conversion system. 也即  和   , 因此确保你的输入拥有  ,  和   来得到结果.要在scene里面选择 game objects导入 conversion world, 我们可以使用  组件. 在    里面, 它会基于一些标准来选择导入什么. 所以若如下图附加到  上, 那么在 conversion world里, 我会得到这些ECS的   component objects:    ,  .当进入 play mode 时,    被调用的瞬间后你得到:当前状态当然还没准备好绘制, 因为还没有   , 但是你可以看到  发现了  component object 然后就在conversion world 被销毁之前, 在 Primary entity 上构建了 LTW/TR .如果我修改一下 scale:转换的结果:因为    conversion system 的代码发现了   有非 1 的 scale, 于是决定加上额外的组件到 primary entity 上.接下来看看  在我们添加了   和   后做些什么:我得到了一个正确转换且拥有纯粹ECS数据后的方块! 另外 conversion world 也可以分配 entity name, 因为 conversion world 知晓    的存在, 所以可以在 conversion world 被销毁前通过   来追踪其名字.组件里\"and destroy\" 选项并非 conversion world 流程里的内容, 由该MonoBehaviour 组件自行完成. 因为它并不觉得你想要复制出同样的结果, 如果我不销毁掉原对象, 那么我就会得到两个方块, 一个来自  和   , 另一个来自Hybrid Renderer 渲染的  和   .如果你不想要默认的行为, 你可以使用  手工转换. 后文会细讲.","titles":[]},"952":{"title":"Hierarchy conversion","content":"实际上提交了所有子    给 conversion world, 除非你在子对象中使用   .上图的结构中, conversion world 最后会得到: A B E F G H. 每一个元素的 component objects 都会和最初的类似.   component object 是关键点, 因为它有  属性, 这样 conversion world 才能基于此构建出整个层级树.给 D 添加   是不会有效果的(在C处转换就停止了), 因此会抛出警告. 而添加  给 B 则没有警告, 但也不会有额外的作用, 因为 A 处隐含了 B也将被纳入层级的事实.ECS 里有一个  组件, 该组件仅有一个  字段用来表示 transform 的层级关系.  的计算总是基于  组件. 如果   是 0, 那么    矩阵的结果并不是在行1 2 3 和 列4为0, 而是直接复制  所指示Entity的   的值.而负责计算  的正是   , 让我们看看结果:我们先猜猜A B E F G H 会占用多少 chunk? (不管转换过程中有多少魔法, 我们永远得关注数据本身!) 先假设我们这些对象的 scale 都为1 (这样就不会产出  组件).为何有 3 个chunk?你可能会猜测所有 chunk 都会有    而对于根部的 A, 其  则可以是一个    , 但是 Unity 并没有选择这样做, 因为在复杂一些的游戏里, 查询时使用   会相对更加高效一点. (你可以想象成如果没有parent组件, transform systems 可以忽略掉一些矩阵运算.)没有 Parent, 但有 child : A  Parent 和 Child 都有: F  叶子节点, 仅有 Child: B E H G你可以看到还有一些 component 被添加了:   ,  ,  .目前还无需关心它们, 总之它们会最终参与  的计算.注意到 conversion 过程中有多少个不同的 Archetype 产生有时候很有用. 比如当你有个巨大的 game objects 层级树, 且其中有些对象仅仅是用来组织结构的空对象, 有些则真正拥有  and  , 这样你最终可能会至少得到 6 个 chunk. (3个前述chunk, 以及3个包含   的chunk). 因为  是  , 如果你有更多的 mesh 和 materials, 那么 chunk 的数量还会继续增加. 总之, 这类的思想也出现在dynamic/static batching, GPU instancing, 或 SRP batchers 之中, 而不是 ECS 独有. 使用Entity Debugger 可以清楚地看到 chunks 是如何被组织的.\"and destroy\" 的行为在 stop 时也会有一些变化, 被 stop 的对象之下的层级会被单独摘出来并保留(因为 Unity 猜测既然那里你没有相应的 entity, 那么就为你保留 gameobject)","titles":[]},"953":{"title":"Disabled 与 GameObject conversion","content":"被 disabled 了的  会被加上一个 ECS 中的  component, 如下所示, Convert and destroying 顶部的 Cube, 你会得到 5 个 Entity, 其中 3 个关联   component:当然你依然可以在层级任何位置添加 Convert To Entity (Stop), 其行为不会发生变化. 比如我在 Cube(1) 和 Cube(4) 上添加 stop, 那么我最终将得到 3 个 Entity: Cube(2) , 有  的Cube(3), 没有  Cube .","titles":[]},"954":{"title":"Convert and inject 模式","content":"假如:你想保留原始的 game object  同时想在 conversion world 销毁之前导出   component objects  给 primary entity. (当然也包含转换过程中新增的 components)如前文中提到的, 我有  和  会被带进 conversion world , 但由于并没有conversion system会处理  和  , 因此会在 conversion world 被销毁时也同时被销毁.但在\"Convert and inject\"模式下, 这两者就可以被保留:这样, 我像之前一样正常得到了   , 但同时我也得到了     和  , 这意味着你得到了一个可以追溯回原始 GameObject 的 Entity. 如果我们在别处 destroy 这个 GameObject, 那么 ECS 侧的   也相应回返回   .现在你应该明白了, 销毁或者不销毁原始 Gameobject 两种模式都有各自的意义 (前者是为了避免重复, 后者为了访问 component objects).这意味着如果我有一个关联  和  的方块同时又选择了inject模式, 我会得到渲染在同一位置的两个方块. 如下图, 一个方块是 2 * 6 * 2 = 24个 tris(额外 2个 tris是蓝色的背景所占用的), 如果使用 convert and destroy, 我依然会得到 26 个 tris并被Hybrid Renderer所用, 在但 inject 模式下, 会变为 50 个 tris, 因为转换前后的对象都被保留了:上面这个例子并不是 inject 模式的预期用法, 该模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯.","titles":[]},"955":{"title":"使用 ECS 的System 来管理传统的 MonoBehaviour","content":"inject 模式最酷的在于, 从现在开始, 你就可以制作 hybrid ECS 游戏了. 你可以把 inject 模式视作将对象转化为 ECS system 可访问的对象, 甚至在你没有 conversion system 的时候. 仅仅是保留 component objects 以及是非常有用了. 你完全可以用   进行组件的开发, 然后用 system 来控制它们.你可以在    上就如同  一般添加   , \"tag 用途的  \" 也是完全可行的. 不过过去常见的  继承模式在ECS的世界里, 你可能需要考虑用组合模式来替代了, 一如 ECS 里常用的   并不能继承.虽然并没有性能上的提升, 但是依托 ECS 的查询能力可以获得 system 设计上极佳的灵活性.或许你过去常常使用一种\"manager优化\"手段, 就是你去掉移除对象的   方法, 然后让一个 Manager 来追踪该对象的  来统一地   .而用于操作 component object (monobehaviour) 的 system 正是和上述优化一模一样的玩意儿! 而且 ECS 在查询上更加灵活. 你可以不断添加查询不同种类 component object 的 system. 这样对于在团队中分割工作量更容易. 也可以通过    调整执行顺序, 而不是过去地狱般的 script execution order.举一个 UGUI 按钮的例子. 我想要用 system 来添加一段逻辑: 改变  时按钮会在正常和禁用状态之间闪烁.所有按钮都使用 convert and inject, 其中一个缺少  \"tag\"  . 目前还没有任何实际代码, 不过我想要用这些类型来进行查询.来看看 conversion 后的结果, 我们得到 2个 chunk, 其中一个有3个 entity (橙色的竖条往右边移动了一点, 意味着其包含 3/160 个 entity), 另一个则有一个 entity.下面的 system 则能自动到 ECS 的数据库里面查询 scene 里面所有带有 blinking 组件的按钮. 这种\"凭空\"查询  的能力让声明  成为了过去时. 即便你对 ECS 毫无兴趣, 这种查询能力也让其成为非常便捷的 Unity 开发工具.也可以使用 component objects, 只不过这时候不能使用  或  关键字, 同时为了防止使用 Burst, 你需要用  来替代  .这样完全或者部分移植到 ECS 的游戏, 也可以自由使用 system 了, 只需要 inject 模式, 你便拥有了基于 Entity 的查询能力.","titles":[]},"956":{"title":"Inject 模式的 conversion 规则","content":"上文例子中将所有的  转换到 ECS 了, 那   里的  怎么办呢?和会将所有子层级提交到 conversion world 的 destroy 模式  不同 , 这时所有的子层级将被忽略(即便你为它们添加了inject模式的  组件). 仅有顶层对象会正常convert and inject. 所以 ECS 不会为创建关联  component object的  .为了更清晰地说明这条规则, 我试着 convert 更上层的  :这下我的 Button 并没出现在 ECS 的世界里, 而只得到了 Canvas, 如果我把模式切回 destroy, 则得到一堆 pure 的 entity 而不带任何 component objects:可以看到, 所有在conversion world 中的 component objects 最终都被销毁了.","titles":[]},"957":{"title":"IConvertGameObjectToEntity","content":"实现 conversion system(通过继承  )可以让你自由控制conversion 的过程. 但如果你想按照具体类型来转换呢? 每当转换执行时, 应当相应地执行一些代码.Unity 内置了另一种名为   的 conversion system. 该 system 会迭代 conversion world 中所有的  , 接着使用   并判断是否实现   接口, 然后再调用该接口的   方法. 你可以把任何逻辑都放在这里:参数是   产生的 primary entity. 回忆一下前文提到\"primary entity\"与   以及相应   关联.   参数则是 destination world 里的   . 在这里你可以做任何相关联的事儿, 比如为每个  添加 500 个屁用没有的 Entity?当然可以!你可以利用这里的机会来使用  来初始化更多数据. 要注意这里有一丝\"遥控\" destination world 的味道(因为实际上你工作在 conversion world 层面). 所以重视这个参数名字, 因为确实有另一个属于 conversion world 的 manager.单独创建 conversion system 并使用  来初始化数据也许会更高效一些(因为你在这里使用 Burst 和 jobs). 但是 Convert 方法运行你获取到  中序列化的字段, 这样更加随心的修改每个 entity 关联的数据.参数则是调用  方法的  本体, 但是强制被转换成了   类型(小心名称有点易混). 其目的是让你可以使用 mapping system 中的方法.","titles":[]},"958":{"title":"LinkedEntityGroup","content":"是一个 dynamic buffer , 通常它会影响:调用  方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的  . 注意实例化并不一定和ECS中的   component 直接关联.  调用  时也会同时销毁   中的所有 entity. 类似在编辑器中删除   调用    加上的   component 会告知 ECS 的查询系统忽略它们, 而    中的 entity 也会受到同样的影响. 有点类似禁用   时同时会禁用整个层级树.注意如果buffer 中的 entity 也有  , 系统  不会递归地 执行instantiation/destroy/disabled 过程.这些过程在具体执行当中也有一些细微不同.  和  只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity   必须要把自己包括在内 才能正常工作**.** 然而  则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.要注意   和   并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.","titles":[]},"959":{"title":"从非 prefab conversion 中获取LinkedEntityGroup","content":"目前, 我们使用  并不能得到   . 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. (  却可以正常得到基于   的层级结构).如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果).从 debbuger 现在可以看到已经正常添加了  , 目前它已经支持  和   的正常工作了:Unity 也在其他一些地方执行这一过程, 比如在转换 prefab   asset  的时候.(后文会讲)","titles":[]},"960":{"title":"尺寸警告!","content":"你可能觉得每个 chunk 16KB 非常多了, 你最多可以放进去 2000个 entity. 一旦你开始转换层级结构,   和它那些朋友们(比如    )会很快耗光这些预算, 每一个 buffer 里的元素都是一个 8 bytes 的   .下图中 12 个 chunks 中, 每个只能容纳 45 个    , 哪怕只是非常简单的层级结构和非常少量的 component, 远达不到我们的千个级别.在 entities-0.5.1版本里,    源码中可看到, 任何没有   的buffer 类型都会默认    的容量.   里面装的是 entity, 因此其容量是    .这意味着:每个 Entity  关联的  (或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.  层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.  除非显式调用,   仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的    数量  在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望  正常工作.最后, 16kb 一个 chunk 意味着 1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).","titles":[]},"961":{"title":"创建额外的 entity","content":"一个常见的情况是一个 GameObject 对应一个 Entity, 也即 \"primary entity\". 在 mapping system 里面, 调用 CreateAdditionalEntity(gameObject)来创建更多的Entity .这些 entity 现在属于这个 game object 的 \"secondary entity\".设想我们的新设计是每当CubeMultiple 转换时将会创建额外的两个 entity:注意Convert调用是递归的, ConvertToEntity 附加在顶部的 CubeHead 上.要注意额外的entity都是新增的, 且没有为它们添加 components, 这不像那些被默认转换的component objects (如 Transform), 注意下方拥有 2008 容量的 chunk:你可能意识的到使用 destination entity manager 的 dstManager.CreateEntity() 来做同样的事情, 下文你会看到这不只是处理方式的问题.","titles":[]},"962":{"title":"从单一源得到 entity","content":"要这样做, 需要在 mapping system 里, 调用GetEntities(gameObject/component). 因为我们增加了额外的 entity, 让 conversion world 知道这些 entity 来自特定的东西, 这样让我们可以查询到它们. 比如, 如果我有一个GameObject CubeMultiple 的引用, 那么使用GetEntities 我就能得到 primary entity 和另外两个新增的 entity.你无需担心它们是否已经被创建了或者担心Convert 顺序, 因为这类调用会例行调用Convert . (这一点同样适用于GetPrimaryEntity )","titles":[]},"963":{"title":"如何影响 linked entity group","content":"回忆一下DeclareLinkedEntityGroup. 通过正确增加额外的 entity, conversion system 知道它们如何关联至 GameObject. 这些结果也会添加进 linked entity group.前面 CubeHead 的例子在自己身上调用DeclareLinkedEntityGroup , 结果是已经把额外增加的 entity 包含进来了:而只是单纯地通过dstManager 来创建 entity 则不会有这样的效果. 这样看起来转换CubeMultiple 更像是带着一些添加更多 Entity 到 destination world 的\"副作用\", 而不是它变成了多个 entity. 而这种模式也能配合 live link 的工作. (后文会解释)","titles":[]},"964":{"title":"声明 Asset","content":"或许你也想通过 asset 而不仅仅是 scene 来生成 entity, 好消息是 primary entity 可以关联到 asset 上, 不只是GameObject (或MonoBehaviour), 如果你调用GetPrimaryEntity 时传入 asset, 最后会在 mapping system 里面注册, 并得到正确的 entity.因为你无法将ConvertToEntity放置到 asset 文件上, 你需要在 conversion 后某种\"声明\"它们是 entity的方法.什么时候声明?答案是在 conversion 真实发生之前. 这被称之为 discovering 过程. 如果你在这个conversion过程之中试图添加, 声明的 API 就会报错. 在声明之后, 在 conversion 过程中, 你就可以使用 GetPrimaryEntity来传入 asset 的 primary entity了. 如果你不这样做, 那么查询它们将会有点困难.IDeclareReferencedPrefabs在 discovering 阶段, 首先, 实现了IDeclareReferencedPrefabs组件接口的GameObject会被扫描, 在这里你可以通过添加 prefab asset (目前只支持 prefab 文件) 到相应的 list 中来进行声明. 你可以在inspector里通过序列化的 GameObject 字段来引用它们.在conversion systems里面声明在扫描了接口之后, 回忆一下我们前面提到的GameObjectExportGroup. 所有运行在第一个 GameObjectDeclareReferencedObjectsGroup 中的 conversion system 会被 update. 在这里, 你有另一个声明 asset 的机会, 这里支持 prefab 和  其他任意类型的 assets.使用 conversion system 意味着你手边可以使用 mapping system. 其中有几个方法可以用来声明 asset. 接下来你将如何在 system 代码中获取到这些 asset 引用呢? 你可以在conversion world 中查询任意可能链接了 asset 的 component object (比如通过在可以在 inspector 中添加的字段). 当然可能某个时间点你会意识到不如最开始就使用IDeclareReferencedPrefabs , 因为反正你都得实现某种\"占位\"机制. 所以, 如非必要, 尽可能使用 IDeclareReferencedPrefabs 吧.接下来到了正常 conversion 的时候, 这时候你可以结合 IConvertGameObjectToEntity 来获取已经被转换好的 asset/prefab 的 Entity, 传入之前一样的引用即可:要注意 IConvertToGameObjectToEntity 的 Convert 被调用时你依然有机会使用 mapping system. (添加额外 entity, 遍历其他 primary entity 等等) 但如果你这时候使用 mapping system 来声明更多东西就太晚了会报错.以下就是完整的过程:顺便一提声明截至仅仅针对 asset/prefab, 你依然可以在conversion 过程中调用DeclareLinkedEntityGroup.声明任意 asset在 mapping system 里 使用DeclareReferencedAsset ,   在 conversion world 里 , 你会得到一个关联 Asset conponent , 外加一个你声明的 asset 类型的 component object 的 Entity (注意并非 destination world).例如我可以通过DeclareReferencedAsset(mySpriteAtlas).来创建一个Entity+Asset+SpriteAtlas , 这时候 destination world 的 primary entity 依然是空的, 目前还不明白这个系统设计的目的, 也许是为了让你自己处理Asset的转换过程.声明 prefab asset添加进IDeclareReferencedPrefabs 里的 list 就行. 对于 GameObjectDeclareReferencedObjectsGroup 里的 system 来讲, 则是使用 mapping system 的DeclareReferencedPrefab 方法.不过这一次和AssetandGameObject component object 不一样, 你会在 destination world 中得到一个真正的   prefab engity  (而不是前面说到的空结果).接下来简单解释下什么是 Entityprefab. 如果你添加一个 Prefab 组件到任何 Entity, 除非你显式指定, 那么它将在默认 query 中隐身, 和Disabled组件的行为很相似. 使用 Instantiate方法则会将实例化出的 entity 将该prefab组件删掉. (毕竟你不太可能想要实例化另一个 prefab 出来...)不过该行为的目的又有所不同, 之所以在 query 中隐藏它们是并非主观上想要让它们处于 \"inactive\" 状态, 而是它们本就该是 \"inactive\". 它们只不过是用来快速创建新数据的蓝图. 因此, 在创建 query 时有两个不同的参数模式: \"include disabled\" 和 \"include prefabs\". 使用时注意语义上的区别 (如不要使用 Prefab 来隐藏 Entity).结合前面提到的LinkedEntityGroup , 现在ECS的实例化已经和传统 Unity 的实例化感觉一样了!通过声明 prefab asset, 你便同时添加了Prefab和LinkedEntityGroup 到目标primary entity上.要注意ConvertToEntity只是转换对象为普通的 Entity, 因为 scene 里的层级结构并不是   asset.  无论它们是不是蓝色的(即在scene里被实例化的 prefab), 我们都无法得到Prefab或LinkedEntityGroup.Prefab 本身则属于 asset 文件, 你无法在 Project panel 中粘贴ConvertToEntity运行. ECS 库通过查看它是不是位于 scene 中来决定它是不是一个 prefab, 显然可以粘贴ConvertToEntity 则意味着对象在 scene 中.","titles":[]},"965":{"title":"Prefab asset conversion 过程","content":"上面的声明过程实际上会调用 convert 过程. 接下来我说说和转换 scene 中GameObject在细节上有哪些不同. 只要在 scene 层级中, 是否从 prefab 实例化就无关紧要, 只有在从 Project panel 处声明的 asset 被实例化时才会有区别:为实例化准备的自动 LinkedEntityGroup如下所示的 prefab asset 设置:要意识到 CubeHead 是一个 asset, 而不是 scene 对象.我们会得到:如果我们 convert 位于 scene 中的 CubeHead, 我们无法获取到LinkedEntityGroup. 该行为仅仅针对 prefab asset, 其目的显然是为了实例化. (链锁销毁行为也一样)  LinkedEntityGroup 包含层级树下的所有对象以及自己, 包括 cube 3 和 cube 4. Conversion过程让 prefab \"线性化\"了, 实例化过程就无需递归调用了, 是需要遍历 LinkedEntityGroup即可.  前文提到过, 之所以LinkedEntityGroup包含它自己是因为 SetEnable 可以一次性完成工作, 而不是一个接一个的调用.  所有转换后的 entity 都会添加 Prefab组件, 但是我们只需要使用最顶层的那个 Entity 用于实例化. 事实上, 实例化过程没有Prefab 什么事儿, 主要是用LinkedEntityGroup 来完成工作. 实际上你可以实例化任何 entity.为禁用功能准备的自动LinkedEntityGroup前文解释过 prefab 的顶层对象会得到LinkedEntityGroup 是因为需要实例化.额外地, 如果在 prefab 的任何位置发现了被禁用的GameObject,该位置的对象也会得到包含所有子级对象的LinkedEntityGroup .该行为的目的是为了你可以在已经被实例化的 Entity 上使用SetEnable 时能高效地添加 Disabled组件. 当然Disabled的 conversion 过程依然遵循相同的规则: 当 convert 一个非 asset 的GameObject , 会自动添加LinkedEntityGroup.Can't stop won't stop你不能在 prefab 中使用 Convert To Entity (Stop), 没用.来点小测验吧.依照目前这些 conversion 的规则, 来检查一下你是否能推算出上面例子正确的结果吧: Parent(还记得这是为 transform systems准备的么),Prefab,Disabled,LinkedEntityGroup(以及里面的 entity).Child和相关组件会根据Parent组件在一轮 transform systems 的update 之后被添加.要记住LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.(也许你觉得这无所谓, 但实际上这会让 chunks 的碎片变多).是否蓝色名字(说明它连接这 prefab asset)无所谓, 它不是 asset, 不会遵循LinkedEntityGroup的conversion 规则.注意, 这时候你无法通过Cube (2) 连锁地禁用 Cube (3) 和 (4), 因为没有自动生成LinkedEntityGroup, 但你可以人工声明它.prefab 实例化时的 Remapping 过程当在拥有LinkedEntityGroup的entity上调用Instantiate时, 会发生   entity remap  过程. (这里阅读更多内容:   https://gametorrahod.com/entity-remapping/ ) 目前你只需要知道 convert 一个 prefab   asset  让LinkedEntityGroup 能工作, 就行了.(译注: entity id 在一个 world 当中是不可重复也不可被外部修改的, 当序列化存储 entity 时, 反序列化过程会因版本问题丢失掉 entity id 引用, 这一问题同样影响实例化过程, 而 entity remap 过程就为了解决这一问题而出现的)所以, \"烘焙\" Entity 值到 prefab entity 的 conversion 结果中是可行的, 当实例化时, 这些烘焙好的值又会\"活了过来\".在前例的情况中, 如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用.![img](data/svg+xml;utf8,)当你调用Instantiate时, 一旦它发现可以被 Remap 的情况(如LinkedEntityGroup) Remapping 就会发生. 因此在 conversion 把它变成 Prefab 之前, \"连接\" Entity 引用是非常有用的, 这样一旦你Instantiate 它, 里面包含的 Entity 关系就已经可用了.没有LinkedEntityGroup则 Remapping不会发生, 因为在那种情况下就没有同级对象需要 remapping Entity 的值了.GameObjectExportGroup 是什么?前面 4 个我们都介绍了它们的作用, 来看看最后这一个. 前面介绍的过程你也许会发现不仅仅可以将 conversion 结果用作运行时, 也可以用来  导出 . 通常 export group 是不包含在conversion 流程中的, 仅当我们显式要求时才导出.如果你的 conversion system 运行在这里, 那么所有的 conversion 都已经完成, LinkedEntityGroup Prefab都已经准备就绪, 当然你不能在这时候继续 convert 了.目前究竟什么是\"导出(export)\"依然是个谜, 或许得等 Unity 团队写点我能看懂的文档. 目前你可以认为这个 Group 在你日常的 conversion 中用不太上. 而且猜想它一定和 Assetentity有某些关系.mapping system 上的 DeclareDependency 是啥我们还漏掉了一个\"声明\". 但是我不清楚这是什么, 它看起来像是 live link 会用到的东西. (后文会解释 live link).","titles":[]},"966":{"title":"声明和使用 prefab asset 的示例","content":"如果我 convert and destroy 上面这些 cubes 的 MeshFilter和MeshRenderer, 我会得到两个 chunk:现在我将把它变成 prefab asset, 并从 scene 中删掉, 接着我会把该 prefab 转换为隐藏的 Prefab entity 以用于后面的 Instantiate.下面是我的计划: 做一个 SpawnHere 用于存储实例化位置 (\"tag\" 性质的MonoBehaviour).不用担心上图中有3个GameObject声明了同一个 prefab, conversion system 知道如何处理重复情况, 下面是代码:在 discovery 阶段 asset 的 primary entity 已经被创建了且包含了Prefab和LinkedEntityGroup, 能够正常用于实例化. (由于 Prefab 的存在, 虽然拥有 RenderMesh和LocalToWorld组件, 但 Cube entity 是对于查询隐藏的, 因此也没有在画面中显示)conversion 之后, 我就可以获取Prefab在 SpawnHere 所在的位置进行实例化了, 因为LocalToWorld或Translation很多 entity 都包含, 被销毁的SpawnHere 是无法被区分的.因此我们添加 SpawnHereEcs 当作 Tag 来使用:另外, 我们可以直接在 SpawnHereEcs 里面加上 prefab entity 的引用, 而获取该 entity 的方式就是前文提到的声明过程:然后我们的 system 将查询SpawnHereEcsentity 并在这些位置执行实例化, 之后再销毁SpawnHereEcs以避免重复实例化.你可以按照 chunk 来批量RemoveComponent , 使用WithStoreEntityQueryInField 来导出 lambda 定义的 EntityQuery, 然后在 ForEach 之后使用 EntityManager.RemoveComponent 传入该EntityQuery.以下是我们的结果:和Prefab 一样我们实例化的结果也拥有LinkedEntityGroup, 你还可以注意到 debugger 现在支持 select 按钮来选中 entity.那么有没有可能在 conversion 阶段就能预先实例化呢? 这样我们就无需 SpawnHereEcstag 了, 因为我们知道TransformConversion完成的确切时间, 所以我们已经可以利用其 primary entity 来获取位置. 然后利用 dstManager来完成实例化. 看起来就像是SpawnHere MonoBehaviour  直接转化 成了 prefab 实例, 而不是在运行时分开来完成这一切.你可以思考一下为什么这种方法无法正确工作然后再继续往下看几乎 能够工作, 但是结果是只有三个cubes. 从图中可以知道, GetPrimaryEntity显然是能够正常工作的, 因为已经度过了 discovery 阶段. GetComponentData 也能正常工作, 因为Transform会在 GameObjectBeforeConversionGroup 阶段转换完成.但是回忆一下LinkedEntityGroup和Prefab 所涉及的声明过程:LinkedEntityGroup和Prefab 并未就绪! 缺乏LinkedEntityGroup导致我们最终的结果里仅仅实例化了最顶层的那个 cube. 因此在conversion过程中你无法这样使用刚刚声明的 Prefab. 如果你不清楚 conversion 流程, 很难知道为什么会有这样的结果.","titles":[]},"967":{"title":"[GenerateAuthoringComponent]","content":"SpawnHere->SpawnHereEcs 这种模式要求你有一个 MonoBehaviourcomponent 在 inspector 中暴露一些字段, 然后在 conversion 后转换为等价的数据. 我们把这个MonoBehaviour称为   authoring component.我们当然可以创建GameObjectConversionSystem来完成相同的工作. 但是使用IConvertGameObjectToEntity无疑是更精简的方式.更棒的是, ECS 还有 IL 黑魔法来帮助你完成这个过程:注意我们这里并没有定义 MonoBehaviour, 我们自动获取到了名为\"My Data Authoring\" 的组件, 甚至 \"My Data\" 也可以作为相同结果来添加. 这部分生成代码会和我们手写有类似 Convert 过程, 由于你无法查看生成的代码是什么, 这基本相当于魔法.目前要施放该魔法, ECS 字段必须定义为 public, 下面这样的代码并无法按你所设想的那样工作:还有一个小技巧是可以生成 \"声明 prefab asset\" 模式功能的代码 (前面SpawnHereEcs的例子),   仅需定义一个 Entity字段即可.以上和以下代码是完全等同的当然, 你可以正常混搭Entity或float字段在一起.","titles":[]},"968":{"title":"混用ConvertToEntity的 destroy 和 inject 模式","content":"inject 模式会产生太多的 component objectes, 而且也不能访问整个层级树. 同样的, destroy 模式也不能清晰完整地转换整个层级到 ECS 中去. 你可能会想要介于二者之间部分地\"inject\". \"stop\" 组件并没有满足需求 (因为你并不是要跳过转换).举个例子, 如果我用Transform,MeshFilter, 和MeshRenderer建造一个飞船, ConvertToEntity 在 destroy 模式下会被转换成LocalToWorld+RenderMesh之前我们的 bouncing system 对 Cube和 Translation有效, 如果添加Cube到飞船的根对象上, 应该也能工作. 当然我们可以继续使用魔法生成代码:如果我们在排气孔位置增加一个粒子效果对象, 我想要的结果粒子随着飞船能上下弹跳:destroy 模式下, 当 ParticleSystem 这个 component object 进入 conversion world 后, 最终是会被销毁的.如果我添加 ConvertToEntity (Stop) 给它, 那么该对象会变成完全和 ECS 无关的东西.那么如果在 destroy 模式里面的子对象上添加 inject 模式呢? 这样做我确实会得到一个包含 ParticleSystem的 Entity . 但它是否和 destroy模式转换的飞船能关联起来呢?结果并不如我们所期望那样:但从 Entity Debugger 中我们可以看到, 这个对象确实是有destroy 模式下转换后的Parent和LocalToParent , 同时也有inject 模式下添加的ParticleSystem这个 component object. 你现在已经实现混用两种模式了!就我们目前所知, Parent会帮助我们计算最终的 LocalToWorld , 但是粒子没有上下弹跳是因为没有什么其他系统在使用它的LocalToWorld, 所以我们可以将它的值复制回原Transform 组件, 这可以通过copy transform to game object proxy 组件来实现, 这个组件同时也需要你添加 GameObjectEntity :注意如果飞船以 prefab asset 形式被实例化, 那么结果将会像仅使用了 destroy 模式, 也即这里的   particle system 会缺失 .","titles":[]},"969":{"title":"Companion Game Object","content":"前文所述的方案听起来像是 hack. Particle System 依然存在于 Hierachy 中, 像是它被\"胶粘\"在被转换后的 Entity 上进行移动.Companion game object 是一种更加\"干净\"的混合转换方式, 它会创建一个新的 game object 来**\"伴随\"(companion)  被转换的数据, 并用它来选择你想保留的组件. 这让它 看起来像**是被完美 conversion 了.我们使用 mapping system 来实现该模式. 如下代码所示, 我没有增加太多非 ECS 内容, 只不过修改了一下转换相关的代码:虽然这模式的名称叫 companion game object, 但你需要配置的其实是  components.  AddHybridComponent 调用不仅指定了哪个GameObject应该\"伴随\", 同时也指定哪些组件会被保留.(primary entity 是按照组件来识别的). 因此我定义了组件的 public 字段而不是 GameObject字段.在下面这个 ParticleSystem 的例子里, 还隐含着一个 ParticleSystemRenderer, 如果缺失了 renderer, 那么最终的 companion game object 里就只有ParticleSystem 从而导致不会渲染结果. (但是 CPU 依然会运行粒子模拟)可以看到, 之前那些 Hack 的内容现在全都不在了! (去掉了ConvertToEntity inject 模式, 去掉了 copy proxy, 去掉了 GameObjectEntity), 现在conversion 完全正常工作!可以看到现在 Hierarchy 窗口里没有 Particle System 了, 但在 Game view 窗口却正常显示着, 所以它是哪里来的?先来看看它对应的 primary entity 的 conversion 结果:调用AddHybridComponent方法让 companion 相关的组件自动添加到了GameObject的 primary entity (也即 Particle System entity) 上, 同时也加上了指定的ParticleSystem和ParticleSystemRenderer.其实这些 component object 仍然关联到 scene 中的对象, 只不过这些对象使用了HideFlags.HideInHierarchy 来隐藏自己. 而CompanionLink组件则指向了这个隐藏对象, 接下来 CompanionGameObjectUpdateTransformSystem 则负责将 transform 复制到 game object 当中.和我们上面的 hack 几乎是一致的过程, 但是更加简洁和官方, 和 conversion system 的衔接也更加无缝.同时也兼容 prefab !Companion 的另一个好处是, 它完全支持 Prefab 转换流程, 并能  正常地实例化.这意味着每次实例化时, 从 MeshFilter和MeshRenderer 中得到RenderMesh会被高效地处理, 而遇到 CompanionLink指定的 component object 则创建有HideFlag的 game object. 并关联好相应的 Entity基本上, 这感觉就和 EntityManager.Instantiate 一样, 完美地实现了 ECS 版本的ParticleSystem.具体来说, 我们将飞船先变成一个 prefab asset. 然后在 Ship 组件正常引用子对象里的组件即可.我继续使用前面说到的魔法:进入 play mode 时, 我已经在 ShipAndCo上拥有一个 就绪的Prefabentity了, 由于我知道ShipAndCo是一个 singleton, 我们用如下系统来玩一玩: 每次我按下 A 键, 在0~10之间的随机位置上实例化该 Entity.我得到了一个正常支持 Entity 实例化的 companion particle systems, 很酷吧:截止到这里, companion game object 可以说是 conversion 过程的最后一块拼图了.","titles":[]},"970":{"title":"GameObjectConversionUtility","content":"如果前述的 convert and destroy 或者 convert and inject 规则你都不喜欢, 你完全可以使用下述static方法自行 convert.但你得先拿到 GameObject才行. ConvertToEntity之所以方便是因为你添加时就选择了该对象, 另外还有它的子层级(根据模式的不同). 而现在你只能传入  一个 GameObject 参数到这个方法中.root 自然是你想要 convert 的对象, 方法名字有 \"hierarchy\", 它知道如何处理这些情况:如果root 是 prefab asset, 那么你得到的结果和前述在 conversion 中声明 prefab 的结果一样. 如果你不喜欢声明和创建 prefab entity 绑定在一起, 那么你可以一个一个来.  如果root 是 scene 中的对象, 它会和ConvertToEntity的工作模式类似, 要注意这个方法同时也会执行LinkedEntityGroup过程.settings可以通过 destination world 来获得:如非特殊, Destination world 通常是 World.DefaultGameObjectInjectionWorld. ConvertToEntity就会在内部默认使用该值.BlobAssetStore我猜测是当你需要产生某些有BlobAssetReference字段的component时需要用到的东西, 目前你可以传入 null 或者 new BlobAssetStore , 但是记得要Dispose.GameObjectConversionUtility 其他有趣的方法和ConvertGameObjectHierarchy几乎一样, 只不过针对的是 scene 中所有的东西. 它不会添加LinkedEntityGroupbuffer, 除非scene中有被禁用的对象. (禁用行为参考前文).这个方法比给每个 scene 对象都加上ConvertToEntity 要高级一些, 后者你无法得到disabled entity 作为结果. 有 ConvertToEntity且被禁用的GameObject 的 Awake 方法不会被调用, 也就完全不会有 conversion 过程.这两个方法是什么? 第一个返回 World, 看起来像是 scene 中的内容可能会变化, 你可以用还未销毁的 conversion world 增量地 convert scene中新增的内容.这两个方法在 live link 系统中有被用到, 后文会解释.","titles":[]},"971":{"title":"Subscene","content":"因为 subscene 还处于开发中, 用法随时可能改变, 所以我计划先写到这里, 不过我会大致解释一下, 然后等 entities package 正式发布.现在你已经可以使用 GameObject 来编辑游戏, 在 ECS 的环境里运行了, 那么还缺点啥?你可能想要在  编辑模式 时查看 conversion 的结果, 无论你多么小心地设计 conversion 过程都有可能出错.  你太懒了, 不想复制粘贴ConvertToEntity, 或者使用 utility 里的 Scene 方法.  你想在发布游戏时, 游戏能预先转换好(  pre-converted ). 当加载 scene 时你就可以不用再重新运行转换过程, 而是加载 chunk 内存直接使用.  你懒得点\"序列化 ECS 内存\" 按钮来保存play mode下的内存供运行时使用, 更懒得添加内存加载的代码.  在 play mode 时, 你不想让这些 pure Entity 从 Hierarchy 窗口消失. (当然你也不想使用 inject 模式来实现, 这会导致重复绘制对象的问题). 在 inspector 快速查看和修改运行时的对象非常有用.你可能想要一边修改内容, 一边实时 convert 这些数据. (比如调整Transform后里面更新到 LocalToWorld/Translation)好消息是, 以上内容在 Subscene 里都是可行的! subscene 并不是比scene \"少\" 些东西, 而是被设计为可以嵌套进普通 scene 中的工具. 它的能力甚至比普通的 scene 要更强.让我们开始吧, 先创建一个 GameObject并添加Subscenecomponent. 这时候你会被告知需要添加一个新的 Scene asset 用来存放 subscene 的内容.你可以点击 \"Edit\" 来添加内容, 或者双击 scene asset 来打开 scene 进行修改 (这和常规的 scene 操作是一样的). 这里我添加了 2 个cube GameObject , 不过我不再需要ConvertToEntity了, scene 中的所有内容偶会被自动 convert (甚至还会警告你把已经没用的 ConvertToEntity 删掉).现在当你进入 play mode, 两个\"世界\"的好处都能获得. Hybrid Renderer负责渲染, tris 数量正常, 没有重复的对象出现.而且, 它们是  可被选中 的. 这意味着尽管已经被convert 并   destroy  了, 但不知为何点击 Hierarchy 的对象依然可以选中转换前的状态.相应地, 如果你点击 scene view 你也可以选中 Hierarchy 中的对象!你可能注意到上图中橙色的轮廓线不见了, 这时因为我开启了下面的选项:SceneView : Live Game State  意思是让 scene view 里面显示已经 convert 过的内容. 因此这时候 scene view 在使用 Hybrid Renderer 来渲染结果, 也无法显示那些橙色的轮廓线.SceneView: Editing State  则是让 scene view 在 play mode 时依然保持在 edit mode 时的状态, 这时候橙色轮廓线就能够显示了. 当然 cube 依然和 MeshFilter+MeshRenderer=RenderMesh设计地那样一样绘制. 但是如果 conversion 过程中将cube 染成了绿色, scene view 中将无法感知这一修改, cube 依然呈灰色.最上面的   Live Conversion in Edit Mode  指示在 edit mode 时的行为, 你可以选中它然后在 edit mode 看到 convert 的状态.   SceneView: Live Game State  开启而   Live Conversion in Edit Mode  保持禁用这种情况没什么用, 因为你本想要在scene view + edit mode 查看实时的游戏状态, 而同时你又禁止它这样做.如果你在 play mode 时移动 scene 中的 Transform (很可能因为 subscene 用预先转换的状态保持了 Hierarchy 的完整), 则会通过增量地重新转换(reconverted, diff-ed)无缝地更新到新状态, 这套机制就是   live link.比较 ConvertToEntity 和 Subscene下面两图中, 前者是通过 Subscene 进行转换, 后者则通过ConvertToEntity. 两者都是 destroy 模式, 所以MeshFilter这样的 component object 会被销毁:Subscene, 上方是 CubeInside, 下方是 CubeConvertToEntity, 上下同理EditorRenderData,EntityGuid,SceneSection,SceneTag是这里最大的区别. 除了EntityGuid, 其他三者都是 ISharedComponentData. 所以基本不用操心 chunk 碎片的问题, 基本上所有 subscene 里的对象都会得到同样的结果.ConvertToEntity或 subscene 都不会为层级结构添加LinkedEntityGroupbuffer, 但是因为 subscene 与 ConvertScene 方法的规则相同, 因此如果有被 disabled 的对象时, 它会添加LinkedEntityGroup.不是一次 conversion, 而是一个 scene!Unity 并不希望传达出\"subscene 是一堆ConvertToEntity的结果\"这样的观念, 这是一个真正的 scene.包括在调用SceneManager.LoadScene 时. 下面的例子中, GO 有一个ConvertToEntity, InSubScene1什么都没有但是位于 subscene 中:当进入 play mode 时, 两者都按照期望被转换了, Subscene 和ConvertToEntity 这时是等价的.但如果我们 SceneManager.LoadScene 改变当前的 scene:可以看到 subscene 里的 entity 同样被删除了, 但是正如ConvertToEntity名字所隐含的意义, 转换后就和 scene 没什么关系了, GO 依然存在. 这对于 entity 的生命周期管理很有帮助. ( 在进入 scene 前, 相关 system 无需做无用功)我猜想 DeclareDependency 应该对这个功能有所帮助.","titles":[]},"972":{"title":"BuildConfiguration","content":"他继承于scriptobject,他的扩展名是\".buildconfiguration\"导入的时候执行了编辑器脚本再看下他再unity中的编辑器显示该脚本定义了三个按钮  ,  ,如何建立从IBuildPipelineComponent组件中获取Pipeline..继承IBuildPipelineComponent接口的组件有  ,   关于platform,我们看下安卓建立的配置,可以看到手动实例化了  ,并且设置了platform","titles":[]},"973":{"title":"BuildPlayerStep","content":"我们看到他的最终执行仍然使用了API, UnityEditor.BuildPipeline.BuildPlayer(buildPlayerOptions);","titles":[]},"974":{"title":"關於深度緩衝 (Depth buffering, or z-buffering)","content":"勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解   Rasterization  怎麼透過   z-buffering  ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小與最後成像尺寸相同。在 Unity shader 中可利用    來切換是否將深度資訊要寫入到 z-buffer。如果場景中其他物件 rendering 時，也在同一個 pixel 位置渲染結果時，會檢查 z-buffer 所儲存的深度資訊，是否將渲染結果覆蓋原本的 pixel，並且將新的深度資訊寫入到 z-buffer。通常條件會設定為深度資訊比原本更接近攝影機時，就能夠覆蓋原本結果。在 Unity shader 中可利用    來調整判斷方式。有 z-buffering 機制，可不管物件算繪順序 (rendering order)，使得離攝影機越近的物件，永遠都描繪在其他離攝影機越遠的物件之前  (  )。房間示意圖房間的深度資訊，越深色表示離攝影機越近場景來源","titles":[]},"975":{"title":"Renderer’s rendering order","content":"假設 shader 中關閉深度機制的判斷 (  )，或者在 render 場景物件的過程中都不寫入深度 (  )，即  沒有 z-buffering 機制，rendering order 會決定成像的結果，越晚畫的物件永遠都在其他較早畫的物件之上 。而在 SpriteRenderer 直接修改 sorting layer 以及 order in layer 來改變 rendering order，就能調整該物件在算繪結果的物件前後，便是基於此緣故，更多細節可查看    shader 程式碼。故整理在 Unity 中，rendering order 是根據以下參數進行排序：  Camera depth > Material type > Sorting layer > Order in layer > Material render queue > Camera order algorithm 。Camera depth   數字越大越晚畫  通常無法搭配 Clear Flags: Don’t Clear，因為不會清除 depth buffer (z-buffer)  程式設定    選擇場景中的 camera 編輯     編輯 depth 參數  Material type   先畫不透明物件 (opaque)，再畫透明物件 (transparent)  根據 material render queue 來決定，數值小於等於 2500 為不透明物件，數值大於 2500 為透明物件  Sorting layer   數字越大越晚畫  大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯（不過自定義編輯器來達成）  程式設定    在 Tag Manager 編輯 Sorting layer     選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Sorting layer     Order in layer   數字越大越晚畫  大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯  程式設定    選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Order in layer     Material render queue   數字越大越晚畫  預設值會從 Shader 取得，但可自行定義  不透明物件 (Opaque)、半透明物件 (AlphaTest)、透明物件 (Transparent) 預設值分別 2000、2450、以及 3000   通常只有透明物件會關閉 ZWrite  程式設定    選擇專案中的 material 編輯     Camera render algorithm   無法在預設編輯器修改，使用程式調整  非透明物件排序演算法     Default：在 Unity 2018.1 預設值 FrontToBack  FrontToBack：粗略低由近到遠排序繪製，能使得 GPU rendering 時有更好的效能  NoDistanceSort：關閉排序繪製，能降低 CPU 的使用量  透明物件排序演算法     Default：根據 camera projection mode 調整  Perspective：根據 camera 位置到物件中心 (object center) 的距離排序  Orthographic：根據 view plane 到物件中心 (object center) 的距離排序  CustomAxis：制定 axis 排序，專門用於 2D 遊戲製作，可參考  這篇文章","titles":[]},"976":{"title":"补充RenderQueue","content":"nderQueue ，RenderQueue 其实就是shader中tags中的Queue默认情况下，Unity会基于对象距离摄像机的远近来排序你的对象。因此，当一个对象离摄像机越近，它就会优先绘制在其他更远的对象上面。对于大多数情况这是有效并合适的，但是在一些特殊情况下，你可能想要自己控制对象的绘制顺序。而使用Tags{}块我们就可以得到这样的控制。Unity提供给我们一些默认的渲染队列，每一个对应一个唯一的值，来指导Unity绘制对象到屏幕上。这些内置的渲染队列被称为Background, Geometry, AlphaTest, GeometryLast,Transparent, Overlay。这些队列不是随便创建的，它们是为了让我们更容易地编写Shader并处理实时渲染的。同时需在SubShader中显示声明ZWrite Off，通知Unity我们会重写物体的渲染深度排序。好了，最后给出一个最终的总结：\n依次按条件先后顺序进行排序渲染处理。先按大项条件排序，后按小项条件排序1.Camera Depth: 越小越优先\n2.RenderQueue 2500以下3.RenderQueue 2500以上\n1. Sorting Layer/Order in Layer\n1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n2.RenderQueue 越小越优先\n3.RenderQueue 相等，说明一下：2500是关键值，它是透明跟不透明的分界点，因此我们考虑层级的时候要注意着点：renderqueue > 2500的物体绝对会在renderqueue <= 2500的物体前面，即渲染时renderqueue大的会挡住renderqueue小的，不论它的sortingLayer和sortingOrder怎么设置都是不起作用的。知道了这点，其他的就很好理解了。当两个的RenderQueue都在同一侧时，在SortingLayer高的绝对会在sortingLayer前面，无视renderqueue跟soringOrder，只有在sortingLayer相同的前提下，soringOrder高的会在sortingOrder低的前面，无视renderqueue。当sortingLayer跟sortingOrder相同时，才看renderqueue的高低，高的在前面。特别要注意一下半透明物体的渲染顺序是  ，这与不透明物体是相反的。UGUI中的ui默认使用的是UI/Default 材质，对应的shader中的渲染队列是Transparent","titles":["Renderer’s rendering order"]},"977":{"title":"UGUI’s rendering order","content":"在 Unity 5.x 推出的 UGUI 系統中，其 rendering order 卻是另外規則，這分成兩個部分探討 Canvas & CanvasRenderer，其概念可想像是 CanvasRenderer 可視為畫在畫布 Canvas 的元件，之後該畫布再畫在最終的畫面上（e.g. render target）。關於 Canvas 的 rendering order：Screen Space - Overlay   想像該 canvas 由隱藏的 camera 處理，其 depth = 101 (最後才處理)  多個相同的 canvas 使用 Sort Order 來決定描繪順序，數字越大越晚畫     Screen Space - Camera & World Space   想像為存在在世界場景的平面  多個相同 canvas 使用 Sorting layer 以及 Order in layer 來決定 rendering order關於同一個 canvas 下，其 CanvasRenderer 之間的 rendering order：Material render queue > Transform order   Material render queue 同前面說明，看材質球 (material) 的 render queue 參數  Transform order：依照 Transform 階層關係，採 Pre-order 方式排序     注意：當所屬的 Canvas 之 render mode 為 Screen Space - Overlay，則無視 Material render queue","titles":["Renderer’s rendering order"]},"978":{"title":"使用實踐情境","content":"3D   不透明物件 & 半透明物件 (e.g. 草、鐵絲網等等) 依照場景擺放   不需要特別設定 rendering order  一切交給 z-buffering 機制  透明物件或是粒子特效 (particle system) 可透過 sort layer & order in layer 機制調整 rendering order   透明物件 shader 通常不會寫 z-buffer (e.g.   )  可 hack inspector 來設定    以及    2D   Sprite renderer 使用 sort layer & order in layer 機制來調整 rendering order，以控制 depth  UGUI   利用 transform hierarchy 來建立 rendering order，因應效能優化可能還得拆成多個 canvas  若採用 Canvas render mode: World space，想讓 UI 與 3D 場景物件的結合，可將 canvas 視為 3D 物件去設計場景架構 (這自己就沒有經驗…)","titles":["Renderer’s rendering order"]},"979":{"title":"静态批处理[  1]","content":"定义标明为 Static 的静态物件，如果在使用  相同材质球 的条件下，在**Build（项目打包）**的时候Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次Draw call分别绘制每一个子模型。Static batching并**不减少Draw call的数量（**但是在编辑器时由于计算方法区别Draw call数量是会显示减少了的[  2] ），但是由于我们预先把所有的子模型的顶点变换到了世界空间下，所以在运行时cpu不需要再次执行顶点变换操作，节约了少量的计算资源，并且这些子模型共享材质，所以在多次Draw call调用之间并没有渲染状态的切换，渲染API（Command Buffer）会缓存绘制命令，起到了渲染优化的目的 。但Static batching也会带来一些性能的负面影响。Static batching会导致应用打包之后体积增大，应用运行时所占用的内存体积也会增大。另外，在很多不同的GameObject引用同一模型的情况下，如果不开启Static batching，GameObject共享的模型会在应用程序包内或者内存中只存在一份，绘制的时候提交模型顶点信息，然后设置每一个GameObjec的材质信息，分别调用渲染API绘制。开启Static batching，在Unity执行Build的时候，场景中所有引用相同模型的GameObject都必须将模型顶点信息复制，并经过计算变化到最终在世界空间中，存储在最终生成的Vertex buffer中。这就导致了打包的体积及运行时内存的占用增大。例如，在茂密的森林级别将树标记为静态会严重影响内存[  3] 。无法参与批处理情况改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。相同材质批处理断开情况位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。  拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行同批处理（除非他们指向lightmap的同一部分）。流程原理","titles":[]},"980":{"title":"动态批处理[  4]","content":"定义在使用  相同材质球 的情况下，Unity会在运行时对于  正在视野中 的符合条件的动态对象在一个Draw call内绘制，所以  会降低Draw Calls 的数量。Dynamic batching的原理也很简单，在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中，然后通过一次Draw call绘制多个模型，达到合批的目的。模型顶点变换的操作是由CPU完成的，所以这会带来一些CPU的性能消耗。并且计算的模型顶点数量不宜太多，否则CPU串行计算耗费的时间太长会造成场景渲染卡顿，所以Dynamic batching只能处理一些小模型。Dynamic batching在降低Draw call的同时会导致额外的CPU性能消耗，所以仅仅在合批操作的性能消耗小于不合批，Dynamic batching才会有意义。而新一代图形API（ Metal、Vulkan）在批次间的消耗降低了很多，所以在这种情况下使用Dynamic batching很可能不能获得性能提升。Dynamic batching相对于Static batching不需要预先复制模型顶点，所以在内存占用和发布的程序体积方面要优于Static batching。但是Dynamic batching会带来一些运行时CPU性能消耗，Static batching在这一点要比Dynamic batching更加高效。无法参与批处理情况物件Mesh大于等于900个面。  代码动态改变材质变量后不算同一个材质，会不参与合批。  如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体，否则都无法参与合批。  改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。批处理中断情况位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。  物体如果都符合条件会优先参与静态批处理，再是GPU Instancing，然后才到动态批处理，假如物体符合前两者，此次批处理都会被打断。  GameObject之间如果有镜像变换不能进行合批，例如，\"GameObject A with +1 scale and GameObject B with –1 scale cannot be batched together\"。  拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。  使用Multi-pass Shader的物体会禁用Dynamic batching，因为Multi-pass Shader通常会导致一个物体要连续绘制多次，并切换渲染状态。这会打破其跟其他物体进行Dynamic batching的机会。  我们知道能够进行合批的前提是多个GameObject共享同一材质，但是对于Shadow casters的渲染是个例外。仅管Shadow casters使用不同的材质，但是只要它们的材质中给Shadow Caster Pass使用的参数是相同的，他们也能够进行Dynamic batching。  Unity的Forward Rendering Path中如果一个GameObject接受多个光照会为每一个per-pixel light产生多余的模型提交和绘制，从而附加了多个Pass导致无法合批，如下图:可以接收多个光源的shader，在受到多个光源是无法合批流程原理","titles":[]},"981":{"title":"GPU Instancing","content":"定义在使用  相同材质球、相同Mesh(预设体的实例会自动地使用相同的网格模型和材质)的情况下，Unity会在运行时对于 正在视野中的符合要求的所有对象使用  Constant Buffer [  5] 将其位置、缩放、uv偏移、  lightmapindex 等相关信息保存在显存中的**“统一/常量缓冲器”  [   6]  中，然后从中抽取一个对象作为实例送入渲染流程，当在执行DrawCall操作后，从显存中取出实例的部分共享信息与从GPU常量缓冲器中取出对应对象的相关信息一并传递到下一渲染阶段，与此同时，不同的着色器阶段可以从缓存区中直接获取到需要的常量，不用设置两次常量。比起以上两种批处理，GPU Instancing可以 规避合并Mesh导致的内存与性能上升**的问题，但是由于场景中所有符合该合批条件的渲染物体的信息每帧都要被重新创建，放入“统一/常量缓冲区”中，而碍于缓存区的大小限制，每一个Constant Buffer的大小要严格限制（不得大于64k）。详细请阅读：Testplus：U3D优化批处理-GPU Instancing了解一下zhuanlan.zhihu.com无法参与加速情况缩放为负值的情况下，会不参与加速。  代码动态改变材质变量后不算同一个材质，会不参与加速，但可以通过将颜色变化等变量加入常量缓冲器中实现[  7] 。  受限于常量缓冲区在不同设备上的大小的上限，移动端支持的个数可能较低。  只支持一盏实时光，要在多个光源的情况下使用实例化，我们别无选择，只能切换到延迟渲染路径。为了能够让这套机制运作起来，请将所需的编译器指令添加到我们着色器的延迟渲染通道中。当在多个光源开启GPU Instancing批处理中断情况位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。  一个批次超过125个物体（受限于常量缓冲区在不同设备上的大小的上限，移动端数量有浮动）的时候会新建另一个加速流程。  物体如果都符合条件会优先参与静态批处理，然后才到GPU Instancing，假如物体符合前者，此次加速都会被打断。流程原理","titles":[]},"982":{"title":"SRP Batcher[  8]","content":"定义在使用LWRP或者HWRP时，开启SRP Batcher的情况下，只要物体的  Shader中变体 一致，就可以启用SRP Batcher加速。它与上文GPU Instancing实现的原理相近，Unity会在运行时对于正在视野中的符合要求的所有对象使用**“Per Object” GPU BUFFER（一个独立的Buffer）** 将其位置、缩放、uv偏移、  lightmapindex 等相关信息保存在GPU内存中，同时也会将正在视野中的符合要求的所有对象使用  Constant Buffer [  5] 将材质信息保存在保存在显存中的**“统一/常量缓冲器”  [   6]  中。与GPU Instancing相比，因为数据不再每帧被重新创建，而且需要保存进“统一/常量缓冲区”的数据排除了各自的位置、缩放、uv偏移、  lightmapindex 等相关信息，所以缓冲区内有更多的空间可以动态地**存储场景中所有渲染物体的材质信息。由于数据不再每帧被重新创建，而是动态更新，所以SRP Batcher的本质并不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本。因为不用重新创建Constant Buffer，所以本质上SRP Batcher不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本无法参与加速情况对象不可以是粒子或蒙皮网格。  Shader中  变体 不一致，如下图两个  相同Shader 的材质，但是因为Surface Options不一致，导致  变体不一样 而无法合并。变体不同的不同材质批处理中断情况位置不相邻且中间夹杂着  不同Shader ，或者  不同变体 的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。流程原理","titles":[]},"983":{"title":"2020年2月13日-更新： 更改对”统一/常量缓冲器“的描述，对SRP Batcher与GPU Instancing的实现原理进行了比较大的修改。","content":"^ ^ 以上只是我工作中的一些小总结  有什么不正确的地方可以在评论告诉我  我的微信号是：sam2b2b  有想一起进步的小伙伴可以加微信逛逛圈","titles":[]},"984":{"title":"参考","content":"^  https://gameinstitute.qq.com/community/detail/114323   ^  https://forum.unity.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/   ^  https://docs.unity3d.com/Manual/DrawCallBatching.html   ^  https://gameinstitute.qq.com/community/detail/114323  ^  a  b Constant Buffer   https://zhuanlan.zhihu.com/p/35830868  ^  a  b unity将常量存储在4M的缓冲池里，并每帧循环池（这个池子被绑定到GPU上，可以在截帧工具比如XCode或者Snapdragon上看到）   ^  https://blog.csdn.net/lzhq1982/article/details/88119283   ^ SRP Batcher 官方文档：   https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw","titles":[]},"985":{"title":"1. 使用SystemStateComponent","content":"","titles":[]},"986":{"title":"原理","content":"所谓State，含义是只能被手动删除的Component，在删除Entity后，依然留下做一些殿后工作，只有被指名要求删除的时候才会被删除。这种特性就让我们可以通过不同的Query去获得结构变化的消息。","titles":[]},"987":{"title":"栗子","content":"假设我们有一个Entity，身上有两个组件，A：IComponentData 与 B: ISystemStateComponentData  当我们添加A组件的时候，通过Filter{ 有A无B }，我们可以在别处得知这个Entity何时被添加。在添加后手动加入B组件。  当我们删除Entity，或者移除A组件的时候，通过Filter { 有B无A }，同理可得知何时这个Entity被移除或是A组件被移除。更具体的实现可以在查看官方对于ParentSystem的设计。","titles":[]},"988":{"title":"2. 查询ComponentVersion","content":"每当出现某Component相关的结构性变化的时候，该Component的版本就会+1 。","titles":[]},"989":{"title":"数据变化","content":"顾名思义。方法有三种。","titles":["2. 查询ComponentVersion"]},"990":{"title":"1. Chunk检查","content":"","titles":["2. 查询ComponentVersion","数据变化"]},"991":{"title":"原理","content":"查看其内部实现什么意思呢？GlobalSystemVersion为记录一个世界所有系统更新信息的版本号。在每一个系统更新  之前 ，GSV++。  LastSystemVersion为系统记录自己的版本号。在某系统更新  之后 ，它会保存GSV，含义是  上次 运行时的版本号，直到下次某系统更新之后，它的版本号不会更改  每一种Component，在System申请写入权限的时候，都会记录该System的LSV 获取方式为chunk.GetArch因此，if ( ComponentVer > LSV ) 就说明该Component被修改了（有系统获得了写入权限）。翻译成大白话，就是Component是否在提供的版本号之后的时间被更新？在当前系统请求LSV的结果是上一帧该系统的版本号，如果Component被写入时的版本号大于该系统上一帧的版本号，就说明Component在此时至上一帧的某个时间点被写入。由于这个Component只有在遍历的时候申请写入权限时才会记住版本号，因此EntityManager手动更新信息是不会被记录的。  这个信息时效性只有一帧，从上次该系统更新后到这次更新后的一帧，因此在这次更新中，修改Component后查询是否改变，答案是True，反之为False。","titles":["2. 查询ComponentVersion","数据变化"]},"992":{"title":"举例","content":"系统的更新顺序为A->B->C->A  那么GSV ：0 -> 1 -> 2 -> 3，每个系统更新之前+1  当数据在B系统被写入，Component就记住了B的GSV = 1  当我们在第二次轮到A系统的时候监测是否Component被改动，DidChange自动使用A系统上次的GSV记录 LSV = 0 与 Component记录的信息CV = 1做对比，发现CV > LSV，得知信息已经被更改了，返回True。","titles":["2. 查询ComponentVersion","数据变化"]},"993":{"title":"API","content":"注意LSV应从EntityManager.LastSystemVersion取得，并传入Job","titles":["2. 查询ComponentVersion","数据变化"]},"994":{"title":"2. Query自动检查","content":"在声明Query的时候，特别注明这样Query就会把没被修改的ComponentType排除在外。注意，这种检查是Component层级，而不是单个Entity层级的。","titles":["2. 查询ComponentVersion","数据变化"]},"995":{"title":"3. IJobForEach中使用 [ChangeFilter]","content":"与Query的排除效果类似。","titles":["2. 查询ComponentVersion","数据变化"]},"996":{"title":"示例","content":"","titles":["2. 查询ComponentVersion","数据变化"]},"997":{"title":"Best Practice","content":"对自己的系统做了一些单元测试后，我觉得有几点应该记录下来。如果要做一套响应式系统循环触发，慎用EntityManager获取信息。因为EntityManager的Get系列API会直接获取写入权限。  Job有延迟，因此单元测试的时候，如果涉及Version，应该做一些操作“等待”正确的版本号刷新，比如Debug.Log()。  GetEntityQuery会在系统注册，因此在Query里SetFilterChanged即可，毋需在Execute()中再声明一遍。  在主线程获取DynamicBuffer的长度时，Query与EM都不能做到以只读方式做到。因此正确的做法是","titles":["2. 查询ComponentVersion"]},"998":{"title":"Reference","content":"https://gametorrahod.com/designing-an-efficient-system-with-version-numbers/Using IJobChunk | Package Manager UI websiteCoping with Change in Unity3D ECS | by Maxim Zaks | MediumHow to build reactive systems with Unity ECS: Part 1 • Effective Unityhttps://www.effectiveunity.com/ecs/07-how-to-build-reactive-systems-with-unity-ecs-part-2/","titles":["2. 查询ComponentVersion"]},"999":{"title":"关于转换系统","content":"ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject最终调用的时候是使用.然后具体的转换过程会新疆一个转换world主要执行GameObjectConversionMappingSystem,然后转换完成后销毁这个worldGameObjectConversionUtility.ConvertGameObjectHierarchy(unitView.gameObject, settings)会转换所有child.  GameObjectConversionMappingSystem.conversion.MappingSystem.AddGameObjectOrPrefab(root);会递归所有child","titles":[]},"1000":{"title":"parent","content":"localtoworld是一个矩阵如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:使用  ,  ,  /  组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个    组件指向了父 Entity, 那么最终该 Entity 的    值将会和父 Entity的 LocalToWorld 一样.我们新建一个场景查看分析器.就能看到如下关系图CUBE     ,   SPHER    ,   ,由于物理的转化规则,子物体没有physicscollider.","titles":[]},"1001":{"title":"LinkedEntityGroup","content":"是一个 dynamic buffer , 通常它会影响:调用  方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的  . 注意实例化并不一定和ECS中的   component 直接关联.  调用  时也会同时销毁   中的所有 entity. 类似在编辑器中删除   调用    加上的   component 会告知 ECS 的查询系统忽略它们, 而    中的 entity 也会受到同样的影响. 有点类似禁用   时同时会禁用整个层级树.注意如果buffer 中的 entity 也有  , 系统  不会递归地 执行instantiation/destroy/disabled 过程.这些过程在具体执行当中也有一些细微不同.  和  只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity   必须要把自己包括在内 才能正常工作**.** 然而  则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.要注意   和   并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.","titles":["parent"]},"1002":{"title":"从非 prefab conversion 中获取LinkedEntityGroup","content":"目前, 我们使用  并不能得到   . 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. (  却可以正常得到基于   的层级结构).如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果).从 debbuger 现在可以看到已经正常添加了  , 目前它已经支持  和   的正常工作了:LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.","titles":["parent"]},"1003":{"title":"关于手动添加  LinkedEntityGroup","content":"如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用.","titles":["parent"]},"1004":{"title":"关于parent和  LinkedEntityGroup","content":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则  linkedEntityGroup 和           有关被disable的组件不会被foreach到,除非主动申请选取disable","titles":[]},"1005":{"title":"最佳的方式去关联entity和prefab","content":"[  Hybrid ECS] Best way to handle Convert and Inject Game Object Prefab? - Unity ForumUnity Tech - Where is the SIMPLE Bridge Between MonoBehaviours and ECS?? - Unity Forum","titles":[]},"1006":{"title":"ability","content":"首先ability总是和item或者character结合在一起的以下Authoring 会为ability加上不同的组件AbilityAutoRifleAuthoring  AbilityMovementAuthoring  AbilitySprintAuthoring  AbilityDeadAuthoring  AbilitySelectSlotAuthoring  AbilityMeleeAuthoring","titles":[]},"1007":{"title":"AbilityCollection","content":"是一个IBufferElementData.存储了多个ability定义了技能类型,能和什么类型一起运行,会打断什么类型一个技能可能会有多个触发button,比如一把枪,会有开火键和装弹键UpdateAbilityOwnership系统.. 填充character的OwnedCollection组件.分别为自己和item再根据OwnedCollection填充ownedAbilitiesPrepareOwnerForAbilityUpdate系统检查ability是否启用.未启用则删除SelectActiveBehavior系统选择激活一个ability","titles":["ability"]},"1008":{"title":"Item","content":"Item.Initialize会查找所有拥有(Inventory.ItemEntry)的实体(就是character)然后将item添加到character的Inventory.ItemEntry组件的buff中.将item和character关联起来Inventory.update系统比较activeslot和lastactiveinventoryslot.来在item上添加和删除PartOwner.Visible组件","titles":[]},"1009":{"title":"Character","content":"","titles":[]},"1010":{"title":"part","content":"Part 模块是抽象\"部分关系\"的一种存在, 不过具体到实现来说, 就是可以用来管理角色模型, 武器模型(以及其LOD), 以角色配置为例说明下述具体用法同样的item和character都可以拥有part","titles":[]},"1011":{"title":"local player","content":"首先看  然后我们就知道.一个character到底有哪些东东了//Assets/Unity.Sample.Terraformer/Prefabs/Characters/Terraformer/Char_Terraformer.prefabSpawnCharacterItemAuthoring","titles":[]},"1012":{"title":"palyer 实例化流程","content":"客户端连接的时候,服务端PlayerModuleServer.CreatePlayerEntity 创建player实体  服务端根据GameMode,创建角色GameModeSystemServer.Update()  客户端创建localplayer.并根据系统将localplayer和character和player进行绑定","titles":[]},"1013":{"title":"NetworkStreamReceiveSystem","content":"客户端连接服务端  ,服务端创建NetworkIdComponent  客户端添加NetworkStreamInGame组件,并通过rpc 发送GoInGameRequest请求  服务端接收到请求后,实例化player   为player添加GhostOwnerComponent  初始化player添加一些其他不需要同步的组件  为connection添加NetworkStreamInGame组件  为connection设置CommandTargetComponent  客户端根据player独有的组件特性,查找已经被ghost同步过来的实体   比对NetworkIdComponent和GhostOwnerComponent的id,判断是否是localPlayer  对localplayer进行初始化  为connection设置CommandTargetComponent为localplayer  客户端使用CommandTargetComponent的targetEntity进行command发送  客户端和服务端对传送的command同时使用PredictedGhostComponent进行预测????   预测不是发生在客户端的吗???貌似netcode服务端也做了预测  在服务器上，预测循环始终仅运行一次，并且不会更新TimeData结构，因为它已经正确。它仍然设置GhostPredictionSystemGroup.PredictingTick以确保可以在客户端和服务器上运行完全相同的代码。插值 是针对其他玩家的本地显示...预测是针对自己操作的角色,最后从服务器校正延迟补偿是服务器在做的一件事情..GhostReceiveSystem  接收快照GhostUpdateSystem  应用快照     设置了predictionStartTick和AppliedTickGhostPredictionSystemGroup   设置了 PredictingTick ,服务端永远为ServerSimulationSystemGroup.servertick=======================================================================客户端的servertick在不同的两帧之间可能是相同的servertick    235PredictingTick    230PredictingTick    231PredictingTick    232PredictingTick    233PredictingTick    234PredictingTick    235servertick    240  因为跑预测所以这里可能过了好几帧servertick这里不是236PredictingTick    240  //自己先跑一下servertick    240 //又可能tick增长时间还没有过PredictingTick    238PredictingTick    239PredictingTick    240实际上没多大复杂的事情..客户端发送命令给服务端,服务端处理后将tick和数据同步给客户端...客户端拿到数据..该预测的预测..该插值的插值...然后还需要处理这帧的自己的命令...客户端:Ghost数据(服务端传送的同步)--预测---输入命令--发送命令给服务端---处理命令----覆盖同步数据(一般是覆盖自己的)--应用数据(位移,动画等)服务端:服务端接收到命令---处理命令----写入Ghost数据(同步)--应用数据(位移,动画等)","titles":[]},"1014":{"title":"预测","content":"输入的时候, 添加发送给服务器时的servertick ,注意这个servertick和ServerSimulationSystemGroup.servertick没有多大关系.m_ClientSimulationSystemGroup.ServerTick标记发送给服务器的命令所在的tick,以及用来接收服务器快照后(快照会包含该tick),丢弃执行过的命令,以及预测未执行的命令使用客户端使用服务端的快照时,将更新PredictedGhostComponent,可以看到他有两个tick,一个是应用tick,一个是预测开始的tick服务端PredictedGhostComponent其中AppliedTick和PredictionStartTick永远为0让我们看下GhostPredictionSystemGroup的源代码:可以看到从开始值不断的改变PredictingTick进行预测,然后执行了base.OnUpdate()","titles":["NetworkStreamReceiveSystem"]},"1015":{"title":"插值","content":"插值就是将网络玩家显示在过去的某个时刻假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。","titles":[]},"1016":{"title":"Translation和Rotation的转换","content":"Unity.NetCode.Editor.GhostAuthoringComponentEditor中添加了Translation和Rotation的转换,只有被转换的才会被传输..如果不想转换可以在code gen window中勾掉Unity.Transforms..auto compile也勾掉我们可以看到这里使用了GhostFiled并且将其设置为Interpolate..我们在看下他生成的code我们看到在读取快照的时候使用了snapshotInterpolationFactor进行插值,SnapshotData类中在其中计算了InterpolationFactor.无论是插值和预测都是先读取快照.我们看下GhostUpdateSystem预测使用的是predictedTargetTick,插值使用的是interpolatedTargetTick而他们又都来自m_ClientSimulationSystemGroup,m_ClientSimulationSystemGroup的tick又来自NetworkTimeSystem","titles":["插值"]},"1017":{"title":"ClientServerTickRate","content":"RpcSetNetworkId服务端在同步networkid的时候会一起同步ClientServerTickRate客户端会比服务端多一个NetworkTimeSystem根据往返时间和最近从服务器收到的快照来计算服务器时间的初始估计来看下插值tick的计算..他首先是算出predictTargetTick然后减去一个插值它是根据网络延迟算出一个tick,然后从快照中取出...","titles":["插值"]},"1018":{"title":"补偿","content":"","titles":[]},"1019":{"title":"GhostSendSystem","content":"以下皆为脑补:发送的时候根据ghost的设置,来判断发送给该用户的数据(ghosts),其中谁是插值,谁是预测..因为插值和预测的包应该是有区别的..接收的时候再根据是否预测,还是插值.进行PredictedGhostComponent的设置","titles":[]},"1020":{"title":"GHOST","content":"GhostAuthoringComponent验证的时候会生成prefabIdGhostAuthoringConversion,会为prefab根据client和server添加各种组件ghost, Snapshot默认一定会添加的组件:客户端会添加 snapshotData和snapshotDataBuffer服务端会添加PredictedGhostComponent,GhostSystemStateComponent,sharedGhostTypeComponent[GhostComponent(PrefabType=GhostPrefabType.Client)] 可以控制服务端和客户端是否添加该组件他会同步ghost prefab..根据ghostid..然后客户端.根据ghostid实例化ghost","titles":["GhostSendSystem"]},"1021":{"title":"启用 堆栈跟踪","content":"单击 Unity 菜单中的 Jobs > Leak Detection > Full Stack Traces 以选中它。还有记得重启unity然后，控制台中的错误内容将显示内存  泄漏 发生在数据保留位置。","titles":[]},"1022":{"title":"关于分配器","content":"NativeContainer（如 NativeArray）在 Dispose 中未释放内存时，会根据某些条件  检测 为内存泄漏。 条件  因分配器 的类型而异，分配器是 Allocator.TempJob，在确保本机 Array 时指定。这是一个详细的解释。NativeContainer - Unity 手册如果 Allocator.Temp 在函数中没有 Dispose， 否则内存  泄漏 ，确定 Allocator.TempJob 必须在\n4 帧内释放， 否则内存  泄漏确定 __Allocator.Persistent 将永久保留，  并且不会 检测到内存泄漏。","titles":["启用 堆栈跟踪"]},"1023":{"title":"用 using 括起来，确保内存安全","content":"知道泄漏的位置后，我们只是将变量放在 Dispose 中，但**建议在 using  语句 **中括起来。这样，当您离开块时，将自动释放变量。\n当有多个变量时，请并排排列它们。从 C# 8 开始，您可以在 Coco 中并排编写句点，但 Unity 现在  像 C# 7.3 一样，将来会起作用吗？","titles":["启用 堆栈跟踪","关于分配器"]},"1024":{"title":"使用射线","content":"这是一种发射线，获取当前点击的物体（具有碰撞器）的坐标点（也就是碰撞器范围的坐标点）","titles":[]},"1025":{"title":"直接转换","content":"摄像机对游戏世界的渲染范围是一个平截头体，渲染边界是一个矩形，用与near clippingplane或者far clippingplane平行的平面截取这个平截头体，可以获得无数个平行的矩形面，也就是我们看到的屏幕矩形。离摄像机越远，矩形越大，离摄像机越近，矩形越小。所以，同样大小的物体，随着离摄像机越来越远，相对于对应屏幕矩形就越来越小，所看起来就越来越小。在屏幕上，某个像素点相对于屏幕矩形的位置，可以对应于游戏世界中的点相对于某个截面的位置，关键在于这个点在哪个截面上，也就是说，关键在于这个截面离摄像机有多远！在ScreenToWorldPoint这个方法中，参数是一个三维坐标，而实际上，屏幕坐标只能是二维坐标。参数中的z坐标的作用就是：用来表示上述平面离摄像机的距离。也就是说，给定一个坐标（X，Y，Z），首先截取一个垂直于摄像机Z轴的，距离为Z的平面P，这样不管X，Y怎么变化，返回的点都只能在这个平面上；然后，X，Y表示像素坐标，根据（X，Y）相对于屏幕的位置，得到游戏世界中的点相对于截面P的位置，我们也就将屏幕坐标转换为了世界坐标。所以如果要判断是否点中一个目标,则传入的z的值即你想选中的目标到摄像机的距离","titles":[]},"1026":{"title":"B站圈毛君翻译教程：","content":"","titles":[]},"1027":{"title":"The Basic：  https://www.bilibili.com/video/av48965588/","content":"","titles":[]},"1028":{"title":"Rule Tile：  https://www.bilibili.com/video/av49083381/","content":"","titles":[]},"1029":{"title":"Prefab Brush：  https://www.bilibili.com/video/av49098444/","content":"","titles":[]},"1030":{"title":"Tilemap Collider：  https://www.bilibili.com/video/av49115670/","content":"","titles":[]},"1031":{"title":"TileBase","content":"确定瓦片在瓦片地图上的外观 ,相当于滚动列表中的getdata..获取数据用于显示,,RefreshTile后会触发","titles":[]},"1032":{"title":"1. UGUI上显示模型","content":"UGUI上显示模型.png创建拍摄用的摄像机  创建RenderTexture并绑定到摄像机camera.targetTexture上  RenderTexture绑定到rawImage.texture上（rawImage见上图）  创建显示的模型，相机可见  注意Destroy销毁 创建出来的RenderTexture 和相机  注意模型上的粒子特效由于Alpha透明通道，显示会有一点问题，可以通过Shader Blend混合处理，挂载在rawImage上。","titles":[]},"1033":{"title":"2. Camera相机拍照分享，保存为jpg","content":"Rendertexture的分配和销毁上有一个地方需要注意：\n如果频繁的要new一个rt出来，那么不要直接new，而是使用RenderTexture提供的GetTemporary和ReleaseTemporary，它将在内部维护一个池，反复重用一些大小格式一样的rt资源，因为让GPU为你分配一个新的texture其实是要耗时间的。  EncodeToJPG 生成的图片体积更小  有的时候我们想人为的控制每一次渲染，你可以将这个摄像机disable掉，然后手动的调用一次render。","titles":[]},"1034":{"title":"3. 制作小地图","content":"这里需要新建一个Layer。依次点击菜单项Edit -> Project Settings -> Tags and Layers新建Layer命名为Minimap。然后新建三个球体。一个设为蓝色代表Unity Chan。将该球体设为Unity Chan的子对象，并将其Layer设为Minimap。对两个机器人进行同样的操作，将球体改为红色。现在最关键的一步来了！选中Main Camera并确保其Culling Mask中不包括Minimap这一层。然后选中Minimap Camera让其Culling Mask只包括Minimap这一层。现在这个小地图看起来就比较完善了！","titles":[]},"1035":{"title":"实际测试","content":"测试之前首先明确两点：什么因素影响绘制顺序  深度缓冲区对绘制结果的影响为了弄清楚第一点，什么因素影响绘制顺序，我们需要把 ZWrite 关闭。同时结合 Unity Frame Debugger来观察绘制顺序。","titles":[]},"1036":{"title":"Render Queue","content":"RenderQueue 是材质（Material）的关键属性，当我们在 Unity 中创建一个材质后，Unity 会给这个材质设置一个默认 Shader，然后这个材质的 RenderQueue 被改为其 Shader 中设定的 RenderQueue。如果给这个材质球换了 Shader，Unity 会更新它的 RenderQueue（但是请注意，假如当前材质的 Shader 的 RenderQueue 是 3000，然后你修改 Shader 让其 RenderQueue 变成 3100，对应材质球的 RenderQueue 并不会更新！）。Unity 最终以 Material 的 RenderQueue 为准。Unity 内置了几个 RenderQueue 的字面值：RenderQueue  值  说明    Background  1000  这个渲染队列最先渲染，一般用于渲染背景   Geometry(默认值)  2000  这个渲染队列是大多数物体的默认队列，用于渲染不透明物体   AlphaTest  2450  使用了 AlphaTest 的物体在这个队列渲染，当所有的不透明物体都渲染完了再渲染这个，有助于提升性能   Transparent  3000  在 Geometry 和 AlphaTest 之后、从后往前渲染，所有的半透明物体都应该在这里渲染   Overlay  4000  在之前的所有渲染队列都渲染完了之后渲染，比如镜头光晕可以看到，RenderQueue 越大，渲染越靠后。","titles":["实际测试"]},"1037":{"title":"Camera.opaqueSortMode","content":"默认情况下，不透明物体被放在粗略分隔的从前往后排布的桶中，GPU 按照这种方式渲染能节省性能。但是也有部分 GPU 不这么干，比如 PowerVR。Camera.opaqueSortMode 这个值的默认值是 Dafault，根据不同硬件平台，这个值有可能是：OpaqueSortMode.FrontToBack 或者 OpaqueSortMode.NoDistanceSort。我们也可以主动设置这个值为某一种。比如为了减少 CPU 消耗，把这个值设置为 NoDistanceSort。所以，不透明物体大部分情况下是按照从前往后渲染，也就是离相机越近，越先渲染。如果是手动选择了 FrontToBack，就是从前往后渲染；如果是 NoDistanceSort，就是从后往前渲染。根据实际测试，渲染的顺序并不是完全按照物体几何中心离相机的距离进行排序，而是一个近似的排序。","titles":["实际测试"]},"1038":{"title":"Camera.transparencySortMode","content":"按照我测试用的 Unity5.3.4f1，修改这个值也会影响不透明物体的渲染顺序。所以这个东西很可能不重要，而且有 bug。","titles":["实际测试"]},"1039":{"title":"SortingLayer","content":"SortingLayer 拥有最高优先级，如果 SortingLayer 不同，则首先按照 SortingLayer 排序；如果 SortingLayer 相同，再按照 RenderQueue 排序。如下图所示，有 6 个立方体，分别按顺序在摄像机前排开：其中，g1 组的立方体 SortingLayer 都是 Layer3，RenderQueue 都是 3000；g2 组的立方体 SortingLayer 都是 Layer2，RenderQueue 都是3500，最终渲染顺序是：  g2m1 g2m2 g2m3 g1m1 g1m2 g1m3 。直观地说，就是 SortingLayer 越大，则物体  层级 越高。SortingLayer 默认只有一个：Default，越往后添加的 SortingLayer 越大。现在把 g1 组的立方体 SortingLayer 改成 Layer2，RenderQueue 改成 3600，最终渲染顺序还是：  g2m1 g2m2 g2m3 g1m1 g1m2 g1m3 。直观地说，SortingLayer 相同的前提下，RenderQueue 越大，则物体  层级 越高。","titles":["实际测试"]},"1040":{"title":"SortingOrder","content":"如果 SortingLayer 和 RenderQueue 都一样，则 SortingOrder 越大，则物体  层级 越高。如果只是 SortingLayer 一样，RenderQueue 和 SortingOrder 都不一样，则物体的  层级 由 RenderQueue 和 SortingOrder 之和决定，相加之和越大，  层级 越高。以上结论是通过 Frame Debugger 单步执行得出的。","titles":["实际测试"]},"1041":{"title":"Camera.depth","content":"还有一个很常用的调整渲染顺序的选项：摄像机深度。摄像机深度是优先级最高的选项，深度值越大，物体  层级 越高。常用的比如 NGUI 就是用一个单独的相机（深度值比渲染场景的相机大）来渲染 UI，这样就保证 UI 在所有东西上方。参考资料：Transparency and sorting in Unity","titles":["实际测试"]},"1042":{"title":"定义实体和组件","content":"SemanticObject  为gameobject添加各种component  Traits : 相当于component.可以定义各种属性","titles":[]},"1043":{"title":"定义处理系统","content":"Problem  依托 DecisionController运行计划  StateTermination  为Problem  提供中止条件  SemanticQuery   根据query为 DecisionController提供实体  Action : 相当于一个特殊的system的基类.他定义了参数,和处理条件.以及effects和reward,但是没有实现具体的方法(executionInfo),executionInfo是需要手动定义的","titles":[]},"1044":{"title":"actions","content":"motives  相当于 preconditions   ..需要一些设定才会执行这个  Requirements   也可以使用preconditions代替   ,","titles":[]},"1045":{"title":"domain","content":"维护了一个entities列表,当entity触发了OnTriggerEnter事件会增加到这个列表中.aiplanner倒是不需要这个..他们是通过entity和component进行目标查找的","titles":[]},"1046":{"title":"Roslyn C# - Runtime Compiler","content":"","titles":[]},"1047":{"title":"通过FileSystemWatcher监控目录检查改变的文件","content":"unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引","titles":["Roslyn C# - Runtime Compiler"]},"1048":{"title":"编译修改的文件并重新加载","content":"","titles":["Roslyn C# - Runtime Compiler"]},"1049":{"title":"替换场景中的monobehavior","content":"通过以上可以看到明显的缺点只支持monobehavior若想支持非monobehavior可能需要自己进行处理","titles":["Roslyn C# - Runtime Compiler"]},"1050":{"title":"ET的热重载","content":"分离项目到不同的dll中  通过代码加载dll   首先进行编译dll  按R热加载后,通过反射,对现有的对象进行销毁,然后重新创建关键代码:按下f8编译dll按下R重载","titles":["Roslyn C# - Runtime Compiler"]},"1051":{"title":"一些记录","content":"关闭netcode的代码生成   关闭burst的编译,命令行添加参数   ,  查看    删除特性   Unity 重新生成   TypeCache 。这大约需要 4000毫秒，具体取决于程序集中的类型数量。所以避免使用过多无用的插件.减少类型数量","titles":[]},"1052":{"title":"参考链接","content":"Fast Domain Reloads in Unity — John Austin   Unity - Improving iteration time on C# script changes - Unity Forum","titles":[]},"1053":{"title":"关于parent和LinkedEntityGroup","content":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则   parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件  添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可  如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获取世界坐标..可以使用LocalToWorld.pos  linkedEntityGroup 和          有关","titles":[]},"1054":{"title":"关于转换","content":"在Conversion World中，仅仅是复制生成了来自Classic World的、保留原有Hierarchy关系的GameObject Entity，这些Entity拥有的组件仍然是我们熟知的传统Unity组件，例如Transform、MeshFilter。接下来，将调用DOTS预置的或我们自定义的Convert接口，完成向IComponentData组件的转换。自然而然的，可能没有实现对某Component Object的转换接口，那么在转换过程中将被丢弃，所以该转换不一定是“一对一”，所以Unity称呼其为\"Primary Entity\"。下图呈现了转换全过程。转换过程都是在Conversion World中完成的,DOTS在内部为转换过程创建了一个World。作为独立World，它拥有自己的EntityManager和ComponentSystem，进而拥有并管理自己的Entity和ComponentData。使用ConvertToEntity组件,添加IConvertGameObjectToEntity接口,或者在组件上添加     同一,但是使用代码控制转换的时机,继承ConvertToSingleEntity,并覆盖awake,然后在手动调用.    使用IDeclareReferencedPrefabs.声明实体的prefab,然后进行存储,以便进行之后的实例化  对于转换世界中的每个游戏对象，在任何转换系统运行之前，都会在目标世界中自动创建一个主要实体。随后可以通过 GameObjectConversionSystem.GetPrimaryEntity 访问与 GameObject 关联的实体。    4.从转换系统中根据component获取实体,和上面类似..因为转换子物体的时候,转换系统中会生成实体,这个时候可以使用组件从conversionSystem中获取,    5.手动转换gameobject,他的代码和  的代码差不多.会创建一个ConversionWorld,然后进行转换,都是使用了  工作","titles":[]}},"dirtCount":0,"index":[["挂载在rawimage上",{"1":{"1032":1}}],["挂buff的消息通知所有客户端",{"1":{"808":1}}],["括起来",{"0":{"1023":1}}],["帧内释放",{"1":{"1022":1}}],["帧不跳了",{"1":{"854":1}}],["条件",{"1":{"1022":1}}],["条件和装饰器",{"0":{"284":1}}],["泄漏确定",{"1":{"1022":1}}],["泄漏",{"1":{"1021":1,"1022":1}}],["丢弃执行过的命令",{"1":{"1014":1}}],["丢包是不可避免的",{"1":{"82":1}}],["貌似netcode服务端也做了预测",{"1":{"1013":1}}],["涉及到localtoworld",{"1":{"1004":1,"1053":1}}],["涉及到批处理的顺序",{"1":{"979":1,"980":1,"981":1,"982":1}}],["毋需在execute",{"1":{"997":1}}],["慎用entitymanager获取信息",{"1":{"997":1}}],["含义是",{"1":{"991":1}}],["含义是只能被手动删除的component",{"1":{"986":1}}],["栗子",{"0":{"987":1}}],["规避合并mesh导致的内存与性能上升",{"1":{"981":1}}],["规则你都不喜欢",{"1":{"970":1}}],["规则",{"0":{"956":1},"1":{"965":1}}],["规则也同样需要重新计算",{"1":{"91":1}}],["达到合批的目的",{"1":{"980":1}}],["視為",{"1":{"978":1}}],["場景物件的結合",{"1":{"978":1}}],["場景物件的過程中都不寫入深度",{"1":{"975":1}}],["鐵絲網等等",{"1":{"978":1}}],["則無視",{"1":{"977":1}}],["則分別表示錨點到物件",{"1":{"634":1}}],["採",{"1":{"977":1}}],["階層關係",{"1":{"977":1}}],["處理",{"1":{"977":1}}],["卻是另外規則",{"1":{"977":1}}],["遊戲製作",{"1":{"975":1}}],["專門用於",{"1":{"975":1}}],["調整",{"1":{"975":1}}],["調整情形如下",{"1":{"650":1}}],["關於",{"1":{"977":1}}],["關於深度緩衝",{"0":{"974":1}}],["關閉排序繪製",{"1":{"975":1}}],["無法在預設編輯器修改",{"1":{"975":1}}],["選擇專案中的",{"1":{"975":1}}],["選擇場景的",{"1":{"975":2}}],["選擇場景中的",{"1":{"975":1}}],["預設值",{"1":{"975":1}}],["預設值分別",{"1":{"975":1}}],["預設值會從",{"1":{"975":1}}],["為",{"1":{"977":1}}],["為透明物件",{"1":{"975":1}}],["為不透明物件",{"1":{"975":1}}],["為二維陣列",{"1":{"974":1}}],["數值大於",{"1":{"975":1}}],["數值小於等於",{"1":{"975":1}}],["數字越大越晚畫",{"1":{"975":4,"977":1}}],["參數",{"1":{"975":1,"977":1}}],["參考資料",{"0":{"651":1}}],["編輯",{"1":{"975":8}}],["程式設定",{"1":{"975":4}}],["程式碼",{"1":{"975":1}}],["程序传递一些重要的参数",{"1":{"574":1}}],["程序还通过环境变量来得到输入",{"1":{"574":1}}],["程序通过标准输入",{"1":{"574":1}}],["程序间传递数据",{"1":{"574":1}}],["程序的main方法就是在这里执行",{"1":{"707":1}}],["程序的传送方式",{"1":{"574":1}}],["程序的类型决定数据向",{"1":{"574":1}}],["程序的交互web",{"1":{"574":1}}],["程序的运行过程和在内存上的表现",{"1":{"131":1}}],["程序和",{"1":{"510":1}}],["程序既不读写",{"1":{"457":1}}],["程序就完成了新旧两个",{"1":{"455":1}}],["程序在这种模式下对",{"1":{"449":1}}],["程序接受到的三个参数分别保存着",{"1":{"445":1}}],["程序会根据命令以及命令的参数",{"1":{"445":1}}],["程序会把clr头",{"1":{"131":1}}],["程序之后",{"1":{"445":1}}],["程序",{"1":{"444":2,"510":1,"536":1,"572":1}}],["程序根据接收到的命令数据",{"1":{"443":1}}],["程序中",{"1":{"443":1}}],["程序自己加上去的之外",{"1":{"443":1}}],["程序也就跑起来了",{"1":{"131":1}}],["程序执行到哪里就编译到哪里",{"1":{"131":1}}],["程序来说",{"1":{"131":1}}],["程序集包含了项目中的简单脚本程序集",{"1":{"592":1}}],["程序集转换为本机代码",{"1":{"130":1}}],["程序集",{"1":{"129":1}}],["程序计数器",{"1":{"113":1}}],["沒有",{"1":{"975":1}}],["永遠都描繪在其他離攝影機越遠的物件之前",{"1":{"974":1}}],["永远存储在它们声明时所在的",{"1":{"884":1}}],["永远返回false",{"1":{"283":1}}],["永远返回true",{"1":{"283":1}}],["機制來調整",{"1":{"978":1}}],["機制調整",{"1":{"978":1}}],["機制",{"1":{"974":1,"975":1,"978":1}}],["並且將新的深度資訊寫入到",{"1":{"974":1}}],["並安裝",{"1":{"566":1}}],["會決定成像的結果",{"1":{"975":1}}],["會檢查",{"1":{"974":1}}],["會儲存在",{"1":{"974":1}}],["產生的深度資訊",{"1":{"974":1}}],["當所屬的",{"1":{"977":1}}],["當物件",{"1":{"974":1}}],["當兩錨點",{"0":{"634":1,"635":1,"636":1,"637":1},"1":{"633":4,"634":1,"635":1,"636":1,"637":1}}],["當兩個錨點的某一維度值相等時",{"1":{"633":1}}],["勢必得先回歸電腦繪圖學",{"1":{"974":1}}],["碎片的问题",{"1":{"971":1}}],["染成了绿色",{"1":{"971":1}}],["删掉",{"1":{"971":1}}],["删除特性",{"1":{"1051":1}}],["删除那些组件",{"1":{"936":1}}],["删除",{"0":{"908":1}}],["删除析构方法中的断点",{"1":{"837":1}}],["删除家庭内容",{"1":{"609":1}}],["删除~",{"1":{"419":1}}],["删除角色a所在的客户端里的1",{"1":{"103":1}}],["删除老版本",{"1":{"88":1}}],["些东西",{"1":{"971":1}}],["绑定在一起",{"1":{"970":1}}],["绑定了",{"1":{"657":1,"691":1}}],["截止到这里",{"1":{"969":1}}],["截止至2022年9月4日",{"1":{"553":1}}],["伴随",{"1":{"969":2}}],["伴随着其中的细细笑语和靡靡乐音",{"1":{"297":1}}],["胶粘",{"1":{"969":1}}],["黑魔法来帮助你完成这个过程",{"1":{"967":1}}],["黑色点是之前轮已经确定的采样点",{"1":{"214":1}}],["黑色你完全看不到后面的情况",{"1":{"0":1}}],["黑色是完全不透光的木板",{"1":{"0":1}}],["缺乏linkedentitygroup导致我们最终的结果里仅仅实例化了最顶层的那个",{"1":{"966":1}}],["缺点标记",{"1":{"119":1}}],["缺点1",{"1":{"115":1}}],["缺点是",{"1":{"111":1}}],["缺点是序列化比其他方法慢",{"1":{"111":1}}],["缺点是使用了反射",{"1":{"111":1}}],["缺点",{"0":{"442":1},"1":{"110":2,"120":1,"753":1,"754":1,"755":1,"758":1,"759":1,"811":1,"876":1}}],["团队写点我能看懂的文档",{"1":{"965":1}}],["团队采用了常规的",{"1":{"946":1}}],["活了过来",{"1":{"965":1}}],["活该",{"1":{"48":1}}],["烘焙对于单个",{"1":{"965":1,"1003":1}}],["烘焙",{"1":{"965":1}}],["链锁销毁行为也一样",{"1":{"965":1}}],["链接backgroundparallax脚本代码说明",{"1":{"736":1}}],["链接",{"0":{"211":1},"1":{"223":1}}],["库通过查看它是不是位于",{"1":{"964":1}}],["库维护的一个属性",{"1":{"944":1}}],["吧",{"1":{"964":1}}],["阶段转换完成",{"1":{"966":1}}],["阶段就能预先实例化呢",{"1":{"966":1}}],["阶段",{"1":{"964":1,"966":2}}],["副作用",{"1":{"963":1}}],["副本",{"0":{"321":1},"1":{"287":1},"2":{"322":1,"323":1,"324":1,"325":1,"326":1}}],["认为",{"1":{"960":1}}],["尺寸警告",{"0":{"960":1}}],["尺寸無關",{"1":{"633":1}}],["遥控",{"1":{"957":1}}],["毫无兴趣",{"1":{"955":1}}],["毫无作用",{"1":{"377":1}}],["橙色的竖条往右边移动了一点",{"1":{"955":1}}],["侧的",{"1":{"954":1}}],["销毁或者不销毁原始",{"1":{"954":1}}],["销毁之前导出",{"1":{"954":1}}],["销毁entity",{"1":{"908":1}}],["独有",{"1":{"952":1}}],["叶子节点",{"1":{"952":1}}],["叶子节点的执行代表着技能真正的执行逻辑",{"1":{"805":1}}],["沟通",{"1":{"950":1}}],["奇迹发生之地",{"1":{"950":1}}],["奇遇",{"1":{"287":1}}],["约束的泛型",{"1":{"946":1}}],["约束矩阵描述了在输入模型中",{"1":{"209":1}}],["横向地",{"1":{"944":1}}],["横版常用背景大概有三种",{"1":{"287":1}}],["妙的一点在于你可以不断地添加新系统来实现代码的",{"1":{"944":1}}],["瞧",{"1":{"943":1}}],["展示了在帧间绘制时并没有太多了",{"1":{"941":1}}],["展示了相机所看到的所有物体",{"1":{"841":1}}],["形式被实例化",{"1":{"968":1}}],["形式",{"1":{"941":1}}],["擅长数据迭代",{"1":{"940":1}}],["缓冲本身",{"1":{"938":1}}],["缓存中的内容被写入到",{"1":{"443":1}}],["缓存中",{"1":{"443":1}}],["缓存追加",{"0":{"445":1},"1":{"443":1}}],["缓存都不用",{"1":{"175":1}}],["差不多",{"1":{"937":1}}],["差集",{"0":{"178":1}}],["诱因",{"0":{"932":1}}],["浅入浅出unity",{"1":{"931":1}}],["浅谈各类防御机制的作用",{"1":{"385":1}}],["筛选",{"1":{"930":1}}],["滥用",{"1":{"929":1}}],["翻译成大白话",{"1":{"991":1}}],["翻译",{"1":{"919":1}}],["翻译过来是合并模式",{"1":{"903":1}}],["翻箱子掉落",{"1":{"269":1}}],["见文章开始部分",{"1":{"898":1}}],["见上上图的左下角",{"1":{"273":1}}],["终结器",{"1":{"898":1}}],["终于可以进行真真切切的",{"1":{"690":1}}],["终于可以看出来反射本身还是挺伤性能的了",{"1":{"175":1}}],["终于把插件的体积从",{"1":{"534":1}}],["柜子里不用的衣服",{"1":{"898":1}}],["柜台可以让npc有个等候区",{"1":{"369":1}}],["阁楼里一箱箱没有用的过时产品",{"1":{"898":1}}],["扔垃圾",{"1":{"898":2}}],["庞大的struct类型",{"1":{"891":1}}],["堆栈跟踪",{"0":{"1021":1},"2":{"1022":1,"1023":1}}],["堆栈原理对代码的影响",{"0":{"888":1},"2":{"889":1}}],["堆中对象之间是没有间隙的",{"1":{"898":1}}],["堆分配一块内存空间给animal",{"1":{"893":1}}],["堆的情况就像你把一堆刚洗完的衣服放在床上还没有时间来的及收走",{"1":{"879":1}}],["堆里的任何信息都可以在任何时间被访问",{"1":{"879":1}}],["堆",{"1":{"879":3}}],["堆与栈",{"0":{"879":1}}],["五",{"1":{"876":1}}],["五边形节点表示根节点",{"1":{"210":1}}],["着色器等",{"1":{"876":1}}],["陀螺仪",{"1":{"868":1}}],["つロ",{"1":{"864":1,"899":1}}],["゜",{"1":{"864":2,"899":2}}],["频繁的临时分配",{"1":{"864":1}}],["频率的临时内存分配",{"1":{"820":1}}],["频率是指采样数据的间隔",{"1":{"204":1}}],["摆ui",{"1":{"862":1}}],["合并之类的",{"1":{"862":1}}],["合并掉可以batch的元素成为一个",{"1":{"862":1}}],["合并批次",{"1":{"862":1}}],["合入",{"1":{"861":1}}],["批处理中断情况位置不相邻且中间夹杂着不同材质的其他物体",{"1":{"980":1}}],["批处理批处理的目的就是为了减少drawcall",{"1":{"876":1}}],["批次",{"1":{"862":3}}],["批量处理的时候",{"1":{"811":1}}],["批量处理工作量大",{"1":{"811":1}}],["剩下的",{"1":{"861":1}}],["剩下的il2cpp",{"1":{"592":1}}],["浪费一点也无所谓",{"1":{"861":1}}],["启用",{"0":{"1021":1},"1":{"878":1},"2":{"1022":1,"1023":1}}],["启用gpu实例化",{"1":{"859":1}}],["启动clr",{"1":{"707":1}}],["启动api",{"1":{"570":1}}],["启动服务",{"0":{"506":1}}],["启动",{"1":{"467":1}}],["启动算法从头再来一次",{"1":{"224":1}}],["间隙",{"1":{"857":2}}],["间隔为单位对游戏做snapshot",{"1":{"14":1}}],["间隔为单位",{"1":{"14":1}}],["池的一部分",{"1":{"857":1}}],["省电发热优化",{"0":{"855":1}}],["套用一句广告语来说",{"1":{"854":1}}],["稳速",{"1":{"854":1}}],["鬼武者3等一些移植到pc上的游戏在关闭垂直同步时通常会出现这种问题",{"1":{"854":1}}],["鬼谷八荒全奇遇任务攻略",{"1":{"296":1}}],["跳帧假如显示器设定的刷新率是80hz",{"1":{"854":1}}],["跳跃动画",{"1":{"244":1}}],["跳跃离开危险或跳入战斗之中",{"1":{"244":1}}],["跳跃攻击",{"1":{"244":1}}],["←",{"1":{"854":1}}],["固然可以换来更快的速度",{"1":{"854":1}}],["固定物理大小",{"0":{"629":1}}],["固定像素",{"0":{"627":1}}],["固定的",{"1":{"301":1}}],["固定日期会产出持续三到五天",{"1":{"300":1}}],["固定精英怪拥有固定的名字和固定的出现地点",{"1":{"266":1}}],["垂直同步一定要开",{"1":{"854":1}}],["垂直同步",{"0":{"854":1},"1":{"855":1}}],["垂直于它的向量",{"1":{"784":1}}],["草",{"1":{"978":1}}],["草等在场景中重复出现的事物时",{"1":{"849":1}}],["草药",{"1":{"304":5}}],["骨骼蒙皮动画",{"1":{"848":1}}],["蒙皮",{"1":{"848":1}}],["蒙版根据黑白灰",{"1":{"0":1}}],["蒙版",{"1":{"0":1}}],["溜",{"1":{"848":1}}],["莫慌",{"1":{"847":1}}],["索引的时候",{"1":{"930":1}}],["索引的数组",{"1":{"929":1}}],["索引数组",{"1":{"930":1}}],["索引",{"1":{"929":1}}],["索引找到",{"1":{"847":1}}],["索要物资",{"1":{"387":1}}],["背面是看不见的",{"1":{"846":1}}],["背景则在它的后边",{"1":{"737":1}}],["背景滚动存在横向和纵向两种",{"1":{"725":1}}],["背景滚动是实现视差效果的核心也是最重要的问题",{"1":{"725":1}}],["背景的话有其他方式",{"1":{"724":1}}],["背景的不同",{"1":{"287":1}}],["背景是一些远的建筑之类的",{"1":{"287":1}}],["背景浮空岛或者是遥远的建筑",{"1":{"287":1}}],["背景为连绵不觉的山",{"1":{"287":1}}],["背景类似这种崖壁或者之类的东西",{"1":{"287":1}}],["背景",{"0":{"171":1,"553":1}}],["拇指指示了三角图元的法线方向",{"1":{"846":1}}],["聚光灯贴图",{"1":{"845":1}}],["法向量和切线信息",{"1":{"869":1}}],["法线和uv值三种属性",{"1":{"980":1}}],["法线和纹理坐标这三个顶点属性",{"1":{"876":1}}],["法线其中一个作用是指明了三角图元的方向",{"1":{"846":1}}],["法线数组存放mesh每个顶点的法线",{"1":{"846":1}}],["法线",{"1":{"846":1,"980":1}}],["法线贴图就是在原物体的凹凸表面的每个点上均作法线",{"1":{"845":1}}],["法术场和弹道都可能造成伤害",{"1":{"809":1}}],["法术场和buff等技能创生体",{"0":{"799":1}}],["法术场和buff",{"1":{"796":1}}],["法术场作为一个entity他的管理成本是比较高的",{"1":{"807":1}}],["法术场结算并不需要同步",{"1":{"807":1}}],["法术场每隔一段时间结算一次",{"1":{"807":1}}],["法术场的执行和同步流程",{"1":{"807":1}}],["法术场需要注意一个问题",{"1":{"801":1}}],["法术场描述对一块区域的影响",{"1":{"801":1}}],["法术场只能检测目标不能造成伤害",{"1":{"799":1}}],["法术场能否对单位造成伤害",{"1":{"799":1}}],["法术场",{"0":{"801":1,"807":1},"1":{"799":1,"801":1,"807":1}}],["法术场是一个场景的某块检测区域",{"1":{"799":1}}],["法术场弹道击中敌人时又有可能产生相应的buff",{"1":{"799":1}}],["法术类",{"1":{"385":1}}],["法术没有命中的机制",{"1":{"385":1}}],["法术躲避几率xii",{"1":{"384":1}}],["材质",{"1":{"976":1}}],["材质具体描述了mesh中的数据如何进行绘制",{"1":{"847":1}}],["材质可包含对纹理的引用",{"1":{"844":1}}],["材质的可用选项取决于材质使用的着色器",{"1":{"844":1}}],["颜色色调等来定义表面应使用的渲染方式",{"1":{"844":1}}],["颜色为",{"1":{"207":1}}],["谢谢",{"1":{"842":1}}],["万向锁",{"1":{"842":1}}],["万一你想知道如何把圆投影到轴上",{"1":{"785":1}}],["局部旋转就为",{"1":{"841":1}}],["局部变量都在线程栈上",{"1":{"131":1}}],["局部变量",{"1":{"131":1}}],["办法就是",{"1":{"841":1}}],["倍视口尺寸哦",{"1":{"841":1}}],["倍频组数的增加",{"1":{"204":1}}],["倍频",{"1":{"204":1}}],["面提到过",{"1":{"847":1}}],["面板中轻松地设置",{"1":{"841":1}}],["面对这种类型的bug我们可以快速的并且很自信的进行修正",{"1":{"594":1}}],["面对来势汹汹的对手",{"1":{"383":1}}],["面对不同势力把持形成的江湖",{"1":{"383":1}}],["肯定会使draw",{"1":{"877":1}}],["肯定是",{"1":{"841":1}}],["肯定有很复杂的代码才可以完成这样逻辑",{"1":{"107":1}}],["吗",{"1":{"841":2}}],["鼠标位置转换成世界坐标",{"1":{"841":1}}],["鼠标位置",{"1":{"841":1}}],["鼠标或控制杆控制移动",{"1":{"42":1}}],["界面的坐标体系我们在做",{"1":{"841":1}}],["屏幕的宽高比直接影响了相机的显示",{"1":{"841":1}}],["屏幕坐标只能是二维坐标",{"1":{"1025":1}}],["屏幕坐标转换成世界坐标后物体的",{"1":{"841":1}}],["屏幕坐标系转换成世界坐标系",{"1":{"841":1}}],["屏幕坐标系中原点",{"1":{"841":1}}],["屏幕坐标系",{"1":{"841":1}}],["屏幕",{"1":{"841":2}}],["屏幕宽高比我举个例子说明一下",{"1":{"618":1}}],["屏幕宽高比也即是摄像机实际宽度",{"1":{"618":1}}],["兼",{"1":{"840":1}}],["兼容级别",{"1":{"722":1}}],["兼容级别时添加程序集引用",{"0":{"722":1}}],["兼容http请求响应以及websocket数据帧的序列格式",{"1":{"583":1}}],["兼容的最新",{"1":{"477":1}}],["析构函数会被内部转换成终结器override",{"1":{"898":1}}],["析构",{"1":{"836":1}}],["析构方法中分别打断点",{"1":{"836":1}}],["勾选上之后就可以调试了",{"1":{"834":1}}],["勾选了include",{"1":{"704":1}}],["维护了一个entities列表",{"1":{"1045":1}}],["维护一个视野队列",{"1":{"104":1}}],["维基百科页面",{"1":{"833":1}}],["典型的堆大小约为200kb",{"1":{"830":1}}],["典型的c",{"1":{"41":1}}],["鉴于它们不能被完全消除",{"1":{"829":1}}],["管理器选择一个未使用的区域",{"1":{"827":1}}],["布尔和unity的结构类型",{"1":{"826":1}}],["布局的元素",{"1":{"406":1}}],["布局以后",{"1":{"405":1}}],["布局",{"1":{"405":2}}],["布局是什么",{"0":{"405":1}}],["浮点数",{"1":{"826":1}}],["倾向于用返回一个空数组来代替null",{"1":{"825":1}}],["声明实体的prefab",{"1":{"1054":1}}],["声明和使用",{"0":{"966":1}}],["声明任意",{"1":{"964":1}}],["声明的",{"1":{"964":1}}],["声明",{"0":{"964":1},"1":{"964":2,"965":1,"967":1}}],["声明一个枚举创建了一个新的值类型",{"1":{"822":1}}],["声明文件global",{"1":{"399":1}}],["声明文件",{"0":{"398":1},"1":{"401":1}}],["识别装箱",{"0":{"821":1}}],["匿名函数在托管堆上生成最少量的暂时垃圾",{"1":{"819":1}}],["临时内存分配可以通过作为一个参数传递函数引用很简单的创建",{"1":{"818":1}}],["临时分配",{"0":{"815":1}}],["闭包在每次调用中分配最多的内存",{"1":{"819":1}}],["闭包和匿名函数",{"0":{"818":1}}],["闭关修炼武功",{"1":{"380":1}}],["耗尽",{"1":{"814":1}}],["严格的说",{"1":{"813":1}}],["彻底干掉了skill这个类",{"1":{"811":1}}],["施法者释放了一个技能",{"1":{"811":1}}],["施法者一组行为和数据的组合",{"1":{"811":1}}],["施烟布瘴",{"1":{"297":1}}],["恰好新的项目里里面我进行了一个比较新的尝试",{"1":{"811":1}}],["供技能调用",{"1":{"810":1}}],["防止要求技能前摇时间过长",{"1":{"803":1}}],["防御",{"1":{"378":2,"381":1}}],["防御值",{"1":{"20":1}}],["告知了我们绘制什么",{"1":{"940":1}}],["告知其他所有的客户端此玩家开始执行技能",{"1":{"803":1}}],["告诉当前技能使其结束",{"1":{"793":1}}],["告诉il2cpp如果可以",{"1":{"592":1}}],["禁魔",{"1":{"800":1}}],["禁用行为参考前文",{"1":{"970":1}}],["禁用",{"1":{"868":1}}],["禁用子组件时要小心",{"1":{"860":1}}],["禁用canvase组件会阻止画布向gpu发起绘图调用",{"1":{"860":1}}],["禁用include",{"0":{"705":1}}],["禁用roomtemplates下的碰撞",{"1":{"228":1}}],["禁用roomtemapltes下的显示",{"1":{"228":1}}],["创生体功能的界定需要根据策划需求",{"1":{"799":1}}],["创建出来的rendertexture",{"1":{"1032":1}}],["创建显示的模型",{"1":{"1032":1}}],["创建rendertexture并绑定到摄像机camera",{"1":{"1032":1}}],["创建角色gamemodesystemserver",{"1":{"1012":1}}],["创建额外的",{"0":{"961":1}}],["创建job后",{"1":{"921":1}}],["创建job的步骤如下",{"1":{"920":1}}],["创建job需要定义一个结构体",{"1":{"920":1}}],["创建job",{"0":{"920":1}}],["创建完entity后",{"1":{"908":1}}],["创建entity",{"0":{"907":1}}],["创建终结器",{"1":{"898":1}}],["创建以后使用entity管理机制服务端通知客户端他们的创建和销毁",{"1":{"807":1}}],["创建",{"1":{"510":1}}],["创建电子书的文件夹目录",{"0":{"502":1}}],["创建配置文件proxychains",{"1":{"473":1}}],["创建一个实现",{"1":{"920":1}}],["创建一个弹道就表示一个子弹特效沿这个弹道移动并检测路径上的敌人",{"1":{"799":1}}],["创建一个外部工具",{"1":{"746":1}}],["创建一个新的",{"1":{"453":1}}],["创建一个不带网络连接的伪客户端",{"1":{"452":1}}],["创建相关实体",{"0":{"264":1}}],["创建的时候",{"1":{"261":1,"262":1}}],["创建player实体",{"1":{"1012":1}}],["创建playload",{"1":{"227":1}}],["创建pipelinetask",{"1":{"227":1}}],["创建房间",{"0":{"225":1}}],["创建solution",{"0":{"224":1}}],["创建了一个自定义的克隆框架",{"1":{"111":1}}],["状态",{"1":{"885":1,"964":1}}],["状态对单位产生一些正面或者负面的影响",{"1":{"799":1}}],["状态的",{"1":{"695":1}}],["狭义的来说",{"1":{"799":1}}],["音效等",{"1":{"798":1}}],["音律",{"1":{"297":2}}],["普遍用法是镜像一个用户组件",{"1":{"933":1}}],["普攻",{"1":{"795":1}}],["普攻是一个循环技能",{"1":{"795":1}}],["普通用途组件",{"0":{"927":1}}],["普通民居",{"1":{"287":1}}],["普通",{"1":{"275":1}}],["普通小怪",{"1":{"266":1}}],["普通boss",{"1":{"266":1}}],["普通怪物的等级为场景等级",{"1":{"265":1}}],["普通伤害",{"1":{"247":1}}],["马上通知顺序节点",{"1":{"795":1}}],["晕眩",{"1":{"793":1,"800":1}}],["符文",{"1":{"792":1}}],["符合要求",{"1":{"275":1}}],["囧",{"1":{"787":1}}],["噢",{"1":{"785":1}}],["阴影",{"1":{"784":1}}],["阴阳师",{"0":{"296":1}}],["循环依赖也是不允许的",{"1":{"958":1,"1001":1}}],["循环进行的手动迭代慢得多",{"1":{"864":1}}],["循环获取第一个多边形的每个点",{"1":{"784":1}}],["循环引用指的是a引用了b",{"1":{"124":1}}],["希望大家不会在这方面被坑得很惨",{"1":{"782":1}}],["希望我已经大致讲清楚了这个逻辑",{"1":{"15":1}}],["凸多边形碰撞",{"0":{"782":1}}],["夹角",{"1":{"780":1,"781":1}}],["θ",{"1":{"780":1}}],["叉乘结果用右手判断法则",{"1":{"777":1}}],["叉乘",{"1":{"777":1}}],["扇形攻击",{"0":{"771":1}}],["凹凸实验室",{"1":{"770":2}}],["读者若感兴趣",{"1":{"767":1}}],["读取streamingassets下的dll文件",{"1":{"708":1}}],["读取",{"1":{"452":2}}],["读取客户端发过来的操作信息",{"1":{"41":1}}],["粗略低由近到遠排序繪製",{"1":{"975":1}}],["粗略阶段",{"0":{"767":1}}],["粗略和精细",{"1":{"766":1}}],["粗看就是从methods中取出来",{"1":{"715":1}}],["碰撞检测有多种",{"1":{"769":1}}],["碰撞检测是在",{"1":{"759":1}}],["碰撞性能优化",{"0":{"766":1},"2":{"767":1,"768":1}}],["边缘法向量",{"1":{"762":1}}],["边缘向量",{"1":{"762":1}}],["边界情况处理用以上方式生成的地图在某些情况下会产生不好的结果",{"1":{"214":1}}],["投影的长度为",{"1":{"763":1}}],["投影的大小",{"1":{"763":1}}],["投影在某一投影轴上",{"1":{"763":1}}],["投影",{"0":{"763":1}}],["投影轴的适当位置",{"1":{"763":1}}],["投影轴的位置不限",{"1":{"762":1}}],["投影轴的数量与多边形的边数相等即可",{"1":{"761":1}}],["投影轴",{"0":{"762":1},"1":{"762":1,"763":1,"784":1}}],["投射物加成",{"1":{"394":1}}],["投射物",{"1":{"243":1}}],["抛弃层级关系",{"1":{"862":1}}],["抛球运动进桶",{"1":{"760":1}}],["抛球进桶图例",{"1":{"760":1}}],["抛开这些",{"1":{"30":1}}],["绘图graphing让我们站在gc的角度研究一下",{"1":{"898":1}}],["绘制的时候提交模型顶点信息",{"1":{"979":1}}],["绘制就是重复地调用没有改变的数据",{"1":{"941":1}}],["绘制都关注于什么样draw",{"1":{"940":1}}],["绘制坐标系",{"1":{"841":1}}],["绘制",{"1":{"841":1,"846":1}}],["绘制第二条线",{"1":{"760":1}}],["绘画",{"1":{"297":1}}],["踩地雷等",{"1":{"758":1}}],["划分为一个个格子",{"1":{"758":1}}],["逆时针旋转",{"1":{"846":1}}],["逆时针",{"1":{"756":1}}],["δ+β",{"1":{"756":1}}],["δ",{"1":{"756":21}}],["度握紧后到了",{"1":{"840":1}}],["度就能把四指握到",{"1":{"840":1}}],["度后的位置为",{"1":{"756":1}}],["度数为90°的扇形",{"1":{"749":1}}],["β",{"1":{"756":22}}],["绕",{"1":{"756":1}}],["绕着当前",{"1":{"693":1}}],["适合运动速度快的物体缺点",{"1":{"760":1}}],["适用于多个人物模型的目的",{"1":{"848":1}}],["适用范围相对局限",{"1":{"760":1}}],["适用范围更广",{"1":{"756":1}}],["适用场景局限",{"1":{"758":1}}],["适用案例",{"1":{"753":1,"758":1,"759":1,"760":1}}],["适时地滚动背景精灵",{"1":{"729":1}}],["矩形越小",{"1":{"1025":1}}],["矩形越大",{"1":{"1025":1}}],["矩形裁剪范围",{"1":{"860":1}}],["矩形旋转的角度",{"1":{"756":1}}],["矩形需是轴对称的",{"1":{"755":1}}],["矩形物体间的碰撞",{"1":{"753":1}}],["矩形的任意一边是否无间距",{"1":{"753":1}}],["矩阵的结果并不是在行1",{"1":{"952":1}}],["矩阵的值为瓦片种类id",{"1":{"208":1}}],["矩阵将会无比痛苦",{"1":{"944":1,"1000":1}}],["矩阵构成的",{"1":{"942":1}}],["矩阵需要绘制",{"1":{"941":1}}],["矩阵或四元数运算更快",{"1":{"858":1}}],["矩阵中的每个点都是一个非负整数",{"1":{"208":1}}],["轴就是右手坐标系",{"1":{"840":1}}],["轴就是左手坐标系",{"1":{"840":1}}],["轴正方向握拳头",{"1":{"840":1}}],["轴正方向",{"1":{"840":1}}],["轴两个方向分别进行寻找",{"1":{"755":1}}],["轴",{"1":{"755":3,"756":2,"840":1}}],["轴对称包围盒",{"0":{"753":1},"1":{"754":1}}],["轴点为左上",{"1":{"625":1}}],["怎麼透過",{"1":{"974":1}}],["怎么办呢",{"1":{"956":1}}],["怎么样获取",{"1":{"930":1}}],["怎么计算相对坐标呢",{"1":{"841":1}}],["怎么区别呢",{"1":{"840":1}}],["怎么检测不到",{"1":{"751":1}}],["怎样在发展中求生存",{"1":{"383":1}}],["劣势",{"1":{"737":1}}],["劣质的判定",{"1":{"275":1}}],["尤其想在游戏中使用变焦的时候",{"1":{"737":1}}],["尤其是c",{"1":{"825":1}}],["尤其是在基于每帧执行的代码中",{"1":{"818":1}}],["尤其是在玩家数量比较多的时候",{"1":{"86":1}}],["尤其是当你把你在微机上运算的结果运用到计算机群上去的话",{"1":{"34":1}}],["层面",{"1":{"957":1}}],["层级",{"1":{"1039":2,"1040":3,"1041":1}}],["层级中",{"1":{"965":1}}],["层级中超过16个子对象并不是什么好事",{"1":{"960":1}}],["层级树",{"1":{"952":1}}],["层级为1",{"1":{"862":1}}],["层级号",{"1":{"862":8}}],["层级视图很简单",{"1":{"737":1}}],["层编译出来的dll程序集进行il代码注入",{"1":{"717":1}}],["拼图等的主平面",{"1":{"737":1}}],["笔者编写此脚本代码说明",{"1":{"736":1}}],["笔者对此",{"1":{"736":1}}],["顾名思义",{"1":{"729":1,"989":1}}],["混用converttoentity的",{"0":{"968":1}}],["混合渲染",{"1":{"905":1}}],["混合移动混合了精灵移动和照相机移动两种方式",{"1":{"729":1}}],["混合滚动方式",{"0":{"729":1},"2":{"730":1,"731":1,"732":1,"733":1,"734":1,"735":1,"736":1}}],["混沌",{"1":{"394":1}}],["照相机移动方式有更多的空间开销",{"1":{"731":1}}],["照相机移动方式",{"0":{"728":1}}],["纹理等信息",{"1":{"862":1}}],["纹理坐标",{"1":{"846":1}}],["纹理还可表示材质表面的许多其他方面",{"1":{"844":1}}],["纹理",{"1":{"726":1,"876":1}}],["稍微解释一下此函数",{"1":{"726":1}}],["坐标系一样",{"1":{"841":1}}],["坐标系还是很简单的",{"1":{"840":1}}],["坐标体系嗯",{"1":{"841":1}}],["坐标体系当我们使用多个相机",{"1":{"841":1}}],["坐标体系除外",{"1":{"841":1}}],["坐标体系",{"0":{"841":1}}],["坐标映射",{"1":{"726":1}}],["坐标值在",{"1":{"726":1}}],["坐标必定会大于",{"1":{"726":1}}],["坐标小数部分为选中背景贴图的采样",{"1":{"726":1}}],["坐标的整数部分标记了当前采样位置使用哪一张背景贴图",{"1":{"726":1}}],["坐标存在两个作用",{"1":{"726":1}}],["坐标",{"1":{"726":2,"759":1,"841":1}}],["坐标形成滚动",{"1":{"726":1}}],["坐标和纹理之间的采样方式",{"1":{"726":1}}],["坐标和采样方式实现平铺背景以及背景滚动",{"1":{"726":1}}],["坐标移动的方法中",{"1":{"726":1}}],["坐标移动形成滚动的效果看起来是这样的",{"1":{"726":1}}],["坐标5到x坐标9为一个格子",{"1":{"107":1}}],["远达不到我们的千个级别",{"1":{"960":1}}],["远处的群山似乎没有在动",{"1":{"724":1}}],["远点",{"1":{"46":1}}],["离摄像机越近",{"1":{"1025":1}}],["离摄像机越远",{"1":{"1025":1}}],["离照相机越近的背景移动越快",{"1":{"724":1}}],["离我们近的星星移动速度则较快",{"1":{"724":1}}],["离我们远的星星移动速度较慢",{"1":{"724":1}}],["离得最近的会被最先搜索",{"1":{"210":1}}],["离得远的玩家看不见",{"1":{"97":1}}],["附带的程序集",{"1":{"722":1}}],["附带的某些程序集",{"1":{"722":1}}],["附加在顶部的",{"1":{"961":1}}],["附加类",{"1":{"254":1}}],["附加暴击等",{"1":{"246":1}}],["附加伤害百分比",{"1":{"246":1,"247":1}}],["附加伤害",{"1":{"246":1,"247":1}}],["附加属性",{"1":{"246":1}}],["博客文章",{"1":{"721":1}}],["承诺在",{"1":{"721":1}}],["匹配",{"1":{"721":1}}],["众所周知gc",{"1":{"718":1}}],["始终工作在默认的appdomain",{"1":{"718":1}}],["知晓",{"1":{"951":1}}],["知道泄漏的位置后",{"1":{"1023":1}}],["知道了这点",{"1":{"976":1}}],["知道了unity编辑器的脚本编译特性后",{"1":{"839":1}}],["知道如何处理重复情况",{"1":{"966":1}}],["知道它们如何关联至",{"1":{"963":1}}],["知道这些",{"1":{"962":1}}],["知道得到服务器的确定以后将其从命令列表中删除",{"1":{"43":1}}],["知乎mono",{"1":{"717":1}}],["车雄生的回答",{"1":{"717":1}}],["腾讯开源的unity热更解决方案xlua有一个非常吸引人的特性就是hotfix",{"1":{"717":1}}],["腾讯dns服务器",{"1":{"529":1}}],["热更方案",{"1":{"717":1}}],["热更新dll和unity主工程的相互调用",{"0":{"716":1}}],["热更新在unity中的应用",{"1":{"708":1}}],["热修复hotfix",{"0":{"717":1}}],["塞入结果",{"1":{"715":1}}],["塞入各个参数",{"1":{"715":1}}],["塞进嘴里咬一下",{"1":{"296":1}}],["逐行显示到屏幕上",{"1":{"854":1}}],["逐个遍历其中的方法做一个分类存储",{"1":{"715":1}}],["逐渐纠正这个错误",{"1":{"84":1}}],["归并几个代码",{"1":{"714":1}}],["归家异途2",{"1":{"287":1}}],["继承converttosingleentity",{"1":{"1054":1}}],["继承ibuildpipelinecomponent接口的组件有",{"1":{"972":1}}],["继承模式在ecs的世界里",{"1":{"955":1}}],["继承适配器",{"1":{"718":1}}],["继承自itype",{"1":{"714":1}}],["继续跟进read操作",{"1":{"714":1}}],["继续盘点大概率啥都没有",{"1":{"295":1}}],["继续追债则会扣道德18",{"1":{"295":1}}],["继续",{"1":{"221":1}}],["继续处理用户的请求",{"1":{"167":1}}],["继续往前",{"1":{"15":1}}],["借助mono",{"0":{"711":1}}],["穿越appdomain的是hard",{"1":{"707":1}}],["穿过屏幕事件发生处位置的一条射线",{"1":{"684":1}}],["线性化",{"1":{"965":1}}],["线性排列的结果",{"1":{"959":1,"1002":1}}],["线程都会来回使用以避免闲置",{"1":{"944":1}}],["线程现在已经在工作了",{"1":{"944":1}}],["线程被传递回go",{"1":{"891":1}}],["线程开始执行此方法",{"1":{"887":1}}],["线程开始执行寄存在方法",{"1":{"885":1}}],["线程执行方法",{"1":{"885":1}}],["线程是个动态概念",{"1":{"707":1}}],["线程",{"1":{"707":1}}],["线缆中的电子",{"1":{"64":1}}],["核心的技能结算逻辑里",{"1":{"811":1}}],["核心技术",{"1":{"770":1}}],["核心思想就是",{"1":{"707":1}}],["核心方法为executeevents",{"1":{"678":1}}],["核心方法就是经过重写的raycaster",{"1":{"676":1}}],["卸载一个assembly",{"1":{"707":1}}],["精细阶段",{"0":{"768":1}}],["精确缺点",{"1":{"764":1}}],["精灵方式则有最大的移动性能消耗",{"1":{"731":1}}],["精灵滚动方式和混合滚动方式可以实现更为复杂一点的背景",{"1":{"732":1}}],["精灵滚动方式和照相机移动方式混合使用",{"1":{"725":1}}],["精灵滚动方式",{"0":{"727":1}}],["精灵便会在场景中不可见",{"1":{"705":1}}],["精英级",{"1":{"273":1}}],["精英怪",{"1":{"266":1}}],["精英怪和boss怪由于数量较少",{"1":{"20":1}}],["精英怪和boss怪的ai",{"0":{"20":1}}],["精英金怪兽88级3种等级的怪物",{"1":{"265":1}}],["某个像素点相对于屏幕矩形的位置",{"1":{"1025":1}}],["某个地方",{"1":{"759":1}}],["某此ui界面占用资源特别多",{"1":{"701":1}}],["某一份数据在其中一台redis数据库已存在",{"1":{"91":1}}],["镜像资源的加载与卸载",{"0":{"696":1}}],["深入解读job",{"1":{"926":2}}],["深复制",{"1":{"898":1}}],["深度值比渲染场景的相机大",{"1":{"1041":1}}],["深度值越大",{"1":{"1041":1}}],["深度缓冲区对绘制结果的影响为了弄清楚第一点",{"1":{"1035":1}}],["深度分析模式不止在编辑器中",{"1":{"815":1}}],["深度遍历的顺序",{"1":{"695":1}}],["深拷贝通常需要灵活地处理不能进行简单自动化特殊情况",{"1":{"111":1}}],["降低文件比特率",{"1":{"867":1}}],["降低自身防御为0有一定的时间",{"1":{"247":1}}],["降序",{"1":{"695":1}}],["排序",{"1":{"695":1,"975":1,"1039":2}}],["排列的",{"1":{"427":1}}],["过的内容",{"1":{"971":1}}],["过程都有可能出错",{"1":{"971":1}}],["过程的最后一块拼图了",{"1":{"969":1}}],["过程就为了解决这一问题而出现的",{"1":{"965":1}}],["过程当在拥有linkedentitygroup的entity上调用instantiate时",{"1":{"965":1}}],["过程依然遵循相同的规则",{"1":{"965":1}}],["过程中将cube",{"1":{"971":1}}],["过程中调用declarelinkedentitygroup",{"1":{"964":1}}],["过程中",{"1":{"964":1}}],["过程中被自动创建",{"1":{"960":1}}],["过程中有多少个不同的",{"1":{"952":1}}],["过程",{"0":{"965":1},"1":{"958":1,"964":1,"965":2,"967":1,"970":1,"1001":1}}],["过高的分辨率会造成手机发热",{"1":{"859":1}}],["过滤",{"0":{"693":1}}],["过去的",{"1":{"88":1}}],["过去的他",{"1":{"79":1}}],["过去这其实并没有什么大不了的问题",{"1":{"78":1}}],["真实发生之前",{"1":{"964":1}}],["真",{"0":{"690":1}}],["真正发挥作用的是buff",{"1":{"811":1}}],["真正导致混乱是的技能实体的范围扩大化了",{"1":{"810":1}}],["真正的服务器",{"1":{"809":1}}],["真正的",{"1":{"695":1}}],["真正调用的时候还需要传入一个实例对象",{"1":{"176":1}}],["真正接收的是低字节",{"1":{"36":1}}],["真正取得是低字节",{"1":{"36":1}}],["紧接着就是",{"1":{"688":1}}],["紧接着声明",{"1":{"199":1}}],["覆写了这两个方法",{"1":{"687":1}}],["覆盖同步数据",{"1":{"1013":1}}],["覆盖原有的",{"1":{"455":1}}],["覆盖当前的房间",{"1":{"224":1}}],["入手点",{"0":{"667":1}}],["入侵模式",{"0":{"332":1,"343":1},"2":{"333":1,"334":1,"335":1,"336":1,"337":1,"338":1,"339":1,"340":1,"341":1,"342":1,"343":1}}],["策划要做一个冰火两重天法术场",{"1":{"807":1}}],["策划需要填表的排斥状态可能成千上万",{"1":{"800":1}}],["策划可以设计出各种各样复杂的技能",{"1":{"795":1}}],["策划又提奇奇怪怪的需求了",{"1":{"666":1}}],["策略府",{"1":{"393":1}}],["依托",{"1":{"1043":1}}],["依照場景擺放",{"1":{"978":1}}],["依照",{"1":{"977":1}}],["依照目前这些",{"1":{"965":1}}],["依此来构建",{"1":{"948":1}}],["依然留下做一些殿后工作",{"1":{"986":1}}],["依然存在",{"1":{"971":1}}],["依然存在于",{"1":{"969":1}}],["依然呈灰色",{"1":{"971":1}}],["依然和",{"1":{"971":1}}],["依然会运行粒子模拟",{"1":{"969":1}}],["依然会被渲染",{"1":{"860":1}}],["依然是个谜",{"1":{"965":1}}],["依然是空的",{"1":{"964":1}}],["依然排得上用场",{"1":{"949":1}}],["依然能帮到你",{"1":{"940":1}}],["依赖于引擎底层的实现",{"1":{"701":1}}],["依赖一个相机",{"1":{"663":1}}],["依次点击菜单项edit",{"1":{"1034":1}}],["依次按条件先后顺序进行排序渲染处理",{"1":{"976":1}}],["依次",{"1":{"691":1}}],["依次遍历x",{"1":{"106":1}}],["依旧先贴出源码地址",{"1":{"666":1}}],["孙节点",{"1":{"660":1}}],["祖先节点",{"1":{"660":1}}],["×",{"1":{"660":7}}],["兄弟节点",{"1":{"660":1}}],["√",{"1":{"660":5}}],["源码中可看到",{"1":{"960":1}}],["源码",{"1":{"658":1}}],["源代码",{"1":{"166":1}}],["阻止手动发送射线穿透ugui问题",{"0":{"658":1}}],["阻塞",{"1":{"451":5}}],["阻塞操作执行得越少",{"1":{"451":1}}],["阻塞主进程",{"1":{"451":1}}],["請點我",{"1":{"657":1}}],["請注意數值部分inspector",{"1":{"650":1}}],["點下事件",{"1":{"657":1}}],["點的位移",{"1":{"634":1}}],["繼承",{"1":{"657":1}}],["触摸事件处理",{"0":{"669":1}}],["触碰的有",{"1":{"657":1}}],["触发移除component的事件",{"1":{"739":1,"744":1}}],["触发",{"1":{"510":1,"655":1}}],["触发剧情",{"1":{"254":1}}],["触发释放特效",{"1":{"242":1}}],["父物体旋转了",{"1":{"841":1}}],["父",{"1":{"660":1}}],["父节点挂载的脚本也是只实现ipointerclickhandler接口的话",{"1":{"657":1}}],["父进程在接到完成信号之后",{"1":{"455":1}}],["父进程都会fork一个子进程",{"1":{"442":1}}],["父进程无需进行io操作",{"1":{"441":1}}],["父进程做的就是fork子进程",{"1":{"441":1}}],["检测到内存泄漏",{"1":{"1022":1}}],["检测",{"1":{"1022":1}}],["检测组件的删除",{"0":{"935":1}}],["检测组件的添加",{"0":{"934":1}}],["检测这块区域内的单位并且对单位进行结算",{"1":{"801":1}}],["检测圆与检测多边形相比",{"1":{"785":1}}],["检测会有问题",{"1":{"748":1}}],["检测所得的对象的",{"1":{"695":1}}],["检测所得是所在",{"1":{"695":1}}],["检测所得",{"1":{"695":1}}],["检测所在的",{"1":{"695":1}}],["检测得到的对象是",{"1":{"695":1}}],["检测得到的对象",{"1":{"695":3}}],["检测得到的结果也应排在前面",{"1":{"695":1}}],["检测得到的结果都会存放在",{"1":{"695":1}}],["检测得到",{"1":{"695":1}}],["检测完",{"1":{"694":1}}],["检测是最终一道坎",{"0":{"694":1}}],["检测是自当前",{"1":{"691":1}}],["检测失败并结束检测",{"1":{"691":1}}],["检测过程可以看出",{"1":{"691":1}}],["检测原理就是",{"1":{"656":1}}],["检查android的managedstrippinglevel设置",{"1":{"868":1}}],["检查abilitytags",{"0":{"238":1},"2":{"239":1,"240":1}}],["检查graphics中standardshaderquality设置",{"1":{"868":1}}],["检查editor",{"1":{"868":5}}],["检查下面非常简单的代码例子",{"1":{"823":1}}],["检查通过il2cpp生成的代码",{"1":{"819":1}}],["检查那些不再被引用的对象并标记",{"1":{"813":1}}],["检查验证工具是否在path中",{"0":{"417":1}}],["检查是否有等候区",{"1":{"369":1}}],["检查怪物mlvl>",{"1":{"275":1}}],["检查附近敌人是否多个",{"1":{"244":1}}],["检查其他自定义条件",{"1":{"241":1}}],["检查冷却时间",{"1":{"241":1}}],["检查释放消耗",{"1":{"241":1}}],["检查tag",{"1":{"241":1}}],["检查人身上特效的tags是否包含这些",{"1":{"240":2}}],["检查cooldow",{"0":{"237":1}}],["检查cost特效身上的modifiers字段",{"1":{"236":1}}],["检查cost",{"0":{"236":1}}],["检查特效tag是否能够添加到角色身上",{"1":{"232":1}}],["检查",{"0":{"180":1},"1":{"860":1}}],["检查游戏规则",{"1":{"82":1}}],["检查和分发",{"1":{"64":1}}],["检查安全性",{"0":{"56":1}}],["拖拽",{"1":{"654":1}}],["射线起点在近裁剪面发出到碰撞点的距离",{"1":{"685":1}}],["射线起点到射线碰撞点的距离",{"1":{"684":1,"695":1}}],["射线检测前后的一些操作",{"0":{"695":1}}],["射线检测过程如下",{"1":{"691":1}}],["射线检测使用",{"1":{"689":1}}],["射线检测时是否忽略背向的",{"1":{"687":1}}],["射线检测的时候可以设置哪些",{"1":{"684":1}}],["射线检测的结果而具体cast的步骤则在下面这个函数中",{"1":{"675":1}}],["射线检测绝对是其中非常重要的一个东西",{"1":{"675":1}}],["射线检测",{"0":{"675":1}}],["射线检测就会依赖这个相机",{"1":{"663":1}}],["射线就依赖这个相机的culling",{"1":{"663":1}}],["射线会检测到下面的立方体",{"1":{"657":1}}],["射线投射以及发送事件",{"1":{"654":1}}],["射击真实命中玩家",{"1":{"85":1}}],["射击信息被打包到用户命令",{"1":{"85":1}}],["射击结果仍然跟延迟有关",{"1":{"45":1}}],["明明我设定好了",{"1":{"751":1}}],["明明瞄准开枪最后却",{"1":{"79":1}}],["明显unity需要实现不同平台的事件处理",{"1":{"653":1}}],["首当其冲的就是monobehavior上的事件回调",{"1":{"652":1}}],["首先进行编译dll",{"1":{"1050":1}}],["首先进行了初步的筛选",{"1":{"690":1}}],["首先截取一个垂直于摄像机z轴的",{"1":{"1025":1}}],["首先看",{"1":{"1011":1}}],["首先ability总是和item或者character结合在一起的以下authoring",{"1":{"1006":1}}],["首先这是一个纯粹的",{"1":{"950":1}}],["首先这不是一种新算法",{"1":{"122":1}}],["首先想想为什么方块能在每帧都被正确绘制到屏幕上",{"1":{"940":1}}],["首先第一部分",{"1":{"856":1}}],["首先分为两个component",{"1":{"851":1}}],["首先可以从上图中知道宽高比的计算方法",{"1":{"841":1}}],["首先打开unity的debug模式开启visual",{"1":{"838":1}}],["首先介绍authority和proxy的概念",{"1":{"801":1}}],["首先冲锋至目标单位身前",{"1":{"795":1}}],["首先说下实现技能的基本思路",{"1":{"791":1}}],["首先是",{"1":{"755":1}}],["首先来看看这些",{"1":{"695":1}}],["首先将",{"1":{"693":1}}],["首先获取其绑定的所有组件",{"1":{"691":1}}],["首先获取pointer数据",{"1":{"669":1}}],["首先调用",{"1":{"688":1}}],["首先调用geteventlist然后获得具体有哪些handler",{"1":{"678":1}}],["首先使用传入的",{"1":{"684":1}}],["首先就来看看",{"1":{"683":1}}],["首先触发pointup事件",{"1":{"672":1}}],["首先找到raycast找到的对象如果为按下事件",{"1":{"671":1}}],["首先判断是为按下事件还是释放事件处理点击事件",{"1":{"670":1}}],["首先处理点击事件",{"0":{"670":1}}],["首先会触发ipointeruphandler接口中的函数onpointerup",{"1":{"657":1}}],["首先会拿到射线检测返回的gameobject",{"1":{"657":1}}],["首先会检查服务器的",{"1":{"167":1}}],["首先到",{"1":{"566":1}}],["首先我们要把程序集分3类",{"1":{"707":1}}],["首先我们要提前介绍",{"1":{"273":1}}],["首先我们需要安装一下",{"1":{"536":1}}],["首先确认已安装",{"1":{"535":1}}],["首先去",{"1":{"472":1}}],["首先下载的时候后面加上",{"1":{"437":1}}],["首先准备三个js文件",{"1":{"398":1}}],["首先行为树会有个根节点",{"1":{"276":1}}],["首先要解决的问题",{"1":{"943":1}}],["首先要清楚类库是什么类型",{"1":{"397":1}}],["首先要了解暗黑世界中的怪物",{"1":{"266":1}}],["首先要考虑的是如何处理共享代码中生成的声效和动画效果",{"1":{"43":1}}],["首先总是类型1",{"1":{"224":1}}],["首先gan需要海量的样本去训练",{"1":{"206":1}}],["首先从appsettings",{"1":{"172":1}}],["首先注意浏览器发送的中文的",{"1":{"157":1}}],["首先identityuser已经被定义",{"1":{"140":1}}],["首先根据x坐标",{"1":{"105":1}}],["首先",{"1":{"15":1,"43":1,"69":1,"197":1,"199":1,"535":1,"661":1,"662":1,"711":1,"714":1,"795":2,"813":1,"818":1,"891":1,"895":1,"964":1}}],["時有更好的效能",{"1":{"975":1}}],["時",{"1":{"650":1,"974":2}}],["忽略了物體的",{"1":{"649":1}}],["忽略屏幕大小和分辨率根据ui的实际物理大小来显示",{"1":{"629":1}}],["忽略屏幕的大小根据ui元素的实际像素显示",{"1":{"627":1}}],["藍圖模式",{"0":{"647":1,"649":1}}],["個別維度的值是跟兩錨點個別維度的差值相關",{"1":{"644":1}}],["世界",{"1":{"841":1,"971":1}}],["世界坐标系不是最简单的",{"1":{"841":1}}],["世界坐标系",{"1":{"841":2}}],["世界坐标是三维的全局坐标",{"1":{"640":1}}],["世界中的坐标系",{"1":{"840":1}}],["世界状态",{"1":{"41":1}}],["縮放",{"1":{"639":1}}],["影響物體的旋轉",{"1":{"639":1}}],["影响drawcall的因素",{"1":{"877":1}}],["影响游戏运行效率",{"1":{"876":1}}],["影响角色幸运",{"1":{"391":1}}],["影响他人的好感",{"1":{"391":1}}],["影响采集被选为舵主忠诚+20左右堂主+10",{"1":{"378":1}}],["影响采集左堂主的智慧和四⼤武功属性",{"1":{"378":1}}],["影响练功右堂主的智慧和四⼒",{"1":{"378":1}}],["影响练功",{"1":{"378":1}}],["影响局势的",{"1":{"260":1}}],["影响性能2",{"1":{"115":1}}],["影响玩家游戏体验的另一个重要方面是客户端如何渲染其它玩家",{"1":{"46":1}}],["來建立",{"1":{"978":1}}],["來設定",{"1":{"978":1}}],["來決定描繪順序",{"1":{"977":1}}],["來決定",{"1":{"975":1,"977":1}}],["來改變",{"1":{"975":1}}],["來調整判斷方式",{"1":{"974":1}}],["來切換是否將深度資訊要寫入到",{"1":{"974":1}}],["來解決物體",{"1":{"974":1}}],["來控制",{"1":{"635":1,"636":1}}],["來定義此物件的顯示方式",{"1":{"634":1}}],["實際的",{"1":{"635":1,"636":1}}],["實測",{"1":{"564":1}}],["值到",{"1":{"965":1}}],["值将会和父",{"1":{"944":1,"1000":1}}],["值是取决于相机的",{"1":{"841":1}}],["值的增加而变得更长",{"1":{"828":1}}],["值用来记住它的位置",{"1":{"826":1}}],["值类型测试",{"0":{"895":1}}],["值类型传递",{"0":{"891":1}}],["值类型和指针永远存储在它们声明时所在的堆或栈里",{"1":{"886":1}}],["值类型和引用类型在栈里的存储是不同的",{"1":{"890":1}}],["值类型和引用类型",{"0":{"826":1}}],["值类型有时候就是会存储在堆里",{"1":{"886":1}}],["值类型会存储在堆里",{"0":{"886":1}}],["值类型",{"0":{"881":1},"1":{"880":1,"895":1}}],["值类型需要设置serializable属性才能被marshal",{"1":{"707":1}}],["值越大越先排在前面",{"1":{"695":1}}],["值",{"1":{"685":3,"695":1,"841":1,"930":1,"944":1,"1036":1}}],["值剛好正負相反的原因",{"1":{"641":1}}],["值設定所影響",{"1":{"634":1}}],["值都相等時",{"1":{"634":1}}],["值为",{"1":{"167":1}}],["維度上則是使用間距",{"1":{"635":1,"636":1}}],["維度的尺寸會受到",{"1":{"635":1,"636":1}}],["維度的值都不相等時",{"0":{"637":1},"1":{"633":1,"637":1}}],["維度的值都相等時",{"0":{"634":1},"1":{"633":1}}],["維度的值相等",{"0":{"636":1},"1":{"633":1,"636":1}}],["維度的值不相等",{"0":{"635":1},"1":{"633":1,"635":1}}],["維度值不相等時",{"0":{"636":1},"1":{"633":1,"636":1}}],["維度值相等時",{"0":{"635":1},"1":{"633":1,"635":1}}],["透明物件或是粒子特效",{"1":{"978":1}}],["透明物件排序演算法",{"1":{"975":1}}],["透明物件",{"1":{"975":1,"978":1}}],["透過兩個錨點所產生出的配置型態總共有四種",{"1":{"633":1}}],["透视摄像机旋转了15度使其可以看到地面",{"1":{"620":1}}],["型態最重要的屬性",{"1":{"633":1}}],["型的cgi",{"1":{"575":1}}],["該維度的尺寸則是固定的",{"1":{"633":1}}],["簡單來說其實就是",{"1":{"633":1}}],["與",{"1":{"633":4,"634":1,"635":1,"636":1,"978":1}}],["錨點們",{"0":{"633":1},"2":{"634":1,"635":1,"636":1,"637":1}}],["網站裡找到很好的教學文件與影片",{"1":{"632":1}}],["刘海屏的适配",{"0":{"630":1}}],["锚点时相对于父容器定义的",{"1":{"643":1}}],["锚点这个概念在unity文档的多分辨率适配中被明确的提到其作用",{"1":{"625":1}}],["锚点",{"0":{"625":1},"1":{"625":1,"639":1}}],["锚点是解决ui控件在canvas里面位置的问题",{"1":{"624":1}}],["缩放后的canvas的高为",{"1":{"628":1}}],["缩放因子",{"1":{"628":1}}],["缩放比",{"1":{"625":1}}],["缩放",{"1":{"624":1,"849":1,"981":1,"982":2}}],["缩容了",{"1":{"89":1}}],["摄像机深度是优先级最高的选项",{"1":{"1041":1}}],["摄像机深度",{"1":{"1041":1}}],["摄像机对游戏世界的渲染范围是一个平截头体",{"1":{"1025":1}}],["摄像机高度",{"1":{"618":1}}],["摄像机orthographicsize",{"1":{"618":1}}],["摄像机实际宽度",{"1":{"618":1}}],["签名",{"1":{"615":1}}],["权限",{"1":{"615":1}}],["权威服务器架构能够防止很多的作弊",{"1":{"65":1}}],["权威服务器知道玩家在",{"1":{"63":1}}],["权威服务器和静默客户端",{"0":{"63":1}}],["页面里",{"1":{"610":1}}],["页面全白",{"1":{"531":1}}],["遇到",{"1":{"610":1}}],["遇到的第一台服务器就是其应该定位到的服务器",{"1":{"92":1}}],["账号里切换地区",{"1":{"609":1}}],["账户登陆和修改root密码",{"0":{"462":1},"2":{"463":1,"464":1}}],["站点上的",{"1":{"604":1}}],["泛型方法",{"0":{"600":1}}],["泛型",{"0":{"599":1},"2":{"600":1}}],["泛型的多参数版本可以使用泛型类型生成器生成",{"1":{"176":1}}],["未启用则删除selectactivebehavior系统选择激活一个ability",{"1":{"1007":1}}],["未进行验证",{"1":{"855":1}}],["未旋转",{"1":{"756":1}}],["未设置时",{"1":{"687":1}}],["未找到解决办法",{"1":{"598":1}}],["未入睡",{"1":{"290":1}}],["顺序",{"1":{"962":1}}],["顺序能得到的正确的结果",{"1":{"940":1}}],["顺序节点就会通知父节点",{"1":{"795":1}}],["顺序节点执行下一个子节点",{"1":{"795":1}}],["顺序节点中一个子节点执行完毕后",{"1":{"795":1}}],["顺便一提声明截至仅仅针对",{"1":{"964":1}}],["顺便附带介绍下属性同步",{"1":{"809":1}}],["顺便说一句",{"1":{"594":1}}],["顺带提一下",{"1":{"784":1}}],["顺藤摸瓜看看到底是什么地方在调用我们实现的接口",{"1":{"668":1}}],["顺藤摸瓜",{"0":{"668":1}}],["顺势邀请博雅喝酒",{"1":{"296":1}}],["测试之前首先明确两点",{"1":{"1035":1}}],["测试脚本",{"1":{"774":1,"778":1}}],["测试帐户作为测试者选择加入",{"1":{"616":1}}],["测试帐户",{"1":{"616":1}}],["测试帐户被添加到开发者控制台中",{"1":{"615":1}}],["测试apk的签名与上传到dev",{"1":{"616":1}}],["测试apk",{"1":{"616":1}}],["测试要求",{"0":{"616":1}}],["测试的时候可以使用debug版本",{"1":{"613":1}}],["测试优先",{"1":{"594":1}}],["测试",{"0":{"594":1},"1":{"773":1,"836":1}}],["尝试销毁entity",{"1":{"931":1}}],["尝试开启graphicjobs并测试",{"1":{"868":1}}],["尝试释放足够的空间来填充内存分配的需求",{"1":{"813":1}}],["尝试在webgl或者ios构建设置中进行些改变",{"1":{"592":1}}],["尝试着将某个元素加入",{"1":{"220":1}}],["裹脚布的最后一块是一个目录",{"1":{"592":1}}],["额外地",{"1":{"965":1}}],["额外",{"1":{"954":1}}],["额外类型文件",{"1":{"592":1}}],["额外搞一套新版本",{"1":{"88":1}}],["又可能tick增长时间还没有过predictingtick",{"1":{"1013":1}}],["又太过于常见",{"1":{"960":1}}],["又添加了一些别的东西",{"1":{"943":1}}],["又要改技能",{"1":{"811":1}}],["又有两种分支",{"1":{"811":1}}],["又或者两个物体在同一格才为碰撞",{"1":{"758":1}}],["又因为我的ui",{"1":{"625":1}}],["又臭又长",{"1":{"592":1}}],["又叫aot",{"1":{"588":1}}],["又原地停留100ms再向右顺移一格",{"1":{"68":1}}],["菜单中的",{"1":{"1021":1}}],["菜单",{"1":{"585":1}}],["允许你跟踪系统",{"1":{"931":1}}],["允许我们的系统去一并处理相似的",{"1":{"928":1}}],["允许使用withany指定单个组件类型",{"1":{"910":1}}],["允许后台弹窗",{"1":{"608":1}}],["允许这些协议能通过网络或本地socket进行传输",{"1":{"583":1}}],["允许父组合继续处理下一个节点",{"1":{"283":1}}],["构造job的数据",{"1":{"921":1}}],["构造",{"1":{"836":1}}],["构成",{"1":{"581":1}}],["构建你自己的渲染模式",{"1":{"942":1}}],["构建的游戏保存在",{"1":{"940":1}}],["构建实例",{"1":{"714":1}}],["构建一个内部定义的类",{"1":{"714":1}}],["构建",{"0":{"539":1}}],["构建流程如下",{"1":{"510":1}}],["监测实体的删除",{"0":{"936":1}}],["监控",{"1":{"580":1}}],["监听",{"1":{"510":1}}],["像",{"1":{"1023":1}}],["像前几节介绍的",{"1":{"890":1}}],["像搭积木一样",{"1":{"879":1}}],["像上面这样的功能通常可以被替换成",{"1":{"828":1}}],["像下面这样",{"1":{"818":1}}],["像素检测",{"0":{"759":1}}],["像素大小始终不变",{"1":{"627":1}}],["像django",{"1":{"578":1}}],["像是它被",{"1":{"969":1}}],["像是一个常驻",{"1":{"575":1}}],["像是非常渴",{"1":{"296":1}}],["配合",{"1":{"577":1}}],["配置完成后",{"1":{"537":1}}],["配置前配置后",{"1":{"495":1}}],["配置一致",{"1":{"473":1}}],["配置如下",{"1":{"473":1}}],["配置说明",{"1":{"467":1}}],["配置默认路径",{"1":{"435":1}}],["配置",{"0":{"143":1,"473":1,"550":1},"1":{"525":1}}],["配置的成本",{"1":{"88":1}}],["配置文件且希望使用",{"1":{"722":1}}],["配置文件时",{"1":{"722":1}}],["配置文件中的所有程序集",{"1":{"722":1}}],["配置文件中未包含项目所需的部分",{"1":{"721":1}}],["配置文件之间进行选择",{"0":{"721":1},"2":{"722":1}}],["配置文件一般在",{"1":{"550":1}}],["配置文件",{"0":{"4":1},"1":{"550":1,"721":3}}],["脚本编译顺序",{"0":{"839":1}}],["脚本越多",{"1":{"811":1}}],["脚本读表获取数据",{"1":{"811":1}}],["脚本作为字段绑定于表里",{"1":{"811":1}}],["脚本",{"1":{"773":1}}],["脚本也不好管理",{"1":{"748":1}}],["脚本仅仅为了变焦",{"1":{"737":1}}],["脚本实现了视差功能",{"1":{"736":1}}],["脚本引用",{"1":{"705":1}}],["脚本限制",{"0":{"596":1},"1":{"604":1},"2":{"597":1,"598":1,"599":1,"600":1,"601":1,"602":1}}],["脚本与",{"1":{"576":1}}],["脚注",{"0":{"50":1}}],["废除了",{"1":{"575":1}}],["废墟3",{"1":{"297":3}}],["废墟2",{"1":{"297":1}}],["废墟",{"1":{"287":1}}],["网友解决办法",{"1":{"658":1}}],["网管组件实现了负载均衡",{"1":{"580":1}}],["网站也越来越复杂",{"1":{"573":1}}],["网络连接等",{"1":{"898":1}}],["网络连接带宽",{"1":{"86":1}}],["网络同步单元",{"1":{"807":1}}],["网络协议protobuf",{"1":{"598":1}}],["网络协议规定接收到得第一个字节是高字节",{"1":{"36":1}}],["网络通讯协议",{"1":{"445":1}}],["网络通信的丢包也将导致明显的毛刺",{"1":{"83":1}}],["网络视图net",{"0":{"86":1}}],["网络延迟",{"1":{"804":1}}],["网络延迟和滞后补偿可能会引起真实的世界不可能的逻辑",{"1":{"85":1}}],["网络延时为100ms",{"1":{"43":1}}],["网络速率和快照更新设置",{"1":{"82":1}}],["网络对时",{"0":{"51":1},"1":{"51":1}}],["网络上可玩的大部分动作游戏都是c",{"1":{"41":1}}],["网络上传输的数据都是字节流",{"1":{"37":1}}],["网络环境下的健壮性",{"1":{"40":1}}],["网络字节转成本机",{"1":{"38":1}}],["网络字节序是大端字节序",{"1":{"37":1}}],["网络字节序",{"0":{"35":1,"37":1},"1":{"33":1},"2":{"36":1,"37":1}}],["网络发送字节流是按大端序发送",{"1":{"38":1}}],["网络好的玩家",{"1":{"15":1}}],["网络中有一个",{"1":{"12":1}}],["断发展",{"1":{"573":1}}],["阿里的有点问题",{"1":{"567":1}}],["阿里dns服务器",{"1":{"529":1}}],["否則請不要使用其他版本",{"1":{"567":1}}],["否则内存",{"1":{"1022":2}}],["否则都无法参与合批",{"1":{"980":1}}],["否则cpu串行计算耗费的时间太长会造成场景渲染卡顿",{"1":{"980":1}}],["否则你无法接受基于",{"1":{"940":1}}],["否则你永远不需要再次输入你的凭证信息",{"1":{"411":1}}],["否则将导致文件过大",{"1":{"872":1}}],["否则将无法恢复体力和精神",{"1":{"380":1}}],["否则不执行",{"1":{"795":1}}],["否则为发生碰撞",{"1":{"761":1}}],["否则会删除该parent和localtoparent组件",{"1":{"1053":1}}],["否则会报错",{"1":{"746":1}}],["否则会将自身添加到行为树的激活任务中",{"1":{"277":1}}],["否则收集的数据会报错",{"1":{"742":1}}],["否则也为",{"1":{"695":1}}],["否则同样也是返回基类设置的",{"1":{"695":1}}],["否则还会继续向上递归检测父节点",{"1":{"691":1}}],["否则直接使用当前",{"1":{"688":1}}],["否则返回flase",{"1":{"751":1}}],["否则返回",{"1":{"687":1}}],["否则激活可能无效",{"1":{"554":1}}],["否则很多插件不能使用nginx",{"1":{"550":1}}],["否则调用",{"1":{"167":1}}],["否则一些模块例如博客的js时不会起作用的",{"1":{"134":1}}],["否则就计算",{"1":{"694":1}}],["否则就是默认所有的层",{"1":{"684":1}}],["否则就没法根据服务器来纠正客户端的预测错误",{"1":{"43":1}}],["否则就没办法获得准确的",{"1":{"41":1}}],["否则就要等待最慢的玩家",{"1":{"11":1}}],["否则",{"1":{"15":1}}],["版权所有",{"1":{"770":1}}],["版開發的",{"1":{"567":1}}],["版本而异",{"1":{"524":1}}],["版本号更多",{"1":{"509":1}}],["版本的particlesystem",{"1":{"969":1}}],["版本的",{"1":{"465":1,"576":1}}],["版本大于等于3的powershell确保您已允许powershell执行本地脚本",{"1":{"426":1}}],["版本",{"1":{"198":1,"567":1}}],["版本2的代码与版本1不同",{"1":{"88":1}}],["這自己就沒有經驗",{"1":{"978":1}}],["這分成兩個部分探討",{"1":{"977":1}}],["這篇文章",{"1":{"975":1}}],["這也關係到物件在",{"1":{"974":1}}],["這裡是ipointerdownhandler",{"1":{"657":1}}],["這裡我們用",{"1":{"566":1}}],["這就是為什麼",{"1":{"641":1}}],["這四對屬性個別不會同時出現",{"1":{"633":1}}],["這兩天",{"1":{"567":1}}],["裡提到",{"1":{"564":1}}],["顯卡都可以跑",{"1":{"564":1}}],["硬體需求",{"0":{"564":1}}],["填充character的ownedcollection组件",{"1":{"1007":1}}],["填充的部分值不一样",{"1":{"685":1}}],["填入到idea中",{"1":{"560":1}}],["填写窗口中的下一个状态",{"1":{"43":1}}],["电压过低也会导致黑屏",{"1":{"551":1}}],["复杂的合批处理可能会消耗更多的cpu时间",{"1":{"849":1}}],["复杂的图形",{"1":{"788":1}}],["复杂度主要放在entity的修改上了",{"1":{"738":1}}],["复合多层背景的滚动",{"0":{"734":1},"1":{"724":1}}],["复刻",{"1":{"542":1}}],["复刻仓库",{"0":{"542":1}}],["复制到",{"1":{"969":1}}],["复制到新的电脑中",{"1":{"481":1}}],["复制一个已有的entity",{"1":{"907":1}}],["复制memcpy",{"1":{"898":2}}],["复制",{"1":{"898":2}}],["复制所有值类型变量",{"1":{"896":1}}],["复制类及其成员跟原始类不产生任何重叠",{"1":{"896":1}}],["复制不仅仅是复制",{"0":{"894":1},"2":{"895":1,"896":1,"897":1,"898":1}}],["复制x给pvalue",{"1":{"892":1}}],["复制代码",{"1":{"203":1,"204":1}}],["复制代码以上的源码可以",{"1":{"202":1}}],["复制代码下面代码则是以另一种令人容易理解的方式完成了这个任务",{"1":{"202":1}}],["复制代码代码的哈希函数",{"1":{"201":1}}],["复制代码代码所计算得出的",{"1":{"200":1}}],["复制代码上面的代码很直观",{"1":{"199":1}}],["复制代码数组会在算法后续的哈希计算中使用到",{"1":{"199":1}}],["复制代码至此",{"1":{"197":1}}],["复制代码点积也可以理解为向量a在向量b上的投影",{"1":{"197":1}}],["复制代码如果两向量互相垂直",{"1":{"197":1}}],["复制代码如果两向量指向相反方向",{"1":{"197":1}}],["复制代码换句话说",{"1":{"197":1}}],["复制算法=标记",{"1":{"121":1}}],["复制算法>标记",{"1":{"121":1}}],["复制算法适合做新生代的gc",{"1":{"120":1}}],["复制算法不适用于存活对象较多的场合",{"1":{"120":1}}],["复制算法的代价是将内存缩小为原来的一半",{"1":{"120":1}}],["复制算法使得每次都只对整个半区进行内存回收",{"1":{"120":1}}],["复制算法简单来说就是把内存一分为二",{"1":{"120":1}}],["复制算法",{"0":{"120":1}}],["太大了",{"1":{"537":1}}],["太郎抢走了你裝勾玉的钱袋",{"1":{"296":1}}],["剥离一些依赖模块",{"1":{"534":1}}],["国家队产品",{"1":{"529":1}}],["国内公共dns服务提供商",{"0":{"529":1}}],["口碑不错",{"1":{"529":3}}],["响应式系统的",{"1":{"742":1}}],["响应式的系统就像执行式系统一样",{"1":{"742":1}}],["响应快",{"1":{"529":2}}],["响应速度也不错",{"1":{"529":1}}],["响应也不可控制",{"1":{"48":1}}],["毕竟你不太可能想要实例化另一个",{"1":{"964":1}}],["毕竟是一个",{"1":{"840":1}}],["毕竟是大品牌",{"1":{"529":1}}],["毕须博须",{"1":{"266":1}}],["百度dns服务器",{"1":{"529":1}}],["市场",{"0":{"515":1}}],["里都是可行的",{"1":{"971":1}}],["里就只有particlesystem",{"1":{"969":1}}],["里的对象都会得到同样的结果",{"1":{"971":1}}],["里的层级结构并不是",{"1":{"964":1}}],["里的元素都是一个",{"1":{"960":1}}],["里的",{"1":{"956":1,"957":1,"964":2,"971":2}}],["里常用的",{"1":{"955":1}}],["里有一个",{"1":{"952":1}}],["里",{"1":{"884":1,"890":1,"940":1,"950":1,"962":1,"964":2}}],["里面显示已经",{"1":{"971":1}}],["里面加上",{"1":{"966":1}}],["里面注册",{"1":{"964":1}}],["里面嵌套的",{"1":{"960":1}}],["里面装的是",{"1":{"960":1}}],["里面所有带有",{"1":{"955":1}}],["里面寻找",{"1":{"948":1}}],["里面没有文件关闭操作",{"1":{"898":1}}],["里面",{"1":{"668":1,"941":1,"950":1,"951":1,"961":1}}],["里面包含的",{"1":{"965":1}}],["里面包含一个值类型myvalue",{"1":{"887":1}}],["里面包含ui事件的详细信息",{"1":{"657":1}}],["里面包含了一个事件的类型",{"1":{"657":1}}],["里面包含了普通的",{"1":{"510":1}}],["里实例的方法其实都是后者",{"1":{"176":1}}],["级别的代码",{"1":{"510":1}}],["果然已经有提供对应的",{"1":{"510":1}}],["果实",{"1":{"287":1}}],["语句",{"1":{"1023":1}}],["语句块",{"1":{"823":1}}],["语言是在小的临时内存分配会被世代的垃圾回收器和分配大小敏感的内存池有效率处理的假设下开发的",{"1":{"820":1}}],["语言写的",{"1":{"510":1}}],["语言和区域",{"1":{"152":1}}],["语法表示",{"1":{"509":1}}],["描述了",{"1":{"941":1}}],["描述一些构建信息",{"1":{"509":1}}],["描述",{"1":{"509":1,"687":1}}],["描述问题",{"0":{"208":1}}],["登录的用户一定是测试人员",{"1":{"611":1}}],["登录时如何维护密码",{"1":{"509":1}}],["登上天梯得功法28",{"1":{"295":1}}],["仓库的名称不要例如igiven",{"1":{"541":1}}],["仓库的",{"1":{"507":2}}],["准备渲染对象",{"1":{"876":1}}],["准备一个覆盖整个屏幕的四边形顶点",{"1":{"726":1}}],["准备好了三件套工具之后",{"1":{"500":1}}],["准备工作",{"0":{"199":1}}],["切换",{"1":{"941":1}}],["切换国内的镜像源",{"0":{"478":1},"2":{"479":1,"480":1,"481":1,"482":1,"483":1}}],["切线是垂直于法线的一条向量",{"1":{"846":1}}],["切线",{"1":{"846":1}}],["切磋",{"0":{"367":1}}],["升级到与您的",{"1":{"477":1}}],["升级你能得到什么",{"1":{"384":1}}],["密码生成工具",{"1":{"475":1}}],["密码永远不会被存储在磁盘中",{"1":{"411":1}}],["私钥是",{"1":{"459":1}}],["私有成员可能不能像期望的那样被克隆",{"1":{"111":1}}],["待续",{"1":{"630":1}}],["待会要用到这个",{"1":{"459":1}}],["待定",{"1":{"287":1}}],["换一下坐标就和处理绝对坐标一样了",{"1":{"841":1}}],["换言之",{"1":{"455":1}}],["换句话说",{"1":{"45":1,"63":1,"75":1,"759":1,"898":1,"940":1}}],["出来",{"1":{"964":1}}],["出发来而不是仅仅是",{"1":{"947":1}}],["出错了",{"1":{"896":1}}],["出场",{"0":{"689":1}}],["出子进程之后开始启用",{"1":{"455":1}}],["出现跳帧以及撕裂",{"1":{"854":1}}],["出现以下的错误",{"1":{"537":1}}],["出现少",{"1":{"299":1}}],["出现在梯子的顶部旁边",{"1":{"225":1}}],["出现数组越界错误",{"1":{"199":1}}],["出现",{"1":{"104":1}}],["出现卡顿现象",{"1":{"11":1}}],["键",{"1":{"464":1,"533":1,"969":1}}],["键在数据库的当前值",{"1":{"454":1}}],["键的状态",{"1":{"453":1}}],["伪客户端执行命令的效果",{"1":{"452":1}}],["停机时丢失的数据量",{"1":{"451":1}}],["停下",{"1":{"76":1}}],["官網",{"1":{"564":1}}],["官网下载idea",{"1":{"554":1}}],["官网",{"1":{"472":1}}],["官网上所说的",{"1":{"449":1}}],["官方",{"1":{"736":1}}],["官方文档",{"0":{"544":1},"1":{"919":1,"984":1}}],["官方文档是这样介绍的",{"1":{"174":1}}],["官方初始化链接",{"1":{"404":1}}],["距离为z的平面p",{"1":{"1025":1}}],["距离",{"1":{"695":1}}],["距离以内的对象",{"1":{"689":1}}],["距离最近的敌人距离",{"1":{"215":1}}],["距今已经超过",{"1":{"449":1}}],["距今不超过",{"1":{"449":1}}],["旧的",{"1":{"449":1}}],["功能图集",{"1":{"861":5}}],["功能",{"1":{"604":1}}],["功能开启的情况下",{"1":{"456":1}}],["功能会继续执行",{"1":{"455":1}}],["功能被关闭",{"1":{"448":1}}],["功用",{"1":{"287":2}}],["域则保存着所有等待写入到",{"1":{"445":1}}],["末尾",{"1":{"445":2}}],["记住job操作的是数据的拷贝",{"1":{"920":1}}],["记住一点",{"1":{"841":1}}],["记住这个顺序",{"1":{"652":1}}],["记住",{"1":{"611":1}}],["记得设定存在时间",{"1":{"751":1}}],["记得释放其中的一份",{"1":{"705":1}}],["记得将这个url输入到google",{"1":{"607":1}}],["记得",{"1":{"460":1}}],["记录这个多边形投影到轴上的最高和最低点",{"1":{"784":1}}],["记录最后一次",{"1":{"456":1}}],["记录当前",{"1":{"456":1}}],["记录到",{"1":{"443":1}}],["记忆方法",{"1":{"32":2}}],["软件列表",{"0":{"438":1}}],["捕捉错误",{"1":{"425":1}}],["應用程式中了",{"1":{"425":1}}],["現在你可以將",{"1":{"425":1}}],["檔案引用兩個命名空間如下",{"1":{"425":1}}],["$",{"1":{"424":1}}],["$env",{"1":{"424":1}}],["列4为0",{"1":{"952":1}}],["列不能用于统计用户创建的线程中发生的托管分配",{"1":{"878":1}}],["列",{"1":{"878":1}}],["列就不能用来测量在用户自己创建的线程中的托管内存分配",{"1":{"815":1}}],["列在这里只是为了完整性的考虑",{"1":{"444":1}}],["列表",{"1":{"427":1,"898":1}}],["列表会被遍历",{"1":{"151":1}}],["列出了许多出版物和在线文章",{"1":{"833":1}}],["列出env驱动器中的内容void",{"1":{"424":1}}],["列出所有的函数",{"1":{"424":1}}],["列出所有的变量",{"1":{"424":1}}],["列出所有的环境变量",{"1":{"424":1}}],["列出所有alias",{"1":{"424":1}}],["驱动器",{"1":{"424":4}}],["驱动器是一个数据存储位置",{"1":{"424":1}}],["凭空",{"1":{"955":1}}],["凭证存储",{"1":{"423":1}}],["凭证以及",{"1":{"411":1}}],["凭据管理器中手动更改我们的credential凭证",{"1":{"420":1}}],["风险",{"1":{"412":1}}],["风神接受了礼物",{"1":{"296":1}}],["访问与",{"1":{"1054":1}}],["访问实体数据",{"0":{"909":1},"2":{"910":1,"911":1,"912":1}}],["访问信息没有约束",{"1":{"879":1}}],["访问静态变量更快捷",{"1":{"707":1}}],["访问被拒绝",{"1":{"707":1}}],["访问量不大的话",{"1":{"581":1}}],["访问",{"1":{"490":1}}],["访问到路径对应的项目",{"1":{"412":1}}],["访问然后添加host",{"1":{"404":1}}],["十分相似",{"1":{"931":1}}],["十分类似",{"1":{"411":1}}],["十字链表",{"1":{"110":1}}],["十字链表基本原理",{"0":{"106":1}}],["十字链表法",{"0":{"105":1},"2":{"106":1,"107":1,"108":1,"109":1,"110":1}}],["窗口消失",{"1":{"971":1}}],["窗口却正常显示着",{"1":{"969":1}}],["窗口里没有",{"1":{"969":1}}],["窗口里什么都没有",{"1":{"943":1}}],["窗口中显示了addressable操作的引用记数",{"1":{"700":1}}],["窗口关闭",{"1":{"657":1}}],["窗口",{"1":{"407":1}}],["占位",{"1":{"964":1}}],["占用了",{"1":{"537":1}}],["占据的交叉轴空间叫做",{"1":{"406":1}}],["占近似一个格子",{"1":{"286":1}}],["叫做燃烧",{"1":{"811":1}}],["叫做",{"1":{"406":1}}],["称为",{"1":{"406":2,"861":1}}],["称为虚拟节点",{"1":{"96":1}}],["报错",{"1":{"403":1}}],["既要改表",{"1":{"811":1}}],["既可以通过全局方式来引用",{"1":{"397":1}}],["既然已经接受了游戏就是改变数据和展示数据",{"1":{"943":1}}],["既然是二维坐标系那么",{"1":{"841":1}}],["既然是射线检测那么最重要的方法莫过于",{"1":{"684":1}}],["既然需要透视效果",{"1":{"724":1}}],["既然我们已经找到了这个宝贝",{"1":{"668":1}}],["既然我们有一个100毫秒的延迟插值",{"1":{"83":1}}],["既然击中检测服务器上的逻辑如此复杂为什么不把命中检查放在客户端呢",{"1":{"85":1}}],["模块是抽象",{"1":{"1010":1}}],["模块类库引入的方式其中",{"1":{"401":1}}],["模块类库",{"0":{"400":1},"1":{"397":1,"398":1}}],["模式来实现",{"1":{"971":1}}],["模式呢",{"1":{"968":1}}],["模式里面的子对象上添加",{"1":{"968":1}}],["模式也不能清晰完整地转换整个层级到",{"1":{"968":1}}],["模式会产生太多的",{"1":{"968":1}}],["模式会将凭证用明文的形式存放在磁盘中",{"1":{"411":1}}],["模式会将凭证存放在内存中一段时间",{"1":{"411":1}}],["模式功能的代码",{"1":{"967":1}}],["模式视作将对象转化为",{"1":{"955":1}}],["模式最酷的在于",{"1":{"955":1}}],["模式的",{"0":{"956":1}}],["模式的预期用法",{"1":{"954":1}}],["模式的操作特性可以总结如下",{"1":{"451":1}}],["模式则是从",{"1":{"944":1}}],["模式下添加的particlesystem这个",{"1":{"968":1}}],["模式下转换后的parent和localtoparent",{"1":{"968":1}}],["模式下会被转换成localtoworld+rendermesh之前我们的",{"1":{"968":1}}],["模式下",{"1":{"449":1,"695":1,"954":2,"968":1}}],["模式可以接受一个",{"1":{"413":1}}],["模式",{"0":{"954":1,"968":1},"1":{"411":1,"451":4,"698":3,"927":1,"955":1,"956":1,"968":1,"969":1,"971":1}}],["模型顶点变换的操作是由cpu完成的",{"1":{"980":1}}],["模型会被描述为一个二维矩阵",{"1":{"208":1}}],["模型一般就是一个二维的封闭区域",{"1":{"206":1}}],["模型则是这些物体的模型",{"1":{"206":1}}],["诅咒",{"1":{"394":1}}],["范围效果",{"1":{"394":1}}],["范围内的余数",{"1":{"199":1}}],["近战加成",{"1":{"394":1}}],["近战攻击伤害每10敏捷=1",{"1":{"384":1}}],["闪电",{"1":{"394":1}}],["闪避值+3",{"1":{"392":6}}],["闪避值每1敏捷=2命中值每5智力=1",{"1":{"384":1}}],["闪避除了可以规避伤害",{"1":{"385":1}}],["闪避将提高1",{"1":{"385":1}}],["闪避是流放之路的三大基本防御形式之一",{"1":{"385":1}}],["闪避是角色在受到攻击前的第一层防御形式",{"1":{"385":1}}],["闪避会增加角色完全避免受到攻击的几率",{"1":{"385":1}}],["闪避不同于躲避",{"1":{"384":1}}],["闪避几率不会低于5",{"1":{"384":1}}],["学识",{"1":{"393":1}}],["学习向量的不错资源",{"1":{"789":1}}],["学习新技能",{"1":{"388":1}}],["学习力",{"0":{"374":1},"1":{"372":1}}],["谋略",{"1":{"393":1}}],["谋反",{"0":{"337":1}}],["威望",{"1":{"393":1}}],["威力强大但不计后果的攻击可以增加伤害和命中率但忽视防御",{"1":{"247":1}}],["铸造",{"1":{"393":1}}],["铸造房有等级的设定",{"1":{"380":1}}],["铸造房",{"1":{"380":1}}],["贩卖商品",{"1":{"393":1}}],["巫术",{"1":{"392":1}}],["儒学",{"1":{"392":1}}],["儒家",{"0":{"251":1}}],["佛法",{"1":{"392":1}}],["佛学",{"1":{"297":2}}],["境界属性",{"0":{"392":1}}],["邪恶",{"1":{"391":1}}],["邪人死地",{"1":{"297":1}}],["③弟子叛逃",{"1":{"391":1}}],["难不成笔者在骗人",{"1":{"847":1}}],["难以寸进",{"1":{"391":1}}],["难度",{"1":{"297":1}}],["②内门心魔",{"1":{"391":1}}],["①外门怠工",{"1":{"391":1}}],["情绪过低",{"1":{"391":1}}],["情况下被通知到的entity",{"1":{"742":1}}],["情况如下图所示于是我们在",{"1":{"68":1}}],["情况是这样的",{"1":{"64":1}}],["童趣",{"1":{"391":1}}],["历练时获得物品的概率也和机缘有关",{"1":{"391":1}}],["历史位置信息记录了物体的时间戳",{"1":{"46":1}}],["历史位置",{"1":{"46":1}}],["魅力",{"1":{"391":1}}],["习武的时候提高的领悟力",{"1":{"391":1}}],["习惯性喂了小猫几串小鱼干",{"1":{"296":1}}],["悟性",{"1":{"391":1}}],["气质才情",{"0":{"391":1}}],["爆击伤害",{"1":{"390":1}}],["力道+5",{"1":{"392":1}}],["力道",{"1":{"390":1,"394":1,"395":1}}],["力量",{"1":{"246":1,"384":1,"394":1}}],["身上有两个组件",{"1":{"987":1}}],["身法+5",{"1":{"392":1}}],["身法",{"1":{"390":1,"394":1,"395":1}}],["身为门派掌门人",{"1":{"382":1}}],["满意度+10",{"1":{"389":1}}],["满足条件则进行射线检测",{"1":{"691":1}}],["满足条件的",{"1":{"690":1}}],["满足公式一",{"1":{"270":1}}],["满足",{"1":{"207":1}}],["举例",{"0":{"992":1}}],["举一个",{"1":{"955":1}}],["举两个类来测试",{"1":{"716":1}}],["举孝廉",{"1":{"389":1}}],["举个栗子",{"1":{"270":2,"862":1,"903":1}}],["举个现实例子",{"1":{"204":1}}],["举个例子来理解伪随机",{"1":{"197":1}}],["举个例子",{"1":{"32":1,"46":1,"89":1,"443":1,"453":1,"591":1,"783":1,"795":1,"824":1,"968":1}}],["售卖收入+50",{"1":{"389":1}}],["售价",{"1":{"302":1}}],["售价和稀有度有关",{"1":{"302":1}}],["街市繁荣",{"1":{"389":1}}],["街边店铺在卖各或各样的面具",{"1":{"296":1}}],["街边店铺门口出现了一道熟悉的身影",{"1":{"296":1}}],["贸易影响+50",{"1":{"389":1}}],["粮食产值+30",{"1":{"389":1}}],["助农",{"1":{"389":1}}],["助医",{"1":{"389":1}}],["助工",{"1":{"389":1}}],["促进思辨",{"1":{"388":1}}],["押镖送货",{"1":{"387":1}}],["哔哩哔哩",{"1":{"385":1,"864":1,"899":1}}],["暴击几率",{"1":{"390":1}}],["暴击和暴击伤害解析",{"1":{"385":1}}],["暴躁外皮的tc=87等等",{"1":{"267":1}}],["暴躁外皮",{"1":{"266":1}}],["游侠网",{"1":{"385":1}}],["游戏能预先转换好",{"1":{"971":1}}],["游戏了",{"1":{"955":1}}],["游戏基本上就这些了",{"1":{"940":1}}],["游戏才会有完整",{"1":{"854":1}}],["游戏运行速度为200fps",{"1":{"854":1}}],["游戏帧速掉为30",{"1":{"854":1}}],["游戏开发的时候",{"1":{"841":1}}],["游戏开发",{"1":{"840":1}}],["游戏开发殷勤",{"1":{"840":1}}],["游戏而言",{"1":{"724":1}}],["游戏前期一般情况下很难招收到",{"1":{"378":1}}],["游戏难度决定",{"1":{"293":1}}],["游戏名称",{"0":{"288":1}}],["游戏进入",{"1":{"275":1}}],["游戏内有7种自带",{"1":{"270":1}}],["游戏自己就会随机生成很多很多有意思的场景",{"1":{"225":1}}],["游戏中的开启垂直同步",{"1":{"854":1}}],["游戏中的大部分武器",{"1":{"380":1}}],["游戏中存在着某些类型的物体",{"1":{"832":1}}],["游戏中技能的升级",{"1":{"792":1}}],["游戏中每一种词缀都代表了某一种特定的属性",{"1":{"270":1}}],["游戏中表现为其名字为白色",{"1":{"266":1}}],["游戏中表现为其名字为蓝色",{"1":{"266":1}}],["游戏中表现为其名字为暗金色",{"1":{"266":1}}],["游戏中是不显示的",{"1":{"224":1}}],["游戏中使用的方法记录下来",{"1":{"217":1}}],["游戏数据使用增量更新压缩来减少网络传输",{"1":{"82":1}}],["游戏架构",{"1":{"78":1}}],["游戏状态以一定的频率",{"1":{"73":1}}],["游戏的帧速被限制为60",{"1":{"854":1}}],["游戏的状态由服务器独自管理",{"1":{"63":1}}],["游戏的过程就是每一个turn不断向前推进",{"1":{"11":1}}],["游戏涉及中延迟补偿的使用",{"0":{"48":1}}],["游戏体验将非常差",{"1":{"46":1}}],["游戏逻辑的快照",{"1":{"15":1}}],["游戏逻辑的回滚回滚逻辑",{"1":{"15":1}}],["游戏外挂的种类有很多",{"1":{"15":1}}],["游戏就会无法继续或者掉线玩家无法重连",{"1":{"12":1}}],["公钥是",{"1":{"459":1}}],["公共秩序+8",{"1":{"389":1}}],["公共语言运行时",{"1":{"131":1}}],["公共语言运行库",{"1":{"127":1}}],["公式如下",{"1":{"628":1}}],["公式二",{"1":{"385":1}}],["公式一",{"1":{"385":1}}],["躲避法术",{"1":{"385":1}}],["爪",{"1":{"384":1}}],["匕首",{"1":{"384":1}}],["细剑",{"1":{"384":1}}],["敏捷也能够提供闪避奖励",{"1":{"385":1}}],["敏捷",{"1":{"384":1,"394":1}}],["广撒银钱",{"1":{"383":1}}],["广结善缘也不失为一种求存之道",{"1":{"383":1}}],["彼此之间都不存在任何友谊",{"1":{"383":1}}],["头也不眩晕了",{"1":{"854":1}}],["头文件在contents",{"1":{"591":1}}],["头文件在editor",{"1":{"591":1}}],["头上有问号",{"1":{"382":1}}],["头目会掉落魔法物品或更多的黄金",{"1":{"274":1}}],["头目",{"1":{"266":1}}],["练功弟子等不同的修行需要放入对应栏目",{"1":{"382":1}}],["练习各类兵器刀棍暗器",{"1":{"380":1}}],["练习各种拳脚功夫",{"1":{"380":1}}],["舵主必须指定",{"1":{"381":1}}],["舵主的忠诚",{"1":{"381":1}}],["舵主的忠诚度和智慧影响该分舵",{"1":{"378":1}}],["右手螺旋",{"1":{"846":1}}],["右上角是",{"1":{"841":1}}],["右上anchor",{"1":{"641":1,"645":1}}],["右边按钮还包含对应的第三方隐私服务链接",{"1":{"607":1}}],["右键默认就有添加到开始屏幕",{"1":{"496":1}}],["右键点击系统桌面左下角的",{"1":{"407":1}}],["右键发送到菜单位置",{"0":{"407":1}}],["右堂主的弟子则可增加10的忠诚度",{"1":{"381":1}}],["右堂主的聪明和四大武功属性影响弟子的采集效率",{"1":{"381":1}}],["右堂主则可根据需要选择是否指定",{"1":{"381":1}}],["右侧是对照组生成的地图",{"1":{"215":1}}],["聪明和四力会影响弟子的采集效率",{"1":{"381":1}}],["聪明和四大武功属性",{"1":{"381":1}}],["聪明",{"1":{"381":1}}],["虽说职位的选择相对少了很多",{"1":{"381":1}}],["虽然拥有",{"1":{"966":1}}],["虽然它们经常同时出现",{"1":{"958":1,"1001":1}}],["虽然并没有性能上的提升",{"1":{"955":1}}],["虽然整个游戏按照这样的方式构建非常恐怖",{"1":{"945":1}}],["虽然entity没有类型",{"1":{"906":1}}],["虽然会增加一些构建时间和包体积",{"1":{"868":1}}],["虽然",{"1":{"864":1}}],["虽然堆中的可用空间总量可能很大",{"1":{"857":1}}],["虽然堆中的总可用空间是非常大的",{"1":{"813":1}}],["虽然重要",{"1":{"841":1}}],["虽然cpu的消耗在访问一个属性一次时并不是非常高",{"1":{"824":1}}],["虽然这模式的名称叫",{"1":{"969":1}}],["虽然这需要在调用代码中完成数组的初始分配",{"1":{"828":1}}],["虽然这通常不是问题",{"1":{"604":1}}],["虽然这类问题很难得到完美解答",{"1":{"80":1}}],["虽然可在自己的代码中使用这些功能",{"1":{"604":1}}],["虽然protobuf本身是支持dictionary的",{"1":{"598":1}}],["虽然江湖中的十二大门派可分为正邪两道",{"1":{"383":1}}],["虽然以贴图为例来说明",{"1":{"207":1}}],["虽然柏林噪声算法一定程度上模拟了自然噪声",{"1":{"204":1}}],["虽然运行效率高",{"1":{"197":1}}],["虽然每个顶点生成的梯度向量看似随机",{"1":{"197":1}}],["虽然我们可以通过dbcontext配置修改数据表的字段",{"1":{"140":1}}],["虽然本文的读者都是游戏开发者",{"1":{"80":1}}],["虽然存在着作弊的玩家",{"1":{"67":1}}],["虽然混合纠正方法也可以使用",{"1":{"50":1}}],["虽然你看到自己用",{"1":{"45":1}}],["虽然看起来笨重一些",{"1":{"15":1}}],["江湖上其他门派的发展速度都要远超我们",{"1":{"383":1}}],["江湖有江湖自己的规则",{"1":{"381":1}}],["江湖场景",{"1":{"287":1}}],["座次排定",{"0":{"381":1}}],["炼制丹药",{"1":{"393":1}}],["炼丹产值+30",{"1":{"389":1}}],["炼丹制药之地",{"1":{"380":1}}],["炼丹房",{"1":{"380":1}}],["炼妖塔",{"1":{"295":1}}],["饰品等物品",{"1":{"380":1}}],["鞋子",{"1":{"380":1}}],["安卓下使用vorbis格式",{"1":{"867":1}}],["安卓上",{"1":{"855":1}}],["安装过程中可能会遇上不少麻烦",{"1":{"569":1}}],["安装stable",{"1":{"569":1}}],["安装scoop到自定义目录",{"0":{"428":1},"2":{"429":1,"430":1}}],["安装scoop前提",{"0":{"426":1}}],["安装模型",{"1":{"568":1}}],["安装完成以后",{"1":{"536":1}}],["安装配置",{"0":{"466":1}}],["安装",{"0":{"465":1,"472":1,"533":1,"546":1},"1":{"510":1},"2":{"547":1,"548":1,"549":1,"550":1}}],["安装应用",{"0":{"430":1}}],["安裝時記得勾選",{"1":{"567":1}}],["安裝前可以取消",{"1":{"566":1}}],["安裝過程中可取消與",{"1":{"566":1}}],["安裝步驟",{"0":{"565":1},"2":{"566":1,"567":1,"568":1,"569":1,"570":1,"571":1}}],["安裝",{"0":{"415":1,"416":1}}],["安排他到修炼室闭关修炼将有可能悟出更加厉害的新武功来",{"1":{"380":1}}],["安全不管什么请求都要经过代理服务器",{"1":{"581":1}}],["安全相关",{"0":{"509":1}}],["安全支持等服务",{"1":{"127":1}}],["安全地通过设置cl",{"1":{"83":1}}],["兵器武场也是门派中最基本的练武之地",{"1":{"380":1}}],["兵器武场",{"1":{"380":1}}],["徒手武场是门派中最基本的练武之地",{"1":{"380":1}}],["徒手武场",{"1":{"380":1}}],["徒手武功在兵器场和兵器武功在徒手武场",{"1":{"374":1}}],["招募",{"1":{"389":1}}],["招募弟子",{"1":{"380":1}}],["招收进入的弟子会自动获得房间分配",{"1":{"380":1}}],["厢房",{"1":{"380":1}}],["唯一要提醒各位的是",{"1":{"380":1}}],["唯一的区别就是法术场在某一位置使用攻击盒检测目标",{"1":{"807":1}}],["唯一的问题是播放模式下在unity中做出的更改不会保存",{"1":{"737":1}}],["唯一的问题就是这个时间复杂度不稳定",{"1":{"108":1}}],["唯一的控制台变量是",{"1":{"86":1}}],["趁着现下各大门派防守松懈之机",{"1":{"380":1}}],["健康会影响分舵弟子的生产效率",{"1":{"381":1}}],["健康|",{"1":{"378":1}}],["健康和智慧影响⽣产",{"1":{"378":1}}],["卖价+50",{"1":{"378":1}}],["卖钱",{"1":{"300":1}}],["|b|",{"1":{"780":1}}],["|a",{"1":{"781":1}}],["|a|",{"1":{"780":2}}],["|ab|",{"1":{"756":3}}],["|cb|",{"1":{"756":2}}],["|备注",{"1":{"378":1}}],["|复仇|当生命小于30",{"1":{"378":1}}],["|求生|当生命低于20",{"1":{"378":1}}],["|反击|当被对手重击石会快速发出下一招武功|",{"1":{"378":1}}],["|意志|对昏迷效果免疫|",{"1":{"378":1}}],["|坚毅|对所有恐惧免疫|神打|除非受到大于最大健康10",{"1":{"378":1}}],["|武痴|所有武功重击率",{"1":{"378":1}}],["|劲掌|以更快的速度施展掌法|自暴|当生命低于150时销号生命100点事下一招攻击+300|",{"1":{"378":1}}],["|速拳|以更快的速度施展拳法|毒杀|当对手楚于异常状态时武功攻击力",{"1":{"378":1}}],["|快腿|以更快速度施展腿法|毒胆|对所有中毒免疫|",{"1":{"378":1}}],["|快逢|织造时指力属性",{"1":{"378":1}}],["|棍通|以更快的速度施展棍法|羽化|施展轻功无须任何消耗|",{"1":{"378":1}}],["|剑灵|以更快的速度施展剑法|忍术|施展轻功无视高度影响|",{"1":{"378":1}}],["|刀敏|以更快的速度施展刀法|焚身|击中对手时有20",{"1":{"378":1}}],["|开窍|战斗的道的经验成以1",{"1":{"378":1}}],["|体健|战斗中六力回复率",{"1":{"378":1}}],["|养生|战斗中将康回复率",{"1":{"378":1}}],["|寻路|队伍移动+100|惩戒|当重击对手时下一招伤害",{"1":{"378":1}}],["|慧根|练武经验增加",{"1":{"378":1}}],["|狂奔|轻功受地形影响减少|延命|生命低于5",{"1":{"378":1}}],["|战斗类特性|",{"1":{"378":1}}],["|聚财|有他在该分舵所有物品买价",{"1":{"378":1}}],["|神笔|悟招跟写秘籍速度",{"1":{"378":1}}],["|活力|每天早上所有精力回复|",{"1":{"378":1}}],["|识药|计算药草时腰力属性",{"1":{"378":1}}],["|铁人|在厢房精力回覆加倍|",{"1":{"378":1}}],["|铁臂|挖金矿铁矿时计算臂力属性",{"1":{"378":1}}],["|探勘|金矿",{"1":{"378":1}}],["|辩矿|金矿",{"1":{"378":1}}],["|炼金|丹药产量",{"1":{"378":1}}],["|工艺|铸造时内力计算",{"1":{"378":1}}],["|耐力|精力减少除以2|",{"1":{"378":1}}],["|剥皮|皮革产能",{"1":{"378":1}}],["|肥田|农田跟药铺等级+1",{"1":{"378":1}}],["|深耕|产粮食腿力计算",{"1":{"378":1}}],["|生产类特性|",{"1":{"378":1}}],["|",{"1":{"378":15,"525":2,"903":2,"998":3}}],["|uic=",{"1":{"153":2}}],["腰",{"1":{"378":2}}],["臂",{"1":{"378":2}}],["臂力和腰力高的就表示拳法学习力高",{"1":{"374":1}}],["青⼯",{"1":{"378":2}}],["智慧每10力量=5生命每5力量=1",{"1":{"384":1}}],["智慧和四⼒",{"1":{"378":1}}],["智慧和四⼤武功属性",{"1":{"378":1}}],["智力",{"1":{"246":1,"394":1}}],["职位的变更会影响到弟子的忠诚",{"1":{"381":1}}],["职位",{"0":{"378":1},"2":{"379":1,"380":1,"381":1,"382":1,"383":1}}],["职业",{"0":{"368":1}}],["劫标那些都不用看",{"1":{"377":1}}],["救济",{"1":{"377":1}}],["救火有可能库存被清空22",{"1":{"295":1}}],["什麼要基础武功都会了才出战",{"1":{"377":1}}],["什么因素影响绘制顺序",{"1":{"1035":2}}],["什么事儿",{"1":{"965":1}}],["什么时候声明",{"1":{"964":1}}],["什么被调用了",{"1":{"885":1}}],["什么在堆和栈里",{"0":{"880":1},"2":{"881":1,"882":1,"883":1,"884":1,"885":1,"886":1,"887":1,"888":1,"889":1,"890":1,"891":1,"892":1,"893":1,"894":1,"895":1,"896":1,"897":1,"898":1}}],["什么收获也没有",{"1":{"296":1}}],["什么是drawcall",{"1":{"876":1}}],["什么是视差背景",{"0":{"724":1}}],["什么是il2cpp",{"0":{"588":1}}],["什么是",{"0":{"206":1}}],["什么是非托管代码",{"1":{"127":1}}],["什么场景下该用哪个接口呢",{"1":{"171":1}}],["什么",{"1":{"34":1}}],["胖子跟瘦子好像是看损血比率",{"1":{"377":1}}],["了的",{"1":{"953":1}}],["了解gc原理可以帮助我们理解gc清理",{"1":{"898":1}}],["了解自动内存管理",{"1":{"864":1}}],["了解自己的目标总是很重要的",{"1":{"218":1}}],["了解托管堆",{"1":{"864":1}}],["了解了其中原理之后就算是事件穿透之类的也完全可以通过源码实现来倒推解决方案",{"1":{"682":1}}],["了icustommessagetarget接口的mono的message1函数",{"1":{"657":1}}],["了配置启动脚本文件",{"1":{"467":1}}],["了",{"1":{"377":1,"500":1,"510":1,"581":1,"690":1,"841":2,"862":1,"924":1,"942":1,"955":1,"956":1,"965":2,"966":1,"969":2,"971":1}}],["备份与恢复",{"0":{"497":1},"2":{"498":1,"499":1}}],["备份",{"1":{"438":1}}],["备",{"1":{"377":1}}],["掌门就让他变态攻击型吧",{"1":{"377":1}}],["掌门的左右护法要一个专练呐喊和防守自补血方针开",{"1":{"377":1}}],["掌柜",{"1":{"368":1}}],["轻功",{"1":{"381":1}}],["轻功都要练完才出战",{"1":{"377":1}}],["轻功要另",{"1":{"372":1}}],["织造房也有7个等级的设定",{"1":{"380":1}}],["织造房",{"1":{"376":1,"380":1}}],["织锦",{"1":{"297":1}}],["冶锻场",{"1":{"376":1}}],["农田至少2",{"1":{"376":1}}],["农夫",{"1":{"368":1}}],["腿",{"1":{"378":2}}],["腿力过低的就增加他的行程点数比例以减少他的行走时间或是只让他在主殿附近工作",{"1":{"375":1}}],["腿法最重",{"1":{"374":1}}],["空位",{"1":{"861":1}}],["空数组重用",{"0":{"825":1}}],["空白色条表示行走",{"1":{"375":1}}],["空间",{"1":{"120":1}}],["空间浪费",{"1":{"118":1}}],["田3工作补强六力",{"1":{"375":1}}],["工程是用unity",{"1":{"737":1}}],["工作",{"1":{"1054":1}}],["工作流并不受影响",{"1":{"960":1}}],["工作时",{"1":{"947":1}}],["工作时辰编排",{"0":{"375":1}}],["工作的方式非常地",{"1":{"942":1}}],["工作量大",{"1":{"811":1}}],["工作原理",{"0":{"574":1}}],["工作线程数",{"1":{"467":1}}],["工坊产值+30",{"1":{"389":1}}],["工具检测",{"0":{"875":1},"2":{"876":1,"877":1,"878":1}}],["工具查看其矩形大小",{"1":{"862":1}}],["工具",{"1":{"287":1,"423":1}}],["扎稳了自然该项所需六力就会相对提高",{"1":{"374":1}}],["越往后添加的",{"1":{"1039":1}}],["越高",{"1":{"1039":2,"1040":2,"1041":1}}],["越高他的学习力就会越高",{"1":{"374":1}}],["越先渲染",{"1":{"1037":1}}],["越先被射线检测选中",{"1":{"695":1}}],["越晚畫的物件永遠都在其他較早畫的物件之上",{"1":{"975":1}}],["越深色表示離攝影機越近場景來源",{"1":{"974":1}}],["越来越大",{"1":{"877":1}}],["越小越优先",{"1":{"976":3}}],["越小越靠前",{"1":{"695":1}}],["越小会越先渲染",{"1":{"695":1}}],["越大的对象越排前面",{"1":{"695":1}}],["越大",{"1":{"695":1,"1036":1,"1039":3,"1040":1}}],["越大越往后渲染",{"1":{"695":1}}],["越少根表示所花时间越少",{"1":{"374":1}}],["示他练武有成",{"1":{"373":1}}],["示例图将坐标轴",{"1":{"763":1}}],["示例中所述",{"1":{"604":1}}],["示例",{"0":{"172":1,"996":1}}],["示例代码调用",{"1":{"111":1}}],["示例代码调用一百万次耗时",{"1":{"111":1}}],["示例代码在这里",{"1":{"111":1}}],["足够大",{"1":{"814":1}}],["足",{"1":{"373":1}}],["算是较细部的观察",{"1":{"373":1}}],["算法简述",{"0":{"783":1}}],["算法的第一部分是生成关卡的",{"1":{"224":1}}],["算法可视化",{"1":{"214":1}}],["算法非常简单",{"1":{"197":1}}],["算法",{"0":{"119":1,"220":1},"1":{"214":1,"753":1,"857":1}}],["算法流程如下",{"1":{"47":1}}],["算法流程可以参考下图",{"1":{"12":1}}],["算法应用于网状网络",{"1":{"12":1}}],["弟⼦的忠诚度",{"1":{"378":1}}],["弟",{"1":{"373":1}}],["弟子会选择叛逃",{"1":{"391":1}}],["弟子培养差事",{"0":{"388":1}}],["弟子最快乐的绿脸时期大多是在刚拿到秘笈至领悟出来这短短的期间",{"1":{"373":1}}],["弟子不爽的缓冲时间就比较充",{"1":{"373":1}}],["弟子心情",{"0":{"373":1}}],["弟子能在武场练",{"1":{"372":1}}],["心情",{"1":{"390":1}}],["心情不是看脸色的",{"1":{"373":1}}],["心情在於练武成",{"1":{"372":1}}],["心态+名气",{"1":{"295":1}}],["支付",{"1":{"610":1}}],["支薪10元练武所需成效最低底限50",{"1":{"372":1}}],["支薪10块钱一开始即使你没排练武行程给他他都不会不高兴",{"1":{"372":1}}],["支持的所有平台上支持此配置文件",{"1":{"721":1}}],["支持的非常爽",{"1":{"580":1}}],["支持噪声重复",{"1":{"198":1}}],["支持高可用",{"1":{"30":1}}],["支持按指定",{"1":{"30":1}}],["支持任务取消",{"1":{"30":1}}],["支持秒级单位的定时任务处理",{"1":{"30":1}}],["六力提升比较正常",{"1":{"372":1}}],["六力很快就能超过原本的人物",{"1":{"372":1}}],["想讓",{"1":{"978":1}}],["想像為存在在世界場景的平面",{"1":{"977":1}}],["想像該",{"1":{"977":1}}],["想像一下我们跟两个好朋友生活在一起",{"1":{"898":1}}],["想像一下如果我们传递mystruct几千次",{"1":{"891":1}}],["想想看",{"1":{"839":1}}],["想用canvas中的ui去遮挡3d物品是做不到的",{"1":{"622":1}}],["想象一下",{"1":{"502":1}}],["想换别的秘笈了",{"1":{"373":1}}],["想当然必须比较快换下一招练",{"1":{"372":1}}],["想要深入了解可以看这篇文章",{"1":{"930":1}}],["想要生成代码只需要保持运行",{"1":{"746":1}}],["想要获得最佳的游戏体验的话必须正确的设置此参数",{"1":{"82":1}}],["想要往右移动两格",{"1":{"68":1}}],["想要接收高字节",{"1":{"36":1}}],["想要取高字节",{"1":{"36":1}}],["後面新加入的弟子资质几乎都比原本的人",{"1":{"372":1}}],["後面会解说",{"1":{"372":1}}],["爽",{"1":{"372":1}}],["薪资",{"0":{"372":1}}],["话",{"1":{"371":1}}],["诊断失败扣除经验",{"1":{"369":1}}],["医院",{"1":{"369":1}}],["医术",{"1":{"297":2,"368":1}}],["营业或者行医",{"1":{"369":1}}],["营寨2",{"1":{"297":1}}],["营寨3",{"1":{"297":2}}],["营寨1",{"1":{"297":1}}],["许可证有个按钮",{"1":{"369":1}}],["许多unity项目都发现每帧有几十或几百kb的临时数据分配到托管堆处理",{"1":{"815":1}}],["许多曾在杀戮中失却心智的疯子与狂人受到炼心师的操弄",{"1":{"297":1}}],["许多同时身负正邪两道数笔血债的亡命之徒盘踞于此地",{"1":{"297":1}}],["许多介绍柏林噪声算法的文章都是根据最初版柏林噪声算法来讲解的",{"1":{"197":1}}],["悬空",{"1":{"800":1}}],["悬挂在屋内",{"1":{"369":1}}],["悬壶",{"1":{"368":1,"393":1}}],["购买许可证",{"1":{"369":1}}],["购买物品的时候",{"1":{"368":1}}],["购买一双新鞋穿着很舒服",{"1":{"296":1}}],["食肆",{"1":{"368":1}}],["食物可以补充体力",{"1":{"301":1}}],["烹饪",{"1":{"368":1}}],["机制",{"1":{"964":1}}],["机制公式",{"1":{"385":1}}],["机能相关的特效和动作就开始播放",{"1":{"796":1}}],["机缘",{"1":{"391":1}}],["机会烧掉对手的6力|",{"1":{"378":1}}],["机会瞬间减少对手25",{"1":{"378":1}}],["机巧减少制作时间",{"1":{"368":1}}],["机关",{"1":{"287":1}}],["渔夫",{"1":{"368":1}}],["渔获每提升一点则减少消耗体力0",{"1":{"368":1}}],["屠夫boss的勾子技能可以将玩家拉过来",{"1":{"795":1}}],["屠夫",{"1":{"368":1}}],["庖丁",{"1":{"368":1}}],["樵夫",{"1":{"368":1}}],["斫木",{"1":{"393":1}}],["斫",{"1":{"368":1}}],["砍树增加经验",{"1":{"368":1}}],["砍伐木材",{"1":{"393":1}}],["砍伐",{"1":{"368":1}}],["扶农",{"1":{"368":1,"393":1}}],["猜测既然那里你没有相应的",{"1":{"952":1}}],["猜谜",{"0":{"366":1}}],["猜灯谜",{"0":{"331":1}}],["武道",{"1":{"392":1}}],["武功是靠悟出来的",{"1":{"380":1}}],["武学",{"0":{"361":1}}],["武器模型",{"1":{"1010":1}}],["武器没有等级概念",{"1":{"250":1}}],["武器决定了有哪些技能",{"1":{"250":1}}],["武器可有技能",{"1":{"250":1}}],["武器技能",{"0":{"250":1}}],["武器进行了射击",{"1":{"45":1}}],["武器开火逻辑代码也跟运动代码一样也作为",{"1":{"44":1}}],["隐藏",{"1":{"979":1,"980":1}}],["隐藏其他被遮蔽的ui",{"1":{"860":1}}],["隐藏地图",{"0":{"360":1}}],["隐私声明",{"0":{"607":1}}],["隐约传来不祥的气息",{"1":{"296":1}}],["奖励",{"0":{"358":1}}],["故整理在",{"1":{"975":1}}],["故而多边形在该轴上的投影是一样的",{"1":{"762":1}}],["故而异常的凶恶",{"1":{"297":1}}],["故事剧情",{"0":{"357":1},"2":{"358":1}}],["资源目录",{"1":{"901":1}}],["资源检查",{"0":{"856":1},"2":{"857":1,"858":1,"859":1,"860":1,"861":1,"862":1,"863":1,"864":1,"865":1,"866":1,"867":1,"868":1,"869":1,"870":1,"871":1,"872":1,"873":1,"874":1}}],["资源包冗余检测",{"1":{"874":1}}],["资源包",{"1":{"705":1}}],["资源的",{"1":{"705":1}}],["资源的定义",{"1":{"131":1}}],["资源",{"0":{"865":1},"1":{"701":1},"2":{"866":1,"867":1,"868":1,"869":1,"870":1,"871":1,"872":1,"873":1}}],["资源加载",{"0":{"697":1}}],["资源丰富的地点",{"1":{"380":1}}],["资源有限",{"0":{"352":1}}],["探索",{"0":{"350":1},"2":{"351":1,"352":1,"353":1,"354":1,"355":1,"356":1,"357":1,"358":1,"359":1,"360":1}}],["养殖",{"0":{"348":1},"1":{"368":1}}],["养殖店",{"1":{"287":1}}],["跑商",{"0":{"346":1}}],["护卫",{"0":{"345":1}}],["妖族入侵",{"0":{"342":1}}],["妖怪退治持续了整整一周",{"1":{"296":1}}],["四个组件缺一不可",{"1":{"1053":1}}],["四",{"1":{"876":1}}],["四叉树",{"1":{"767":1}}],["四种方式的优劣",{"0":{"730":1},"2":{"731":1,"732":1,"733":1,"734":1}}],["四大圣兽入侵",{"0":{"341":1}}],["四级装备就能过九级地牢",{"1":{"293":1}}],["僵尸王",{"0":{"339":1}}],["蛇人入侵",{"0":{"338":1}}],["蛇窝",{"1":{"224":1}}],["节约了少量的计算资源",{"1":{"979":1}}],["节日",{"0":{"327":1},"2":{"328":1,"329":1,"330":1,"331":1}}],["节点拥有较轻度的condition功能",{"1":{"795":1}}],["节点开始",{"1":{"691":1}}],["节点开始不断向上",{"1":{"691":1}}],["节点",{"1":{"12":1}}],["爬塔",{"0":{"326":1}}],["蛙岛",{"0":{"323":1}}],["经常要处理",{"1":{"841":1}}],["经常会使用内置的",{"1":{"841":1}}],["经常会被",{"1":{"840":1}}],["经常用来做网络连通性测试的",{"1":{"529":1}}],["经典的",{"1":{"737":1}}],["经代理服务器做出处理后再转给目标服务器",{"1":{"581":1}}],["经验值从0到最高上限都是普通心情",{"1":{"372":1}}],["经营",{"1":{"369":1}}],["经商",{"1":{"368":1}}],["经济",{"0":{"319":1}}],["经过以上排序",{"1":{"862":1}}],["经过分析与测试",{"1":{"836":1}}],["经过测试目前sd2",{"1":{"568":1}}],["经过一段时间的尝试",{"1":{"210":1}}],["经过前面的几步计算",{"1":{"203":1}}],["经过排查",{"1":{"135":1}}],["经过哈希计算后",{"1":{"92":1}}],["经过",{"1":{"69":1,"273":1}}],["玩熟了之後再去研究调整薪资",{"1":{"372":1}}],["玩法系统现在就可以通过修改",{"1":{"944":1}}],["玩法",{"0":{"310":1},"2":{"311":1,"312":1,"313":1,"314":1,"315":1,"316":1,"317":1,"318":1,"319":1,"320":1,"321":1,"322":1,"323":1,"324":1,"325":1,"326":1,"327":1,"328":1,"329":1,"330":1,"331":1,"332":1,"333":1,"334":1,"335":1,"336":1,"337":1,"338":1,"339":1,"340":1,"341":1,"342":1,"343":1,"344":1,"345":1,"346":1,"347":1,"348":1,"349":1,"350":1,"351":1,"352":1,"353":1,"354":1,"355":1,"356":1,"357":1,"358":1,"359":1,"360":1,"361":1,"362":1,"363":1,"364":1,"365":1,"366":1,"367":1}}],["玩家应该开始能感受到乐趣了",{"1":{"940":1}}],["玩家控制的客户端",{"1":{"805":1}}],["玩家b刚开始执行技能动作",{"1":{"804":1}}],["玩家单位技能发起是由她的客户端",{"1":{"802":1}}],["玩家点击按钮释放一个技能",{"1":{"802":1}}],["玩家本地的客户端就是主控端",{"1":{"801":1}}],["玩家松开按钮",{"1":{"795":1}}],["玩家出生地的产物",{"1":{"301":1}}],["玩家出生点的选择",{"1":{"214":1}}],["玩家得跳到上面去",{"1":{"225":1}}],["玩家之间有更大的平均极小距离",{"1":{"215":1}}],["玩家初始的出生点占位的分布也会影响游戏的平衡性",{"1":{"213":1}}],["玩家占位符",{"1":{"213":1}}],["玩家必须派遣探险者进入这片迷雾中",{"1":{"212":1}}],["玩家必须对游戏中的其他玩家进行外推以便正确击中",{"1":{"46":1}}],["玩家和怪物",{"1":{"103":1}}],["玩家离开地图",{"1":{"103":1}}],["玩家多",{"1":{"97":1}}],["玩家位置和像素命中处理检测都可以精准的进行",{"1":{"85":1}}],["玩家位置和动画可以在两个最近收到快照之间的连续插值",{"1":{"83":1}}],["玩家将会恢复到原来的位置",{"1":{"85":1}}],["玩家输入和相应的视觉反馈之间的延迟会产生一种奇怪的",{"1":{"84":1}}],["玩家看到",{"1":{"78":2}}],["玩家看到的敌人的位置永远是过去的",{"1":{"59":1}}],["玩家看到的别的物体是经过插值计算出来的",{"1":{"47":1}}],["玩家经常快速跑动",{"1":{"76":1}}],["玩家发出操作指令会非常频繁",{"1":{"73":1}}],["玩家",{"0":{"59":1}}],["玩家在服务器的位置是在ct3需要boss把攻击作为关键事件",{"1":{"58":1}}],["玩家ct2的时候开始移动",{"1":{"58":1}}],["玩家就可以直接瞄准目标进行设计",{"1":{"47":1}}],["玩家是否处于躲避状态",{"1":{"47":1}}],["玩家更难击中",{"1":{"46":1}}],["玩家还可以移动到合理的目标位置",{"1":{"46":1}}],["玩家可以通过控制ui控制技能的释放方向",{"1":{"797":1}}],["玩家可以从上面跳下去",{"1":{"287":1}}],["玩家可以随时转弯",{"1":{"46":1}}],["玩家可以算出快速发射武器的时候需要多大的提前量",{"1":{"45":1}}],["玩家奔跑速度是500单位每秒",{"1":{"45":1}}],["玩家会感觉游戏中的移动和武器状态100",{"1":{"44":1}}],["玩家的总数量",{"1":{"214":1}}],["玩家的角色将在游戏世界中向前行走",{"1":{"84":1}}],["玩家的调制解调器连接不能获得超过5",{"1":{"82":1}}],["玩家的初始状态和预测结果用来渲染场景",{"1":{"43":1}}],["玩家的状态同步之后",{"1":{"16":1}}],["玩家a的网速慢",{"1":{"12":1}}],["晶石",{"0":{"309":1},"1":{"309":1}}],["铂金矿",{"1":{"307":1}}],["金芒果软件网",{"1":{"385":1}}],["金矿",{"1":{"307":1}}],["金色怪物等级为场景等级加3",{"1":{"265":1}}],["钨矿",{"1":{"307":1}}],["银矿",{"1":{"307":1}}],["铅矿",{"1":{"307":1}}],["锡矿",{"1":{"307":1}}],["铜矿",{"1":{"307":1}}],["石头",{"1":{"307":1}}],["贝母",{"1":{"304":1}}],["人参",{"1":{"304":1}}],["人物经验+5",{"1":{"388":1}}],["人物在一级时",{"1":{"385":1}}],["人物",{"0":{"355":1}}],["人物会在该场景移动",{"1":{"287":1}}],["人物的等级与掉落的物品有关么",{"1":{"274":1}}],["冬虫夏草",{"1":{"304":1}}],["冬天",{"1":{"290":1}}],["雪莲花",{"1":{"304":1}}],["藏红花",{"1":{"304":1}}],["藏经阁",{"1":{"254":1}}],["环境变量",{"1":{"509":1,"574":1}}],["环境",{"1":{"303":1,"304":1,"305":1,"306":1,"307":1,"308":1,"309":1,"510":1}}],["环境的外部",{"1":{"127":1}}],["望天树",{"1":{"302":1}}],["桦木",{"1":{"302":1}}],["楠木",{"1":{"302":1}}],["楠树",{"1":{"302":1}}],["榉木",{"1":{"302":1}}],["榉树",{"1":{"302":1}}],["黄金规则2",{"1":{"886":1}}],["黄杨木",{"1":{"302":1}}],["黄色",{"1":{"275":3}}],["黄色最多选择6个",{"1":{"270":1}}],["杨树",{"1":{"302":1}}],["乌木",{"1":{"302":1}}],["柏树",{"1":{"302":1}}],["柏林噪声的生成采用伪随机数的生成方式",{"1":{"214":1}}],["柏林噪声程序化生成随机地图",{"1":{"214":1}}],["柏林噪声有较好的连续性分布",{"1":{"214":1}}],["柏林噪声可以用于生成波形",{"1":{"214":1}}],["柏林噪声柏林噪声",{"1":{"214":1}}],["柏林噪声哈希函数用于给每组输入计算返回一个唯一",{"1":{"201":1}}],["柏林噪声每隔256个整数就会再次重复",{"1":{"199":1}}],["铁匠",{"1":{"368":1}}],["铁匠铺",{"1":{"287":1}}],["铁矿",{"1":{"307":1,"378":2}}],["铁力木",{"1":{"302":1}}],["冷杉",{"1":{"302":1}}],["冷却时间特效最终会被添加到人物的身上",{"1":{"237":1}}],["松木",{"1":{"302":1}}],["松树",{"1":{"302":1}}],["松果",{"1":{"299":1}}],["砂树",{"1":{"302":1}}],["价格越高树木",{"1":{"302":1}}],["价格非常昂贵",{"1":{"300":1}}],["稀有度越高",{"1":{"302":1}}],["衡量产出时间",{"1":{"301":1}}],["产生的",{"1":{"957":1}}],["产生有时候很有用",{"1":{"952":1}}],["产生下面的中间语言",{"1":{"823":1}}],["产生",{"1":{"694":1}}],["产生心魔",{"1":{"391":1}}],["产品已发布",{"1":{"615":1}}],["产品价值也就越高",{"1":{"380":1}}],["产品的价值也越高",{"1":{"380":1}}],["产量越少",{"1":{"301":1}}],["产出种类",{"0":{"300":1}}],["城市产出说明",{"0":{"301":1}}],["城市场景",{"1":{"287":1}}],["翡翠原石鉴定而得",{"1":{"300":1}}],["翡翠",{"1":{"300":1}}],["偶尔会出现宝石洞",{"1":{"300":1}}],["偶然捡到一只小猫",{"1":{"296":1}}],["宝箱",{"0":{"353":1,"356":1}}],["宝石可以用来制作物品",{"1":{"300":1}}],["宝石",{"0":{"308":1},"1":{"300":1,"308":1}}],["宝藏",{"1":{"295":1}}],["矿工",{"1":{"368":1}}],["矿石",{"0":{"307":1},"1":{"300":1,"307":1}}],["矿锄",{"1":{"287":1}}],["鱼类",{"0":{"306":1},"1":{"300":1,"306":1}}],["鱼竿",{"1":{"287":1}}],["皮毛用来制造衣服",{"1":{"300":1}}],["药圃",{"1":{"380":1}}],["药",{"1":{"376":1}}],["药园都要有",{"1":{"376":1}}],["药师",{"1":{"368":1}}],["药材的素材只有一种",{"1":{"304":1}}],["药材",{"0":{"304":1},"1":{"300":1}}],["药店室内",{"1":{"287":1}}],["肉苁蓉",{"1":{"304":1}}],["肉用来制作食物",{"1":{"300":1}}],["肉",{"1":{"299":1}}],["蜂蜜",{"1":{"299":1}}],["甜菜",{"1":{"299":1}}],["浆果",{"1":{"299":1}}],["野外食物产出",{"0":{"299":1}}],["弃世绝境",{"1":{"297":1}}],["弃置着众多枉死者尸身的不祥之地",{"1":{"297":1}}],["庙宇3",{"1":{"297":1}}],["庙宇2",{"1":{"297":1}}],["群魔乱舞",{"1":{"297":1}}],["仍旧要放在循环条件的外面",{"1":{"824":1}}],["仍然关联到",{"1":{"969":1}}],["仍然存在",{"1":{"935":1}}],["仍然没有可以满足需求的连续内存空间",{"1":{"813":1}}],["仍然会穿透ui",{"1":{"657":1}}],["仍然有插值的安全量",{"1":{"86":1}}],["仍不断游荡在此地附近",{"1":{"297":1}}],["荒野2",{"1":{"297":1}}],["闻者无不色变",{"1":{"297":1}}],["林野3",{"1":{"297":1}}],["潭泽2",{"1":{"297":1}}],["行内元素也可以使用",{"1":{"405":1}}],["行程安排",{"0":{"382":1}}],["行事只凭一时之兴",{"1":{"297":1}}],["行为树的运行",{"0":{"277":1},"2":{"278":1,"279":1,"280":1,"281":1,"282":1,"283":1,"284":1}}],["行为树的构建",{"0":{"276":1}}],["善恶不分",{"1":{"297":1}}],["茅庐3",{"1":{"297":1}}],["湖泊2",{"1":{"297":1}}],["品鉴",{"1":{"297":1}}],["品质等级决定具体是哪件装备",{"1":{"271":1}}],["品质等级是玩家无法左右的",{"1":{"271":1}}],["品质等级",{"0":{"271":1},"1":{"271":1,"272":1}}],["诗书",{"1":{"297":1}}],["弈棋",{"1":{"297":1}}],["异步网关协议接口",{"1":{"583":1}}],["异士居",{"1":{"297":1}}],["异常处理和线程同步等等",{"1":{"131":1}}],["异常处理和其他操作的说明",{"1":{"127":1}}],["古迹3",{"1":{"297":2}}],["古墓3",{"1":{"297":2}}],["古怪的石料看人品±修为",{"1":{"295":1}}],["乱葬岗",{"1":{"297":1}}],["阵阵异香不断地飘送出来",{"1":{"297":1}}],["花费时间",{"1":{"388":1,"389":1}}],["花费了一个时辰陪猫玩耍",{"1":{"296":1}}],["花海3",{"1":{"297":1}}],["迷香阵笼罩在一片红雾之内",{"1":{"297":1}}],["迷香阵",{"1":{"297":1}}],["朝不保夕的日子",{"1":{"297":1}}],["朝生夕亡",{"1":{"120":1}}],["峡谷3",{"1":{"297":1}}],["术数",{"1":{"297":2}}],["乡村2",{"1":{"297":1}}],["乡村1",{"1":{"297":1}}],["制定",{"1":{"975":1}}],["制造分舵或是采集分舵",{"1":{"382":1}}],["制药和行医的时候增加经验",{"1":{"368":1}}],["制作小地图",{"0":{"1034":1}}],["制作工艺品",{"1":{"393":1}}],["制作订单牌",{"1":{"368":1}}],["制作时消耗的燃料",{"1":{"368":1}}],["制作家具和武器增加经验",{"1":{"368":1}}],["制作家具和装备",{"1":{"300":1}}],["制作",{"1":{"368":1}}],["制作药品",{"1":{"300":1}}],["制作食物",{"1":{"300":1}}],["制作料理",{"1":{"254":1}}],["制木",{"1":{"297":1}}],["叛徒结伙",{"1":{"297":1}}],["拉取源码",{"1":{"510":1}}],["拉取该地图所有npc的任务",{"1":{"252":1}}],["拉帮结派",{"1":{"297":1}}],["沙漠2",{"1":{"297":2}}],["沙漠场景",{"1":{"287":1}}],["锻造装备",{"1":{"393":1}}],["锻造",{"1":{"297":1}}],["锻造师",{"1":{"295":1}}],["悍匪砦",{"1":{"297":1}}],["专门窃夺无辜百姓的财物",{"1":{"297":1}}],["洞穴3",{"1":{"297":1}}],["洞穴2",{"1":{"297":3}}],["洞窟",{"1":{"287":1}}],["巧匠",{"1":{"297":1,"393":1}}],["贼人营寨",{"1":{"297":1}}],["杂学",{"1":{"297":6}}],["杂货店花费10000g购买",{"1":{"290":1}}],["杂货店内",{"1":{"287":1}}],["恶丐窝",{"1":{"297":1}}],["恶人谷",{"1":{"297":1}}],["恶人",{"1":{"295":1}}],["^",{"1":{"297":2,"983":2,"984":8}}],["转成",{"1":{"937":1}}],["转而执行",{"1":{"657":1}}],["转而使用一种长生存期的方法",{"1":{"575":1}}],["转换系统中会生成实体",{"1":{"1054":1}}],["转换过程都是在conversion",{"1":{"1054":1}}],["转换过程是创建特定目的的",{"1":{"947":1}}],["转换后就和",{"1":{"971":1}}],["转换后的坐标若超出",{"1":{"688":1}}],["转换流程",{"1":{"969":1}}],["转换时将会创建额外的两个",{"1":{"961":1}}],["转换到",{"1":{"956":1}}],["转换的结果",{"1":{"951":1}}],["转换上面的例子到touch",{"1":{"824":1}}],["转换一个匿名函数为闭包显著增加了需要传递闭包到函数接收的内存量",{"1":{"818":1}}],["转换",{"1":{"604":1,"946":1}}],["转换为隐藏的",{"1":{"966":1}}],["转换为",{"1":{"948":1}}],["转换为视窗坐标",{"1":{"688":1}}],["转换为持续",{"1":{"284":1}}],["转换为本机代码",{"1":{"129":3,"130":2}}],["转换为特定于",{"1":{"127":1}}],["转发的请求并处理后发给",{"1":{"581":1}}],["转发响应的程序",{"1":{"577":2}}],["转盘检定",{"1":{"297":1}}],["笑着鼓励她要继续加油",{"1":{"296":1}}],["鱗片的妖力引来了奇怪的妖怪在附近徘徊",{"1":{"296":1}}],["妥善保管",{"1":{"296":1}}],["崩坏了门牙",{"1":{"296":1}}],["退出播放模式后",{"1":{"737":1}}],["退出",{"1":{"494":1}}],["退治妖物后收集到了一些金色的鱗片",{"1":{"296":1}}],["退到客户端发送命令时候的准确时间",{"1":{"47":1}}],["纸鹤飞到了小纸人看不见的高度",{"1":{"296":1}}],["派出小纸人跟踪它们",{"1":{"296":1}}],["派小纸人去风神神社回一份小礼",{"1":{"296":1}}],["吹坏了庭院的大门",{"1":{"296":1}}],["揭下风符并妥善保管",{"1":{"296":1}}],["幸运的是",{"1":{"398":1,"411":1,"826":1}}],["幸亏风符保护才安然无事",{"1":{"296":1}}],["幸存区",{"1":{"120":1}}],["庭院门前被人提前贴了风符",{"1":{"296":1}}],["竹林里传来悠杨的笛声",{"1":{"296":1}}],["竹林场景",{"1":{"287":1}}],["曼曼珠沙华价格暴涨",{"1":{"296":1}}],["曼珠沙华水土不服",{"1":{"296":1}}],["伤心了一个早晨",{"1":{"296":1}}],["伤害结算等",{"1":{"802":1}}],["伤害怎么计算",{"1":{"385":1}}],["伤害公式",{"0":{"385":1}}],["伤害特效",{"1":{"247":2}}],["伤害类型",{"1":{"246":1,"394":1}}],["伤害",{"0":{"809":1},"1":{"246":1}}],["京都居民结伴赏花",{"1":{"296":1}}],["京都郊外突然盛开了大片的红色曼珠沙华",{"1":{"296":1}}],["京都热闹非凡",{"1":{"296":1}}],["皇室送来了一些珠宝作为谢礼",{"1":{"296":1}}],["走代理来访问网络",{"1":{"471":1}}],["走近用火暖暖手",{"1":{"296":1}}],["走到sequence后",{"1":{"278":1}}],["宫廷周围闪烁着忽明忽暗的蓝绿色灯火",{"1":{"296":1}}],["戴上后身体变得轻盈了",{"1":{"296":1}}],["戴上后变得十分可爱",{"1":{"296":1}}],["买个天狗面具戴",{"1":{"296":1}}],["买个般若面具戴",{"1":{"296":1}}],["居然真的收到了礼物",{"1":{"296":1}}],["居民",{"1":{"220":1}}],["问题就产生了",{"1":{"896":1}}],["问题在于",{"1":{"848":1}}],["问题较少",{"1":{"815":1}}],["问题",{"0":{"403":1,"607":1,"608":1,"609":1,"610":1,"611":1,"612":1,"613":1},"1":{"624":1,"737":1},"2":{"614":1,"615":1,"616":1,"617":1}}],["问题更大～",{"1":{"79":1}}],["问猫掌柜丟了什么",{"1":{"296":1}}],["猫掌柜似乎正在找着什么",{"1":{"296":1}}],["突然感觉作者好不靠谱啊",{"1":{"787":1}}],["突然刮起了狂风",{"1":{"296":1}}],["突然罕见地遇到了镰鼬三兄弟之一",{"1":{"296":1}}],["突起在地面上玩家可以搬箱子放置触发",{"1":{"287":1}}],["店铺老板正在向过往行人兜售锦鲤",{"1":{"296":1}}],["迫狗玩耍",{"1":{"296":1}}],["劝他回去安心作画吧",{"1":{"296":1}}],["邀他一同游玩京都吧",{"1":{"296":1}}],["邀请好友→假装不敌",{"1":{"295":1}}],["弥助不知道画了一张什么玩意",{"1":{"296":1}}],["弥助闷闷不乐",{"1":{"296":1}}],["弥助灵感迸发",{"1":{"296":1}}],["弥助的身影也出现在銜上",{"1":{"296":1}}],["弥补了因为网络质量不好带来的负面影响",{"1":{"40":1}}],["剧本新颖",{"1":{"296":1}}],["剧情精彩老套无聊不小心睡着了",{"1":{"296":1}}],["听俏人鱼力斩冰海收珍宝",{"1":{"296":1}}],["听奇鬼王怒杀恶兽扩疆域",{"1":{"296":1}}],["恢复了一些体力",{"1":{"296":1}}],["椐说根椐真事改编",{"1":{"296":1}}],["木材资源等级+1|",{"1":{"378":1}}],["木材产量",{"1":{"378":1}}],["木材采集",{"1":{"254":1}}],["木每提升一点则减少消耗体力0",{"1":{"368":1}}],["木头",{"1":{"302":8}}],["木偶商人有新的剧目了",{"1":{"296":1}}],["弄脏了鞋子",{"1":{"296":1}}],["踏过的地面会留下红色印记的女子",{"1":{"296":1}}],["饮水水过量的男子晕倒了",{"1":{"296":1}}],["蟠桃大会",{"1":{"295":1}}],["仙树叶子发蔫",{"1":{"295":1}}],["仙树叶子枯黄",{"1":{"295":1}}],["仙树吸引妖兽",{"1":{"295":1}}],["仙岛",{"1":{"295":1}}],["袭击魔修者+道德",{"1":{"295":1}}],["魔免",{"1":{"800":1}}],["魔力回复速度",{"1":{"390":1}}],["魔杖",{"1":{"384":1}}],["魔教也说不准转眼就杀进了洞庭帮的总舵",{"1":{"383":1}}],["魔教",{"0":{"336":1}}],["魔修者",{"1":{"295":1}}],["魔法等级",{"1":{"270":1}}],["拍卖",{"1":{"295":1}}],["教训流氓得随机物品32",{"1":{"295":1}}],["教训一番声明大涨",{"1":{"295":1}}],["寻找声明文件js类库一般有三类",{"1":{"397":1}}],["寻找最远需要开始计算的snapshot",{"1":{"14":1}}],["寻宝",{"0":{"349":1}}],["寻求救援",{"1":{"295":1}}],["寻仇",{"1":{"295":1}}],["天赋",{"1":{"384":1}}],["天天最多只会有一名应征者前来应征",{"1":{"380":1}}],["天天看板上都会登出本门本派拉人入伙的公告",{"1":{"380":1}}],["天下霸图",{"0":{"379":1},"2":{"380":1,"381":1,"382":1,"383":1}}],["天下霸图2弟子特性一览表|",{"1":{"378":1}}],["天下霸图2",{"0":{"370":1},"2":{"371":1,"372":1,"373":1,"374":1,"375":1,"376":1,"377":1,"378":1,"379":1,"380":1,"381":1,"382":1,"383":1}}],["天人入侵",{"0":{"340":1}}],["天冬",{"1":{"304":1}}],["天麻",{"1":{"304":1}}],["天梯",{"1":{"295":1}}],["天仙下凡",{"1":{"295":1}}],["联手反击",{"1":{"295":1}}],["灵宝殿",{"1":{"295":1}}],["灵石市场",{"1":{"295":1}}],["灵石矿脉",{"1":{"295":1}}],["道法",{"1":{"297":2,"392":1}}],["道德",{"1":{"295":1}}],["道德+修为",{"1":{"295":1}}],["道德24",{"1":{"295":1}}],["道侣",{"1":{"295":1}}],["据为己有+修为",{"1":{"295":1}}],["判定始终在攻击轨迹中央",{"1":{"750":1}}],["判断是否是localplayer",{"1":{"1013":1}}],["判断一个点是否在三角形里面",{"0":{"777":1},"2":{"778":1}}],["判断目标点是否在某一矩形区域",{"0":{"774":1}}],["判断目标点是否在指定的矩形内",{"0":{"773":1}}],["判断两多边形的投影是否重合",{"1":{"763":1}}],["判断两圆心距离是否小于两半径之和",{"1":{"754":1}}],["判断任意两个",{"1":{"753":1}}],["判断组件",{"1":{"691":1}}],["判断数据在此计算机结构中存储时的字节顺序",{"1":{"38":1}}],["判官雕像",{"1":{"295":1}}],["潜到潭底概率±修为",{"1":{"295":1}}],["碧水寒潭",{"1":{"295":1}}],["府库失火",{"1":{"295":1}}],["拒绝啥都不扣19",{"1":{"295":1}}],["落难母子",{"1":{"295":1}}],["追加命令到缓存的步骤执行完毕",{"1":{"445":1}}],["追债",{"1":{"295":1}}],["追杀人物",{"1":{"254":1}}],["勇闯遗迹→制造临时分身",{"1":{"295":1}}],["场外观战+战力15",{"1":{"295":1}}],["场景中所有引用相同模型的gameobject都必须将模型顶点信息复制",{"1":{"979":1}}],["场景中animator组件的cullingmode是alwaysanimate会增加cpu使用率",{"1":{"866":1}}],["场景中可以存在一个或多个",{"1":{"695":1}}],["场景加载",{"0":{"698":1}}],["场景和ui位置的适配",{"0":{"621":1},"2":{"622":1,"623":1}}],["场景适配",{"0":{"619":1},"2":{"620":1,"621":1,"622":1,"623":1}}],["场景",{"1":{"287":1,"758":1}}],["场景制作说明",{"0":{"287":1}}],["场景的蓝色精英怪物等级为场景等级加2",{"1":{"265":1}}],["场景资源",{"0":{"261":1}}],["场景相关数值计算场景大小",{"1":{"103":1}}],["旁听论道+悟性",{"1":{"295":1}}],["旁边都是空的",{"1":{"225":1}}],["旁边有个障碍物",{"1":{"225":1}}],["论道大会",{"1":{"295":1}}],["治疗腿溃→给他酒+随机属性8",{"1":{"295":1}}],["跛足乞丐",{"1":{"295":1}}],["怀疑好友",{"1":{"295":1}}],["帮我们实现了一堆有用的系统来修改它",{"1":{"944":1,"1000":1}}],["帮被偷东西",{"1":{"295":1}}],["帮助性",{"1":{"817":1}}],["帮助店主",{"1":{"295":1}}],["帮助书生抵债",{"1":{"295":1}}],["帮助获得宠物5",{"1":{"295":1}}],["帮派",{"0":{"318":1},"1":{"260":1},"2":{"319":1,"320":1}}],["仇敌",{"1":{"295":1}}],["表里的jit编译过的指令",{"1":{"885":1}}],["表有一个",{"1":{"878":1}}],["表格如图02",{"1":{"854":1}}],["表的某个字段就是技能的脚本路径",{"1":{"811":1}}],["表的作用实际不是定义流程",{"1":{"810":1}}],["表与脚本混合",{"1":{"811":1}}],["表面挖增加修为",{"1":{"295":1}}],["表示",{"1":{"931":2}}],["表示大技能结束根节点保存一个完整技能的信息",{"1":{"805":1}}],["表示一个技能树的执行节点的进入",{"1":{"805":1}}],["表示一个大技能的进入",{"1":{"805":1}}],["表示被主控端控制",{"1":{"801":1}}],["表示碰到物体",{"1":{"750":1}}],["表示這個程式是基於",{"1":{"567":1}}],["表示当前",{"1":{"509":1}}],["表示当前该点可以填入的瓦片id的集合",{"1":{"210":1}}],["表示有一半的几率味空",{"1":{"225":1}}],["表示放置在空中",{"1":{"225":1}}],["表示放置在地上",{"1":{"225":1}}],["表示那有25",{"1":{"225":1}}],["表示100",{"1":{"225":1}}],["表示空",{"1":{"225":1}}],["表示玩家的朝向",{"1":{"42":1}}],["传入该entityquery",{"1":{"966":1}}],["传入之前一样的引用即可",{"1":{"964":1}}],["传入的三个参数就是射线",{"1":{"684":1}}],["传给第二个job调用",{"1":{"923":1}}],["传递引用类型跟上一节所示例中用引用的方式传递值类型相似",{"1":{"892":1}}],["传递到栈里",{"1":{"891":1}}],["传递多长时间就会让这个进程阻塞多长时间",{"1":{"581":1}}],["传功",{"1":{"295":1}}],["传统的",{"1":{"947":1}}],["传统消息通信",{"1":{"660":1}}],["传统方式进行",{"0":{"660":1}}],["传统程序在编译时",{"1":{"130":1}}],["传统架构应用",{"1":{"88":1}}],["少",{"1":{"971":1}}],["少使用顶点属性",{"1":{"876":1}}],["少部分界面",{"1":{"628":1}}],["少林寺同样可能在一夜之间发动对武当山的偷袭",{"1":{"383":1}}],["少不了规划一番",{"1":{"380":1}}],["少量道德",{"1":{"295":1}}],["少数情况的回滚",{"1":{"15":1}}],["避而不见",{"1":{"295":1}}],["避免使用",{"1":{"864":1}}],["避免装箱",{"1":{"864":1}}],["避免因拖动打乱原有的depth排序",{"1":{"860":1}}],["避免出现已经被总结出来的问题",{"1":{"856":1}}],["避免出现打包失败的问题",{"1":{"534":1}}],["避免这个问题的一个方法是利用数组是引用类型的事实",{"1":{"828":1}}],["避免闭包",{"1":{"819":1}}],["避免不了每一层背景都需要有一个独立的背景照相机",{"1":{"729":1}}],["避免了精灵滚动方式移动过程中",{"1":{"729":1}}],["避免了从头到尾遍历所有对象",{"1":{"105":1}}],["避免访问数组",{"1":{"199":1}}],["概念",{"0":{"933":1},"1":{"753":1,"754":1,"755":1,"756":1,"758":1,"759":1,"760":1,"761":1},"2":{"934":1,"935":1,"936":1}}],["概",{"1":{"374":1}}],["概率获取",{"1":{"290":1}}],["概率出现",{"1":{"290":1}}],["概述写着",{"1":{"815":1}}],["概述",{"0":{"61":1,"66":1,"72":1,"78":1}}],["春季或秋季赛马获胜",{"1":{"290":1}}],["几乎是一致的过程",{"1":{"969":1}}],["几乎不会进行代码的合并工作",{"1":{"594":1}}],["几个步骤列一下",{"1":{"862":1}}],["几个时辰加的六力是最高的",{"1":{"373":1}}],["几个客户端玩家会同时发送数据",{"1":{"73":1}}],["几率出现一次",{"1":{"290":1}}],["装箱操作已经从foreach循环中消除",{"1":{"823":1}}],["装箱在cpu跟踪数据中显示为一些函数的调用",{"1":{"821":1}}],["装箱是unity项目中最普遍的意识不到的临时内存分配的原",{"1":{"820":1}}],["装箱",{"0":{"820":1},"2":{"821":1,"822":1,"823":1,"824":1,"825":1}}],["装备等外部模块对技能参数的修改",{"1":{"792":1}}],["装备材料",{"1":{"387":1}}],["装备生产设施",{"1":{"376":1}}],["装备女神的秘宝",{"1":{"290":1}}],["装饰器将检查它的状态",{"1":{"283":2}}],["装饰器将同时停止",{"1":{"283":1}}],["装饰器将在启动时检查它的状态",{"1":{"283":1}}],["装饰器将在启动时检查一次它的条件状态",{"1":{"283":1}}],["装饰器只会在启动时检查一次它的状态",{"1":{"283":1}}],["泡温泉",{"1":{"290":1}}],["吃东西",{"1":{"290":1}}],["睡的越多回复的越多",{"1":{"290":1}}],["睡觉",{"1":{"290":1}}],["晚上十点到早上六点",{"1":{"301":1}}],["晚上睡觉可以补充体力",{"1":{"301":1}}],["晚上0",{"1":{"290":1}}],["晚多少取决于延时多少",{"1":{"50":1}}],["雨雪天气再室外使用道具",{"1":{"290":1}}],["体系右下角的坐标为",{"1":{"841":1}}],["体积",{"0":{"537":1}}],["体质",{"1":{"395":1}}],["体魄合体期事件1",{"1":{"295":1}}],["体魄26",{"1":{"295":1}}],["体魄",{"1":{"295":1}}],["体魄+战力6",{"1":{"295":1}}],["体力",{"1":{"390":1}}],["体力果实",{"1":{"290":1}}],["体力为0后不能继续工作",{"1":{"290":1}}],["体力会随着使用道具和工具等减少",{"1":{"290":1}}],["体力的回复",{"0":{"290":1}}],["体育",{"1":{"84":1}}],["苟与剑",{"1":{"288":1}}],["衙门",{"1":{"287":1}}],["赌场",{"1":{"287":1}}],["赌博得的装备等级=人物等级+4或",{"1":{"269":1}}],["书籍的目录结构在这里配置",{"1":{"503":1}}],["书籍的介绍写在这个文件里",{"1":{"503":1}}],["书写秘籍",{"1":{"393":1}}],["书院",{"1":{"287":1}}],["书的等级限制能炼到的等级",{"1":{"251":1}}],["镖局",{"1":{"287":1}}],["镖局任务",{"1":{"254":1}}],["商店资源太大",{"0":{"527":1}}],["商店买的装备等级=人物等级+5",{"1":{"269":1}}],["商人",{"1":{"368":1}}],["商行",{"1":{"287":1}}],["礼品店",{"1":{"287":1}}],["客人走进屋子内",{"1":{"369":1}}],["客栈室内",{"1":{"287":1}}],["客户会收到包含基于他早期预测用户命令更改服务器的快照",{"1":{"84":1}}],["客户的时间将继续在此快照的基础上基于客户端的帧率增加",{"1":{"83":1}}],["客户可以要求全额快照同步",{"1":{"82":1}}],["客户可以增加与的cl",{"1":{"82":1}}],["客户通常只能提供有限的带宽",{"1":{"82":1}}],["客户端会添加",{"1":{"1020":1}}],["客户端会将预测位置同服务器的位置对比",{"1":{"84":1}}],["客户端拿到数据",{"1":{"1013":1}}],["客户端使用commandtargetcomponent的targetentity进行command发送",{"1":{"1013":1}}],["客户端使用与服务端tickrate一样的频率采样操作输入创建用户命令",{"1":{"82":1}}],["客户端根据player独有的组件特性",{"1":{"1013":1}}],["客户端根据最新的结果进行更新",{"1":{"69":1}}],["客户端添加networkstreamingame组件",{"1":{"1013":1}}],["客户端连接服务端",{"1":{"1013":1}}],["客户端连接的时候",{"1":{"1012":1}}],["客户端创建localplayer",{"1":{"1012":1}}],["客户端创建命令并发送到服务器",{"1":{"42":1}}],["客户端负责表现",{"1":{"808":1}}],["客户端表现是一个特效在飞",{"1":{"807":1}}],["客户端表现来看",{"1":{"97":1}}],["客户端播放相应的表现",{"1":{"807":1}}],["客户端播放结算特效等",{"1":{"807":1}}],["客户端和服务端对传送的command同时使用predictedghostcomponent进行预测",{"1":{"1013":1}}],["客户端和服务端都维护一个buff管理器",{"1":{"808":1}}],["客户端和服务端的技能树状态统一",{"1":{"805":1}}],["客户端和服务器之间发送的每个包都会带有ack序列号来跟踪网络数据流",{"1":{"82":1}}],["客户端首先响应",{"1":{"802":1}}],["客户端先行",{"1":{"802":1}}],["客户端请求连接就要进行长时间的等待",{"1":{"581":1}}],["客户端所输入的数据也会传给这个外部程序",{"1":{"573":1}}],["客户端所看到的世界是当前的",{"1":{"69":1}}],["客户端时需要配置一致",{"1":{"475":1}}],["客户端",{"0":{"467":1},"1":{"1013":1},"2":{"468":1,"469":1,"470":1}}],["客户端需要执行命令时",{"1":{"444":1}}],["客户端性能所限",{"1":{"97":1}}],["客户端受屏幕大小影响",{"1":{"97":1}}],["客户端看到流血效果",{"1":{"85":1}}],["客户端查看插值然后服务器会将所有其他玩家回溯到命令执行时的位置",{"1":{"85":1}}],["客户端准确运行相同的代码和规则服务器将使用来处理用户命令",{"1":{"84":1}}],["客户端本地预测和服务器的延迟补偿技术可以尽量为网络较差的游戏玩家提供相对公平的体验",{"1":{"82":1}}],["客户端本地即时执行移动操作",{"1":{"43":1}}],["客户端不会把每个用户命令都立即发送到服务器而是以每秒",{"1":{"82":1}}],["客户端不需要服务器确认帧返回才执行指令",{"1":{"15":1}}],["客户端发送命令给服务端",{"1":{"1013":1}}],["客户端发送开火指令到服务器",{"1":{"79":1}}],["客户端发送输入并且模拟游戏的结果",{"1":{"78":1}}],["客户端获取世界更新",{"1":{"78":1}}],["客户端接收到服务器发送来的每个其他车的速度和行驶方向",{"1":{"75":1}}],["客户端模拟出输入的结果",{"1":{"71":1}}],["客户端具体如何处理",{"1":{"69":1}}],["客户端得到",{"1":{"69":1}}],["客户端得到的游戏状态都是过去的",{"1":{"69":1}}],["客户端在每次请求的时候加上一个编号",{"1":{"69":1}}],["客户端在收到来自服务器的最新信息后",{"1":{"43":1}}],["客户端必须纠正自己的位置",{"1":{"84":1}}],["客户端必须将角色移回",{"1":{"68":1}}],["客户端必须重新运行旧的命令",{"1":{"43":1}}],["客户端能够预测游戏世界在接受输入后的状态",{"1":{"67":1}}],["客户端只将输入发送到服务器中",{"1":{"66":1}}],["客户端只是纯粹的接受服务器下发的怪物状态数据",{"1":{"17":1}}],["客户端对结果进行渲染呈现",{"1":{"63":1}}],["客户端想要作弊",{"1":{"63":1}}],["客户端跟服务器完全匹配",{"1":{"50":1}}],["客户端跟服务器采用相同的代码来计算移动",{"1":{"43":1}}],["客户端服务器完全同步",{"1":{"50":1}}],["客户端通过2个更新信息插值并且朝最新更新位置移动",{"1":{"46":1}}],["客户端通过减去时间差",{"1":{"46":1}}],["客户端渲染的时候会有100ms滞后",{"1":{"46":1}}],["客户端物体实际移动位置总是滞后一段时间",{"1":{"46":1}}],["客户端可以在带宽可用的情况下增加他们的快照更新率",{"1":{"86":1}}],["客户端可以在这个外推的位置渲染这个玩家",{"1":{"46":1}}],["客户端可以看到",{"1":{"84":1}}],["客户端可以通过设置cl",{"1":{"82":1}}],["客户端可以基于上次服务器发来的状态和",{"1":{"69":1}}],["客户端可以一直往前预测",{"1":{"15":1}}],["客户端进行运动和武器效果预测是非常可行的",{"1":{"45":1}}],["客户端武器开火预测包括预测武器切换",{"1":{"44":1}}],["客户端玩家需要记录一些状态",{"1":{"44":1}}],["客户端将向服务器发送文本",{"1":{"444":1}}],["客户端将只告诉服务器用",{"1":{"85":1}}],["客户端将",{"1":{"69":1}}],["客户端将内部游戏状态更新为服务器所发来的游戏状态",{"1":{"69":1}}],["客户端将动作发送给服务器",{"1":{"63":1}}],["客户端将没有执行的客户端命令进行标记",{"1":{"43":1}}],["客户端将加速",{"1":{"15":1}}],["客户端帧率",{"1":{"43":1}}],["客户端又在不停地以一定速度",{"1":{"43":1}}],["客户端算法大致如下",{"1":{"43":1}}],["客户端就可以假设事实上这个玩家当前实际的位置已经向前移动了50个单位",{"1":{"46":1}}],["客户端就会给服务器发送类似这样的结果报告",{"1":{"45":1}}],["客户端就不再是一个",{"1":{"43":1}}],["客户端就发一个消息给服务器",{"1":{"19":1}}],["客户端预测的位置已经到达",{"1":{"68":1}}],["客户端预测",{"0":{"43":1,"67":1},"1":{"72":1}}],["客户端执行了操作到看到操作的结果就需要500ms",{"1":{"42":1}}],["客户端执行完每个逻辑帧后",{"1":{"15":1}}],["客户端收到伤害信息",{"1":{"807":1}}],["客户端收到一个快照",{"1":{"83":1}}],["客户端收到以后进行渲染",{"1":{"42":1}}],["客户端收到确认后",{"1":{"15":1}}],["客户端的安装配置",{"1":{"467":1}}],["客户端的输入预测",{"1":{"84":1}}],["客户端的cpu负载",{"1":{"82":1}}],["客户端的行为越方便预测",{"1":{"74":1}}],["客户端的预测行为独立于服务端的更新",{"1":{"74":1}}],["客户端的游戏状态需要通过服务器的回复和还未处理的输入进行重新计算",{"1":{"71":1}}],["客户端的位置会由服务器来处理",{"1":{"63":1}}],["客户端的移动位置要优先于服务端的",{"1":{"57":1}}],["客户端的每一帧循环如下",{"1":{"41":1}}],["客户端的时间",{"1":{"15":1}}],["客户端仅仅是用来接收玩家的操作并发给服务器",{"1":{"41":1}}],["客户端提前服务器的方式",{"1":{"15":1}}],["客户端逻辑如果足够干净和独立",{"1":{"15":1}}],["客户端分布式验证假如客户端的核心逻辑写得足够干净和独立的话",{"1":{"15":1}}],["客户端上报服务器各自计算的state",{"1":{"15":1}}],["客户端自验证",{"1":{"15":1}}],["已发布到",{"1":{"465":1}}],["已日为单位",{"1":{"373":1}}],["已画建筑的简单变形",{"1":{"287":1}}],["已经被创建了且包含了prefab和linkedentitygroup",{"1":{"966":1}}],["已经被连续排列好了",{"1":{"945":1}}],["已经被删除了",{"1":{"935":1}}],["已经被占用",{"1":{"221":1}}],["已经帮我们预制好相应的函数方法了",{"1":{"841":1}}],["已经介绍",{"1":{"805":1}}],["已经失效了",{"1":{"553":1}}],["已经执行超过",{"1":{"449":1}}],["已经没有永久区了",{"1":{"122":1}}],["已经隐藏起来的玩家需要取一个历史位置并计算是否击中",{"1":{"48":1}}],["桥",{"1":{"287":1}}],["绳索",{"1":{"287":1}}],["袋装的种子",{"1":{"287":1}}],["锤子",{"1":{"287":1}}],["剪刀",{"1":{"287":1}}],["斧头",{"1":{"287":1}}],["镰刀",{"1":{"287":1}}],["水平的主轴",{"1":{"406":1}}],["水果动物掉落",{"1":{"299":1}}],["水壶",{"1":{"287":1}}],["水体比例",{"1":{"214":1}}],["锄头",{"1":{"287":1}}],["旅途的场景",{"1":{"287":1}}],["旅途",{"1":{"287":1}}],["冰冷",{"1":{"394":1}}],["冰雪场景",{"1":{"287":1}}],["冰冻",{"1":{"246":1}}],["遗迹",{"1":{"287":1,"295":1}}],["村庄背景",{"1":{"287":1}}],["房間示意圖房間的深度資訊",{"1":{"974":1}}],["房屋内部",{"1":{"287":1}}],["房屋和树的结合",{"1":{"287":1}}],["房间模板",{"1":{"225":2}}],["房间类型对开始的房间来说没太大影响",{"1":{"224":1}}],["没什么关系了",{"1":{"971":1}}],["没用",{"1":{"965":1}}],["没错",{"1":{"846":1}}],["没必要的重复访问会导致托管堆的扩张",{"1":{"824":1}}],["没到前摇时间就进行了技能结算",{"1":{"804":1}}],["没啥特别之处",{"1":{"472":1}}],["没铁矿产的第2要先著手掌法",{"1":{"374":1}}],["没特别的想法",{"1":{"287":1}}],["没有重复的对象出现",{"1":{"971":1}}],["没有linkedentitygroup则",{"1":{"965":1}}],["没有回调",{"1":{"932":1}}],["没有unit就没有buff",{"1":{"808":1}}],["没有碰到",{"1":{"750":1}}],["没有使用的字段都不会被编译",{"1":{"602":1}}],["没有什么能够比数据更有说服力",{"1":{"175":1}}],["没有执行到的就不会加载和编译",{"1":{"131":1}}],["没有的话做jit编译",{"1":{"131":1}}],["没有的话jit把这段il代码编译成本地代码保存到内存中并方法表的存根做上标记",{"1":{"131":1}}],["没有的话就加载进来并在托管堆上建一个类型对象",{"1":{"131":1}}],["没有任何区别",{"1":{"130":1}}],["没有可测试的样例",{"1":{"104":1}}],["没有必要发给客户端",{"1":{"97":1}}],["没有设置集群",{"1":{"91":1}}],["没有一个确定ok的环境",{"1":{"89":1}}],["没有需要预测的输入",{"1":{"69":1}}],["没有限制",{"1":{"46":1}}],["没有",{"1":{"12":1,"456":2,"693":1,"952":1,"953":1}}],["家园场景",{"1":{"287":1}}],["茂密高大的竹林背景",{"1":{"287":1}}],["茂密高大的森林背景",{"1":{"287":1}}],["山岭2",{"1":{"297":1}}],["山下来妖",{"1":{"295":1}}],["山林中既有矿石",{"1":{"287":1}}],["山谷场景",{"1":{"287":1}}],["丛林场景",{"1":{"287":1}}],["海滩场景",{"1":{"287":1}}],["海岛群",{"1":{"214":1}}],["树",{"1":{"940":1}}],["树木",{"0":{"302":1},"1":{"300":1,"849":1}}],["树林2",{"1":{"297":1}}],["树林3",{"1":{"297":1}}],["树林场景",{"1":{"287":1}}],["树的当前节点会被标记为不可通行",{"1":{"210":1}}],["画不破了",{"1":{"854":1}}],["画不出也没关系",{"1":{"287":16}}],["画面是不是清爽了许多",{"1":{"854":1}}],["画面撕裂",{"1":{"854":1}}],["画面撕裂假设游戏中有一面黑白相间的栅栏墙高速向左运动",{"1":{"854":1}}],["画面滞后会延迟影响双方玩家",{"1":{"86":1}}],["画完所有行发出一个垂直同步信号",{"1":{"854":1}}],["画一个文本显示相关信息等",{"1":{"841":1}}],["画一条与物体的速度向量相重合的线",{"1":{"760":1}}],["画出来",{"1":{"751":1}}],["画风都不符合国内游戏的感觉",{"1":{"287":1}}],["服装",{"0":{"285":1},"1":{"287":1},"2":{"286":1,"287":1}}],["服务是否已成功启动",{"1":{"475":1}}],["服务",{"1":{"475":1}}],["服务验证安装至此就完成了",{"1":{"467":1}}],["服务在接受和处理请求时",{"1":{"170":1}}],["服务的代码量并不下",{"1":{"170":1}}],["服务端接收到命令",{"1":{"1013":1}}],["服务端接收到请求后",{"1":{"1013":1}}],["服务端传送的同步",{"1":{"1013":1}}],["服务端处理后将tick和数据同步给客户端",{"1":{"1013":1}}],["服务端处理queue里面所有的input",{"1":{"73":1}}],["服务端永远为serversimulationsystemgroup",{"1":{"1013":1}}],["服务端创建networkidcomponent",{"1":{"1013":1}}],["服务端根据gamemode",{"1":{"1012":1}}],["服务端playermoduleserver",{"1":{"1012":1}}],["服务端首先根据技能信息计算伤害值",{"1":{"809":1}}],["服务端负责结算即可",{"1":{"808":1}}],["服务端确定buff是否可以挂在unit上面",{"1":{"808":1}}],["服务端计算攻击伤害等信息",{"1":{"807":1}}],["服务端发起创建一个法术场",{"1":{"807":1}}],["服务端广播给所有的其他客户端",{"1":{"805":1}}],["服务端广播给所有的客户端",{"1":{"803":1}}],["服务端不再同步给其他客户端",{"1":{"805":1}}],["服务端不用遍历全场景对象",{"1":{"97":1}}],["服务端开始进行技能结算",{"1":{"803":1}}],["服务端延迟一段时间后",{"1":{"803":1}}],["服务端和其他玩家的客户端都是proxy",{"1":{"801":1}}],["服务端",{"0":{"475":1},"1":{"1013":1}}],["服务器呢",{"1":{"581":1}}],["服务器之间要符合",{"1":{"577":1}}],["服务器之间的桥梁",{"1":{"576":1}}],["服务器之间的接口标准",{"1":{"572":1}}],["服务器将结果发送给客户端",{"1":{"576":1}}],["服务器将根据",{"1":{"574":1}}],["服务器进行通信",{"1":{"576":1}}],["服务器与",{"1":{"574":1}}],["服务器再返回给客户端",{"1":{"573":1}}],["服务器运行另一个外部程序",{"1":{"573":1}}],["服务器简单地响应浏览器发来的",{"1":{"573":1}}],["服务器上",{"1":{"572":1}}],["服务器上的密码",{"1":{"411":1}}],["服务器程序之间通信",{"1":{"572":1}}],["服务器调用外部应用程序的时候需要输入的参数",{"1":{"572":1}}],["服务器所执行的命令",{"1":{"453":1}}],["服务器启动",{"0":{"167":1}}],["服务器要下发消息",{"1":{"103":1}}],["服务器大格子的大小",{"1":{"103":1}}],["服务器和",{"1":{"574":1,"577":1}}],["服务器和所有客户端都具有必要的硬件资源可用",{"1":{"86":1}}],["服务器和客户端在同一台机器上",{"1":{"83":1}}],["服务器和客户端时间差算法",{"0":{"52":1},"2":{"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1}}],["服务器移到你的命中包围盒时光倒流",{"1":{"85":1}}],["服务器回溯演绎",{"1":{"85":1}}],["服务器回复的时候将其处理过最后一个请求的编号包含在消息中",{"1":{"69":1}}],["服务器恢复基于所述估计的命令执行时间目标位置",{"1":{"85":1}}],["服务器端可以启用sv",{"1":{"85":1}}],["服务器端工作线程可控",{"1":{"30":1}}],["服务器预计在命令创建什么时间如下",{"1":{"85":1}}],["服务器持续模拟游戏世界",{"1":{"85":1}}],["服务器管理员可以通过sv",{"1":{"82":1}}],["服务器以一个固定的时间间隔更新模拟游戏世界",{"1":{"82":1}}],["服务器向所有客户端发送游戏世界的快照",{"1":{"78":1}}],["服务器处理输入并且更新世界状态",{"1":{"78":1}}],["服务器从客户端收到带有时间戳的输入信息",{"1":{"78":1}}],["服务器说",{"1":{"69":1}}],["服务器校对",{"0":{"69":1}}],["服务器在",{"1":{"456":1}}],["服务器在接到客户端的请求之后",{"1":{"444":1}}],["服务器在该时间点处理快照",{"1":{"79":1}}],["服务器在50ms之后获取了数据",{"1":{"64":1}}],["服务器在自己的98帧或99帧收到了a",{"1":{"15":1}}],["服务器来周期性地更新游戏状态",{"1":{"63":1}}],["服务器来运行这个游戏",{"1":{"63":1}}],["服务器同样不信任玩家的位置",{"1":{"63":1}}],["服务器发给每个客户端数据包以后",{"1":{"50":1}}],["服务器执行客户端命令之前执行以下操作",{"1":{"47":1}}],["服务器执行到97帧",{"1":{"15":1}}],["服务器",{"0":{"73":1,"164":1,"580":1},"1":{"45":1,"444":1,"573":1,"575":1,"576":2,"581":2}}],["服务器需要将必要的字段发给客户端",{"1":{"45":1}}],["服务器不会每次都发送一个完整的世界快照",{"1":{"82":1}}],["服务器不会处理",{"1":{"43":1}}],["服务器不信任玩家的在客户端的血量",{"1":{"63":1}}],["服务器不参与怪物的状态",{"1":{"17":1}}],["服务器也要避免客户端意见预测的效果",{"1":{"43":1}}],["服务器仍然在运行并保证在客户端跟服务器运行结果不一致的情况下纠正客户端错误的模拟",{"1":{"43":1}}],["服务器响应这些命令并把更新了的世界和物体位置信息发回客户端",{"1":{"42":1}}],["服务器的",{"1":{"576":1}}],["服务器的返回结果",{"1":{"572":1}}],["服务器的状态",{"1":{"445":1}}],["服务器的硬件和网络配置工作",{"1":{"86":1}}],["服务器的循环大同小异",{"1":{"41":1}}],["服务器的帧步进是不会等待的",{"1":{"12":1}}],["服务器对这些操作作出响应",{"1":{"41":1}}],["服务器计算出boss怪当前最适合攻击的对象",{"1":{"20":1}}],["服务器到了100帧",{"1":{"15":1}}],["服务器收到后给客户端确认",{"1":{"15":1}}],["服务器都根据客户端的state",{"1":{"15":1}}],["服务器统计与运营策略非单机模式下",{"1":{"15":1}}],["服务器验证与客户端分布式验证相同",{"1":{"15":1}}],["服务器可以将某一场战斗的数据下发给一个空闲客户端",{"1":{"15":1}}],["服务器可以通过对比state",{"1":{"15":1}}],["服务器会保存玩家当场游戏的游戏指令以及状态信息",{"1":{"12":1}}],["子目录下文件返回的路径是错的",{"1":{"1047":1}}],["子元素依然参与全局的depth排序",{"1":{"860":1}}],["子元素的",{"1":{"405":1}}],["子类和",{"1":{"858":1}}],["子物体没有physicscollider",{"1":{"1000":1}}],["子物体就不需要额外旋转了",{"1":{"841":1}}],["子物体当做世界中的物体",{"1":{"841":1}}],["子物体",{"1":{"841":1}}],["子",{"1":{"660":1}}],["子节点只实现ipointerclickhandler接口的话",{"1":{"657":1}}],["子节点在相对于父节点的位置上保持不变的",{"1":{"625":1}}],["子节点永远返回true",{"1":{"283":1}}],["子节点永远返回false",{"1":{"283":1}}],["子进程带有主进程的数据副本",{"1":{"455":1}}],["子进程进行",{"1":{"455":1}}],["子进程里执行",{"1":{"455":1}}],["子线程没有在执行",{"1":{"449":1}}],["子线程正在执行",{"1":{"449":1}}],["子心情代表其个人的该日心情",{"1":{"373":1}}],["子嗣传功",{"1":{"295":1}}],["子弹",{"1":{"243":1}}],["子弹拐到角落里",{"1":{"48":1}}],["生活属性",{"0":{"393":1}}],["生产环境下建议用其他wsgi",{"1":{"578":1}}],["生产服饰之地",{"1":{"380":1}}],["生产周期",{"1":{"303":2}}],["生财",{"1":{"368":1,"393":1}}],["生死搏斗",{"1":{"295":1}}],["生效的方式",{"1":{"283":1}}],["生成的图片体积更小",{"1":{"1033":1}}],["生成的exe既然是window下可执行文件",{"1":{"131":1}}],["生成了一个匿名类",{"1":{"818":1}}],["生成出来的代码会先向用户请求新的值",{"1":{"739":1,"744":1}}],["生成出口",{"1":{"224":1}}],["生成新的代码",{"1":{"709":1}}],["生成新的迁移",{"1":{"132":1}}],["生成实时信息等",{"1":{"577":1}}],["生成一个随机密码以上三项信息在配置",{"1":{"475":1}}],["生成后可以把",{"1":{"459":1}}],["生成私钥",{"0":{"459":1}}],["生成什么类型的怪物",{"1":{"292":1}}],["生成时系统将会随机挑选一些词缀安排给这个物品",{"1":{"270":1}}],["生成类",{"0":{"226":1},"2":{"227":1,"228":1,"229":1,"230":1}}],["生成room",{"0":{"225":1}}],["生成关卡的critical",{"1":{"224":1}}],["生成地图质量的定量评估",{"0":{"215":1}}],["生成地图的轮廓",{"1":{"214":1}}],["生成地图的效率等要求",{"1":{"213":1}}],["生成代码",{"1":{"176":1}}],["生成命令",{"1":{"43":1}}],["观察某个变量stops",{"1":{"283":1}}],["观察某个变量",{"1":{"283":3}}],["观察者装饰器",{"1":{"283":1}}],["观察者模式",{"0":{"283":1}}],["观察者可能收到超出自己视野范围的消息",{"1":{"104":1}}],["观察者位置变化",{"1":{"104":1}}],["累计tick",{"1":{"277":1}}],["暗器种类也不尽相同",{"1":{"380":1}}],["暗器都需要自己生产才能获得",{"1":{"380":1}}],["暗器",{"1":{"378":2,"381":1}}],["暗色的砖石",{"1":{"287":1}}],["暗金",{"1":{"275":1}}],["暗黑中怪物分为如下几个种类等级",{"1":{"266":1}}],["暗黑3",{"1":{"254":1}}],["暂不介绍",{"1":{"275":1}}],["暂时用不到的api可以可以不写",{"1":{"398":1}}],["暂时没有好的理解",{"1":{"239":1}}],["暂时没看到使用的地方",{"1":{"233":1}}],["暂时称之为b格子",{"1":{"107":1}}],["暂时称之为a格子",{"1":{"107":1}}],["较低的",{"1":{"941":1}}],["较多",{"1":{"861":1}}],["较为复杂",{"1":{"275":1}}],["较高的tickrate增加了模拟精度",{"1":{"82":1}}],["≥",{"1":{"275":1}}],["锁住的箱子会掉更好的东西么",{"1":{"274":1}}],["成像後前後順序",{"1":{"974":1}}],["成了",{"1":{"966":1}}],["成为了过去时",{"1":{"955":1}}],["成为测试人员",{"1":{"610":1}}],["成功的对象深度排序",{"0":{"692":1}}],["成功的攻击将使敌人晕眩并提高你的命中率",{"1":{"247":1}}],["成功",{"1":{"691":1}}],["成熟所需天数",{"1":{"303":1}}],["成色判定过程",{"1":{"275":1}}],["成品qlvl",{"1":{"273":1}}],["谐角之冠",{"1":{"273":2,"275":6}}],["军帽",{"1":{"273":5,"275":3}}],["军团要塞",{"1":{"41":1,"49":1}}],["底材判定过程",{"1":{"275":1}}],["底材",{"0":{"273":1},"1":{"273":4}}],["底部有出口",{"1":{"224":1}}],["财宝等级",{"1":{"272":2}}],["财宝等级决定物品的品质等级怪物是否能掉落对应装备必须满足两个条件",{"1":{"272":1}}],["财宝阶层",{"0":{"267":1}}],["财富等级",{"0":{"272":1}}],["答案就是我们最前面提到的屏幕宽高比",{"1":{"618":1}}],["答案是true",{"1":{"991":1}}],["答案是在",{"1":{"964":1}}],["答案是肯定的",{"1":{"536":1,"841":1}}],["答案是有的",{"1":{"535":1}}],["答案是",{"1":{"270":1}}],["答案当然是有存在的必要",{"1":{"206":1}}],["统一",{"0":{"983":1},"1":{"981":2,"982":2}}],["统一在服务端处理",{"1":{"802":1}}],["统治者大盾",{"1":{"275":1}}],["统盾",{"1":{"270":1}}],["统计的结果如下所示",{"1":{"215":1}}],["统计每个玩家与其他势力最小距离的均值与方差",{"1":{"215":1}}],["统计信息",{"1":{"30":1}}],["超频总结",{"0":{"551":1}}],["超过最高上限他就会不爽",{"1":{"372":1}}],["超过则当日之后的战斗结算均无效",{"1":{"15":1}}],["超市金怪出了一个君主盾",{"1":{"270":1}}],["带有一个存储",{"1":{"929":1}}],["带给了我一些计算方面的想法",{"1":{"789":1}}],["带着金钱或原料资源前去交涉疏通",{"1":{"383":1}}],["带一株回到庭院里种",{"1":{"296":1}}],["带入公式",{"1":{"270":2}}],["带上本地时间",{"1":{"51":1}}],["<=",{"1":{"976":1}}],["<",{"1":{"270":2,"737":1,"824":4}}],["仅管shadow",{"1":{"980":1}}],["仅需定义一个",{"1":{"967":1}}],["仅当我们显式要求时才导出",{"1":{"965":1}}],["仅仅在",{"1":{"960":1}}],["仅仅是复制生成了来自classic",{"1":{"1054":1}}],["仅仅是保留",{"1":{"955":1}}],["仅仅是告诉你重叠了多少和分开它们所需的最短距离",{"1":{"788":1}}],["仅有顶层对象会正常convert",{"1":{"956":1}}],["仅有",{"1":{"952":1}}],["仅一个指针被移动到addfive",{"1":{"885":1}}],["仅使用少量",{"1":{"849":1}}],["仅用于已发布的版本",{"1":{"703":1}}],["仅在",{"1":{"695":1}}],["仅限于单手剑",{"1":{"384":1}}],["仅限蓝色装备",{"1":{"270":1}}],["仅作参考矿洞场景",{"1":{"287":1}}],["仅供参考",{"1":{"287":1}}],["仅设置culture",{"1":{"152":1}}],["偏向对应格档速度和格档机率",{"1":{"270":1}}],["珠宝匠对应4孔",{"1":{"270":1}}],["红字为稀有特性或特有特性",{"1":{"378":1}}],["红框内是后缀",{"1":{"270":1}}],["红色箭头",{"1":{"898":1}}],["红色部分",{"1":{"657":1}}],["红色正方向锚点y轴坐标",{"1":{"625":1}}],["红色正方形的左上顶点距离canvas左上顶点距离",{"1":{"625":1}}],["红色图片的锚点为左上",{"1":{"625":1}}],["红色image大小100",{"1":{"625":1}}],["红色的节点表示需要回退的节点",{"1":{"210":1}}],["红色命中包围盒显示了客户端那里是100毫秒+插补周期前的目标位置",{"1":{"85":1}}],["词缀种类非常多",{"1":{"270":1}}],["词缀等级按照",{"1":{"270":1}}],["词缀等级",{"0":{"270":1},"1":{"270":1}}],["词条等",{"1":{"234":1}}],["掉",{"1":{"575":1,"947":1}}],["掉的问题",{"1":{"372":1}}],["掉落",{"1":{"302":1,"303":1,"304":1,"305":1,"306":1,"307":1,"308":1,"309":1}}],["掉落过程",{"0":{"275":1}}],["掉落的物品只与怪物等级与场景等级有关",{"1":{"274":1}}],["掉落的装备就是68级",{"1":{"270":1}}],["掉落机制",{"0":{"274":1},"2":{"275":1}}],["掉落规则",{"0":{"268":1},"2":{"269":1,"270":1,"271":1,"272":1,"273":1,"274":1,"275":1}}],["掉入的房间",{"1":{"225":1}}],["共享材质会更有效率",{"1":{"929":1}}],["共享组件",{"0":{"928":1},"1":{"905":1},"2":{"929":1,"930":1,"931":1,"932":1,"933":1,"934":1,"935":1,"936":1,"937":1,"938":1,"939":1}}],["共享代码",{"1":{"44":1}}],["共有29个递增的tc阶层",{"1":{"267":1}}],["☆",{"1":{"275":2}}],["☆也就是说",{"1":{"275":1}}],["☆tc由3到87",{"1":{"267":1}}],["☆血乌",{"1":{"266":1}}],["名气",{"1":{"295":1}}],["名气14",{"1":{"295":1}}],["名字由词缀",{"1":{"266":1}}],["名称为",{"1":{"398":1}}],["名称进行监听",{"1":{"167":1}}],["名称空间",{"1":{"166":1}}],["名称是",{"1":{"153":1}}],["名称",{"1":{"153":1,"297":1}}],["拥有最高优先级",{"1":{"1039":1}}],["拥有lightmap的物体将不会进行批处理",{"1":{"980":1}}],["拥有lightmap的物体将不会进行同批处理",{"1":{"979":1}}],["拥有lightmap的物体含有额外",{"1":{"979":1,"980":1}}],["拥有以下事件onentityadded",{"1":{"740":1}}],["拥有一个凭证系统来处理这个事情",{"1":{"411":1}}],["拥有基础的53闪避值iv",{"1":{"384":1}}],["拥有固定属性以及可能出现的随机属性",{"1":{"266":1}}],["拥有超过15年历史的陈旧c编译器所产生的代码都是非托管代码",{"1":{"127":1}}],["尼拉塞克",{"1":{"266":1}}],["衣卒尔",{"1":{"266":1}}],["罗达门特",{"1":{"266":1}}],["格外的说明",{"1":{"699":1}}],["格式",{"1":{"506":1}}],["格式的文档进行转换",{"1":{"506":1}}],["格挡率",{"1":{"390":1}}],["格挡iii",{"1":{"384":1}}],["格里斯瓦得",{"1":{"266":1}}],["格子越小",{"1":{"104":1}}],["格子坐标",{"1":{"103":1}}],["格子编号",{"1":{"103":1}}],["格子的y轴坐标",{"1":{"103":2}}],["格子的x轴坐标",{"1":{"103":2}}],["格子长度",{"1":{"103":1}}],["格子宽度",{"1":{"103":1}}],["格子",{"0":{"98":1},"1":{"100":1},"2":{"99":1,"100":1,"101":1,"102":1,"103":1,"104":1}}],["墨家",{"1":{"392":1}}],["墨菲斯托等",{"1":{"266":1}}],["墨西哥",{"1":{"152":1}}],["督瑞尔",{"1":{"266":1}}],["君主",{"1":{"260":1}}],["叙事",{"1":{"254":1}}],["挑战",{"1":{"254":1}}],["解释器与",{"1":{"576":1}}],["解析配置文件",{"1":{"575":1}}],["解压后在ja",{"1":{"556":1}}],["解压后是这样",{"1":{"556":1}}],["解压到磁盘",{"1":{"556":1}}],["解谜",{"1":{"254":1}}],["解决这种问题比较直接的方式是技能直接创建两个法术场",{"1":{"801":1}}],["解决这个问题的关键是要延迟渲染",{"1":{"83":1}}],["解决基于z轴方向哪个视差对象被哪个视差相机渲染的问题",{"1":{"737":1}}],["解决办法",{"0":{"837":1},"1":{"658":1}}],["解决加载多个模块速度过慢的问题",{"1":{"536":1}}],["解决方案",{"0":{"404":1},"1":{"161":1}}],["解决方法也很简单",{"1":{"204":1}}],["解决方法",{"1":{"135":1}}],["解决方法很简单",{"1":{"43":1}}],["解决问题的关键就是将网络玩家显示在过去的某个时刻",{"1":{"76":1}}],["解决上面说的问题的办法就是你得意识到",{"1":{"69":1}}],["解决思路也基本是正确的",{"1":{"15":1}}],["狩猎",{"1":{"254":1}}],["星露谷",{"1":{"254":2}}],["收起思绪",{"1":{"714":1}}],["收人的时候除了看属性和特技",{"1":{"374":1}}],["收入就要靠其他弟子来分担",{"1":{"373":1}}],["收学费2块钱的话大约最高练武上限能到4000而已",{"1":{"372":1}}],["收获农产品增加经验",{"1":{"368":1}}],["收获了一整天的好心情",{"1":{"296":1}}],["收集到新的entity才会被执行",{"1":{"742":1}}],["收集粮食",{"1":{"393":1}}],["收集古董",{"0":{"317":1}}],["收集不同的草药",{"0":{"316":1}}],["收集不同的鱼类",{"0":{"315":1}}],["收集不同的矿物",{"0":{"314":1}}],["收集不同的植物",{"0":{"313":1}}],["收集九块令牌",{"0":{"312":1}}],["收集包",{"1":{"254":1}}],["收集",{"0":{"311":1},"1":{"254":1},"2":{"312":1,"313":1,"314":1,"315":1,"316":1,"317":1}}],["收到",{"1":{"51":1}}],["送礼好感度=====获取的难度",{"1":{"301":1}}],["送礼物",{"1":{"254":1}}],["送男子就医",{"1":{"296":1}}],["送信",{"1":{"254":1}}],["跨地图送货",{"1":{"254":1}}],["杀了150个强盗",{"0":{"334":1}}],["杀人",{"1":{"254":1}}],["杀狼",{"1":{"254":1}}],["酒馆",{"1":{"369":1}}],["酒店室内",{"1":{"287":1}}],["酒",{"1":{"254":1}}],["钓鱼增加经验",{"1":{"368":1}}],["钓鱼",{"1":{"254":1,"368":1}}],["搜集特殊物品",{"1":{"254":1}}],["搜索失败",{"1":{"210":1}}],["搜索算法部分是最为困难的部分了",{"1":{"210":1}}],["搜索算法",{"0":{"210":1}}],["搜索所走过的路径称为引用链",{"1":{"116":1}}],["任可对pvalue的改变都会影响到x",{"1":{"891":1}}],["任意凸多边形和圆形",{"1":{"764":1}}],["任务自身时间消耗占当前帧cpu消耗的时间比例",{"1":{"878":1}}],["任务名称",{"1":{"388":1,"389":1}}],["任务类型",{"1":{"387":1}}],["任务",{"0":{"387":1}}],["任务按钮",{"1":{"255":1}}],["任务分类",{"0":{"254":1}}],["任务接受流程",{"0":{"253":1}}],["任何没有",{"1":{"960":1}}],["任何实现了",{"1":{"920":1}}],["任何与主列表中有关联的东西也被画入图中",{"1":{"898":1}}],["任何情况下",{"1":{"841":1}}],["任何坐标系的坐标和屏幕坐标系的转换都是非常重要的",{"1":{"841":1}}],["任何对象只能属于一个appdomain",{"1":{"707":1}}],["任何一个容器都可以指定为",{"1":{"405":1}}],["任何东西都不能比光快吧",{"1":{"64":1}}],["任何类型的游戏开发都是某种挑战",{"1":{"61":1}}],["任何战斗模式都可以进行验证了",{"1":{"15":1}}],["略麻烦升级可以解锁一条额外属性",{"1":{"251":1}}],["顶部的",{"1":{"953":1}}],["顶点属性要小于900",{"1":{"876":1}}],["顶点坐标数组存放mesh的每个顶点的空间坐标",{"1":{"846":1}}],["顶点坐标",{"1":{"846":1}}],["顶点的梯度向量直接决定了这一点",{"1":{"197":1}}],["顶级",{"1":{"251":1}}],["圆是没有任何的边",{"1":{"785":1}}],["圆心",{"1":{"755":1}}],["圆满",{"1":{"248":1}}],["圆形攻击范围有两种",{"1":{"776":1}}],["圆形攻击范围",{"0":{"776":1}}],["圆形与多边形之间的碰撞检测",{"0":{"764":1}}],["圆形与旋转矩形",{"0":{"756":1}}],["圆形与矩形",{"0":{"755":1},"1":{"756":3}}],["圆形的物体",{"1":{"754":1}}],["圆形碰撞",{"0":{"754":1}}],["圆形竞技场",{"1":{"220":1}}],["圆形节点则表示",{"1":{"210":1}}],["巅峰",{"1":{"248":1}}],["警告队友迫近的危险并提升他们的防御力",{"1":{"247":1}}],["狂暴",{"1":{"247":1}}],["案例中更好的表现静态批处理",{"1":{"737":1}}],["案例",{"0":{"247":1}}],["召唤者",{"1":{"266":1}}],["召唤物的属性",{"1":{"246":1}}],["召唤object",{"1":{"246":1}}],["召唤",{"1":{"246":1}}],["召唤怪物",{"1":{"245":1}}],["扣除属性等",{"1":{"246":1}}],["敌人在这个范围内受伤",{"1":{"776":1}}],["敌人附加状态",{"1":{"246":1}}],["敌人和宝箱什么的",{"0":{"225":1},"1":{"224":1}}],["火焰突然变旺了",{"1":{"296":1}}],["火焰",{"1":{"246":1,"394":1}}],["毒术",{"1":{"297":2}}],["毒",{"1":{"246":1}}],["击落失败",{"1":{"296":1}}],["击落一只看看",{"1":{"296":1}}],["击杀怪物a",{"1":{"275":1}}],["击杀特效",{"1":{"245":1}}],["击晕特效",{"1":{"247":1}}],["击晕",{"1":{"247":1}}],["击退特效",{"1":{"247":1}}],["击中特效",{"1":{"245":1}}],["旋转后的坐标",{"1":{"756":1}}],["旋转",{"1":{"756":1,"848":1,"905":1}}],["旋转得到",{"1":{"693":1}}],["旋转动画并且移动的一个特殊动作",{"1":{"244":1}}],["旋转的死亡之舞挥砍所有在旋转路径上的敌人",{"1":{"244":1}}],["旋风",{"1":{"244":1}}],["动画等",{"1":{"1013":2}}],["动画曲线精度过高会增加动画占用内存",{"1":{"866":1}}],["动画与游戏开发",{"1":{"770":1}}],["动则就是几十兆的内存",{"1":{"849":1}}],["动物",{"0":{"305":1},"1":{"254":1,"300":1,"305":1}}],["动作等一系列和战斗逻辑有直接关系但没有本质关系的概念与数据的总和",{"1":{"811":1}}],["动作",{"1":{"244":1}}],["动态缓冲的内存管理是全自动的",{"1":{"937":1}}],["动态缓冲",{"0":{"937":1},"2":{"938":1}}],["动态合批原理及如何成功合批",{"1":{"876":1}}],["动态合批消耗过大",{"1":{"849":1}}],["动态批处理对于模型缩放的限制已经不存在了",{"1":{"876":1}}],["动态批处理原理",{"1":{"876":1}}],["动态批处理",{"0":{"980":1},"1":{"849":1}}],["动态改变文本",{"1":{"639":1}}],["动态请求转发以及结果的回复",{"1":{"581":1}}],["动态请求",{"1":{"576":1}}],["动态返回给客户端各种各样动态变化的信息",{"1":{"573":1}}],["动态链接库",{"1":{"125":1}}],["动态调整",{"1":{"15":1}}],["弹道的同步类似",{"1":{"807":1}}],["弹道的同步比较类似",{"1":{"807":1}}],["弹道的同步",{"0":{"807":1}}],["弹道的时候",{"1":{"797":1}}],["弹道等",{"1":{"803":1}}],["弹道或buff",{"1":{"803":1}}],["弹道和buff",{"1":{"801":1}}],["弹道是一类子弹移动路径的抽象",{"1":{"799":1}}],["弹道",{"0":{"799":1},"1":{"806":1}}],["弹性布局",{"1":{"405":1}}],["弹幕攻击",{"1":{"243":1}}],["弹球弹的效果就被平滑掉了",{"1":{"46":1}}],["激活idea",{"0":{"560":1}}],["激活阶段",{"1":{"242":1}}],["激活体会自始至终地处理完成每个请求后",{"1":{"158":1}}],["释放的空间成为其他内存段之间的",{"1":{"857":1}}],["释放的空间",{"1":{"857":1}}],["释放对象时",{"1":{"857":1}}],["释放内存",{"1":{"813":1}}],["释放法术场",{"1":{"803":1}}],["释放包括创建相应的弹道",{"1":{"796":1}}],["释放特效",{"1":{"245":1}}],["释放project",{"1":{"242":1}}],["释放阶段",{"1":{"242":1}}],["释放后",{"0":{"242":1},"2":{"243":1,"244":1,"245":1,"246":1,"247":1,"248":1,"249":1,"250":1,"251":1}}],["释放前",{"0":{"241":1},"1":{"699":1}}],["常量缓冲区",{"1":{"981":1,"982":1}}],["常量缓冲器",{"0":{"983":1},"1":{"981":1,"982":1}}],["常常可以重用对象",{"1":{"832":1}}],["常常只讨论武器和防具的掉落",{"1":{"267":1}}],["常见问题",{"0":{"561":1},"2":{"562":1,"563":1}}],["常见的有",{"1":{"573":1}}],["常见的有dll",{"1":{"131":1}}],["常见的",{"1":{"525":1}}],["常见的守护进程包括系统日志进程syslogd",{"1":{"3":1}}],["常规的",{"1":{"472":1}}],["常用的比如",{"1":{"1041":1}}],["常用于在uwsgi服务器与其他网络服务器的数据通信",{"1":{"582":1}}],["常用",{"1":{"574":1}}],["常用链接",{"0":{"483":1}}],["常用软件",{"0":{"482":1}}],["常用命令",{"0":{"424":1,"427":1}}],["常用tag写死",{"1":{"241":1}}],["常利用门派的情报介面看各人物的工作成效",{"1":{"373":1}}],["持续时间",{"1":{"394":1}}],["持续时间等创建方法",{"1":{"231":1}}],["持续的任务是怎么运行的",{"0":{"278":1}}],["持久化存储等说了这么多的优点",{"1":{"30":1}}],["持久化保存任务",{"1":{"30":1}}],["位移",{"1":{"1013":2}}],["位移信息会影响顶点",{"1":{"848":1}}],["位于",{"1":{"965":1}}],["位于释放的对象两侧的对象可能仍在使用中",{"1":{"857":1}}],["位于左下角",{"1":{"841":1}}],["位于连接处的tile",{"1":{"230":1}}],["位也一并下载安装此时点击开始菜单应该就能看到应用商店了清空应用商店缓存",{"1":{"533":1}}],["位安装包",{"1":{"533":1}}],["位可执行文件",{"1":{"510":3}}],["位置到物件中心",{"1":{"975":1}}],["位置渲染結果時",{"1":{"974":1}}],["位置也是从",{"1":{"841":1}}],["位置信息是否满足等",{"1":{"690":1}}],["位置",{"0":{"640":1},"1":{"639":1}}],["位置一般是固定的",{"1":{"257":1}}],["位置等",{"1":{"257":1}}],["位置变化",{"1":{"104":1}}],["门人弟子就会在一旁发呆",{"1":{"382":1}}],["门人弟子在工作之后精力会下降",{"1":{"382":1}}],["门客",{"0":{"344":1},"2":{"345":1,"346":1,"347":1,"348":1,"349":1}}],["门派内差事",{"0":{"389":1}}],["门派设施同一时间内只答应一位弟子进入工作或练习",{"1":{"382":1}}],["门派掌门人就是总舵的舵主",{"1":{"381":1}}],["门派的声望越高",{"1":{"380":1}}],["门派的薪资调整其实是在设定弟子心情的基准底限",{"1":{"372":1}}],["门派标志",{"1":{"380":1}}],["门派介面的脸是代表弟子基准心情底限及平均变化量",{"1":{"373":1}}],["门派介面的脸和弟子个别人物情报的脸是不一样的",{"1":{"373":1}}],["门派",{"0":{"320":1}}],["门派大比",{"1":{"295":1}}],["门派场景",{"1":{"287":1}}],["门",{"1":{"287":1}}],["门锁",{"1":{"229":1}}],["门和通道",{"1":{"218":1}}],["流放之路伤害类型",{"1":{"385":1}}],["流放之路伤害机制介绍",{"1":{"385":2}}],["流放之路攻击伤害和物理伤害",{"1":{"385":1}}],["流放之路poe丨各类防御机制",{"1":{"385":1}}],["流放之路技能伤害怎么计算",{"1":{"385":1}}],["流放之路技能伤害计算公式一览",{"1":{"385":1}}],["流放之路",{"1":{"385":2}}],["流放之路中",{"1":{"384":1}}],["流程原理",{"1":{"979":1,"981":1,"982":1}}],["流程中的",{"1":{"965":1}}],["流程中所处的位置大致如下图",{"1":{"656":1}}],["流程里的内容",{"1":{"951":1}}],["流程都是有脚本实现",{"1":{"811":1}}],["流程无从谈起",{"1":{"275":1}}],["流程",{"0":{"227":1},"1":{"966":1}}],["流量就可以走",{"1":{"467":1}}],["流量上来看",{"1":{"97":1}}],["流量的剧增",{"1":{"91":1}}],["译外话",{"1":{"889":1,"896":1,"898":4}}],["译者已查",{"0":{"824":1}}],["译者",{"1":{"782":1,"787":2,"788":1}}],["译于2018",{"1":{"225":1}}],["译注",{"1":{"50":1,"225":1,"588":1,"591":1,"594":1,"965":1}}],["障碍块",{"1":{"225":1}}],["静态",{"1":{"898":1}}],["静态批处理",{"0":{"979":1}}],["静态批处理原理",{"1":{"876":1}}],["静态批处理后",{"1":{"849":1}}],["静态和概率tile",{"1":{"225":1}}],["静态变量如果你初始化了tryoutrunners",{"1":{"898":1}}],["静态变量这些根向上找",{"1":{"131":1}}],["静态变量",{"1":{"131":1}}],["静态变量3",{"1":{"116":1}}],["嗯",{"1":{"225":2,"506":1,"592":1,"594":1,"847":1}}],["立即向下移动并同时切换左右方向",{"1":{"224":1}}],["立刻执行",{"1":{"15":1}}],["左图利用三个点绘制了一个三角形",{"1":{"846":1}}],["左图的玩家初始分布密集",{"1":{"213":1}}],["左下角为",{"1":{"841":1}}],["左下anchor",{"1":{"641":1}}],["左手坐标系和右手坐标系",{"1":{"840":1}}],["左手",{"1":{"781":1}}],["左键中建以及右键的处理都是分开的",{"1":{"674":1}}],["左",{"1":{"381":1}}],["左堂主的聪明和四大武功属性会影响弟子的练功效率",{"1":{"381":1}}],["左边是2个tile宽的墙",{"1":{"225":1}}],["左右",{"1":{"224":1}}],["左右上一定有出口第一步在最顶部这行随机选取一格创建一个start",{"1":{"224":1}}],["左右下一定有出口",{"1":{"224":1}}],["左右一定有出口",{"1":{"224":1}}],["感谢unity提供精选案例的免费资源",{"1":{"737":1}}],["感谢洋芋君指出之前的翻译问题",{"1":{"224":1}}],["感觉是版本管理的标准的开发流程",{"1":{"594":1}}],["感觉没啥变化",{"1":{"287":1}}],["感觉会非常奇怪",{"1":{"76":1}}],["感觉类似于冰面移动",{"1":{"50":1}}],["次法线",{"1":{"846":1}}],["次要房间",{"1":{"224":1}}],["次左右会通过这步",{"1":{"220":1}}],["次左右到地牢中去",{"1":{"220":1}}],["陷阱",{"0":{"225":1},"1":{"224":1}}],["陷阱呀什么的来守护比较",{"1":{"219":1}}],["扫描失败了",{"1":{"221":1}}],["扫描寻找新的房间所占用空间",{"1":{"221":1}}],["秘钥",{"1":{"510":1}}],["秘境",{"0":{"322":1}}],["秘道门和财宝什么的",{"1":{"220":1}}],["秘密就在上面的第15行",{"1":{"173":1}}],["写的是值类型",{"1":{"892":1}}],["写得比touch更加紧凑",{"1":{"674":1}}],["写成",{"1":{"590":1}}],["写上标题",{"1":{"502":1}}],["写入ghost数据",{"1":{"1013":1}}],["写入程序自动生成的",{"1":{"452":1}}],["写入操作由主进程执行",{"1":{"451":1}}],["写入和保存都由主进程执行",{"1":{"451":1}}],["写一个",{"1":{"220":1}}],["写个简单的例子",{"1":{"209":1}}],["放在其后",{"1":{"949":1}}],["放在1~3张大图集中",{"1":{"861":1}}],["放入",{"1":{"981":1}}],["放入到standard",{"1":{"839":1}}],["放入炼妖塔16",{"1":{"295":1}}],["放置于三角形",{"1":{"763":1}}],["放开的情形",{"0":{"672":1}}],["放出宠物+宠物战斗力10",{"1":{"295":1}}],["放一列房间",{"1":{"224":1}}],["放进去怪兽和物品第",{"1":{"220":1}}],["放各种",{"1":{"97":1}}],["返回的点都只能在这个平面上",{"1":{"1025":1}}],["返回的时成功或者失败",{"1":{"277":2}}],["返回true",{"1":{"992":1}}],["返回object对象",{"1":{"896":1}}],["返回result",{"1":{"885":1}}],["返回一个预先分配好的长度为0的数组的单例实例比重复创造空数组被认为更有效率",{"1":{"825":1}}],["返回值是bool类型",{"1":{"750":1}}],["返回",{"1":{"687":1,"695":1}}],["返回结果就是检测成功得到的",{"1":{"684":1}}],["返回本身的宽高",{"1":{"642":1}}],["返回左下角相对于pivot的距离",{"1":{"642":1}}],["返回字符窜",{"1":{"425":1}}],["返回第",{"1":{"220":1}}],["返回用于跟踪用户的首选区域性信息默认的",{"1":{"153":1}}],["步之后",{"1":{"452":1}}],["步骤四",{"1":{"784":1}}],["步骤三",{"1":{"784":1}}],["步骤二",{"1":{"784":1}}],["步骤一",{"1":{"784":1}}],["步骤",{"1":{"446":1}}],["步就是随机的创建怪兽",{"1":{"220":1}}],["步要看个人喜好了",{"1":{"220":1}}],["步返回去创建更多的房间",{"1":{"220":1}}],["步会将新元素添加到地图上去",{"1":{"220":1}}],["步继续",{"1":{"220":1}}],["步决定是否创建这个元素",{"1":{"220":1}}],["步更复杂一些",{"1":{"220":1}}],["步不太困难",{"1":{"220":1}}],["步麻烦一些",{"1":{"220":1}}],["步很简单",{"1":{"220":1}}],["步",{"1":{"220":2}}],["选中main",{"1":{"1034":1}}],["选中等",{"1":{"654":1}}],["选中某一房间",{"1":{"220":1}}],["选为左",{"1":{"381":1}}],["选项并非",{"1":{"951":1}}],["选项后",{"1":{"878":1}}],["选项打开",{"1":{"815":1}}],["选项勾上",{"1":{"592":1}}],["选项",{"1":{"586":1,"705":1,"869":1}}],["选项b",{"1":{"296":15}}],["选项a",{"1":{"296":15}}],["选安抚失去一个功法30",{"1":{"295":1}}],["选半价拍卖得随机的半价东西或者灵兽25",{"1":{"295":1}}],["选择场景视图在其工具栏左侧的显示模式",{"1":{"847":1}}],["选择合适最重要",{"1":{"769":1}}],["选择使用网址",{"1":{"610":1}}],["选择对应的选项",{"1":{"607":1}}],["选择一个可以访问的网站",{"1":{"560":1}}],["选择输入激活码",{"1":{"560":1}}],["选择适当的命令函数",{"1":{"444":1}}],["选择不要的功法和丹药换修为33",{"1":{"295":1}}],["选择",{"0":{"282":1}}],["选择另外一面墙",{"1":{"221":1}}],["选择性的让实例失效",{"1":{"174":1}}],["选择加载合适版本的clr",{"1":{"131":1}}],["代替复制",{"1":{"896":1}}],["代替此方法返回像素数据的nativearray",{"1":{"864":1}}],["代替",{"1":{"858":1}}],["代表打断点可发现只要在那个单例类的析构中打断点就会造成",{"1":{"836":1}}],["代表的就是原子状态之间的规则",{"1":{"800":1}}],["代表的就是自身pivot到anchor的向量",{"1":{"640":1}}],["代表这个事件已经被处理了",{"1":{"657":1}}],["代表物件的寬高尺寸都會受到",{"1":{"637":1}}],["代表",{"1":{"635":1,"636":1}}],["代表此物件的寬高尺寸都是固定值",{"1":{"634":1}}],["代表着某种地图元素",{"1":{"220":1}}],["代理和理由功能uwsgi也可以当做中间件",{"1":{"580":1}}],["代理端口",{"1":{"467":1}}],["代理",{"1":{"467":2}}],["代码动态改变材质变量后不算同一个材质",{"1":{"980":1,"981":1}}],["代码加载额外的locator存储了一个iresourcelocation列表",{"1":{"901":1}}],["代码图例",{"0":{"887":1,"889":1}}],["代码修改坐标及大小",{"0":{"645":1}}],["代码中获取到这些",{"1":{"964":1}}],["代码中没有直接使用过的泛型实例都会在运行时出现问题",{"1":{"599":1}}],["代码中创建实体",{"0":{"263":1}}],["代码也是非常的简单",{"1":{"592":1}}],["代码生成为c++代码",{"1":{"589":1}}],["代码并编译成",{"1":{"536":1}}],["代码并生成可执行",{"1":{"125":1}}],["代码非常简单就是两个",{"1":{"510":1}}],["代码完全开源",{"1":{"198":1}}],["代码实现原文地址",{"1":{"223":1}}],["代码实现c",{"1":{"223":1}}],["代码实现c++",{"1":{"223":1}}],["代码实现也很简单",{"1":{"204":1}}],["代码实现如下",{"1":{"200":1}}],["代码实现是c",{"1":{"198":1}}],["代码实现",{"0":{"198":1,"223":1},"1":{"223":5},"2":{"199":1,"200":1,"201":1,"202":1,"203":1}}],["代码如下",{"1":{"173":1,"684":1,"688":1,"695":2}}],["代码略",{"1":{"172":1}}],["代码里任何的定义项都可以在这个表里找到",{"1":{"131":1}}],["代码必须自己提供垃圾回收",{"1":{"127":1}}],["代码引用的成员以及运行时在执行时间使用的其他数据",{"1":{"127":1}}],["代码可以运行之前",{"1":{"127":1}}],["代码时",{"1":{"125":1}}],["代码",{"0":{"857":1},"1":{"125":1,"535":1,"536":1,"576":1,"604":1,"726":2},"2":{"858":1,"859":1,"860":1,"861":1,"862":1,"863":1,"864":1}}],["元气",{"1":{"390":1,"394":1,"395":1}}],["元宵节",{"0":{"330":1},"2":{"331":1}}],["元素加成",{"1":{"394":1}}],["元素",{"1":{"220":1}}],["元数据主要由定义表",{"1":{"131":1}}],["元数据很重要",{"1":{"131":1}}],["元数据",{"1":{"131":1}}],["元数据描述代码中的类型",{"1":{"127":1}}],["慢慢向四周扩散",{"1":{"219":1}}],["挖一个更大一些的洞",{"1":{"219":1}}],["计划",{"0":{"219":1},"1":{"898":1}}],["计算可以参考以下",{"1":{"862":1}}],["计算层级号的算法",{"1":{"862":1}}],["计算以后将信息通过技能模块发送给所有客户端",{"1":{"809":1}}],["计算夹角",{"1":{"771":1}}],["计算距离",{"1":{"771":1}}],["计算某个点绕另外一个点旋转一定角度后的坐标",{"1":{"756":1}}],["计算得到从当前射线检测使用的",{"1":{"684":1}}],["计算位置的时候会使用到",{"1":{"639":1}}],["计算时",{"1":{"378":1}}],["计算举个栗子",{"1":{"270":1}}],["计算词缀等级",{"1":{"270":2}}],["计算一个权重",{"1":{"210":1}}],["计算出canvas的大小",{"1":{"626":1}}],["计算出需要通知玩家消失的格子集合",{"1":{"103":1}}],["计算出当前的curaoi集合",{"1":{"103":1}}],["计算出移动前的oldaoi集合",{"1":{"103":1}}],["计算玩家正确的延迟",{"1":{"47":1}}],["计算",{"1":{"46":1,"270":1,"694":1,"695":1}}],["计算网络包的超时时间",{"1":{"12":1}}],["哪怕只是非常简单的层级结构和非常少量的",{"1":{"960":1}}],["哪怕你随后会做无数的修改",{"1":{"218":1}}],["哪些可見那些不可見",{"1":{"974":1}}],["哪些必须串行",{"1":{"916":1}}],["哪些不是",{"1":{"898":1}}],["哪些",{"1":{"687":1}}],["哪些类型的对象会阻挡",{"1":{"687":1}}],["哪些类型是不能够被剪裁掉的",{"1":{"603":1}}],["哪些还活着",{"1":{"114":1}}],["哪些内存需要gc回收",{"1":{"113":1}}],["引起会准备一些",{"1":{"940":1}}],["引擎会编译并排序整个",{"1":{"940":1}}],["引擎将",{"1":{"604":1}}],["引入一个叫buff原子状态的概念",{"1":{"800":1}}],["引入",{"1":{"573":1}}],["引入全局类库的方式",{"1":{"401":1}}],["引言",{"0":{"217":1}}],["引用是非常有用的",{"1":{"965":1}}],["引用呢",{"1":{"964":1}}],["引用变量已被重新分配",{"1":{"827":1}}],["引用类型测试",{"0":{"896":1}}],["引用类型传递",{"0":{"892":1}}],["引用类型永远存储在堆里",{"1":{"884":1}}],["引用类型",{"0":{"882":1},"1":{"880":1}}],["引用类型的示例包括对象",{"1":{"826":1}}],["引用类型需要继承system",{"1":{"707":1}}],["引用",{"1":{"826":1,"883":1,"965":1}}],["引用表包括程序集",{"1":{"131":1}}],["引用表",{"1":{"131":1}}],["引用4",{"1":{"126":1}}],["引用2",{"1":{"126":2}}],["引用计数会置零",{"1":{"930":1}}],["引用计数为1",{"1":{"124":1}}],["引用计数为2",{"1":{"124":1}}],["引用计数法的逻辑是",{"1":{"115":1}}],["引用计数法",{"0":{"115":1}}],["引用和去引用伴随加法和减法",{"1":{"115":1}}],["引用会被赋值而引用的对象则不会",{"1":{"111":1}}],["扩张完成后各资源占有量的均值与方差以及每位玩家潜在冲突势力的均值与方差",{"1":{"215":1}}],["扩展级和精英级三类",{"1":{"273":1}}],["扩展性",{"0":{"95":1}}],["扩展性是指当加入新的服务器后",{"1":{"91":1}}],["扩展阅读",{"0":{"81":1}}],["轮流从目前领土所毗邻的无人单元格中抽取一个进行占领以扩张势力范围",{"1":{"215":1}}],["岩石与资源单元格",{"1":{"214":1}}],["岩石与资源数量",{"1":{"214":1}}],["岩石与资源占比分别计算出每位玩家区应当分配到的植被",{"1":{"214":1}}],["岩石与矿产资源",{"1":{"214":1}}],["岩石比例与资源的比例等",{"1":{"214":1}}],["米切尔最佳候选算法是一种渐进",{"1":{"214":1}}],["米切尔最佳候选算法为了保证每位玩家两两之间的初始分布不会过近",{"1":{"214":1}}],["起到了渲染优化的目的",{"1":{"979":1}}],["起源",{"0":{"573":1}}],["起初都是每个人各项设施一点",{"1":{"375":1}}],["起伏不平的材质或者纹理",{"1":{"214":1}}],["起始状态",{"1":{"43":1}}],["植被比例",{"1":{"214":1}}],["盘古大陆",{"1":{"214":1}}],["战力4",{"1":{"295":1}}],["战略资源的分布采样出玩家的分布之后",{"1":{"214":1}}],["战略游戏地图的随机地图还要考虑到",{"1":{"213":1}}],["战略特征的平衡是指每一名玩家在一定时间内获得基本相同的资源",{"1":{"213":1}}],["战略特征是指玩家在游戏中可以利用的战略资源",{"1":{"213":1}}],["战略特征",{"1":{"213":1}}],["战争迷雾",{"1":{"212":1}}],["战斗结算中",{"1":{"811":1}}],["战斗界面等根据需要设置anchors中的全屏拉伸",{"1":{"628":1}}],["战斗属性",{"0":{"394":1},"2":{"395":1,"396":1}}],["战斗",{"0":{"377":1},"1":{"387":1}}],["战斗单位又引用了地图",{"1":{"124":1}}],["战斗是顺畅的",{"1":{"15":1}}],["搭建了一个多人回合制战略游戏",{"1":{"212":1}}],["卡坦岛",{"1":{"212":1}}],["英文简称sat",{"1":{"782":1}}],["英雄无敌",{"1":{"212":1}}],["英语",{"1":{"155":1}}],["受限于常量缓冲区在不同设备上的大小的上限",{"1":{"981":2}}],["受到任务场地空间的限制",{"1":{"382":1}}],["受其欺凌者不计其数",{"1":{"297":1}}],["受制规则",{"1":{"212":1}}],["受他控制",{"1":{"44":1}}],["交由web框架来处理",{"1":{"577":1}}],["交叉编译出不同操作系统下",{"1":{"510":2}}],["交叉轴的开始位置叫做",{"1":{"406":1}}],["交易时获得的金钱",{"1":{"368":1}}],["交互方式",{"1":{"212":1}}],["交集",{"0":{"180":1},"1":{"903":1}}],["建立一个类",{"1":{"599":1}}],["建立连接",{"1":{"577":1}}],["建立搜索树",{"1":{"210":1}}],["建造面积够宽",{"1":{"380":1}}],["建议在",{"1":{"1023":1}}],["建议在安装时把",{"1":{"533":1}}],["建议用脚本直接将此文件中所有float精度都调小",{"1":{"866":1}}],["建议用",{"1":{"862":1}}],["建议你关闭canvas组件",{"1":{"860":1}}],["建议新项目使用",{"1":{"721":1}}],["建议路径中不要包含空格",{"1":{"559":1}}],["建议第二种",{"1":{"524":1}}],["建议以原本设定支薪10就好",{"1":{"372":1}}],["建议对具有更高tickrate超的游戏服务器预留必要的cpu资源",{"1":{"86":1}}],["灰色点是本轮随机采样的候选点",{"1":{"214":1}}],["灰色的节点表示还没探索到",{"1":{"210":1}}],["灰色是一块半透明的玻璃板",{"1":{"0":1}}],["便是基於此緣故",{"1":{"975":1}}],["便在所有成员上一次性执行",{"1":{"958":1,"1001":1}}],["便不会向这片树枝搜索了",{"1":{"210":1}}],["便可以向前和向后遍历",{"1":{"105":1}}],["说道为什么会影响效率",{"1":{"876":1}}],["说穿了只是一个流程",{"0":{"810":1},"2":{"811":1}}],["说人话",{"1":{"283":1}}],["说明一下",{"1":{"976":1}}],["说明它连接这",{"1":{"965":1}}],["说明当前",{"1":{"693":1}}],["说明",{"1":{"244":1,"247":1,"287":2,"390":1,"391":1,"392":2,"395":1,"475":1,"1036":1}}],["说明我们的战略特征分配与朴素的随机生成的地图相比更加均衡",{"1":{"215":1}}],["说明走了一条错误的路径",{"1":{"210":1}}],["说起栈帧",{"1":{"131":1}}],["宽高比",{"1":{"841":1}}],["宽高比为2",{"1":{"618":1}}],["宽和高真正的計算方法是",{"1":{"644":1}}],["宽度也是总的瓦片id数",{"1":{"209":1}}],["宽带网络的出现有利于在线游戏开发",{"1":{"40":1}}],["负责发送输入事件",{"1":{"654":1}}],["负责接收",{"1":{"581":1}}],["负责静态资源发送",{"1":{"581":1}}],["负责管理一个进程池来处理来自",{"1":{"576":1}}],["负责进行丹药的生产炼制",{"1":{"380":1}}],["负责释放",{"1":{"165":1}}],["负向的约束",{"1":{"209":1}}],["负向",{"1":{"209":1}}],["获得完美游戏效果解析显卡垂直同步设置",{"1":{"854":2}}],["获得ugui会从射线检测到的gameobject开始",{"1":{"679":1}}],["获得了一张新的风符",{"1":{"296":1}}],["获得一只紫白配色的锦鲤",{"1":{"296":1}}],["获得一只红白配色的锦鲤",{"1":{"296":1}}],["获得约束矩阵",{"0":{"209":1}}],["获取数据用于显示",{"1":{"1031":1}}],["获取当前点击的物体",{"1":{"1024":1}}],["获取方式为chunk",{"1":{"991":1}}],["获取相应的数据worker",{"1":{"944":1}}],["获取的就是鼠标在屏幕中的位置坐标",{"1":{"841":1}}],["获取enemy到avatar的方向向量",{"1":{"771":1}}],["获取正方向向量",{"1":{"771":1}}],["获取avatar正方向的一个点与avatar世界坐标相减",{"1":{"771":1}}],["获取纹理相关的",{"1":{"726":1}}],["获取类型的过程",{"1":{"715":1}}],["获取类",{"1":{"714":1}}],["获取size",{"1":{"713":1}}],["获取",{"0":{"491":1},"1":{"947":1}}],["获取cdn域名以及ip地址",{"1":{"490":1,"491":1}}],["获取github地址",{"0":{"490":1}}],["获取更多关于服务器如何获取文化的信息",{"1":{"155":1}}],["获取中间语言生成器",{"1":{"111":1}}],["获取到链表中的一个节点",{"1":{"105":1}}],["获取帧结束时间",{"1":{"41":2}}],["获取帧开始时间",{"1":{"41":2}}],["获取处理服务器传过来的数据包",{"1":{"41":1}}],["显卡显示了10个数字而显示器只刷新了8次",{"1":{"854":1}}],["显卡以100fps循环显示0",{"1":{"854":1}}],["显卡已经将第2帧图像送了过来",{"1":{"854":1}}],["显卡刷新显示缓冲的速度比显示器快",{"1":{"854":1}}],["显卡无法在在显示器等待的1",{"1":{"854":1}}],["显卡无法绘制下一屏",{"1":{"854":1}}],["显卡就可以在显示器等待的1",{"1":{"854":1}}],["显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制",{"1":{"854":1}}],["显卡先从显示缓冲取数据刷新到显示器存储器上",{"1":{"854":1}}],["显示会有一点问题",{"1":{"1032":1}}],["显示帧",{"1":{"855":1}}],["显示一个无撕裂的画面",{"1":{"854":1}}],["显示器设定的刷新率是100hz",{"1":{"854":1}}],["显示器每画完一行发出一个水平同步信号",{"1":{"854":1}}],["显示器从左上到右下",{"1":{"854":1}}],["显示结果就有点不同了",{"1":{"841":1}}],["显示结果也一致",{"1":{"841":1}}],["显示简单的声明以及指定一个system",{"1":{"819":1}}],["显示的大小",{"1":{"624":1}}],["显示了自有的uwsgi协议的web服务器",{"1":{"580":1}}],["显示不出内容",{"1":{"531":1}}],["显示如下",{"1":{"504":1}}],["显示对话按钮",{"1":{"255":1}}],["显示",{"0":{"255":1}}],["显示服务器和客户端射击包围盒位置差异",{"1":{"85":1}}],["显然可以粘贴converttoentity",{"1":{"964":1}}],["显然无需回溯",{"1":{"954":1}}],["显然会影响程序性能",{"1":{"898":1}}],["显然这样做是很不合理的",{"1":{"707":1}}],["显然",{"1":{"208":1,"219":1,"898":1}}],["载入输入模型信息",{"1":{"208":1}}],["载入瓦片信息",{"1":{"208":1}}],["种植",{"0":{"347":1}}],["种植店",{"1":{"287":1}}],["种不同的房间类型",{"1":{"224":1}}],["种子购买价格",{"1":{"303":1}}],["种子",{"1":{"214":2,"287":1}}],["种类编号和瓦片的图片",{"1":{"208":1}}],["种方法对派生类都是有效的",{"1":{"111":1}}],["属于玩家信息",{"1":{"809":1}}],["属于这个",{"1":{"689":1}}],["属于editor包里的",{"1":{"601":1}}],["属于",{"1":{"207":1,"689":1}}],["属性名称的对应",{"1":{"858":2}}],["属性进行内部寻址",{"1":{"858":1}}],["属性的同步",{"0":{"809":1}}],["属性或方法",{"0":{"687":1}}],["属性将失效",{"1":{"405":1}}],["属性",{"0":{"384":1},"1":{"131":1,"270":1,"390":1,"391":1,"392":1,"393":1,"395":1,"687":1,"759":1,"952":1}}],["贴图来构成地图",{"1":{"207":1}}],["贴图模型合成技术的研究和应用已经有很多年的历史了",{"1":{"206":1}}],["物件去設計場景架構",{"1":{"978":1}}],["物體會維持目前的位置與大小",{"1":{"650":1}}],["物體自身的支點",{"1":{"639":1}}],["物理",{"1":{"394":1}}],["物理伤害减免xiv",{"1":{"384":1}}],["物理就够难了",{"1":{"206":1}}],["物资尽量平均卖",{"1":{"376":1}}],["物依稀为贵",{"1":{"301":1}}],["物等",{"1":{"270":1}}],["物品产出表",{"0":{"298":1},"2":{"299":1,"300":1,"301":1,"302":1,"303":1,"304":1,"305":1,"306":1,"307":1,"308":1,"309":1}}],["物品底材qlvl时",{"1":{"275":1}}],["物品的属性就在那一瞬间随机生成了",{"1":{"270":1}}],["物品的属性来源于物品所具有的词缀",{"1":{"270":1}}],["物品等级越高",{"1":{"269":1}}],["物品等级决定了装备的词缀",{"1":{"269":1}}],["物品等级最大的作用有两个",{"1":{"269":1}}],["物品等级最大99",{"1":{"269":1}}],["物品等级常用术语为ilvl",{"1":{"269":1}}],["物品等级",{"0":{"269":1}}],["物体如果都符合条件会优先参与静态批处理",{"1":{"980":1,"981":1}}],["物体不可移动",{"1":{"876":1}}],["物体运动速度过快时",{"1":{"753":1}}],["物体信息储存在hit中",{"1":{"750":1}}],["物体对象",{"1":{"684":1}}],["物体接下来",{"1":{"656":1}}],["物体",{"1":{"656":1,"1041":1}}],["物体移动和动画会看起来很诡异",{"1":{"83":1}}],["物体有时候会被服务器拉回",{"1":{"46":1}}],["物体看作一个点",{"1":{"46":1}}],["粒子的状态才能被确定",{"1":{"206":1}}],["波函数坍塌",{"0":{"206":1},"1":{"206":1,"207":1}}],["噪声对于最终叠加噪声的影响程度变小",{"1":{"204":1}}],["振幅是指返回值的幅度范围",{"1":{"204":1}}],["除此之外还有其它的一些优点",{"1":{"576":1}}],["除非主动申请选取disable",{"1":{"1004":1}}],["除非他们指向lightmap的同一部分",{"1":{"979":1,"980":1}}],["除非scene中有被禁用的对象",{"1":{"970":1}}],["除非显式调用",{"1":{"960":1}}],["除非使用",{"1":{"920":1}}],["除非它被频繁调用",{"1":{"828":1}}],["除非你显式指定",{"1":{"964":1}}],["除非你在子对象中使用",{"1":{"952":1}}],["除非你知道如何使用",{"1":{"942":1}}],["除非你想要支持很多性能跨度很大的设备",{"1":{"868":1}}],["除非你想給自己找麻煩",{"1":{"567":1}}],["除非你把它们分成一些小的凸多边形",{"1":{"788":1}}],["除非通过代码的方式更改",{"1":{"174":1}}],["除去刀劈剑砍之外",{"1":{"383":1}}],["除特殊产出",{"1":{"301":1}}],["除了entityguid",{"1":{"971":1}}],["除了上文的弹跳球这样的简单场景",{"1":{"945":1}}],["除了在lambda参数列表中找到所有组件类型之外",{"1":{"910":1}}],["除了单例",{"1":{"858":1}}],["除了游戏对象表面的基本颜色",{"1":{"844":1}}],["除了坐标系的转换",{"1":{"841":1}}],["除了继承",{"1":{"687":1}}],["除了获取eventhandler这种情形之外",{"1":{"680":1}}],["除了会将这个写命令的协议内容追加到现有的",{"1":{"455":1}}],["除了列表和集合之外",{"1":{"454":1}}],["除了",{"1":{"443":1,"509":1,"840":1}}],["除了卖钱别无他用",{"1":{"300":1}}],["除了以上两点对游戏平衡性的影响之外",{"1":{"213":1}}],["除了前面所讲的计算",{"1":{"204":1}}],["得知信息已经被更改了",{"1":{"992":1}}],["得不偿失",{"1":{"849":1}}],["得出",{"1":{"755":1}}],["得出了最终结果",{"1":{"203":1}}],["得施肥4",{"1":{"295":1}}],["得浇水3",{"1":{"295":1}}],["得到游戏世界中的点相对于截面p的位置",{"1":{"1025":1}}],["得到的值是4不是3是因为我们操作栈里两个指针并且它们指向堆里同一个对象",{"1":{"889":1}}],["得到的结果是完全可预测的",{"1":{"67":1}}],["得到一个确切的答案",{"1":{"768":1}}],["得到旋转后的圆心坐标值后",{"1":{"756":1}}],["得到以下内容",{"1":{"592":1}}],["得到",{"1":{"535":1}}],["得到休息后可恢复",{"1":{"391":1}}],["得到弥助大作太鼓",{"1":{"296":1}}],["得到这个空间的数据",{"1":{"220":1}}],["得到约束条件矩阵",{"1":{"208":1}}],["得到最新的结果",{"1":{"69":1}}],["得到正确的最新状态",{"1":{"14":1}}],["技术细节",{"0":{"813":1}}],["技巧来实现",{"1":{"202":1}}],["技能越多",{"1":{"811":1}}],["技能变成了只在概念讨论里才出现的词汇",{"1":{"811":1}}],["技能只在数据层和讨论的概念中出现",{"1":{"811":1}}],["技能只是负责技能的执行流程",{"1":{"799":1}}],["技能效果相应的数据应该仅限于这个技能释放条件和它的直接效果",{"1":{"810":1}}],["技能直接伤害等",{"1":{"806":1}}],["技能叶子节点enter",{"1":{"805":1}}],["技能根节点enter",{"1":{"805":1}}],["技能根据等级分为入门",{"1":{"248":1}}],["技能同步包括三类同步消息",{"1":{"805":1}}],["技能同步的原则",{"0":{"802":1}}],["技能系统",{"1":{"805":1}}],["技能执行流程的同步",{"0":{"803":1},"2":{"804":1}}],["技能结算包括创建法术场",{"1":{"806":1}}],["技能结算的同步",{"0":{"806":1},"2":{"807":1,"808":1}}],["技能结算等信息",{"1":{"805":1}}],["技能结算",{"1":{"803":1}}],["技能结算在服务端发起",{"1":{"802":1}}],["技能结束skill",{"1":{"793":1}}],["技能和法术场都可以对单位造成伤害",{"1":{"799":1}}],["技能创建相应的弹道和法术场",{"1":{"799":1}}],["技能方向不变",{"1":{"797":1}}],["技能方向可能需要一些配置",{"1":{"797":1}}],["技能的主流程由脚本实现",{"1":{"811":1}}],["技能的主流程",{"1":{"811":1}}],["技能的表象数据必须要有",{"1":{"810":1}}],["技能的表现包括动作",{"1":{"798":1}}],["技能的承载内容应该仅仅是这个流程本身",{"1":{"810":1}}],["技能的方向就是释法者到目标的方向",{"1":{"797":1}}],["技能的执行流程包括",{"1":{"796":1}}],["技能获得一个目标对象以后",{"1":{"797":1}}],["技能在释放法术场",{"1":{"797":1}}],["技能释放过程中",{"1":{"797":1}}],["技能释放时",{"1":{"797":1}}],["技能释放流程",{"0":{"235":1}}],["技能目标查找",{"0":{"797":1}}],["技能对应的特效以及人物动作可能还会继续播放",{"1":{"796":1}}],["技能真正的结算",{"1":{"802":1}}],["技能真正的结束",{"1":{"796":1}}],["技能真正的释放并结算",{"1":{"796":1}}],["技能播放到后摇点时间时",{"1":{"796":1}}],["技能后摇点",{"1":{"796":1}}],["技能前摇结束时技能开始真正的释放以及结算",{"1":{"796":1}}],["技能开始播放动作",{"1":{"803":2}}],["技能开始以后",{"1":{"796":1}}],["技能开始",{"1":{"796":1,"803":1}}],["技能开始skill",{"1":{"793":1}}],["技能模块的同步",{"1":{"795":1}}],["技能模块提供尽量少的接口供ai",{"1":{"793":1}}],["技能本身并不会有太复杂的控制结构",{"1":{"795":1}}],["技能就会一直执行",{"1":{"795":1}}],["技能树如何同步",{"1":{"805":1}}],["技能树管理以及技能流程管理",{"1":{"799":1}}],["技能树在使用后慢慢发现一些问题",{"1":{"795":1}}],["技能树的同步",{"0":{"805":1}}],["技能树的同步要求每个树节点都进行同步",{"1":{"795":1}}],["技能树的引入有以下好处",{"1":{"795":1}}],["技能树的重点并不是根据上下文选择一个合适的节点执行",{"1":{"795":1}}],["技能树没有tick的概念",{"1":{"795":1}}],["技能树和行为树在结构上比较类似",{"1":{"795":1}}],["技能树参考传统行为树的设计",{"1":{"795":1}}],["技能树",{"0":{"795":1}}],["技能树执行节点",{"1":{"794":1}}],["技能可以分成一个树形结构",{"1":{"794":1}}],["技能流程负责动作",{"1":{"803":1}}],["技能流程以authority为发起端",{"1":{"802":1}}],["技能流程",{"1":{"801":1}}],["技能流程这里分两点讨论",{"1":{"794":1}}],["技能流程管理",{"0":{"794":1},"2":{"795":1,"796":1,"797":1,"798":1,"799":1,"800":1,"801":1,"802":1,"803":1,"804":1,"805":1,"806":1,"807":1,"808":1,"809":1}}],["技能会被强制停止",{"1":{"793":1}}],["技能停止skill",{"1":{"793":1}}],["技能不再继续执行",{"1":{"793":1}}],["技能调用接口",{"0":{"793":1}}],["技能池管理都在这个模块",{"1":{"792":1}}],["技能加点",{"1":{"792":1}}],["技能信息管理",{"0":{"792":1}}],["技能标签",{"1":{"394":1}}],["技能经验+5",{"1":{"388":1}}],["技能书分为初级",{"1":{"251":1}}],["技能词条",{"0":{"248":1}}],["技能是否能够执行",{"1":{"241":1}}],["技能",{"0":{"234":1,"810":1},"1":{"97":1,"247":1,"809":1},"2":{"235":1,"236":1,"237":1,"238":1,"239":1,"240":1,"811":1}}],["令人十分愉悦",{"1":{"296":1}}],["令人费解",{"1":{"202":1}}],["令其新起一个线程慢慢地计算验证",{"1":{"15":1}}],["梯度函数",{"0":{"202":1}}],["梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的",{"1":{"197":1}}],["变成",{"1":{"1036":1}}],["变成了带有1",{"1":{"273":1}}],["变体不同的不同材质批处理中断情况位置不相邻且中间夹杂着",{"1":{"982":1}}],["变体不一样",{"1":{"982":1}}],["变体",{"1":{"982":1}}],["变羊等等等",{"1":{"800":1}}],["变量rec的作用域是大括号内",{"1":{"898":1}}],["变量result被放到了栈里",{"1":{"885":1}}],["变量的前一个内容都会变死",{"1":{"828":1}}],["变量类型为raycasthit",{"1":{"750":1}}],["变量",{"1":{"510":1}}],["变量将在后面的插值计算中使用到",{"1":{"200":1}}],["变化变慢",{"1":{"197":1}}],["正确的版本号刷新",{"1":{"997":1}}],["正确的公钥是在结尾会有一个空格加上你的",{"1":{"460":1}}],["正式发布",{"1":{"971":1}}],["正式安裝",{"0":{"569":1}}],["正常地实例化",{"1":{"969":1}}],["正常工作",{"1":{"960":1}}],["正常添加",{"1":{"959":1,"1002":1}}],["正儿八经的游戏要改成",{"1":{"945":1}}],["正文如下",{"1":{"782":1}}],["正方向上的投影",{"1":{"694":1}}],["正方向上的投影以及计算射线方向在",{"1":{"694":1}}],["正方向是否与默认正方向",{"1":{"693":1}}],["正方形节点表示选择点操作",{"1":{"210":1}}],["正向的就是由浏览器主动的想代理服务器发出请求",{"1":{"581":1}}],["正是和上述优化一模一样的玩意儿",{"1":{"955":1}}],["正是由于垂直同步的存在",{"1":{"854":1}}],["正是因为垂直同步的存在",{"1":{"854":1}}],["正是因此",{"1":{"383":1}}],["正是如此",{"1":{"535":1}}],["正义",{"1":{"391":1}}],["正殿是门派内一切设施建造的前提",{"1":{"380":1}}],["正殿",{"1":{"380":1}}],["正如预期的那样",{"1":{"819":1}}],["正如其名",{"1":{"759":1}}],["正如在这两种情况下",{"1":{"283":1}}],["正如上文所提",{"1":{"200":1}}],["正在视野中的符合要求的所有对象使用",{"1":{"981":1}}],["正在视野中",{"1":{"980":1}}],["正在播放那个武器动画",{"1":{"44":1}}],["正在使用的是哪一个",{"1":{"44":1}}],["特别注明这样query就会把没被修改的componenttype排除在外",{"1":{"994":1}}],["特别要注意一下半透明物体的渲染顺序是",{"1":{"976":1}}],["特别是通过反射等方式在编译时无法得知的函数调用",{"1":{"603":1}}],["特别是如果它们有单独的物理数据库",{"1":{"142":1}}],["特别是",{"1":{"79":1,"823":1}}],["特别是一群怪围着几个角色进行攻击时",{"1":{"19":1}}],["特殊引用类型string",{"0":{"898":1}}],["特殊人物的特性有些是鸡肋但是特殊人物学习力也是一般弟子望尘莫及的",{"1":{"378":1}}],["特殊动作",{"1":{"244":1}}],["特有特性是特殊人物才有的特性",{"1":{"378":1}}],["特效等",{"1":{"805":1}}],["特效以及技能结算",{"1":{"803":1}}],["特效比较复杂",{"1":{"798":1}}],["特效2",{"1":{"247":1}}],["特效1",{"1":{"247":1}}],["特效动作",{"0":{"246":1}}],["特效",{"0":{"231":1,"233":1,"245":1},"1":{"243":1,"798":1},"2":{"232":1,"233":1,"234":1,"235":1,"236":1,"237":1,"238":1,"239":1,"240":1,"246":1,"247":1,"248":1}}],["特性组件发生变化的实体",{"1":{"910":1}}],["特性",{"1":{"198":1}}],["瓦片重复",{"1":{"198":1}}],["搞清了算法的各个实现关键步骤后",{"1":{"197":1}}],["求得检测最大距离",{"1":{"684":1}}],["求得加权平均值",{"1":{"197":1}}],["求助",{"1":{"387":1}}],["求丹",{"1":{"295":1}}],["求出",{"1":{"199":1}}],["求出子问题的解",{"1":{"107":1}}],["预设体的实例会自动地使用相同的网格模型和材质",{"1":{"981":1}}],["预先编译",{"1":{"588":1}}],["预计",{"1":{"537":1}}],["预览书籍",{"0":{"506":1}}],["预定义的梯度表不是本文所说的这12个向量",{"1":{"197":1}}],["预测",{"0":{"1014":1},"1":{"1013":1}}],["预测是针对自己操作的角色",{"1":{"1013":1}}],["预测循环始终仅运行一次",{"1":{"1013":1}}],["预测不是发生在客户端的吗",{"1":{"1013":1}}],["预测只对本地玩家以及那些只收它影响的实体有效",{"1":{"84":1}}],["预测误差平滑处理可以通过设置cl",{"1":{"84":1}}],["预测误差校正可以是相当明显的",{"1":{"84":1}}],["预测完成后",{"1":{"84":1}}],["预测的位置将是非常错误的",{"1":{"75":1}}],["预测的过程中允许一定的延迟",{"1":{"50":1}}],["预测的过程中",{"1":{"43":1}}],["预测位置的过程被多次执行的时候要注意避免重声等不正确的效果",{"1":{"43":1}}],["预测了比较多的帧",{"1":{"15":1}}],["预测a执行攻击",{"1":{"15":1}}],["预测b不执行操作",{"1":{"15":1}}],["预测错误",{"1":{"15":1}}],["抽取小数点后2位",{"1":{"197":1}}],["必須先開啟控制面板的",{"1":{"639":1}}],["必不可缺",{"1":{"380":1}}],["必要建筑",{"1":{"287":1}}],["必要物品",{"1":{"287":1}}],["必定得到相同的输出",{"1":{"197":1}}],["必须在",{"1":{"1022":1}}],["必须要把自己包括在内",{"1":{"958":1,"1001":1}}],["必须要测试人员点击同意参加测试才行",{"1":{"610":1}}],["必须包含any中至少一个组件类型",{"1":{"915":1}}],["必须包含all中所有的组件类型",{"1":{"915":1}}],["必须使用名为",{"1":{"722":1}}],["必须手动添加程序集引用",{"1":{"722":1}}],["必须加上",{"1":{"405":1}}],["必须先留出4个小铜人",{"1":{"382":1}}],["必须根据clr公共语言运行时将其编译为目标计算机基础结构的本机代码",{"1":{"128":1}}],["必须显示调用操作系统的接口",{"1":{"127":1}}],["必须将",{"1":{"127":1}}],["必须x",{"1":{"106":1}}],["图里看不到",{"1":{"885":1}}],["图只是为了阐述原理而放的引用",{"1":{"885":1}}],["图集整理",{"0":{"861":1}}],["图集资源会被打进app包体里",{"1":{"704":1}}],["图01",{"1":{"854":1}}],["图像",{"1":{"846":1}}],["图形",{"1":{"770":1,"846":1}}],["图例",{"1":{"754":1,"759":1,"761":1}}],["图中对象2和4被认定为垃圾将被清理",{"1":{"898":1}}],["图中分布着所有我们在房子中需要保留东西",{"1":{"898":1}}],["图中把returnvalue作为此栈结构的开始只是为了解释栈原理",{"1":{"890":1}}],["图中的test",{"1":{"664":1}}],["图中绿色背景大小960",{"1":{"625":1}}],["图标",{"1":{"287":2}}],["图片尺寸为2的次幂时",{"1":{"861":1}}],["图片等",{"1":{"581":1}}],["图片有点拉垮",{"1":{"568":1}}],["图片宽高",{"1":{"287":1}}],["图片不清楚可以放大看首先判断类型是否都加载",{"1":{"131":1}}],["图书馆",{"1":{"254":1}}],["图7",{"1":{"204":1}}],["图6所有噪声的叠加结果很明显",{"1":{"204":1}}],["图6",{"1":{"204":1}}],["图5",{"1":{"197":1,"200":1}}],["图4",{"1":{"197":1}}],["图3",{"1":{"197":1}}],["图2通过以上的了解",{"1":{"854":1}}],["图2",{"1":{"197":1}}],["图1cs",{"1":{"854":1}}],["图1",{"1":{"197":1}}],["补偿",{"0":{"1018":1}}],["补集",{"0":{"179":1}}],["补充renderqueue",{"0":{"976":1}}],["补充",{"1":{"39":1}}],["去掉了",{"1":{"969":2}}],["去掉了converttoentity",{"1":{"969":1}}],["去掉不需要的graphic",{"1":{"860":1}}],["去整理内部的状态",{"1":{"936":1}}],["去不同的城市",{"0":{"351":1},"2":{"352":1,"353":1}}],["去除",{"0":{"178":1}}],["去色",{"0":{"2":1}}],["吕毅",{"1":{"176":1}}],["拿",{"1":{"948":1}}],["拿上一段",{"1":{"929":1}}],["拿上面的",{"1":{"176":1}}],["拿到x",{"1":{"105":1}}],["损失非常小",{"1":{"175":1}}],["��",{"1":{"175":5}}],["▲",{"1":{"175":1}}],["性能依然优异",{"1":{"941":1}}],["性能分析器会显示特定帧中分配的字节数",{"1":{"878":1}}],["性能分析器中",{"1":{"878":1}}],["性能优化技巧",{"1":{"864":1,"899":1}}],["性能要求比较高",{"1":{"759":1}}],["性能比前两者都要好",{"1":{"729":1}}],["性能跟直接调差别也不大嘛",{"1":{"175":1}}],["性能对比数据",{"0":{"175":1}}],["性质的monobehaviour",{"1":{"966":1}}],["性质",{"1":{"38":1}}],["命名空间中的任何方法",{"1":{"597":1}}],["命名相同",{"1":{"399":1}}],["命名实例",{"1":{"174":1}}],["命中值+2",{"1":{"392":6}}],["命中值",{"1":{"390":1}}],["命中率的范围",{"1":{"385":1}}],["命令行添加参数",{"1":{"1051":1}}],["命令等",{"1":{"876":1}}],["命令来安装",{"1":{"465":1}}],["命令来代替前面的四条命令",{"1":{"454":1}}],["命令在进行",{"1":{"456":1}}],["命令参数都会被传播到",{"1":{"444":1}}],["命令也算作参数",{"1":{"444":1}}],["命令例子",{"1":{"444":1}}],["命令的工作原理",{"1":{"455":1}}],["命令的",{"1":{"444":1}}],["命令的参数和命令的个数",{"1":{"452":1}}],["命令的参数以及命令的个数",{"1":{"452":1}}],["命令的参数个数等信息发送到",{"1":{"443":1}}],["命令的参数",{"1":{"443":1,"445":1}}],["命令的执行过程就是",{"1":{"43":1}}],["命令传播",{"0":{"444":1},"1":{"443":1}}],["命令是由",{"1":{"452":1}}],["命令是",{"1":{"443":1}}],["命令同步",{"0":{"443":1}}],["命令执行时间=当前服务器时间",{"1":{"85":1}}],["命令",{"0":{"5":1,"425":1},"1":{"63":1,"407":1,"452":2,"454":1,"505":1,"535":1}}],["外加一个你声明的",{"1":{"964":1}}],["外加对应的",{"1":{"941":1}}],["外接图形判别法",{"0":{"752":1},"2":{"753":1,"754":1,"755":1,"756":1,"757":1,"758":1,"759":1,"760":1,"761":1,"762":1,"763":1,"764":1,"765":1,"766":1,"767":1,"768":1,"769":1,"770":1}}],["外部模块对这个entity的引用没有改变",{"1":{"739":1}}],["外部的更改只对当次有效",{"1":{"173":1}}],["外包给别人吧",{"1":{"573":1}}],["外门弟子心情低于50",{"1":{"391":1}}],["外开个分舵了",{"1":{"373":1}}],["外练",{"1":{"372":1}}],["外道巢穴",{"0":{"297":1}}],["外推只会快照更新包连续丢失",{"1":{"83":1}}],["外推法的最大缺点是玩家的移动并不是完全弹道的",{"1":{"46":1}}],["外推法把其它玩家",{"1":{"46":1}}],["外推法和内插法",{"1":{"46":1}}],["理解",{"1":{"974":1}}],["理解为什么会这样",{"1":{"173":1}}],["理由同上",{"1":{"858":1}}],["理结果给客户端",{"1":{"573":1}}],["理论命中率",{"1":{"385":1}}],["理论上四种方式都可以实现无限延伸",{"1":{"733":1}}],["理论上",{"1":{"88":1}}],["却可以正常得到基于",{"1":{"959":1,"1002":1}}],["却可以分别通过ioptions<>",{"1":{"172":1}}],["却因场地没有空间而无法进入时",{"1":{"382":1}}],["却是很多人不知道",{"1":{"130":1}}],["看材質球",{"1":{"977":1}}],["看下面代码",{"1":{"896":1}}],["看下面的图解",{"1":{"896":1}}],["看下面的代码",{"1":{"891":1}}],["看下边的视频",{"1":{"737":1}}],["看上去有点复杂",{"1":{"842":1}}],["看情况使用",{"1":{"749":1}}],["看源码在entitas",{"1":{"744":1}}],["看一下track可以大概了解整个反射的执行过程",{"1":{"716":1}}],["看到",{"1":{"971":1}}],["看到的onpointdown是用事件链",{"1":{"681":1}}],["看到一只有灵力的纸鹤在到处飞舞",{"1":{"296":1}}],["看更多",{"1":{"657":1}}],["看两者是否为同一个gameobject",{"1":{"657":1}}],["看名字就知道",{"1":{"626":1}}],["看做归一化的数值",{"1":{"625":1}}],["看报错信息中使用的openssl文件",{"1":{"476":1}}],["看图",{"1":{"384":1}}],["看板就会自动开始使用",{"1":{"380":1}}],["看板",{"1":{"380":1}}],["看",{"1":{"374":1}}],["看蓝色条",{"1":{"373":1}}],["看起来像是",{"1":{"970":1}}],["看起来像",{"1":{"969":1}}],["看起来就像是spawnhere",{"1":{"966":1}}],["看起来就像下面这样",{"1":{"225":1}}],["看起来会不自然",{"1":{"197":1}}],["看看实现的具体细节",{"1":{"715":1}}],["看看关键的几个属性的设置",{"1":{"714":1}}],["看看对于c++编译器来说",{"1":{"595":1}}],["看看任务管理器有没有",{"1":{"563":1}}],["看看成立一个门派需要配置些怎样的家什",{"1":{"380":1}}],["看看是不是真的",{"1":{"296":1}}],["看看吧",{"1":{"175":1}}],["看看asp",{"1":{"170":1}}],["看个简单的例子",{"1":{"131":1}}],["协议",{"1":{"577":1}}],["协议实现",{"1":{"576":1}}],["协议文本生成之后",{"1":{"445":1}}],["协议解析及请求处理",{"0":{"167":1}}],["协议比",{"1":{"51":1}}],["及时你所使用的是子物体",{"1":{"841":1}}],["及旋转的角度",{"1":{"756":1}}],["及选择设备分辨率和设计分辨率的宽",{"1":{"628":2}}],["及其参数",{"1":{"443":1}}],["及",{"1":{"163":1}}],["浏览器",{"1":{"157":1}}],["西班牙",{"1":{"155":1}}],["西班牙语",{"1":{"155":1}}],["美术相关内容",{"1":{"945":1}}],["美国",{"1":{"155":1}}],["美景就破灭了",{"1":{"77":1}}],["决定相机被渲染的正确顺序",{"1":{"737":1}}],["决定将",{"1":{"455":1}}],["决定了ecs会将实体的components也就是数据存在什么地方",{"1":{"905":1}}],["决定了这个地图里是生成什么类型的怪物",{"1":{"292":1}}],["决定了该物品的最大出孔数",{"1":{"269":1}}],["决定如何通过",{"1":{"155":1}}],["决定的依据是用户的带宽",{"1":{"50":1}}],["指示在",{"1":{"971":1}}],["指示缺少程序集引用",{"1":{"722":1}}],["指针修复等",{"1":{"898":1}}],["指针占用在内存中的存储和其它的相同",{"1":{"883":1}}],["指针",{"0":{"883":1},"1":{"826":1,"880":1,"890":1,"898":1}}],["指的是凹多边形",{"1":{"788":1}}],["指向",{"1":{"762":1}}],["指定的对象生效",{"1":{"687":1}}],["指定的区域性信息将同时用于",{"1":{"153":1}}],["指明il2cpp",{"1":{"592":1}}],["指由ken",{"1":{"214":1}}],["指纹",{"1":{"201":1}}],["指令整合到你的",{"1":{"425":1}}],["指令用来填充一个区域是比较有效的做法",{"1":{"220":1}}],["指令包的时间戳",{"1":{"12":1}}],["指令",{"1":{"12":2,"880":1}}],["区分坐标系可以按上图方法",{"1":{"840":1}}],["区间之外时",{"1":{"726":1}}],["区间",{"1":{"726":1}}],["区域",{"1":{"297":1}}],["区域信息",{"1":{"153":1}}],["区别三种算法比较",{"1":{"121":1}}],["区别只在于",{"1":{"15":1}}],["查询componentversion",{"0":{"988":1},"2":{"989":1,"990":1,"991":1,"992":1,"993":1,"994":1,"995":1,"996":1,"997":1,"998":1}}],["查询时使用",{"1":{"952":1}}],["查询时可以指定下面三种类型",{"1":{"915":1}}],["查询",{"1":{"858":1,"955":1}}],["查询此buff持有的原子状态和单位身上已经有的原子状态之间的关系",{"1":{"800":1}}],["查询字符串",{"1":{"152":1}}],["查了一下发现是c",{"1":{"526":1}}],["查看其内部实现什么意思呢",{"1":{"991":1}}],["查看实时的游戏状态",{"1":{"971":1}}],["查看对游戏画面的影响",{"1":{"841":1}}],["查看有没有需要处理的输入信息",{"1":{"653":1}}],["查看哪里报错",{"1":{"613":1}}],["查看c盘使用情况",{"1":{"523":1}}],["查看c盘存储",{"0":{"523":1}}],["查看命令信息",{"1":{"424":1}}],["查看下你现在使用的credential",{"1":{"417":1}}],["查看从选中的墙延伸出去是否有足够的空间承载新的元素",{"1":{"220":1}}],["查看",{"1":{"202":1,"422":1,"535":1,"701":1,"1051":1}}],["查找已经被ghost同步过来的实体",{"1":{"1013":1}}],["查找翻译字符串",{"1":{"155":1}}],["查找周围",{"1":{"109":1}}],["查找周围玩家直接前后查找移动就可以了",{"1":{"108":1}}],["订阅原始实体的更改事件",{"1":{"142":1}}],["映射到现实逻辑",{"1":{"811":1}}],["映射",{"0":{"141":1}}],["迁移dbcontext中使用了identityuser",{"1":{"137":1}}],["完美地实现了",{"1":{"969":1}}],["完美解决上述问题",{"1":{"135":1}}],["完备",{"1":{"805":1}}],["完",{"1":{"769":1}}],["完整的文件内容应该是这样的",{"1":{"559":1}}],["完全正常工作",{"1":{"969":1}}],["完全是用来被其他系统获取",{"1":{"950":1}}],["完全是使用四個方向的間距來定義此物件的顯示區域",{"1":{"637":1}}],["完全精度和非半精度",{"1":{"570":1}}],["完全一样",{"1":{"452":1}}],["完全搬不幼",{"1":{"296":1}}],["完成向icomponentdata组件的转换",{"1":{"1054":1}}],["完成环境迁移",{"0":{"481":1}}],["完成第",{"1":{"452":1}}],["完成得越快",{"1":{"451":1}}],["完成阶段",{"1":{"242":1}}],["完成垃圾回收",{"1":{"120":1}}],["完成了一记漂亮的爆头你的敌人可能是唯一不完全开心的哪个",{"1":{"79":1}}],["项目打包",{"1":{"979":1}}],["项目的根assets目录中创建名为",{"1":{"722":1}}],["项目的构建流程是在项目",{"1":{"510":1}}],["项目时",{"1":{"722":1}}],["项目用",{"1":{"510":1}}],["项目默认沿主轴排列",{"1":{"406":1}}],["项目名称为",{"1":{"166":1}}],["项目下执行项目dothass",{"1":{"133":1}}],["项目",{"1":{"132":1,"406":2}}],["项目和解决方案",{"1":{"125":1}}],["替换场景中的monobehavior",{"0":{"1049":1}}],["替换为可能缺少引用的任何包含的程序集",{"1":{"722":1}}],["替换完成后注意保存",{"1":{"569":1}}],["替换前替换所有的",{"1":{"569":1}}],["替换成为",{"1":{"476":1}}],["替换mysql",{"1":{"132":1}}],["替换数据库为mysql",{"0":{"132":1}}],["虚函数也一样",{"1":{"131":1}}],["虚拟地图编辑器",{"1":{"217":1}}],["虚拟机环境下",{"1":{"510":1}}],["虚拟机",{"1":{"116":1}}],["虚拟机栈和本地方法栈三个区域是线程私有的",{"1":{"113":1}}],["虚拟节点机制",{"1":{"96":1}}],["虚拟节点",{"0":{"96":1}}],["凡是包含的对象都认为还有引用",{"1":{"131":1}}],["寄存器",{"1":{"131":1}}],["寄存器中的变量在java中",{"1":{"116":1}}],["确保内存安全",{"0":{"1023":1}}],["确保你所使用的账号是在测试人员里",{"1":{"610":1}}],["确保所有的bug已经正确的修正了",{"1":{"594":1}}],["确保插件在打包的时候",{"1":{"537":1}}],["确保类型安全且元数据正确",{"1":{"131":1}}],["确切的次数跟你地牢的尺寸以及其它参数有关",{"1":{"220":1}}],["确定瓦片在瓦片地图上的外观",{"1":{"1031":1}}],["确定",{"1":{"1022":1}}],["确定技能如何表现",{"1":{"791":1}}],["确定了物品的底材后",{"1":{"275":1}}],["确定了输入坐标在单元正方形里的空间位置",{"1":{"199":1}}],["确定要修建某种新元素",{"1":{"220":1}}],["确定值",{"1":{"201":1}}],["确实",{"1":{"131":1}}],["找引用的对象",{"1":{"131":1}}],["找到堆里所有主程序不会访问到的对象并删除它们",{"1":{"887":1}}],["找到满足这次修改条件的group",{"1":{"738":1}}],["找到被射线穿过的graphic获得射线所穿过的graphic",{"1":{"676":1}}],["找到",{"1":{"559":1}}],["找到idea安装目录",{"1":{"559":1}}],["找到里面的几个配置文件进行修改",{"1":{"556":1}}],["找到报错的文件",{"1":{"476":1}}],["找到通路之后",{"1":{"224":1}}],["找到剩余所有没有瓦片的点",{"1":{"210":1}}],["找到所有由某个实体",{"1":{"936":1}}],["找到所有的点",{"1":{"210":1}}],["找到所有可访问的对象",{"1":{"118":1}}],["找到后看是否有存根标识",{"1":{"131":1}}],["找到子弹打出时那一刻的世界状态",{"1":{"59":1}}],["找到包含目标时间的记录区间",{"1":{"46":1}}],["事物总是不",{"1":{"573":1}}],["事先声明",{"1":{"197":1}}],["事件",{"0":{"743":1},"2":{"744":1,"745":1}}],["事件触发机制总结",{"0":{"681":1}}],["事件链",{"0":{"680":1}}],["事件才能正确回调",{"1":{"664":1}}],["事件和handler的连接触发方式对于某些ui组件",{"1":{"657":1}}],["事件透传如果事件被接收后",{"1":{"657":1}}],["事件接口实现脚本",{"1":{"664":1}}],["事件接口",{"1":{"657":1}}],["事件必须由touch或pointer碰撞触发",{"1":{"653":1}}],["事件总线",{"1":{"142":1}}],["事件的定义",{"1":{"131":1}}],["事实上编辑器里之所以可以选中是因为",{"1":{"943":1}}],["事实上这一过程也常常使人放松",{"1":{"940":1}}],["事实上",{"1":{"131":1,"885":1,"929":1,"942":1,"965":1}}],["字节",{"1":{"943":1}}],["字节序",{"1":{"167":1}}],["字节序问题不是指多个字节传输的先后",{"1":{"39":1}}],["字节序问题之存在于需要使用两个字节以上来表示整数",{"1":{"39":1}}],["字节序转换函数会根据当前平台的存储模式做出相应正确的转换",{"1":{"36":1}}],["字典和枚举",{"0":{"822":1}}],["字符串和数组",{"1":{"826":1}}],["字符串和数组要大得多",{"1":{"826":1}}],["字符串对象",{"1":{"444":2}}],["字符串",{"1":{"214":1,"454":1}}],["字段而不是",{"1":{"969":1}}],["字段必须定义为",{"1":{"967":1}}],["字段来引用它们",{"1":{"964":1}}],["字段用来表示",{"1":{"952":1}}],["字段里",{"1":{"910":1}}],["字段的副本",{"1":{"142":1}}],["字段添加到你自己的表中",{"1":{"142":1}}],["字段",{"1":{"131":1}}],["清理对象2",{"1":{"898":1}}],["清空文件内容即可",{"1":{"421":1}}],["清单表主要是程序集",{"1":{"131":1}}],["清单表组成",{"1":{"131":1}}],["清除阶段",{"1":{"118":1}}],["清除",{"1":{"118":1,"800":1}}],["清除算法或是标记",{"1":{"122":1}}],["清除算法>复制算法",{"1":{"121":1}}],["清除算法​",{"1":{"121":1}}],["清除算法当中",{"1":{"119":1}}],["清除算法是一模一样的",{"1":{"119":1}}],["清除算法的基础上做了一些优化",{"1":{"119":1}}],["清除算法",{"0":{"118":1},"1":{"121":1}}],["验证代码类型安全",{"1":{"131":1}}],["验证服务器和无逻辑的客户端老系统也会有自相矛盾的情况",{"1":{"48":1}}],["托管堆之外的终止化队列finalization",{"1":{"898":1}}],["托管堆中的对象1",{"1":{"898":1}}],["托管堆里任何被cpu内存地址指向的对象都需要被保留",{"1":{"898":1}}],["托管堆可能也找不到足够大的连续内存块来满足该分配需求",{"1":{"857":1}}],["托管堆的核心问题是其扩张是以两倍进行的",{"1":{"814":1}}],["托管堆的关键问题",{"0":{"814":1}}],["托管堆扩大的具体大小由平台决定",{"1":{"813":1}}],["托管堆是内存中被项目脚本运行时",{"1":{"813":1}}],["托管堆怎样运行以及为什么它会扩张",{"0":{"813":1}}],["托管堆内存",{"1":{"131":1}}],["托管代码剥离",{"0":{"603":1},"2":{"604":1,"605":1,"606":1}}],["托管代码直接编译成目标计算机的机械码",{"1":{"127":1}}],["函数中",{"1":{"841":1}}],["函数会对指定的纹理的参数进行设置",{"1":{"726":1}}],["函数会被调用",{"1":{"443":1}}],["函数执行时",{"1":{"456":1}}],["函数被调用时",{"1":{"449":1}}],["函数时",{"1":{"449":1}}],["函数都会被调用",{"1":{"446":1}}],["函数或者",{"1":{"443":1}}],["函数的第一个参数",{"1":{"202":1}}],["函数的作用在于计算随机选取的梯度向量以及顶点位置向量的点积",{"1":{"202":1}}],["函数的数学表示",{"1":{"200":1}}],["函数写法过于复杂",{"1":{"202":1}}],["函数可以简化成单纯将输入值增加1",{"1":{"201":1}}],["函数用于将输入值增加1",{"1":{"201":1}}],["函数接收",{"1":{"197":1}}],["函数",{"1":{"131":2,"227":1,"444":1,"446":1,"448":1,"476":1,"950":1}}],["详细请阅读",{"1":{"981":1}}],["详细解答+悟性",{"1":{"295":1}}],["详细可以参考winnt",{"1":{"131":1}}],["详细说明如下",{"1":{"17":1}}],["微软dns服务器",{"0":{"528":1}}],["微软特有的git",{"0":{"414":1},"2":{"415":1,"416":1,"417":1}}],["微软还附带了一个工具",{"1":{"130":1}}],["微服务架构应用",{"1":{"88":1}}],["全部已分配的内存",{"1":{"878":1}}],["全部编译成本地代码",{"1":{"130":1}}],["全文搜索cleanup将所有",{"1":{"476":1}}],["全局",{"1":{"898":1}}],["全局类库",{"0":{"399":1},"1":{"397":1}}],["全局变量2",{"1":{"116":1}}],["全身穿封印",{"1":{"377":1}}],["全奇遇事件选择及奖励",{"1":{"296":1}}],["全体加血",{"1":{"245":1}}],["全称common",{"1":{"131":1}}],["全称是即时编译器",{"1":{"130":1}}],["若採用",{"1":{"978":1}}],["若游戏的实际显示帧速小于60",{"1":{"854":1}}],["若显示器刷新率是75",{"1":{"854":1}}],["若这种需求较少",{"1":{"807":1}}],["若前摇时间短",{"1":{"804":1}}],["若成功的拉过来",{"1":{"795":1}}],["若和目标的距离很近",{"1":{"795":1}}],["若技能不循环进行",{"1":{"793":1}}],["若每个周期都需要对全部物体进行两两判断",{"1":{"766":1}}],["若在某一角度光源下",{"1":{"761":1}}],["若在当前节点绑定的一系列的组件中都未能成功唤起检测",{"1":{"691":1}}],["若对整个",{"1":{"759":1}}],["若存在非透明像素",{"1":{"759":1}}],["若小于则为碰撞",{"1":{"754":1,"755":1}}],["若",{"1":{"691":1}}],["若是",{"1":{"691":1}}],["若要使用这些",{"1":{"722":1}}],["若要解决这些问题",{"1":{"604":1}}],["若要允许生成的代码跨应用程序的多个调用或跨共享一组程序集的多个进程进行共享",{"1":{"130":1}}],["若未安装",{"1":{"535":1}}],["若联网的玩家有一个网速慢了",{"1":{"12":1}}],["跟shader中pass的数量有关",{"1":{"877":1}}],["跟踪看maptype",{"1":{"714":1}}],["跟踪loadedtypes",{"1":{"714":1}}],["跟随源代码做一个详细的跟踪",{"1":{"711":1}}],["跟",{"1":{"633":1}}],["跟泛型实例一样",{"1":{"600":1}}],["跟丟了纸鹤",{"1":{"296":1}}],["跟着笛声在庭院里跳一支舞",{"1":{"296":1}}],["跟上去看看",{"1":{"296":1}}],["跟前面做法一样",{"1":{"221":1}}],["跟visual",{"1":{"127":1}}],["跟linux上的crontab指令相似",{"1":{"30":1}}],["连锁地禁用",{"1":{"965":1}}],["连线到前一个物体",{"1":{"760":1}}],["连接",{"1":{"965":1}}],["连接两个点形成线段",{"1":{"751":1}}],["连接登录成功后",{"1":{"463":1}}],["连接这些房间",{"1":{"224":1}}],["连接了一个在纽约的服务器",{"1":{"64":1}}],["连那些依然残存在你的硬盘中",{"1":{"127":1}}],["非透明物件排序演算法",{"1":{"975":1}}],["非压缩",{"1":{"857":1}}],["非压缩意味着内存中的对象不会重新移动位置来使对象间的空隙关闭",{"1":{"813":1}}],["非分代",{"1":{"857":1}}],["非世代意味着当执行一次收集的时候",{"1":{"813":1}}],["非填满整个矩形",{"1":{"753":1}}],["非gac的assembly依然会加载到被使用的appdomain中",{"1":{"707":1}}],["非常多了",{"1":{"960":1}}],["非常重要",{"1":{"841":1}}],["非常适合用作备份",{"1":{"441":1}}],["非常类似",{"1":{"130":1}}],["非线性的插值函数",{"1":{"197":1}}],["非托管程序会通过com接口来获取操作系统服务",{"1":{"127":1}}],["非托管代码不能享受一些运行库所提供的服务",{"1":{"127":1}}],["非托管代码就是在visual",{"1":{"127":1}}],["非托管代码",{"1":{"127":1}}],["非玩家物体完全由服务器控制其状态",{"1":{"41":1}}],["容量的",{"1":{"961":1}}],["容量也不用太担心了",{"1":{"960":1}}],["容积变小的原因",{"1":{"960":1}}],["容器连接了绘制的内容和其他编辑的内容",{"1":{"943":1}}],["容器类型",{"1":{"937":1}}],["容器类暴露了一个clear函数",{"1":{"817":1}}],["容器时尤其好用",{"1":{"817":1}}],["容器和数组重用",{"0":{"817":1}}],["容器默认存在两根轴",{"1":{"406":1}}],["容器",{"1":{"406":2}}],["容易理解",{"1":{"176":1}}],["容纳",{"1":{"127":1}}],["容错性",{"0":{"94":1}}],["容错性和扩展性",{"0":{"93":1},"2":{"94":1,"95":1}}],["容错性是指当系统中的某个服务出现问题时",{"1":{"91":1}}],["控制台中的错误内容将显示内存",{"1":{"1021":1}}],["控制被传递到jit编译过的方法里",{"1":{"890":1}}],["控制",{"1":{"885":1}}],["控制节点",{"1":{"795":1}}],["控制节点往往存储更多的控制信息来控制子节点的执行流程",{"1":{"795":1}}],["控制当地",{"1":{"380":1}}],["控制流",{"1":{"127":1}}],["控制着当前地图中所有怪物的移动状态",{"1":{"17":1}}],["初始自由分配点60",{"1":{"390":1}}],["初始属性",{"0":{"390":1}}],["初始变化慢",{"1":{"197":1}}],["初始化player添加一些其他不需要同步的组件",{"1":{"1013":1}}],["初始化并填充addressables",{"1":{"900":1}}],["初始化的时间",{"1":{"868":1}}],["初始化的时候加载",{"1":{"260":1}}],["初始化heap中的table后",{"1":{"713":1}}],["初始化inputmoduleunity自己提供的各种inputmodule在eventsystem的update当中就会分别调用这些inputmoduleeventsystem主循环首先tick所有的输入模块",{"1":{"668":1}}],["初始化执行环境",{"1":{"575":1}}],["初始化篇章",{"0":{"505":1}}],["初始化gitbook",{"0":{"503":1},"1":{"503":1}}],["初始化项目",{"0":{"133":1}}],["初始化和调用对象方法的说明",{"1":{"127":1}}],["初学者会发现这个框架有3个主要的面向消费者的接口",{"1":{"171":1}}],["初中的几何计算而已",{"1":{"103":1}}],["且没有为它们添加",{"1":{"961":1}}],["且其中有些对象仅仅是用来组织结构的空对象",{"1":{"952":1}}],["且其中一个使用的是透视",{"1":{"620":1}}],["且entity",{"1":{"942":1}}],["且在启动时会全部加载",{"1":{"873":1}}],["且在每一帧对entity进行频繁修改的时候",{"1":{"738":1}}],["且该交点满足一定条件",{"1":{"760":1}}],["且均不允许旋转",{"1":{"753":1}}],["且满足对于的参数条件",{"1":{"715":1}}],["且它们直接是相互隔离的",{"1":{"707":1}}],["且设置了",{"1":{"691":1}}],["且要经常登录微软账号",{"1":{"528":1}}],["且如果自己的状态曾经为",{"1":{"277":1}}],["且如果根节点返回的是成功或者失败",{"1":{"277":1}}],["且具有3倍耐久度",{"1":{"275":1}}],["且装备的打造问题",{"1":{"250":1}}],["且有计算公式",{"1":{"236":1}}],["且",{"1":{"207":1,"756":1,"914":1}}],["且可以有效地转换为本机代码的说明",{"1":{"127":1}}],["且按照内存地址次序依次排列",{"1":{"119":1}}],["文档",{"1":{"502":1,"536":1,"604":2,"652":1}}],["文明",{"1":{"212":1}}],["文件上",{"1":{"964":1}}],["文件上分析前面执行的四条命令",{"1":{"454":1}}],["文件后",{"1":{"940":1}}],["文件到项目中",{"1":{"604":1}}],["文件返回给浏览器",{"1":{"573":1}}],["文件这么大的吗",{"1":{"535":1}}],["文件引用",{"1":{"525":1}}],["文件夹",{"1":{"556":1}}],["文件夹中再次执行",{"1":{"505":1}}],["文件夹下执行以下命令",{"1":{"503":1}}],["文件通过保存所有修改数据库的命令来记录数据库的状态",{"1":{"457":1}}],["文件通过同步",{"1":{"453":1}}],["文件大小比最后一次",{"1":{"456":1}}],["文件大小和最后一次",{"1":{"456":1}}],["文件大小大于",{"1":{"456":1}}],["文件大小的变量",{"1":{"456":2}}],["文件和数据库三者的状态就完全一致了",{"1":{"455":1}}],["文件和原有",{"1":{"453":1}}],["文件之外",{"1":{"455":1}}],["文件进行解压",{"1":{"535":1}}],["文件进行改名",{"1":{"455":1}}],["文件进行任何写入和读取",{"1":{"454":1}}],["文件进行重写",{"1":{"453":1}}],["文件来代替原有的",{"1":{"453":1}}],["文件就需要保存四条命令",{"1":{"453":1}}],["文件会变得越来越大",{"1":{"453":1}}],["文件时",{"1":{"452":1}}],["文件所保存的数据库就会被完整地还原出来",{"1":{"452":1}}],["文件并还原数据库的详细步骤如下",{"1":{"452":1}}],["文件里的协议",{"1":{"452":1}}],["文件保存的数据库状态完全一样",{"1":{"453":1}}],["文件保存了",{"1":{"452":1}}],["文件保存到磁盘中",{"1":{"446":1}}],["文件触发",{"1":{"451":1}}],["文件的交替",{"1":{"455":1}}],["文件的任务",{"1":{"455":1}}],["文件的体积",{"1":{"453":1}}],["文件的体积小于等于原有",{"1":{"453":1}}],["文件的体积就会急速膨胀",{"1":{"453":1}}],["文件的内容",{"1":{"452":1}}],["文件的读取和数据还原",{"0":{"452":1}}],["文件的协议文本",{"1":{"445":1}}],["文件的整个过程可以分为三个阶段",{"1":{"443":1}}],["文件末尾",{"1":{"443":1}}],["文件写入和保存",{"0":{"446":1},"1":{"443":1}}],["文件使用网络通讯协议的格式来保存这些命令",{"1":{"443":1}}],["文件路径",{"1":{"421":1,"432":1}}],["文件类型",{"1":{"131":1}}],["文件创建日期",{"1":{"131":1}}],["文件是windows下可执行文件的总称",{"1":{"131":1}}],["文件中加入以下内容",{"1":{"537":1}}],["文件中描述的目录和文件",{"1":{"505":1}}],["文件中的所有命令都以",{"1":{"457":1}}],["文件中的所有命令执行完毕",{"1":{"452":1}}],["文件中的数据不一致",{"1":{"455":1}}],["文件中就实际保存如下",{"1":{"443":1}}],["文件中所有",{"1":{"129":1}}],["文件中元数据的存在以及",{"1":{"127":1}}],["文件中",{"1":{"127":1,"443":1,"455":2}}],["文件",{"1":{"125":1,"131":1,"155":1,"438":1,"443":1,"446":1,"452":1,"453":1,"455":2,"457":1,"504":1,"510":1,"524":1,"535":1,"559":1,"586":1,"722":1,"964":2}}],["文章并不是完全的实现热更新",{"1":{"708":1}}],["文章作者",{"1":{"217":1}}],["文章的最后描述了一个叫做延迟补偿的机制",{"1":{"40":1}}],["文章中",{"1":{"15":1}}],["文章和",{"1":{"15":1}}],["编码时",{"1":{"820":1}}],["编码单元的顺序是由编码方案指定的",{"1":{"39":1}}],["编写",{"1":{"604":1}}],["编写gitbook",{"0":{"501":1},"2":{"502":1,"503":1,"504":1,"505":1,"506":1}}],["编辑模式",{"1":{"971":1}}],["编辑操作",{"1":{"946":1}}],["编辑工作流程",{"1":{"737":1}}],["编辑器窗口里也无法选中它",{"1":{"943":1}}],["编辑器按下",{"1":{"835":1}}],["编辑器中调试代码",{"1":{"835":1}}],["编辑器调试无响应问题",{"0":{"835":1},"2":{"836":1,"837":1}}],["编辑器安装的",{"1":{"722":1}}],["编辑器",{"1":{"505":1,"722":1}}],["编辑",{"1":{"504":1,"569":1}}],["编号41组按等级加法力",{"1":{"270":1}}],["编号44组",{"1":{"270":1}}],["编号4组忽略目标防御",{"1":{"270":1}}],["编号30组减需求",{"1":{"270":1}}],["编号31组加力量",{"1":{"270":1}}],["编号39组永不磨损",{"1":{"270":1}}],["编号39组投掷物恢复数量",{"1":{"270":1}}],["编号37组装备自动修复",{"1":{"270":1}}],["编号35组加快速奔跑",{"1":{"270":1}}],["编号6组反弹伤害",{"1":{"270":1}}],["编号8组加格挡",{"1":{"270":1}}],["编号9组加施法速度",{"1":{"270":1}}],["编号7组加攻击速度",{"1":{"270":1}}],["编号26组加生命",{"1":{"270":1}}],["编号23组加能量",{"1":{"270":1}}],["编号29组减少中毒时间",{"1":{"270":1}}],["编号2组魔法伤害减少",{"1":{"270":1}}],["编号25组同时加照亮范围和准确",{"1":{"270":1}}],["编号22组加mf",{"1":{"270":1}}],["编号21组加额外金币",{"1":{"270":1}}],["编号20组阻止怪物",{"1":{"270":1}}],["编号24组",{"1":{"270":1}}],["编号28组偷取法力",{"1":{"270":1}}],["编号27组偷取生命",{"1":{"270":1}}],["编号19组自动恢复生命",{"1":{"270":1}}],["编号17组加敏捷",{"1":{"270":1}}],["编号18组加快速打击恢复",{"1":{"270":1}}],["编号1组物理伤害减少",{"1":{"270":1}}],["编号16组加毒伤害",{"1":{"270":1}}],["编号15组加最小伤害值",{"1":{"270":1}}],["编号10组加冰伤害",{"1":{"270":1}}],["编号109组按百分比加耐力",{"1":{"270":1}}],["编号108组加耐力",{"1":{"270":1}}],["编号101组加防御",{"1":{"270":1}}],["编号107组所受伤害转为法力",{"1":{"270":1}}],["编号105组增强伤害",{"1":{"270":1}}],["编号12组加火伤害",{"1":{"270":1}}],["编号125小组",{"1":{"270":1}}],["编号122组增加凹槽",{"1":{"270":1}}],["编号120组加抗毒",{"1":{"270":1}}],["编号121组杀死敌人加法力",{"1":{"270":1}}],["编号123组加对恶魔的准确和伤害",{"1":{"270":1}}],["编号14组加最大伤害值",{"1":{"270":1}}],["编号141组增加投掷物数量",{"1":{"270":1}}],["编号140组加毒伤害",{"1":{"270":1}}],["编号142组加对不死的准确和伤害",{"1":{"270":1}}],["编号13组加电伤害",{"1":{"270":1}}],["编号139组加电伤害",{"1":{"270":1}}],["编号138组加火伤害",{"1":{"270":1}}],["编号137组加冰伤害",{"1":{"270":1}}],["编号11组冰冻时间减半",{"1":{"270":1}}],["编号115组加法力",{"1":{"270":1}}],["编号116组加全抗",{"1":{"270":1}}],["编号119组加抗电",{"1":{"270":1}}],["编号118组加抗火",{"1":{"270":1}}],["编号117组加抗冰",{"1":{"270":1}}],["编号112组加照亮范围",{"1":{"270":1}}],["编号114组加mf",{"1":{"270":1}}],["编号113组吓跑怪物",{"1":{"270":1}}],["编号111组同时加准确和伤害",{"1":{"270":1}}],["编号110组加准确率",{"1":{"270":1}}],["编译修改的文件并重新加载",{"0":{"1048":1}}],["编译剩余script",{"1":{"839":1}}],["编译项目中所有剩余的runtime",{"1":{"839":1}}],["编译以上三个文件夹中editor文件夹下的script",{"1":{"839":1}}],["编译standard",{"1":{"839":1}}],["编译速度优化",{"0":{"605":1}}],["编译出来",{"1":{"510":1}}],["编译的方法的后续调用会直接转到本机代码",{"1":{"129":1}}],["编译将执行期间可能永远不会调用的某些代码的可能性考虑在内",{"1":{"129":1}}],["编译并可在具有不同计算机基础结构的不同计算机上运行",{"1":{"129":1}}],["编译在应用程序运行时按需将",{"1":{"129":1}}],["编译和运行",{"1":{"127":1}}],["编译为本机代码",{"0":{"128":1},"2":{"129":1,"130":1}}],["编译为托管代码时",{"1":{"127":1}}],["编译为",{"0":{"127":1}}],["编译器有了重大升级",{"1":{"823":1}}],["编译器运行时",{"1":{"823":1}}],["编译器生成的",{"1":{"864":1}}],["编译器生成的il构造了一个通用的值类型枚举器以迭代值类型的容器",{"1":{"823":1}}],["编译器生成的代码会绑定到触发编译的进程上",{"1":{"130":1}}],["编译器中",{"1":{"823":1}}],["编译器无法检测到需要为该类型或方法生成代码",{"1":{"598":1}}],["编译器会提示",{"1":{"401":1}}],["编译器的操作",{"1":{"130":1}}],["编译器执行的操作",{"1":{"130":1}}],["编译器将报错",{"1":{"722":1}}],["编译器将程序集的",{"1":{"130":1}}],["编译器将源代码转换为",{"1":{"127":1}}],["编译器编译",{"0":{"129":1}}],["编译器针对4",{"1":{"126":1}}],["编译器以2",{"1":{"126":1}}],["编译器被认为是c",{"1":{"126":1}}],["编译器",{"0":{"125":1},"1":{"125":1,"127":2,"128":1,"129":2},"2":{"126":1,"127":1,"128":1,"129":1,"130":1}}],["强制让某个事件发生在某个handler上",{"1":{"657":1}}],["强盗王",{"0":{"333":1},"2":{"334":1}}],["强力打击增加造成的伤害并震退敌人",{"1":{"247":1}}],["强引用",{"1":{"124":1}}],["强迫每个用户都以固定速度更新",{"1":{"46":1}}],["往其子结点进行遍历",{"1":{"124":1}}],["地面和角色形成视差",{"1":{"620":1}}],["地面和角色不是用一个相机",{"1":{"620":1}}],["地面砖块的不同",{"1":{"287":1}}],["地块应该有一些标记",{"1":{"301":1}}],["地形",{"1":{"287":1}}],["地牢的地图种类",{"1":{"292":1}}],["地牢有很多种美术不同的地图",{"1":{"292":1}}],["地牢",{"1":{"287":1}}],["地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍",{"1":{"758":1}}],["地图中参与检测的对象都存储着自身所在格子的坐标",{"1":{"758":1}}],["地图格子划分",{"0":{"758":1}}],["地图难度越高",{"1":{"293":1}}],["地图外",{"1":{"254":2}}],["地图内",{"1":{"254":2}}],["地图内传话",{"1":{"254":1}}],["地图内找寻物品",{"1":{"254":1}}],["地图算法的文章",{"1":{"217":1}}],["地图的两边是各自的城门",{"1":{"287":1}}],["地图的类型",{"1":{"214":1}}],["地图的生成过程",{"0":{"214":1}}],["地图的美观性",{"1":{"213":1}}],["地图的平衡性指标",{"0":{"213":1}}],["地图开始被",{"1":{"212":1}}],["地图引用了战斗单位",{"1":{"124":1}}],["地址空间",{"1":{"814":1}}],["地址好记",{"1":{"529":1}}],["地址由小向大增加",{"1":{"32":1}}],["地址",{"1":{"15":1,"697":1,"699":1}}],["集合的状态",{"1":{"454":1}}],["集成的是开源项目boehm",{"1":{"123":1}}],["集群至少要6台",{"1":{"91":1}}],["长方形范围攻击检测",{"0":{"772":1}}],["长度为",{"1":{"763":1}}],["长度均为5",{"1":{"749":1}}],["长期遭受虐待而得不到改善时",{"1":{"391":1}}],["长的",{"1":{"374":1}}],["长命对象放在老年代中",{"1":{"122":1}}],["长路径切分成多个短路径做位置更新",{"1":{"104":1}}],["短命对象存放在新生代中",{"1":{"122":1}}],["伊面区",{"1":{"120":1}}],["整体停止",{"1":{"887":1}}],["整数数学比浮点数学更快",{"1":{"858":1}}],["整数x被装箱",{"1":{"820":1}}],["整合成为整个",{"1":{"857":1}}],["整合",{"1":{"566":1}}],["整理我们的代码",{"0":{"897":1}}],["整理成矩阵也就是",{"1":{"209":1}}],["整理算法",{"1":{"122":1}}],["整理算法=标记",{"1":{"121":1}}],["整理算法>标记",{"1":{"121":2}}],["整理算法要低于复制算法",{"1":{"119":1}}],["整理算法唯一的缺点就是效率也不高",{"1":{"119":1}}],["整理算法不仅可以弥补标记",{"1":{"119":1}}],["整理算法适合用于存活对象较多的场合",{"1":{"119":1}}],["整理阶段",{"1":{"119":1}}],["整个游戏如果按照这种方式获取",{"1":{"945":1}}],["整个游戏世界的更新和客户端的输入频率",{"1":{"73":1}}],["整个",{"1":{"942":1}}],["整个检测过程是在一个循环中实现的",{"1":{"691":1}}],["整个插件的体积是",{"1":{"535":1}}],["整个重写过程基本上不影响",{"1":{"457":1}}],["整个重写过程可以用伪代码表示如下",{"1":{"454":1}}],["整个读取和还原过程可以用以下伪代码表示",{"1":{"452":1}}],["整个缓存追加过程可以分为以下三步",{"1":{"445":1}}],["整个柏林噪声算法还剩下最后一块拼图了",{"1":{"197":1}}],["整个排序过程可以",{"1":{"107":1}}],["整个场景在x方向上有land",{"1":{"101":1}}],["整个world中所有的对象链表的链表头可依次存储于一个一维数组中",{"1":{"101":1}}],["整个空间按顺时针方向组织",{"1":{"92":1}}],["整个哈希空间环如下",{"1":{"92":1}}],["整个系统能正确高效运行",{"1":{"91":1}}],["压缩",{"0":{"119":1},"1":{"510":2}}],["点落再矩形中",{"1":{"860":1}}],["点燃",{"1":{"811":1}}],["点总是在圆周",{"1":{"756":1}}],["点旋转后的",{"1":{"756":1}}],["点旋转前的角度为",{"1":{"756":1}}],["点后的角度为",{"1":{"756":1}}],["点的位置pivot和text的填充当pivot为0",{"1":{"639":1}}],["点那个",{"1":{"610":1}}],["点选看板之后就可查看到应征者的资料",{"1":{"380":1}}],["点击事件处理",{"0":{"674":1}}],["点击事件也是可以接收到的",{"1":{"657":1}}],["点击最顶级的遮罩",{"1":{"657":1}}],["点击",{"1":{"654":1,"835":1}}],["点击保存",{"1":{"607":1}}],["点击激活就完成了",{"1":{"560":1}}],["点击此时生成了一个文件",{"1":{"508":1}}],["点击实例的名称进入实例的详情后",{"1":{"460":1}}],["点击确定或者回车",{"1":{"407":1}}],["点击提示消耗一天",{"1":{"369":1}}],["点击这里",{"1":{"202":1}}],["点我下载",{"1":{"287":2}}],["点积大于",{"1":{"693":1}}],["点积结果为负数",{"1":{"197":1}}],["点积结果为正数",{"1":{"197":1}}],["点积结果为",{"1":{"197":1}}],["点积运算为两向量长度之积",{"1":{"197":1}}],["点积",{"1":{"197":1}}],["点",{"1":{"118":1}}],["点对点的游戏也是这么做的",{"1":{"45":1}}],["遍历其他",{"1":{"964":1}}],["遍历所有符合条件的内存块",{"1":{"911":1}}],["遍历所有角度是不现实的",{"1":{"761":1}}],["遍历实体和组件最有效的方式时在一个并行化的job中按顺序处理组件",{"1":{"909":1}}],["遍历内存中的所有游戏对象和组件",{"1":{"858":1}}],["遍历",{"1":{"691":3}}],["遍历堆",{"1":{"118":1}}],["遍历这些灯塔",{"1":{"104":1}}],["标签对应的资源",{"1":{"903":1}}],["标签页看到执行结果",{"1":{"508":1}}],["标准库和原来使用mono编译时候的一模一样",{"1":{"593":1}}],["标准库",{"1":{"593":2}}],["标记的所有组件",{"1":{"936":1}}],["标记的存活对象将会被整理",{"1":{"119":1}}],["标记这个地方是否可以生成矿",{"1":{"301":1}}],["标记整理",{"0":{"119":1}}],["标记阶段",{"1":{"118":1,"119":1}}],["标记",{"0":{"118":1},"1":{"118":1,"119":2,"121":1}}],["标志玩家是否按着某些按键",{"1":{"42":1}}],["三角图元1中有两个顶点的位置信息",{"1":{"846":1}}],["三角形个数",{"1":{"846":1}}],["三角形的数组的size",{"1":{"846":1}}],["三角形序列",{"1":{"846":1}}],["三维坐标系最后",{"1":{"841":1}}],["三次",{"1":{"699":1}}],["三种",{"1":{"451":1}}],["三种算法总结",{"0":{"121":1}}],["三消",{"0":{"364":1}}],["三太郎抡走了你的丸子串",{"1":{"296":1}}],["三类底材拥有同样的模型",{"1":{"273":1}}],["三个操作系统对应的",{"1":{"510":1}}],["三个字符串",{"1":{"445":1}}],["三个参数",{"1":{"444":1}}],["三个变量",{"1":{"199":2}}],["三个坐标分量作为输入",{"1":{"197":1}}],["三个算法都基于根搜索算法去判断一个对象是否应该被回收",{"1":{"121":1}}],["三",{"0":{"117":1,"842":1},"1":{"876":1},"2":{"118":1,"119":1,"120":1,"121":1,"122":1}}],["主线程代码",{"1":{"925":1}}],["主线程都可以安全访问joba使用的nativecontainer",{"1":{"924":1}}],["主线程才能安全的访问nativecontainer中的数据",{"1":{"924":1}}],["主逻辑",{"1":{"811":1}}],["主脚本副表",{"1":{"811":1}}],["主表副脚本",{"1":{"811":1}}],["主控端同步给服务端",{"1":{"805":1}}],["主控端",{"1":{"805":1}}],["主控端告诉服务端技能开始",{"1":{"803":1}}],["主控端点击技能按钮",{"1":{"803":1}}],["主控端就是服务端",{"1":{"801":1}}],["主用",{"1":{"528":1}}],["主进程处理命令请求",{"1":{"457":1}}],["主进程就可以继续像往常一样接受命令请求了",{"1":{"455":1}}],["主进程需要执行以下三个工作",{"1":{"455":1}}],["主进程在接到新的写命令之后",{"1":{"455":1}}],["主进程还需要继续处理命令",{"1":{"455":1}}],["主进程可以继续处理命令请求",{"1":{"455":1}}],["主进程无法持续处理请求",{"1":{"451":1}}],["主进程会被阻塞",{"1":{"450":1}}],["主进程执行的",{"1":{"450":1}}],["主进程阻塞",{"1":{"448":1}}],["主轴的开始位置",{"1":{"406":1}}],["主",{"1":{"376":1}}],["主动请求垃圾收集",{"0":{"829":1},"2":{"830":1,"831":1,"832":1,"833":1}}],["主动帮她一起扛",{"1":{"296":1}}],["主动发起",{"1":{"51":2}}],["主角在am6",{"1":{"291":1}}],["主要介绍下伤害的同步",{"1":{"809":1}}],["主要就是",{"1":{"685":1}}],["主要还是触发enter",{"1":{"673":1}}],["主要用于在linux服务器环境下",{"1":{"545":1}}],["主要减免3盘伤害",{"1":{"377":1}}],["主要在原料店",{"1":{"376":1}}],["主要是用linkedentitygroup",{"1":{"965":1}}],["主要是用来设置payload",{"1":{"228":1}}],["主要是包括数据",{"1":{"876":1}}],["主要是供插件使用",{"1":{"570":1}}],["主要是门派介面的基准底限不要太低的话",{"1":{"373":1}}],["主要是为了丰富游戏多样性",{"1":{"287":1}}],["主要是控制npc的指示显示",{"1":{"252":1}}],["主要是比对并找到人身上同tag的特效",{"1":{"237":1}}],["主要是根据prioritycallbacks按照优先顺序执行回调函数",{"1":{"228":1}}],["主要是通过graphbasedgeneratorgrid2d来设置payload",{"1":{"228":1}}],["主要是依赖于样本相邻各点的布局结构",{"1":{"207":1}}],["主要是增加了代码的整洁性和可读性",{"1":{"198":1}}],["主要指声明为final的常量值",{"1":{"116":1}}],["栈里的指针",{"1":{"898":1}}],["栈里已经存储的数据",{"1":{"885":1}}],["栈分配一块内存空间给vegetable",{"1":{"893":1}}],["栈分配一块内存空间给pvalue并指向x",{"1":{"893":1}}],["栈分配一块内存空间给x",{"1":{"892":1,"893":1}}],["栈分配一块内在空间给pvalue",{"1":{"892":1}}],["栈没有无限的空间去使用",{"1":{"891":1}}],["栈为x分配一块内存空间并存储值5然后",{"1":{"891":1}}],["栈为任何值类型创建副本",{"1":{"890":1}}],["栈会为它分配一块内存空间并把值类型变量的值存储进去",{"1":{"891":1}}],["栈会分配一块内存空间给程序执行所需要的信息",{"1":{"890":1}}],["栈会分配一块内存给变量result存放",{"1":{"885":1}}],["栈也为任何引用类型的指针创建副本",{"1":{"890":1}}],["栈像下图所示",{"1":{"890":1}}],["栈工作原理",{"0":{"885":1}}],["栈的情况就像你叠在一起的鞋盒子",{"1":{"879":1}}],["栈",{"1":{"814":4,"879":3,"885":1}}],["栈中的引用的对象2",{"1":{"116":1}}],["栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作",{"1":{"113":1}}],["栈上的空间默认是1m",{"1":{"131":1}}],["栈上的所有局部变量",{"1":{"116":1}}],["栈上传入的参数变量5",{"1":{"116":1}}],["垃圾清理",{"1":{"898":1}}],["垃圾收集对程序员来说是自动的",{"1":{"828":1}}],["垃圾收集器周期运行",{"1":{"813":1}}],["垃圾收集器对堆中的对象进行回收前",{"1":{"114":1}}],["垃圾回收gc的时候了",{"1":{"887":1}}],["垃圾回收时的标识",{"1":{"131":1}}],["垃圾回收时候将上述两块中存活的对象复制到另外一块survivor上",{"1":{"120":1}}],["垃圾回收器都会进行清理来释放内存",{"1":{"124":1}}],["垃圾回收算法",{"0":{"117":1},"2":{"118":1,"119":1,"120":1,"121":1,"122":1}}],["垃圾回收重点关注的是堆和方法区部分的内存",{"1":{"113":1}}],["垃圾对象的判定",{"0":{"114":1},"2":{"115":1,"116":1,"117":1,"118":1,"119":1,"120":1,"121":1,"122":1,"123":1}}],["克隆所有引用类型变量",{"1":{"896":1}}],["克隆方法共有的问题是",{"1":{"111":1}}],["克隆都不会重新生成一遍",{"1":{"111":1}}],["拷贝由私有方法创建的对象",{"1":{"111":1}}],["参与排序",{"1":{"976":1}}],["参看",{"1":{"652":2}}],["参看视频",{"1":{"287":1}}],["参加固定+100万修为和20名气",{"1":{"295":1}}],["参加论道+名气9",{"1":{"295":1}}],["参见",{"1":{"228":1}}],["参见本文评论",{"1":{"111":1}}],["参考这篇日文博客",{"1":{"941":1}}],["参考资料",{"0":{"770":1},"1":{"1041":1}}],["参考锚点位置",{"1":{"625":1}}],["参考分辨率960",{"1":{"625":1}}],["参考链接",{"0":{"532":1,"631":1,"1052":1},"1":{"876":1}}],["参考连接",{"0":{"525":1}}],["参考图",{"1":{"287":1}}],["参考",{"0":{"899":1,"984":1},"1":{"155":1,"601":2,"941":1}}],["参考文章",{"1":{"15":1}}],["参数中的z坐标的作用就是",{"1":{"1025":1}}],["参数到这个方法中",{"1":{"970":1}}],["参数则是调用",{"1":{"957":1}}],["参数则是",{"1":{"957":1}}],["参数是一个三维坐标",{"1":{"1025":1}}],["参数是",{"1":{"957":1}}],["参数pvalue将会被放到当前线程栈上",{"1":{"887":1}}],["参数调用",{"1":{"684":1}}],["参数解释",{"0":{"570":1}}],["参数确定",{"1":{"204":1}}],["参数进行多几次柏林噪声计算",{"1":{"204":1}}],["参数",{"0":{"890":1},"1":{"131":2,"413":1}}],["框架下",{"1":{"942":1}}],["框架逻辑有表的字段来决定",{"1":{"811":1}}],["框架写了一个网站",{"1":{"581":1}}],["框架等具体的功能",{"1":{"577":1}}],["框架和",{"1":{"577":1}}],["框架",{"1":{"111":1,"577":1}}],["委托会被缓存",{"1":{"111":1}}],["调度job的步骤如下",{"1":{"921":1}}],["调度job",{"0":{"921":1}}],["调试unity失效",{"0":{"834":1}}],["调试优化也不方便",{"1":{"15":1}}],["调整执行顺序",{"1":{"955":1}}],["调整",{"1":{"726":1}}],["调整某些元素出现的权重",{"1":{"220":1}}],["调用多次draw",{"1":{"979":1}}],["调用addhybridcomponent方法让",{"1":{"969":1}}],["调用不仅指定了哪个gameobject应该",{"1":{"969":1}}],["调用getentities",{"1":{"962":1}}],["调用后",{"1":{"959":1,"1002":1}}],["调用后引用记数会减1",{"1":{"697":1}}],["调用之间引擎需要初始化",{"1":{"940":1}}],["调用jobhandle的complete方法后",{"1":{"924":1}}],["调用的每个方法都必须在内存中找到该方法的地址",{"1":{"858":1}}],["调用替换为",{"1":{"858":2}}],["调用dictionary",{"1":{"822":1}}],["调用技能结束接口",{"1":{"793":1}}],["调用时可以提供一个目标unit",{"1":{"793":1}}],["调用vector3",{"1":{"771":1}}],["调用方法也是通过反射",{"1":{"718":1}}],["调用executeevents",{"1":{"657":1}}],["调用者线程会被阻塞",{"1":{"455":1}}],["调用",{"1":{"446":1,"510":1,"921":2,"958":3,"961":1,"1001":3}}],["调用对象的gethashcode",{"1":{"131":1}}],["调用一百万次耗时",{"1":{"111":2}}],["取得",{"1":{"975":1}}],["取消了垂直同步信号",{"1":{"854":1}}],["取消并行节点",{"1":{"795":1}}],["取消则减之",{"1":{"378":1}}],["取排过序的",{"1":{"695":1}}],["取决于我们希望这个蛇窝有多深",{"1":{"224":1}}],["取决于你所使用的序列化的类型",{"1":{"111":1}}],["取一个均匀分布的随机数",{"1":{"224":1}}],["取屏幕长宽的1",{"1":{"103":1}}],["意味着你手边可以使用",{"1":{"964":1}}],["意味着其包含",{"1":{"955":1}}],["意味着创建了更多的工作给gc",{"1":{"898":1}}],["意味着我们可以通过指针访问它",{"1":{"883":1}}],["意味着不会为内存中的对象重新分配内存地址来消除对象之间的间隙",{"1":{"857":1}}],["意味着",{"1":{"857":1,"960":1}}],["意识",{"1":{"594":1}}],["意为",{"1":{"405":1}}],["意思就是",{"1":{"644":1}}],["意思应该是只有在真正观察时",{"1":{"206":1}}],["意思是让",{"1":{"971":1}}],["意思是它只有一个空的",{"1":{"950":1}}],["意思是指显卡等待到一个垂直同步信号后才开始工作",{"1":{"854":1}}],["意思是",{"1":{"43":1}}],["意在支持超过memberwiseclone所提供的功能",{"1":{"111":1}}],["综合起来",{"1":{"445":1,"451":1}}],["综合以上三种方法",{"1":{"107":1}}],["综上所述",{"1":{"215":1}}],["综上",{"1":{"124":1}}],["综述",{"0":{"40":1}}],["序列法术场",{"1":{"801":1}}],["序列",{"0":{"281":1},"1":{"107":1}}],["序列化方法是自动的",{"1":{"111":1}}],["序列化",{"0":{"598":1},"1":{"102":1,"971":1}}],["递归地查询",{"1":{"959":1,"1002":1}}],["递归",{"1":{"107":1,"691":2}}],["冒泡排序",{"1":{"107":1}}],["针对上面的",{"1":{"444":1}}],["针对每一种元素",{"1":{"220":1}}],["针对这样的插入方法目前大家常用的有快速排序",{"1":{"106":1}}],["针对不同的游戏",{"1":{"74":1}}],["添加iconvertgameobjecttoentity接口",{"1":{"1054":1}}],["添加了parent组件且添加了translation",{"1":{"1053":1}}],["添加发送给服务器时的servertick",{"1":{"1014":1}}],["添加额外",{"1":{"964":1}}],["添加背景层照相机",{"1":{"725":1}}],["添加程序集引用",{"1":{"722":1}}],["添加collider和eventsystem的事件处理回调接口",{"1":{"664":1}}],["添加脚本事件阻止父子之间阻止向父级传递事件",{"1":{"657":1}}],["添加主机时必须使用python2",{"1":{"541":1}}],["添加nginx",{"0":{"530":1}}],["添加环境变量",{"1":{"526":1}}],["添加globalpackagesfolder节点",{"1":{"524":1}}],["添加此action前记得先添加分支gh",{"1":{"517":1}}],["添加应用到开始屏幕",{"0":{"496":1}}],["添加保存",{"1":{"494":1}}],["添加公钥到谷歌云的实例中",{"0":{"460":1}}],["添加完host后",{"1":{"404":1}}],["添加到循环列表中",{"1":{"914":1}}],["添加到行为树中让我们看看任务的子类有哪些",{"1":{"277":1}}],["添加到玩家任务列表",{"1":{"252":1}}],["添加到aoi",{"1":{"106":1}}],["添加特效到角色",{"0":{"232":1}}],["添加一个隐藏的暗门",{"1":{"221":1}}],["添加",{"0":{"177":1,"908":1},"1":{"952":1,"957":1}}],["添加或删除一个槽位的几乎需要对所有关键字进行重新映射",{"1":{"92":1}}],["类提供了一个构造一个你数据的视图方法",{"1":{"912":1}}],["类来管理一个world中的所有实体",{"1":{"906":1}}],["类animal和vegetables衍生于thing",{"1":{"893":1}}],["类库中提供的所有代码",{"1":{"721":1}}],["类库",{"1":{"708":1}}],["类库名",{"1":{"398":1}}],["类似在编辑器中删除",{"1":{"958":1,"1001":1}}],["类似于物理中左右手判断法则",{"1":{"846":1}}],["类似于订阅",{"1":{"104":1}}],["类似适用案例",{"1":{"754":1}}],["类似",{"1":{"695":2}}],["类重载了",{"0":{"690":1}}],["类里面缓存了一些通过反射得到的射线检测相关的类方法",{"1":{"684":1}}],["类继承自",{"1":{"684":1,"685":1}}],["类移除了自己的注册",{"1":{"683":1}}],["类注册了自己",{"1":{"683":1}}],["类还继承自",{"1":{"683":1}}],["类很简单",{"1":{"683":1}}],["类都继承自",{"1":{"683":1}}],["类的对象所在的",{"1":{"695":1}}],["类的一些属性和方法外",{"1":{"687":1}}],["类的成员属性很少",{"1":{"687":1}}],["类的",{"1":{"657":1,"684":2}}],["类的命令来构建c",{"1":{"125":1}}],["类的命令来构建它们",{"1":{"125":1}}],["类中",{"1":{"695":1}}],["类中返回的是",{"1":{"695":1}}],["类中被覆写",{"1":{"695":1}}],["类中覆写了此方法",{"1":{"695":1}}],["类中没有覆写",{"1":{"695":1}}],["类中直接使用父类的",{"1":{"687":1}}],["类中相应事件接口对应的方法",{"1":{"657":1}}],["类中的",{"1":{"657":1,"660":1,"695":1}}],["类实现了所有常用的",{"1":{"657":1}}],["类调用powershell",{"0":{"425":1}}],["类游戏最独特的一点",{"1":{"217":1}}],["类时",{"1":{"169":1}}],["类处理用户请求",{"1":{"168":1}}],["类",{"0":{"683":1},"1":{"151":1,"601":1,"683":2,"753":1,"754":1,"828":1,"916":1}}],["类型都会默认",{"1":{"960":1}}],["类型组件",{"1":{"947":1}}],["类型的",{"1":{"930":1,"946":2,"964":1}}],["类型和值",{"1":{"929":1}}],["类型和成员的引用",{"1":{"131":1}}],["类型结构shoe是它的成员",{"1":{"895":1}}],["类型",{"1":{"607":1,"726":1,"811":1,"937":1,"946":1,"957":1}}],["类型为7",{"1":{"224":1}}],["类型是不是2",{"1":{"224":1}}],["类型是应该转成的委托的类型他们的区别在于前者创建出来的委托是直接调用那个实例方法本身",{"1":{"176":1}}],["类型对象包含静态字段",{"1":{"131":1}}],["类型检查",{"1":{"127":1}}],["类型安全的克隆icloneable的另一个缺点是clone方法返回的是一个对象",{"1":{"111":1}}],["类型一",{"1":{"103":1}}],["削去了遍历周边地格所有对象的逻辑",{"1":{"104":1}}],["效果可能差一些",{"1":{"804":1}}],["效果比512的好",{"1":{"568":1}}],["效果图如下",{"1":{"537":1}}],["效果",{"1":{"387":1,"388":1,"389":1}}],["效果不好",{"1":{"373":1}}],["效果不是很好",{"1":{"46":1}}],["效",{"1":{"372":1}}],["效率考虑等因素调整",{"1":{"799":1}}],["效率自然也就提高了",{"1":{"575":1}}],["效率",{"1":{"121":1}}],["效率也非常高",{"1":{"108":1}}],["效率提升不明显",{"1":{"104":1}}],["优先级数值越大",{"1":{"695":1}}],["优先保证地图类型能够满足用户的需求",{"1":{"214":1}}],["优点与不足",{"0":{"786":1},"2":{"787":1,"788":1}}],["优点标记",{"1":{"119":1}}],["优点1",{"1":{"115":1}}],["优点",{"0":{"441":1,"787":1},"1":{"110":2,"120":1,"756":1,"760":1,"764":1,"811":1,"876":1}}],["优点是可处理视野不同的观察者",{"1":{"104":1}}],["优缺点",{"0":{"110":1}}],["优化策略就是shader的优化",{"1":{"876":1}}],["优化",{"0":{"828":1}}],["优化显存占用情况的插件",{"1":{"570":1}}],["优化最简单的策略就是",{"1":{"91":1}}],["优化好了",{"1":{"15":1}}],["路径中的斜杠使用",{"1":{"559":1}}],["路径短的话也可能不是问题",{"1":{"104":1}}],["路上遇到了形迹可疑的路人",{"1":{"296":1}}],["路由指向蓝色环境了",{"1":{"88":1}}],["路由在传播的时候也会产生一些延迟",{"1":{"64":1}}],["消耗",{"1":{"1037":1}}],["消耗内存越大",{"1":{"104":1}}],["消除不必要的运算",{"1":{"787":1}}],["消失",{"1":{"104":1}}],["消息驱动",{"1":{"652":1}}],["消息广播还是有点多",{"1":{"19":1}}],["消息还是有点多",{"1":{"19":1}}],["灯塔法",{"0":{"104":1}}],["绿色的部分表示引用记数",{"1":{"700":1}}],["绿色的箭头表示已经探索的路径",{"1":{"210":1}}],["绿色形态",{"1":{"275":1}}],["绿色",{"1":{"275":3}}],["绿色物品还会有自己的专属qlvl",{"1":{"273":1}}],["绿色表示手机客户端的显示区域",{"1":{"103":1}}],["绿配置",{"1":{"88":1}}],["加上的",{"1":{"958":1,"1001":1}}],["加上verticallayoutgroup和contentsizefitter两个组件设置成0",{"1":{"639":1}}],["加",{"1":{"940":1,"948":1}}],["加速国内git",{"1":{"569":1}}],["加速度来推算出来",{"1":{"77":1}}],["加密方式",{"1":{"467":1}}],["加体力少树木掉落",{"1":{"299":1}}],["加的比减得多",{"1":{"295":1}}],["加法师单个技能",{"1":{"270":1}}],["加法师单系技能",{"1":{"270":1}}],["加圣骑士单个技能",{"1":{"270":1}}],["加圣骑士单系技能",{"1":{"270":1}}],["加死灵法师单个技能",{"1":{"270":1}}],["加死灵法师单系技能",{"1":{"270":1}}],["加德鲁伊单个技能",{"1":{"270":1}}],["加德鲁伊单系技能",{"1":{"270":1}}],["加野蛮人单个技能",{"1":{"270":1}}],["加野蛮人单系技能",{"1":{"270":1}}],["加亚马逊单个技能",{"1":{"270":1}}],["加亚马逊单系技能",{"1":{"270":1}}],["加刺客单系技能",{"1":{"270":1}}],["加人物技能",{"1":{"270":1}}],["加载获取该dll中的指定类",{"1":{"714":1}}],["加载该资源",{"1":{"705":1}}],["加载一个prefab时",{"1":{"699":1}}],["加载到的资源将会被存储到",{"1":{"697":1}}],["加载的资源",{"1":{"697":1}}],["加载后返回一个",{"1":{"696":1}}],["加载land后",{"1":{"259":1}}],["加载数据",{"1":{"257":1,"258":1}}],["加载程序创建并将存根附加到类型中的每个方法",{"1":{"129":1}}],["加载类型并将其初始化时",{"1":{"129":1}}],["加了一个域",{"1":{"111":1}}],["加入到所属的格子中",{"1":{"103":1}}],["九级装备才能过九级地牢",{"1":{"293":1}}],["九个格子的大小略大于屏幕大小",{"1":{"103":1}}],["九宫格也是打格子的方式之一",{"1":{"103":1}}],["九宫格",{"0":{"103":1},"1":{"110":1}}],["请并排排列它们",{"1":{"1023":1}}],["请将所需的编译器指令添加到我们着色器的延迟渲染通道中",{"1":{"981":1}}],["请将代码执行从单独线程切换到主线程以进行调试",{"1":{"878":1}}],["请尝试最小化单个数学运算的成本",{"1":{"858":1}}],["请避免在紧凑循环中或每帧运行的代码中进行unityengine",{"1":{"858":1}}],["请记住在内存中对象必须总是占用一段连续的空间",{"1":{"813":1}}],["请注明出处",{"1":{"770":1}}],["请注意对象在内存空间中的分配地址必须始终为连续空间块",{"1":{"857":1}}],["请注意在unity5",{"1":{"823":1}}],["请注意剩下的参数其实都是传递给il2cpp",{"1":{"592":1}}],["请注意时效",{"1":{"553":1}}],["请注意躲避和闪避的区别",{"1":{"385":1}}],["请注意",{"1":{"75":1,"524":1,"585":1,"813":2,"815":3,"822":1,"823":1,"824":1,"825":1}}],["请使用",{"1":{"721":1}}],["请使用ioptionssnapshot",{"1":{"174":1}}],["请确定磁盘末被写保护",{"1":{"707":1}}],["请添加一个",{"1":{"604":1}}],["请完整复制",{"1":{"438":1}}],["请求都会经过代理服务器处理再发给目标服务器使用nginx作为反向代理服务器的好处",{"1":{"581":1}}],["请求过来时",{"1":{"575":1}}],["请求",{"1":{"174":1,"573":1,"576":1}}],["请不要将",{"1":{"130":1}}],["请参考之前所画的",{"1":{"286":1}}],["请参考图",{"1":{"103":1}}],["请参阅",{"1":{"125":2,"604":2}}],["利用点乘和差乘实现判断一个点是否在三角形里面",{"1":{"777":1}}],["利用这点可让物体绕旋转点",{"1":{"756":1}}],["利用这种采样方式采样出玩家的初始占位符",{"1":{"214":1}}],["利用射线linecast",{"0":{"751":1}}],["利用射线raycast",{"0":{"750":1}}],["利用数学判断",{"0":{"749":1}}],["利用ontriggerentry函数",{"1":{"748":1}}],["利用碰撞器的触发器trigger",{"0":{"748":1}}],["利用gameobject本身的层级顺序来控制update的调用顺序",{"1":{"653":1}}],["利用锚点来保证ui与边缘或角落的距离",{"1":{"626":1}}],["利用",{"1":{"573":1,"759":1,"978":1}}],["利用关系解锁地块",{"0":{"354":1},"2":{"355":1,"356":1}}],["利用柏林噪声生成自然地图可以参考b站视频",{"1":{"214":1}}],["利用倍频实现更自然的噪声",{"0":{"204":1}}],["利用格子id得到y轴坐标编号",{"1":{"103":1}}],["利用格子id得到x轴坐标编号",{"1":{"103":1}}],["利用格子id得到格子坐标",{"1":{"103":1}}],["利用格子坐标得到格子编号",{"1":{"103":1}}],["利用一个queue",{"1":{"73":1}}],["y表示像素坐标",{"1":{"1025":1}}],["y怎么变化",{"1":{"1025":1}}],["y就是4",{"1":{"889":1}}],["ye关闭",{"1":{"869":1}}],["y值范围是0到1的点",{"1":{"639":1}}],["yaml格式的",{"1":{"940":1}}],["yaml",{"1":{"601":1,"940":1}}],["yarn",{"1":{"134":1}}],["yu使用不同的布局",{"1":{"225":1}}],["yidian",{"1":{"211":1}}],["y",{"0":{"634":1,"635":1,"636":1,"637":1},"1":{"207":1,"633":5,"634":2,"635":1,"636":3,"637":1,"642":1,"657":1,"755":2,"756":6,"800":1,"818":4,"820":2,"822":2,"824":8,"840":2,"1025":2}}],["y坐标同时都在通知范围内才可以进入通知集合",{"1":{"106":1}}],["y坐标",{"1":{"106":1}}],["y链表上需要关注的对象",{"1":{"105":1}}],["y链表上",{"1":{"105":1}}],["y轴坐标的位置",{"1":{"106":1}}],["y轴坐标链表",{"1":{"106":1}}],["y轴格子数量",{"1":{"103":1}}],["y轴长度",{"1":{"103":1}}],["your",{"1":{"22":4,"23":1,"28":3,"181":2,"183":1,"184":1,"185":1,"489":1,"571":1,"585":2,"720":3}}],["you",{"1":{"22":5,"23":2,"24":1,"26":1,"27":10,"28":8,"29":1,"90":2,"181":2,"185":1,"189":1,"196":2,"485":1,"486":1,"571":3,"585":5,"737":1}}],["到物件中心",{"1":{"975":1}}],["到目标primary",{"1":{"964":1}}],["到相应的",{"1":{"964":1}}],["到这呢",{"1":{"920":1}}],["到真实数据",{"1":{"826":1}}],["到对象类型的函数中",{"1":{"820":1}}],["到对象a的客户端",{"1":{"102":1}}],["到具体对象",{"1":{"654":1}}],["到开发者控制台",{"1":{"615":1}}],["到",{"1":{"567":1,"742":1,"756":1,"841":1,"944":1,"963":1,"965":1,"1003":1}}],["到了要开分舵的时候不只要这些啦",{"1":{"376":1}}],["到此为止",{"1":{"43":1}}],["内置了几个",{"1":{"1036":1}}],["内置了另一种名为",{"1":{"957":1}}],["内置的",{"1":{"951":1}}],["内置的一个",{"1":{"510":2}}],["内运行",{"1":{"949":1}}],["内所有像素都进行此操作",{"1":{"759":1}}],["内部将会调用",{"1":{"947":1}}],["内部筛选的只是",{"1":{"930":1}}],["内部也是通过groups的方式来实现",{"1":{"740":1}}],["内部使用了",{"1":{"684":1}}],["内核的浏览器",{"1":{"405":1}}],["内门弟子长期心情过差",{"1":{"391":1}}],["内力值",{"1":{"390":1}}],["内容修改为",{"1":{"504":1}}],["内容如下",{"1":{"467":1,"475":2,"510":1}}],["内容紧凑",{"1":{"441":1}}],["内容",{"1":{"287":1,"387":1,"969":1}}],["内",{"1":{"201":2,"378":2}}],["内有效",{"1":{"174":1}}],["内存直接使用",{"1":{"971":1}}],["内存中挪到堆内存中",{"1":{"960":1}}],["内存里",{"1":{"945":1}}],["内存块里面存的是索引数组",{"1":{"929":1}}],["内存块中的数据会紧密排列",{"1":{"905":1}}],["内存结构",{"0":{"929":1}}],["内存管理是一个微妙而复杂的课题",{"1":{"833":1}}],["内存管理器认为这些",{"1":{"827":1}}],["内存管理器会搜索所有当前活动的引用变量",{"1":{"827":1}}],["内存管理器跟踪它知道未被使用的堆中的区域",{"1":{"827":1}}],["内存",{"0":{"864":1},"1":{"759":1,"971":1}}],["内存清理时机",{"0":{"701":1},"2":{"702":1}}],["内存超频的问题也会导致黑屏",{"1":{"551":1}}],["内存超频问题会影响cpu超频",{"1":{"551":1}}],["内存分配和垃圾收集",{"0":{"827":1}}],["内存分配发生在每次访问",{"1":{"824":1}}],["内存分配在每次",{"1":{"824":1}}],["内存分配在托管堆上",{"1":{"131":1}}],["内存分配时也就不用考虑内存碎片等复杂情况",{"1":{"120":1}}],["内存利用率",{"1":{"121":1}}],["内存整齐度",{"1":{"121":1}}],["内存减半的高额代价",{"1":{"119":1}}],["内存区域分散的缺点",{"1":{"119":1}}],["内存自然就跟随着回收了",{"1":{"113":1}}],["内存消耗仅和实体数有关",{"1":{"110":1}}],["内存消耗不仅和实体数有关",{"1":{"110":1}}],["内存开销小",{"1":{"110":1}}],["内存开销大",{"1":{"110":1}}],["内的其他对象",{"1":{"102":1}}],["内插法的大致过程如下",{"1":{"46":1}}],["组的立方体",{"1":{"1039":3}}],["组成的向量",{"1":{"763":1}}],["组成",{"1":{"99":1,"165":1}}],["组件正常引用子对象里的组件即可",{"1":{"969":1}}],["组件来实现",{"1":{"968":1}}],["组件并没有满足需求",{"1":{"968":1}}],["组件并设置了",{"1":{"691":1}}],["组件到任何",{"1":{"964":1}}],["组件到一个entity上时",{"1":{"742":1}}],["组件的按钮",{"1":{"955":1}}],["组件的话",{"1":{"927":1}}],["组件自行完成",{"1":{"951":1}}],["组件里",{"1":{"951":1}}],["组件创建一个空的",{"1":{"947":1}}],["组件作为",{"1":{"944":1}}],["组件指向了父",{"1":{"944":1,"1000":1}}],["组件将会极大简化我们的操作",{"1":{"944":1,"1000":1}}],["组件将不会调用",{"1":{"691":1}}],["组件在持续地改变它的",{"1":{"940":1}}],["组件被删除的时候",{"1":{"937":1}}],["组件和修改其他需要的内部状态",{"1":{"935":1}}],["组件和其他需要的内部状态",{"1":{"934":1}}],["组件类型供查询选择",{"1":{"910":1}}],["组件中",{"1":{"904":1}}],["组件中的",{"1":{"685":2}}],["组件对应的content填加",{"1":{"860":1}}],["组件转换目标设置为",{"1":{"264":1}}],["组件targetable中执行interact",{"1":{"253":1}}],["组件",{"0":{"918":1},"1":{"30":1,"657":1,"684":1,"691":1,"695":1,"860":1,"904":2,"927":2,"942":2,"946":1,"947":1,"948":2,"949":1,"951":1,"952":3,"956":1,"968":1}}],["块我们就可以得到这样的控制",{"1":{"976":1}}],["块内存",{"1":{"927":1}}],["块之间的任何空间都是空的",{"1":{"827":1}}],["块",{"1":{"99":1}}],["均匀的数据分布",{"1":{"96":1}}],["于是决定加上额外的组件到",{"1":{"951":1}}],["于是就有了fastcgi",{"1":{"574":1}}],["于是在官方市场搜索了一下",{"1":{"510":1}}],["于是物品就有了变化莫测的属性取最高",{"1":{"270":1}}],["于是我将其封装成了泛型版本",{"1":{"176":1}}],["于是可以分为",{"1":{"96":1}}],["于是皆大欢喜～服务器很开心是因为他是服务器",{"1":{"79":1}}],["导入的时候执行了编辑器脚本再看下他再unity中的编辑器显示该脚本定义了三个按钮",{"1":{"972":1}}],["导入大小需要设置maxsize和compression",{"1":{"872":1}}],["导出过程中裁剪掉未使用的代码",{"1":{"604":1}}],["导出说明",{"0":{"585":1}}],["导出完成后",{"1":{"481":1}}],["导出",{"0":{"438":1},"1":{"965":2}}],["导致",{"1":{"982":1}}],["导致忽略了本应碰撞的事件发生",{"1":{"753":1}}],["导致在压缩的过程中出现内存溢出的问题",{"1":{"537":1}}],["导致每次请求远程url都会报错",{"1":{"420":1}}],["导致数据大部分都存储在redis4中",{"1":{"96":1}}],["导弹是由服务器处理的",{"1":{"50":1}}],["具有碰撞器",{"1":{"1024":1}}],["具有较好的容错性和可扩展性",{"1":{"95":1}}],["具体取决于程序集中的类型数量",{"1":{"1051":1}}],["具体来说",{"1":{"969":1}}],["具体如下",{"1":{"923":1}}],["具体方法就是将第一个job的",{"1":{"923":1}}],["具体方法为physics",{"1":{"751":1}}],["具体执行的任务在这个方法里实现",{"1":{"920":1}}],["具体过程就是",{"1":{"876":1}}],["具体原因未知",{"1":{"836":1}}],["具体时间取决于不同的平台",{"1":{"813":1}}],["具体参考文章",{"1":{"795":1}}],["具体可看源码",{"1":{"762":1}}],["具体实现步骤",{"1":{"726":1}}],["具体run怎么执行",{"1":{"715":1}}],["具体到",{"1":{"713":1}}],["具体的描述也很简单",{"1":{"811":1}}],["具体的信息根据策划需求设置",{"1":{"795":1}}],["具体的读取manifest和module内部数据",{"1":{"713":1}}],["具体的计算过程大致是",{"1":{"689":1}}],["具体的代码可以点击",{"1":{"535":1}}],["具体代码如下",{"1":{"684":1,"695":1}}],["具体做法就是在unity工程的assets目录中建立一个叫link",{"1":{"603":1}}],["具体做法可以在服务器ip或主机名的后面增加编号来实现",{"1":{"96":1}}],["具体请参考",{"1":{"526":1}}],["具体说明可查看",{"1":{"475":1}}],["具体还要您自己去实现啦",{"1":{"220":1}}],["具体都做了些什么",{"1":{"166":1}}],["具体位置如下图所示",{"1":{"95":1,"96":1}}],["干杯~",{"1":{"864":1,"899":1}}],["干扰的也只有redis3而已",{"1":{"95":1}}],["干扰的只有前面的数据",{"1":{"94":1}}],["干净",{"1":{"85":1,"969":1}}],["哈希表可以快速地找到相应的值",{"1":{"929":1}}],["哈希表等键也可以用类似的方法来保存状态",{"1":{"454":1}}],["哈希表槽位数",{"1":{"92":1}}],["哈希函数是一种从任何一种数据中创建小的数字",{"1":{"201":1}}],["哈希函数在维基百科的定义如下",{"1":{"201":1}}],["哈希函数",{"0":{"201":1}}],["哈希值是32位无符号整形",{"1":{"92":1}}],["个立方体",{"1":{"1039":1}}],["个cube",{"1":{"971":1}}],["个chunk",{"1":{"943":1,"952":1}}],["个我们都介绍了它们的作用",{"1":{"965":1}}],["个转换后的gameobject",{"1":{"960":1}}],["个屁用没有的",{"1":{"957":1}}],["个关联",{"1":{"953":1}}],["个关键字重新映射",{"1":{"92":1}}],["个方块",{"1":{"943":1}}],["个位置",{"1":{"943":1}}],["个",{"1":{"943":3,"944":1,"952":1,"953":2,"954":2,"955":1,"960":3}}],["个人认为这个和给target发送message1",{"1":{"657":1}}],["个人认为quartz",{"1":{"30":1}}],["个人更倾向于uwsgi是类似wsgi的通信协议的说法",{"1":{"582":1}}],["个来源",{"1":{"507":1}}],["个柔弱的小女孩扛着一只巨大的蒲公英",{"1":{"296":1}}],["个房间按照",{"1":{"224":1}}],["个浅拷贝",{"1":{"111":1}}],["现有",{"1":{"455":1}}],["现有的",{"1":{"455":1}}],["现实地形会有大段连绵",{"1":{"204":1}}],["现假设有一台redis服务器宕机了",{"1":{"91":1}}],["现在把",{"1":{"1039":1}}],["现在这个小地图看起来就比较完善了",{"1":{"1034":1}}],["现在最关键的一步来了",{"1":{"1034":1}}],["现在当你进入",{"1":{"971":1}}],["现在conversion",{"1":{"969":1}}],["现在支持",{"1":{"966":1}}],["现在我将把它变成",{"1":{"966":1}}],["现在我们回过头来看看",{"1":{"275":1}}],["现在我们已经生成了整个critical",{"1":{"224":1}}],["现在我们可以向下移动了",{"1":{"224":1}}],["现在我们需要用代码表示前面所提到的fade函数",{"1":{"200":1}}],["现在ecs的实例化已经和传统",{"1":{"964":1}}],["现在属于这个",{"1":{"961":1}}],["现在可以看到已经正常添加了",{"1":{"959":1,"1002":1}}],["现在已经有足够的知识来执行转换过程了",{"1":{"951":1}}],["现在已经包括源代码了",{"1":{"111":1}}],["现在是需要c",{"1":{"887":1}}],["现在是indices数组中",{"1":{"846":1}}],["现在有很多unity的api有不会造成内存分配的新版本",{"1":{"824":1}}],["现在匿名函数需要在此函数作用范围之外获取一个变量的状态",{"1":{"818":1}}],["现在在编辑器中需要把所有的视差对象放入视差层中",{"1":{"737":1}}],["现在让我们看一下如何设置",{"1":{"737":1}}],["现在让我们着手把代码实现出来",{"1":{"197":1}}],["现在要将它挂在网上运行",{"1":{"581":1}}],["现在要做的是如何在这100ms内让网络角色看起来非常自然",{"1":{"76":1}}],["现在的模块化的前端开发范式非常流行",{"1":{"536":1}}],["现在的虚拟机使用复制算法来进行新生代的内存回收",{"1":{"120":1}}],["现在你已经可以使用",{"1":{"971":1}}],["现在你应该明白了",{"1":{"954":1}}],["现在你有一个数据并且绘制了",{"1":{"944":1}}],["现在你准备构建一本书籍",{"1":{"502":1}}],["现在你在看这个模板",{"1":{"225":1}}],["现在安装",{"1":{"500":1}}],["现在基于gan的ai看起来能够生成又是动画又是图片的",{"1":{"206":1}}],["现在变了",{"1":{"131":1}}],["现在来看看双击后是怎样运行的",{"1":{"131":1}}],["现在使用的java虚拟机并不是只是使用一种内存回收机制",{"1":{"122":1}}],["现在",{"1":{"78":1,"451":1,"535":1,"1023":1}}],["现在得到的结果都是正确的",{"1":{"69":1}}],["现在玩家按了两下方向键右",{"1":{"68":1}}],["现在玩家输入和运行结果之间就没有任何延迟存在了",{"1":{"67":1}}],["现在假设客户端保存了一份发送到服务器的请求",{"1":{"69":1}}],["现在假设另一种情况",{"1":{"68":1}}],["现在假设有100ms的延迟",{"1":{"67":1}}],["现在假设服务器能够立即响应并且将结果返回",{"1":{"64":1}}],["现在为止的时间内的指令重新执行",{"1":{"14":1}}],["kyone",{"1":{"616":1}}],["kill",{"1":{"575":1}}],["kind",{"1":{"189":1,"489":1}}],["knightmore",{"1":{"939":1}}],["knife",{"1":{"542":1}}],["know",{"1":{"81":1,"196":1}}],["kkkgo",{"1":{"533":1}}],["ken",{"1":{"197":1,"198":2,"202":1}}],["keeping",{"1":{"191":1}}],["kestrel",{"1":{"166":2}}],["kestrelserver",{"0":{"166":1}}],["key",{"0":{"562":1},"1":{"91":3,"186":1,"221":1,"459":1,"822":1}}],["k",{"1":{"92":1}}],["无视renderqueue",{"1":{"976":1}}],["无视renderqueue跟soringorder",{"1":{"976":1}}],["无视不扣属性20",{"1":{"295":1}}],["无此属性",{"1":{"976":1}}],["无缝地更新到新状态",{"1":{"971":1}}],["无关的东西",{"1":{"968":1}}],["无所谓",{"1":{"965":1}}],["无需做无用功",{"1":{"971":1}}],["无需",{"1":{"942":1}}],["无需在对对象成员进行增删的时候做出修",{"1":{"111":1}}],["无",{"1":{"931":2}}],["无响应表中",{"1":{"836":1}}],["无响应",{"1":{"836":2}}],["无用",{"1":{"831":1}}],["无内存分配的版本是非常简单的",{"1":{"824":1}}],["无疑会浪费很多资源",{"1":{"759":1}}],["无旋转",{"0":{"755":1},"1":{"753":1,"756":3}}],["无非需要针对多屏幕",{"1":{"676":1}}],["无名仙岛",{"1":{"295":1}}],["无法参与批处理情况物件mesh大于等于900个面",{"1":{"980":1}}],["无法参与批处理情况改变renderer",{"1":{"979":1}}],["无法删除",{"1":{"936":1}}],["无法删除windowsapplication1",{"1":{"707":1}}],["无法通过静态批处理减少dc",{"1":{"877":1}}],["无法使用此方法",{"1":{"788":1}}],["无法使用该应用",{"0":{"611":1}}],["无法直接在",{"1":{"722":1}}],["无法购买您要的商品",{"0":{"610":1},"1":{"610":1}}],["无法跟其他武器同时持有",{"1":{"384":1}}],["无法影响装备的品质等级qlvl",{"1":{"275":1}}],["无法保证对相同的key的所有访问都发送到相同的redis中要解决上述的问题",{"1":{"91":1}}],["无重复地存放了0",{"1":{"199":1}}],["无状态grain",{"0":{"159":1}}],["无论你多么小心地设计",{"1":{"971":1}}],["无论它们是不是蓝色的",{"1":{"964":1}}],["无论这个变量是显式",{"1":{"819":1}}],["无论是插值和预测都是先读取快照",{"1":{"1016":1}}],["无论是显式的还是内部的",{"1":{"912":1}}],["无论是蓝色还是黄色",{"1":{"271":1}}],["无论是gc内存上的",{"1":{"15":1}}],["无论如何",{"1":{"202":1}}],["无论玩家实际做什么",{"1":{"75":1}}],["无论一个汉字是多少个字节",{"1":{"39":1}}],["+1",{"1":{"980":1}}],["+1天赋点",{"1":{"392":6}}],["+=",{"1":{"823":1}}],["+",{"1":{"90":1,"102":2,"103":1,"270":2,"285":2,"303":1,"459":1,"626":1,"756":11,"945":2,"971":1}}],["滚动方式构建",{"1":{"734":1}}],["滚动方式碍于实现只能做简单的平铺背景的滚动效果",{"1":{"732":1}}],["滚动方式只使用了一个四边形并且移动时也只是单纯改变了",{"1":{"731":1}}],["滚动方式",{"0":{"726":1},"1":{"725":1}}],["滚动部署模型",{"0":{"90":1}}],["滚动发布也有它非常合适的场景",{"1":{"89":1}}],["滚动发布",{"0":{"89":1},"1":{"89":1}}],["尽可能使用",{"1":{"964":1}}],["尽可能的设置到最小",{"1":{"872":1}}],["尽可能的降低帧率",{"1":{"860":1}}],["尽可能少的light",{"1":{"859":1}}],["尽可能大",{"1":{"831":1}}],["尽量关闭read",{"1":{"869":1}}],["尽量不要使用resources文件夹",{"1":{"873":1}}],["尽量不要使用layout",{"1":{"860":1}}],["尽量不要让弟子发呆就是了",{"1":{"375":1}}],["尽量避免调用object",{"1":{"858":1}}],["尽量使用热更dll内部的类作为泛型参数",{"1":{"599":1}}],["尽量减少预测量",{"1":{"15":1}}],["尽管",{"1":{"941":1}}],["尽管游戏并非在",{"1":{"940":1}}],["尽管一次只会有少量的物体在游戏中",{"1":{"832":1}}],["尽管他们乍一看是无辜的",{"1":{"828":1}}],["尽管可能会有足够的总空间来容纳一个确定大小的分配",{"1":{"813":1}}],["尽管我们可以用过修改快照实现持久化的频率",{"1":{"442":1}}],["尽管它们看起来可能杂乱无章",{"1":{"219":1}}],["尽管msbuild是visual",{"1":{"125":1}}],["尽管这种方法比使用反射快",{"1":{"111":1}}],["尽管有一些自动化的运维工具",{"1":{"89":1}}],["脾气不好的程序猿很可能想掀桌子",{"1":{"89":1}}],["周而复始",{"1":{"89":1}}],["等同于",{"1":{"976":1}}],["等等",{"1":{"964":1}}],["等组件的",{"1":{"949":1}}],["等方法来获取数据并绘制它们",{"1":{"941":1}}],["等相关信息保存在gpu内存中",{"1":{"982":1}}],["等相关信息保存在显存中的",{"1":{"981":1}}],["等相关信息",{"1":{"849":1,"982":1}}],["等技能前摇结束以后",{"1":{"796":1}}],["等于",{"1":{"780":1,"781":1}}],["等于单位向量",{"1":{"780":1}}],["等于选取该节点记录的点为当前点",{"1":{"210":1}}],["等效脚本运行时",{"1":{"721":1}}],["等属性",{"1":{"683":1}}],["等都继承了",{"1":{"661":1}}],["等平台时",{"1":{"604":1}}],["等累积3个同样任务",{"1":{"377":1}}],["等稳定後才开始盖并且才派人员工作",{"1":{"376":1}}],["等到",{"1":{"931":1}}],["等到晚上",{"1":{"377":1}}],["等到可以开打的时候",{"1":{"377":1}}],["等到都练好了",{"1":{"377":1}}],["等到有5个武场的时候才4练武3种",{"1":{"375":1}}],["等到有分舵才在分舵主攻兵器场",{"1":{"374":1}}],["等到他长拳练到3xxx经验值时臂力应该破400其他都破200",{"1":{"372":1}}],["等级",{"1":{"302":1,"303":1,"304":1,"305":1,"306":1,"307":1,"308":1,"309":1}}],["等级越高",{"1":{"301":1,"380":1}}],["等级提升添加境界限制",{"1":{"251":1}}],["等待job执行完毕",{"0":{"924":1},"2":{"925":1}}],["等待编译完成",{"1":{"717":1}}],["等待片刻",{"1":{"560":1}}],["等待",{"1":{"535":1,"997":1}}],["等待超时时间",{"1":{"467":1}}],["等待时间技能",{"1":{"244":1}}],["等待动作",{"1":{"242":1}}],["等待线程池的调度",{"1":{"167":1}}],["等游戏做到后期",{"1":{"800":1}}],["等游戏",{"1":{"212":1}}],["等测试发现新版本ok后",{"1":{"88":1}}],["等",{"0":{"601":1},"1":{"88":1,"266":1,"536":1,"767":1,"794":1,"800":1}}],["等服务器执行到100帧的时候",{"1":{"15":1}}],["老版本的王昭君大招是在自身一定半径以内",{"1":{"776":1}}],["老版本的状态不受影响",{"1":{"88":1}}],["老年代",{"1":{"122":1}}],["老系统的一个问题是",{"1":{"48":1}}],["新对象将被放到对象5的上面",{"1":{"898":1}}],["新释放的空间仅可用于存储与释放相同大小或更小的对象的数据",{"1":{"857":1}}],["新手朋友们可以记住这么一个快捷键",{"1":{"841":1}}],["新版本的王昭君的大招是指定位置施法的",{"1":{"776":1}}],["新版本上线的过程中",{"1":{"88":1}}],["新建一个classlibrary",{"1":{"708":1}}],["新建一个appdomain",{"1":{"707":1}}],["新建启动脚本文件",{"1":{"475":1}}],["新",{"1":{"453":1,"455":1}}],["新增一行",{"1":{"404":1}}],["新生代",{"1":{"122":1}}],["新功能开放",{"1":{"254":1}}],["新功能",{"1":{"88":1}}],["新的部分不会被一个接一个地添加到字符串中",{"1":{"828":1}}],["新的content从剪切板粘贴过来",{"1":{"737":1}}],["新的",{"1":{"68":1}}],["随后可以通过",{"1":{"1054":1}}],["随后需要监测新版本应用",{"1":{"88":1}}],["随附的",{"1":{"477":1}}],["随意画点东西吧",{"1":{"287":15}}],["随从",{"1":{"266":1}}],["随着离摄像机越来越远",{"1":{"1025":1}}],["随着方法的执行",{"1":{"885":1}}],["随着代码的执行每遇见方法中的变量",{"1":{"885":1}}],["随着剑的挥动",{"1":{"748":1}}],["随着我们技术的结合",{"1":{"737":1}}],["随着运行时间的流逝",{"1":{"453":1}}],["随着等级的提高",{"1":{"380":1}}],["随着一些江湖上的诡怪术士在此地频繁出入",{"1":{"297":1}}],["随着倍频增大",{"1":{"204":1}}],["随着对象的增多而变大",{"1":{"131":1}}],["随",{"1":{"130":1}}],["随线程灭而灭",{"1":{"113":1}}],["随线程生而生",{"1":{"113":1}}],["随机两种控制类型节点",{"1":{"795":1}}],["随机精英怪则是在游戏中随机出现",{"1":{"266":1}}],["随机位置",{"1":{"258":1}}],["随机采样玩家分布得到的地图",{"1":{"215":1}}],["随机数种子",{"1":{"214":1}}],["随机选择一面墙",{"1":{"221":1}}],["随机选择一个瓦片填入",{"1":{"210":1}}],["随机选一个节点",{"1":{"210":1}}],["随机挑选结果其实取决于前一步所计算得出的哈希值",{"1":{"202":1}}],["随机的移动",{"1":{"18":1}}],["随机种子",{"1":{"12":1}}],["目录中查看",{"1":{"722":1}}],["目录和node",{"1":{"535":1}}],["目录的体积是最大的",{"1":{"535":1}}],["目录推送到",{"1":{"507":1}}],["目录下找到它",{"1":{"585":1}}],["目录下有很多模块",{"1":{"535":1}}],["目录下",{"1":{"411":1}}],["目录",{"1":{"407":1,"507":1}}],["目前要施放该魔法",{"1":{"967":1}}],["目前你可以传入",{"1":{"970":1}}],["目前你可以认为这个",{"1":{"965":1}}],["目前你只需要知道",{"1":{"965":1}}],["目前究竟什么是",{"1":{"965":1}}],["目前只支持",{"1":{"964":1}}],["目前它已经支持",{"1":{"959":1,"1002":1}}],["目前这是默认的行为",{"1":{"959":1,"1002":1}}],["目前还不明白这个系统设计的目的",{"1":{"964":1}}],["目前还没有任何实际代码",{"1":{"955":1}}],["目前还无需关心它们",{"1":{"952":1}}],["目前我们仅仅使用",{"1":{"951":1}}],["目前已知的排序规则是",{"1":{"862":1}}],["目前",{"1":{"819":1,"959":1,"1002":1}}],["目前支持三种",{"1":{"447":1}}],["目前是不支持大端序的",{"1":{"167":1}}],["目前常用的排序算法",{"0":{"107":1}}],["目的是看看调用委托相比调用方法本身是否有性能损失",{"1":{"175":1}}],["目的是使这个exe在dos下执行时弹出一个提示",{"1":{"131":1}}],["目的是减少发布过程中服务停止的时间",{"1":{"88":1}}],["目标可能已经由ai传给了技能模块",{"1":{"797":1}}],["目标可能已经移动到一个不同的位置",{"1":{"85":1}}],["目标会进入trigger的范围",{"1":{"748":1}}],["目标对象负责接收事件并处理",{"1":{"654":1}}],["目标继续向左移动",{"1":{"85":1}}],["目标需要有一个提前量",{"1":{"48":1}}],["目标时间情况用来通过插值计算结果",{"1":{"46":1}}],["目标的显示",{"0":{"46":1}}],["年里",{"1":{"88":1}}],["蓝不足等",{"1":{"793":1}}],["蓝色的背景当前加载的资源",{"1":{"700":1}}],["蓝色的节点表示已探索或者待探索的节点",{"1":{"210":1}}],["蓝色判定的几率",{"1":{"275":1}}],["蓝色",{"1":{"275":2}}],["蓝色装备最多可以从词缀中选择不同的两个",{"1":{"270":1}}],["蓝色玩家初始时可以获得更多的矿产资源",{"1":{"213":1}}],["蓝色点",{"1":{"197":1}}],["蓝色环境和绿色环境有被摧毁的风险",{"1":{"88":1}}],["蓝色击中盒",{"1":{"85":1}}],["蓝绿发布对于增量升级有比较好的支持",{"1":{"88":1}}],["蓝绿发布是一种用于升级与更新的发布策略",{"1":{"88":1}}],["蓝绿配置",{"1":{"88":2}}],["蓝绿部署模型",{"0":{"90":1}}],["蓝绿部署适用的场景",{"1":{"88":1}}],["蓝绿部署需要有基础设施支持",{"1":{"88":1}}],["蓝绿部署的弱点",{"1":{"88":1}}],["蓝绿部署的优点",{"1":{"88":1}}],["蓝绿部署无需停机",{"1":{"88":1}}],["蓝绿部署原理上很简单",{"1":{"88":1}}],["蓝绿部署是最常见的一种0",{"1":{"88":1}}],["蓝绿部署虽然算不上",{"1":{"88":1}}],["蓝绿部署",{"0":{"88":1}}],["绝大多数所所谓高性能优化都是起负面作用不要关闭画面插值和延迟补偿​",{"1":{"87":1}}],["绝对值",{"1":{"50":1}}],["插件进行打包",{"1":{"538":1}}],["插件启动效果图如下",{"1":{"535":1}}],["插件为例子进行分析",{"1":{"535":1}}],["插件时",{"1":{"534":1,"538":1}}],["插入的时候把链表分成多份",{"1":{"108":1}}],["插补周期=",{"1":{"86":1}}],["插值使用的是interpolatedtargettick而他们又都来自m",{"1":{"1016":1}}],["插值就是将网络玩家显示在过去的某个时刻假设你在t=1000收到位置信息",{"1":{"1015":1}}],["插值整合",{"0":{"203":1}}],["插值处理可能表现不会很好",{"1":{"83":1}}],["插值可以使用快照340和344来进行平滑处理",{"1":{"83":1}}],["插值通常都可以处理得很好",{"1":{"76":1}}],["插值得到的精确时间",{"1":{"47":1}}],["插值也会带来延迟",{"1":{"47":1}}],["插值多少时间需要权衡",{"1":{"46":1}}],["插值法可以这样理解",{"1":{"46":1}}],["插值",{"0":{"1015":1},"1":{"15":1,"1013":1},"2":{"1016":1,"1017":1}}],["双持的定义在于同时持有2把单手武器",{"1":{"384":1}}],["双持",{"1":{"384":1}}],["双手挥击",{"1":{"244":1}}],["双击事件等",{"1":{"841":1}}],["双击间隔是固定为0",{"1":{"671":1}}],["双击文件后os",{"1":{"131":1}}],["双击exe后就从这里开始执行",{"1":{"131":1}}],["双向链表的好处是",{"1":{"105":1}}],["双方玩家都不能获利",{"1":{"86":1}}],["双字节",{"1":{"39":1}}],["视口预览",{"1":{"841":1}}],["视口",{"1":{"841":1}}],["视口坐标系对于场景的显示非常重要",{"1":{"841":1}}],["视口坐标系",{"1":{"841":1}}],["视乎有些困难",{"1":{"756":1}}],["视觉上的判定也是准星方向",{"1":{"750":1}}],["视觉效果因素",{"1":{"46":2}}],["视差背景其实就是通过多层次的背景来模拟透视视差效果",{"1":{"724":1}}],["视差效果",{"1":{"724":1}}],["视窗坐标下",{"1":{"688":1}}],["视野内的对象也相应变化",{"1":{"104":1}}],["视野加载",{"1":{"102":1}}],["视图内插延迟会导致移动的玩家会比静止不动的玩家更早发现对方",{"1":{"86":1}}],["您实例化一个纯粹用于对内存管理器产生影响的",{"1":{"831":1}}],["您应该谨慎使用此技术",{"1":{"830":1}}],["您必须自己保管着此对象",{"1":{"699":1}}],["您将会得到三个不同的",{"1":{"697":1}}],["您可以在",{"1":{"1023":1}}],["您可以获得一个包含实体的",{"1":{"912":1}}],["您可以手动遍历实体或块",{"1":{"912":1}}],["您可以立即添加组件",{"1":{"907":1}}],["您可以显式地请求垃圾收集",{"1":{"831":1}}],["您可以通过在启动期间预先分配一些占位符空间来手动扩展堆",{"1":{"831":1}}],["您可以使用这个entityquery对象用于获取符合条件的实体的数量",{"1":{"910":1}}],["您可以使用两种主要策略来最大限度地减少其入侵游戏",{"1":{"829":1}}],["您可以使用unity的方法进行实例化",{"1":{"697":1}}],["您可以选择clusterid对不同的部署使用不同的名称",{"1":{"90":1}}],["您可能想知道msbuild传递给特定构建的csc的信息",{"1":{"125":1}}],["您可能被你看不到的目标所击中",{"1":{"85":1}}],["您的平均延迟时间",{"1":{"86":1}}],["作者用",{"1":{"937":1}}],["作者博客找最新版本的release下载即可下载地址",{"1":{"555":1}}],["作业系统",{"1":{"926":1}}],["作业",{"0":{"916":1}}],["作品最终发布到",{"1":{"840":1}}],["作物",{"0":{"303":1},"1":{"299":1,"300":1}}],["作用则有好几个",{"1":{"131":1}}],["作弊代理",{"1":{"85":1}}],["作为独立world",{"1":{"1054":1}}],["作为结果",{"1":{"970":1}}],["作为余弦函数的输入",{"1":{"944":1}}],["作为其他job的依赖项",{"1":{"923":1}}],["作为参数传递给函数的数组可以在该函数内修改",{"1":{"828":1}}],["作为流程控制节点",{"1":{"805":1}}],["作为这个",{"1":{"644":1}}],["作为草稿",{"1":{"615":1}}],["作为登录名",{"1":{"459":1}}],["作为一个函数的参数声明",{"1":{"819":1}}],["作为一个游戏开发者",{"1":{"62":1}}],["作为一种辅佐性的维护手段",{"1":{"455":1}}],["作为例子",{"1":{"452":1}}],["作为休息睡眠之用",{"1":{"382":1}}],["作为开发者",{"1":{"62":1}}],["打勾设置pip源",{"1":{"567":1}}],["打包的时候会占体积max",{"1":{"872":1}}],["打包的时候",{"1":{"612":1}}],["打包时留下这个prefab就可以确保这个类不被strip掉了",{"1":{"601":1}}],["打包构建插件时",{"1":{"537":1}}],["打包后",{"1":{"536":1}}],["打包插件需要使用",{"1":{"535":1}}],["打入版本号",{"1":{"509":1}}],["打开垂直同步后做相同的测试",{"1":{"854":1}}],["打开这个网站",{"1":{"560":1}}],["打开idea",{"1":{"560":1}}],["打开所有设置",{"1":{"523":1}}],["打开浏览器看一下吧",{"1":{"506":1}}],["打开命令行",{"1":{"500":1}}],["打开cmd刷新一下dns就好了",{"1":{"493":1}}],["打开hosts映射",{"0":{"492":1},"2":{"493":1,"494":1,"495":1}}],["打开",{"1":{"438":1,"533":1,"700":1}}],["打开sendto",{"1":{"407":1}}],["打开对话框questgiver",{"1":{"253":1}}],["打造武器暗器之地",{"1":{"380":1}}],["打牌",{"0":{"363":1}}],["打架",{"1":{"295":1}}],["打怪刷到的装备等级=掉装备怪物的等级",{"1":{"269":1}}],["打怪掉落",{"1":{"269":1}}],["打怪的效果也可以接受",{"1":{"18":1}}],["打通这些房间",{"1":{"224":1}}],["打印结果正相反",{"1":{"893":1}}],["打印结果",{"1":{"893":1}}],["打印",{"1":{"172":2}}],["打个tag",{"1":{"145":1}}],["打",{"1":{"85":2}}],["该插值的插值",{"1":{"1013":1}}],["该预测的预测",{"1":{"1013":1}}],["该component的版本就会+1",{"1":{"988":1}}],["该代码意图在于记住",{"1":{"965":1,"1003":1}}],["该行为的目的是为了你可以在已经被实例化的",{"1":{"965":1}}],["该行为仅仅针对",{"1":{"965":1}}],["该位置的对象也会得到包含所有子级对象的linkedentitygroup",{"1":{"965":1}}],["该模式是用于当你需要在",{"1":{"954":1}}],["该组件仅有一个",{"1":{"952":1}}],["该系统是所有",{"1":{"950":1}}],["该",{"1":{"943":1,"957":1}}],["该次任务在栈里所占的所有内存将被清理",{"1":{"885":1}}],["该变量都会被放到栈的最上面",{"1":{"885":1}}],["该间隙由上图中的红色圆圈指示",{"1":{"857":1}}],["该buff附带特效火焰和200点的碰撞伤害",{"1":{"811":1}}],["该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了",{"1":{"764":1}}],["该轴的方向才是关键的",{"1":{"762":1}}],["该属性会让两者的重叠部分会被保留",{"1":{"759":1}}],["该工具可以构建支持运行在任何环境的",{"1":{"586":1}}],["该文件中包含的程序集和命名空间列表不会执行裁剪过程",{"1":{"604":1}}],["该文件会为关联设备生成临时apk文件",{"1":{"585":1}}],["该文件可以直接发布到google",{"1":{"585":1}}],["该文件基于且扩展已发布的",{"1":{"127":1}}],["该程序运行结束后会将生成的",{"1":{"573":1}}],["该协议定义了",{"1":{"572":1}}],["该项学习力越高",{"1":{"374":1}}],["该函数首先获取事件链",{"1":{"680":1}}],["该函数",{"1":{"237":1}}],["该特效对属性的修改",{"1":{"233":1}}],["该瓦片的种类取决于记录矩阵在该点允许的选择",{"1":{"210":1}}],["该矩阵与最终输出模型大小相同",{"1":{"210":1}}],["该公式描述了上文中提及的一致性约束",{"1":{"207":1}}],["该如何连接",{"1":{"107":1}}],["该队列为其视野范围内的所有对象",{"1":{"104":1}}],["该画面在主机上设置延迟200毫秒",{"1":{"85":1}}],["该命令通过网络的方式发送至服务器",{"1":{"85":1}}],["该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节",{"1":{"37":1}}],["设想我们的新设计是每当cubemultiple",{"1":{"961":1}}],["设想一下",{"1":{"941":1}}],["设",{"1":{"756":1}}],["设定好大小",{"1":{"748":1}}],["设定该节点对应的点为当前节点",{"1":{"210":1}}],["设计上极佳的灵活性",{"1":{"955":1}}],["设计规则的重要元素",{"1":{"932":1}}],["设计job时",{"1":{"920":1}}],["设计ui时要考虑重用性",{"1":{"861":1}}],["设计的初衷也是为了gui服务的",{"1":{"652":1}}],["设计分辨率为1280",{"1":{"628":1}}],["设计类游戏",{"1":{"84":1}}],["设备永久了",{"1":{"481":1}}],["设为",{"1":{"405":1}}],["设施建造",{"0":{"380":1}}],["设施",{"0":{"376":1}}],["设输入模型为",{"1":{"207":1}}],["设置每个对象的渲染状态",{"1":{"876":1}}],["设置颜色",{"1":{"876":1}}],["设置一个新的值给这个component",{"1":{"739":1,"744":1}}],["设置透视相机来渲染视差层",{"1":{"737":1}}],["设置合适的精灵排序就会变的困难",{"1":{"737":1}}],["设置时",{"1":{"722":1}}],["设置其父类型",{"1":{"714":1}}],["设置的值",{"1":{"976":1}}],["设置的",{"1":{"694":1}}],["设置",{"1":{"690":1,"965":1}}],["设置成compressed",{"1":{"867":1}}],["设置成",{"1":{"592":1}}],["设置下载路径设置部署脚本",{"1":{"540":1}}],["设置构建命令设置构建物",{"1":{"539":1}}],["设置虽然适用于计算机上的所有操作",{"1":{"524":1}}],["设置应用于所有操作",{"1":{"524":1}}],["设置应用于子文件夹中的所有项目",{"1":{"524":1}}],["设置这里的",{"1":{"509":1}}],["设置为false",{"1":{"699":1}}],["设置为",{"1":{"155":1,"687":2,"695":2}}],["设置为西班牙语",{"1":{"152":1}}],["设置了predictionstarttick和appliedtickghostpredictionsystemgroup",{"1":{"1013":1}}],["设置了",{"1":{"12":1,"1013":1}}],["滞后",{"1":{"83":1}}],["渲染越靠后",{"1":{"1036":1}}],["渲染边界是一个矩形",{"1":{"1025":1}}],["渲染api",{"1":{"979":1}}],["渲染的顺序并不是完全按照物体几何中心离相机的距离进行排序",{"1":{"1037":1}}],["渲染的",{"1":{"951":1}}],["渲染的先后顺序都和距离摄像机的距离有关",{"1":{"695":1}}],["渲染",{"1":{"905":1}}],["渲染统计窗口",{"0":{"877":1}}],["渲染状态",{"1":{"876":1}}],["渲染到内存比渲染到屏幕更快",{"1":{"759":1}}],["渲染器会使用外推法",{"1":{"83":1}}],["渲染场景",{"1":{"41":1}}],["增强了unity生成il的能力",{"1":{"823":1}}],["增长百分比为",{"1":{"456":1}}],["增长百分比变量",{"1":{"456":1}}],["增量地",{"1":{"970":1}}],["增量编译",{"1":{"605":1}}],["增量式的均匀采样方法",{"1":{"214":1}}],["增量快照",{"1":{"82":1}}],["增加奇怪技能",{"1":{"811":1}}],["增加了一种新的法术场",{"1":{"801":1}}],["增加了一个",{"1":{"455":1}}],["增加同步负担",{"1":{"795":1}}],["增加复刻的仓库作为上游远程仓库",{"0":{"543":1}}],["增加0",{"1":{"395":1}}],["增加身法伤害的1",{"1":{"395":1}}],["增加力道伤害的1",{"1":{"395":1}}],["增加1点护甲",{"1":{"395":2}}],["增加15点耕地有1",{"1":{"290":1}}],["增加元气伤害的1",{"1":{"395":1}}],["增加金钱",{"1":{"387":1}}],["增加声望",{"1":{"387":3}}],["增加最大能量护盾每2智力=1魔力a",{"1":{"384":1}}],["增加血和蓝",{"1":{"300":1}}],["增加体力和非战斗相关的buff",{"1":{"300":1}}],["增加防御",{"1":{"247":1}}],["增加易用性",{"1":{"176":1}}],["增加tickrate通常可以提高运动和射击精度",{"1":{"86":1}}],["增加采样率可以减轻这种影响",{"1":{"46":1}}],["秒钟的数据",{"1":{"451":1}}],["秒钟数据的说法",{"1":{"449":1}}],["秒的数据",{"1":{"451":1}}],["秒的",{"1":{"449":1}}],["秒的流量",{"1":{"82":1}}],["秒内所产生的所有数据",{"1":{"449":1}}],["秒",{"1":{"82":1,"449":4}}],["快捷方式",{"0":{"429":1}}],["快捷方式等",{"1":{"428":1}}],["快指针继续向后面4个格子移动",{"1":{"108":1}}],["快的指针每次移动4个",{"1":{"108":1}}],["快慢针实现",{"1":{"108":1}}],["快慢针",{"0":{"108":1}}],["快照会包含该tick",{"1":{"1014":1}}],["快照速率和视图延迟插值之间的关系如下",{"1":{"86":1}}],["快照更新速率由服务器tickrate限制",{"1":{"86":1}}],["快照",{"1":{"82":1,"86":1}}],["快速查看和修改运行时的对象非常有用",{"1":{"971":1}}],["快速的数据库里查询数据",{"1":{"944":1}}],["快速控制器的基本操作我們就不在這裡贅述",{"1":{"632":1}}],["快速开始",{"0":{"508":1}}],["快速排序由c",{"1":{"107":1}}],["快速排序",{"1":{"107":1}}],["快速转向等",{"1":{"76":1}}],["快速追回当前操作",{"1":{"15":1}}],["默认只有一个",{"1":{"1039":1}}],["默认值",{"1":{"1036":1}}],["默认值为",{"1":{"456":1}}],["默认appdomain才会随之消失",{"1":{"707":1}}],["默认都是存在c盘下",{"1":{"526":1}}],["默认转换为",{"1":{"506":1}}],["默认布局位于",{"1":{"497":1}}],["默认使用的是国外的源",{"1":{"478":1}}],["默认是",{"1":{"413":1}}],["默认所有都不缓存",{"1":{"411":1}}],["默认项目设置为相关链接",{"1":{"132":1}}],["默认比例",{"1":{"120":1}}],["默认512",{"1":{"99":1}}],["默认的npc",{"0":{"257":1}}],["默认的回调函数",{"1":{"228":1}}],["默认的",{"1":{"151":1,"153":1,"164":1}}],["默认的cl",{"1":{"86":1}}],["默认的插值延迟为0",{"1":{"86":1}}],["默认的网络设置是专门为通过互联网连接的游戏服务器设计的",{"1":{"86":1}}],["默认20",{"1":{"82":1}}],["默认情况下不会引用",{"1":{"722":1}}],["默认情况下启用此选项",{"1":{"703":1}}],["默认情况下配置文件为assets",{"1":{"700":1}}],["默认情况下",{"1":{"82":1,"158":1,"456":1,"822":1,"917":1,"1037":1}}],["运权",{"1":{"389":1}}],["运标",{"1":{"377":1}}],["运功调息躲过一劫",{"1":{"295":1}}],["运算",{"1":{"197":1}}],["运行在这里",{"1":{"965":1}}],["运行在其后",{"1":{"949":1}}],["运行在每秒60帧的情况下",{"1":{"815":1}}],["运行后我们会发现输出",{"1":{"717":1}}],["运行无反应",{"0":{"563":1}}],["运行一个",{"1":{"510":1}}],["运行线程会把函数的参数和局部变量压入线程栈上",{"1":{"131":1}}],["运行时库",{"0":{"591":1}}],["运行时库则提供诸如垃圾回收",{"1":{"589":1}}],["运行时的版本号",{"1":{"991":1}}],["运行时的另外一个重要的部分",{"1":{"591":1}}],["运行时的npc",{"0":{"258":1}}],["运行时的类型安全检查也离不开它",{"1":{"131":1}}],["运行时也可以脱离jit了",{"1":{"130":1}}],["运行时在执行期间会根据需要从文件中查找并提取元数据",{"1":{"127":1}}],["运行",{"0":{"131":1},"1":{"128":1,"407":1}}],["运行高效",{"1":{"120":1}}],["运行当前生产环境中的应用",{"1":{"88":1}}],["运行物理模拟步",{"1":{"82":1}}],["运营可以为玩家每日不同步可结算的次数设定一个阈值",{"1":{"15":1}}],["基础上运行",{"1":{"940":1}}],["基础内存维护",{"0":{"816":1},"2":{"817":1,"818":1,"819":1,"820":1,"821":1,"822":1,"823":1,"824":1,"825":1}}],["基础最大值",{"1":{"384":1}}],["基础爆击伤害",{"1":{"384":1}}],["基础腿法长拳掌招防御",{"1":{"377":1}}],["基础武学要扎稳啊",{"1":{"374":1}}],["基础武学越扎稳该项六力",{"1":{"374":1}}],["基础结构提供",{"1":{"129":1}}],["基准调越高",{"1":{"372":1}}],["基类的引用",{"1":{"131":1}}],["基本的逻辑是",{"1":{"791":1}}],["基本思路就是对stack的操作",{"1":{"715":1}}],["基本概念",{"0":{"406":1,"844":1},"2":{"845":1}}],["基本属性i",{"1":{"384":1}}],["基本上所有",{"1":{"971":1}}],["基本上都可以在",{"1":{"632":1}}],["基本上黑屏重启都是cpu的温度造成的",{"1":{"551":1}}],["基本上",{"1":{"197":1}}],["基本上每个人都知道的是",{"1":{"130":1}}],["基本原理",{"0":{"197":1,"207":1}}],["基本网络模型",{"0":{"82":1}}],["基于正在使用的脚本后端",{"1":{"821":1}}],["基于以上思想",{"1":{"800":1}}],["基于il虚拟机或者",{"1":{"716":1}}],["基于前面的反射",{"1":{"716":1}}],["基于appdomain内嵌的invoke来实现反射",{"0":{"715":1}}],["基于其",{"1":{"714":1}}],["基于代码来分析",{"1":{"714":1}}],["基于loadedtypes这种来获取热更新中的dll",{"1":{"714":1}}],["基于loadedtypes来实现反射方法的调用",{"0":{"714":1}}],["基于www的方式加载assetbundle或者dll",{"1":{"711":1}}],["基于新的游戏状态",{"1":{"69":1}}],["基于",{"1":{"69":2,"942":1}}],["基于服务器的这种情况",{"1":{"50":1}}],["基于这个引用",{"1":{"716":1}}],["基于这个原因",{"1":{"50":1}}],["基于这四步操作",{"1":{"713":1}}],["基于这种考虑",{"1":{"41":1}}],["基于c",{"1":{"42":1}}],["基于half",{"1":{"42":1}}],["基于客户端的状态同步",{"0":{"17":1},"2":{"18":1,"19":1,"20":1}}],["哦好冷啊你很开心是因为你瞄准目标头部并射击",{"1":{"79":1}}],["比对networkidcomponent和ghostownercomponent的id",{"1":{"1013":1}}],["比起以上两种批处理",{"1":{"981":1}}],["比起之前建立这些键的状态所使用命令的数量要大大减少",{"1":{"454":1}}],["比武大会",{"0":{"329":1}}],["比较同样也是按照降序进行的",{"1":{"695":1}}],["比较physicsraycaster",{"1":{"695":2}}],["比较sortingorder",{"1":{"695":1}}],["比较也是按照从大到小的顺序得到最终的结果",{"1":{"695":1}}],["比较",{"1":{"695":2,"858":1,"971":1}}],["比较重要的就是获取事件链的过程",{"1":{"680":1}}],["比较业务向也就不再写了",{"1":{"673":1}}],["比较推荐768",{"1":{"568":1}}],["比较小的",{"1":{"568":1}}],["比较之下",{"1":{"372":1}}],["比较特别的元素",{"1":{"221":1}}],["比较幸运的是有一个相对简单的解决方案",{"1":{"79":1}}],["比客户端大一点",{"1":{"103":1}}],["比方说",{"1":{"85":1}}],["比如镜头光晕可以看到",{"1":{"1036":1}}],["比如debug",{"1":{"997":1}}],["比如调整transform后里面更新到",{"1":{"971":1}}],["比如通过在可以在",{"1":{"964":1}}],["比如child",{"1":{"959":1,"1002":1}}],["比如为了减少",{"1":{"1037":1}}],["比如为每个",{"1":{"957":1}}],["比如为什么在一定情况下我们使用stringbuilder代替string+string+string+string",{"1":{"898":1}}],["比如我在",{"1":{"953":1}}],["比如我们经常需要处理鼠标的相关事件",{"1":{"841":1}}],["比如我们经常要把世界三维坐标系转换成我们最终屏幕中的二维坐标系",{"1":{"840":1}}],["比如我们上面",{"1":{"681":1}}],["比如我们常说的墨菲斯托的tc=78",{"1":{"267":1}}],["比如我们从圆周率π",{"1":{"197":1}}],["比如当你有个巨大的",{"1":{"952":1}}],["比如上图",{"1":{"947":1}}],["比如上图中",{"1":{"12":1}}],["比如看着一个球在屏幕上下移动",{"1":{"940":1}}],["比如方块可能有个",{"1":{"940":1}}],["比如添加移除component",{"1":{"908":1}}],["比如hybird",{"1":{"905":1}}],["比如传入的参数是",{"1":{"903":1}}],["比如欧拉角的旋转",{"1":{"842":1}}],["比如你有这么个需求",{"1":{"841":1}}],["比如你掉出去的房间",{"1":{"225":1}}],["比如显示一个按钮控制游戏",{"1":{"841":1}}],["比如各种插件代码",{"1":{"839":1}}],["比如结构体和枚举器",{"1":{"823":1}}],["比如int和float",{"1":{"820":1}}],["比如法术场检测",{"1":{"802":1}}],["比如技能能否直接对单位造成伤害",{"1":{"799":1}}],["比如根据不同的上下文确定技能的执行流程",{"1":{"795":1}}],["比如以一定的顺序执行一系列子技能",{"1":{"795":1}}],["比如顺序结点包括原子属性和循环属性",{"1":{"795":1}}],["比如冲锋斩",{"1":{"794":1}}],["比如三段击",{"1":{"794":1}}],["比如某些循环技能",{"1":{"793":1}}],["比如游戏中玩家可以选择使用哪些技能",{"1":{"792":1}}],["比如五角星",{"1":{"788":1}}],["比如最远的背景由于基本上都是简单的平铺可以使用",{"1":{"734":1}}],["比如打ios安装包的时候",{"1":{"709":1}}],["比如这些事件要穿透啦",{"1":{"666":1}}],["比如键盘或控制器按钮的事件就没有办法捕获了",{"1":{"653":1}}],["比如设备分辨率为1920",{"1":{"628":1}}],["比如竖屏游戏",{"1":{"623":1}}],["比如google",{"1":{"607":1}}],["比如静态文件",{"1":{"581":1}}],["比如wsgi",{"1":{"580":1}}],["比如apache就可以说内置了php模块",{"1":{"580":1}}],["比如基于",{"1":{"573":1}}],["比如说场景加载时",{"1":{"815":1}}],["比如说一帧内实例化100个",{"1":{"699":2}}],["比如说",{"1":{"443":1,"444":2,"445":1,"701":1}}],["比如说以贴图中某个点周围的不仅上下左右",{"1":{"207":1}}],["比如jquery需要额外安装类型声明包",{"1":{"398":1}}],["比如异常状态和眩晕",{"1":{"385":1}}],["比如聚财是特殊人物钱广进的特性",{"1":{"378":1}}],["比如普通",{"1":{"293":1}}],["比如屋顶瓦片的颜色",{"1":{"287":1}}],["比如如果玩家在附近",{"1":{"283":1}}],["比如按最低的68白怪掉的一个战帽",{"1":{"270":1}}],["比如按照b的预测",{"1":{"15":1}}],["比如图中的绿框内是前缀",{"1":{"270":1}}],["比如状态",{"1":{"257":1}}],["比如火系弓箭技能",{"1":{"250":1}}],["比如眩晕等",{"1":{"241":1}}],["比如动物",{"1":{"220":1}}],["比如输出模型是10",{"1":{"210":1}}],["比如用于提前生成游戏地形等",{"1":{"204":1}}],["比如在转换",{"1":{"959":1}}],["比如在startup类中",{"1":{"174":1}}],["比如在射击游戏中爆掉敌人的头",{"1":{"78":1}}],["比如古老的386指令集",{"1":{"130":1}}],["比如链表长度为10",{"1":{"108":1}}],["比如x坐标1到x坐标4为一个格子我们",{"1":{"107":1}}],["比如z的x轴位置是5",{"1":{"106":1}}],["比如激活ai等",{"1":{"102":1}}],["比如射击或者移动物体",{"1":{"77":1}}],["比如一把枪",{"1":{"1007":1}}],["比如一件执政官铠甲",{"1":{"271":1}}],["比如一个",{"1":{"944":1,"1000":1}}],["比如一个3d物体可能会包含用于transform的组件",{"1":{"905":1}}],["比如一个text的层级为0",{"1":{"862":1}}],["比如一个技能",{"1":{"801":1}}],["比如一个顺序节点",{"1":{"795":1}}],["比如一个案例",{"1":{"657":1}}],["比如一个scene的尺寸为1200",{"1":{"99":1}}],["比如一个玩家射击另一个玩家的时候",{"1":{"76":1}}],["比如一定要5s定时执行",{"1":{"30":1}}],["比如更多的位置采样点",{"1":{"76":1}}],["比如3d射击",{"1":{"76":1}}],["比如策略游戏或者棋牌类的游戏",{"1":{"64":1}}],["比如加速齿轮",{"1":{"51":1}}],["比如500ms",{"1":{"48":1}}],["比如每秒10次",{"1":{"46":1}}],["比如quake限制不能超过100ms",{"1":{"46":1}}],["比如即时射击武器",{"1":{"45":1}}],["比如弹药",{"1":{"44":1}}],["比如身上有哪些武器",{"1":{"44":1}}],["比如玩家是或者还是已经已经死掉",{"1":{"47":1}}],["比如玩家蹲下来眼睛的位置",{"1":{"43":1}}],["比如玩过早期的冰封王座都知道",{"1":{"12":1}}],["比如位置",{"1":{"43":1}}],["比如半条命以及其修改版反恐精英",{"1":{"41":1}}],["比如utf",{"1":{"39":1}}],["比如血量最少的玩家",{"1":{"20":1}}],["比如100ms前做一个",{"1":{"14":1}}],["比如",{"1":{"12":1,"37":1,"63":1,"66":1,"70":1,"102":1,"204":1,"220":1,"225":1,"269":1,"536":1,"576":1,"601":1,"663":1,"696":1,"701":1,"798":1,"807":1,"811":1,"912":1,"947":1,"960":1,"962":1,"979":1,"980":1,"1037":1}}],["架构",{"1":{"79":1}}],["处声明的",{"1":{"965":1}}],["处隐含了",{"1":{"952":1}}],["处世",{"1":{"393":1}}],["处理命令",{"1":{"1013":2}}],["处理命令请求",{"1":{"455":1}}],["处理射线检测",{"1":{"695":1}}],["处理输入事件首先看看",{"1":{"669":1}}],["处理输入事件并找到合适的接收者",{"1":{"657":1}}],["处理physics",{"0":{"662":1},"2":{"663":1,"664":1,"665":1}}],["处理函数可以使用两种函数参数",{"1":{"657":1}}],["处理完成后",{"1":{"576":1}}],["处理完再把进程",{"1":{"575":1}}],["处理ai事件",{"1":{"260":1}}],["处理请求",{"1":{"169":1}}],["处理http请求",{"0":{"168":1},"2":{"169":1,"170":1}}],["处理新接入的用户请求",{"1":{"167":1}}],["处理用户的http请求",{"1":{"167":1}}],["处理任务",{"1":{"30":1,"393":1}}],["处于",{"1":{"78":2}}],["之和决定",{"1":{"1040":1}}],["之",{"1":{"977":1}}],["之間的",{"1":{"977":1}}],["之後該畫布再畫在最終的畫面上",{"1":{"977":1}}],["之後就",{"1":{"373":1}}],["之中",{"1":{"952":1}}],["之所以linkedentitygroup包含它自己是因为",{"1":{"965":1}}],["之所以在",{"1":{"964":1}}],["之所以没有被称为",{"1":{"947":1}}],["之所以这种方式称之为",{"1":{"942":1}}],["之上",{"1":{"885":1}}],["之外",{"1":{"844":1}}],["之间的向量在",{"1":{"694":1}}],["之间的通信",{"1":{"576":1}}],["之间",{"1":{"688":1}}],["之类的",{"1":{"287":1,"666":1}}],["之前那些",{"1":{"969":1}}],["之前剔除掉无法被看到的东西",{"1":{"943":1}}],["之前说过",{"1":{"916":1}}],["之前不是说过",{"1":{"847":1}}],["之前",{"1":{"577":1,"965":1,"991":1}}],["之前永久区存放的东西基本上放到了元空间中",{"1":{"122":1}}],["之前的玩家的头",{"1":{"79":1}}],["之前三篇文章主要解释了关于",{"1":{"78":1}}],["之后使用",{"1":{"966":1}}],["之后被添加",{"1":{"965":1}}],["之后做事情",{"1":{"949":1}}],["之后执行",{"1":{"949":1}}],["之后",{"1":{"741":1,"835":1,"966":1,"991":1,"1036":1}}],["之后再销毁spawnhereecs以避免重复实例化",{"1":{"966":1}}],["之后再获取该类型entity的复杂度就只有o",{"1":{"738":1}}],["之后再广播给所有的玩家",{"1":{"11":1}}],["之后是移动",{"1":{"734":1}}],["之后就称之为混合滚动方式",{"1":{"725":1}}],["之后就称之为照相机移动方式",{"1":{"725":1}}],["之后就称之为精灵滚动方式",{"1":{"725":1}}],["之后就称之为",{"1":{"725":1}}],["之后处理move以及drag事件",{"0":{"673":1}}],["之后寻找pointclick事件",{"1":{"672":1}}],["之后baseinputmodule的process接口才会被调用",{"1":{"654":1}}],["之后才会部署到设备上",{"1":{"586":1}}],["之后的讨论均假设",{"1":{"102":1}}],["之后所发生的变化",{"1":{"82":1}}],["之后继续执行104帧",{"1":{"15":1}}],["别的玩家看你的位置也不是正确的",{"1":{"77":1}}],["移除任何",{"1":{"936":1}}],["移除单个entity中的组件",{"1":{"908":1}}],["移除背景纹理和其他不透明纹理的alpha通道",{"1":{"872":1}}],["移除空的monobehaviour方法start",{"1":{"858":1}}],["移除了致命的延迟",{"1":{"77":1}}],["移动端数量有浮动",{"1":{"981":1}}],["移动端支持的个数可能较低",{"1":{"981":1}}],["移动时",{"1":{"726":1}}],["移动照相机形成滚动",{"1":{"725":1}}],["移动形成滚动",{"1":{"725":1}}],["移动",{"1":{"254":1}}],["移动所有存活的对象",{"1":{"119":1}}],["移动路径上的玩家被忽视了",{"1":{"104":1}}],["移动一格花费100ms",{"1":{"68":1}}],["移动的延迟补偿",{"0":{"57":1}}],["移动到最新目标点进行插值这种方法效果欠佳",{"1":{"50":1}}],["移动玩家周围物体",{"1":{"41":1}}],["航位推就没用了",{"1":{"77":1}}],["航位推算法就非常无力了",{"1":{"76":1}}],["航位推测法",{"0":{"75":1}}],["校正可以是大的或相对小的",{"1":{"75":1}}],["校验包客户端有没有修改时间",{"1":{"56":1}}],["赛车不能立即进行180度转弯",{"1":{"75":1}}],["速度如何决定并没有统一的方法或是模式",{"1":{"734":1}}],["速度会受到影响",{"1":{"707":1}}],["速度对比",{"0":{"495":1}}],["速度",{"1":{"77":1}}],["速度和方向",{"1":{"75":1}}],["速度已知",{"1":{"46":1}}],["汽车的位置被修正",{"1":{"75":1}}],["汽车的机动性是这样的",{"1":{"75":1}}],["汽车可能加速或减速了一点",{"1":{"75":1}}],["误差",{"0":{"70":1}}],["输出渲染图元",{"1":{"876":1}}],["输出hello",{"1":{"592":1}}],["输出的中间语言",{"1":{"589":1}}],["输出流和环境变量来与",{"1":{"574":1}}],["输出模型",{"1":{"208":1}}],["输出模型为",{"1":{"207":1}}],["输出",{"1":{"208":1}}],["输出将会是",{"1":{"155":1}}],["输出是玩家操作以后的状态",{"1":{"43":1}}],["输入的时候",{"1":{"1014":1}}],["输入命令",{"1":{"1013":1}}],["输入",{"1":{"722":1}}],["输入密码的时候不会显示出来",{"1":{"463":1}}],["输入以下命令然后会要求输入新密码",{"1":{"463":1}}],["输入数据有任何细微的不同",{"1":{"201":1}}],["输入预测",{"0":{"84":1}}],["输入就是向右移动",{"1":{"69":1}}],["=>",{"1":{"818":2}}],["=>x",{"1":{"657":1}}],["=new",{"1":{"750":1}}],["==1",{"1":{"780":1}}],["==",{"1":{"460":1,"780":1,"822":1}}],["=",{"1":{"68":6,"69":1,"91":2,"103":15,"270":5,"303":1,"385":1,"424":5,"618":2,"625":6,"628":2,"737":1,"756":16,"780":1,"781":1,"817":2,"818":3,"820":2,"822":1,"823":1,"824":14,"846":1,"898":1,"954":1,"977":1,"992":3}}],["给定一个坐标",{"1":{"1025":1}}],["给定一个游戏状态和一些列的输入",{"1":{"67":1}}],["给它",{"1":{"968":1}}],["给",{"1":{"952":3,"954":1}}],["给方块",{"1":{"944":1}}],["给结构体添加所需的成员变量",{"1":{"920":1}}],["给需要碰撞检测的gameobject",{"1":{"664":1}}],["给他丹药+道德",{"1":{"295":1}}],["给属性打标签根据标签",{"1":{"15":1}}],["单步执行得出的",{"1":{"1040":1}}],["单次",{"1":{"947":1}}],["单次调用",{"1":{"947":1}}],["单次对时往往会受到网络波动的影响",{"1":{"51":1}}],["单独创建",{"1":{"957":1}}],["单独建立buff表",{"1":{"810":1}}],["单独使用",{"1":{"176":1}}],["单位的属性由基础成长属性+装备属性+buff属性构成",{"1":{"809":1}}],["单位播放动作以及相应的技能特效",{"1":{"802":1}}],["单位也会执行完挥砍后才会推出技能",{"1":{"795":1}}],["单位售价",{"1":{"303":1}}],["单击",{"1":{"542":1,"841":1,"1021":1}}],["单个项目占据的主轴空间叫做",{"1":{"406":1}}],["单手斧",{"1":{"384":1}}],["单手锤",{"1":{"384":1}}],["单背景",{"1":{"287":1}}],["单人每秒多少",{"1":{"97":1}}],["单体项目逐渐划分为分布式系统",{"1":{"91":1}}],["单纯地依赖这种模型会导致玩家输入命令和画面更新之间的延迟感",{"1":{"66":1}}],["沿着直线传播",{"1":{"64":1}}],["沿着自己的弹道向前移动",{"1":{"46":1}}],["光照贴图",{"1":{"845":1}}],["光标文件",{"1":{"845":1}}],["光线投射法",{"0":{"760":1}}],["光环",{"1":{"394":1}}],["光传播的速度大概是300000km",{"1":{"64":1}}],["光从对时的角度来看",{"1":{"51":1}}],["数量正常",{"1":{"971":1}}],["数量巨大",{"1":{"941":1}}],["数量综合决定的",{"1":{"427":1}}],["数量和",{"1":{"427":1}}],["数量",{"1":{"427":1,"960":1}}],["数量是相对独立的",{"1":{"73":1}}],["数组按照",{"1":{"684":1}}],["数组中得到的",{"1":{"201":1}}],["数组",{"1":{"201":1,"684":1,"718":1}}],["数组的用法",{"1":{"199":1}}],["数组长度为256",{"1":{"199":1}}],["数组就行了",{"1":{"199":1}}],["数据变化",{"0":{"989":1},"2":{"990":1,"991":1,"992":1,"993":1,"994":1,"995":1,"996":1}}],["数据喂给",{"1":{"943":1}}],["数据在ecs里类似数据库",{"1":{"941":1}}],["数据",{"1":{"940":1,"942":1,"944":1}}],["数据的自由列表",{"1":{"929":1}}],["数据库连接",{"1":{"898":1}}],["数据迁移上下文",{"0":{"136":1},"2":{"137":1}}],["数据节等",{"1":{"131":1}}],["数据c保存到虚拟节点redis1",{"1":{"96":1}}],["数据c被保存到redis4中",{"1":{"95":1}}],["数据存储不平衡",{"1":{"96":1}}],["数据b对应的节点保存到redisservice3中",{"1":{"94":1}}],["数据b被定为到server",{"1":{"92":1}}],["数据a会被定为到server",{"1":{"92":1}}],["数据包延迟",{"1":{"85":1}}],["数据是由无数个路由经过一系列的跳",{"1":{"64":1}}],["数据传播的底层可能是光的脉冲",{"1":{"64":1}}],["数字和货币格式的结果",{"1":{"155":1}}],["数字",{"1":{"32":1}}],["两物体的投影存在间隙",{"1":{"761":1}}],["两物体必须是矩形",{"1":{"753":1}}],["两直线交点在桶口的左右边沿间",{"1":{"760":1}}],["两点之间的距离公式",{"1":{"755":1}}],["两点之间的距离由以下公式可得",{"1":{"754":1}}],["两矩形间碰撞的各种情况",{"1":{"753":1}}],["两者都按照期望被转换了",{"1":{"971":1}}],["两者都是",{"1":{"971":1}}],["两者相除就得到最终的",{"1":{"694":1}}],["两者便会都接收不到点击事件",{"1":{"657":1}}],["两者底层的通信协议的规范",{"1":{"575":1}}],["两个黄金规则",{"0":{"884":1}}],["两个三角面片要求绘制出不同的颜色",{"1":{"847":1}}],["两个玩家移动对战",{"1":{"841":1}}],["两个逻辑互不依赖",{"1":{"807":1}}],["两个五边形就需要检测10个角度",{"1":{"783":1}}],["两个随机点确定的矩形",{"0":{"773":1}}],["两个选择给出不同的效果",{"1":{"737":1}}],["两个",{"1":{"695":1,"947":1,"971":1}}],["两个键的数据",{"1":{"452":1}}],["两个操作都会阻塞主进程",{"1":{"451":1}}],["两个步骤都需要根据一定的条件来执行",{"1":{"446":1}}],["两个的运行效率根本不是一个等级的",{"1":{"130":1}}],["两篇参考文献制定出评估对称性对抗游戏地图平衡性的两点指标",{"1":{"213":1}}],["两倍的实例数",{"1":{"89":1}}],["两地相距4000km或者2500英里",{"1":{"64":1}}],["两种模式都有各自的意义",{"1":{"954":1}}],["两种理解方式",{"0":{"53":1},"2":{"54":1,"55":1,"56":1}}],["两种基本的判断机制是",{"1":{"46":1}}],["下方是",{"1":{"971":1}}],["下方在线运行示例",{"1":{"760":1}}],["下文你会看到这不只是处理方式的问题",{"1":{"961":1}}],["下文称之为",{"1":{"950":1}}],["下行一半不能确定",{"1":{"803":1}}],["下行",{"1":{"803":1}}],["下是否同时存在非透明的像素",{"1":{"759":1}}],["下同",{"1":{"753":1}}],["下拉列表中使用",{"1":{"722":1}}],["下所有",{"1":{"695":1}}],["下所有的",{"1":{"688":1,"691":1}}],["下图呈现了转换全过程",{"1":{"1054":1}}],["下图中",{"1":{"960":1}}],["下图是视口坐标系和鼠标在屏幕上的坐标系的转换结果",{"1":{"841":1}}],["下图是该点在2维空间上的表示",{"1":{"197":1}}],["下图设置成0",{"1":{"639":1}}],["下建一个空的prefab",{"1":{"601":1}}],["下一步",{"1":{"885":1,"896":1}}],["下一次我们会深入到il2cpp",{"1":{"595":1}}],["下一个技能可以执行",{"1":{"796":1}}],["下一个参数是il2cpp",{"1":{"592":1}}],["下一个请求来时再创建新进程",{"1":{"574":1}}],["下一个tick所有task都会reset",{"1":{"278":1}}],["下一个视图帧渲染时间是当前客户端的时间10",{"1":{"83":1}}],["下的",{"1":{"585":1}}],["下載",{"1":{"566":1,"567":1}}],["下載並安裝",{"0":{"566":1,"567":1}}],["下载模型",{"0":{"568":1}}],["下载ja",{"0":{"555":1}}],["下载idea",{"0":{"554":1}}],["下载代码进行编译安装",{"1":{"472":1}}],["下载",{"1":{"411":1}}],["下场比武+名气",{"1":{"295":1}}],["下午10",{"1":{"290":1}}],["下",{"1":{"228":1,"656":1,"695":1,"977":1}}],["下次分配内存时就从指针指的位置开始",{"1":{"131":1}}],["下次可开火时间",{"1":{"44":1}}],["下面这样的代码并无法按你所设想的那样工作",{"1":{"967":1}}],["下面以",{"1":{"933":1}}],["下面示例展示了第一种实现方式",{"1":{"759":1}}],["下面列举在",{"1":{"759":1}}],["下面给出该公式的推导过程",{"1":{"756":1}}],["下面一个方法",{"1":{"885":1}}],["下面一步就到了使用这两个属性来阻断射线检测部分",{"1":{"689":1}}],["下面一排是地面",{"1":{"225":1}}],["下面我们从",{"1":{"755":1}}],["下面我们看下去也可以知道到底是为啥",{"1":{"667":1}}],["下面我们就来看看",{"1":{"166":1}}],["下面就来让我们好好看看这套",{"1":{"661":1}}],["下面用一张图来解释",{"1":{"639":1}}],["下面罗列了一些保证",{"1":{"610":1}}],["下面",{"1":{"437":1}}],["下面有一些",{"1":{"411":1}}],["下面有个2维空间下的例子",{"1":{"197":1}}],["下面是代码",{"1":{"966":1}}],["下面是我的计划",{"1":{"966":1}}],["下面是方法",{"1":{"909":1}}],["下面是图解",{"1":{"896":1}}],["下面是值类型传递在栈里的内幕",{"1":{"891":1}}],["下面是当代码运行时会产生的一个详细过程",{"1":{"890":1}}],["下面是栈里发生的情况",{"1":{"885":1}}],["下面是",{"1":{"225":1}}],["下面是一个类和一个结构类型",{"1":{"895":1}}],["下面是一个比较大的struct结构类型",{"1":{"891":1}}],["下面是一个简单的例子",{"1":{"111":1}}],["下面是一个进行深拷贝的简单例子",{"1":{"111":1}}],["下面两张图显示了玩家初始占位符分布密度不同导致游戏性不平衡的情况",{"1":{"213":1}}],["下面两张图显示了两名玩家战略特征不平衡的情况",{"1":{"213":1}}],["下面通过一副彩色图",{"1":{"197":1}}],["下面的例子中",{"1":{"971":1}}],["下面的例子指定了具体的区域性",{"1":{"152":1}}],["下面的",{"1":{"943":1,"955":1}}],["下面的是一个对上面代片段实现iequalitycomparer的简单例子",{"1":{"822":1}}],["下面的代码会将x改变成",{"1":{"891":1}}],["下面的代码在vertices数组的每次迭代中虚拟的创造了四份拷贝",{"1":{"824":1}}],["下面的代码片段举出了一个简单的例子展示了装箱的问题",{"1":{"822":1}}],["下面的代码是一个非常简单的例子",{"1":{"817":1}}],["下面的图都是西方游戏的设计",{"1":{"287":1}}],["下面的曲线图中",{"1":{"86":1}}],["下面考虑另一种情况",{"1":{"95":1}}],["下面来解释一下它的工作流程",{"1":{"79":1}}],["下面来谈一些物理的问题",{"1":{"64":1}}],["总是会包含它自己",{"1":{"965":1,"1002":1}}],["总是可以在两个有效快照之间进行平滑插值",{"1":{"83":1}}],["总而言之",{"1":{"846":1}}],["总之它们会最终参与",{"1":{"952":1}}],["总之",{"1":{"734":1,"799":1,"952":1}}],["总舵是门派中的门主所在地",{"1":{"380":1}}],["总舵",{"1":{"380":1}}],["总支薪是310元的",{"1":{"371":1}}],["总共20个城市",{"1":{"287":1}}],["总共八个点建立约束条件",{"1":{"207":1}}],["总的来讲",{"1":{"120":1}}],["总的来说ugui的事件系统并不复杂",{"1":{"682":1}}],["总的来说",{"1":{"63":1,"654":1,"793":1}}],["总有一个指针快于一个指针",{"1":{"108":1}}],["总计25个patch",{"1":{"102":1}}],["总体来说还是挺很好理解的",{"1":{"842":1}}],["总体来说",{"1":{"73":1,"815":1,"818":1,"823":1,"825":1}}],["总结some",{"1":{"737":1}}],["总结如下",{"1":{"104":1}}],["总结起来大概就是以下这些",{"1":{"78":1}}],["总结",{"0":{"49":1,"65":1,"71":1,"77":1,"80":1,"222":1,"538":1,"582":1,"682":1,"789":1,"842":1},"1":{"20":1,"287":1},"2":{"81":1}}],["把方块",{"1":{"943":1}}],["把一个system当作工具类使用",{"1":{"914":1}}],["把entities",{"1":{"910":1}}],["把它变成",{"1":{"965":1}}],["把它当成值类型来演示了",{"1":{"898":1}}],["把它想像成叠在一起的盒子",{"1":{"879":1}}],["把它编译成一个委托",{"1":{"111":1}}],["把需要进行静态批处理的模型合并到一个新的网格中",{"1":{"876":1}}],["把渲染3d场景的摄像机关掉",{"1":{"860":1}}],["把相机放到一个产生了合适旋转角度的父物体当中",{"1":{"841":1}}],["把父物体当做世界",{"1":{"841":1}}],["把后续效果剥离出来会好很多",{"1":{"810":1}}],["把技能做为一个流程也没什么错",{"1":{"810":1}}],["把这个值设置为",{"1":{"1037":1}}],["把这个脚本挂在某个物体上",{"1":{"661":1}}],["把这个网址给你的测试人员",{"1":{"610":1}}],["把用到的泛型实例都进行clr绑定",{"1":{"599":1}}],["把插件打包中不需要的文件忽略掉",{"1":{"536":1}}],["把多个小的源文件打包成单个入口文件",{"1":{"536":1}}],["把多个模块打包成一个模块",{"1":{"536":1}}],["把刚刚复制的公钥粘贴进去",{"1":{"460":1}}],["把上面显示的那串",{"1":{"459":1}}],["把不同的分舵分为练功分舵",{"1":{"382":1}}],["把未被标记的对象回收缺",{"1":{"118":1}}],["把慢指针指向快指针的位置",{"1":{"108":1}}],["把扫格子实现的地格看做一个灯塔区域",{"1":{"104":1}}],["把地图划分为很多小格子",{"1":{"103":1}}],["把服务器按照ip或主机名作为关键字进行哈希",{"1":{"92":1}}],["把常用的数据保存到redis中",{"1":{"91":1}}],["把本地的血量调到10000",{"1":{"63":1}}],["把接收到的第一个字节当作高位字节看待",{"1":{"37":1}}],["按r热加载后",{"1":{"1050":1}}],["按钮来保存play",{"1":{"971":1}}],["按钮来选中",{"1":{"966":1}}],["按钮的例子",{"1":{"955":1}}],["按钮等",{"1":{"861":1}}],["按住空格的时候让它跳的更疯狂",{"1":{"943":1}}],["按下f8编译dll按下r重载",{"1":{"1050":1}}],["按下键盘上的左箭头",{"1":{"854":1}}],["按下的情形",{"0":{"671":1}}],["按鈕",{"1":{"639":1}}],["按等级加生命或按等级同时加法力和生命",{"1":{"270":1}}],["按等级加准确",{"1":{"270":1}}],["按3递增",{"1":{"267":1}}],["按顺序分配内存即可",{"1":{"120":1}}],["按照我测试用的",{"1":{"1038":1}}],["按照这种方式渲染能节省性能",{"1":{"1037":1}}],["按照sorting",{"1":{"976":1}}],["按照材质",{"1":{"862":1}}],["按照深度",{"1":{"692":1}}],["按照官方的解释",{"1":{"652":1}}],["按照以前的做法",{"1":{"502":1}}],["按照",{"1":{"270":3}}],["按照内存地址依次排列",{"1":{"119":1}}],["按照指定的范围查找自己周围玩家",{"1":{"109":1}}],["按照其最近一个输入做预测",{"1":{"15":1}}],["按区域划分格子的方式是目前最佳的方式",{"1":{"107":1}}],["按区域划分格子该方法是把区域划分成多个格子",{"1":{"107":1}}],["按区域划分格子等方式",{"1":{"106":1}}],["按客户端iphone4s的960",{"1":{"103":1}}],["按键",{"1":{"63":1}}],["反复重用一些大小格式一样的rt资源",{"1":{"1033":1}}],["反序列化过程会因版本问题丢失掉",{"1":{"965":1}}],["反正这个工作是美术做的",{"1":{"848":1}}],["反照率",{"1":{"844":1}}],["反射一个类",{"1":{"718":1}}],["反射就是靠这个表只要一个名字就能得到属性或函数",{"1":{"131":1}}],["反之为false",{"1":{"991":1}}],["反之亦然",{"1":{"916":1}}],["反之越慢",{"1":{"724":1}}],["反之該維度的尺寸則是相對於",{"1":{"633":1}}],["反之我们建议保持默认设置",{"1":{"82":1}}],["反向旋转",{"1":{"756":1}}],["反向的就是不管浏览器同不同意",{"1":{"581":1}}],["反向代理",{"1":{"88":1,"581":1}}],["反作弊",{"0":{"62":1}}],["反弹球",{"1":{"46":1}}],["好消息是",{"1":{"964":1,"971":1}}],["好让你的游戏变得更有趣",{"1":{"940":1}}],["好像并没什么规则",{"1":{"862":1}}],["好像永远没有弹到地面一样",{"1":{"46":1}}],["好那么我们从何处入手呢",{"1":{"667":1}}],["好戏连台",{"0":{"595":1}}],["好不容易上传了一大半搞不好就因为网络原因又要重新上传",{"1":{"510":1}}],["好在",{"1":{"481":1}}],["好在国内的清华大学和中科大提供了",{"1":{"478":1}}],["好处",{"1":{"372":1}}],["好",{"1":{"372":1}}],["好看的场景",{"0":{"359":1}}],["好奇地现祭红色印记",{"1":{"296":1}}],["好言相劝",{"1":{"295":1}}],["好了",{"1":{"221":1,"222":1,"500":1,"714":1,"976":1}}],["好吧",{"1":{"591":1}}],["好吧这的确有可能发生",{"1":{"79":1}}],["好吧其实是作弊和地理限制造成的网络延时",{"1":{"61":1}}],["那你只能批处理180顶点以下的物体",{"1":{"980":1}}],["那你只用简单地把圆心投影上去",{"1":{"785":1}}],["那",{"1":{"956":1}}],["那样返回",{"1":{"946":1}}],["那样就成了一个技能执行的序列",{"1":{"793":1}}],["那如果一个job有多个依赖项怎么办呢",{"1":{"923":1}}],["那如何确定",{"1":{"761":1}}],["那如何找出矩形上离圆心最近的点呢",{"1":{"755":1}}],["那如何让柏林噪声算法模拟出这样的自然噪声特性",{"1":{"204":1}}],["那两个text的层级就一致了",{"1":{"862":1}}],["那此时2个text因为层级不同会安排2个drawcall",{"1":{"862":1}}],["那将是非常低效的",{"1":{"826":1}}],["那一列",{"1":{"815":1}}],["那只要向context询问特定的组就能立刻获取到所有符合的entity",{"1":{"740":1}}],["那会很卡",{"1":{"702":1}}],["那时候也是4",{"1":{"667":1}}],["那麼他們出現的規則是什麼呢",{"1":{"633":1}}],["那摄像机的宽度是如何确定的呢",{"0":{"618":1}}],["那些事件要做特殊处理啦",{"1":{"666":1}}],["那些没有被其他任何程序集引用到的程序集",{"1":{"592":1}}],["那些原本隐居于绝境中的人满怀着仇恨被迫重返尘世",{"1":{"297":1}}],["那它的",{"1":{"862":2}}],["那它的qlvl显然就是58",{"1":{"273":1}}],["那它就是服务器",{"1":{"580":1}}],["那uwsgi就是一个中间件",{"1":{"580":1}}],["那我们就可以通过查找引用大法",{"1":{"668":1}}],["那我们现在需要借助",{"1":{"537":1}}],["那我们能不能用这些构建工具",{"1":{"536":1}}],["那我们有办法知道究竟是哪些文件导致这个",{"1":{"535":1}}],["那我们应该分别挑选多大的频率和振幅来进行噪声计算呢",{"1":{"204":1}}],["那我们应该怎么处理输入值",{"1":{"197":1}}],["那上面的问题都可以迎刃而解了",{"1":{"510":1}}],["那上面代码就会是这样",{"1":{"124":1}}],["那等於偶而救济一下浪费时间",{"1":{"377":1}}],["那这个setpasscall的数值也会离这个30比较接近",{"1":{"877":1}}],["那这个约定就是",{"1":{"573":1}}],["那这个链表会很长",{"1":{"106":1}}],["那这就永远是砖块了",{"1":{"225":1}}],["那这一列房间有几率成为一个蛇窝",{"1":{"224":1}}],["那肯定不行了",{"1":{"224":1}}],["那也就是标准的pe文件",{"1":{"131":1}}],["那windows是怎么区分可执行文件和非可执行文件的呢",{"1":{"131":1}}],["那就相当于修改了实体的原型",{"1":{"905":1}}],["那就是仅传递原始值类型的引用",{"1":{"891":1}}],["那就是获取一种类型的entity",{"1":{"738":1}}],["那就是玩家们",{"1":{"80":1}}],["那就完全不需要进行任何处理",{"1":{"599":1}}],["那就来厘清一下这几个概念",{"1":{"577":1}}],["那就必须手动为门徒弟子安排房间",{"1":{"380":1}}],["那就设定肉15000木11000",{"1":{"376":1}}],["那就要设定卖的储存量肉3000药3000",{"1":{"376":1}}],["那就没有职业差异化了",{"0":{"251":1}}],["那就添加一个新房间",{"1":{"221":1}}],["那就表示要插入的位置是当前链表最后的位置",{"1":{"108":1}}],["那服务端主循环的逻辑有所不同了",{"1":{"73":1}}],["那个人其实已不在那个位置所以需要记录游戏的世界状态",{"1":{"59":1}}],["那么不要直接new",{"1":{"1033":1}}],["那么不妨找一名聪明较高的门人弟子",{"1":{"383":1}}],["那么gsv",{"1":{"992":1}}],["那么还缺点啥",{"1":{"971":1}}],["那么还需要在代码里进行约束",{"1":{"751":1}}],["那么结果将会像仅使用了",{"1":{"968":1}}],["那么该对象会变成完全和",{"1":{"968":1}}],["那么有没有可能在",{"1":{"966":1}}],["那么有对象在这一块区域出现消失移动你就通知我",{"1":{"104":1}}],["那么所有的",{"1":{"965":1}}],["那么所有的其他",{"1":{"688":1}}],["那么查询它们将会有点困难",{"1":{"964":1}}],["那么使用getentities",{"1":{"962":1}}],["那么使用一条",{"1":{"454":1}}],["那么使用一致性哈希算法的容错性和扩展性如何呢",{"1":{"93":1}}],["那么最终的",{"1":{"969":1}}],["那么最终该",{"1":{"944":1,"1000":1}}],["那么最简单的方式不是去",{"1":{"454":1}}],["那么mergemode是node或usefirst时",{"1":{"903":1}}],["那么此值类型将会被放在这个引用类型里并存储在堆上",{"1":{"886":1}}],["那么把它们按一千个单独的网格进行渲染所花费的时间要远大于直接渲染一个包含了一千个三角形的网格",{"1":{"876":1}}],["那么按前两种方式遍历计算所有的",{"1":{"862":1}}],["那么按照叶子节点的策略",{"1":{"805":1}}],["那么显卡每2个显示器帧才向显示器刷新一次数据",{"1":{"854":1}}],["那么游戏中作完一屏画面",{"1":{"854":1}}],["那么在转换过程中将被丢弃",{"1":{"1054":1}}],["那么在",{"1":{"951":1}}],["那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像",{"1":{"854":1}}],["那么在输出贴图中",{"1":{"207":1}}],["那么发出一个垂直同步信号后会等待1",{"1":{"854":1}}],["那么帽子也会自动变大",{"1":{"848":1}}],["那么要想让模型能够被动态批处理",{"1":{"876":1}}],["那么要绘制上图中的三角形",{"1":{"846":1}}],["那么要将该玩家从旧格子移除",{"1":{"103":1}}],["那么右上角必然就是",{"1":{"841":1}}],["那么每个ui元素对应的",{"1":{"862":1}}],["那么每个处于",{"1":{"695":1}}],["那么每次都会分配新的内存",{"1":{"828":1}}],["那么一个更好的选择是mono库的",{"1":{"828":1}}],["那么一个魔法免疫状态",{"1":{"800":1}}],["那么执行一个闭包需要在托管堆中分配一个对象",{"1":{"818":1}}],["那么垃圾回收器则不能释放这些临时对象并且托管堆需要扩张",{"1":{"815":1}}],["那么托管堆将会被扩大",{"1":{"813":1}}],["那么unity的内存管理器将执行两个操作",{"1":{"813":1}}],["那么实现方式是技能数据告诉我会播放什么样的施法动画",{"1":{"811":1}}],["那么应用程序就可以判定小球已落入桶中",{"1":{"760":1}}],["那么射线应该怎发射呢",{"1":{"750":1}}],["那么这两个图形一定没有相交",{"1":{"784":1}}],["那么这两个图形就显而易见地没有接触",{"1":{"783":1}}],["那么这两个图形就一定接触",{"1":{"783":1}}],["那么这里",{"1":{"726":1}}],["那么这个module",{"1":{"714":1}}],["那么这个项目所产生的就是非托管程序",{"1":{"127":2}}],["那么可能就需要相应尺寸的背景贴图",{"1":{"724":1}}],["那么可以成功掉落",{"1":{"275":1}}],["那么初始化操作看看",{"1":{"715":1}}],["那么接下来的readimage操作",{"1":{"711":1}}],["那么code就被直接装载到了appdomain中",{"1":{"707":1}}],["那么csc",{"1":{"125":1}}],["那么我最终将得到",{"1":{"953":1}}],["那么我就会得到两个方块",{"1":{"951":1}}],["那么我们就从最简单的说起吧",{"1":{"841":1}}],["那么我们将画布",{"1":{"756":1}}],["那么我们该怎么办呢",{"1":{"707":1}}],["那么我该怎么去建设我的地牢呢",{"1":{"219":1}}],["那么您只能通过调用",{"1":{"699":1}}],["那么对应的引用记数也会正确的减少",{"1":{"698":1}}],["那么对于接下来的所有",{"1":{"691":1}}],["那么对数据库所做的写操作就随之而消失了并没有持久化本地dump",{"1":{"442":1}}],["那么那个结果会被舍弃",{"1":{"689":1}}],["那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢",{"1":{"783":1}}],["那么会使用",{"1":{"689":1}}],["那么会怎样呢",{"1":{"94":1}}],["那么则会使用",{"1":{"689":1}}],["那么只实现ipointerclickhandler接口便是可以接收到点击事件的",{"1":{"657":1}}],["那么锚点是指一个偏移百分比",{"1":{"625":1}}],["那么也始终在中心原点",{"1":{"625":1}}],["那么无论屏幕分辨率怎么变化",{"1":{"625":1}}],["那么摄像机实际宽度按照公式算出6",{"1":{"618":1}}],["那么如果在",{"1":{"968":1}}],["那么如果设摄像机高度size值为4",{"1":{"618":1}}],["那么如何处理圆呢",{"0":{"785":1}}],["那么如何实现uwsgi和wsgi的配合呢",{"1":{"577":1}}],["那么如何解决这个问题",{"1":{"12":1}}],["那么建议你先卸载并清除数据再安装",{"1":{"554":1}}],["那么触发自动",{"1":{"456":1}}],["那么光是记录",{"1":{"453":1}}],["那么丢失数据的数量由操作系统的缓存冲洗策略决定",{"1":{"451":1}}],["那么用户损失的数据是可以超过",{"1":{"449":1}}],["那么用户最多损失小于",{"1":{"449":1}}],["那么程序执行",{"1":{"449":3}}],["那么程序直接返回",{"1":{"449":1}}],["那么它就会使用",{"1":{"942":1}}],["那么它就会运行",{"1":{"813":1}}],["那么它将在默认",{"1":{"964":1}}],["那么它将永远不会被gc清理",{"1":{"898":1}}],["那么它将生成协议文本",{"1":{"445":1}}],["那么它的",{"1":{"862":1}}],["那么它的上下左右四个点的颜色必须是",{"1":{"207":1}}],["那么它每秒就会分配60kb的内存",{"1":{"815":1}}],["那么它们是相互碰撞的",{"1":{"784":1}}],["那么它们则可能接触",{"1":{"784":1}}],["那么它会被彻底的卸载掉",{"1":{"697":1}}],["那么其中四条对数据库有修改的写入命令就会被同步到",{"1":{"443":1}}],["那么fork出子进程的这个过程将是非常耗时的",{"1":{"442":1}}],["那么得了好处的他也就不会再时刻想着前来对你展开武力行动了",{"1":{"383":1}}],["那么整个门派都将随着门主的死去而马上灭亡",{"1":{"380":1}}],["那么整个动作完成需要花费200ms",{"1":{"67":1}}],["那么根本不会掉落底材",{"1":{"275":1}}],["那么问题来了",{"1":{"270":1}}],["那么问题又来了",{"1":{"107":1}}],["那么公式计算",{"1":{"270":1}}],["那么就为你保留",{"1":{"952":1}}],["那么就需要用version来区分这个entity是新生实体",{"1":{"906":1}}],["那么就需要将两者分开",{"1":{"765":1}}],["那么就面临一个问题",{"1":{"805":1}}],["那么就应该这么使用physics",{"1":{"750":1}}],["那么就勾选上",{"1":{"607":1}}],["那么就可以选择任意的server和application组合实现自己的web应用",{"1":{"578":1}}],["那么就可以掉落qlvl为58的底材",{"1":{"275":1}}],["那么就一定具有这个词缀所代表的属性",{"1":{"270":1}}],["那么就回到第",{"1":{"220":1}}],["那么当敌人蹲下的时候",{"1":{"750":1}}],["那么当前所在打开的场景都会被关闭",{"1":{"698":1}}],["那么当前列表键",{"1":{"454":1}}],["那么当前这个房间类型一定要是2或3",{"1":{"224":1}}],["那么当",{"1":{"207":1}}],["那么当他的状态发生变化时",{"1":{"103":1}}],["那么首先考虑ioptionsmonitor<>",{"1":{"174":1}}],["那么上面这段代码的输出是这样的",{"1":{"172":1}}],["那么视野范围必然发生变化",{"1":{"104":1}}],["那么为了填补空缺",{"1":{"91":1}}],["那么增加的cl",{"1":{"83":1}}],["那么预测的位置将与修正的位置完全相同",{"1":{"75":1}}],["那么本地客户端对其他玩家知道的信息就很少了",{"1":{"74":1}}],["那么你只能批处理300顶点以下的物体",{"1":{"980":1}}],["那么你可以一个一个来",{"1":{"970":1}}],["那么你得到的结果和前述在",{"1":{"970":1}}],["那么你就能马上得出结果",{"1":{"787":1}}],["那么你就能用这个值来分开这两个图形",{"1":{"784":1}}],["那么你即可以认为两个物体在相邻格子时为碰撞",{"1":{"758":1}}],["那么你的角色就会移动到",{"1":{"67":1}}],["那么你完全可以忽略字节序的存在",{"1":{"34":1}}],["那么客户端在50ms之后获得新的游戏状态",{"1":{"64":1}}],["那么需要往后拉多少",{"1":{"50":1}}],["那么需要等待50ms以后下个更新包才能发送",{"1":{"50":1}}],["那么导弹应该位于哪个时间区间",{"1":{"50":1}}],["那么0x11为高字节",{"1":{"33":1}}],["那么必然存在着一个如果将多个字节安排的问题",{"1":{"33":1}}],["那么必然会导致其计算出的state",{"1":{"15":1}}],["那么何为字节序",{"0":{"32":1},"2":{"33":1,"34":1}}],["那么",{"1":{"15":1,"74":1,"94":1,"270":1,"665":1,"684":1,"695":1,"724":1,"755":6,"801":1,"833":1,"841":1,"854":1,"891":1,"952":2,"954":1}}],["那么服务器也可以自己验算战斗结果",{"1":{"15":1}}],["那么他这个时候",{"1":{"12":1}}],["戏过程中实际向服务器发送数据包的时间",{"1":{"55":1}}],["端午划龙舟",{"0":{"328":1}}],["端口监听",{"0":{"167":1}}],["端口的形式",{"1":{"135":1}}],["端需要对主动发起的client对时请求做一些安全校验",{"1":{"51":1}}],["端游一般是专门用的一个进程或者另外一台物理服务器来进行怪物ai的计算",{"1":{"20":1}}],["考虑下面的代码",{"1":{"818":1}}],["考虑下面的计算",{"1":{"815":1}}],["考虑这样一个情况",{"1":{"454":1}}],["考虑到加载操作",{"1":{"815":1}}],["考虑到这毕竟不是我原创发明的算法",{"1":{"198":1}}],["考虑到反外挂",{"1":{"51":1}}],["考虑网络问题",{"0":{"64":1}}],["考虑两个玩家直线跑向对方并且开火",{"1":{"48":1}}],["关系就已经可用了",{"1":{"965":1}}],["关系到练武经验的最大上限",{"1":{"372":1}}],["关联的实体",{"1":{"1054":1}}],["关联的",{"1":{"960":1}}],["关联的数据",{"1":{"957":1}}],["关联的内存由",{"1":{"937":1}}],["关联",{"1":{"957":1}}],["关联了是",{"1":{"942":1}}],["关键在于这个截面离摄像机有多远",{"1":{"1025":1}}],["关键在于这个点在哪个截面上",{"1":{"1025":1}}],["关键点是任何被传递的值类型参数仅是一个碳复制",{"1":{"891":1}}],["关键操作就是2步",{"1":{"715":1}}],["关键操作是readtype这个操作",{"1":{"714":1}}],["关键是通常有一个特殊的平面",{"1":{"737":1}}],["关键是",{"1":{"714":1}}],["关键是read操作",{"1":{"714":1}}],["关键是看types是怎么获取的",{"1":{"714":1}}],["关键的是第一行",{"1":{"711":1}}],["关键字",{"1":{"510":1,"604":1,"955":1}}],["关闭burst的编译",{"1":{"1051":1}}],["关闭netcode的代码生成",{"1":{"1051":1}}],["关闭",{"1":{"1035":1}}],["关闭read",{"1":{"872":1}}],["关闭rigs",{"1":{"869":1}}],["关闭垂直同步后进入游戏",{"1":{"854":1}}],["关闭垂直同步时若游戏的实际显示帧速大于60",{"1":{"854":1}}],["关闭实例所在场景或者使用",{"1":{"699":1}}],["关闭实时保护",{"1":{"605":1}}],["关闭时执行",{"1":{"451":1}}],["关闭或",{"1":{"451":1}}],["关底boss",{"1":{"266":1}}],["关底boss等级固定",{"1":{"265":1}}],["关卡生成算法的第二部分",{"0":{"225":1}}],["关卡生成算法的第一部分",{"1":{"224":1}}],["关卡由",{"1":{"224":1}}],["关卡通路",{"0":{"224":1},"1":{"224":2}}],["关心对时结果",{"1":{"51":2}}],["关于转换",{"0":{"1054":1}}],["关于转换系统",{"0":{"999":1}}],["关于分配器",{"0":{"1022":1},"2":{"1023":1}}],["关于手动添加",{"0":{"1003":1}}],["关于parent和linkedentitygroup",{"0":{"1053":1}}],["关于parent和",{"0":{"1004":1}}],["关于platform",{"1":{"972":1}}],["关于prefab到entity",{"0":{"939":1}}],["关于网格合并",{"1":{"848":1}}],["关于骨骼",{"1":{"848":1}}],["关于这个主题我会在我的下一篇文章中提到",{"1":{"841":1}}],["关于如何进行unity远程debugger",{"0":{"838":1}}],["关于如何测试",{"0":{"613":1},"2":{"614":1,"615":1,"616":1,"617":1}}],["关于好处1",{"1":{"795":1}}],["关于技能树的使用和思考技能树开始的设计思路是",{"1":{"795":1}}],["关于replace都干了什么",{"0":{"744":1}}],["关于il2cpp我们还有很多可以说的",{"1":{"595":1}}],["关于奖惩",{"0":{"294":1}}],["关于地形",{"1":{"287":1}}],["关于",{"0":{"148":1},"1":{"640":1,"699":1}}],["关于参数",{"0":{"147":1}}],["关于多语言",{"0":{"146":1}}],["关于版本",{"0":{"145":1}}],["关于客户端js",{"0":{"134":1}}],["关于c",{"0":{"124":1}}],["关于mono和unity",{"1":{"123":1}}],["关于作弊和反作弊的问题超出了本篇文章讨论的范围",{"1":{"50":1}}],["关于字串的字节序问题",{"1":{"39":1}}],["关于快照",{"1":{"15":1}}],["回忆一下我们前面提到的gameobjectexportgroup",{"1":{"964":1}}],["回忆一下declarelinkedentitygroup",{"1":{"963":1}}],["回忆一下前文提到",{"1":{"957":1}}],["回收实体",{"1":{"936":1}}],["回调栈",{"1":{"890":1}}],["回到开始",{"1":{"715":1}}],["回到最开始的",{"1":{"714":1}}],["回到我们的例子",{"1":{"64":1}}],["回来练功导致声望降回还要重新打声望的",{"1":{"377":1}}],["回去画画",{"1":{"296":1}}],["回复持续6秒|",{"1":{"378":1}}],["回复量因物品而异",{"1":{"290":1}}],["回复30点+睡眠事件",{"1":{"290":1}}],["回复时的本地时间",{"1":{"51":1}}],["回复当前自己的系统时间",{"1":{"51":1}}],["回滚的问题",{"1":{"88":1}}],["回滚input到",{"1":{"69":1}}],["回滚导致的一些轻微的抖动",{"1":{"15":1}}],["回滚重新执行后",{"1":{"15":1}}],["回滚会多一些",{"1":{"15":1}}],["回滚到上一个状态",{"1":{"13":1}}],["向withall列表和withany或withnone列表添加组件会创建一个不合逻辑的查询",{"1":{"910":1}}],["向windows桌面双击操作一样打开某个文件或者目录",{"1":{"424":1}}],["向显示缓冲绘制数据",{"1":{"854":1}}],["向量教程",{"1":{"789":1}}],["向量的叉乘",{"0":{"781":1}}],["向量的点乘",{"0":{"780":1}}],["向量的点积的其中一个几何含义是",{"1":{"763":1}}],["向量的计算有两种",{"1":{"779":1}}],["向量",{"0":{"779":1},"2":{"780":1,"781":1}}],["向量相减更多关于向量的知识可通过其它渠道学习",{"1":{"762":1}}],["向量2为transform",{"1":{"749":1}}],["向量1为transform",{"1":{"749":1}}],["向量有方向也有长度",{"1":{"749":1}}],["向量指向方向为正向",{"1":{"197":1}}],["向上查找",{"0":{"679":1}}],["向上走的楼梯",{"1":{"218":1}}],["向女神献上贡品10次",{"1":{"290":1}}],["向下走的楼梯",{"1":{"218":1}}],["向方法中注入代码",{"1":{"111":1}}],["向左顺移一格",{"1":{"68":1}}],["向",{"1":{"51":1}}],["使技能模块可以获得部分ai的能力",{"1":{"795":1}}],["使得離攝影機越近的物件",{"1":{"974":1}}],["使得画面更加平滑和稳定",{"1":{"854":1}}],["使得背景取景区域内的背景正确",{"1":{"729":1}}],["使得玩家很难移动或精确瞄准",{"1":{"84":1}}],["使代码能够描述自身",{"1":{"127":1}}],["使",{"1":{"51":1}}],["使用ideclarereferencedprefabs",{"1":{"1054":1}}],["使用射线",{"0":{"1024":1}}],["使用實踐情境",{"0":{"978":1}}],["使用程式調整",{"1":{"975":1}}],["使用withstoreentityqueryinfield",{"1":{"966":1}}],["使用时注意语义上的区别",{"1":{"964":1}}],["使用同样的",{"1":{"942":1}}],["使用job",{"1":{"912":1}}],["使用ja",{"0":{"552":1,"556":1},"2":{"553":1,"554":1,"555":1,"556":1,"557":2,"558":2,"559":1,"560":1,"561":1,"562":1,"563":1}}],["使用一个job结构来有效的遍历实体",{"1":{"910":1}}],["使用列表维护所有实体以及和实体关联的数据",{"1":{"906":1}}],["使用操作符",{"1":{"898":1}}],["使用declarereferencedasset",{"1":{"964":1}}],["使用dude",{"1":{"897":1}}],["使用dll进行热更",{"0":{"708":1},"2":{"709":1}}],["使用引用类型",{"1":{"889":1}}],["使用光照纹理的物体需要小心处理",{"1":{"876":1}}],["使用心得与性能总结",{"1":{"863":1}}],["使用entity",{"1":{"952":1}}],["使用entity的管理机制通知所有客户端destroy法术场",{"1":{"807":1}}],["使用empty4raycast代替空的image",{"1":{"860":1}}],["使用texture2d",{"1":{"858":1}}],["使用typora来编写框架内容",{"0":{"504":1}}],["使用比较简单",{"1":{"841":1}}],["使用这些类型",{"1":{"946":1}}],["使用这些函数",{"1":{"841":1}}],["使用这个站点",{"1":{"607":1}}],["使用这个方式",{"1":{"108":1}}],["使用foreach循环会在每次循环结束时强制unity去装箱一个值",{"1":{"823":1}}],["使用unity的深度分析模式来定位托管内存分配的特定原因",{"1":{"815":1}}],["使用树增加拓展性",{"1":{"795":1}}],["使用树形结构控制技能的执行流程",{"1":{"795":1}}],["使用physics",{"1":{"750":1}}],["使用混合滚动方式形成的滚动效果看起来是这样的",{"1":{"729":1}}],["使用照相机移动形成滚动的效果看起来是这样的",{"1":{"728":1}}],["使用精灵滚动形成滚动的效果看起来是这样的",{"1":{"727":1}}],["使用late",{"0":{"705":1}}],["使用lockstep同步机制的游戏中",{"1":{"11":1}}],["使用assetbundle时可以从assetbundle中加载部分内容",{"1":{"701":1}}],["使用此同步流程的表现为",{"0":{"804":1}}],["使用此技术最小化长时间运行的进程的工作集",{"1":{"707":1}}],["使用此种方法虽然可以提高部分性能",{"1":{"699":1}}],["使用此方法就不再合适",{"1":{"699":1}}],["使用此id的所有客户端和silo将能够直接相互通信",{"1":{"90":1}}],["使用上述的两个方法会将资源加载到内存中",{"1":{"697":1}}],["使用systemstatecomponent",{"0":{"985":1}}],["使用setinsetandsizefromparentedge函数来进行设定",{"1":{"645":1}}],["使用setsizewithcurrentanchors函数来进行设定",{"1":{"645":1}}],["使用ssd",{"1":{"605":1}}],["使用ssh工具连接到实例",{"0":{"461":1}}],["使用发行证书进行调试",{"1":{"616":1}}],["使用vpn切换到指定国家",{"1":{"609":1}}],["使用字段",{"1":{"598":1}}],["使用默认的",{"1":{"592":1}}],["使用技巧",{"0":{"586":1}}],["使用技能",{"1":{"17":1}}],["使用hexo",{"0":{"516":1},"2":{"517":1}}],["使用hash算法",{"1":{"91":1}}],["使用npm安装gitbook",{"0":{"500":1},"2":{"501":1,"502":1,"503":1,"504":1,"505":1,"506":1,"507":1}}],["使用net",{"1":{"86":1}}],["使用清华大学的镜像",{"0":{"480":1},"2":{"481":1,"482":1,"483":1}}],["使用中科大的镜像",{"0":{"479":1}}],["使用起来还是很方便的",{"1":{"473":1}}],["使用普通用户登陆",{"0":{"458":1},"2":{"459":1}}],["使用子进程也有一个问题需要解决",{"1":{"455":1}}],["使用子进程而不是线程",{"1":{"455":1}}],["使用适当的写入命令来重现键的当前值",{"1":{"454":1}}],["使用伪客户端执行该命令",{"1":{"452":1}}],["使用converttoentity组件",{"1":{"1054":1}}],["使用componenttype的数组来创建一个entity使用entityarchetype来创建一个entity通过",{"1":{"907":1}}],["使用cmd",{"1":{"527":1}}],["使用c",{"0":{"425":1}}],["使用流程",{"0":{"397":1},"2":{"398":1,"399":1,"400":1,"401":1,"402":1}}],["使用道具",{"1":{"290":1}}],["使用类来表示相关的设置组",{"1":{"171":1}}],["使用拉的方式从github直接请求",{"1":{"144":1}}],["使用了ecs同样注意",{"1":{"864":1}}],["使用了透视摄像机",{"1":{"620":1}}],["使用了相对简单的一种方法",{"1":{"220":1}}],["使用了",{"1":{"135":1,"1036":1}}],["使用了客户端预测的话",{"1":{"57":1}}],["使用multi",{"1":{"980":1}}],["使用msbuild获取构建日志",{"1":{"125":1}}],["使用memberwiseclone方法memberwiseclone是object类的受保护方法",{"1":{"111":1}}],["使用它来编译代码",{"1":{"125":1}}],["使用扩展方法进行克隆havard",{"1":{"111":1}}],["使用蓝绿部署",{"1":{"89":1}}],["使用蓝绿部署需要注意的一些细节包括",{"1":{"88":1}}],["使用的资源",{"1":{"88":1}}],["使用之前我们说的技术",{"1":{"68":1}}],["使用之前说的实现方式",{"1":{"67":1}}],["使用权威服务器可以防止很多的漏洞",{"1":{"63":1}}],["使用服务器校对不会出什么问题",{"1":{"57":1}}],["使用",{"0":{"130":1,"279":1,"462":1,"481":1,"536":1,"537":1,"722":1,"955":1},"1":{"39":1,"90":1,"438":1,"500":1,"503":1,"509":1,"510":4,"537":2,"644":1,"695":5,"697":1,"699":1,"701":1,"726":1,"835":1,"857":1,"864":1,"907":1,"941":1,"943":1,"944":1,"947":1,"964":2,"977":2,"978":1,"1000":1},"2":{"280":1,"281":1,"282":1,"283":1,"284":1,"463":1,"464":1}}],["使用抢占式",{"1":{"19":1}}],["使用色彩范围或者其他东西",{"1":{"2":1}}],["zaks",{"1":{"998":1}}],["zwrite",{"1":{"975":1,"1035":1}}],["zblade",{"1":{"719":1}}],["zero",{"1":{"486":1}}],["zones",{"1":{"214":2}}],["zucker",{"1":{"197":1}}],["zinx",{"1":{"103":1}}],["zip",{"1":{"50":1,"287":1,"510":2,"535":2}}],["z",{"0":{"974":1},"1":{"101":1,"800":1,"824":8,"840":2,"974":7,"975":2,"978":2,"1025":1}}],["zhi",{"1":{"587":1}}],["zhihu",{"1":{"15":1,"211":2,"412":1,"812":1,"850":2,"981":1,"984":1}}],["zhuo",{"1":{"368":1}}],["zhuanlan",{"1":{"15":1,"211":2,"812":1,"850":2,"984":1}}],["zhepama",{"1":{"105":1,"498":1,"611":1}}],["zh",{"1":{"57":1,"59":1,"131":2,"132":1,"140":1,"147":2,"423":1,"499":1,"533":1,"719":1,"723":1}}],["zh服务器获得服务器与客户端的时间差值后",{"1":{"55":1}}],["错误",{"0":{"135":1,"161":1,"476":1}}],["错误可以顺利解决",{"1":{"84":1}}],["错误可能就会比较明显",{"1":{"48":1}}],["错位的玩家移动到他们当前正确位置",{"1":{"47":1}}],["谁是预测",{"1":{"1019":1}}],["谁让你在空旷区域狂奔呢",{"1":{"48":1}}],["谁就获得了怪物的控制权",{"1":{"19":1}}],["至关重要的是",{"1":{"813":1}}],["至于哪些资源会双份",{"1":{"704":1}}],["至于引擎的实现",{"1":{"652":1}}],["至于转发的内容是什么",{"1":{"577":1}}],["至于为何没有卡顿的现象",{"1":{"12":1}}],["至此",{"1":{"445":1,"811":1}}],["至少",{"1":{"947":1}}],["至少执行两次gc清理才能把对象4清理掉",{"1":{"898":1}}],["至少据我所知是这样的",{"1":{"787":1}}],["至少一次将apk上传到alpha",{"1":{"615":1}}],["至少是82级",{"1":{"270":1}}],["至少第一人称射击游戏是这样",{"1":{"48":1}}],["刚添加",{"1":{"931":1}}],["刚开始接触",{"1":{"840":1}}],["刚好能够完全显示",{"1":{"628":1}}],["刚好就是屏幕的单位宽度",{"1":{"618":1}}],["刚好相反",{"1":{"33":1}}],["刚才hashcode不是用了这26位吗",{"1":{"131":1}}],["刚才提到的冲锋的玩家视野差不多是90°",{"1":{"48":1}}],["被改为其",{"1":{"1036":1}}],["被转换的数据",{"1":{"969":1}}],["被转换时调用",{"1":{"965":1,"1003":1}}],["被实例化时才会有区别",{"1":{"965":1}}],["被调用时你依然有机会使用",{"1":{"964":1}}],["被调用的瞬间后你得到",{"1":{"951":1}}],["被",{"1":{"952":1,"953":1}}],["被添加了",{"1":{"952":1}}],["被销毁的spawnhere",{"1":{"966":1}}],["被销毁时也同时被销毁",{"1":{"954":1}}],["被销毁前通过",{"1":{"951":1}}],["被销毁之前",{"1":{"951":1}}],["被标记了如下",{"1":{"948":1}}],["被成为",{"1":{"947":1}}],["被删除的时候才被重用",{"1":{"936":1}}],["被删除",{"1":{"931":1}}],["被存在无垃圾回收的",{"1":{"927":1}}],["被放到栈上",{"1":{"891":1}}],["被传递到寄存在方法类型表里的addfive",{"1":{"885":1}}],["被耗尽",{"1":{"814":1}}],["被释放的内存变成了其他内存段中间的空隙",{"1":{"813":1}}],["被释放对象两边的对象仍然被使用",{"1":{"813":1}}],["被定义为",{"1":{"811":1}}],["被定义在每个ability下然后对其重写",{"0":{"240":1}}],["被加载后",{"1":{"701":1}}],["被唤起的部分",{"1":{"695":1}}],["被任意应用进程发送和接受的抽象",{"1":{"583":1}}],["被关闭",{"1":{"448":1}}],["被选为舵主的弟子可以增加20的忠诚度",{"1":{"381":1}}],["被打到一样都只剩两成血",{"1":{"377":1}}],["被小女孩无情嘲笑了",{"1":{"296":1}}],["被突然出现的一群纸鹤追着跑了两条銜",{"1":{"296":1}}],["被路过的博雅看见了",{"1":{"296":1}}],["被当成了大义的追求者",{"1":{"296":1}}],["被神秘男子搭讪了",{"1":{"296":1}}],["被使用",{"1":{"151":1}}],["被清除的对象留下内存的空缺位置会造成内存不连续",{"1":{"118":1}}],["被击中的玩家看他的射击者在前方",{"1":{"48":1}}],["被服务器拉回",{"1":{"46":1}}],["让其",{"1":{"1036":1}}],["让linkedentitygroup",{"1":{"965":1}}],["让每个",{"1":{"947":1}}],["让每个玩家即时与世界交互并开火",{"1":{"48":1}}],["让视角匀速转动",{"1":{"854":1}}],["让",{"1":{"780":2,"962":1}}],["让assembly加载到这个新appdomain中然后执行",{"1":{"707":1}}],["让你的测试人员用他的google账号点进去",{"1":{"610":1}}],["让人感觉好像apache就支持php一样",{"1":{"580":1}}],["让子进程进行持久化操作",{"1":{"442":1}}],["让子进程负责持久化操作",{"1":{"441":1}}],["让应征者正式成为门派一员",{"1":{"380":1}}],["让玩家看到它并调整对象至实际视口",{"1":{"737":1}}],["让玩家根据种子生成地图的原因",{"1":{"214":1}}],["让玩家的行动感到更即时",{"1":{"84":1}}],["让我们开始吧",{"1":{"971":1}}],["让我们使用",{"0":{"951":1}}],["让我们用纯数据来做个游戏吧",{"0":{"943":1}}],["让我们更进一步清理上面的代码",{"1":{"897":1}}],["让我们测试一下在堆中存储值类型变量和引用类型变量时会产生的不同情况",{"1":{"894":1}}],["让我们看一下",{"1":{"898":1}}],["让我们看看结果",{"1":{"952":1}}],["让我们看看堆栈里到底发生了什么情况调用go",{"1":{"893":1}}],["让我们看看执行下面代码go",{"1":{"891":1}}],["让我们看代码与图例",{"1":{"885":1}}],["让我们来看一下更加详细的内容",{"1":{"890":1}}],["让我们分拆来看看这几个读取函数的实现1",{"1":{"712":1}}],["让我们从一个简单的例子入手",{"1":{"592":1}}],["让我们从最基本的柏林噪声函数看起",{"1":{"197":1}}],["让我们从options框架的源代码着手",{"1":{"173":1}}],["让我们回到addoptions的源代码",{"1":{"173":1}}],["让我们首先绘制一个2d的地图我们给这个地图定义一些数值",{"1":{"103":1}}],["让我们假设一个玩家有150毫秒的网络延迟",{"1":{"84":1}}],["让客户端广播自己的位置",{"1":{"45":1}}],["让客户端领先服务器少一些",{"1":{"15":1}}],["低内存和中内存",{"1":{"570":1}}],["低于100",{"1":{"391":1}}],["低频更新处理",{"0":{"74":1}}],["低延迟在玩多人在线游戏时有显著的优势",{"1":{"82":1}}],["低延迟玩家可能已经从角落里冲出",{"1":{"48":1}}],["低延时玩家会觉得他再角落里被击中了",{"1":{"48":1}}],["低延时的玩家可能已经跑到角落里并且蹲在一个箱子后面",{"1":{"48":1}}],["低延时的玩家会感觉高延时玩家",{"1":{"48":1}}],["低地址存放的是低字节",{"1":{"36":1}}],["低地址部分权值低",{"1":{"32":1}}],["延伸",{"0":{"765":1}}],["延时补偿",{"0":{"79":1}}],["延时补偿只会把玩家在移动直线上往后拉",{"1":{"48":1}}],["延时补偿使得玩家只需要直接瞄准他的目标并按下开火按钮即可",{"1":{"48":1}}],["延迟时间=技能前摇时间",{"1":{"803":2}}],["延迟小",{"1":{"529":2}}],["延迟很小",{"1":{"529":1}}],["延迟可能会达到零点几秒",{"1":{"66":1}}],["延迟+",{"1":{"54":2}}],["延迟补偿系统使所有玩家最近位置的历史一秒",{"1":{"85":1}}],["延迟补偿有更多需要解决的问题",{"1":{"50":1}}],["延迟补偿所带来的效果提升显著大于其带来的错误",{"1":{"49":1}}],["延迟补偿是当前动作游戏改善延迟影响的一种方法",{"1":{"49":1}}],["延迟补偿是服务器执行的一种策略",{"1":{"47":1}}],["延迟补偿可以看做服务器处理用户命令的时候回退一段时间",{"1":{"47":1}}],["延迟补偿",{"0":{"47":1,"85":1}}],["延迟越大",{"1":{"45":1}}],["延迟超过了预设的阈值",{"1":{"12":1}}],["瞄准敌人进行射击几乎总是不能击中",{"1":{"48":1}}],["9数字",{"1":{"854":1}}],["9266800",{"1":{"850":1}}],["9100146",{"1":{"719":1}}],["91",{"1":{"601":2}}],["9nblggh4nns1https",{"1":{"533":1}}],["9wzdncrfjbmp应用安装器",{"1":{"533":1}}],["98482430",{"1":{"850":1}}],["98",{"1":{"529":1}}],["95",{"1":{"385":1}}],["900",{"1":{"628":1}}],["90",{"1":{"297":2,"840":2}}],["94",{"1":{"287":3}}],["96084686",{"1":{"850":2}}],["960",{"1":{"618":1,"625":2}}],["96",{"1":{"287":1}}],["9c",{"1":{"287":4}}],["99",{"1":{"270":5,"287":3}}],["9这三个格子里的地图内容",{"1":{"103":1}}],["9这三个格子里的内容",{"1":{"103":1}}],["9",{"0":{"48":1},"1":{"48":1,"50":1,"103":1,"220":1,"221":1,"224":2,"267":1,"296":1,"297":2,"823":2}}],["中设定的",{"1":{"1036":1}}],["中创建一个材质后",{"1":{"1036":1}}],["中并排编写句点",{"1":{"1023":1}}],["中括起来",{"1":{"1023":1}}],["中未释放内存时",{"1":{"1022":1}}],["中再声明一遍",{"1":{"997":1}}],["中關閉深度機制的判斷",{"1":{"975":1}}],["中可利用",{"1":{"974":2}}],["中可以通过gameobjectconversionsystem根据prefab获取entity",{"1":{"939":1}}],["中可以batch的元素作为一个",{"1":{"862":1}}],["中将无法感知这一修改",{"1":{"971":1}}],["中声明",{"1":{"970":1}}],["中得到rendermesh会被高效地处理",{"1":{"969":1}}],["中得到一个真正的",{"1":{"964":1}}],["中我们可以看到",{"1":{"968":1}}],["中去",{"1":{"968":1}}],["中暴露一些字段",{"1":{"967":1}}],["中删掉",{"1":{"966":1}}],["中用不太上",{"1":{"965":1}}],["中gameobject在细节上有哪些不同",{"1":{"965":1}}],["中来决定它是不是一个",{"1":{"964":1}}],["中来进行声明",{"1":{"964":1}}],["中粘贴converttoentity运行",{"1":{"964":1}}],["中隐藏它们是并非主观上想要让它们处于",{"1":{"964":1}}],["中隐身",{"1":{"964":1}}],["中添加的字段",{"1":{"964":1}}],["中添加程序集引用",{"1":{"722":1}}],["中拿出来",{"1":{"960":1}}],["中获取linkedentitygroup",{"0":{"959":1,"1002":1}}],["中获得特殊属性",{"1":{"266":1}}],["中序列化的字段",{"1":{"957":1}}],["中被调用",{"1":{"948":1}}],["中被触发",{"1":{"742":1}}],["中构建出",{"1":{"947":1}}],["中捕获这些变量",{"1":{"944":1}}],["中常用的无",{"1":{"937":1}}],["中查询任意可能链接了",{"1":{"964":1}}],["中查询",{"1":{"934":1,"935":1}}],["中找到的",{"1":{"947":1}}],["中找",{"1":{"929":1}}],["中显示例程",{"1":{"878":1}}],["中文字幕",{"1":{"864":1,"899":1}}],["中文中我们称之为",{"1":{"266":2}}],["中文中我们一般称之为",{"1":{"266":2}}],["中各种坐标系搞得昏头转向不知所措",{"1":{"840":1}}],["中所有的东西",{"1":{"970":1}}],["中所有的",{"1":{"957":1}}],["中所有的物体",{"1":{"656":1}}],["中所有类都是引用类型",{"1":{"818":1}}],["中进行",{"1":{"759":1}}],["中进行操作",{"1":{"88":1}}],["中判断同一位置",{"1":{"759":1}}],["中加上了矩形的中心点的坐标值",{"1":{"756":1}}],["中加载数据",{"1":{"261":1}}],["中完成",{"1":{"726":1}}],["中阅读有关这些选项的更多信息",{"1":{"721":1}}],["中对应于",{"1":{"701":1}}],["中分发事件",{"1":{"695":1}}],["中第一个结果作为响应事件的输入事件的",{"1":{"695":1}}],["中使用的工具",{"1":{"950":1}}],["中使用闭包",{"1":{"818":1}}],["中使用",{"1":{"695":1,"736":1,"965":1}}],["中也使用的该方法进行射线检测",{"1":{"689":1}}],["中是",{"1":{"685":1}}],["中最后调用的是",{"1":{"685":1}}],["中有一个方法可以使用",{"1":{"959":1,"1002":1}}],["中有两个好处",{"1":{"938":1}}],["中有趣的是",{"1":{"898":1}}],["中有三种类型的",{"1":{"656":1}}],["中有关米切尔候选算法的部分如下图所示",{"1":{"214":1}}],["中數值部分",{"1":{"650":1}}],["中調整",{"1":{"650":3}}],["中点",{"1":{"640":1}}],["中启动速度降到了",{"1":{"537":1}}],["中启动速度大概为",{"1":{"535":1}}],["中配置",{"1":{"537":1}}],["中非常大的体积",{"1":{"537":1}}],["中都有相应的函数",{"1":{"841":1}}],["中都是引用类型",{"1":{"818":1}}],["中都已经包括了需要的模块",{"1":{"536":1}}],["中都可以使用",{"1":{"176":1}}],["中情况",{"1":{"523":1}}],["中接着创建一个",{"1":{"510":1}}],["中发生故障停机",{"1":{"449":2}}],["中从",{"1":{"257":1,"258":1}}],["中级",{"1":{"251":1}}],["中的工具",{"1":{"971":1}}],["中的内容可能会变化",{"1":{"970":1}}],["中的对象",{"1":{"969":1,"970":1,"971":1}}],["中的所有内容偶会被自动",{"1":{"971":1}}],["中的所有",{"1":{"958":1,"1001":1}}],["中的所有实体都添加",{"1":{"927":1}}],["中的方法",{"1":{"957":1}}],["中的值",{"1":{"908":1}}],["中的元素单独拎出来",{"1":{"861":1}}],["中的坐标系是非产重要的",{"1":{"840":1}}],["中的两种实现方式",{"1":{"759":1}}],["中的视差滚动技术进行了研究",{"1":{"736":1}}],["中的下拉菜单指定",{"1":{"721":1}}],["中的作用和流程基本就是上述的内容",{"1":{"695":1}}],["中的三个",{"1":{"683":1}}],["中的",{"1":{"535":1,"537":1,"684":1,"686":1,"695":2,"924":1,"947":1,"949":1,"953":1,"956":1,"958":4,"964":1,"965":1,"971":1,"1001":4}}],["中的启动速度非常慢",{"1":{"534":1}}],["中的累积设置驱动",{"1":{"524":1}}],["中的上下文信息",{"1":{"509":1}}],["中的缓存写入到",{"1":{"446":1}}],["中的文件系统驱动器那样访问它",{"1":{"424":1}}],["中的代码",{"1":{"176":1}}],["中的一个参数进行传递",{"1":{"152":1}}],["中就有的方法",{"1":{"176":1}}],["中间有长而且直的走廊连接",{"1":{"220":1}}],["中间变化快",{"1":{"197":1}}],["中间件负责组装连接相关的上下文数据",{"1":{"168":1}}],["中间件",{"1":{"167":3}}],["中间件request的语言判断",{"0":{"151":1},"2":{"152":1,"153":1,"154":1}}],["中间语言",{"1":{"111":1,"127":1,"128":1}}],["中",{"1":{"72":2,"164":1,"536":1,"537":1,"576":1,"661":1,"695":2,"697":1,"726":2,"742":1,"861":1,"908":1,"927":1,"928":2,"929":2,"938":1,"944":1,"948":1,"949":3,"960":1,"964":1,"969":1,"971":1,"975":1,"981":2,"982":1,"1000":1,"1023":1}}],["中实际向服务器发送数据包的时间来判定在游戏时间中事件发生的实际顺序",{"1":{"55":1}}],["中执行用户命令",{"1":{"47":1}}],["中途加入游戏是从技术上来讲是非常困难的",{"1":{"12":1}}],["更具体的实现可以在查看官方对于parentsystem的设计",{"1":{"987":1}}],["更改对",{"0":{"983":1}}],["更懒得添加内存加载的代码",{"1":{"971":1}}],["更棒的是",{"1":{"967":1}}],["更像是带着一些添加更多",{"1":{"963":1}}],["更上层的",{"1":{"956":1}}],["更好的方法是使用idisposable接口",{"1":{"898":1}}],["更好的用户体验",{"1":{"538":1}}],["更正原文说的把对象放到finalization",{"1":{"898":1}}],["更换的服装例如帽子好好的",{"1":{"848":1}}],["更高的版本不保证适用",{"1":{"553":1}}],["更快的启动速度",{"1":{"538":1}}],["更详细的步骤可以参考",{"1":{"536":1}}],["更为详细",{"1":{"714":1}}],["更为此地蒙上了一层可怖的阴影",{"1":{"297":1}}],["更为重要的是",{"1":{"130":1}}],["更想要紫白配色的锦鲤",{"1":{"296":1}}],["更想要红白配色的锦鲤",{"1":{"296":1}}],["更多細節可查看",{"1":{"975":1}}],["更多信息",{"0":{"833":1}}],["更多关于分离轴定理的资料",{"1":{"764":1}}],["更多物理攻击伤害c",{"1":{"384":1}}],["更多攻击速度ii",{"1":{"384":1}}],["更多",{"1":{"255":1}}],["更何况是量子力学",{"1":{"206":1}}],["更小点的有大块岩石",{"1":{"204":1}}],["更友好",{"1":{"180":1}}],["更加具体直观的算法解释可以参考",{"1":{"214":1}}],["更加节约资源",{"1":{"89":1}}],["更加复杂的触发器",{"1":{"30":1}}],["更合适一些",{"1":{"51":1}}],["更新以来",{"1":{"910":1}}],["更新pip",{"1":{"567":1}}],["更新记录矩阵",{"1":{"210":1}}],["更新和使用的",{"1":{"138":1}}],["更新",{"0":{"983":1},"1":{"111":1}}],["更新频率",{"1":{"82":1}}],["更新时间间隔没必要是固定的",{"1":{"50":1}}],["更新的过程中我们可以设一个标志表示不插值或清除历史记录",{"1":{"46":1}}],["减少类型数量",{"1":{"1051":1}}],["减少托管堆里对象的移动",{"1":{"898":1}}],["减少了进程消耗",{"1":{"575":1}}],["减少",{"0":{"537":1},"1":{"534":1}}],["减少到",{"1":{"534":1}}],["减少数据层的压力",{"1":{"91":1}}],["减小上面提到的平滑处理带来的问题",{"1":{"46":1}}],["减缓服务器压力",{"1":{"17":1}}],["信息可以参考官方文档",{"1":{"509":1}}],["信息越少的话",{"1":{"74":1}}],["信息",{"1":{"46":1}}],["半圆形攻击范围检测",{"0":{"775":1}}],["半径为",{"1":{"756":1}}],["半径",{"1":{"756":1}}],["半条命代码中usercmd",{"1":{"50":1}}],["半条命游戏数据包发送间隔是随机的",{"1":{"50":1}}],["半条命的默认设置是每秒每个用户",{"1":{"46":1}}],["半透明物件",{"1":{"975":1,"978":1}}],["半透明",{"1":{"0":1}}],["球或者在空中",{"1":{"46":1}}],["极端情况下",{"1":{"46":1}}],["来在item上添加和删除partowner",{"1":{"1008":1}}],["来指导unity绘制对象到屏幕上",{"1":{"976":1}}],["来指定射线检测阻挡",{"1":{"689":1}}],["来打开",{"1":{"971":1}}],["来",{"1":{"969":1}}],["来导出",{"1":{"966":1}}],["来批量removecomponent",{"1":{"966":1}}],["来检查一下你是否能推算出上面例子正确的结果吧",{"1":{"965":1}}],["来点小测验吧",{"1":{"965":1}}],["来隐藏自己",{"1":{"969":1}}],["来隐藏",{"1":{"964":1}}],["来讲",{"1":{"964":1}}],["来声明更多东西就太晚了会报错",{"1":{"964":1}}],["来生成",{"1":{"964":1}}],["来做同样的事情",{"1":{"961":1}}],["来做一些测试",{"1":{"841":1}}],["来初始化数据也许会更高效一些",{"1":{"957":1}}],["来初始化更多数据",{"1":{"957":1}}],["来看看最后这一个",{"1":{"965":1}}],["来看看",{"1":{"955":1}}],["来添加内容",{"1":{"971":1}}],["来添加一段逻辑",{"1":{"955":1}}],["来添加缓冲",{"1":{"938":1}}],["来统一地",{"1":{"955":1}}],["来追踪该对象的",{"1":{"955":1}}],["来追踪其名字",{"1":{"951":1}}],["来控制它们",{"1":{"955":1}}],["来控制敏感信息",{"1":{"411":1}}],["来得到结果",{"1":{"951":1}}],["来得出最终的尺寸大小",{"1":{"841":1}}],["来convert吧",{"0":{"951":1}}],["来与",{"1":{"950":1}}],["来替代",{"1":{"947":1,"955":1}}],["来获得",{"1":{"970":1}}],["来获得更多的游戏精度",{"1":{"86":1}}],["来获取位置",{"1":{"966":1}}],["来获取已经被转换好的",{"1":{"964":1}}],["来获取",{"1":{"947":1,"950":1}}],["来仅实现",{"1":{"946":1}}],["来加载一个引用了相关",{"1":{"943":1}}],["来每帧合并",{"1":{"942":1}}],["来绘制数据",{"1":{"942":1}}],["来完成工作",{"1":{"965":1}}],["来完成上文提到的绘制工作",{"1":{"942":1}}],["来完成当前环境的导出",{"1":{"481":1}}],["来开发游戏的方式",{"1":{"940":1}}],["来开发游戏的原因",{"1":{"940":1}}],["来开始安装的过程",{"1":{"481":1}}],["来定义其他的",{"1":{"938":1}}],["来储存临近的圆柱体实体",{"1":{"937":1}}],["来管理传统的",{"0":{"955":1}}],["来管理",{"1":{"937":1}}],["来存储",{"1":{"937":1}}],["来存储属性",{"1":{"142":1}}],["来迭代所有拥有某个特定",{"1":{"930":1}}],["来迭代遍历所有的组件",{"1":{"915":1}}],["来监测内存块的利用",{"1":{"929":1}}],["来修改组件数据",{"1":{"927":1}}],["来组织system",{"1":{"917":1}}],["来只遍历符合条件的实体或组件",{"1":{"912":1}}],["来执行比",{"1":{"911":1}}],["来执行接口中定义的方法excute泛型方法",{"1":{"661":1}}],["来确保对象不会被gc回收",{"1":{"898":1}}],["来减少",{"1":{"940":1}}],["来减少磁盘容量",{"1":{"869":1}}],["来减少插补周期",{"1":{"83":1}}],["来达到性能的提升",{"1":{"861":1}}],["来判断发送给该用户的数据",{"1":{"1019":1}}],["来判断对象是否该做出反应",{"1":{"860":1}}],["来判断是否发生碰撞",{"1":{"761":1}}],["来渲染结果",{"1":{"971":1}}],["来渲染",{"1":{"849":1,"1041":1}}],["来显示场景中需要显示的物体",{"1":{"841":1}}],["来配制成某些技能",{"1":{"791":1}}],["来设置针对前面说的三种程序集的代码存放以及访问方式",{"1":{"707":1}}],["来一个请求",{"1":{"575":1}}],["来分析",{"1":{"537":1}}],["来进行输入输出",{"1":{"574":1}}],["来进行创建",{"1":{"510":1}}],["来进行对象克隆",{"1":{"111":1}}],["来创建一个entity+asset+spriteatlas",{"1":{"964":1}}],["来创建更多的entity",{"1":{"961":1}}],["来创建组件的查询",{"1":{"946":1}}],["来创建entity",{"1":{"906":1}}],["来创建对应的",{"1":{"510":1}}],["来创建",{"1":{"510":1,"963":1}}],["来预览这本书籍",{"1":{"506":1}}],["来编辑游戏",{"1":{"971":1}}],["来编辑这两个文件了",{"1":{"504":1}}],["来编译",{"1":{"130":1}}],["来使得当前终端全局走代理",{"1":{"474":1}}],["来使用",{"1":{"467":1,"966":1}}],["来到了另一条街道",{"1":{"296":1}}],["来记录所有对记录矩阵的操作",{"1":{"210":1}}],["来说明会更直观一些",{"1":{"176":1}}],["来自特定的东西",{"1":{"962":1}}],["来自于initializetypedefinitions这个操作",{"1":{"714":1}}],["来自于文章二中的loadassembly的后续操作",{"1":{"714":1}}],["来自不同请求的延续回合",{"1":{"158":1}}],["来自",{"1":{"151":1}}],["来自非作弊玩家的",{"1":{"67":1}}],["来构建它们以输出",{"1":{"125":1}}],["来构建它们",{"1":{"125":1}}],["来源于国外大神的解释",{"1":{"124":1}}],["来实现该模式",{"1":{"969":1}}],["来实现层级结构",{"1":{"944":1,"1000":1}}],["来实现",{"1":{"573":1,"661":1}}],["来实现热部署",{"1":{"88":1}}],["来实现实时的角色控制",{"1":{"77":1}}],["来改变获得快照平的频率",{"1":{"82":1}}],["来换取平滑",{"1":{"46":1}}],["来决定下一帧需要多少时间",{"1":{"41":1}}],["角度制",{"1":{"749":1}}],["角度信息",{"1":{"46":1}}],["角度",{"1":{"46":2}}],["角色的情绪稳定标准",{"1":{"391":1}}],["角色的属性信息等",{"1":{"12":1}}],["角色属性",{"0":{"386":1}}],["角色动作",{"1":{"244":1}}],["角色动画",{"1":{"242":1}}],["角色字段",{"1":{"234":1}}],["角色向右移动两格",{"1":{"68":1}}],["角色移动一格需要花费100ms",{"1":{"67":1}}],["角色与boss的距离远近等",{"1":{"20":1}}],["角色打怪时",{"1":{"18":1}}],["接收的时候再根据是否预测",{"1":{"1019":1}}],["接收快照ghostupdatesystem",{"1":{"1013":1}}],["接收消息",{"1":{"661":1}}],["接收",{"1":{"576":1}}],["接收方网络协议函数接收时会将接收到的第一个字节存放到低地址",{"1":{"36":1}}],["接著我們在",{"1":{"425":1}}],["接受来自unity自带的或者由mono编译器产生的托管程序集",{"1":{"590":1}}],["接受命令",{"1":{"445":1}}],["接受订单",{"1":{"368":1}}],["接受一个参数",{"1":{"164":1}}],["接着我会把该",{"1":{"966":1}}],["接着我们执行",{"1":{"506":1}}],["接着使用",{"1":{"957":1}}],["接着会执行栈里addfive",{"1":{"885":1}}],["接着会按照类似的方式去搜索自身以及父节点上是否有实现了idraghandler的组件",{"1":{"657":1}}],["接着运行时将这两个",{"1":{"847":1}}],["接着如果加载了",{"1":{"701":1}}],["接着修改ssh配置文件",{"0":{"464":1}}],["接着",{"1":{"197":1,"199":1}}],["接着通过代码来修改testoptions的值",{"1":{"172":1}}],["接着分别打印ioptions<>",{"1":{"172":1}}],["接口来创建",{"1":{"927":1}}],["接口的结构体",{"1":{"920":2}}],["接口的定义包含了三个方法",{"1":{"165":1}}],["接口之后",{"1":{"920":1}}],["接口且",{"1":{"691":1}}],["接口实现这个接口",{"1":{"661":1}}],["接口",{"1":{"657":1,"691":1,"920":1,"957":1}}],["接口又另外设置了一些环境变量",{"1":{"574":1}}],["接口定义了web",{"1":{"163":1}}],["接下来我说说和转换",{"1":{"965":1}}],["接下来我们添加",{"1":{"944":1}}],["接下来我们加点玩法",{"1":{"944":1}}],["接下来我们直接跳到最后",{"1":{"941":1}}],["接下来我们就看一下具体是如何针对一个gameobject进行事件调用的",{"1":{"678":1}}],["接下来简单解释下什么是",{"1":{"964":1}}],["接下来到了正常",{"1":{"964":1}}],["接下来你将如何在",{"1":{"964":1}}],["接下来看看",{"1":{"951":1}}],["接下来实现弹跳",{"1":{"944":1}}],["接下来进行gc的清理",{"1":{"898":1}}],["接下来不同于上一节所介绍的是myint是一个引用类型",{"1":{"887":1}}],["接下来创建两个默认的material",{"1":{"847":1}}],["接下来是三张可拼接的背景精灵",{"1":{"725":1}}],["接下来是将其封入到memorystream中",{"1":{"711":1}}],["接下来卸载资源",{"1":{"701":1}}],["接下来将详细的描述一下不同资源的释放方式及规则",{"1":{"696":1}}],["接下来就来讨论一下unity的层级合并与计算算法",{"1":{"862":1}}],["接下来就来到最重要的覆写的",{"1":{"688":1}}],["接下来就是进行射线检测了",{"1":{"684":1}}],["接下来就一起看看这个方法",{"1":{"684":1}}],["接下来需要启动服务",{"1":{"467":1}}],["接下来要做的最后一件事",{"1":{"224":1}}],["接下来要简要介绍下基本的原理",{"1":{"206":1}}],["接下来当然是要介绍具体的算法了",{"1":{"207":1}}],["接下来",{"1":{"92":1,"969":1,"1054":1}}],["接下来的100ms我们就可以朝这个新的位置移动",{"1":{"46":1}}],["另一块操作则是逻辑",{"1":{"940":1}}],["另一个则有一个",{"1":{"955":1}}],["另一个来自hybrid",{"1":{"951":1}}],["另一个值得看的例子是",{"1":{"948":1}}],["另一个",{"1":{"947":1}}],["另一个可batch的text叠在一个图片a上",{"1":{"862":1}}],["另一个问题",{"1":{"111":1}}],["另一个是对本灯塔感兴趣的对象集合",{"1":{"104":1}}],["另一方面获得该通知哪些结点",{"1":{"106":1}}],["另一方面",{"1":{"75":1,"453":1,"841":1}}],["另一种方法叫插值法",{"1":{"46":1}}],["另外该类中还包含了",{"1":{"683":1}}],["另外需要注意的是",{"1":{"663":1}}],["另外需要注意的是服务器不处理",{"1":{"43":1}}],["另外有一个inputmanager面板用来配置input相关属性的",{"1":{"653":1}}],["另外一个方式是在unity主工程中",{"1":{"599":1}}],["另外一个玩家在垂直于第一个玩家视线的方向冲锋",{"1":{"48":1}}],["另外还有它的子层级",{"1":{"970":1}}],["另外还有我们自己定义的developer和people",{"1":{"131":1}}],["另外还需要安装",{"1":{"536":1}}],["另外继承类的类型对象里面都有个字段指向基类",{"1":{"131":1}}],["另外也别忘了基类object",{"1":{"131":1}}],["另外为什么是索引而不是地址呢",{"1":{"131":1}}],["另外它也能被写成提供深拷贝的方法",{"1":{"111":1}}],["另外",{"1":{"33":1,"40":2,"43":1,"46":2,"88":1,"111":1,"218":1,"450":1,"456":1,"535":1,"655":1,"758":1,"759":1,"841":2,"847":1,"951":1,"966":1,"979":1}}],["另外如果中途有人掉线了",{"1":{"12":1}}],["纠错不至于太大",{"1":{"46":1}}],["方块坐标位于",{"1":{"943":1}}],["方便以原來的旋轉與大小調整物體",{"1":{"649":1}}],["方圆数百里内",{"1":{"297":1}}],["方法有三种",{"1":{"989":1}}],["方法不会被调用",{"1":{"970":1}}],["方法名字有",{"1":{"970":1}}],["方法运行你获取到",{"1":{"957":1}}],["方法获取到",{"1":{"950":1}}],["方法获取当前",{"1":{"688":1}}],["方法执行过后",{"1":{"924":1}}],["方法执行完成",{"1":{"885":1}}],["方法强制等待",{"1":{"924":1}}],["方法合并他们",{"1":{"923":1}}],["方法时",{"1":{"923":1,"958":1,"1001":1}}],["方法时再到dosomething",{"1":{"891":1}}],["方法会在",{"1":{"965":1,"1003":1}}],["方法会将job放到job执行队列的适当位置",{"1":{"921":1}}],["方法会发生的情况",{"1":{"891":1}}],["方法里",{"1":{"896":2}}],["方法里的对象在托管堆nextobjptr指向的位置分配内存并把内存地址存到栈上的局部变量里",{"1":{"131":1}}],["方法体内每次定义的值类型变量都会被放到栈里",{"1":{"885":1}}],["方法对应的指令集中",{"1":{"885":1}}],["方法并不存在栈里",{"1":{"885":1}}],["方法参数pvalue会被放到栈上",{"1":{"885":1}}],["方法就是使用索引",{"1":{"846":1}}],["方法2",{"1":{"776":1}}],["方法进行碰撞检测了",{"1":{"756":1}}],["方法进行检测",{"1":{"691":1}}],["方法只会在收集器距离上一次",{"1":{"742":1}}],["方法本身会有一些格外的开销",{"1":{"699":2}}],["方法来释放一个实例",{"1":{"699":1}}],["方法最后使用自定义",{"1":{"695":1}}],["方法返回",{"1":{"691":1}}],["方法检测",{"1":{"691":1}}],["方法计算是否射线检测成功",{"1":{"691":1}}],["方法计算",{"1":{"689":1,"695":1}}],["方法转换坐标",{"1":{"688":1}}],["方法和",{"1":{"687":1}}],["方法中返回了一个监测了",{"1":{"742":1}}],["方法中的一点点细小的区别",{"1":{"685":1}}],["方法中",{"1":{"684":1}}],["方法中从",{"1":{"683":1}}],["方法中向",{"1":{"683":1}}],["方法sendmessage",{"1":{"660":1}}],["方法二",{"0":{"778":1},"1":{"251":1}}],["方法一次性复制多个entity",{"1":{"907":1}}],["方法一次性填充多个新的entity到一个nativearry中",{"1":{"907":1}}],["方法一",{"1":{"251":1}}],["方法是先在第一排随机找到一个起始房间",{"1":{"224":1}}],["方法是静态方法",{"1":{"131":1}}],["方法可以用for循环遍历所有的块中的元素",{"1":{"911":1}}],["方法可以进行卸载",{"1":{"697":1}}],["方法可以接受加载到的对象",{"1":{"696":1}}],["方法可以启动iserver对象",{"1":{"164":1}}],["方法可能每次都需要尝试第一个参数到底应该传入些什么",{"1":{"176":1}}],["方法等待线程池可用线程",{"1":{"169":1}}],["方法默认使用",{"1":{"167":1}}],["方法添加到线程池中",{"1":{"167":1}}],["方法将保存的结果进行释放",{"1":{"699":1}}],["方法将某点转换成一条射线",{"1":{"684":1}}],["方法将",{"1":{"167":1}}],["方法在完成请求的处理后",{"1":{"165":1}}],["方法创建的",{"1":{"165":1}}],["方法使用的是右边的参数去比较左边的参数",{"1":{"695":1}}],["方法使用",{"1":{"165":1}}],["方法用来产生新的dude复制类",{"1":{"896":1}}],["方法用来复制生成新dude",{"1":{"895":1}}],["方法用来创建处理请求的上下文中所需要的所有相关数据",{"1":{"165":1}}],["方法用来处理停止服务的请求",{"1":{"164":1}}],["方法的规则相同",{"1":{"971":1}}],["方法的",{"1":{"957":1}}],["方法的所有参数将被复制到栈里",{"1":{"890":1}}],["方法的代码实现",{"1":{"167":1}}],["方法的参数和局部变量都会压到函数的栈帧上",{"1":{"131":1}}],["方法的methoddeftoken",{"1":{"131":1}}],["方法",{"0":{"470":1,"690":1},"1":{"131":2,"167":1,"176":3,"180":1,"594":1,"657":2,"683":1,"684":2,"685":1,"687":1,"688":1,"689":1,"690":1,"695":2,"892":1,"893":3,"896":1,"897":1,"898":1,"916":2,"921":2,"924":1,"938":1,"947":1,"955":1,"957":1,"964":1,"971":1}}],["方法区中的常量引用的对象",{"1":{"116":1}}],["方法区中的类静态属性引用的对象3",{"1":{"116":1}}],["方向即横向",{"1":{"726":1}}],["方向与正方向",{"1":{"693":1}}],["方向垂直于玩家视线",{"1":{"46":1}}],["方向",{"1":{"46":1}}],["方式排序",{"1":{"977":1}}],["方式有着非常良好的性能",{"1":{"726":1}}],["方式",{"1":{"472":1}}],["方式分为两种状况",{"1":{"283":1}}],["方式称之为",{"1":{"33":1}}],["方式来存储数据",{"1":{"33":1}}],["方式存储数据",{"1":{"33":1}}],["79771454",{"1":{"850":1}}],["73",{"1":{"823":2}}],["74",{"1":{"823":1}}],["72",{"1":{"823":2}}],["720",{"1":{"628":2}}],["72级",{"1":{"270":1}}],["7cfcb7b0cfe7",{"1":{"606":1}}],["768的时候效果比较好",{"1":{"568":1}}],["76",{"1":{"529":3}}],["7+",{"1":{"467":1}}],["7z然后旧可以解压了安装脚本都是执行在scoop",{"1":{"437":1}}],["7z类似的后缀",{"1":{"437":1}}],["75秒",{"1":{"854":1}}],["75",{"1":{"384":6,"390":1}}],["75swe",{"1":{"195":1}}],["70",{"1":{"297":2,"823":2}}],["700",{"1":{"99":1}}],["77级词缀等级",{"1":{"270":1}}],["71级物等",{"1":{"270":1}}],["71级之间",{"1":{"270":1}}],["71177规则和之前的一样",{"1":{"225":1}}],["78s",{"1":{"195":1}}],["78aa012966213643",{"1":{"103":1}}],["7kb",{"1":{"82":1}}],["7",{"0":{"46":1,"409":1},"1":{"46":1,"50":1,"103":2,"126":1,"220":1,"221":1,"225":1,"296":1,"297":4,"302":1,"541":1,"823":1,"981":1,"1023":1}}],["靠感觉弥补延迟太困难了",{"1":{"45":1}}],["欺骗",{"1":{"45":1}}],["67",{"1":{"823":2}}],["6时期ugui刚出来的时候发现的",{"1":{"667":1}}],["6时服务器就无法检测到射击命中",{"1":{"85":1}}],["6d9cf92d335d",{"1":{"607":1}}],["6和5",{"1":{"594":1}}],["6g",{"1":{"564":1}}],["6mb内存是有问题的",{"1":{"815":1}}],["6mb的垃圾",{"1":{"815":1}}],["6m",{"1":{"537":1}}],["65<",{"1":{"275":1}}],["65495333",{"1":{"211":1}}],["69",{"1":{"273":1,"275":1}}],["68",{"1":{"270":2,"529":1,"823":2}}],["640",{"1":{"625":2}}],["640分辨来制定",{"1":{"103":1}}],["64",{"1":{"225":1,"390":1,"437":1,"510":3,"533":1,"567":1}}],["60内完成绘制",{"1":{"854":2}}],["60sclearly",{"1":{"195":1}}],["60",{"1":{"194":1,"297":3,"960":1}}],["66416593",{"1":{"211":1}}],["66s",{"1":{"195":1}}],["66",{"1":{"86":1}}],["66运行时的约1",{"1":{"86":1}}],["66次每秒的频率更新模拟游戏世界",{"1":{"82":1}}],["6",{"0":{"45":1,"71":1,"77":1,"799":1,"800":1,"801":1},"1":{"46":1,"50":1,"88":1,"103":1,"126":1,"127":2,"214":1,"220":1,"221":1,"225":2,"266":1,"267":1,"290":2,"296":1,"297":2,"302":1,"529":3,"567":1,"594":1,"625":1,"952":1,"954":1,"981":1,"982":1,"1039":1},"2":{"801":1}}],["手动转换gameobject",{"1":{"1054":1}}],["手动触发",{"1":{"456":1}}],["手段",{"1":{"955":1}}],["手工转换",{"1":{"951":1}}],["手工克隆一个能够保证对象完全按照你所想的那样进行克隆的方式是手工克隆对象的每一个域",{"1":{"111":1}}],["手机很热",{"1":{"855":1}}],["手册如果",{"1":{"1022":1}}],["手册",{"1":{"527":1,"601":1,"859":1,"864":3,"926":1}}],["手枪皮套",{"1":{"44":1}}],["手感很好",{"1":{"15":1}}],["部分关系",{"1":{"1010":1}}],["部分目录结构说明如下",{"1":{"535":1}}],["部分代码这种方法",{"1":{"15":1}}],["部署一个",{"1":{"577":1}}],["部署的最小维度是容器",{"1":{"88":1}}],["部署版本2的应用",{"1":{"88":1}}],["部署版本1的应用",{"1":{"88":1}}],["部署",{"0":{"540":1},"1":{"44":1}}],["开销",{"1":{"940":1}}],["开源",{"1":{"717":1}}],["开头的",{"1":{"510":1}}],["开头的公钥复制下来",{"1":{"459":1}}],["开启srp",{"1":{"982":1}}],["开启static",{"1":{"979":1}}],["开启而",{"1":{"971":1}}],["开启了",{"1":{"942":1}}],["开启mesh",{"1":{"869":1}}],["开启垂直同步时若游戏的实际显示帧速大于60",{"1":{"854":1}}],["开启这两个参数会让显存占用增加",{"1":{"570":1}}],["开启方法",{"1":{"467":1}}],["开启fast",{"1":{"467":1}}],["开帮立派建好正殿之后",{"1":{"380":1}}],["开帮立派",{"1":{"380":1}}],["开山",{"1":{"368":1,"393":1}}],["开箱子掉落的装备等级=场景等级",{"1":{"269":1}}],["开始调用go",{"1":{"892":1}}],["开始时所在的可用内存地址上",{"1":{"885":1}}],["开始",{"1":{"407":1,"1023":1}}],["开始接受客户端的请求",{"1":{"167":1}}],["开始执行switcharoo",{"1":{"893":1}}],["开始执行技能",{"1":{"793":1}}],["开始执行另一个请求",{"1":{"158":1}}],["开始执行",{"1":{"131":1}}],["开始状态",{"1":{"43":1}}],["开发工具",{"1":{"955":1}}],["开发了",{"1":{"942":1}}],["开发的两大块",{"1":{"577":1}}],["开发中",{"1":{"577":1}}],["开发黑市",{"1":{"389":1}}],["开发者都要自己创造一个",{"1":{"217":1}}],["开发者可以通过限制外推时间来减轻外推误差",{"1":{"46":1}}],["开发这些模型或者贴图合成技术是为了能使用一块很小的由人工制作的贴图或者模型来生成大量相似的贴图或者模型",{"1":{"206":1}}],["开发人员可以构建一组",{"1":{"129":1}}],["开火的时候",{"1":{"79":1}}],["开火逻辑放在客户端",{"1":{"45":1}}],["开火逻辑可以建立在运动逻辑上面",{"1":{"44":1}}],["开火过程中的客户端预测",{"0":{"44":1}}],["然後在白天看一下任务内容",{"1":{"377":1}}],["然後原料店要盖出来",{"1":{"376":1}}],["然而从上面绘制四边形的数据中可以发现",{"1":{"846":1}}],["然而可以在播放模式下拷贝编辑过的对象并粘贴到编辑器中然后保存",{"1":{"737":1}}],["然而我们的libil2cpp被设计成可以方便使用其他垃圾回收器",{"1":{"591":1}}],["然而目前的常用的wsgi主要是针对http风格的请求响应模型做的设计",{"1":{"583":1}}],["然而在实际使用过程中",{"1":{"603":1}}],["然而在传统的哈希表中",{"1":{"92":1}}],["然而在多人游戏中我们还有更多全新的问题函待解决～最最",{"1":{"61":1}}],["然而却没打到",{"1":{"79":1}}],["然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题",{"1":{"72":1}}],["然而下一秒你告诉服务器",{"1":{"63":1}}],["然而这也不是纯客户端信息",{"1":{"43":1}}],["然而",{"1":{"43":2,"46":1,"48":1,"204":1,"737":1,"813":2,"823":2,"824":1,"826":1,"828":1,"829":1,"958":1,"1001":1}}],["然后重新创建关键代码",{"1":{"1050":1}}],["然后重新执行上述步骤",{"1":{"854":1}}],["然后这个材质的",{"1":{"1036":1}}],["然后选中minimap",{"1":{"1034":1}}],["然后选出一个当前在使用的输入模块中的process进行处理",{"1":{"668":1}}],["然后新建三个球体",{"1":{"1034":1}}],["然后手动的调用一次render",{"1":{"1033":1}}],["然后客户端",{"1":{"1020":1}}],["然后还需要处理这帧的自己的命令",{"1":{"1013":1}}],["然后转换完成后销毁这个worldgameobjectconversionutility",{"1":{"999":1}}],["然后具体的转换过程会新疆一个转换world主要执行gameobjectconversionmappingsystem",{"1":{"999":1}}],["然后才到gpu",{"1":{"981":1}}],["然后才到动态批处理",{"1":{"980":1}}],["然后设置每一个gameobjec的材质信息",{"1":{"979":1}}],["然后设置一次渲染状态",{"1":{"979":1}}],["然后等",{"1":{"971":1}}],["然后等待所有子节点的反馈是成功还是失败",{"1":{"280":1}}],["然后利用",{"1":{"966":1}}],["然后让一个",{"1":{"955":1}}],["然后就在conversion",{"1":{"951":1}}],["然后就处理pointerdown事件",{"1":{"671":1}}],["然后修改",{"1":{"944":1}}],["然后可能根据玩家的输入等因素来改变",{"1":{"940":1}}],["然后自定义对entity的操作",{"1":{"939":1}}],["然后经过计算处理",{"1":{"904":1}}],["然后清理对象4",{"1":{"898":1}}],["然后递归搜索对象引用并决定什么需要保留",{"1":{"898":1}}],["然后调用go",{"1":{"892":1}}],["然后调用这个委托",{"1":{"175":1}}],["然后向gpu发送drawcall命令",{"1":{"876":1}}],["然后向容器注册依赖配置文件的testoptions",{"1":{"172":1}}],["然后text上又叠了一个图片时",{"1":{"862":1}}],["然后又gpu从中读取命令",{"1":{"876":1}}],["然后又无法batch的话",{"1":{"862":1}}],["然后又重复上述的检查一次最后还需要调用所有被加入的monobehaviour的awake方法",{"1":{"858":1}}],["然后拼出对应的界面",{"1":{"861":1}}],["然后只对特定曾有用",{"1":{"859":1}}],["然后只对该区域内的像素进行检测即可",{"1":{"759":1}}],["然后从快照中取出",{"1":{"1017":1}}],["然后从中抽取一个对象作为实例送入渲染流程",{"1":{"981":1}}],["然后从内存加载到显存",{"1":{"876":1}}],["然后从已知的未使用的空间中移除分配的内存",{"1":{"827":1}}],["然后从该节点向前和向后遍历",{"1":{"105":2}}],["然后删除没有被引用的对象",{"1":{"813":1}}],["然后播放跳字等通用伤害客户端表现",{"1":{"809":1}}],["然后依次检验这些小的多边形",{"1":{"788":1}}],["然后依然是把newpressed赋值为这个控件的gameobject",{"1":{"657":1}}],["然后加上和减去半径就能得到投影长度了",{"1":{"785":1}}],["然后保留该多边形在该投影轴上所有投影中的最大值和最小值",{"1":{"763":1}}],["然后保存文件",{"1":{"722":1}}],["然后保存到runtime中",{"1":{"718":1}}],["然后保存好你的私钥和公钥到本地目录中",{"1":{"459":1}}],["然后触发一次增加component的事件",{"1":{"739":1,"744":1}}],["然后触发一个个事件",{"1":{"287":1}}],["然后预制件就可以使用了",{"1":{"737":1}}],["然后创建对象",{"1":{"718":1}}],["然后创建一个带monobehaviour的脚本文件",{"1":{"592":1}}],["然后插入到方法的最前端",{"1":{"717":1}}],["然后退回",{"1":{"715":1}}],["然后做数据填充",{"1":{"714":1}}],["然后填充size",{"1":{"713":1}}],["然后赋值给section的data",{"1":{"712":1}}],["然后去执行读取",{"1":{"712":1}}],["然后去同步块数组找一个闲置项",{"1":{"131":1}}],["然后由appdomain创建程序集中的对象",{"1":{"707":1}}],["然后由每个客户端根据怪物固定的攻击速度各自去表现",{"1":{"19":1}}],["然后逐个进行触发",{"1":{"680":1}}],["然后逐个进行计算",{"1":{"73":1}}],["然后逐一进行调用",{"1":{"678":1}}],["然后事件就会按照这个顺序被传递",{"1":{"662":1}}],["然后找到",{"1":{"657":1}}],["然后找到idea的卡片选择复制激活码",{"1":{"560":1}}],["然后取消其interactable和blocks",{"1":{"657":1}}],["然后取他们的交集",{"1":{"105":1}}],["然后搜索当前的",{"1":{"657":1}}],["然后搜索位置历史信息",{"1":{"46":1}}],["然后一个完整的事件系统就有了",{"1":{"654":1}}],["然后一直调用这个方法",{"1":{"175":1}}],["然后baseinputmodule会在updatemodule接口中将自己的状态修改成",{"1":{"654":1}}],["然后按照下面的格式指定你需要保留的类型",{"1":{"603":1}}],["然后对目标单位进行挥砍",{"1":{"795":1}}],["然后对检测得到的",{"1":{"684":1}}],["然后对该数据进行处理",{"1":{"669":1}}],["然后对input进行设置",{"1":{"653":1}}],["然后对这个泛型方法调用一下即可",{"1":{"600":1}}],["然后对比当前节点如果位置小于的话",{"1":{"108":1}}],["然后安装apk文件到设备并运行应用程序",{"1":{"585":1}}],["然后立即可以接受下一个请求",{"1":{"575":1}}],["然后我接收你的处",{"1":{"573":1}}],["然后我们就知道",{"1":{"1011":1}}],["然后我们的",{"1":{"966":1}}],["然后我们的搜索算法会按照之前走过来的路径回退到上一个操作点",{"1":{"210":1}}],["然后我们查看一下我们的注入方法",{"1":{"717":1}}],["然后我们看前面两个函数",{"1":{"717":1}}],["然后我们尝试着将代码注入到该函数中",{"1":{"717":1}}],["然后我们回到命令行",{"1":{"505":1}}],["然后我们统计每个玩家占领到的资源数量",{"1":{"215":1}}],["然后我们会有4个类似这样的约束矩阵对应不同方向的邻居",{"1":{"209":1}}],["然后鼠标右键",{"1":{"533":1}}],["然后开始巴滋巴滋地笔耕",{"1":{"502":1}}],["然后回车",{"1":{"463":1}}],["然后拉到下方找到如下图的地方点击添加一项",{"1":{"460":1}}],["然后使用同一个材质对其渲染",{"1":{"876":1}}],["然后使用目标平台的本机编译器进行编译",{"1":{"604":1}}],["然后使用",{"1":{"459":1,"535":1}}],["然后执行了base",{"1":{"1014":1}}],["然后执行一次操作",{"1":{"715":1}}],["然后执行相应的反射",{"1":{"715":1}}],["然后执行反射",{"1":{"715":1}}],["然后执行后面的",{"1":{"452":1}}],["然后执行这个委托",{"1":{"111":1}}],["然后继续接受客户端请求",{"1":{"441":1}}],["然后scoop保存的时候",{"1":{"437":1}}],["然后把石头丢出去砸到了某人",{"1":{"811":1}}],["然后把这个",{"1":{"535":1}}],["然后把那个公用的删除",{"1":{"422":1}}],["然后把tag的版本号填入上方的",{"1":{"145":1}}],["然后产出药材",{"1":{"304":1}}],["然后中间就是道路和风景一些道具图标以及工具",{"1":{"287":1}}],["然后停止自身",{"1":{"283":1}}],["然后会在进程中加载clr",{"1":{"707":1}}],["然后会再次搜索当前gameobject以及其父节点上是否有实现了ipointerclickhandler接口的控件",{"1":{"657":1}}],["然后会立即重新开始当前节点",{"1":{"283":1}}],["然后会根据约束矩阵",{"1":{"210":1}}],["然后决定低优先级节点",{"1":{"283":1}}],["然后绑定view",{"0":{"263":1}}],["然后进一步执行后续的createmodule操作",{"1":{"713":1}}],["然后进一步处理",{"1":{"15":1}}],["然后进行转换",{"1":{"1054":1}}],["然后进行存储",{"1":{"1054":1}}],["然后进行测试",{"1":{"594":1}}],["然后进行生成",{"1":{"259":1}}],["然后实例化任务",{"1":{"252":1}}],["然后境界限制学习的条件",{"1":{"251":1}}],["然后和角色属性进行对比",{"1":{"236":1}}],["然后分别覆盖",{"1":{"228":1}}],["然后分析输入模型",{"1":{"208":1}}],["然后要决定往哪边走",{"1":{"224":1}}],["然后为这些房间随机选取对应的预定义好的关卡模块",{"1":{"224":1}}],["然后随机使相邻的房间成为通路的一部分",{"1":{"224":1}}],["然后检查该特效的totalduration",{"1":{"237":1}}],["然后检查是否这个空间由土填满",{"1":{"220":1}}],["然后检查最大请求长度限制的设置项",{"1":{"167":1}}],["然后你修改",{"1":{"1036":1}}],["然后你给我什么",{"1":{"573":1}}],["然后你要去判断它是否和已经有的元素相交",{"1":{"220":1}}],["然后你把结果返回给客户端",{"1":{"63":1}}],["然后在手动调用",{"1":{"1054":1}}],["然后在",{"1":{"966":1,"967":1,"969":1}}],["然后在vs中运行",{"1":{"746":1}}],["然后在发生背景移动时",{"1":{"727":1}}],["然后在向这个gameobject的父级去找",{"1":{"657":1}}],["然后在里面定义用到的那些泛型实例的public变量",{"1":{"599":1}}],["然后在中间用长长的通道连接起来",{"1":{"219":1}}],["然后在每个玩家区域内不重不漏地采样出相等数量的植被",{"1":{"214":1}}],["然后在web项目中添加依赖",{"1":{"133":1}}],["然后返回第2步",{"1":{"210":1}}],["然后当填充这个瓦片相邻的四个瓦片时",{"1":{"209":1}}],["然后第一和第四步都是常规操作",{"1":{"208":1}}],["然后给予一个种子来生成一个更大的模型",{"1":{"208":1}}],["然后给类型的方法表里每个方法一个存根",{"1":{"131":1}}],["然后通过一次draw",{"1":{"980":1}}],["然后通过一个特定的种子来生成随机数",{"1":{"208":1}}],["然后通过改变相机的视口尺寸",{"1":{"841":1}}],["然后通过判断该点与圆心的距离是否小于圆的半径",{"1":{"755":1}}],["然后通过调整它的",{"1":{"726":1}}],["然后通过内置的il解译执行虚拟机来执行dll中的代码",{"1":{"710":1}}],["然后通过点积判断",{"1":{"693":1}}],["然后通过",{"1":{"510":1,"755":1}}],["然后通过瓦片的放置来完成地图",{"1":{"207":1}}],["然后通过修改appsettings",{"1":{"172":1}}],["然后通过线程栈上的根",{"1":{"131":1}}],["然后存储到数据库作为缓存注意开发环境下",{"1":{"144":1}}],["然后jit返回编译前的位置并把原来clr指向jit的地址修改为指向本地代码的地址",{"1":{"131":1}}],["然后模拟成x86代码",{"1":{"130":1}}],["然后用",{"1":{"955":1}}],["然后用手的四指从",{"1":{"840":1}}],["然后用一条",{"1":{"454":1}}],["然后用反射对所有域进行浅拷贝",{"1":{"111":1}}],["然后用找到的信息插值计算当前帧的位置",{"1":{"46":1}}],["然后移动到掩体内部的安全位置后才被命中了呢",{"1":{"79":1}}],["然后",{"1":{"75":1,"84":1,"92":1,"854":1,"860":1,"885":1,"887":1,"1025":1}}],["然后广播游戏状态",{"1":{"73":1}}],["然后方向键右被按下了",{"1":{"67":1}}],["然后服务器处理了出入之后计算出新的游戏状态",{"1":{"66":1}}],["然后服务端每秒钟20",{"1":{"12":1}}],["然后玩家等了半秒钟才开始移动",{"1":{"66":1}}],["然后告知玩家",{"1":{"63":1}}],["然后判定https",{"1":{"59":1}}],["然后根据你传入的组件类型的组合",{"1":{"915":1}}],["然后根据约束矩阵以及当前选择去更新记录矩阵中相邻点的记录",{"1":{"210":1}}],["然后根据记录矩阵中的值",{"1":{"210":1}}],["然后根据y坐标",{"1":{"105":1}}],["然后根据玩家的状态信息渲染当前帧",{"1":{"43":1}}],["然后根据确认的100帧操作去执行100帧",{"1":{"15":1}}],["然后将item添加到character的inventory",{"1":{"1008":1}}],["然后将渲染对象从硬盘加载到内存",{"1":{"876":1}}],["然后将屏幕坐标转换到",{"1":{"688":1}}],["然后将域名解析到该服务器安装nginx",{"1":{"550":1}}],["然后将",{"1":{"481":1}}],["然后将协议内容追加到服务器的",{"1":{"443":1}}],["然后将根据这些点与当前所选中的点的距离",{"1":{"210":1}}],["然后将结果叠加在一起",{"1":{"204":1}}],["然后将结果复制到目标状态",{"1":{"43":1}}],["然后将末端内存地址以后的内存全部回收",{"1":{"119":1}}],["然后将游戏状态更新为x=12",{"1":{"69":1}}],["然后将所有未收到回复但已经发送给服务器的输入用于预测",{"1":{"69":1}}],["然后将新的游戏状态发送给客户端",{"1":{"63":1}}],["然后将ai控制权发给那个客户端",{"1":{"20":1}}],["然后将指令发送给服务器",{"1":{"15":1}}],["然后写通用的方法",{"1":{"15":1}}],["然后快速执行101",{"1":{"15":1}}],["然后a和b立刻开始执行100帧",{"1":{"15":1}}],["然后再迭代",{"1":{"958":1,"1001":1}}],["然后再调用该接口的",{"1":{"957":1}}],["然后再根据mergemode进行最终结果的计算",{"1":{"903":1}}],["然后再从另一个待检测物体出发",{"1":{"760":1}}],["然后再进行回收",{"1":{"739":1}}],["然后再通过group将这次修改事件分发到collector或其他监听该group的模块中去",{"1":{"738":1}}],["然后再操作",{"1":{"707":1}}],["然后再使用",{"1":{"699":1}}],["然后再传给web服务器",{"1":{"581":1}}],["然后再",{"1":{"575":1}}],["然后再输入最后重启下服务器即可",{"1":{"464":1}}],["然后再输找到以下内容并修改修改完成后",{"1":{"464":1}}],["然后再重复一次密码",{"1":{"463":1}}],["然后再停止父节点在当前节点激活的时候",{"1":{"283":1}}],["然后再随机补充上非通路部分的房间",{"1":{"224":1}}],["然后再是整理内存",{"1":{"131":1}}],["然后再执行",{"1":{"130":1}}],["然后再按此方法对这两部分数据分别进行快速排序",{"1":{"107":1}}],["然后再将新的游戏状态传回给客户端",{"1":{"66":1}}],["然后再将这些颜色使用替换颜色",{"1":{"2":1}}],["然后再追上当前客户端的帧",{"1":{"15":1}}],["然后周边肯定有一部分的灰色去除不掉的",{"1":{"2":1}}],["修炼室也是门派中最基本的练武之地",{"1":{"380":1}}],["修炼室",{"1":{"380":1}}],["修罗场",{"1":{"297":1}}],["修为31",{"1":{"295":1}}],["修为27",{"1":{"295":1}}],["修为+随机的物品",{"1":{"295":1}}],["修为+战力17",{"1":{"295":1}}],["修为",{"1":{"295":2}}],["修仙式人生",{"0":{"295":1},"2":{"296":1,"297":1}}],["修正在一个网络传输周期以后才会执行",{"1":{"43":1}}],["修改这个值也会影响不透明物体的渲染顺序",{"1":{"1038":1}}],["修改component后查询是否改变",{"1":{"991":1}}],["修改cockpit",{"0":{"531":1}}],["修改都要增加新",{"1":{"944":1}}],["修改四个顶点的",{"1":{"726":1}}],["修改idea",{"0":{"559":1}}],["修改url",{"0":{"558":1}}],["修改dns",{"0":{"557":1}}],["修改内容如下执行",{"1":{"508":1}}],["修改root密码完成",{"1":{"463":1}}],["修改",{"0":{"286":1},"1":{"536":1,"908":1}}],["修改m",{"1":{"866":1}}],["修改migrationservice",{"1":{"133":1}}],["修改mysql配置my",{"1":{"8":1}}],["修改连接字符串",{"1":{"132":1}}],["修改引用地址等",{"1":{"131":1}}],["修改了现有的环境",{"1":{"89":1}}],["修改配置",{"0":{"432":1},"1":{"4":1}}],["小心名称有点易混",{"1":{"957":1}}],["小图自己是做不到每张图都是2的次幂的",{"1":{"861":1}}],["小堆垃圾收集快速可频繁收集",{"0":{"830":1}}],["小球位于第二条线",{"1":{"760":1}}],["小",{"1":{"721":1}}],["小的物体进行射线检测",{"1":{"695":1}}],["小于",{"1":{"694":1}}],["小结",{"0":{"457":1}}],["小女孩冲你露出一个可爱的笑容",{"1":{"296":1}}],["小猫贪吃的模样神似伊吹",{"1":{"296":1}}],["小猫安全回家了",{"1":{"296":1}}],["小概率被烧几件东西",{"1":{"295":1}}],["小成",{"1":{"248":1}}],["小房间",{"1":{"220":1}}],["小蓝点",{"1":{"201":1}}],["小蓝点代表输入值在单元正方形里的空间坐标",{"1":{"197":1}}],["小型客户端",{"1":{"43":1}}],["小端模式的多字节数据在存放时",{"1":{"36":1}}],["小端模式",{"1":{"33":1}}],["小端模式所谓的小端模式",{"1":{"32":1}}],["结算时",{"1":{"798":1}}],["结算",{"0":{"612":1},"1":{"798":1}}],["结合前面提到的linkedentitygroup",{"1":{"964":1}}],["结合改变数据和对数据的绘制",{"1":{"940":1}}],["结合上animation的录制功能",{"1":{"748":1}}],["结合透视和正交相机在unity2d游戏中制作视差效果",{"0":{"737":1}}],["结合",{"0":{"507":1}}],["结构不包含托管对象",{"1":{"927":1}}],["结构维持着",{"1":{"445":1}}],["结构的",{"1":{"445":1}}],["结构中最关键的变量时msec",{"1":{"42":1}}],["结居b",{"1":{"296":1}}],["结居洛",{"1":{"296":1}}],["结界阻拦了宫廷附近的跃怪",{"1":{"296":1}}],["结局b",{"1":{"296":13}}],["结局a",{"1":{"296":15}}],["结尾变化又慢下来",{"1":{"197":1}}],["结果并不如我们所期望那样",{"1":{"968":1}}],["结果用作运行时",{"1":{"965":1}}],["结果中是可行的",{"1":{"965":1}}],["结果是已经把额外增加的",{"1":{"963":1}}],["结果是正确的",{"1":{"67":1}}],["结果以参数中的列表返回",{"1":{"930":1}}],["结果改变了",{"1":{"896":1}}],["结果",{"1":{"836":1,"969":1}}],["结果将在函数返回后保留",{"1":{"828":1}}],["结果会按照元素之间的距离排序",{"1":{"662":1}}],["结果必定为4",{"1":{"197":1}}],["结果必定为1",{"1":{"197":1}}],["结果看似随机",{"1":{"197":1}}],["结论",{"0":{"174":1}}],["结束时显示",{"1":{"798":1}}],["结束时间减去开始时间就是下一帧的模拟时间在这个模型中",{"1":{"41":1}}],["结束时间减去开始时间就是下一帧的模拟时间客户端每完成一个帧循环",{"1":{"41":1}}],["结束特效",{"1":{"798":1}}],["结束后将跳出节点",{"1":{"691":1}}],["结束位置叫做",{"1":{"406":2}}],["结束语",{"0":{"170":1}}],["采取不需要传递函数作为参数的的编码风格​",{"1":{"819":1}}],["采样方式",{"1":{"731":1}}],["采矿增加经验",{"1":{"368":1}}],["采矿",{"1":{"368":1}}],["采矿场100层锄地",{"1":{"290":1}}],["采集药品",{"1":{"393":1}}],["采集药材+10",{"1":{"389":1}}],["采集药材之地",{"1":{"380":1}}],["采集矿物",{"1":{"393":1}}],["采集矿产+10",{"1":{"389":1}}],["采集木材+10",{"1":{"389":1}}],["采集时间",{"1":{"377":1}}],["采集的时候增加经验",{"1":{"368":1}}],["采集",{"1":{"368":1}}],["采集用户输入",{"1":{"41":1}}],["采用匿名函数而不是预定义函数​",{"1":{"819":1}}],["采用此方式的前提是",{"1":{"758":1}}],["采用米切尔候选算法均匀采样每一种资源",{"1":{"214":1}}],["采用这些特殊梯度向量的原因在",{"1":{"197":1}}],["采用不同的收集算法",{"1":{"122":1}}],["采用的话需要自己实现和测试",{"1":{"104":1}}],["采用延迟补偿以后带来的是另一种形式的不一致",{"1":{"48":1}}],["采用延迟补偿以后",{"1":{"48":1}}],["采用客户端运动预测以后",{"1":{"43":1}}],["采用上一个循环得到的模拟时间来模拟服务器控制的物体移动状态",{"1":{"41":1}}],["采用",{"1":{"12":1,"406":1,"813":1}}],["此次加速都会被打断",{"1":{"981":1}}],["此次批处理都会被打断",{"1":{"980":1}}],["此列显示了在特定帧中的托管堆上分配的字节数",{"1":{"878":1}}],["此规则仅面向以文本格式序列化的",{"1":{"866":1}}],["此表是一个n",{"1":{"800":1}}],["此节点顺序执行三个子节点",{"1":{"795":1}}],["此模块还需要管理技能等级",{"1":{"792":1}}],["此模块管理unit可使用哪些技能",{"1":{"792":1}}],["此方式反而会带来额外的性能消耗",{"1":{"728":1}}],["此方法调用后将会返回false",{"1":{"699":1}}],["此方法目前适用于idea",{"1":{"553":1}}],["此方法有两个重载",{"1":{"176":1}}],["此精灵的",{"1":{"726":1}}],["此配置文件提供对最新",{"1":{"721":1}}],["此配置文件与",{"1":{"721":1}}],["此委托方法将提供一个要绑定的图集标签和一个接受",{"1":{"705":1}}],["此assetbundle才会被卸载当使用unity的",{"1":{"701":1}}],["此函数不受锚点和中心的影响",{"1":{"645":1}}],["此函数受当前锚点和中心点的影响",{"1":{"645":1}}],["此项会根据设备真实分辨率与设计分辨率来对canvas进行缩放",{"1":{"628":1}}],["此应用的测试版尚未发布",{"0":{"611":1}}],["此商品无法在您设备所在的国家地区安装",{"0":{"609":1}}],["此链接",{"1":{"535":1,"536":1}}],["此处还包括属于通用模块的跳字等",{"1":{"807":1}}],["此处的何种行为",{"1":{"800":1}}],["此处的资源指的是使用",{"1":{"697":1}}],["此处不列举图例",{"1":{"755":1}}],["此处我是用的是visual",{"1":{"569":1}}],["此处只安装了",{"1":{"533":1}}],["此处逻辑较为复杂",{"1":{"15":1}}],["此版本的应用未配置为通过googleplay",{"0":{"612":1}}],["此版本的",{"1":{"465":1}}],["此地曾是某处世外绝境的屏障",{"1":{"297":1}}],["此地聚集了许多来自不同门派的弃徒",{"1":{"297":1}}],["此刻需要将对象从老的灯塔的观察者列表移除",{"1":{"104":1}}],["此id应该保持稳定",{"1":{"90":1}}],["此时添加",{"1":{"931":1}}],["此时该画布不会丢弃它的顶点缓冲区",{"1":{"860":1}}],["此时新的技能调用信息会被保存",{"1":{"793":1}}],["此时技能到达后摇点时",{"1":{"793":1}}],["此时我们可以选择记录某几个时间点上判定点的世界坐标",{"1":{"751":1}}],["此时判定就会出现错误",{"1":{"749":1}}],["此时就可以计算敌人是不是在攻击范围内",{"1":{"749":1}}],["此时就会调用ontriggerentry函数",{"1":{"748":1}}],["此时就会",{"1":{"689":1}}],["此时攻击范围为半径为5",{"1":{"749":1}}],["此时的",{"1":{"695":1}}],["此时拿到的结果一般来说并非预期的结果",{"1":{"644":1}}],["此时可以在",{"1":{"508":1}}],["此时可以在ts文件中使用全局api如果此时编译器未报错",{"1":{"399":1}}],["此时每个key就要按h",{"1":{"91":1}}],["此时",{"1":{"89":1,"628":1,"701":1,"854":2,"862":1,"890":1}}],["此时射击绝对万无一失",{"1":{"79":1}}],["此后再也不会读取配置文件",{"1":{"173":1}}],["此后",{"1":{"85":1}}],["此外禁用canvas组件不会触发canvas层级上性能消耗较大的ondisable",{"1":{"860":1}}],["此外如果泛型模版类就是在dll里定义的的话",{"1":{"599":1}}],["此外基于tickrate模拟的运动物体的速度也有精度的限制",{"1":{"85":1}}],["此外",{"1":{"40":1,"48":1,"104":1,"125":1,"574":1,"604":1,"721":1,"793":1,"795":1,"797":1}}],["介绍了很多在线动作游戏中采用的c",{"1":{"40":1}}],["本体",{"1":{"957":1}}],["本质是",{"1":{"535":1}}],["本质上是客户端缓存了接下来100ms的数据",{"1":{"46":1}}],["本节不讨论这个",{"1":{"444":1}}],["本节内容大多源于",{"1":{"197":1}}],["本草",{"1":{"393":1}}],["本来不打算房间能进的",{"1":{"287":1}}],["本身则属于",{"1":{"964":1}}],["本身为我们提供了一个非常好用的环境迁移的工具",{"1":{"481":1}}],["本身",{"0":{"233":1},"1":{"940":1}}],["本篇主要内容来自clr",{"1":{"131":1}}],["本篇文章讨论了如何提供给玩家顶尖的操作体验",{"1":{"40":1}}],["本机就宕机了",{"1":{"442":1}}],["本机映像生成器",{"1":{"128":1,"130":1}}],["本机到网络转换",{"1":{"38":1}}],["本地基本设置",{"1":{"737":1}}],["本地端口",{"1":{"467":1}}],["本地使用的",{"1":{"467":2}}],["本地ip",{"1":{"467":1}}],["本地删除当前用户目录下保存密码的文件",{"1":{"421":1}}],["本地方法栈中jni的引用的对象",{"1":{"116":1}}],["本地客户端收到其他玩家更新坐标的消息",{"1":{"74":1}}],["本地命令队列中已经有5条信息",{"1":{"43":1}}],["本文翻译自",{"1":{"789":1}}],["本文由",{"1":{"770":1}}],["本文将带你分析插件体积过大和启动速度过慢的原因",{"1":{"534":1}}],["本文以及提供的代码只会考虑正方形的瓦片",{"1":{"207":1}}],["本文我将使用2002年发明的改进版柏林噪声算法",{"1":{"197":1}}],["本文重点",{"1":{"175":1}}],["本文档",{"1":{"125":1}}],["本文是关于探索快节奏多人游戏的技术和算法系列的第一篇",{"1":{"61":1}}],["本文假设计算连接延时的时候客户端与服务器完全同步",{"1":{"50":1}}],["系統中",{"1":{"977":1}}],["系统的更新顺序为a",{"1":{"992":1}}],["系统的写缓存被刷新",{"1":{"448":1}}],["系统中有被用到",{"1":{"970":1}}],["系统中如果有服务器更变",{"1":{"91":1}}],["系统内部只把它们看过一个单独的",{"1":{"960":1}}],["系统支持的",{"1":{"946":1}}],["系统需要通过值来管理这些状态",{"1":{"932":1}}],["系统可能需要保持一个基于",{"1":{"932":1}}],["系统状态组件",{"0":{"931":1},"2":{"932":1,"933":1,"934":1,"935":1,"936":1}}],["系统",{"0":{"913":1},"1":{"958":1,"1001":1},"2":{"914":1,"915":1,"916":1,"917":1}}],["系统就会遍历所有可能接收输入事件的ui元素",{"1":{"860":1}}],["系统实现的射线投射类组件有physicsraycaster",{"1":{"654":1}}],["系统底层的mscorlib",{"1":{"592":1}}],["系统会检查怪物等级是否满足物品的成品qlvl",{"1":{"275":1}}],["系统将按照暗金",{"1":{"275":1}}],["系统是如何判断这个文件是一个合法的动态库呢",{"1":{"131":1}}],["系统自动扩容",{"1":{"89":1}}],["系统并不知道",{"1":{"39":1}}],["系列cpu采用little",{"1":{"33":1}}],["系列cpu采用big",{"1":{"33":1}}],["同前面說明",{"1":{"977":1}}],["同级的引用",{"1":{"965":1,"1003":1}}],["同上",{"1":{"868":1}}],["同张画布中的ui元素要有一样的z值",{"1":{"860":1}}],["同属于一个",{"1":{"695":1}}],["同wsgi一样是一种通信协议uwsgi协议是一个uwsgi服务器自有的协议",{"1":{"579":1}}],["同网站多账号的问题",{"0":{"422":1},"2":{"423":1}}],["同理可得知何时这个entity被移除或是a组件被移除",{"1":{"987":1}}],["同理",{"1":{"625":1,"755":1,"924":1}}],["同理也可用领悟的方式查",{"1":{"374":1}}],["同理就可以推导出其他三个瓦片能够选择的id",{"1":{"209":1}}],["同意",{"1":{"295":1}}],["同步命令到",{"1":{"443":1}}],["同步",{"0":{"142":1},"1":{"1013":1}}],["同步块索引的格式是前6个标志位加后面26位内容",{"1":{"131":1}}],["同步问题",{"0":{"68":1}}],["同一",{"1":{"1054":1}}],["同一个group中的所有system都会比下一个group中的system先执行",{"1":{"917":1}}],["同一个内存块中的所有实体的共享组件中的数据值都是相同的",{"1":{"905":1}}],["同一兵器武场在同一时刻只能安排一位门徒弟子进行练习",{"1":{"380":1}}],["同一徒手武场在同一时刻只能安排一位门徒弟子进行练习",{"1":{"380":1}}],["同一底材的暗金",{"1":{"273":1}}],["同一组的",{"1":{"127":1}}],["同一份数据可能在多个redis数据库",{"1":{"91":1}}],["同一时刻下服务端减去客户端的时间差",{"1":{"54":1,"55":1}}],["同一时刻下客户端减去服务端的时间差",{"1":{"54":1}}],["同样大小的物体",{"1":{"1025":1}}],["同样被删除了",{"1":{"971":1}}],["同样也把它们画入图中",{"1":{"898":1}}],["同样unity在",{"1":{"848":1}}],["同样可以将节点分为控制节点和执行节点",{"1":{"794":1}}],["同样是按照降序排列",{"1":{"695":1}}],["同样是灰幕寿衣",{"1":{"269":1}}],["同样在ugui中射线检测也是同样的存在",{"1":{"675":1}}],["同样有着7个等级的设定",{"1":{"380":1}}],["同样的",{"1":{"945":1,"968":1}}],["同样的创建一个",{"1":{"510":1}}],["同样的代码再次执行的话就直接在内存里拿了",{"1":{"131":1}}],["同样的有三个主要的操作",{"1":{"103":1}}],["同样",{"1":{"51":1,"91":1,"103":1,"663":1,"751":1,"831":1}}],["同样数值不同机器中表示不同",{"1":{"39":1}}],["同时结合",{"1":{"1035":1}}],["同时需在subshader中显示声明zwrite",{"1":{"976":1}}],["同时为了防止使用",{"1":{"955":1}}],["同时想在",{"1":{"954":1}}],["同时也会将正在视野中的符合要求的所有对象使用",{"1":{"982":1}}],["同时也会创建相同的",{"1":{"958":1,"1001":1}}],["同时也兼容",{"1":{"969":1}}],["同时也加上了指定的particlesystem和particlesystemrenderer",{"1":{"969":1}}],["同时也指定哪些组件会被保留",{"1":{"969":1}}],["同时也有inject",{"1":{"968":1}}],["同时也知晓用于存储转换结果的",{"1":{"947":1}}],["同时也非常适合用作灾难性恢复",{"1":{"441":1}}],["同时按顺序调用绘制函数",{"1":{"940":1}}],["同时又lable",{"1":{"901":1}}],["同时因为addfive",{"1":{"891":1}}],["同时栈分配内存空间给参数pvalue并复制x的值给它",{"1":{"891":1}}],["同时线程开始执行代码",{"1":{"890":1}}],["同时调整堆和栈里指向它们的指针",{"1":{"887":1}}],["同时调整提前量直到听到稳定的音调串",{"1":{"45":1}}],["同时资源量也尽可能少",{"1":{"861":1}}],["同时可能存在",{"1":{"849":1}}],["同时可以在参数中指定使用",{"1":{"698":1}}],["同时一定程度上影响代码的简洁性",{"1":{"848":1}}],["同时丢出一个弹道",{"1":{"811":1}}],["同时法术场的管理具有一定的成本",{"1":{"801":1}}],["同时此开销对性能的影响与游戏引擎的场景管理模块密切关联",{"1":{"731":1}}],["同时在finalization",{"1":{"898":1}}],["同时在代码实现良好的情况下",{"1":{"729":1}}],["同时在背景移动时",{"1":{"728":1}}],["同时在加载的过程中addressable在加载prefab的同时也会加载其依赖",{"1":{"699":1}}],["同时对于加载出来的资源一般情况下",{"1":{"701":1}}],["同时当所有的gameobject不再使用后",{"1":{"699":1}}],["同时自己保存返回的结果",{"1":{"699":1}}],["同时这些实例均引用相同的底层操作",{"1":{"697":1}}],["同时这个记录矩阵也需要回退相应的步数",{"1":{"210":1}}],["同时这个新玩家初始化九个格子内的所有玩家",{"1":{"103":1}}],["同时这个客户端会将这个怪物的行为上发到服务器",{"1":{"19":1}}],["同时保持最高效率",{"1":{"911":1}}],["同时保存下拖拽初始状态",{"1":{"671":1}}],["同时保证范围在",{"1":{"201":1}}],["同时保证了较好的游戏体验",{"1":{"20":1}}],["同时计算scalexy",{"1":{"626":1}}],["同时计算量变大",{"1":{"104":1}}],["同时",{"1":{"584":1,"701":2}}],["同时我们又会说",{"1":{"577":1}}],["同时它也是一个",{"1":{"576":1}}],["同时很多地图事件对机缘有要求",{"1":{"391":1}}],["同时安排门徒在此听训",{"1":{"380":1}}],["同时执行下面所有子节点的start",{"1":{"280":1}}],["同时销毁该实体",{"1":{"264":1}}],["同时决定了文字如何排序",{"1":{"155":1}}],["同时清理上述eden和survivor",{"1":{"120":1}}],["同时找到它视野范围内相关联的物体",{"1":{"104":1}}],["同时将对象添加进新的灯塔的观察者列表",{"1":{"104":1}}],["同时将这些对象添加到自己的视野队列中",{"1":{"104":1}}],["同时下发消息新增4",{"1":{"103":1}}],["同时他将新看到4",{"1":{"103":1}}],["同时通知aoi集合有玩家离开",{"1":{"103":1}}],["同时通过消息让服务器同步给其他玩家",{"1":{"20":1}}],["同时分别遍历oldaoi",{"1":{"103":1}}],["同时加入新格子",{"1":{"103":1}}],["同时包含开火的一瞬间确切的时间和方向",{"1":{"79":1}}],["同时服务器还是权威服务器",{"1":{"67":1}}],["同时假设延迟相等",{"1":{"54":1}}],["同时让游戏效果在可接受的范围内",{"1":{"20":1}}],["同时怪物自身的等级要大于或等于装备自身的",{"1":{"272":1}}],["同时怪物进入攻击状态",{"1":{"19":1}}],["同时怪物的移动也是采用基于预言的状态同步",{"1":{"17":1}}],["同时减少怪物的状态同步",{"1":{"17":1}}],["分离项目到不同的dll中",{"1":{"1050":1}}],["分离轴定理中用到的方法使算法本身显得十分独特",{"1":{"783":1}}],["分离轴定理需要一点数学向量的知识",{"1":{"782":1}}],["分离轴定理算法无法告诉你是那条边发生的碰撞",{"1":{"788":1}}],["分离轴定理算法只适用于凸多边形",{"1":{"788":1}}],["分离轴定理算法十分得准",{"1":{"787":1}}],["分离轴定理算法十分得快",{"1":{"787":1}}],["分离轴定理算法有它自己的优点和不足",{"1":{"786":1}}],["分离轴定理算法",{"0":{"782":1}}],["分离轴定理的整体代码实现",{"1":{"764":1}}],["分离轴定理",{"0":{"761":1},"1":{"782":2,"783":1},"2":{"762":1,"763":1,"764":1,"765":1,"766":1,"767":1,"768":1,"769":1,"770":1}}],["分代的",{"1":{"864":1}}],["分代收集算法",{"0":{"122":1}}],["分配器是",{"1":{"1022":1}}],["分配对象时",{"1":{"857":1}}],["分配在堆上然后通过指针访问的类型称为引用类型",{"1":{"826":1}}],["分配近似于闭包的内存量",{"1":{"819":1}}],["分开之后",{"1":{"765":1}}],["分支二",{"1":{"811":1}}],["分支一",{"1":{"811":1}}],["分支执行下面命令",{"1":{"507":1}}],["分支的",{"1":{"507":1}}],["分支",{"1":{"507":2}}],["分舵被人占领",{"1":{"380":1}}],["分舵可在当地招收门徒并进行与主舵内容完全一致的各类练习和工作",{"1":{"380":1}}],["分舵",{"1":{"380":1}}],["分等级",{"1":{"304":1}}],["分为",{"1":{"285":1}}],["分为固定精英怪",{"1":{"266":1}}],["分为三个操作",{"1":{"104":1}}],["分别按顺序在摄像机前排开",{"1":{"1039":1}}],["分别为自己和item再根据ownedcollection填充ownedabilitiesprepareownerforabilityupdate系统检查ability是否启用",{"1":{"1007":1}}],["分别调用渲染api绘制",{"1":{"979":1}}],["分别在法术场开始时",{"1":{"798":1}}],["分别可以分为法术场开始",{"1":{"798":1}}],["分别去根据这些表格中的内容",{"1":{"791":1}}],["分别得到这两个多边形的投影",{"1":{"784":1}}],["分别基于协程来return",{"1":{"714":1}}],["分别读取dll的pe的各个信息",{"1":{"711":1}}],["分别指锚点占父容器尺寸的百分比位置",{"1":{"643":1}}],["分别保存",{"1":{"444":1}}],["分别表示全局类库",{"1":{"398":1}}],["分别代表x轴正向",{"1":{"209":1}}],["分别随机",{"1":{"199":1}}],["分别创建对应版本的connection类",{"1":{"169":1}}],["分析器显示的事在特定帧被分配的比特数量",{"1":{"815":1}}],["分析策划需求发现",{"1":{"794":1}}],["分析",{"0":{"173":1}}],["分受信任的环境中是不可用的",{"1":{"111":1}}],["分治算法分治算法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题",{"1":{"107":1}}],["分治",{"1":{"106":1}}],["分块管理",{"0":{"101":1},"2":{"102":1,"103":1,"104":1}}],["分布的环位置如下图所示",{"1":{"96":1}}],["分布式部署",{"1":{"30":1}}],["分大小端unicode",{"1":{"39":1}}],["后按小项条件排序1",{"1":{"976":1}}],["后转换为等价的数据",{"1":{"967":1}}],["后某种",{"1":{"964":1}}],["后的结果",{"1":{"955":1}}],["后做些什么",{"1":{"951":1}}],["后文会解释",{"1":{"963":1,"965":1,"970":1}}],["后文会细讲",{"1":{"951":1}}],["后文会讲",{"1":{"949":1,"959":1}}],["后文将以上情况称之为在对象a的视野中加载对象b",{"1":{"102":1}}],["后两个批次可以合并",{"1":{"862":1}}],["后进行三角面片的绘制",{"1":{"847":1}}],["后来发现自己应该是不小心把attach",{"1":{"834":1}}],["后来发现",{"1":{"805":1}}],["后来我们对技能树进行了优化",{"1":{"795":1}}],["后来查了一下",{"1":{"39":1}}],["后摇时间点",{"1":{"794":1}}],["后摇角色动画",{"1":{"242":1}}],["后斩",{"1":{"794":1}}],["后",{"1":{"756":1,"935":1,"968":1}}],["后段部分的流程",{"1":{"695":1}}],["后台运行",{"0":{"469":1}}],["后台",{"1":{"455":1}}],["后台重写的触发条件",{"0":{"456":1}}],["后台重写都不会对主进程造成阻塞",{"1":{"455":1}}],["后台重写过程中",{"1":{"455":1}}],["后台重写",{"0":{"455":1},"1":{"455":1}}],["后缀ps1",{"1":{"430":1}}],["后缀名为",{"1":{"399":1}}],["后缀共分为四个系35个小组",{"1":{"270":1}}],["后一级比前一级的基础属性更高",{"1":{"273":1}}],["后续请求以相同的方式处理",{"1":{"827":1}}],["后续都是对其的封装和填充",{"1":{"714":1}}],["后续就可以进行合并操作了https",{"1":{"543":1}}],["后续代码会详细展示",{"1":{"199":1}}],["后续的时间就都能节省下来",{"1":{"839":1}}],["后续的",{"1":{"111":1,"275":1}}],["后者你无法得到disabled",{"1":{"970":1}}],["后者是递归地工作",{"1":{"958":1,"1001":1}}],["后者为了访问",{"1":{"954":1}}],["后者速度稍快初始化简单但在大字符串操作上耗内存",{"1":{"898":1}}],["后者可以传入一个你保存的数组避免重新分配",{"1":{"864":1}}],["后者则通过converttoentity",{"1":{"971":1}}],["后者则是可将武功秘籍交由其他同门师兄弟阅读",{"1":{"380":1}}],["后者则更原始一些",{"1":{"176":1}}],["后者得到的委托相当于",{"1":{"176":1}}],["后者将该方法的",{"1":{"129":1}}],["后26则变成这项在数组中的索引",{"1":{"131":1}}],["后26位会存储对象的hashcode",{"1":{"131":1}}],["后标志位改变一位",{"1":{"131":1}}],["后面组件部分会详细说明",{"1":{"908":1}}],["后面还会具体讲解commandbuffer",{"1":{"908":1}}],["后面会具体说这是个什么东东",{"1":{"905":1}}],["后面会用到",{"1":{"652":1}}],["后面对所有的",{"1":{"689":1}}],["后面3个参数则代表由输入点指向顶点的距离向量",{"1":{"202":1}}],["后面",{"1":{"170":1}}],["后面创建的对象类型的对象类型指针指针就指向这个type",{"1":{"131":1}}],["后面的服务器按顺序前移一位并将其编号值减一",{"1":{"91":1}}],["后期为了解决这个问题",{"1":{"12":1}}],["推出的",{"1":{"977":1}}],["推导坐标旋转公式感谢您的阅读",{"1":{"770":1}}],["推箱子",{"1":{"758":1}}],["推荐使用yarn或者npm进行安装",{"1":{"549":1}}],["推荐使用凭证存储模式",{"0":{"412":1},"2":{"413":1,"414":1,"415":1,"416":1,"417":1}}],["推荐使用这种方法",{"1":{"38":1}}],["推荐大格子具体的大小",{"1":{"103":1}}],["推算定位可以应用于低速情况",{"1":{"75":1}}],["推送",{"1":{"12":1}}],["造成合批失败",{"1":{"860":1}}],["造成对gpu发送更多drawcall",{"1":{"860":1}}],["造成其他角色看起来不像站在地面上一样",{"1":{"620":1}}],["造成这个错误的原因有两个",{"1":{"612":1}}],["造成运行时抛出找不到某个类型的异常",{"1":{"603":1}}],["造成黑屏",{"1":{"551":1}}],["造成缓存命中率降低",{"1":{"91":1}}],["造成数据冗余",{"1":{"91":1}}],["造成网关不能正常识别协议",{"1":{"38":1}}],["造成资源的浪费",{"1":{"36":1}}],["多個相同",{"1":{"977":1}}],["多個相同的",{"1":{"977":1}}],["多pass的shader会中断批处理",{"1":{"876":1}}],["多些重用",{"1":{"861":1}}],["多玩家场景",{"1":{"803":1}}],["多分辨率的思路是scaler中选择expand保证所有ui元素在屏幕内部",{"1":{"628":1}}],["多个组件的组合叫做一个原型",{"1":{"905":1}}],["多个",{"1":{"575":1}}],["多层背景可以同时只是用一种滚动方式",{"1":{"734":1}}],["多层和单背景混合",{"1":{"287":1}}],["多层组合",{"1":{"287":1}}],["多倍的性能损失了",{"1":{"175":1}}],["多倍的性能损失啊",{"1":{"175":1}}],["多人游戏击中检测不是基于像素的完美匹配",{"1":{"85":1}}],["多人游戏则不同",{"1":{"62":1}}],["多字节数值在发送之前",{"1":{"37":1}}],["多语言支持",{"1":{"30":1}}],["高的在前面",{"1":{"976":1}}],["高度是",{"1":{"841":1}}],["高比中选择最大值作为缩放因子",{"1":{"628":1}}],["高比中选择最小值作为缩放因子",{"1":{"628":1}}],["高谈阔论",{"1":{"295":1}}],["高等级词缀当然只能出现在物品等级和品质等级更高的装备上",{"1":{"270":1}}],["高耸的山地",{"1":{"204":1}}],["高",{"1":{"180":1,"625":1,"628":1}}],["高apm的玩家",{"1":{"73":1}}],["高速网络用户可以每秒更新50次",{"1":{"46":1}}],["高位字节存放在低地址处",{"1":{"37":1}}],["高地址部分权值高",{"1":{"32":1}}],["发生在数据保留位置",{"1":{"1021":1}}],["发生过极多可怕杀戮的凶恶之地",{"1":{"297":1}}],["发给测试人员激活",{"1":{"611":1}}],["发给服务器",{"1":{"64":1}}],["发呆同样会损耗精力",{"1":{"382":1}}],["发展受限",{"1":{"213":1}}],["发现cv",{"1":{"992":1}}],["发现去掉代码中一个单例类的析构方法中的断点即可调试了",{"1":{"836":1}}],["发现打包后的插件体积非常大",{"1":{"534":1}}],["发现占用空间资源比较大的时用户级别的nuget包",{"1":{"524":1}}],["发现",{"1":{"523":1}}],["发现identityserver4配置中",{"1":{"135":1}}],["发现没有标识则进入lock区域并把标识改变",{"1":{"131":1}}],["发现了",{"1":{"951":1}}],["发现了几个小问题",{"1":{"104":1}}],["发现了问题",{"1":{"89":1}}],["发现在100帧",{"1":{"15":1}}],["发布的",{"1":{"721":1}}],["发布il2cpp",{"0":{"594":1}}],["发布",{"1":{"88":1,"104":1}}],["发出消息以后就等待服务器响应",{"1":{"42":1}}],["发送的时候根据ghost的设置",{"1":{"1019":1}}],["发送的第一个字节是该数值在内存中的起始地址处对应的那个字节",{"1":{"37":1}}],["发送命令给服务端",{"1":{"1013":1}}],["发送goingamerequest请求",{"1":{"1013":1}}],["发送了remove",{"1":{"739":1}}],["发送到",{"1":{"407":1}}],["发送到服务器",{"1":{"63":1}}],["发送对时请求",{"1":{"51":1}}],["发送20次更新",{"1":{"46":1}}],["发送打包相应的物体",{"1":{"41":1}}],["​\t备用",{"1":{"529":3}}],["​\t主用",{"1":{"529":4}}],["​",{"1":{"37":1,"85":1,"113":1,"119":1,"120":1,"121":2,"122":2,"625":3,"738":2,"813":10,"814":6,"815":10,"816":1,"817":4,"818":9,"819":6,"820":5,"821":5,"822":9,"823":6,"824":8,"825":2,"876":2}}],["二是静态批处理",{"1":{"876":1}}],["二级属性",{"0":{"396":1}}],["二进制",{"1":{"111":1}}],["二",{"0":{"37":1,"114":1,"406":1,"841":1},"1":{"876":1},"2":{"115":1,"116":1,"117":1,"118":1,"119":1,"120":1,"121":1,"122":1,"123":1}}],["则物体的",{"1":{"1040":1}}],["则物体",{"1":{"1039":2,"1040":1}}],["则首先按照",{"1":{"1039":1}}],["则传入的z的值即你想选中的目标到摄像机的距离",{"1":{"1025":1}}],["则创建有hideflag的",{"1":{"969":1}}],["则负责将",{"1":{"969":1}}],["则意味着对象在",{"1":{"964":1}}],["则无所谓",{"1":{"958":1,"1001":1}}],["则无法掉落",{"1":{"275":1}}],["则得到一堆",{"1":{"956":1}}],["则得使用message手动触发事件忽略如果需要当前节点及子节点都不响应ui事件勾选raycast",{"1":{"657":1}}],["则能自动到",{"1":{"955":1}}],["则能帮助数据容易多线程处理",{"1":{"940":1}}],["则没有警告",{"1":{"952":1}}],["则运行在",{"1":{"949":1}}],["则确保了重复的数据查询是高效的",{"1":{"944":1}}],["则我只需要定义一个",{"1":{"931":1}}],["则禁用",{"1":{"872":1}}],["则不会有这样的效果",{"1":{"963":1}}],["则不显示",{"1":{"855":1}}],["则不能使用该方法",{"1":{"264":1}}],["则显示器扫描第1帧图像至屏幕垂直方向中点时",{"1":{"854":1}}],["则vertex的size为n",{"1":{"846":1}}],["则收集大约需要7ms",{"1":{"830":1}}],["则它占用的内存可以安全地重新分配",{"1":{"827":1}}],["则代价太大",{"1":{"807":1}}],["则延迟时间=0",{"1":{"804":1}}],["则跳过冲锋节点",{"1":{"795":1}}],["则这个顺树节点在执行的过程中并不会被end",{"1":{"795":1}}],["则技能可以自动结束",{"1":{"793":1}}],["则为不碰撞",{"1":{"761":1}}],["则为碰撞",{"1":{"759":1}}],["则旋转",{"1":{"756":1}}],["则必须为",{"1":{"722":1}}],["则主要是在热更新工程中添加对于unity工程的assembly",{"1":{"716":1}}],["则进行查找和填充",{"1":{"715":1}}],["则进行开始检查",{"1":{"252":1}}],["则在运行时试图使用jit编译时",{"1":{"709":1}}],["则卸载该应用程序域时也会同时卸载程序集",{"1":{"707":1}}],["则当进程运行时将无法从内存中卸载该程序集",{"1":{"707":1}}],["则当前节点组件",{"1":{"691":1}}],["则结果通过最终的测试可被用作事件的接收者之一",{"1":{"694":1}}],["则相交",{"1":{"693":1}}],["则将这些",{"1":{"946":1}}],["则将背向",{"1":{"693":1}}],["则将counter++",{"1":{"115":1}}],["则此次",{"1":{"691":1}}],["则此",{"1":{"691":1}}],["则直接调用组件实现的",{"1":{"691":1}}],["则直接返回不进行转换",{"1":{"36":1}}],["则判断组件是否是",{"1":{"691":1}}],["则指定",{"1":{"691":1}}],["则舍弃该事件",{"1":{"688":1}}],["则使用simulatedsafearearelative在editor代码中如果改变了模拟器的环境",{"1":{"852":1}}],["则使用",{"1":{"688":1}}],["则触发进入事件",{"1":{"671":1}}],["则",{"1":{"598":1,"701":1,"1040":1}}],["则执行一次静态构造",{"1":{"715":1}}],["则执行以下的命令安装",{"1":{"535":1}}],["则执行该装饰器下代码",{"1":{"283":1}}],["则控制台显示的信息可能类似这样",{"1":{"475":1}}],["则离开",{"1":{"369":1}}],["则该任务会被认为时激活的",{"1":{"277":1}}],["则该物品是低等物品",{"1":{"270":1}}],["则清空所有任务并",{"1":{"277":1}}],["则怪物能掉落该物品底材",{"1":{"275":1}}],["则实例化",{"1":{"260":1}}],["则会通过增量地重新转换",{"1":{"971":1}}],["则会在build",{"1":{"940":1}}],["则会把finalization",{"1":{"898":1}}],["则会更改该值而生产环境中则会使用notchsolutionutility",{"1":{"852":1}}],["则会先",{"1":{"575":1}}],["则会走出房屋",{"1":{"369":1}}],["则会进入下一个循环",{"1":{"278":1}}],["则会",{"1":{"277":3}}],["则会掉落该物品的蓝色形态并拥有2倍的耐久度",{"1":{"275":1}}],["则会掉落该物品的黄色形态并拥有3倍的耐久度",{"1":{"275":1}}],["则会根据地图id从characterspaceproxy中加载用户数据",{"1":{"262":1}}],["则会根据地图id从",{"1":{"261":1}}],["则会转换",{"1":{"259":1}}],["则会默认使用",{"1":{"167":1}}],["则根据随机数选择一个瓦片填入",{"1":{"210":1}}],["则根据a对象类型",{"1":{"102":1}}],["则生成失败",{"1":{"210":1}}],["则生成成功",{"1":{"210":1}}],["则是让",{"1":{"971":1}}],["则是使用",{"1":{"964":1}}],["则是实现了wsgi协议的一个web服务器",{"1":{"577":1}}],["则是几何纬度上正负向的单位向量",{"1":{"207":1}}],["则是以双字节表示一个整数",{"1":{"39":1}}],["则对该项目没有任何影响",{"1":{"524":1}}],["则对于",{"1":{"207":1}}],["则对象所属的对象链表的索引计算方式为",{"1":{"101":1}}],["则点积结果为0",{"1":{"197":1}}],["则点积结果为",{"1":{"197":1}}],["则拒绝用户的请求并断开连接",{"1":{"167":1}}],["则定义了处理http协议的应用程序的基本功能",{"1":{"163":1}}],["则公共语言运行时支持预编译模式",{"1":{"130":1}}],["则可以是一个",{"1":{"952":1}}],["则可以直接通过相应的",{"1":{"950":1}}],["则可以判断",{"1":{"935":1}}],["则可以判断这个实体是新添加的",{"1":{"934":1}}],["则可以考虑将用到的",{"1":{"861":1}}],["则可以",{"1":{"125":1}}],["则a",{"1":{"124":1}}],["则说明该对象已经被废弃",{"1":{"115":1}}],["则还需要维护多一个z轴的链表",{"1":{"106":1}}],["则他将不再看到1",{"1":{"103":1}}],["则通知格子内的所有玩家该玩家在移动",{"1":{"103":1}}],["则需要将你的",{"1":{"949":1}}],["则需要更新视差相机的裁剪平面",{"1":{"737":1}}],["则需要system",{"1":{"714":1}}],["则需要回退到上一个圆形节点",{"1":{"210":1}}],["则需要6个land来表示",{"1":{"99":1}}],["则需要同步地图中怪物的位置信息",{"1":{"16":1}}],["则发生了预测误差",{"1":{"84":1}}],["则播放相应的效果",{"1":{"43":1}}],["原有层级关系和组件的",{"1":{"947":1}}],["原型中也可以定义",{"1":{"928":1}}],["原型中的",{"1":{"905":1}}],["原型和内存块的关系是一对多的关系",{"1":{"905":1}}],["原型",{"0":{"905":1}}],["原文可能笔误",{"1":{"892":1}}],["原文链接",{"1":{"737":1,"833":1}}],["原因分析",{"0":{"836":1}}],["原因如下",{"1":{"36":1}}],["原子状态的数量远远小于buff的数量",{"1":{"800":1}}],["原子状态关系",{"1":{"800":1}}],["原子状态表示一类状态",{"1":{"800":1}}],["原本是一个天文学术语",{"1":{"724":1}}],["原本数据c是保存到redis3中",{"1":{"95":1}}],["原点",{"1":{"625":1}}],["原始编辑模式",{"0":{"647":1,"650":1}}],["原始打包",{"0":{"535":1}}],["原始对象及其克隆都会引用同一个对象",{"1":{"111":1}}],["原则上",{"1":{"449":1}}],["原则上每隔一秒钟就会执行一次",{"1":{"449":1}}],["原来是vertices数组中",{"1":{"846":1}}],["原来项目每次的编译时间从23s下降到7s",{"1":{"839":1}}],["原来老外也喜欢先谈优点啊～>～",{"1":{"787":1}}],["原来每位门人弟子都有12个小铜人",{"1":{"382":1}}],["原来optionsmonitor的更新能力是从ioptionschangetokensource而来",{"1":{"173":1}}],["原料店很重要",{"1":{"376":1}}],["原料店要设定下一个预见设施的储存量",{"1":{"376":1}}],["原数据被保存到顺时针的下一个服务器",{"1":{"94":1}}],["原地停留50ms后",{"1":{"68":1}}],["原理基础",{"0":{"545":1}}],["原理就是使用这个",{"1":{"510":1}}],["原理就是一个对象只要有gc",{"1":{"116":1}}],["原理是一样的",{"1":{"197":1}}],["原理",{"0":{"0":1,"144":1,"852":1,"986":1,"991":1},"1":{"777":1},"2":{"1":1}}],["竟然变成另外一个数字了",{"1":{"34":1}}],["试想",{"1":{"34":1}}],["操作是一样的",{"1":{"971":1}}],["操作是由后台子线程调用的",{"1":{"449":1}}],["操作两个不同对象",{"1":{"889":1}}],["操作",{"1":{"508":1,"876":1}}],["操作如下",{"1":{"503":1}}],["操作如下图",{"1":{"500":1}}],["操作之后的数据",{"1":{"451":1}}],["操作都会引起",{"1":{"448":1}}],["操作到游戏世界中的可视反馈之间的时间",{"1":{"82":1}}],["操作系统将会终止这个程序",{"1":{"814":1}}],["操作系统能识别的是hard",{"1":{"707":1}}],["操作系统提供了许多环境变量",{"1":{"574":1}}],["操作系统最后一次对",{"1":{"451":1}}],["操作系统",{"1":{"33":1,"38":1}}],["操作自己都是及时反馈的",{"1":{"15":1}}],["x最终变成vegetable",{"1":{"893":1}}],["x最终也会获得这个改变的值",{"1":{"892":1}}],["x的值是堆中myint对应在栈里的内存地址",{"1":{"892":1}}],["x的值为0x1122",{"1":{"33":1}}],["x就是3",{"1":{"889":1}}],["xbox",{"1":{"720":1}}],["xboxone",{"1":{"720":1}}],["xm加回来",{"1":{"601":1}}],["xml的xml文件",{"1":{"603":1}}],["xml",{"1":{"111":1,"524":1,"604":1}}],["xformers",{"1":{"570":1}}],["xiii",{"1":{"384":1}}],["xxx",{"1":{"422":1,"437":1}}],["xxx之xxx的",{"1":{"266":1}}],["xxx层",{"1":{"254":1}}],["xxproj",{"1":{"125":2}}],["xp以后的系统",{"1":{"131":1}}],["x轴格子数量",{"1":{"103":1}}],["x轴宽度",{"1":{"103":1}}],["x个land",{"1":{"101":1}}],["x=12",{"1":{"69":1}}],["x=11",{"1":{"69":1}}],["x",{"0":{"634":1,"635":1,"636":1,"637":1,"721":1,"722":1},"1":{"68":4,"101":1,"207":3,"270":5,"303":2,"633":6,"634":2,"635":3,"636":1,"637":1,"642":1,"657":1,"720":3,"721":4,"722":2,"726":1,"755":2,"756":6,"818":4,"820":2,"822":4,"823":2,"824":8,"840":1,"977":1,"1025":3},"2":{"722":1}}],["x64",{"1":{"33":2,"38":2,"585":1}}],["x86",{"1":{"33":3,"38":2}}],["很可能因为",{"1":{"971":1}}],["很酷吧",{"1":{"969":1}}],["很特殊",{"1":{"949":1}}],["很幸运",{"1":{"896":1}}],["很容易出现穿模",{"1":{"848":1}}],["很容易检查到提前或者滞后",{"1":{"51":1}}],["很显然",{"1":{"841":1}}],["很方便",{"1":{"811":1}}],["很简单",{"1":{"666":1}}],["很明显从左图中给定的三个点",{"1":{"846":1}}],["很明显",{"1":{"455":1,"896":1,"898":1}}],["很明显这种情况令人难以接受",{"1":{"68":1}}],["很难知道为什么会有这样的结果",{"1":{"966":1}}],["很难了",{"1":{"373":1}}],["很难注意到",{"1":{"151":1}}],["很难处理循环引用",{"1":{"115":1}}],["很少的服务节点",{"1":{"96":1}}],["很困难",{"1":{"89":1}}],["很有可能客户端发过来的数据超过了处理能力",{"1":{"50":1}}],["很多有",{"1":{"946":1}}],["很多时候",{"1":{"922":1}}],["很多情况下",{"1":{"832":1}}],["很多类型有可能会被意外剪裁掉",{"1":{"603":1}}],["很多观众都打赏了勾玉",{"1":{"296":1}}],["很多事物都只是被赋予了高大上的名字",{"1":{"206":1}}],["很多人都以为jit其实就是跟java",{"1":{"130":1}}],["很多公司都在使用蓝绿部署",{"1":{"88":1}}],["很多游戏都有爆头这一说",{"1":{"77":1}}],["很多军方仿真系统就是这样做的",{"1":{"45":1}}],["很多宽带网络质量很差",{"1":{"40":1}}],["很多用户的硬件配置跟网络跟当前最好的配置跟网络有一定差距",{"1":{"40":1}}],["很多的arm",{"1":{"33":1}}],["很自然的它会将你的数据翻译为0x78563412",{"1":{"34":1}}],["很大的原因在于项目需要一个后台可监控的应用",{"1":{"30":1}}],["要在多个光源的情况下使用实例化",{"1":{"981":1}}],["要在scene里面选择",{"1":{"951":1}}],["要更强",{"1":{"971":1}}],["要高级一些",{"1":{"970":1}}],["要记住linkedentitygroup",{"1":{"965":1}}],["要意识到",{"1":{"965":1}}],["要这样做",{"1":{"962":1}}],["要使用的数据",{"1":{"943":1}}],["要使用它也很简单",{"1":{"848":1}}],["要注意这个方法同时也会执行linkedentitygroup过程",{"1":{"970":1}}],["要注意这里有一丝",{"1":{"957":1}}],["要注意converttoentity只是转换对象为普通的",{"1":{"964":1}}],["要注意额外的entity都是新增的",{"1":{"961":1}}],["要注意的是你不能使用",{"1":{"949":1}}],["要注意",{"1":{"941":1,"958":1,"964":1,"1001":1}}],["要注意ui元素间的层叠关系",{"1":{"862":1}}],["要batch",{"1":{"862":1}}],["要解决这个问题",{"1":{"822":1}}],["要求",{"1":{"858":1}}],["要求两个三角面片使用不同的材质吗",{"1":{"847":1}}],["要求使用不同的材质",{"1":{"847":1}}],["要求技能前摇时间>2",{"1":{"804":1}}],["要求传入一个类型和一个实例",{"1":{"176":1}}],["要求传入一个类型",{"1":{"176":1}}],["要找出其离圆心最近的点",{"1":{"756":1}}],["要想使用批处理",{"1":{"876":1}}],["要想在游戏中获得更好的画质",{"1":{"854":1}}],["要想",{"1":{"707":1}}],["要想让",{"1":{"661":1}}],["要用的时候再加呗",{"1":{"681":1}}],["要实现",{"1":{"661":1}}],["要正确地使用sizedelta",{"1":{"644":1}}],["要获取某个recttransform的屏幕坐标",{"1":{"640":1}}],["要获取该对象的视野范围就变得非常简单",{"1":{"105":1}}],["要执行命令",{"1":{"444":1}}],["要练防3盘并且闪躲率高的",{"1":{"377":1}}],["要是卖米肉药",{"1":{"376":1}}],["要靠",{"1":{"375":1}}],["要",{"1":{"374":1}}],["要让每日练武成效破2千甚至3千以上",{"1":{"373":1}}],["要么是成功的",{"1":{"280":1}}],["要么是持续的",{"1":{"280":1}}],["要研究暗黑2的物品掉落系统",{"1":{"266":1}}],["要科学",{"1":{"225":1}}],["要知道",{"1":{"218":1}}],["要开发的资源以及要消灭的对手",{"1":{"212":1}}],["要不然是不确定的",{"1":{"206":1}}],["要先确定这些对象是否还有用",{"1":{"114":1}}],["要将宕机的服务器从编号列表中移除",{"1":{"91":1}}],["要做的最简单的事情是假设汽车的航向和加速度在100毫秒内保持不变",{"1":{"75":1}}],["要看具体的编译器",{"1":{"33":1}}],["要及时转成datetimeoffset",{"1":{"31":1}}],["为problem",{"1":{"1043":1}}],["为player添加ghostownercomponent",{"1":{"1013":1}}],["为gameobject添加各种component",{"1":{"1042":1}}],["为准",{"1":{"1036":1}}],["为内存泄漏",{"1":{"1022":1}}],["为connection设置commandtargetcomponent为localplayer",{"1":{"1013":1}}],["为connection设置commandtargetcomponent",{"1":{"1013":1}}],["为connection添加networkstreamingame组件",{"1":{"1013":1}}],["为禁用功能准备的自动linkedentitygroup前文解释过",{"1":{"965":1}}],["为实例化准备的自动",{"1":{"965":1}}],["为实体做一个基于目前为止的一个简单线性外推",{"1":{"83":1}}],["为何有",{"1":{"952":1}}],["为何不直接使用透视投影来做呢",{"1":{"724":1}}],["为纯粹的",{"1":{"946":1}}],["为key的iresourcelocation",{"1":{"901":1}}],["为底下的ui的层级+1",{"1":{"862":1}}],["为解决这个问题",{"1":{"801":1}}],["为障碍物",{"1":{"758":1}}],["为例",{"1":{"726":1,"948":1}}],["为空",{"1":{"693":1}}],["为此建立一套单独的流程",{"1":{"810":1}}],["为此",{"1":{"586":1,"794":1,"795":1}}],["为密码",{"1":{"475":1}}],["为服务监听端口",{"1":{"475":1}}],["为加密方法",{"1":{"475":1}}],["为类库moment增添自定义方法",{"1":{"402":1}}],["为类库添加插件",{"0":{"402":1}}],["为害江湖",{"1":{"297":1}}],["为65",{"1":{"275":1}}],["为59",{"1":{"275":1}}],["为x",{"1":{"270":1}}],["为新的通道元素进行区域搜索",{"1":{"221":1}}],["为当前点选择了一个特定的瓦片",{"1":{"210":1}}],["为",{"1":{"153":1,"377":1,"510":1,"533":2,"569":1,"604":1,"685":2,"691":3,"693":1,"694":3,"695":1,"861":1,"944":1,"948":1,"1000":1}}],["为区域信息",{"1":{"153":1}}],["为silverlight定义的api",{"1":{"126":1}}],["为的cl",{"1":{"86":1}}],["为了能够让这套机制运作起来",{"1":{"981":1}}],["为了程序的执行",{"1":{"898":1}}],["为了决定哪些需要保留",{"1":{"898":1}}],["为了更清晰地说明这条规则",{"1":{"956":1}}],["为了更清晰的阐述这个问题",{"1":{"894":1}}],["为了更好的学习",{"1":{"840":1}}],["为了更好地解释这几种实现方式",{"1":{"725":1}}],["为了让这些物体可以被动态批处理",{"1":{"876":1}}],["为了让每名玩家在游戏初始时具有公平的战略特征",{"1":{"214":1}}],["为了cpu和gpu可以进行并行工作",{"1":{"876":1}}],["为了加快速度",{"1":{"858":1}}],["为了验证这个",{"1":{"847":1}}],["为了确定哪些堆块不再被使用",{"1":{"827":1}}],["为了确保持续的改进得以实施",{"1":{"594":1}}],["为了要传递到object",{"1":{"820":1}}],["为了实现这个需求",{"1":{"818":1}}],["为了实现以上功能",{"1":{"800":1}}],["为了实现高可用使用了3台redis",{"1":{"91":1}}],["为了完成技能的一些需求",{"1":{"795":1}}],["为了帮助其他那些不精通数学的开发者",{"1":{"782":1}}],["为了真正地掌握它",{"1":{"782":1}}],["为了易于理解",{"1":{"763":1}}],["为了保持你的group",{"1":{"745":1}}],["为了保证ui的位置",{"1":{"626":1}}],["为了保证他们的状态",{"1":{"382":1}}],["为了保证兼容性",{"1":{"130":1}}],["为了节省填充率我们使用了不透明的对象",{"1":{"737":1}}],["为了使其按照从上到下",{"1":{"639":1}}],["为了使客户端运动预测有效",{"1":{"43":1}}],["为了减轻头疼",{"1":{"897":1}}],["为了减轻这种效果",{"1":{"45":1}}],["为了减少使用构建和运行时的迭代次数",{"1":{"586":1}}],["为了拯救c盘空间",{"1":{"526":1}}],["为了检查",{"1":{"475":1}}],["为了处理的方便",{"1":{"443":1}}],["为了方便理解",{"1":{"885":1}}],["为了方便描述",{"1":{"755":1}}],["为了方便起见",{"1":{"443":1}}],["为了方便讲解",{"1":{"197":1}}],["为了跟上潮流上集市高价购买了一株",{"1":{"296":1}}],["为了便于理解",{"1":{"287":1}}],["为了解决这个问题",{"1":{"455":1,"800":1}}],["为了解决这种数据存储不平衡的问题",{"1":{"96":1}}],["为了解决以上的问题",{"1":{"453":1}}],["为了解决攻击使用什么技能",{"1":{"250":1}}],["为了判断我们的生成随机地图算法是否具有良好的平衡性指标",{"1":{"215":1}}],["为了兼顾效果与效率",{"1":{"214":1}}],["为了模块间不产生依赖",{"1":{"137":1}}],["为了达到这样的目的",{"1":{"71":1}}],["为了防止作弊",{"1":{"62":1}}],["为了避免对数据的完整性产生影响",{"1":{"452":1}}],["为了避免这种",{"1":{"412":1}}],["为了避免这种问题",{"1":{"50":1}}],["为了避免缓存溢出",{"1":{"199":1}}],["为了避免",{"1":{"46":1}}],["为了简单",{"1":{"44":1}}],["为了同步官方和考虑移动平台流量问题",{"1":{"17":1}}],["为什么使用图集",{"1":{"861":1}}],["为什么好好的模型要进行网格的合并呢",{"1":{"848":1}}],["为什么想看看事件系统的实现",{"0":{"666":1}}],["为什么不单独使用一个正交摄像机看角色",{"1":{"620":1}}],["为什么不把服务器逻辑取消",{"1":{"45":1}}],["为什么还需要",{"1":{"581":1}}],["为什么也会更新呢",{"1":{"173":1}}],["为什么呢",{"1":{"173":1,"750":1}}],["为什么这样设计",{"0":{"137":1}}],["为什么要合并到人物模型上",{"1":{"848":1}}],["为什么要进行视野管理",{"0":{"97":1}}],["为什么要注意字节序的问题呢",{"0":{"34":1}}],["为什么会发生这种事情",{"1":{"79":1}}],["为什么会有这样的情况呢",{"0":{"33":1}}],["为什么是大约呢",{"1":{"75":1}}],["假設",{"1":{"975":1}}],["假想你拿一个电筒从不同的角度照射到两个图形上",{"1":{"783":1}}],["假扮渔贩施舍得丹药12",{"1":{"295":1}}],["假如当前材质的",{"1":{"1036":1}}],["假如物体符合前者",{"1":{"981":1}}],["假如物体符合前两者",{"1":{"980":1}}],["假如有30种material",{"1":{"877":1}}],["假如游戏帧速50",{"1":{"854":1}}],["假如感觉满足",{"1":{"380":1}}],["假如你没有完全把握应对",{"1":{"383":1}}],["假如你的门派声望够高",{"1":{"380":1}}],["假如你在旧金山",{"1":{"64":1}}],["假如需要还可以任命左右堂主",{"1":{"380":1}}],["假如增加一台服务器redis4",{"1":{"95":1}}],["假如redisservice2宕机了",{"1":{"94":1}}],["假如",{"1":{"50":1,"954":1}}],["假如某个客户端使用了外挂的话",{"1":{"15":1}}],["假设有一个网络同步",{"1":{"931":1}}],["假设执行方法",{"1":{"889":1}}],["假设执行完全预测",{"1":{"43":1}}],["假设所有ui元素",{"1":{"862":1}}],["假设某mesh有n个顶点",{"1":{"846":1}}],["假设context有上千个entities",{"1":{"740":1}}],["假设pixels",{"1":{"618":1}}],["假设我们有一个entity",{"1":{"987":1}}],["假设我们使用",{"1":{"581":1}}],["假设我们插值的物体是弹球",{"1":{"46":1}}],["假设目标目录是",{"1":{"429":2}}],["假设此时可以掉落该底材的暗金品质装备",{"1":{"275":1}}],["假设它的财宝等级",{"1":{"275":1}}],["假设在输入贴图中有且仅有一点坐标是",{"1":{"207":1}}],["假设新增一个对象z",{"1":{"106":1}}],["假设对象的坐标为",{"1":{"101":1}}],["假设平均每秒5个移动包",{"1":{"97":1}}],["假设你想要转换过程中",{"1":{"949":1}}],["假设你需要收集和处理所有entities",{"1":{"741":1}}],["假设你正用狙击枪完美的瞄准目标的头部",{"1":{"79":1}}],["假设你在t=1000收到位置信息",{"1":{"76":1}}],["假设你在玩赛车游戏",{"1":{"75":1}}],["假设你客户端延迟为100ms",{"1":{"45":1}}],["假设现在服务器延时250ms",{"1":{"68":1}}],["假设网络因为什么原因发生阻塞了呢",{"1":{"64":1}}],["假设数据传播的速度是光速",{"1":{"64":1}}],["假设同步频率还是10次每秒",{"1":{"46":1}}],["假设延时是100ms",{"1":{"46":1}}],["假设客户端运行帧率为50fps",{"1":{"43":1}}],["假设int占4个字节",{"1":{"32":2}}],["假定服务器即时通知客户端可以执行操作",{"1":{"43":1}}],["前文所述的方案听起来像是",{"1":{"969":1}}],["前文提到过",{"1":{"965":1}}],["前两个用途已经在前面的网络同步例子中呈现过",{"1":{"933":1}}],["前两个属性为面板属性",{"1":{"809":1}}],["前三个选项是阴影线框和阴影线框",{"1":{"847":1}}],["前三者通知对应灯塔区域的观察者",{"1":{"104":1}}],["前提是你把他加进了测试人员列表",{"1":{"610":1}}],["前言",{"0":{"534":1,"840":1}}],["前台运行",{"0":{"468":1}}],["前者是通过",{"1":{"971":1}}],["前者是为了避免重复",{"1":{"954":1}}],["前者速度稍慢初始化耗多点内存但在大字符串操作上节省内存",{"1":{"898":1}}],["前者会有大量的托管内存参考",{"1":{"864":1}}],["前者会分配托管内存",{"1":{"864":1}}],["前者可让门徒弟子学会新的武功",{"1":{"380":1}}],["前者得到的委托相当于",{"1":{"176":1}}],["前来应征的人属性也就越强",{"1":{"380":1}}],["前所未闻",{"1":{"296":1}}],["前往助拳+名气+道德29",{"1":{"295":1}}],["前辈拜访",{"1":{"295":1}}],["前缀",{"1":{"405":1}}],["前缀共分为三个系26个小组",{"1":{"270":1}}],["前缀和后缀又分别按照所代表属性的不同分成组",{"1":{"270":1}}],["前缀和后缀",{"1":{"270":1}}],["前摇结束",{"1":{"803":1}}],["前摇时间结束",{"1":{"796":1}}],["前摇时间",{"1":{"796":1}}],["前摇过程中目标移动",{"1":{"797":1}}],["前摇过程结束=技能结算时间点",{"1":{"794":1}}],["前摇过程",{"1":{"794":1}}],["前摇",{"1":{"242":1}}],["前",{"1":{"128":1,"971":1}}],["前面spawnhereecs的例子",{"1":{"967":1}}],["前面介绍的过程你也许会发现不仅仅可以将",{"1":{"965":1}}],["前面",{"1":{"963":1,"965":1}}],["前面说了每个内存块都有一个",{"1":{"930":1}}],["前面说的输入模块要检测到鼠标事件必须有射线投射组件才能确定目标对象",{"1":{"654":1}}],["前面提到的",{"1":{"756":1}}],["前面讲到",{"1":{"689":1}}],["前面已经提到过",{"1":{"275":1}}],["前面部分都是讲述到redis节点较多和节点分布较为均衡的情况",{"1":{"96":1}}],["前面文章",{"1":{"15":1}}],["前进键被按下的信息被存储在用户命令",{"1":{"84":1}}],["前32位应该这样读",{"1":{"32":2}}],["例",{"1":{"401":1}}],["例子",{"0":{"221":1},"1":{"32":2,"946":1}}],["例如transform",{"1":{"1054":1}}],["例如用",{"1":{"938":1}}],["例如用户表",{"1":{"137":1}}],["例如已经被分配的资源",{"1":{"932":1}}],["例如在组件中的值改变的时候",{"1":{"932":1}}],["例如在没有任何内存块拥有某个",{"1":{"930":1}}],["例如在一个32位的索引数组中使用了64位的指针从而导致c++编译器失败",{"1":{"594":1}}],["例如有时候我们的实体需要共享一套材质",{"1":{"928":1}}],["例如魔兽世界中",{"1":{"848":1}}],["例如上面所绘制的四边形",{"1":{"847":1}}],["例如上面的情况",{"1":{"96":1}}],["例如其反射率或粗糙度",{"1":{"844":1}}],["例如当一个对象被实例化时",{"1":{"827":1}}],["例如当水体比例过低时生成海岛地形",{"1":{"214":1}}],["例如color和vector3",{"1":{"826":1}}],["例如resharper中内置的il查看器或者dotpeek反编译器",{"1":{"821":1}}],["例如一个从上至下的斩击",{"1":{"750":1}}],["例如一个16bit的short型x",{"1":{"33":1}}],["例如设定两个向量",{"1":{"749":1}}],["例如玩家有一把剑",{"1":{"748":1}}],["例如玩家的位置信息",{"1":{"15":1}}],["例如未选中",{"1":{"705":1}}],["例如未受管理的资源",{"1":{"111":1}}],["例如是否在摄像机后面",{"1":{"676":1}}],["例如反射的部分内容和使用",{"1":{"604":1}}],["例如websocket",{"1":{"583":1}}],["例如我可以通过declarereferencedasset",{"1":{"964":1}}],["例如我定义一个射线ray",{"1":{"750":1}}],["例如我要监听点击事件我就实现一下ipointerclickhandler然后挂在物体上就好了",{"1":{"667":1}}],["例如我下一个设施想盖武场需要500肉和200",{"1":{"376":1}}],["例如我们可以轻易地给实体加标记来区分玩家和敌人",{"1":{"927":1}}],["例如我们有a",{"1":{"92":1}}],["例如我们要看战斗录像",{"1":{"15":1}}],["例如你的门派介面设定支薪10",{"1":{"371":1}}],["例如可以将",{"1":{"142":1}}],["例如安全和内存管理等",{"1":{"127":1}}],["例如visual",{"1":{"127":1}}],["例如x轴坐标为",{"1":{"106":1}}],["例如持久性提供程序",{"1":{"90":1}}],["例如每次只取出集群的20",{"1":{"89":1}}],["例如实例",{"1":{"88":1}}],["例如战列舰",{"1":{"75":1}}],["例如100ms一次",{"1":{"73":1}}],["例如16位或者32位的处理器",{"1":{"33":1}}],["例如时间递增",{"1":{"51":1}}],["例如quake3就支持这样的预测",{"1":{"45":1}}],["例如gbk的编码单元是字节",{"1":{"39":1}}],["例如秒杀场景",{"1":{"30":1}}],["例如获取随机数也需要回滚",{"1":{"15":1}}],["例如",{"1":{"15":2,"45":1,"48":1,"75":1,"85":1,"89":1,"91":1,"96":2,"152":1,"153":1,"155":1,"265":1,"397":1,"402":1,"460":1,"510":2,"578":1,"592":1,"722":1,"737":1,"846":1,"858":1,"872":1,"876":1,"905":1,"912":1,"923":1,"924":1,"979":1,"980":1}}],["例如前摇动作和位移",{"1":{"15":1}}],["例如领先5帧",{"1":{"15":1}}],["例如网络好的",{"1":{"15":1}}],["例如a核对后",{"1":{"15":1}}],["保留原有hierarchy关系的gameobject",{"1":{"1054":1}}],["保留与之前轮的所有采样点中最小距离最大的点作为本轮的采样结果",{"1":{"214":1}}],["保存为jpg",{"0":{"1033":1}}],["保存独立物体的像素",{"1":{"759":1}}],["保存操作由子线程执行",{"1":{"451":1}}],["保存模式对数据的安全性",{"1":{"457":1}}],["保存模式对性能和安全性的影响",{"0":{"451":1}}],["保存模式的工作方式",{"1":{"451":1}}],["保存模式",{"0":{"447":1},"1":{"447":1,"451":1},"2":{"448":1,"449":1,"450":1}}],["保存条件被满足的话",{"1":{"443":1}}],["保存在内存的高地址中",{"1":{"32":1}}],["保存在内存的低地址中",{"1":{"32":1}}],["保护的那个要全身封印装",{"1":{"377":1}}],["保护",{"1":{"377":1}}],["保险柜等等",{"1":{"220":1}}],["保证后台和你传入的购买商品的",{"1":{"610":1}}],["保证服务器性能提高web服务器的io性能请求从客户端传到web服务器是需要时间的",{"1":{"581":1}}],["保证数据的安全性",{"1":{"455":1}}],["保证该装饰器节点是active状态",{"1":{"283":1}}],["保证该装饰器节点是inactive状态",{"1":{"283":1}}],["保证对象生命周期内hashcode的唯一",{"1":{"131":1}}],["保证了网络不好的b的操作手感",{"1":{"15":1}}],["保持禁用这种情况没什么用",{"1":{"971":1}}],["保持对托管内存分配的追踪非常简单",{"1":{"815":1}}],["保持扩张的托管堆",{"1":{"814":1}}],["保持完好状态收场才不用花费休息时间",{"1":{"377":1}}],["保持时间基本一致",{"1":{"51":1}}],["保持玩家位于当前位置直到收到下一个更新包",{"1":{"46":1}}],["呢",{"0":{"32":1},"1":{"761":1,"841":1},"2":{"33":1,"34":1}}],["直观地说",{"1":{"1039":2}}],["直观地看下各顶点的影响值",{"1":{"197":1}}],["直至顺序节点的最后一个子节点执行完毕",{"1":{"795":1}}],["直至向上再没有节点或者节点绑定的组件中有被射线检测出来结果而返回",{"1":{"691":1}}],["直到下次某系统更新之后",{"1":{"991":1}}],["直到没有足够大的空闲区域分配所需的块大小",{"1":{"827":1}}],["直到根为止",{"1":{"679":1}}],["直到",{"1":{"452":1}}],["直到无休止的江湖纷争蔓延至此",{"1":{"297":1}}],["直到找到为止",{"1":{"657":1}}],["直到找到一个空的位置去放置楼梯",{"1":{"220":1}}],["直到找到横向或者纵向毗邻一个干净的方块那个",{"1":{"220":1}}],["直到找到大于的节点为止",{"1":{"108":1}}],["直到地牢建设完成",{"1":{"220":1}}],["直到地图中所有的单元格都被有且只有一个玩家占领",{"1":{"215":1}}],["直到整个地牢形成",{"1":{"219":1}}],["直到集群中所有的实例都更新成新版本",{"1":{"89":1}}],["直到一百年后你的角色向右移动了一格",{"1":{"64":1}}],["直到客户端有ct4事件出来时再执行st2",{"1":{"58":1}}],["直到怪物死亡或脱离战斗状态",{"1":{"19":1}}],["直的视线指向一个瞄准点然后开火",{"1":{"48":1}}],["直接转换",{"0":{"1025":1}}],["直接转化",{"1":{"966":1}}],["直接修改",{"1":{"975":1}}],["直接修改配置文件",{"1":{"524":1}}],["直接关联",{"1":{"958":1,"1001":1}}],["直接写脚本就可以了",{"1":{"811":1}}],["直接效果之外的触发效果",{"1":{"810":1}}],["直接挥砍",{"1":{"795":1}}],["直接使用的实例源代码",{"1":{"714":1}}],["直接使用position就可以",{"1":{"640":1}}],["直接判断当前",{"1":{"693":1}}],["直接上",{"1":{"658":1}}],["直接将3d物品拖到ui中然后添加rect",{"1":{"622":1}}],["直接跳到15",{"1":{"287":1}}],["直接调用事件",{"0":{"678":1}}],["直接调用",{"1":{"175":1}}],["直接去people类型对象的方法表里去找",{"1":{"131":1}}],["直接编译成目标计算机码",{"1":{"127":1}}],["直接内存访问",{"1":{"127":1}}],["直接由服务器同步的位置呈现",{"1":{"83":1}}],["直接取字串对应字节数组",{"1":{"39":1}}],["直接提供了网络字节序转换方法",{"1":{"38":1}}],["直接赋值",{"1":{"31":1}}],[">c",{"1":{"992":1}}],[">condition",{"1":{"281":1,"282":1}}],[">b",{"1":{"992":1}}],[">spawnhereecs",{"1":{"967":1}}],[">结束",{"1":{"876":1}}],[">绘制",{"1":{"876":1}}],[">绘图方式",{"1":{"876":1}}],[">顶点坐标",{"1":{"876":1}}],[">texte",{"1":{"862":1}}],[">imagef",{"1":{"862":1}}],[">imageb",{"1":{"862":1}}],[">imagea",{"1":{"862":1}}],[">inverter",{"1":{"282":1}}],[">lighting",{"1":{"859":1}}],[">p2",{"1":{"846":2}}],[">p1它们的区别在哪里呢",{"1":{"846":1}}],[">p1",{"1":{"846":1}}],[">projectsetting",{"1":{"703":1}}],[">叉乘应用c",{"1":{"781":1}}],[">点乘应用如果",{"1":{"780":1}}],[">editor如上图",{"1":{"703":1}}],[">a",{"1":{"780":1,"781":1,"992":1}}],[">addressable",{"1":{"700":1}}],[">asset",{"1":{"700":1}}],[">选择c盘",{"1":{"523":1}}],[">选项",{"1":{"422":1}}],[">存储",{"1":{"523":1}}],[">系统",{"1":{"523":1}}],[">验证编辑那个网站的账号",{"1":{"422":1}}],[">下面我将演示",{"1":{"398":1}}],[">",{"1":{"270":1,"282":2,"284":1,"467":1,"509":1,"571":2,"585":2,"652":2,"653":2,"657":1,"721":2,"737":1,"859":1,"868":16,"975":5,"976":1,"977":1,"991":1,"992":4,"1021":2,"1034":2}}],[">8",{"1":{"120":1}}],[">扣减库存",{"1":{"30":1}}],[">订单生成",{"1":{"30":1}}],["用与near",{"1":{"1025":1}}],["用",{"0":{"1023":1}}],["用预先转换的状态保持了",{"1":{"971":1}}],["用途的",{"1":{"955":1}}],["用克隆clone",{"1":{"896":1}}],["用引用的方式传递引用类型",{"0":{"893":1}}],["用文本编辑器打开",{"1":{"866":1}}],["用手握住",{"1":{"840":1}}],["用这个方法",{"1":{"739":1,"744":1}}],["用这样的方式插入是很快了",{"1":{"107":1}}],["用正交相机来渲染有角色",{"1":{"737":1}}],["用assembly",{"1":{"708":1}}],["用class代替",{"1":{"598":1}}],["用于渲染不透明物体",{"1":{"1036":1}}],["用于存储实例化位置",{"1":{"966":1}}],["用于存储一些数据点",{"1":{"817":1}}],["用于实例化",{"1":{"965":1}}],["用于寻址属性",{"1":{"858":1}}],["用于托管堆的地址空间",{"1":{"814":1}}],["用于射线检测",{"1":{"686":1}}],["用于接收各种eventdata",{"1":{"678":1}}],["用于接收前端服务器转发的动态请求并处理后发给",{"1":{"580":1}}],["用于检测场景中的",{"1":{"684":1}}],["用于检测",{"1":{"656":3}}],["用于加载",{"1":{"536":1}}],["用于授权访问你自己的",{"1":{"510":1}}],["用于上传资源到对应的",{"1":{"510":1}}],["用于创建",{"1":{"510":1}}],["用于确定一组输入最终挑选哪个梯度向量",{"1":{"199":1}}],["用法随时可能改变",{"1":{"971":1}}],["用法",{"0":{"474":1}}],["用法如下",{"1":{"471":1,"847":1}}],["用的",{"1":{"459":2}}],["用阵法成长时间加十年2",{"1":{"295":1}}],["用妖兽错过神兽大会",{"1":{"295":1}}],["用以处理http协议各个阶段和组成部分的功能集",{"1":{"164":1}}],["用到了int",{"1":{"131":1}}],["用反射进行克隆用反射进行克隆是使用activator",{"1":{"111":1}}],["用来表示上述平面离摄像机的距离",{"1":{"1025":1}}],["用来表示当当前点上的瓦片id是某个值时",{"1":{"209":1}}],["用来存放",{"1":{"971":1}}],["用来当作",{"1":{"950":1}}],["用来创建hybrid",{"1":{"943":1}}],["用来跟踪程序运行情况",{"1":{"879":1}}],["用来保存闭包需要的超过作用范围的对象",{"1":{"818":1}}],["用来在游戏概念中定义一个技能的所有特征",{"1":{"811":1}}],["用来在命令行中调用",{"1":{"536":1}}],["用来做射击游戏的攻击判定是非常合适的",{"1":{"750":1}}],["用来检测当前事件发送给哪个对象",{"1":{"656":1}}],["用来检查",{"1":{"240":2}}],["用来向",{"1":{"574":1}}],["用来为盒状模型提供最大的灵活性",{"1":{"405":1}}],["用来提高佛法境界",{"1":{"392":1}}],["用来提高武道境界",{"1":{"392":1}}],["用来升级技能",{"1":{"391":1}}],["用来制作食物",{"1":{"300":1}}],["用来响应中断停止应用程序的请求",{"1":{"164":1}}],["用来响应中断应用程序启动的请求",{"1":{"164":1}}],["用来接受用户请求",{"1":{"164":1}}],["用来插值的t=900和t=1000的数据依赖于游戏",{"1":{"76":1}}],["用来度量使玩家改变加速度的作用的快慢",{"1":{"50":1}}],["用上面介绍的外推法",{"1":{"46":1}}],["用户应按任意方式",{"1":{"705":1}}],["用户可以监听回调",{"1":{"705":1}}],["用户范围和计算机范围的级别",{"1":{"524":1}}],["用户帐户",{"1":{"420":1}}],["用户名",{"1":{"412":1}}],["用户信息暴露",{"1":{"412":1}}],["用户物品",{"0":{"262":1}}],["用户访问的时候",{"1":{"88":1}}],["用户指令被执行",{"1":{"85":1}}],["用户命令",{"1":{"86":1}}],["用户命令到达后",{"1":{"85":1}}],["用户命令到达服务器时间10",{"1":{"85":1}}],["用户命令处理完成后",{"1":{"85":1}}],["用户命令是由移动代码逻辑处理",{"1":{"84":1}}],["用户命令基本上是当前的键盘和鼠标状态的快照",{"1":{"82":1}}],["用户操作的响应速度",{"1":{"82":1}}],["用户社区通常采用这种情况来描述不一致性",{"1":{"50":1}}],["用户设置的每秒更新频率",{"1":{"50":1}}],["用户每秒可以请求任意数量的更新包",{"1":{"46":1}}],["用户会感觉到网络连接带来的明显延迟",{"1":{"42":1}}],["用户消息的内容",{"0":{"42":1}}],["用户虽然偶尔能够享受到高带宽",{"1":{"40":1}}],["用户下单",{"1":{"30":1}}],["用两个字节表示一个汉字",{"1":{"39":1}}],["用其标定一个具体的游戏状态",{"1":{"15":1}}],["良好的扩展性",{"1":{"30":1}}],["重用图集",{"1":{"861":3}}],["重启",{"1":{"722":1}}],["重启等",{"1":{"283":1}}],["重置idea体验版的插件",{"1":{"553":1}}],["重写是一个有歧义的名字",{"1":{"457":1}}],["重写的目的是用更小的体积来保存数据库状态",{"1":{"457":1}}],["重写的实现原理",{"1":{"454":1}}],["重写的实现",{"0":{"454":1}}],["重写的实现方式",{"1":{"453":1}}],["重写后的大小之间的比率大于等于指定的增长百分比",{"1":{"456":1}}],["重写可以由用户通过调用",{"1":{"456":1}}],["重写对性能造成的影响降到了最低",{"1":{"455":1}}],["重写之后",{"1":{"455":1,"456":1}}],["重写时的大小要大一倍的话",{"1":{"456":1}}],["重写时",{"1":{"455":1}}],["重写缓存中的内容全部写入到新",{"1":{"455":1}}],["重写缓存中",{"1":{"455":2}}],["重写缓存",{"1":{"455":1}}],["重写期间发生停机",{"1":{"455":1}}],["重写期间",{"1":{"455":2}}],["重写程序放到",{"1":{"455":1}}],["重写程序可以很好地完成创建一个新",{"1":{"455":1}}],["重写造成服务器无法处理请求",{"1":{"455":1}}],["重写并不需要对原有的",{"1":{"454":1}}],["重写",{"0":{"453":1},"1":{"454":1,"456":2}}],["重点",{"1":{"372":1,"373":1,"374":1,"375":1,"376":1,"377":1}}],["重点优化的是b",{"1":{"15":1}}],["重新生成",{"1":{"1051":1}}],["重新生长天数作物",{"1":{"303":1}}],["重新发布app等候google",{"1":{"607":1}}],["重新使用gitbook根据目录",{"0":{"505":1}}],["重新安装会是一个大麻烦",{"1":{"481":1}}],["重新安装您在",{"1":{"477":1}}],["重新执行一遍里面指示的所有命令",{"1":{"452":1}}],["重新加载配置",{"1":{"174":1}}],["重复字符串连接是一个典型的例子",{"1":{"828":1}}],["重复",{"1":{"254":1}}],["重击",{"1":{"247":1}}],["重入",{"0":{"158":1}}],["重要的是要避免那些比实际需要触发更多次收集器和在执行中引入暂停的错误",{"1":{"828":1}}],["重要的是技能的方向而不是技能目标一般来说",{"1":{"797":1}}],["重要",{"1":{"120":1}}],["重构后的系统架构如下图所示",{"1":{"91":1}}],["重试机制",{"1":{"30":1}}],["队列",{"1":{"30":1}}],["日历以及任务调度处理",{"1":{"30":1}}],["8s",{"1":{"535":1}}],["8个小铜人可根据苦力弟子",{"1":{"382":1}}],["800",{"1":{"625":2}}],["80",{"1":{"297":4}}],["80字节",{"1":{"97":1}}],["8c",{"1":{"287":3}}],["83620",{"1":{"527":1}}],["83",{"1":{"287":3,"625":1}}],["8e",{"1":{"287":4}}],["88119283",{"1":{"984":1}}],["88",{"1":{"270":1}}],["88级",{"1":{"270":1}}],["82",{"1":{"270":2,"287":4}}],["87",{"1":{"267":1}}],["84",{"1":{"267":1}}],["84s",{"1":{"195":1}}],["81",{"1":{"267":1,"287":4}}],["85级",{"1":{"270":1}}],["85级的场景中会出现普通怪物85级",{"1":{"265":1}}],["85+3",{"1":{"270":1}}],["85s",{"1":{"195":1}}],["85",{"1":{"189":1,"191":1}}],["864",{"1":{"287":1}}],["86s",{"1":{"195":1}}],["86",{"1":{"189":1,"191":1}}],["8x",{"1":{"181":1}}],["8由于几个字节表示并不相同",{"1":{"39":1}}],["8只是一串字节流",{"1":{"39":1}}],["8也没有字节序的问题",{"1":{"39":1}}],["8都是以单个字节表示数字的",{"1":{"39":1}}],["8",{"0":{"47":1,"982":1},"1":{"26":1,"47":1,"50":1,"103":2,"220":1,"221":1,"224":3,"296":1,"297":2,"302":1,"529":1,"618":1,"823":1,"960":2,"1023":1}}],["vulkan",{"1":{"980":1}}],["void",{"1":{"817":2,"823":2}}],["volo",{"1":{"156":1}}],["vector",{"1":{"765":1}}],["vector3",{"1":{"749":1,"751":2,"771":1}}],["vending",{"1":{"615":1}}],["vertex",{"1":{"846":1}}],["vertices和",{"1":{"864":1}}],["vertices",{"1":{"824":10}}],["vertices属性被访问时发生",{"1":{"824":1}}],["versus",{"1":{"486":1}}],["versa",{"1":{"194":1}}],["version用于描述这个实体的生命周期",{"1":{"906":1}}],["versioncode的值比提交到google",{"1":{"612":1}}],["versioncode",{"1":{"610":1}}],["version",{"1":{"25":1,"181":1,"488":1,"720":2,"998":1}}],["very",{"1":{"191":1}}],["vb",{"1":{"573":1}}],["v",{"1":{"568":1,"823":5,"984":1}}],["v4",{"1":{"544":1}}],["vsynccount",{"1":{"854":2,"855":2}}],["vs2019",{"0":{"834":1}}],["vsix",{"1":{"535":3}}],["vsce",{"1":{"535":1}}],["vscode",{"1":{"438":1}}],["vs",{"0":{"486":1},"1":{"534":2,"535":3,"537":1,"538":2,"544":1,"707":5,"835":2,"899":4}}],["v1",{"1":{"437":1,"510":1,"719":1}}],["v2",{"1":{"423":1}}],["v3",{"1":{"404":1}}],["vmoption文件",{"0":{"559":1}}],["vm差不多的东西",{"1":{"130":1}}],["vm",{"1":{"88":1}}],["var",{"1":{"424":2,"822":1,"824":1}}],["variant",{"1":{"960":1}}],["variables",{"1":{"515":1}}],["variable",{"1":{"424":2,"937":1}}],["variation",{"1":{"28":1,"29":1}}],["various",{"0":{"408":1},"1":{"22":1},"2":{"409":1,"410":1}}],["vast",{"1":{"196":1}}],["valuable",{"1":{"186":1}}],["valuetype",{"1":{"823":5,"881":1}}],["value",{"1":{"90":1,"486":1,"487":1,"707":1,"822":1}}],["values",{"1":{"90":1,"484":1}}],["valvesoftware",{"1":{"50":1,"87":1}}],["violation",{"1":{"607":1}}],["video",{"0":{"1027":1,"1028":1,"1029":1,"1030":1},"1":{"571":1}}],["videos",{"1":{"410":1}}],["visible组件",{"1":{"1008":1}}],["visibility",{"1":{"974":1}}],["vista",{"0":{"410":1}}],["visualstudio",{"1":{"606":1,"723":1}}],["visual",{"1":{"127":2,"722":2}}],["vice",{"1":{"194":1}}],["virtualcast",{"1":{"941":1}}],["virtual",{"1":{"131":1}}],["viewport",{"1":{"841":2}}],["view=vs",{"1":{"606":1,"723":1}}],["view=win10",{"1":{"499":1}}],["viewangles是一个三维向量",{"1":{"42":1}}],["viewangles",{"1":{"42":1}}],["view",{"1":{"23":1,"969":1,"971":6,"975":1}}],["view的预测执行",{"1":{"15":1}}],["via",{"1":{"22":1,"131":1}}],["nderqueue",{"1":{"976":1}}],["ndk",{"1":{"585":1}}],["n重天",{"1":{"807":1}}],["n为游戏中所有的原子状态的数量",{"1":{"800":1}}],["n的二维数组",{"1":{"800":1}}],["nvidia",{"1":{"564":1}}],["npm",{"1":{"500":2}}],["npc会说话",{"1":{"369":1}}],["npc的ai",{"1":{"369":1}}],["npc没有在固定时间接待",{"1":{"369":1}}],["npc互动和小游戏",{"0":{"362":1},"2":{"363":1,"364":1,"365":1,"366":1,"367":1}}],["npc生成方式",{"0":{"256":1},"2":{"257":1,"258":1,"259":1,"260":1,"261":1,"262":1}}],["npc任务指示的显示",{"0":{"252":1},"2":{"253":1,"254":1,"255":1}}],["ngui",{"1":{"1041":1}}],["nginx+uwgsi",{"0":{"581":1}}],["nginx中httpuwsgimodule的作用是与uwsgi服务器进行交换",{"1":{"580":1}}],["nginx也罢",{"1":{"580":1}}],["nginx就是一个web服务器",{"1":{"577":1}}],["nginx",{"1":{"532":1,"573":1,"575":2,"576":1,"577":1,"581":7}}],["ng",{"1":{"471":1}}],["ngen",{"0":{"130":1},"1":{"128":1,"130":2}}],["nativecontainer",{"1":{"1022":2}}],["nativearray",{"1":{"941":1,"1022":1}}],["natural",{"1":{"214":1}}],["narrow",{"0":{"768":1},"1":{"766":1}}],["navrátil告诉我他差不多会花掉一半的工作时间来设置正交视差层",{"1":{"737":1}}],["navigate",{"1":{"542":1}}],["nan",{"1":{"571":1}}],["nans",{"1":{"571":1}}],["nansexception",{"1":{"571":1}}],["name",{"1":{"184":1,"510":1,"951":1}}],["nightmare",{"1":{"192":1}}],["ny",{"1":{"103":2}}],["nx",{"1":{"103":7}}],["n是槽位数量",{"1":{"92":1}}],["n",{"1":{"92":1}}],["ncrontab",{"1":{"30":1}}],["num",{"1":{"823":4}}],["numbers",{"1":{"998":1}}],["number",{"1":{"26":1,"485":2}}],["null",{"0":{"486":1},"1":{"484":1,"486":2,"487":2,"524":1,"592":1,"657":1,"687":1,"694":1,"858":1,"946":1,"970":1}}],["nuxtjs",{"1":{"404":1}}],["nuget文件夹占用的空间很大",{"1":{"523":1}}],["nuget包管理器",{"1":{"132":1}}],["nuget",{"1":{"23":1,"523":1,"524":2,"525":2}}],["necessarily",{"1":{"195":1}}],["nearestneighbors列表每帧被分配一次",{"1":{"817":1}}],["nearestneighbors",{"1":{"817":7}}],["near近距离视差相机clear",{"1":{"737":1}}],["nearclipplane",{"1":{"684":1}}],["near除外",{"1":{"102":1}}],["near",{"1":{"102":2}}],["new",{"1":{"25":2,"28":1,"188":1,"191":1,"192":1,"424":1,"471":1,"817":2,"820":1,"822":2,"970":1}}],["needs",{"1":{"81":1}}],["need",{"1":{"25":1,"27":1,"28":1,"190":1,"193":1,"196":1,"485":1,"585":1}}],["next",{"1":{"25":1,"27":1,"28":1,"29":1,"571":1}}],["netcode",{"1":{"1016":1}}],["netfx",{"1":{"720":1}}],["netfilter",{"0":{"555":1,"556":1},"1":{"553":1,"556":1},"2":{"557":1,"558":1}}],["netfilter激活idea",{"0":{"552":1},"2":{"553":1,"554":1,"555":1,"556":1,"557":1,"558":1,"559":1,"560":1,"561":1,"562":1,"563":1}}],["net框架",{"1":{"717":1}}],["net框架中淘汰的讨论",{"1":{"111":1}}],["net本身反射来实现交互",{"1":{"716":1}}],["net应用程序或者一个运行库宿主时",{"1":{"707":1}}],["net和mono编译器对其进行编译",{"1":{"590":1}}],["net和java混为一谈",{"1":{"130":1}}],["net的核心库mscoree",{"1":{"131":1}}],["net库",{"1":{"130":2}}],["net程序引用",{"1":{"707":1}}],["net程序都要引用到的程序集",{"1":{"707":1}}],["net程序的基本部署单元",{"1":{"707":1}}],["net程序所有的il代码都编译成本地代码并保存在缓存区中",{"1":{"130":1}}],["net程序第一次运行都启动很慢的原因",{"1":{"130":1}}],["net程序被加载入内存以后",{"1":{"130":1}}],["net程序运行的重要部件之一",{"1":{"130":1}}],["net使用的是更为高级的技术",{"1":{"130":1}}],["net语言都将被编译成为一个叫做il汇编的中间语言",{"1":{"130":1}}],["netmodule",{"1":{"125":1}}],["net中可以当作gc",{"1":{"116":1}}],["netease",{"1":{"104":1}}],["net在定时任务处理方面优势如下",{"1":{"30":1}}],["net对比",{"0":{"30":1}}],["networkstreamreceivesystem",{"0":{"1013":1},"2":{"1014":1}}],["network",{"1":{"186":1,"187":1,"188":1,"191":1}}],["networked",{"1":{"15":1}}],["networkinglatency",{"1":{"81":1}}],["networking",{"1":{"15":1,"87":1,"186":1,"187":1,"189":2}}],["net",{"0":{"22":1,"23":1,"489":1,"721":2,"722":1},"1":{"10":1,"22":14,"23":4,"24":1,"25":1,"26":2,"27":1,"29":2,"30":2,"50":1,"85":1,"126":3,"127":1,"128":3,"155":2,"163":1,"164":1,"166":1,"170":1,"171":1,"173":1,"174":1,"176":3,"188":1,"190":1,"385":1,"467":1,"489":1,"491":1,"589":1,"604":2,"720":3,"721":12,"722":5,"789":1,"850":3,"899":4,"984":1},"2":{"722":2}}],["nodistancesort",{"1":{"975":1,"1037":3}}],["node",{"1":{"500":2,"535":1}}],["noprofile",{"1":{"424":1}}],["noerror",{"1":{"424":1}}],["normals",{"1":{"869":1}}],["normal等",{"1":{"847":1}}],["normal",{"1":{"266":1,"845":1,"846":2}}],["noise",{"1":{"197":1,"214":1}}],["now",{"1":{"26":1,"188":1,"864":1,"899":1}}],["notch",{"0":{"851":1},"2":{"852":1,"853":1}}],["not来看select",{"1":{"282":1}}],["notice",{"1":{"189":1}}],["nothing",{"1":{"188":1}}],["not",{"0":{"470":1},"1":{"26":1,"90":1,"181":1,"186":1,"188":1,"191":2,"192":1,"195":1,"484":1,"485":1,"486":1,"487":1,"571":3,"601":1,"707":1,"984":2}}],["notes",{"1":{"770":1}}],["note",{"1":{"24":1,"191":1,"192":1,"193":1,"195":1}}],["no",{"1":{"25":1,"188":1,"191":1,"193":1,"195":1,"196":1,"571":1}}],["none",{"1":{"186":1,"283":1,"915":1}}],["non",{"1":{"22":2,"25":1,"225":1}}],["07",{"1":{"998":1}}],["09",{"1":{"854":2}}],["0技能表",{"0":{"791":1}}],["02",{"1":{"770":1}}],["0271",{"1":{"81":1}}],["0位置的对象就会被远处的相机渲染",{"1":{"737":1}}],["0的视差中的所有东西都会被近处的相机渲染",{"1":{"737":1}}],["0的double值作为输出",{"1":{"197":1}}],["0parallax",{"1":{"737":1}}],["01far",{"1":{"737":1}}],["012",{"1":{"81":1}}],["0只有以下两种模型可以用",{"1":{"568":1}}],["0版本中替换成为解决办法",{"1":{"476":1}}],["05",{"1":{"385":1,"606":1,"854":2}}],["0是空",{"1":{"225":1}}],["003b",{"1":{"823":1}}],["0036",{"1":{"823":1}}],["0031",{"1":{"823":1}}],["0030",{"1":{"823":1}}],["003c",{"1":{"823":2}}],["002b",{"1":{"823":1}}],["0026",{"1":{"823":1}}],["0021",{"1":{"823":1}}],["001e",{"1":{"823":1}}],["001d",{"1":{"823":1}}],["001c",{"1":{"823":1}}],["001b",{"1":{"823":1}}],["001a",{"1":{"823":1}}],["0015",{"1":{"823":1}}],["0013",{"1":{"823":2}}],["001f",{"1":{"823":2}}],["00102",{"1":{"225":1}}],["000e",{"1":{"823":1}}],["000d",{"1":{"823":1}}],["0008",{"1":{"823":1}}],["0003",{"1":{"823":1}}],["0002",{"1":{"823":1}}],["0001",{"1":{"823":1}}],["0000",{"1":{"823":1}}],["00000",{"1":{"225":1}}],["00~am5",{"1":{"291":1}}],["00使用道具",{"1":{"290":1}}],["00",{"1":{"290":4}}],["0表示空瓦片",{"1":{"208":1}}],["0~1",{"1":{"197":1}}],["0中定义的api",{"1":{"126":1}}],["0语言",{"1":{"126":2}}],["0概要文件库",{"1":{"126":2}}],["0和",{"1":{"126":1}}],["0和c",{"1":{"126":1}}],["0和2^32",{"1":{"92":1}}],["0来关闭",{"1":{"84":1}}],["0x22放在高地址中",{"1":{"33":1}}],["0x22为低字节",{"1":{"33":1}}],["0x12345678来说",{"1":{"34":1}}],["0x12345678",{"1":{"32":1}}],["0",{"0":{"721":1,"802":1},"1":{"22":2,"23":1,"39":1,"64":1,"74":1,"83":2,"126":8,"135":2,"181":1,"191":4,"194":2,"195":11,"199":2,"201":2,"209":4,"224":2,"225":1,"228":1,"302":1,"385":1,"487":1,"510":2,"529":1,"544":1,"567":1,"592":1,"594":1,"625":3,"639":5,"685":2,"688":2,"693":1,"694":1,"695":5,"720":3,"721":5,"722":1,"726":2,"737":2,"763":2,"823":8,"824":4,"841":6,"944":2,"952":1,"960":1,"992":2,"1000":1},"2":{"722":1}}],["06",{"1":{"15":1,"287":4,"606":1}}],["qian",{"1":{"460":1}}],["q",{"1":{"270":5}}],["qlvl和其底材一样",{"1":{"271":1}}],["qlvl",{"1":{"270":1,"271":1,"272":1}}],["qtiger",{"1":{"131":1}}],["queue",{"0":{"1036":1},"1":{"975":3,"977":4}}],["queue的线程",{"1":{"898":1}}],["queue中",{"1":{"898":1}}],["queue里的指针后",{"1":{"898":1}}],["queue里指向它的指针移到freachable",{"1":{"898":1}}],["queue里",{"1":{"898":1}}],["queue里创建指向它们的指针",{"1":{"898":2}}],["queue有些情况下",{"1":{"898":1}}],["queue和终止化",{"1":{"898":1}}],["query与em都不能做到以只读方式做到",{"1":{"997":1}}],["query自动检查",{"0":{"994":1}}],["query",{"1":{"915":1,"964":3}}],["querystringrequestcultureprovider",{"0":{"152":1}}],["querieshittriggers设置为true",{"1":{"652":1}}],["quicksettings",{"1":{"571":1}}],["quickstart",{"1":{"543":1}}],["quicksort",{"1":{"107":1}}],["quality的设置",{"1":{"868":1}}],["qualitysettings",{"1":{"855":2}}],["quad",{"1":{"767":1}}],["quake等大多数pc游戏在关闭垂直同步后都会有这种现象产生",{"1":{"854":1}}],["quakeforge",{"1":{"50":1}}],["quake3对你的射击播放一个短音来进行确定",{"1":{"45":1}}],["quakeworld2中采用了这种类型的预测",{"1":{"43":1}}],["quartznet",{"1":{"29":2}}],["quartzhostedservice",{"0":{"27":1}}],["quartz",{"0":{"22":1,"23":1},"1":{"22":7,"23":2,"24":2,"25":4,"26":2,"27":5,"29":1}}],["q=fast",{"1":{"81":1}}],["q=lag+compensation",{"1":{"81":1}}],["q1source",{"1":{"50":1}}],["qq三国",{"1":{"287":1}}],["qq",{"1":{"15":1,"385":1,"984":3}}],["5实现了终结器",{"1":{"898":1}}],["5是被直接引用",{"1":{"898":1}}],["5被根roots引用",{"1":{"898":1}}],["5游戏",{"1":{"854":1}}],["5技能表现",{"0":{"798":1}}],["5时数字的填充时以中心点向上下方向扩展rect一般来讲",{"1":{"639":1}}],["5和0",{"1":{"639":1}}],["5缩放后的canvas的宽为",{"1":{"628":1}}],["5中c",{"1":{"823":1}}],["5中",{"1":{"591":1}}],["5中定义的api",{"1":{"126":1}}],["5点内力值",{"1":{"395":1}}],["5的非整数将四舍五入到最接近的5的整数",{"1":{"385":1}}],["5|",{"1":{"378":1}}],["5|虐杀|击中对手时有30",{"1":{"378":1}}],["59期间可以活动",{"1":{"291":1}}],["51",{"1":{"270":1}}],["512的",{"1":{"568":1}}],["512",{"1":{"99":1,"568":1}}],["5454",{"1":{"225":1}}],["5x3",{"1":{"225":1}}],["561",{"1":{"625":1}}],["56009",{"1":{"483":1}}],["56s",{"1":{"195":1}}],["5696",{"1":{"90":1}}],["5273281",{"1":{"131":1}}],["5倍",{"1":{"86":1}}],["5s的时刻射击了一个目标",{"1":{"85":1}}],["502的时候能给出更多的错误细节",{"1":{"576":1}}],["50s",{"1":{"195":1}}],["50",{"1":{"103":2,"175":1,"191":1,"297":3,"390":1,"625":1,"954":1}}],["500",{"1":{"957":1}}],["500depth",{"1":{"737":1}}],["5000",{"1":{"152":2}}],["500kb",{"1":{"97":1}}],["500ms的延迟也是有可能的",{"1":{"64":1}}],["503595998",{"1":{"90":1}}],["50次向所有客户端发送更新消息",{"1":{"12":1}}],["5",{"0":{"44":1,"65":1,"70":1,"76":1,"122":1},"1":{"26":1,"27":1,"46":1,"50":1,"88":1,"103":7,"126":1,"189":1,"214":2,"220":1,"221":1,"225":2,"266":1,"269":1,"290":1,"296":1,"297":2,"302":1,"304":1,"385":1,"390":1,"529":3,"628":1,"639":4,"645":1,"720":2,"737":1,"823":2,"854":1,"866":1,"953":1,"960":1,"977":1,"981":1,"982":1,"1054":1}}],["5th",{"1":{"26":1}}],["5dbdf81c4e69",{"1":{"21":1}}],["jp",{"1":{"941":1}}],["jpg",{"1":{"854":2}}],["jquery不可以",{"1":{"402":1}}],["jquery是一种umd库",{"1":{"397":1}}],["judging",{"1":{"196":1}}],["jueves",{"1":{"155":1}}],["justified",{"1":{"195":1}}],["just",{"1":{"24":1,"26":1,"131":1,"190":1,"709":1}}],["js",{"1":{"500":1,"535":1,"537":1,"581":1}}],["json中打开allumdglobalaccess配置项可以消除提示",{"1":{"401":1}}],["json文件中name的值修改为test",{"1":{"172":1}}],["json文件来修改testoptions的值",{"1":{"172":1}}],["json文件读取配置",{"1":{"172":1}}],["json文件",{"1":{"172":1}}],["json然后在中间件中删除acceptlanguageheaderrequestcultureprovider",{"1":{"157":1}}],["json",{"1":{"146":1,"186":1,"604":1}}],["js代码写得不是很好",{"1":{"104":1}}],["jvm只需要持有一个内存的起始地址即可",{"1":{"119":1}}],["jvm",{"1":{"116":1}}],["jimmy",{"1":{"564":1}}],["jit和clr",{"1":{"898":1}}],["jit编译的过程根本还没开始",{"1":{"709":1}}],["jit编译之前clr会对main方法的代码进行验证",{"1":{"131":1}}],["jit编译器就会将这段il代码",{"1":{"130":1}}],["jit的优化指的是可以针对本地cpu",{"1":{"130":1}}],["jit是",{"1":{"130":1}}],["jit",{"0":{"129":1},"1":{"116":1,"127":3,"128":1,"129":6,"130":4,"131":1,"709":1,"898":1}}],["jianshu",{"1":{"21":1,"606":1,"631":1,"719":1,"747":1,"863":1}}],["john",{"1":{"1052":1}}],["joaoborks",{"1":{"81":1}}],["job有延迟",{"1":{"997":1}}],["job代码",{"1":{"925":1}}],["job并不会立即开始执行",{"1":{"924":1}}],["job并不是独立运行的",{"1":{"922":1}}],["jobhandle",{"0":{"923":1}}],["job的依赖关系",{"0":{"922":1},"2":{"923":1}}],["job是一个统称",{"1":{"920":1}}],["job调度器会使用job依赖来决定哪些job可以并行",{"1":{"916":1}}],["jobcomponentsystem",{"1":{"910":1}}],["jobs",{"0":{"28":1,"916":1},"1":{"22":1,"25":1,"26":2,"27":1,"28":1,"29":2,"868":1,"944":1,"946":1,"957":1,"1021":1}}],["job",{"0":{"26":1},"1":{"22":3,"24":2,"25":2,"26":5,"27":2,"28":1,"510":1,"911":1,"926":1}}],["jar同目录下应该会有一个",{"1":{"556":1}}],["ja",{"1":{"553":1}}],["jan",{"1":{"225":1}}],["java",{"1":{"223":2,"573":1}}],["java程序吞吐量降低",{"1":{"118":1}}],["java语言是通过可达性分析算法来判断对象是否存活的",{"1":{"116":1}}],["java堆中存放着几乎所有的对象实例",{"1":{"114":1}}],["java编写的程序则唯一采用",{"1":{"33":1}}],["jagt",{"1":{"60":1}}],["jenny使用了roslyn",{"1":{"746":1}}],["jenny",{"0":{"746":1},"2":{"747":1}}],["jenkins",{"0":{"6":1},"2":{"7":1}}],["jetbrains",{"1":{"815":1}}],["jetbra",{"1":{"560":1}}],["jerk",{"1":{"46":1,"50":1}}],["相加之和越大",{"1":{"1040":1}}],["相应地",{"1":{"971":1}}],["相应代码则基于此来绘制",{"1":{"940":1}}],["相撞的双方依然存在",{"1":{"765":1}}],["相等",{"1":{"756":1,"976":1}}],["相等的时候",{"1":{"695":1}}],["相机可见",{"1":{"1032":1}}],["相机已经是父物体世界中的子物体了",{"1":{"841":1}}],["相机就相当于子物体",{"1":{"841":1}}],["相机的宽高比和屏幕宽高比一致",{"1":{"841":1}}],["相机放在z轴",{"1":{"737":1}}],["相机和场景设置",{"1":{"737":1}}],["相反",{"1":{"722":1,"879":1}}],["相反方向为反向",{"1":{"197":1}}],["相交区域",{"1":{"759":1}}],["相交",{"1":{"693":1}}],["相对不频繁并可以在游戏暂停期间处理的游戏最适用",{"1":{"831":1}}],["相对局限",{"1":{"753":1}}],["相对位置",{"1":{"640":2}}],["相对于屏幕的位置",{"1":{"1025":1}}],["相对于对应屏幕矩形就越来越小",{"1":{"1025":1}}],["相对于圆形与矩形",{"1":{"756":1}}],["相对于旋转点",{"1":{"756":1}}],["相对于",{"1":{"641":2,"645":1}}],["相对于父级物体的相对位置",{"1":{"640":1}}],["相对于普通扫格子的实现在代码层面耦合度降低",{"1":{"104":1}}],["相对比的一个选项是shrink",{"1":{"628":1}}],["相对使用保守垃圾回收策略",{"1":{"591":1}}],["相信大部分的前端开发者都知道",{"1":{"536":1}}],["相信大家已经看明白了",{"1":{"108":1}}],["相信用过的人都深有体会",{"1":{"510":1}}],["相关",{"1":{"971":1}}],["相关的组件自动添加到了gameobject的",{"1":{"969":1}}],["相关的代码进行构建",{"1":{"535":1}}],["相关依赖也存在于插件中",{"1":{"537":1}}],["相关配置",{"1":{"537":1}}],["相关连接",{"0":{"439":1}}],["相关链接",{"0":{"21":1,"162":1,"423":1,"499":1,"587":1,"606":1,"617":1,"706":1,"719":1,"723":1,"747":1,"812":1,"850":1,"919":1,"926":1}}],["相邻点的布局关系",{"1":{"209":1}}],["相同shader",{"1":{"982":1}}],["相同mesh",{"1":{"981":1}}],["相同材质批处理断开情况位置不相邻且中间夹杂着不同材质的其他物体",{"1":{"979":1}}],["相同材质球",{"1":{"979":1,"980":1,"981":1}}],["相同网格的多个副本",{"1":{"849":1}}],["相同",{"1":{"695":3,"1039":1}}],["相同的前提下",{"1":{"1039":1}}],["相同的",{"1":{"214":1}}],["相同的数据",{"1":{"86":1}}],["相同部分只算一次",{"1":{"177":1}}],["相同点",{"1":{"121":1}}],["相同字节序的平台在进行网络通信时可以不进行字节序转换",{"1":{"36":1}}],["相当于传统的localtranslation",{"1":{"1053":1}}],["相当于一个特殊的system的基类",{"1":{"1043":1}}],["相当于一开始就知道该从哪里是队头队尾",{"1":{"39":1}}],["相当于component",{"1":{"1042":1}}],["相当于滚动列表中的getdata",{"1":{"1031":1}}],["相当于drawcallsaved",{"1":{"877":1}}],["相当于变相的封锁了jit这种编译方式",{"1":{"709":1}}],["相当于if",{"1":{"282":1}}],["相当于",{"1":{"51":1,"1044":1}}],["相比fastcgi静态的唤起cgi",{"1":{"576":1}}],["相比",{"1":{"12":1,"198":1}}],["所看起来就越来越小",{"1":{"1025":1}}],["所看到的结果就是上一个方法",{"1":{"756":1}}],["所儲存的深度資訊",{"1":{"974":1}}],["所涉及的声明过程",{"1":{"966":1}}],["所指示entity的",{"1":{"952":1}}],["所关联的堆内存空间也会自动释放掉",{"1":{"937":1}}],["所里可以被不同的字典重用以节省内存",{"1":{"822":1}}],["所在",{"1":{"942":1}}],["所在在两个不同的reactivesystem中使用matcher相同的collector时",{"1":{"739":1}}],["所在的位置进行实例化了",{"1":{"966":1}}],["所在的坐标系就是",{"1":{"841":1}}],["所在的对象身上",{"1":{"686":1}}],["所在的对象有",{"1":{"684":1}}],["所在的cpu相关",{"1":{"33":1}}],["所寫",{"1":{"564":1}}],["所保存的文本",{"1":{"452":1}}],["所处的状态有关",{"1":{"449":1}}],["所使用的三种保存模式",{"1":{"446":1}}],["所使用的保存模式来决定",{"1":{"446":1}}],["所使用的数据库等信息",{"1":{"445":1}}],["所使用的策略可以考虑角色的伤害值",{"1":{"20":1}}],["所能炼制的丹药效果越好",{"1":{"380":1}}],["所得练武经验值及练武意愿",{"1":{"374":1}}],["所画",{"1":{"286":1}}],["所覆盖",{"1":{"212":1}}],["所谓state",{"1":{"986":1}}],["所谓的技能我们都理解为",{"1":{"811":1}}],["所谓的包装类型即指定了当",{"1":{"726":1}}],["所谓的",{"1":{"454":1}}],["所谓贴图是指数字动画中被贴在物体表面的图片",{"1":{"206":1}}],["所谓快慢针就是",{"1":{"108":1}}],["所谓十字链表法",{"1":{"105":1}}],["所谓灯塔法",{"1":{"104":1}}],["所有转换后的",{"1":{"965":1}}],["所有运行在第一个",{"1":{"964":1}}],["所有嵌套",{"1":{"960":1}}],["所有在conversion",{"1":{"956":1}}],["所有在mscorlib",{"1":{"593":1}}],["所有按钮都使用",{"1":{"955":1}}],["所有添加到lambda函数参数列表中的组件都会自动添加到实体查询的withall列表中",{"1":{"910":1}}],["所有gameobject所包含的material种类数量",{"1":{"877":1}}],["所有相邻层的可batch的ui元素将会在一个drawcall完成",{"1":{"862":1}}],["所有这些操作都是有成本的",{"1":{"858":1}}],["所有属性名称都经过哈希处理为属性",{"1":{"858":1}}],["所有返回数组的unity的api都会在每次它们被访问时返回一个该数组新的拷贝",{"1":{"824":1}}],["所有函数引用在c",{"1":{"818":1}}],["所有非空引用类型的对象和所有被装箱的值类型对象都必须被分配到托管堆上",{"1":{"813":1}}],["所有客户端接到信息后首先播放技能伤害相关的表现",{"1":{"809":1}}],["所有客户端都可信",{"1":{"45":1}}],["所有使用视差背景的游戏都会有横向滚动的情况",{"1":{"725":1}}],["所有raycast在enable的时候就会自动注册到raycaster",{"1":{"675":1}}],["所有如果ui即使全屏了",{"1":{"657":1}}],["所有对数据库进行修改的命令都会被记录到",{"1":{"455":1}}],["所有对象的视野都是full",{"1":{"102":1}}],["所有人物的基础闪避将以53点为开始",{"1":{"385":1}}],["所有人物升级所获得的都是一样的a每级+12最大生命b每级+2命中值c每级+3闪避值d每级+6最大魔力e每级+1天赋点人物有三大基础属性",{"1":{"384":1}}],["所有子节点都会执行reset",{"1":{"277":1}}],["所有的半透明物体都应该在这里渲染",{"1":{"1036":1}}],["所有的函数的调用都被独立记录",{"1":{"815":1}}],["所有的参与战斗逻辑的实体都是buff",{"1":{"811":1}}],["所有的客户端都是proxy",{"1":{"801":1}}],["所有的assembly代码是进程级别的",{"1":{"707":1}}],["所有的",{"1":{"695":1}}],["所有的事件通信都是用了",{"1":{"661":1}}],["所有的词缀总共分为2类",{"1":{"270":1}}],["所有的空间必须能够到达最后一点尤其重要",{"1":{"218":1}}],["所有的和",{"1":{"177":1}}],["所有的一切的起源都是作弊",{"1":{"62":1}}],["所有",{"1":{"130":1,"695":1,"927":1}}],["所有引用的对象都必须是可序列化的",{"1":{"111":1}}],["所有游戏对象的视野范围均为full",{"1":{"102":1}}],["所有外部请求的流量都打到这个版本上",{"1":{"88":1}}],["所有玩家都想要作弊",{"1":{"62":1}}],["所有会影响到武器状态的变量",{"1":{"44":1}}],["所有网络协议也都是采用",{"1":{"33":1}}],["所以该转换不一定是",{"1":{"1054":1}}],["所以该画布不再可见",{"1":{"860":1}}],["所以父实体需要添加translation和localtoworld",{"1":{"1053":1}}],["所以避免使用过多无用的插件",{"1":{"1051":1}}],["所以本质上srp",{"1":{"982":1}}],["所以srp",{"1":{"982":1}}],["所以缓冲区内有更多的空间可以动态地",{"1":{"982":1}}],["所以仅仅在合批操作的性能消耗小于不合批",{"1":{"980":1}}],["所以dynamic",{"1":{"980":1}}],["所以developer的类型对象指针指向developer",{"1":{"131":1}}],["所以meshfilter这样的",{"1":{"971":1}}],["所以重视这个参数名字",{"1":{"957":1}}],["所以若如下图附加到",{"1":{"951":1}}],["所以若策划想出一些需求需要使用多个法术场实现",{"1":{"807":1}}],["所以别害怕使用它",{"1":{"942":1}}],["所以迭代是线性且快速的",{"1":{"941":1}}],["所以ecs会把他们分类成是一类原型",{"1":{"905":1}}],["所以电视遥控器也会被画入图中",{"1":{"898":1}}],["所以结果是5是合理的",{"1":{"891":1}}],["所以unity称呼其为",{"1":{"1054":1}}],["所以ui就是这样一层一层地叠上去画出来的",{"1":{"862":1}}],["所以utf",{"1":{"39":1}}],["所以折衷一下",{"1":{"861":1}}],["所以将更新频率不同的ui分再不同的画布上",{"1":{"860":1}}],["所以切线最终规定为由uv坐标来决定朝向",{"1":{"846":1}}],["所以熟悉掌握",{"1":{"840":1}}],["所以所消耗的堆空间数量也增加了",{"1":{"828":1}}],["所以变成了一个闭包",{"1":{"818":1}}],["所以采用了以前一直只想没实践的想法",{"1":{"811":1}}],["所以是2个drawcall",{"1":{"862":1}}],["所以是可以接受的",{"1":{"804":1}}],["所以是没有明显的用于投影的轴",{"1":{"785":1}}],["所以默认为上行=下行另一种中庸的计算方式是",{"1":{"803":1}}],["所以默认正方向为",{"1":{"693":1}}],["所以叉乘一般是用来计算方向的",{"1":{"781":1}}],["所以现在的问题就是这么计算这个夹角计算的方式是",{"1":{"771":1}}],["所以最好也放在一起",{"1":{"810":1}}],["所以最好在initialize前",{"1":{"745":1}}],["所以最后双方都正确的收发了数据",{"1":{"36":1}}],["所以即使多次调用getgroup方法",{"1":{"740":1}}],["所以即使怪物坐标在不同的客户端有点不一致",{"1":{"18":1}}],["所以并没有产生多大影响",{"1":{"737":1}}],["所以天然支持无限延伸的背景",{"1":{"733":1}}],["所以编译完成之后就会自动执行",{"1":{"717":1}}],["所以基本不用操心",{"1":{"971":1}}],["所以基本方法还是readlistrange",{"1":{"714":1}}],["所以基本是没有延迟问题的",{"1":{"12":1}}],["所以相关的实质和前面一个部分相差不大",{"1":{"708":1}}],["所以top的值应该是一个负值2",{"1":{"645":1}}],["所以只有调用过jobhandle上的complete方法后",{"1":{"924":1}}],["所以只有當兩錨點某的維度的值相等的時候",{"1":{"644":1}}],["所以只要了解這兩個設定值關係與行為",{"1":{"633":1}}],["所以會用到",{"1":{"635":1,"636":1}}],["所以我计划先写到这里",{"1":{"971":1}}],["所以我会尝试着将代码注入到其中",{"1":{"717":1}}],["所以我們會透過",{"1":{"634":1}}],["所以我们可以将它的值复制回原transform",{"1":{"968":1}}],["所以我们已经可以利用其",{"1":{"966":1}}],["所以我们想出了一个可能并不是独一无二的方法",{"1":{"737":1}}],["所以我们这里添加了标签",{"1":{"717":1}}],["所以我们在每次修改代码之后都需要进行注入",{"1":{"717":1}}],["所以我们只能反映引用记数的变化",{"1":{"701":1}}],["所以我们不用单独安装",{"1":{"500":1}}],["所以我们的程序至少需要做下面几件事",{"1":{"208":1}}],["所以我们的算法就是根据输入贴图提供的这种约束关系来生成输出贴图",{"1":{"207":1}}],["所以红色正方形此时的高度为100",{"1":{"625":1}}],["所以2d单位的容器也需要旋转15度",{"1":{"620":1}}],["所以让我们把命令分拆一下",{"1":{"592":1}}],["所以wsgi只是一个协议",{"1":{"577":1}}],["所以出现动态技术",{"1":{"573":1}}],["所以请放在自己不会清理的位置",{"1":{"556":1}}],["所以直接输入密码",{"1":{"463":1}}],["所以程序使用了一个没有网络连接的伪客户端来执行命令",{"1":{"452":1}}],["所以一般说来",{"1":{"451":1}}],["所以一般还需要做多次统计一个比较合理的时间偏移",{"1":{"51":1}}],["所以要合并",{"1":{"862":1}}],["所以要确保你的atlasrequested回调一定能返回正确的值",{"1":{"705":1}}],["所以要自己做",{"1":{"434":1}}],["所以要想获得强力的高等级武器",{"1":{"380":1}}],["所以要想在总舵或分舵中招收更多的门徒弟子",{"1":{"380":1}}],["所以法术是默认必中的",{"1":{"385":1}}],["所以都只练腿掌法",{"1":{"374":1}}],["所以此代的学习力是可以成",{"1":{"374":1}}],["所以就要按照一定规则将图片进行分类",{"1":{"861":1}}],["所以就要另",{"1":{"373":1}}],["所以就写了多个",{"1":{"510":1}}],["所以就算是把mf堆到10000",{"1":{"275":1}}],["所以还是建议10就好",{"1":{"372":1}}],["所以进入sequence后会直接执行taskb",{"1":{"278":1}}],["所以怪物是68",{"1":{"270":1}}],["所以怪物的ai可以考虑放在客户端触发",{"1":{"17":1}}],["所以位置基本是固定出现",{"1":{"224":1}}],["所以生成器重写房间类型为2",{"1":{"224":1}}],["所以当销毁转换后的",{"1":{"959":1,"1002":1}}],["所以当我们增加一个",{"1":{"742":1}}],["所以当处理有关il2cpp的bug的时候",{"1":{"593":1}}],["所以当生成一个2d模型时",{"1":{"209":1}}],["所以当t=250ms的时候",{"1":{"69":1}}],["所以接下来将仅介绍2d下的离散模型合成技术",{"1":{"207":1}}],["所以哈希函数的返回值范围限定在",{"1":{"201":1}}],["所以数组最终长度为512",{"1":{"199":1}}],["所以在内存占用和发布的程序体积方面要优于static",{"1":{"980":1}}],["所以在这种情况下使用dynamic",{"1":{"980":1}}],["所以在多次draw",{"1":{"979":1}}],["所以在运行时cpu不需要再次执行顶点变换操作",{"1":{"979":1}}],["所以在绘制过程中",{"1":{"876":1}}],["所以在深究这个算法前",{"1":{"782":1}}],["所以在filter",{"1":{"739":1}}],["所以在z",{"1":{"737":1}}],["所以在800",{"1":{"625":1}}],["所以在",{"1":{"450":1}}],["所以在配置文件更新的下一次访问",{"1":{"174":1}}],["所以在t=1000到t=1100之间",{"1":{"76":1,"1015":1}}],["所以配置文件更新",{"1":{"173":1}}],["所以它是哪里来的",{"1":{"969":1}}],["所以它的安全性要高于模式",{"1":{"451":1}}],["所以它的值不会更新",{"1":{"173":1}}],["所以它不会引起服务器主进程阻塞",{"1":{"449":1}}],["所以它依然可以使用预测技术",{"1":{"74":1}}],["所以更改了以后的值是保留的",{"1":{"173":1}}],["所以很容易引起困惑",{"1":{"171":1}}],["所以可重入是很有必要的",{"1":{"158":1}}],["所以可以在",{"1":{"951":1}}],["所以可以在编辑器中用它来设置",{"1":{"737":1}}],["所以可以使用",{"1":{"914":1}}],["所以可以很容易的定义这些规则",{"1":{"800":1}}],["所以可以转移到同步块中",{"1":{"131":1}}],["所以可以将状态的概念向上扩大",{"1":{"19":1}}],["所以如果要判断是否点中一个目标",{"1":{"1025":1}}],["所以如果我遗漏了什么",{"1":{"789":1}}],["所以如果当一个点击事件被触发",{"1":{"657":1}}],["所以如果锚点不是在同一个点的情况下",{"1":{"645":1}}],["所以如果定压定频的话",{"1":{"551":1}}],["所以如果发现语言不是按照逻辑顺序显示",{"1":{"151":1}}],["所以如果你更改了docs",{"1":{"146":1}}],["所以建议控制台设置代理然后运行",{"1":{"149":1}}],["所以有种很好的移动性能",{"1":{"728":1}}],["所以有了锚点",{"1":{"625":1}}],["所以有了extra",{"1":{"140":1}}],["所以有时候会生成一些围墙",{"1":{"224":1}}],["所以有时我们也会把",{"1":{"33":1}}],["所以会有三种节点出现isconditionmet",{"1":{"283":1}}],["所以会很慢",{"1":{"144":1}}],["所以会调用developer方法表里的isrich方法",{"1":{"131":1}}],["所以会出现不同客户端里",{"1":{"18":1}}],["所以才能往上执行到基类方法表里的方法",{"1":{"131":1}}],["所以先加载mscorlib",{"1":{"131":1}}],["所以用索引就不用管数组在哪个位置了",{"1":{"131":1}}],["所以a",{"1":{"124":1}}],["所以c",{"1":{"124":1}}],["所以每次创建新范围时获取的都是一个新的值",{"1":{"173":1}}],["所以每次新生代就可以使用90",{"1":{"120":1}}],["所以每一步所有客户端的计算结果都一致的",{"1":{"11":1}}],["所以执行性能较低",{"1":{"118":1}}],["所以垃圾回收器所关注的主要是这部分的内存",{"1":{"113":1}}],["所以你也可以得到一堆完整复刻",{"1":{"947":1}}],["所以你可以将一个group添加到另外一个group中",{"1":{"917":1}}],["所以你应该根据你的实际使用场景来选择到底是用这三者中的哪一个",{"1":{"174":1}}],["所以你才你没有注意到这个问题",{"1":{"85":1}}],["所以你知道玩家在t=900和t=1000的位置",{"1":{"76":1,"1015":1}}],["所以再一次进行客户端预测",{"1":{"69":1}}],["所以他将这个备份丢弃掉",{"1":{"69":1}}],["所以角色的位置是x=11",{"1":{"69":1}}],["所以保险起见",{"1":{"64":1}}],["所以传播4000km需要13ms",{"1":{"64":1}}],["所以这会带来一些cpu的性能消耗",{"1":{"980":1}}],["所以这种方法不太适用于3d游戏",{"1":{"748":1}}],["所以这里的",{"1":{"695":1}}],["所以这里的补偿是补偿从客户端到服务端这段延迟",{"1":{"57":1}}],["所以这两个属性也是相对于父容器的",{"1":{"643":1}}],["所以这个东西很可能不重要",{"1":{"1038":1}}],["所以这个过程中",{"1":{"103":1}}],["所以这个问题不是很明显",{"1":{"18":1}}],["所以插值过程中需要考虑在服务器上玩家的目标是否正确",{"1":{"47":1}}],["所以考虑延迟补偿的过程中需要理解插值过程",{"1":{"47":1}}],["所以必须指定字节序",{"1":{"39":1}}],["所以也就不再赘述了",{"1":{"674":1}}],["所以也不要一口气把所有的事件全给重载了",{"1":{"681":1}}],["所以也不用再配置cgi端口",{"1":{"576":1}}],["所以也不会有字节序问题",{"1":{"39":1}}],["所以也只做了1和4",{"1":{"15":1}}],["所以为会有字节序问题",{"1":{"39":1}}],["所以不仅改变数据的逻辑非常高效而且绘制本身也是高效的",{"1":{"941":1}}],["所以不论循环两次还是两百次内存使用都是相同的",{"1":{"823":1}}],["所以不要在循环和update中使用",{"1":{"864":1}}],["所以不要在awake中获取rect",{"1":{"642":1}}],["所以不要让他领悟出来",{"1":{"373":1}}],["所以不需要使用entity来同步",{"1":{"808":1}}],["所以不需要将整个内存分为两个部分",{"1":{"120":1}}],["所以不需要预测",{"1":{"69":1}}],["所以不存在字节序问题",{"1":{"39":2}}],["所以不能由客户端来申请ai控制权",{"1":{"20":1}}],["所以需要先存储下cs文件进行索引",{"1":{"1047":1}}],["所以需要过滤下filter",{"1":{"742":1}}],["所以需要再次调用",{"1":{"699":1}}],["所以需要转换大小端转换c",{"1":{"38":1}}],["所以需要手动设置下contentroot如果启动失败",{"1":{"9":1}}],["所以说",{"1":{"37":1}}],["所以发送时会首先去低地址取数据的高字节",{"1":{"36":1}}],["所以b的操作手感",{"1":{"15":1}}],["所以",{"1":{"15":2,"130":1,"217":1,"219":1,"230":1,"455":1,"644":1,"695":1,"766":1,"819":2,"841":3,"855":1,"879":1,"920":1,"944":1,"946":1,"956":1,"964":1,"965":1,"979":1,"980":2,"1000":1,"1025":1,"1037":1}}],["所以除了渐变工具",{"1":{"0":1}}],["由隱藏的",{"1":{"977":1}}],["由该monobehaviour",{"1":{"951":1}}],["由以上可以发现",{"1":{"807":1}}],["由以下三角函数两角和差公式",{"1":{"756":1}}],["由上述可得投影对象",{"1":{"763":1}}],["由上述公式推导后可得",{"1":{"756":1}}],["由上可以转换为现假设",{"1":{"54":1}}],["由小到大排序",{"1":{"684":1}}],["由前面的执行流程图可知",{"1":{"653":1}}],["由il2cpp",{"1":{"595":1}}],["由il2cpp产生的c++代码和libil2cpp之间的接口api",{"1":{"591":1}}],["由它来分配",{"1":{"581":1}}],["由子进程来进行实际的持久化操作",{"1":{"442":1}}],["由游戏难度和地图难度决定",{"1":{"293":1}}],["由下图可以看出",{"1":{"282":1}}],["由少量的特殊怪兽或者生物会在生成房间的时候添加进去",{"1":{"220":1}}],["由一个小的地牢开始",{"1":{"219":1}}],["由接口的实现自己定义类型",{"1":{"165":1}}],["由局部变量",{"1":{"131":1}}],["由",{"0":{"129":1},"1":{"130":1,"427":1,"1040":1}}],["由操作系统直接执行的代码",{"1":{"127":1}}],["由此可见",{"1":{"37":1}}],["由那个客户端控制攻击行为",{"1":{"20":1}}],["由服务器广播给周围的其他玩家",{"1":{"19":1}}],["由于物理的转化规则",{"1":{"1000":1}}],["由于这个component只有在遍历的时候申请写入权限时才会记住版本号",{"1":{"991":1}}],["由于这个原因",{"1":{"813":1}}],["由于数据不再每帧被重新创建",{"1":{"982":1}}],["由于数组可能非常大",{"1":{"828":1}}],["由于我知道shipandco是一个",{"1":{"969":1}}],["由于我们没有过多的使用缩放",{"1":{"737":1}}],["由于你无法查看生成的代码是什么",{"1":{"967":1}}],["由于前文所提到的",{"1":{"947":1}}],["由于同一",{"1":{"942":1}}],["由于实体必须有一个或多个这样的",{"1":{"910":1}}],["由于实体是可以重用的",{"1":{"906":1}}],["由于实体插值包含在公式中",{"1":{"85":1}}],["由于对象3的地址变了",{"1":{"898":1}}],["由于对它们应用了透视视角",{"1":{"737":1}}],["由于此类",{"1":{"858":1}}],["由于显示器刷新率跟不上游戏的fps",{"1":{"854":1}}],["由于显而易见的原因",{"1":{"827":1}}],["由于栅栏墙高速向左运动",{"1":{"854":1}}],["由于它们头部骨骼的大小不一样",{"1":{"848":1}}],["由于它是68场景等级",{"1":{"270":1}}],["由于骨骼的大小",{"1":{"848":1}}],["由于垂直于法线的向量有无数条",{"1":{"846":1}}],["由于字符串随着",{"1":{"828":1}}],["由于函数调用的开销",{"1":{"823":1}}],["由于函数参数声明方式的不同",{"1":{"819":1}}],["由于unity的内存分配器使用不区分内存分配大小的内存池",{"1":{"820":1}}],["由于object的equals函数要求传入的是一个object作为参数",{"1":{"820":1}}],["由于执行闭包需要实例化一个生成它的类的拷贝",{"1":{"818":1}}],["由于多边形的性质",{"1":{"783":1}}],["由于圆形可近似地看成一个有无数条边的正多边形",{"1":{"764":1}}],["由于需要逐像素检测",{"1":{"759":1}}],["由于只启动一个appdomain",{"1":{"707":1}}],["由于和当初的ngui很像所以被大家广泛使用",{"1":{"667":1}}],["由于",{"1":{"657":1,"756":1,"763":1,"966":1}}],["由于会受到",{"1":{"645":1}}],["由于canvas的世界尺寸与其像素尺寸在数值上相等",{"1":{"640":1}}],["由于fpm是使用unix",{"1":{"576":1}}],["由于没有温度墙会升高温度",{"1":{"551":1}}],["由于没有温度墙等限制",{"1":{"551":1}}],["由于经过",{"1":{"536":1}}],["由于一间厢房只能让一位门徒弟子休息",{"1":{"380":1}}],["由于哈希结果值是从",{"1":{"201":1}}],["由于是采用lerp线性插值计算得出的值",{"1":{"197":1}}],["由于ioptions<>和ioptionsmonitor<>都被注册为单例服务",{"1":{"173":1}}],["由于在调用该程序集中定义的各个方法时",{"1":{"130":1}}],["由于公共语言运行时为每个受支持的",{"1":{"129":1}}],["由于公共语言运行时为其支持的每个计算机基础结构提供一个或多个",{"1":{"127":1}}],["由于存活的对象比较多哈",{"1":{"122":1}}],["由于存活的对象相对比较少",{"1":{"122":1}}],["由于服务器获取所有带有时间戳的输入",{"1":{"79":1}}],["由于真个游戏世界的状态以一个比较低的频率进行更新",{"1":{"74":1}}],["由于状态同步以服务端为准",{"1":{"57":1}}],["由于网络延迟",{"1":{"43":2,"48":1}}],["由于java采取big",{"1":{"34":1}}],["由于寄存器宽度大于一个字节",{"1":{"33":1}}],["由于客户端自己控制怪物的随机走动",{"1":{"18":1}}],["由于手机上很难出现像pc里那样的外挂",{"1":{"17":1}}],["由于大家的turn一致",{"1":{"11":1}}],["大多數的",{"1":{"975":2}}],["大多数情况下",{"1":{"828":1}}],["大多数unity平台将托管堆扩大一倍",{"1":{"813":1}}],["大括号外不可访问",{"1":{"898":1}}],["大画面",{"0":{"890":1}}],["大型文件",{"1":{"867":1}}],["大拇指朝向",{"1":{"840":1}}],["大堆垃圾收集缓慢且不可频繁收集",{"0":{"831":1}}],["大项目的实际存储空间是从堆中分配的",{"1":{"826":1}}],["大致代码如下",{"1":{"695":1}}],["大功告成",{"1":{"425":1}}],["大约武场有3个的时候",{"1":{"375":1}}],["大逃杀",{"0":{"324":1}}],["大批异疆邪教中人群聚于此",{"1":{"297":1}}],["大批气焰嚣张的匪类于此地占路夺桥",{"1":{"297":1}}],["大天狗飞过庭院",{"1":{"296":1}}],["大量心态7",{"1":{"295":1}}],["大量道德2",{"1":{"295":1}}],["大量的key会重定向到其他服务器中",{"1":{"91":1}}],["大牢",{"1":{"287":1}}],["大于",{"1":{"689":1}}],["大于或等于装备所在的",{"1":{"272":1}}],["大于品质",{"1":{"270":1}}],["大秘境",{"1":{"254":1}}],["大成",{"1":{"248":1}}],["大叫",{"1":{"247":1}}],["大房间",{"1":{"220":1}}],["大洲",{"1":{"214":1}}],["大概包含",{"1":{"960":1}}],["大概是这样的",{"1":{"810":1}}],["大概是里斯本到莫斯科的距离",{"1":{"64":1}}],["大概的问题是",{"1":{"537":1}}],["大概率",{"1":{"295":1}}],["大概早就做完游戏了",{"1":{"206":1}}],["大对象直接进入老年代",{"1":{"120":1}}],["大幅削减了mutator的最大暂停时间",{"1":{"115":1}}],["大小为2的幂次方",{"1":{"872":1}}],["大小与顶点坐标对应",{"1":{"846":1}}],["大小写转换以及字符串比较",{"1":{"155":1}}],["大小",{"1":{"92":1,"644":1}}],["大部分游戏都会将碰撞分为两个阶段",{"1":{"766":1}}],["大部分的类库",{"1":{"398":1}}],["大部分的强交互网游会做对时",{"1":{"51":1}}],["大部分是单独提供额外安装",{"1":{"398":1}}],["大部分元素在这步都会被打回",{"1":{"220":1}}],["大部分fps游戏采用非现实的玩家系统",{"1":{"46":1}}],["大端转换",{"0":{"38":1},"2":{"39":1}}],["大端模式所谓的大端模式",{"1":{"32":1}}],["大体实现和玩家移动相似",{"1":{"17":1}}],["大家知道",{"1":{"940":1}}],["大家应该注意到了吧",{"1":{"841":1}}],["大家稍微测试一下就知道了",{"1":{"841":1}}],["大家看下图就知道了",{"1":{"840":1}}],["大家都爱用的eventtrigger具体怎么做我想大家已经明白了",{"1":{"667":1}}],["大家可以关注我的博客",{"1":{"841":1}}],["大家可以在",{"1":{"841":1}}],["大家可以在相机",{"1":{"841":1}}],["大家可以测试一下",{"1":{"841":1}}],["大家可以看下图加深理解",{"1":{"841":1}}],["大家可以仔细考虑一下或者自己写一个demo",{"1":{"107":1}}],["大家可能会注意到这里面明显少了什么",{"1":{"592":1}}],["大家在调试代码时应该都喜欢用callstack吧",{"1":{"131":1}}],["大家一眼就看出来了",{"1":{"107":1}}],["大家参看几篇链接的文章",{"1":{"15":1}}],["大家是要等着的",{"1":{"12":1}}],["第7式除外",{"1":{"383":1}}],["第四系是属性后缀共计7个小组",{"1":{"270":1}}],["第四个通知观察者本身",{"1":{"104":1}}],["第",{"1":{"220":8}}],["第三种被放于内存管理体制中的是类型的引用",{"1":{"883":1}}],["第三参数",{"1":{"726":1}}],["第三个参数",{"1":{"684":1}}],["第三个参数为宽度",{"1":{"645":1}}],["第三步",{"0":{"665":1}}],["第三步是最为麻烦的",{"1":{"208":1}}],["第三系是技能后缀有1个小组",{"1":{"270":1}}],["第三系是技能前缀有1个小组",{"1":{"270":1}}],["第三行显示刚刚传出的数据包",{"1":{"86":1}}],["第2帧图像已经左移了一段距离",{"1":{"854":1}}],["第2",{"1":{"51":1}}],["第二参数",{"1":{"726":1}}],["第二处同",{"1":{"685":1}}],["第二步合并相同",{"1":{"862":1}}],["第二步",{"0":{"664":1}}],["第二个示例",{"1":{"889":1}}],["第二个submesh使用第二个material绘制",{"1":{"847":1}}],["第二个法术场创建具有延迟时间",{"1":{"801":1}}],["第二个参数则是pointeventdata",{"1":{"678":1}}],["第二个参数为距离边界的距离",{"1":{"645":1}}],["第二个就是",{"1":{"612":1}}],["第二个是获取对应的",{"1":{"510":1}}],["第二个玩家根据这些数据包进行改变",{"1":{"17":1}}],["第二天风符消失了",{"1":{"296":1}}],["第二天就枯萎了",{"1":{"296":1}}],["第二天增加buff",{"1":{"290":1}}],["第二系是防御型后缀共计11小组",{"1":{"270":1}}],["第二系是防御型前缀共计11小组",{"1":{"270":1}}],["第二次结算是冰霜",{"1":{"807":1}}],["第二次结算对单位进行伤害",{"1":{"801":1}}],["第二次修改配置文件后ioptionsmonitor<>和ioptionssnapshot<>的值更新了",{"1":{"173":1}}],["第二次按键的请求编号为",{"1":{"69":1}}],["第二行显示在最后进来的数据包",{"1":{"86":1}}],["第二篇文章",{"1":{"72":1}}],["第二种是固定位置施法",{"1":{"776":1}}],["第二种是插值技术",{"1":{"77":1}}],["第二种方式",{"0":{"55":1}}],["第二种情况是两个玩家中的一个射击",{"1":{"48":1}}],["第二",{"1":{"46":1}}],["第一参数",{"1":{"726":1}}],["第一系是进攻型后缀共计16小组",{"1":{"270":1}}],["第一系是进攻型前缀共计14小组",{"1":{"270":1}}],["第一步计算每个ui元素的",{"1":{"862":1}}],["第一步",{"0":{"663":1},"1":{"199":1}}],["第一个返回",{"1":{"970":1}}],["第一个示例中",{"1":{"889":1}}],["第一个参数是发送message的gameobject对象",{"1":{"661":1}}],["第一个",{"1":{"657":1}}],["第一个是打包的时候",{"1":{"612":1}}],["第一个是获取创建好的",{"1":{"510":1}}],["第一个房间",{"1":{"221":1}}],["第一个provider",{"1":{"151":1}}],["第一个玩家会广播当前所有怪物的状态",{"1":{"17":1}}],["第一行显示每秒当前的渲染的帧",{"1":{"86":1}}],["第一种是制定位置施法",{"1":{"776":1}}],["第一种是航位推技术",{"1":{"77":1}}],["第一种方法需要两个",{"1":{"759":1}}],["第一种方式",{"0":{"54":1}}],["第一篇文章",{"1":{"72":1}}],["第一次结算使用火焰",{"1":{"807":1}}],["第一次结算对每个单位进行晕眩",{"1":{"801":1}}],["第一次访问的时候生成实例并加载配置文件中的值",{"1":{"173":1}}],["第一次调用某个方法时",{"1":{"129":1}}],["第一次按键请求编号为",{"1":{"69":1}}],["第一次连接的对时",{"1":{"56":1}}],["第一",{"1":{"46":1,"48":1,"685":1}}],["第一人称角色网络游戏的设计是一项很有挑战性的工作",{"1":{"40":1}}],["因分配器",{"1":{"1022":1}}],["因應效能優化可能還得拆成多個",{"1":{"978":1}}],["因為不會清除",{"1":{"975":1}}],["因引入额外方法调用而增加的开销可能会变得非常显著",{"1":{"858":1}}],["因",{"1":{"524":1}}],["因而当弟子被安排了某项任务",{"1":{"382":1}}],["因此正确的做法是",{"1":{"997":1}}],["因此单元测试的时候",{"1":{"997":1}}],["因此entitymanager手动更新信息是不会被记录的",{"1":{"991":1}}],["因此我定义了组件的",{"1":{"969":1}}],["因此我们考虑层级的时候要注意着点",{"1":{"976":1}}],["因此我们添加",{"1":{"966":1}}],["因此我们要避免添加不必要的数据或修改数据到",{"1":{"929":1}}],["因此我们需要注意",{"1":{"657":1}}],["因此我们需要通过",{"1":{"465":1}}],["因此我们现在也在研究集成微软开源的垃圾回收器",{"1":{"591":1}}],["因此也没有在画面中显示",{"1":{"966":1}}],["因此也是游戏中必须建造的设施之一",{"1":{"380":1}}],["因此确保你的输入拥有",{"1":{"951":1}}],["因此你只需要注意你的",{"1":{"960":1}}],["因此你的默认运行在",{"1":{"949":1}}],["因此你可以使用",{"1":{"946":1}}],["因此如果有被",{"1":{"971":1}}],["因此如果你在叶子对象上禁用了",{"1":{"965":1,"1002":1}}],["因此如果你想要获取到",{"1":{"949":1}}],["因此如果你想要在unity内置的",{"1":{"949":1}}],["因此如果cpu性能不足可能会导致严重的计算滞后",{"1":{"86":1}}],["因此顺序并没有被清晰地定义",{"1":{"949":1}}],["因此更推荐的方法是直接继承ecs库里已提供的",{"1":{"948":1}}],["因此在query里setfilterchanged即可",{"1":{"997":1}}],["因此在这次更新中",{"1":{"991":1}}],["因此在conversion过程中你无法这样使用刚刚声明的",{"1":{"966":1}}],["因此在",{"1":{"965":1}}],["因此在代码中有大量逻辑简单的",{"1":{"944":1}}],["因此在finalization",{"1":{"898":1}}],["因此有一定的计算量",{"1":{"941":1}}],["因此官方也推荐利用好",{"1":{"927":1}}],["因此使用带有单个类型的withany等同于将该类型放在withall语句中",{"1":{"910":1}}],["因此比动态批处理更加高效",{"1":{"876":1}}],["因此无法有效清除由装箱生成的小型",{"1":{"864":1}}],["因此随着堆的扩展",{"1":{"857":1}}],["因此一旦这个帽子戴到别的人物模型身上时",{"1":{"848":1}}],["因此一旦生成了",{"1":{"174":1}}],["因此材质的着色器可在计算游戏对象的表面颜色时使用纹理",{"1":{"844":1}}],["因此其容量是",{"1":{"960":1}}],["因此其不能有效率的清除由装箱带来的小的",{"1":{"820":1}}],["因此其recttransform的position与其在屏幕空间的坐标在数值上也相等",{"1":{"640":1}}],["因此分配到了托管堆",{"1":{"818":1}}],["因此不管流程需要数据的是前端还是后端",{"1":{"810":1}}],["因此装备属性的同步需要通知逻辑服务器",{"1":{"809":1}}],["因此需要知道技能的开始和结束",{"1":{"805":1}}],["因此需要尽量避免在热更dll中调用unity主工程的泛型方法",{"1":{"600":1}}],["因此根节点",{"1":{"795":1}}],["因此前景在正交平面之前",{"1":{"737":1}}],["因此此方式下",{"1":{"726":1}}],["因此代码访问静态变量需要先得到appdomain的引用再进行转换",{"1":{"707":1}}],["因此所有的appdomain只访问一份代码",{"1":{"707":1}}],["因此越嵌套在靠近",{"1":{"695":1}}],["因此计算得到的",{"1":{"695":1}}],["因此都返回基类的",{"1":{"695":1}}],["因此对于每个内存块来说",{"1":{"930":1}}],["因此对于射线检测来说",{"1":{"695":1}}],["因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论",{"1":{"61":1}}],["因此会打断批处理",{"1":{"979":1,"980":1}}],["因此会在",{"1":{"954":1}}],["因此会抛出警告",{"1":{"952":1}}],["因此会执行",{"1":{"657":1}}],["因此会比较慢",{"1":{"111":1}}],["因此建议大家在实际开发中",{"1":{"599":1}}],["因此这时候",{"1":{"971":1}}],["因此这里",{"1":{"449":1}}],["因此这几个区域的内存分配和回收都具有确定性",{"1":{"113":1}}],["因此绝对不能轻视",{"1":{"381":1}}],["因此假如需要练习的门徒弟子很多",{"1":{"380":1}}],["因此假如想同时练习很多徒手武功的弟子",{"1":{"380":1}}],["因此当需要很多弟子加入时",{"1":{"380":1}}],["因此挑选总舵时最好找那些地图够大",{"1":{"380":1}}],["因此每次调用这个函数时都很容易消耗数百字节的空闲堆空间",{"1":{"828":1}}],["因此每次调用clone都要进行一次强制类型转换",{"1":{"111":1}}],["因此每次获取的都是同一个实例",{"1":{"173":1}}],["因此激活体仍然一次执行一个回合",{"1":{"158":1}}],["因此它们会随着项目规模的扩大而产生性能问题",{"1":{"858":1}}],["因此它还覆写了",{"1":{"683":1}}],["因此它的写入性能要比后面两种模式要高",{"1":{"451":1}}],["因此它的值会更新",{"1":{"173":1}}],["因此它在运行时中对性能产生负面影响",{"1":{"130":1}}],["因此它可以在过去的任何时刻重构世界",{"1":{"79":1}}],["因此可以采用复制算法该算法效率比较快",{"1":{"122":1}}],["因此中间语言只在初次克隆的时候才会生成",{"1":{"111":1}}],["因此调用者将无法确定实际情况",{"1":{"111":1}}],["因此即使",{"1":{"96":1}}],["因此玩家看到自己开始行动的响应会有150毫秒延迟",{"1":{"84":1}}],["因此客户端可以通过在控制台设置接受带宽限制",{"1":{"82":1}}],["因此角色的位置又顺移回去了",{"1":{"68":1}}],["因此他被击中也不会感觉奇怪或者错误",{"1":{"48":1}}],["因此外推法得到的结果经常是错误地",{"1":{"46":1}}],["因此",{"1":{"34":1,"46":1,"48":1,"50":2,"84":1,"86":1,"91":2,"94":1,"95":1,"111":2,"129":1,"197":3,"707":1,"722":1,"726":1,"755":1,"756":2,"759":2,"764":1,"815":1,"822":1,"830":1,"841":1,"857":2,"876":1,"878":1,"890":1,"892":1,"896":1,"897":1,"898":1,"929":1,"949":1,"964":1,"976":1}}],["因此就导致了大端存储模式和小端存储模式",{"1":{"33":1}}],["因此采用此种手段",{"1":{"17":1}}],["因为转换子物体的时候",{"1":{"1054":1}}],["因为转换前后的对象都被保留了",{"1":{"954":1}}],["因为让gpu为你分配一个新的texture其实是要耗时间的",{"1":{"1033":1}}],["因为插值和预测的包应该是有区别的",{"1":{"1019":1}}],["因为插值是基于缓冲区的历史快照进行的",{"1":{"83":1}}],["因为跑预测所以这里可能过了好几帧servertick这里不是236predictingtick",{"1":{"1013":1}}],["因为entitymanager的get系列api会直接获取写入权限",{"1":{"997":1}}],["因为eventsystem的源码显示",{"1":{"655":1}}],["因为不用重新创建constant",{"1":{"982":1}}],["因为不正确的更改可能导致负面影响大于实际效益",{"1":{"82":1}}],["因为数据不再每帧被重新创建",{"1":{"982":1}}],["因为multi",{"1":{"980":1}}],["因为transform会在",{"1":{"966":1}}],["因为tc>底材qlvl",{"1":{"275":1}}],["因为已经度过了",{"1":{"966":1}}],["因为已经被下层拦截",{"1":{"681":1}}],["因为localtoworld或translation很多",{"1":{"966":1}}],["因为反正你都得实现某种",{"1":{"964":1}}],["因为确实有另一个属于",{"1":{"957":1}}],["因为实际上你工作在",{"1":{"957":1}}],["因为实质上也是将对clr方法的反射调用重定向到我们自己定义的方法里面来",{"1":{"718":1}}],["因为还没有",{"1":{"951":1}}],["因为还有其它的在使用此assetbundle",{"1":{"701":1}}],["因为更改",{"1":{"930":1}}],["因为上面的第二个要点",{"1":{"929":1}}],["因为内存块只需要存其索引",{"1":{"929":1}}],["因为conversion",{"1":{"947":1}}],["因为collector收集的entity很可能在其他地方被改变",{"1":{"739":1}}],["因为clone",{"1":{"896":1}}],["因为现在shoe是引用类型而不是值类型",{"1":{"896":1}}],["因为现在点击到physics也会让这个函数返回true",{"1":{"665":1}}],["因为值",{"1":{"895":1}}],["因为pvalue",{"1":{"891":1}}],["因为pc端分辨率差异并不大",{"1":{"627":1}}],["因为闭包和匿名方法都会都是引用类型",{"1":{"864":1}}],["因为getstats",{"1":{"898":1}}],["因为gpu可以在这张图中的不同区域进行采样",{"1":{"861":1}}],["因为gbk和utf",{"1":{"39":1}}],["因为会从变动节点递归向上调用getcomponents",{"1":{"860":1}}],["因为对应的mask",{"1":{"860":1}}],["因为对于剧烈运动的游戏",{"1":{"50":1}}],["因为摄像机依然能看到这些对象",{"1":{"860":1}}],["因为屏幕显示的就是相机所看到的内容",{"1":{"841":1}}],["因为屏幕宽度是",{"1":{"841":1}}],["因为存储在变量中的值仅仅是",{"1":{"826":1}}],["因为input",{"1":{"824":1}}],["因为技能需求足够复杂",{"1":{"811":1}}],["因为有静态指针一直指向初始化的对象",{"1":{"898":1}}],["因为有些图片透明",{"1":{"862":1}}],["因为有些物体分布在不同区域",{"1":{"766":1}}],["因为有缓存",{"1":{"858":1}}],["因为有来回两次延迟",{"1":{"57":1}}],["因为其长度是无限的",{"1":{"762":1}}],["因为其他的玩家都是存在于过去的某个时候",{"1":{"76":1}}],["因为射击游戏的发射方向是可以根据准星调整的",{"1":{"750":1}}],["因为默认就是会收集在",{"1":{"742":1}}],["因为系统外对entity的持有不会被自动引用计数",{"1":{"739":1}}],["因为层级不会移动简单的编辑工作流程disadvantages",{"1":{"737":1}}],["因为稍后可以移动和缩放相机并且它会表现的很自然",{"1":{"737":1}}],["因为需要检查每一像素来判定是否碰撞",{"1":{"759":1}}],["因为需要移动所有背景精灵带来的额外性能开销",{"1":{"729":1}}],["因为需要引入3d的内容所以",{"1":{"620":1}}],["因为如果下层已经实现了该回调则上层回调则再也无法被调用到",{"1":{"681":1}}],["因为如何设计直接影响到游戏的体验",{"1":{"49":1}}],["因为当event发生时",{"1":{"657":1}}],["因为我选的screen",{"1":{"625":1}}],["因为我们知道transformconversion完成的确切时间",{"1":{"966":1}}],["因为我们知道每一个顶点的位置信息",{"1":{"846":1}}],["因为我们增加了额外的",{"1":{"962":1}}],["因为我们可以使用jobs或者",{"1":{"941":1}}],["因为我们用它做起点",{"1":{"898":1}}],["因为我们希望保护原始变量的值",{"1":{"891":1}}],["因为我们只使用一张精灵",{"1":{"726":1}}],["因为我们创建的room是一定有左右出口的",{"1":{"224":1}}],["因为我们之前解释过的",{"1":{"79":1}}],["因为是透视相机",{"1":{"620":1}}],["因为dll内部的类型都是iltypeinstance",{"1":{"599":1}}],["因为原来在il中的名字被更短的取代了",{"1":{"592":1}}],["因为从应用程序包生成apk需要额外时间",{"1":{"586":1}}],["因为生成的应用程序包应包含所有支持目标的库",{"1":{"585":1}}],["因为apache也好",{"1":{"580":1}}],["因为多开应用或者持续高使用率",{"1":{"551":1}}],["因为nuget",{"1":{"524":1}}],["因为子进程在进行",{"1":{"455":1}}],["因为阻塞操作会让",{"1":{"451":1}}],["因为",{"1":{"442":1,"449":1,"450":1,"452":1,"929":1,"930":1,"949":1,"951":2,"952":3,"964":1,"971":1}}],["因为scoop是低污染的",{"1":{"434":1}}],["因为str",{"1":{"39":1}}],["因为闪避不是对应法术对应的防御措施",{"1":{"385":1}}],["因为一个内存块共享同一个数组的",{"1":{"929":1}}],["因为一个drawcall就把所有原材料传过去了",{"1":{"861":1}}],["因为一个assetbundle中可能包含有多个资源",{"1":{"701":1}}],["因为一个接口中的多个实现类需要的内存可能不一样",{"1":{"113":1}}],["因为一开始低等盗匪不值得花时间去打",{"1":{"377":1}}],["因为掌门大多是专武的特技",{"1":{"377":1}}],["因为很容易让该日练武成效破千",{"1":{"373":1}}],["因为他也是执行在update中",{"1":{"864":1}}],["因为他会先看组件有没有disallowmultiplecomponent的设置",{"1":{"858":1}}],["因为他们在摄像机的显示是按照z去排的",{"1":{"622":1}}],["因为他们一出来只有长拳1xx多经验",{"1":{"372":1}}],["因为他的行为不会给其他人带来影响",{"1":{"62":1}}],["因为没有自动生成linkedentitygroup",{"1":{"965":1}}],["因为没有办法立即从他们身上得到操作信息",{"1":{"84":1}}],["因为没铁矿或许也没卖武器的民房",{"1":{"374":1}}],["因为没打算让原本的弟子打通关",{"1":{"372":1}}],["因为移动到别的地方的时候各定的基本设定都",{"1":{"372":1}}],["因为要养殖鱼",{"1":{"299":1}}],["因为过着刀口舔血",{"1":{"297":1}}],["因为此时tc>底材qlvl",{"1":{"275":1}}],["因为它已经正确",{"1":{"1013":1}}],["因为它有",{"1":{"952":1}}],["因为它并不觉得你想要复制出同样的结果",{"1":{"951":1}}],["因为它只需要进行一次合并操作",{"1":{"876":1}}],["因为它会先销毁传入的entity",{"1":{"958":1,"1001":1}}],["因为它会复位所有的视差层",{"1":{"737":1}}],["因为它会与财宝等级",{"1":{"271":1}}],["因为它们运行在特定的过程的前后",{"1":{"949":1}}],["因为它们将在重新打开项目时丢失",{"1":{"722":1}}],["因为它们是这种地形的一部分",{"1":{"224":1}}],["因为+2全技能的词缀是90级的",{"1":{"270":1}}],["因为2",{"1":{"224":1}}],["因为处理时间可以忽略",{"1":{"220":1}}],["因为规则是要将元素添加到当前的地牢当中",{"1":{"220":1}}],["因为玩家永远要面对新的挑战",{"1":{"217":1}}],["因为玩家1有延迟",{"1":{"11":1}}],["因为算法不仅能处理整数",{"1":{"199":1}}],["因为访问grain一般是需要跨服务器的",{"1":{"158":1}}],["因为访问github如果超时就会出现404",{"1":{"149":1}}],["因为同步块数组的大小不是固定的",{"1":{"131":1}}],["因为大部分情况下是不用lock的",{"1":{"131":1}}],["因为涉及大量的内存遍历工作",{"1":{"118":1}}],["因为方法结束或线程结束时",{"1":{"113":1}}],["因为视野范围变化",{"1":{"104":1}}],["因为回滚是一个痛苦",{"1":{"89":1}}],["因为光传播如此之快",{"1":{"85":1}}],["因为相对网络包传输的速度",{"1":{"85":1}}],["因为即使客户端是",{"1":{"85":1}}],["因为预测的工作原理是使用客户端的操作来预测的",{"1":{"84":1}}],["因为该预测之后误差将变得太大",{"1":{"83":1}}],["因为每个玩家看到自己的世界是当前的",{"1":{"76":1}}],["因为位置和速度和前面的数据无关",{"1":{"76":1}}],["因为权威服务器的缘故",{"1":{"68":1}}],["因为首先客户端需要把输入传给服务器",{"1":{"66":1}}],["因为包必须被打包",{"1":{"64":1}}],["因为游戏服务器不能信任客户端这种重要决定",{"1":{"85":1}}],["因为游戏状态的复杂性",{"1":{"70":1}}],["因为游戏世界是确定的",{"1":{"67":1}}],["因为游戏世界中发生的一切都在服务器中进行",{"1":{"63":1}}],["因为游戏逻辑执行在本地",{"1":{"15":1}}],["因为这类调用会例行调用convert",{"1":{"962":1}}],["因为这张图可能非常大",{"1":{"861":1}}],["因为这对于美术设计在场景中移动很容易",{"1":{"737":1}}],["因为这样的画",{"1":{"620":1}}],["因为这个系统不关心",{"1":{"904":1}}],["因为这个",{"1":{"510":1}}],["因为这时",{"1":{"449":1}}],["因为这会让玩家流失",{"1":{"62":1}}],["因为这种方法是用延时",{"1":{"46":1}}],["因为最终仍然是以服务器为准的",{"1":{"57":1}}],["因为采用频率限制",{"1":{"46":1}}],["因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后",{"1":{"451":1}}],["因为服务器拥有客户端预测最终决定权",{"1":{"84":1}}],["因为服务器端的滞后补偿知道客户端实体插值并纠正这个误差",{"1":{"83":1}}],["因为服务器是权威的",{"1":{"69":1}}],["因为服务器也会处理这个数据",{"1":{"43":1}}],["因为服务器要等待所有输入达到之后再同步到所有的c端",{"1":{"12":1}}],["因为命令可能会被多次执行",{"1":{"43":1}}],["因为通常延迟比较小",{"1":{"42":1}}],["因为在那种情况下就没有同级对象需要",{"1":{"965":1}}],["因为在复杂一些的游戏里",{"1":{"952":1}}],["因为在同一个",{"1":{"945":1}}],["因为在新生代中绝大多数的对象都是",{"1":{"120":1}}],["因为在时间测量精度的误差客户端和服务器命中包围盒不完全匹配",{"1":{"85":1}}],["因为在没一帧开始你不可能知道这一帧需要多长时间",{"1":{"41":1}}],["因为在严格的帧同步的情况下",{"1":{"12":1}}],["因为全自动",{"1":{"15":1}}],["因为基于反射",{"1":{"15":1}}],["因为b看自己",{"1":{"15":1}}],["因为客户端可能",{"1":{"45":1}}],["因为客户端收到的修正信息是过去某个时间的",{"1":{"43":1}}],["因为客户端不等待服务器确认",{"1":{"15":1}}],["因为客户端对当前操作的立刻执行",{"1":{"15":1}}],["因为严格的帧同步",{"1":{"12":1}}],["因为那时都是解决方案都是采用局域网的方式",{"1":{"12":1}}],["因为你本想要在scene",{"1":{"971":1}}],["因为你并不是要跳过转换",{"1":{"968":1}}],["因为你无法将converttoentity放置到",{"1":{"964":1}}],["因为你在这里使用",{"1":{"957":1}}],["因为你要确保你的",{"1":{"949":1}}],["因为你可以射击",{"1":{"79":1}}],["因为你发的微小的位移数据",{"1":{"76":1}}],["因为你重新进来之后",{"1":{"12":1}}],["因为你的图层是智能图层",{"1":{"1":1}}],["吸怪等外挂手段",{"1":{"17":1}}],["实在懒得写排序",{"1":{"862":1}}],["实例",{"1":{"966":1}}],["实例代码",{"0":{"925":1}}],["实例代码如下",{"1":{"920":1}}],["实例化player",{"1":{"1013":1}}],["实例化流程",{"0":{"1012":1}}],["实例化的",{"1":{"969":1}}],["实例化时的",{"1":{"965":1}}],["实例化过程没有prefab",{"1":{"965":1}}],["实例化过程就无需递归调用了",{"1":{"965":1}}],["实例化就无关紧要",{"1":{"965":1}}],["实例化job",{"1":{"921":1}}],["实例化他们",{"1":{"917":1}}],["实例化",{"1":{"859":1}}],["实例jaroslav准备并给出了你们可以尝试并学习的unity工程",{"1":{"737":1}}],["实例更新通知",{"1":{"174":1}}],["实施代码又回到了",{"1":{"695":1}}],["实验组与对照组各生成100次地图",{"1":{"215":1}}],["实验组是我们的算法生成的地图",{"1":{"215":1}}],["实时渲染",{"1":{"505":1}}],["实时",{"1":{"127":1,"128":1}}],["实体不能具有任何这些组件类型",{"1":{"910":1}}],["实体查询首先需要一些组件类型",{"1":{"915":1}}],["实体查询",{"0":{"915":1},"1":{"910":1}}],["实体非常非常的简单",{"1":{"906":1}}],["实体b的原型就会变成n",{"1":{"905":1}}],["实体c的原型是n",{"1":{"905":1}}],["实体a和b的原型都是m",{"1":{"905":1}}],["实体a和b还有renderer组件",{"1":{"904":1}}],["实体存在哪里和哪些实体在其周围",{"1":{"767":1}}],["实体内会插导致100毫秒默认",{"1":{"83":1}}],["实体",{"0":{"906":1},"1":{"83":1,"928":1,"936":1},"2":{"907":1,"908":1,"909":1,"910":1,"911":1,"912":1}}],["实体插值",{"0":{"76":1}}],["实际测试",{"0":{"1035":1},"2":{"1036":1,"1037":1,"1038":1,"1039":1,"1040":1,"1041":1}}],["实际情况是",{"1":{"828":1}}],["实际ugui就是这么做的",{"1":{"625":1}}],["实际的重写工作是针对数据库的当前值来进行的",{"1":{"457":1}}],["实际命中率",{"1":{"385":1}}],["实际上你可以实例化任何",{"1":{"965":1}}],["实际上提交了所有子",{"1":{"952":1}}],["实际上只需要勾选batching",{"1":{"876":1}}],["实际上只需要一个样本就可以完成所有的工作了",{"1":{"206":1}}],["实际上正是这些",{"1":{"858":1}}],["实际上并不准确",{"1":{"449":1}}],["实际上并不是",{"1":{"197":1}}],["实际上还不在树里",{"1":{"210":1}}],["实际上还有double啊",{"1":{"131":1}}],["实际上我们可以建立更复杂的相邻布局约束",{"1":{"207":1}}],["实际上数据保存到redis1中",{"1":{"96":1}}],["实际上",{"1":{"75":1,"454":1,"577":1,"592":1,"937":1}}],["实际上是合并",{"1":{"941":1}}],["实际上是进行了克隆",{"1":{"898":1}}],["实际上是所有魔法装备的衍生基础",{"1":{"273":1}}],["实际上是一个np",{"1":{"207":1}}],["实际上是一种贴图以及模型合成技术",{"1":{"206":1}}],["实际上是同时省去了游戏服务器的怪物ai模块",{"1":{"20":1}}],["实际上是由地图中玩家所决定的",{"1":{"17":1}}],["实际应用总应该总是采用完全预测",{"1":{"50":1}}],["实际应用中",{"1":{"50":1}}],["实际网络延迟",{"1":{"50":1}}],["实现了ideclarereferencedprefabs组件接口的gameobject会被扫描",{"1":{"964":1}}],["实现了",{"1":{"920":1}}],["实现idisposable接口的对象可以使用using关键字",{"1":{"898":1}}],["实现技能的基本思路就是通过策划填写表格",{"1":{"791":1}}],["实现方法有多种",{"1":{"759":1}}],["实现方法",{"1":{"758":1}}],["实现方式",{"0":{"109":1}}],["实现方式是",{"1":{"108":1}}],["实现起来会比较麻烦",{"1":{"733":1}}],["实现视差效果",{"0":{"734":1},"1":{"724":1}}],["实现单层背景的滚动",{"0":{"725":1},"1":{"724":1},"2":{"726":1,"727":1,"728":1,"729":1,"730":1,"731":1,"732":1,"733":1,"734":1,"735":1,"736":1,"737":1}}],["实现类的时候才可以",{"1":{"661":1}}],["实现反向代理",{"1":{"581":1}}],["实现应用服务器接口的请求插件支持多种语言和平台",{"1":{"580":1}}],["实现的是windows和android平台下",{"1":{"708":1}}],["实现的应用",{"1":{"573":1}}],["实现的关键就在于",{"1":{"176":1}}],["实现任何设备通过浏览器即可访问vscode",{"1":{"545":1}}],["实现是",{"1":{"164":1}}],["实现",{"0":{"166":1},"1":{"127":1,"170":1,"920":1,"957":1}}],["实现简单",{"1":{"120":1}}],["实现策略",{"1":{"17":1}}],["实现接口",{"1":{"15":1}}],["怪物在地图中的等级",{"0":{"293":1}}],["怪物在地图种的类型",{"0":{"292":1}}],["怪物才能掉落该物品的暗金",{"1":{"275":1}}],["怪物会掉落特定的物品么",{"1":{"274":1}}],["怪物死亡后掉落的物品就是从其tc目录的物品清单中按照一定规则随机取出物品",{"1":{"267":1}}],["怪物等级越高",{"1":{"293":1}}],["怪物等级",{"0":{"265":1},"1":{"275":1},"2":{"266":1,"267":1,"268":1,"269":1,"270":1,"271":1,"272":1,"273":1,"274":1,"275":1}}],["怪物",{"0":{"259":1}}],["怪物掉落或者采集物品的时候偶尔采集到",{"1":{"254":1}}],["怪物ai的这个处理方式",{"1":{"20":1}}],["怪物可以每进行一次攻击",{"1":{"19":1}}],["怪物位置不一样的问题",{"1":{"18":1}}],["怪物没有进入战斗状态时",{"1":{"18":1}}],["怪物都会有一个固定的位置",{"1":{"18":1}}],["怪物的技能发起是由ai也就是服务端",{"1":{"802":1}}],["怪物的tc值代表了怪物能掉落的物品底材的最高qlvl",{"1":{"275":1}}],["怪物的种类与掉落的物品没有关系",{"1":{"274":1}}],["怪物的",{"1":{"272":1}}],["怪物的分类",{"0":{"266":1}}],["怪物的等级由场景等级决定",{"1":{"265":1}}],["怪物的等级由怪物的种类决定",{"1":{"265":1}}],["怪物的同步方式的选择",{"1":{"20":1}}],["怪物的同步在传统的端游里",{"1":{"17":1}}],["怪物的ai锁定",{"1":{"19":1}}],["怪物的ai就被这个角色所在的客户端锁定了",{"1":{"19":1}}],["怪物的行为同步",{"0":{"19":1}}],["怪物的随机移动不同步",{"0":{"18":1}}],["怪物的位置由第一个进入该地图的玩家决定",{"1":{"17":1}}],["怪物的位置计算是属于离线计算",{"1":{"17":1}}],["怪物的位置信息同步方式一般有两种实现方式",{"1":{"16":1}}],["怪物状态同步",{"0":{"16":1},"2":{"17":1,"18":1,"19":1,"20":1}}],["dstmanager来完成实例化",{"1":{"966":1}}],["dstmanager",{"1":{"961":1}}],["dsp都为小端模式",{"1":{"33":1}}],["django实现了python",{"1":{"578":1}}],["django或flask就是web框架",{"1":{"577":1}}],["django",{"1":{"577":1,"578":1,"581":6}}],["drawcallbatching",{"1":{"984":1}}],["drawcall即cpu命令gpu去绘制",{"1":{"876":1}}],["drawcall为什么会影响游戏运行效率",{"1":{"876":1}}],["drawcall",{"0":{"876":1}}],["drawcall就可以减少一个",{"1":{"862":1}}],["drawcalls",{"1":{"849":1}}],["draw",{"1":{"860":1,"940":3,"942":1,"984":1}}],["drawline",{"1":{"751":1}}],["dragonflylee",{"1":{"533":1}}],["dreams中制作视差效果不同的制作方法",{"1":{"737":1}}],["dreams开发初期",{"1":{"737":1}}],["driven",{"1":{"594":1}}],["dropdown",{"1":{"571":1}}],["drop",{"1":{"225":1}}],["drops",{"1":{"191":1}}],["dns服务器",{"1":{"529":1}}],["dns",{"1":{"490":1}}],["dl",{"1":{"437":2}}],["dll等中的c",{"1":{"593":1}}],["dll也不见了踪影",{"1":{"592":1}}],["dll到哪去了",{"1":{"592":1}}],["dll程序集",{"1":{"131":1}}],["dll程序集的system命名空间下",{"1":{"131":1}}],["dll的热更新步骤",{"1":{"708":1}}],["dll的扩展方法",{"1":{"173":1}}],["dll的",{"1":{"131":3}}],["dll文件本质上和exe一样",{"1":{"131":1}}],["dll",{"1":{"125":1,"592":2,"593":1,"604":2,"722":2}}],["d",{"0":{"637":1},"1":{"384":1,"399":2,"400":1,"401":1,"633":1,"756":6,"800":1,"903":5,"952":1}}],["db游戏网",{"1":{"385":1}}],["db=ef",{"1":{"147":1}}],["dbmigrator初始化数据",{"1":{"133":1}}],["dmcs",{"1":{"126":1}}],["dynamic",{"0":{"937":1},"1":{"937":1,"940":2,"958":1,"980":4,"984":1,"1001":1},"2":{"938":1}}],["dynamically",{"1":{"471":1}}],["dynamicmethod",{"1":{"111":1}}],["dy",{"1":{"103":1}}],["dx",{"1":{"103":1}}],["d被定为到server",{"1":{"92":1}}],["d四个数据对象",{"1":{"92":1}}],["dude类是一个复杂类型",{"1":{"895":1}}],["dude类包含一个name元素和两个shoe元素",{"1":{"895":1}}],["duplicate",{"0":{"485":1},"1":{"485":1}}],["durationpolicy和durationmodifier和durationmultiplier构成了该特效的持续时间",{"1":{"233":1}}],["during",{"1":{"90":1}}],["dungeon",{"1":{"218":1}}],["due",{"1":{"27":1,"193":1}}],["dto",{"1":{"26":1,"27":1}}],["domain",{"0":{"1045":1},"1":{"1052":1}}],["domains",{"1":{"719":1}}],["double",{"1":{"881":1}}],["door",{"0":{"229":1}}],["does",{"1":{"191":1,"192":1,"486":1,"571":1}}],["dots在内部为转换过程创建了一个world",{"1":{"1054":1}}],["dots",{"0":{"941":1},"1":{"940":1}}],["dots技术详解",{"1":{"919":1}}],["dots从原理到应用",{"1":{"919":1}}],["dotfx",{"0":{"512":1}}],["dothass",{"1":{"132":1}}],["dotnet",{"1":{"90":1,"131":2,"162":1,"181":1,"512":1,"719":1}}],["dosomething",{"1":{"824":2}}],["dos",{"1":{"131":2}}],["docfx",{"1":{"512":2}}],["document",{"1":{"532":1}}],["documentspublic",{"1":{"410":1}}],["documentspicturesmusicvideossearches",{"1":{"410":1}}],["documentation",{"1":{"26":1,"162":1,"941":1}}],["docid=0m2y2bvm",{"1":{"211":1}}],["doc",{"0":{"147":1,"148":1},"1":{"131":1,"706":1}}],["docs",{"1":{"126":1,"131":2,"132":1,"140":1,"147":2,"181":1,"499":2,"515":1,"525":2,"543":1,"544":1,"606":4,"701":1,"719":1,"723":2,"825":1,"839":1,"850":2,"941":1,"942":1,"984":1}}],["docker",{"1":{"88":1}}],["do",{"1":{"28":1,"90":1,"188":2,"190":1,"191":1,"192":1,"193":1}}],["downloads",{"1":{"567":1}}],["download",{"1":{"437":1,"527":1}}],["downtime部署的方式",{"1":{"88":1}}],["down",{"1":{"27":2,"191":2}}],["doing",{"1":{"25":1,"191":1}}],["don",{"1":{"22":1,"27":1,"737":1,"975":1}}],["didchange自动使用a系统上次的gsv记录",{"1":{"992":1}}],["dictionary<myenum",{"1":{"822":1}}],["dictionary",{"1":{"822":2}}],["dialog",{"1":{"585":1}}],["directx",{"1":{"726":1}}],["directive",{"1":{"720":21}}],["directory",{"1":{"439":1}}],["directly",{"1":{"25":1,"27":1,"187":1,"188":1}}],["diff",{"1":{"971":1}}],["diffusion比较简单",{"1":{"569":1}}],["diffusion",{"0":{"569":1},"1":{"564":1,"571":1}}],["difference",{"1":{"486":1}}],["different",{"1":{"26":1,"90":1,"188":1,"195":1,"196":1,"485":1}}],["difficult",{"1":{"193":1}}],["discovery",{"1":{"966":2}}],["discovering",{"1":{"964":2}}],["discuss",{"1":{"27":1}}],["display",{"1":{"688":3}}],["dispose方法的定位",{"1":{"823":1}}],["dispose",{"1":{"28":1,"823":1,"1022":2,"1023":1}}],["distance来计算距离",{"1":{"749":1}}],["distancetoclipplane",{"1":{"684":1}}],["distance",{"0":{"694":1},"1":{"662":1,"684":3,"685":1,"689":1,"694":4,"695":7,"771":1}}],["distances",{"1":{"644":1}}],["distance有关",{"1":{"622":1}}],["distinction",{"1":{"187":1}}],["distinct",{"1":{"90":1}}],["disabled组件",{"1":{"965":1}}],["disabled",{"0":{"953":1},"1":{"953":1,"958":1,"964":1,"965":1,"971":1,"1001":1}}],["disableautocreation",{"0":{"914":1}}],["disable",{"1":{"571":2,"965":1,"1002":1}}],["disableroomtemplatescolliders",{"1":{"228":1}}],["disableroomtemplatesrenderers",{"1":{"228":1}}],["di",{"1":{"25":1,"26":2,"27":2}}],["dafault",{"1":{"1037":1}}],["dataproviders需要更改下",{"1":{"746":1}}],["data",{"1":{"186":4,"187":4,"188":2,"189":2,"193":1,"195":2,"196":1,"590":1,"591":1,"942":2,"943":1,"945":1,"946":1,"965":1,"967":2}}],["database",{"1":{"90":1}}],["dashboard授权控制",{"1":{"30":1}}],["days",{"1":{"22":1}}],["day",{"1":{"22":1}}],["daemon",{"0":{"3":1},"1":{"3":1},"2":{"4":1,"5":1,"6":1,"7":1,"8":1}}],["decisioncontroller提供实体",{"1":{"1043":1}}],["decisioncontroller运行计划",{"1":{"1043":1}}],["decimal",{"1":{"881":1}}],["declaredependency",{"1":{"965":1,"971":1}}],["declare",{"1":{"949":1}}],["decorated",{"1":{"24":1}}],["deepprofiling在安卓和桌面上使用",{"1":{"815":1}}],["deep",{"1":{"815":1,"878":1}}],["deactivate",{"1":{"741":1}}],["dead",{"1":{"15":1,"75":1,"225":1}}],["demers",{"1":{"591":1}}],["demo和源代码请到原文中查看和下载",{"1":{"782":1}}],["demo",{"1":{"81":1,"287":1,"510":1,"726":1,"736":3}}],["devices",{"1":{"571":1}}],["development",{"1":{"225":1,"592":1}}],["developer的实例化虽然是用people定义的",{"1":{"131":1}}],["developer",{"1":{"50":1,"87":1}}],["developers",{"1":{"22":1}}],["derived",{"0":{"484":1},"1":{"484":2}}],["deriving",{"1":{"27":1}}],["derek",{"1":{"225":1}}],["debbuger",{"1":{"959":1,"1002":1}}],["debugger来观察绘制顺序",{"1":{"1035":1}}],["debugger",{"1":{"838":1,"929":1,"943":1,"952":1,"966":1,"968":1,"1040":1}}],["debugging",{"1":{"192":1}}],["debroglie",{"1":{"211":1}}],["detection",{"1":{"764":3,"770":4,"1021":1}}],["determines",{"1":{"488":1}}],["determine",{"1":{"193":1}}],["deth",{"1":{"690":1}}],["details",{"1":{"850":2,"984":1}}],["detail",{"1":{"15":1,"984":2}}],["de",{"1":{"155":2,"587":1}}],["deprecated",{"1":{"720":1}}],["depthonlyculling",{"1":{"737":1}}],["depth",{"0":{"974":1,"1041":1},"1":{"692":1,"695":10,"737":1,"974":1,"975":4,"976":1,"977":1,"978":1}}],["deployments",{"1":{"90":1}}],["deployment",{"0":{"88":1},"1":{"90":2}}],["dependencies",{"1":{"27":1,"28":1}}],["dependency",{"1":{"24":1,"25":1,"28":1}}],["destination",{"0":{"947":1},"1":{"947":4,"948":1,"950":2,"957":2,"961":1,"963":1,"964":3,"970":2}}],["destroy模式转换的飞船能关联起来呢",{"1":{"968":1}}],["destroying",{"1":{"953":1}}],["destroy",{"0":{"968":1},"1":{"25":1,"947":1,"951":1,"952":1,"954":2,"956":2,"958":1,"966":1,"968":5,"970":1,"971":2,"1001":1}}],["desireddivisor变量必须通过某种方式传进闭包中",{"1":{"818":1}}],["desireddivisor",{"1":{"818":2}}],["designing",{"1":{"998":1}}],["design",{"1":{"27":1,"50":1,"81":1,"594":1}}],["deserialization",{"1":{"486":1,"487":1}}],["deserialised",{"1":{"189":1}}],["deserialises",{"1":{"189":1}}],["deserialising",{"1":{"188":1,"191":1}}],["desktoppublic",{"1":{"410":1}}],["desktop",{"0":{"408":1},"2":{"409":1,"410":1}}],["despite",{"1":{"195":1}}],["described",{"1":{"28":1}}],["defind宏变量",{"0":{"720":1},"2":{"721":1,"722":1,"723":1}}],["defining",{"1":{"489":1}}],["definitelytyped",{"1":{"398":1}}],["defined",{"1":{"399":1,"489":1,"720":2}}],["define",{"1":{"26":1,"720":21}}],["defaultgameobjectinjectionworld",{"1":{"970":1}}],["defaultcookiename",{"1":{"153":1}}],["default",{"1":{"25":1,"39":2,"193":1,"845":1,"975":2,"976":1,"1039":1}}],["delegateadapter",{"1":{"718":1}}],["delegate",{"1":{"25":1,"882":1}}],["rpcsetnetworkid服务端在同步networkid的时候会一起同步clientservertickrate客户端会比服务端多一个networktimesystem根据往返时间和最近从服务器收到的快照来计算服务器时间的初始估计来看下插值tick的计算",{"1":{"1017":1}}],["rpg游戏之类的",{"1":{"750":1}}],["r树",{"1":{"767":1}}],["rsp",{"1":{"722":2}}],["rsa",{"1":{"459":1}}],["rigidbody有个特点",{"1":{"655":1}}],["right",{"1":{"186":1,"633":2,"635":2,"637":1,"641":1}}],["rhel",{"0":{"548":1}}],["rdb文件中",{"1":{"442":1}}],["rdb这种持久化方式不太适应对数据完整性要求严格的情况",{"1":{"442":1}}],["rdb是一个非常紧凑",{"1":{"441":1}}],["rdb可以最大化redis性能",{"1":{"441":1}}],["rdb方式要比aof方式恢复速度要快",{"1":{"441":1}}],["rdb优点与缺点",{"0":{"440":1},"2":{"441":1,"442":1,"443":1,"444":1,"445":1,"446":1,"447":1,"448":1,"449":1,"450":1,"451":1,"452":1,"453":1,"454":1,"455":1,"456":1,"457":1}}],["rasterization",{"1":{"974":1}}],["ray",{"0":{"760":1},"1":{"684":1,"750":3}}],["raycastnonalloc",{"1":{"858":1}}],["raycastall",{"1":{"858":1}}],["raycasttarget",{"1":{"690":1}}],["raycast3dall",{"1":{"689":1}}],["raycasts",{"1":{"687":2}}],["raycasts的勾选",{"1":{"657":1}}],["raycastresult",{"1":{"684":2,"685":1,"695":4}}],["raycasthit",{"1":{"684":3,"685":1,"695":1}}],["raycast",{"0":{"688":1,"690":1,"691":1,"692":1},"1":{"656":2,"657":1,"690":1,"691":2,"750":2},"2":{"689":1,"690":1,"691":1,"692":1,"693":1,"694":1,"695":1}}],["raycastermanager",{"1":{"683":2}}],["raycaster以外还有各种各样的raycaster",{"1":{"675":1}}],["raycaster是用来做什么的了吧",{"1":{"675":1}}],["raycaster所在的相机层级",{"1":{"663":1}}],["raycaster挂载在哪个相机上面",{"1":{"663":1}}],["raycaster",{"0":{"676":1,"684":1,"685":1,"686":1},"1":{"656":4,"663":1,"675":1,"683":1,"684":2,"686":1,"695":10,"860":1},"2":{"687":1,"688":1,"689":1,"690":1,"691":1,"692":1,"693":1,"694":1,"695":1}}],["raycasters",{"0":{"656":1},"1":{"656":4,"662":2,"683":1},"2":{"657":1,"658":1}}],["raycaster的相机",{"1":{"655":1}}],["rawimage见上图",{"1":{"1032":1}}],["raw",{"0":{"647":1,"650":1}}],["rack",{"1":{"580":1}}],["ram",{"1":{"564":1}}],["range",{"1":{"714":2}}],["random",{"1":{"266":1}}],["ran",{"1":{"189":1}}],["ratio",{"1":{"86":1}}],["ratiocvar的",{"1":{"83":1}}],["rate",{"1":{"86":1}}],["rva",{"1":{"131":1}}],["r",{"1":{"107":1,"195":2,"756":7,"767":1}}],["rule",{"0":{"1028":1}}],["rules",{"1":{"26":1}}],["runtime",{"0":{"1046":1},"1":{"131":1},"2":{"1047":1,"1048":1,"1049":1,"1050":1}}],["runs",{"1":{"22":1,"28":1}}],["run",{"1":{"22":6,"24":1,"26":1,"27":1,"29":1,"131":1,"489":1,"585":1}}],["running",{"1":{"22":4,"27":2,"194":1,"720":1}}],["roslyn",{"0":{"1046":1},"2":{"1047":1,"1048":1,"1049":1,"1050":1}}],["rotated",{"1":{"770":1}}],["rotation",{"1":{"649":1,"693":1}}],["roaming",{"1":{"498":1}}],["roderickqiu",{"1":{"437":1}}],["room来取代向下的房间",{"1":{"224":1}}],["room类型我们会选1或者2",{"1":{"224":1}}],["room",{"1":{"224":1,"225":1}}],["rootcanvas",{"1":{"687":1}}],["root的对象有以下几种",{"1":{"116":1}}],["root的对象有如下几种",{"1":{"116":1}}],["root引用",{"1":{"116":1}}],["root",{"0":{"462":1},"1":{"116":1,"225":1,"805":2,"898":2,"970":1,"999":1},"2":{"463":1,"464":1}}],["roots没有任何引用链相连时",{"1":{"116":1}}],["roots",{"1":{"116":1,"124":1}}],["roguelike",{"0":{"325":1},"1":{"217":4}}],["rollup",{"1":{"536":1}}],["rolling",{"0":{"89":1}}],["rollback",{"1":{"13":1}}],["robust",{"1":{"22":1,"195":1}}],["regression",{"1":{"984":1}}],["registered",{"1":{"28":1}}],["register",{"1":{"27":2}}],["reversed",{"0":{"693":1}}],["review",{"1":{"186":1}}],["rendertexture的分配和销毁上有一个地方需要注意",{"1":{"1033":1}}],["rendertexture绑定到rawimage",{"1":{"1032":1}}],["renderqueue",{"1":{"976":6,"1036":11,"1039":5,"1040":3}}],["renderring",{"1":{"946":1}}],["rendermesh和localtoworld组件",{"1":{"966":1}}],["rendermesh",{"1":{"929":1,"949":1}}],["rendermode",{"1":{"689":1,"695":3}}],["renderer负责渲染",{"1":{"971":1}}],["renderer所用",{"1":{"954":1}}],["renderer",{"0":{"843":1,"942":1,"975":1},"1":{"905":1,"942":2,"943":4,"946":1,"951":1,"954":1,"969":1,"971":1,"975":2,"978":1},"2":{"976":1,"977":1,"978":1}}],["rendering当然",{"1":{"759":1}}],["rendering",{"0":{"975":1,"977":1},"1":{"759":1,"941":1,"942":1,"974":5,"975":4,"977":4,"978":4,"980":1},"2":{"976":1,"977":1,"978":1}}],["renderorder",{"1":{"687":1}}],["renderorderpriority",{"1":{"683":1,"695":3}}],["render",{"0":{"1036":1},"1":{"687":2,"694":1,"849":1,"975":5,"977":6,"978":1}}],["removecomponent",{"1":{"966":1}}],["remove等等",{"1":{"822":1}}],["remove等动作",{"1":{"745":1}}],["remap",{"1":{"965":3}}],["remapping不会发生",{"1":{"965":1}}],["remapping",{"1":{"965":4}}],["remain",{"1":{"90":1}}],["remember",{"0":{"487":1}}],["rewrite",{"1":{"453":1}}],["refreshtile后会触发",{"1":{"1031":1}}],["reference",{"0":{"998":1},"1":{"707":1}}],["referenced",{"1":{"185":1}}],["refers",{"1":{"193":1}}],["reflection",{"0":{"597":1}}],["reflect",{"1":{"192":1}}],["reuse",{"1":{"191":1,"195":1}}],["replication",{"1":{"444":1}}],["repeatuntilsuccess",{"1":{"284":1}}],["repeat",{"1":{"199":1,"201":1,"726":2}}],["repeats",{"1":{"189":1}}],["represent",{"1":{"187":1,"571":1}}],["repository",{"1":{"542":1}}],["report",{"1":{"410":1}}],["repo",{"1":{"166":1,"509":1,"543":1}}],["resharper这个visual",{"1":{"815":1}}],["restart这个会停止低优先级",{"1":{"283":1}}],["restart和stops",{"1":{"283":1}}],["restart",{"1":{"283":6}}],["response",{"1":{"764":1}}],["responsible",{"1":{"22":1,"489":1}}],["respectively",{"1":{"191":2,"194":1}}],["resulting",{"1":{"193":1,"947":1}}],["result",{"1":{"189":1,"192":1,"196":1,"864":1,"974":1}}],["results",{"1":{"189":3,"195":2,"662":1}}],["resourcelocators",{"1":{"900":1}}],["resource",{"1":{"601":1}}],["resources文件夹",{"0":{"873":1}}],["resources",{"1":{"162":1,"701":1,"705":1}}],["resourcemanager",{"1":{"155":2}}],["resx",{"1":{"155":1}}],["redirects",{"1":{"471":1}}],["redirectedfrom=msdn",{"1":{"131":1}}],["redis",{"0":{"433":1},"1":{"443":2,"444":5,"445":2,"447":1,"448":2,"449":2,"450":1,"451":3,"452":5,"453":3,"455":4,"457":3}}],["redisservice2",{"1":{"96":3}}],["redisservice1",{"1":{"96":3}}],["redis4的hash范围比redis3的hash范围大",{"1":{"96":1}}],["reloads",{"1":{"1052":1}}],["reload",{"1":{"571":1}}],["release",{"1":{"510":7,"567":1}}],["releases",{"1":{"415":1,"437":1}}],["relevant",{"1":{"186":1}}],["related",{"1":{"189":1}}],["relative",{"1":{"131":1,"191":1,"195":1,"644":1}}],["reliable",{"1":{"22":1,"187":1}}],["reconverted",{"1":{"971":1}}],["reconciliation",{"1":{"71":1}}],["rectangle",{"1":{"644":1,"770":1}}],["rect属性同样是一个计算出来的值",{"1":{"642":1}}],["rect属性",{"1":{"642":1}}],["rect",{"0":{"642":1},"1":{"642":1,"860":2}}],["recttransform入門",{"1":{"651":1}}],["recttransform的一些其他操做",{"0":{"646":1},"2":{"647":1,"648":1,"649":1,"650":1,"651":1}}],["recttransform的渲染与摄像机有关",{"1":{"640":1}}],["recttransform左下角",{"1":{"641":1}}],["recttransform右上角",{"1":{"641":1,"645":1}}],["recttransform",{"0":{"632":1,"633":1},"1":{"633":3,"644":4},"2":{"634":1,"635":1,"636":1,"637":1}}],["reckoning",{"1":{"15":1,"75":1}}],["ret",{"1":{"823":1}}],["retrieve",{"1":{"28":1}}],["returnvalue方法不会存在栈上",{"1":{"890":1}}],["returned",{"1":{"190":1}}],["returns",{"1":{"25":1}}],["return",{"1":{"25":2,"50":1,"189":1,"822":2}}],["requirements",{"1":{"195":1,"196":1,"1044":1}}],["require",{"1":{"192":1}}],["requires",{"1":{"188":2,"193":1}}],["required",{"1":{"25":3}}],["requestcultureprovider",{"1":{"151":1}}],["requestlocalizationoptions",{"1":{"151":1}}],["requested",{"1":{"25":1}}],["re",{"1":{"24":2,"25":2}}],["reactive",{"1":{"998":2}}],["reactivesystem",{"0":{"742":1}}],["reasonably",{"1":{"196":1}}],["reason",{"1":{"186":1,"191":1}}],["reasons",{"1":{"22":1,"187":1}}],["readcliheader",{"0":{"713":1}}],["readsections读取分块数据封装一个section",{"1":{"712":1}}],["readoptionalheaders主要读取pe的相关信息",{"1":{"712":1}}],["readimagefrom的操作",{"1":{"711":1}}],["reading",{"1":{"195":1}}],["readme",{"1":{"503":2}}],["reader",{"1":{"195":2}}],["ready",{"1":{"185":1}}],["read",{"1":{"103":1,"188":1,"189":1,"190":2}}],["real",{"1":{"15":1,"189":1}}],["pvalue改变了x的值使其指向vegetable的内在地址",{"1":{"893":1}}],["pvp3人及以上的战斗中",{"1":{"15":1}}],["pvp",{"1":{"15":1}}],["p0",{"1":{"846":2}}],["png创建拍摄用的摄像机",{"1":{"1032":1}}],["png1",{"1":{"803":1}}],["png三段击本身是一个顺序节点",{"1":{"795":1}}],["p2",{"1":{"762":1}}],["p1和p3",{"1":{"846":1}}],["p1",{"1":{"762":1}}],["ppc",{"1":{"720":1}}],["pdb后",{"1":{"711":1}}],["phase",{"0":{"767":1,"768":1},"1":{"767":1}}],["physicsraycaster",{"1":{"684":1,"685":5,"687":1,"689":2,"695":3}}],["physics2d",{"0":{"685":1},"1":{"685":1,"858":1}}],["physics2draycaster",{"1":{"654":1,"685":2,"687":1,"689":1,"695":5}}],["physics2d中设置",{"1":{"652":1}}],["physics事件之后",{"1":{"652":1}}],["physics",{"0":{"684":1},"1":{"652":2,"653":1,"656":2,"663":3,"684":2,"751":1,"868":1}}],["physical",{"0":{"629":1}}],["php",{"0":{"576":1},"1":{"111":1,"573":3,"574":1,"576":10,"737":1}}],["p5版本中首次引入il2cpp以来",{"1":{"594":1}}],["py或者bottle或者django等等的python",{"1":{"578":1}}],["py",{"1":{"569":1}}],["python",{"0":{"567":1},"1":{"223":2,"465":2,"567":4,"573":2,"577":1,"581":1}}],["pbo中的温度墙以及负压",{"1":{"551":1}}],["ps4",{"1":{"720":1}}],["ps",{"1":{"499":1,"616":1}}],["psdrive",{"1":{"424":1}}],["psd",{"1":{"287":3}}],["please",{"1":{"489":1}}],["playables",{"1":{"851":2}}],["playstation",{"1":{"720":1}}],["play后台上的包的签名不一致",{"1":{"612":1}}],["play后台的版本要高",{"1":{"612":1}}],["play后台的隐私设置区域",{"1":{"607":1}}],["play应用需要授予",{"1":{"608":1}}],["play团队的审核",{"1":{"607":1}}],["playbackengines",{"1":{"591":1}}],["play",{"1":{"585":2,"607":2,"610":1,"611":1,"951":1,"969":1,"971":5}}],["playersettings",{"1":{"721":1,"868":3}}],["player",{"0":{"1011":1},"1":{"43":1,"213":1,"214":1,"585":1,"592":1,"721":1}}],["plane",{"1":{"975":1}}],["planes",{"1":{"737":1}}],["planesnear",{"1":{"737":2}}],["plan",{"1":{"571":1}}],["platformdependentcompilation",{"1":{"723":1}}],["platform",{"1":{"225":1,"606":1,"720":8,"723":1}}],["platformer",{"1":{"225":1}}],["placeholder",{"1":{"213":1}}],["place",{"1":{"188":1}}],["pwsh",{"0":{"435":1}}],["pwd",{"1":{"424":1}}],["pure",{"1":{"945":1,"956":1,"971":1}}],["purpose",{"0":{"927":1},"1":{"188":2}}],["public",{"1":{"719":1,"822":3,"967":1,"969":1}}],["push",{"1":{"510":1}}],["pushlatency这个变量应该从半条命引擎中移除",{"1":{"50":1}}],["put",{"1":{"486":1}}],["pull",{"1":{"420":1}}],["puzzle型任务",{"1":{"254":1}}],["pe文件可以是任何扩展名",{"1":{"131":1}}],["pe",{"1":{"127":2,"129":1,"131":3}}],["persistent",{"1":{"1022":1}}],["persistence",{"1":{"204":1}}],["perspective",{"1":{"737":1,"975":1}}],["permutation",{"1":{"199":1}}],["perlin发明的自然噪声生成算法",{"1":{"214":1}}],["perlin巧妙地使用了位翻转",{"1":{"202":1}}],["perlin的最初版算法里的",{"1":{"202":1}}],["perlin的java版本实现",{"1":{"198":1}}],["perlin才是",{"1":{"198":1}}],["perlin",{"1":{"197":1,"214":1}}],["perform",{"1":{"189":1}}],["performance",{"0":{"189":1,"191":1,"194":1},"1":{"186":2,"189":4,"191":3,"195":4,"196":2}}],["period",{"1":{"90":1}}],["per",{"1":{"22":1,"189":1,"982":1}}],["p=1",{"1":{"81":1}}],["pivotinspector",{"1":{"650":1}}],["pivot相对于四个锚点",{"1":{"640":1}}],["pivot",{"0":{"639":1},"1":{"634":2,"639":5,"650":1}}],["pixel",{"0":{"627":1},"1":{"974":3,"980":1}}],["pixels",{"1":{"196":1}}],["picture",{"1":{"571":1}}],["picturespublic",{"1":{"410":1}}],["pip",{"0":{"465":1},"1":{"465":4}}],["pipelinetask",{"0":{"228":1},"2":{"229":1}}],["pipelinerunner执行管道任务",{"1":{"227":1}}],["ping",{"1":{"51":2}}],["piece",{"1":{"26":1}}],["pc上面的开发者需要考虑到玩家层次不齐的机器配置以及网络状况",{"1":{"40":1}}],["pot",{"1":{"872":1}}],["policy页面了",{"1":{"607":1}}],["policy",{"1":{"607":2}}],["port",{"1":{"467":3}}],["portable",{"1":{"131":1}}],["powervr",{"1":{"1037":1}}],["powershell执行安装命令",{"1":{"533":1}}],["powershell",{"0":{"519":1},"1":{"424":3,"425":1,"499":1}}],["powerpc",{"1":{"33":1}}],["pomelo",{"1":{"104":1}}],["point2",{"1":{"751":1}}],["point1",{"1":{"751":1}}],["point时可以设置loaderoptimization属性",{"1":{"707":1}}],["pointercurrentraycast",{"1":{"695":1}}],["pointereventdata",{"1":{"684":1}}],["points",{"0":{"633":1},"2":{"634":1,"635":1,"636":1,"637":1}}],["point",{"1":{"27":1}}],["posy",{"1":{"634":2,"635":1}}],["posx",{"1":{"634":2,"636":1}}],["pos",{"1":{"633":3,"1053":1}}],["positive",{"1":{"191":1}}],["postdeserialize",{"1":{"489":1}}],["post",{"1":{"22":1,"28":3,"29":4,"189":1,"483":1}}],["possible",{"1":{"22":2,"189":1}}],["palyer",{"0":{"1012":1}}],["panel",{"1":{"964":1,"965":1}}],["pass使用的参数是相同的",{"1":{"980":1}}],["pass",{"1":{"940":1,"941":1,"942":1,"980":2}}],["pass越多drawcall越大",{"1":{"877":1}}],["pass越多这个越大",{"1":{"877":1}}],["password",{"1":{"467":1}}],["passwd",{"1":{"421":1}}],["paste",{"1":{"795":1,"803":1}}],["pa",{"1":{"789":1}}],["padding",{"1":{"635":1,"636":1}}],["page",{"1":{"527":1,"535":1}}],["pages",{"0":{"507":1},"1":{"507":3,"517":1}}],["payload",{"1":{"228":1}}],["paper",{"1":{"197":1}}],["pair",{"1":{"193":1}}],["parameters",{"1":{"866":1}}],["params",{"0":{"147":1}}],["parallaxdemo",{"1":{"737":1}}],["parallax",{"1":{"737":2}}],["parent和位置有关系",{"1":{"1053":1}}],["parent会帮助我们计算最终的",{"1":{"968":1}}],["parent",{"0":{"1000":1},"1":{"633":2,"635":1,"636":1,"637":1,"644":2,"944":1,"952":2,"959":1,"965":1,"1000":1,"1002":1,"1004":1,"1053":1},"2":{"1001":1,"1002":1,"1003":1}}],["parseable",{"1":{"488":1}}],["parse",{"1":{"488":1}}],["particle",{"1":{"968":1,"969":4,"978":1}}],["particlesystemrenderer",{"1":{"969":1,"975":4}}],["particlesystem的",{"1":{"968":1}}],["particlesystem",{"1":{"968":1,"969":1}}],["part2",{"0":{"225":1}}],["part1",{"0":{"224":1}}],["part",{"0":{"61":1,"62":1,"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"1010":1},"1":{"27":1,"899":4,"998":2,"1010":1},"2":{"81":1}}],["path中如果一个gameobject接受多个光照会为每一个per",{"1":{"980":1}}],["path記得要把",{"1":{"567":1}}],["path碰到屏幕边缘",{"1":{"224":1}}],["path向下",{"1":{"224":1}}],["path向右",{"1":{"224":1}}],["path向左",{"1":{"224":1}}],["path上",{"1":{"224":2}}],["path",{"0":{"224":1},"1":{"224":3,"901":1}}],["patch的边长为patch",{"1":{"101":1}}],["patch",{"0":{"100":1}}],["patent",{"1":{"55":1,"57":1,"59":1}}],["patents",{"1":{"55":1,"57":1,"59":1}}],["packet前4byte为传输信息类型描述",{"1":{"579":1}}],["packages",{"1":{"523":1,"927":1,"930":1,"942":1}}],["package",{"1":{"23":2,"526":1,"971":1,"998":1}}],["paced+multiplayer",{"1":{"81":1}}],["practice",{"0":{"997":1}}],["practices",{"1":{"162":1}}],["primary",{"0":{"947":1},"1":{"947":4,"949":1,"951":2,"954":1,"957":2,"959":1,"961":1,"962":1,"964":4,"966":2,"969":3,"1002":1,"1054":1}}],["primitive",{"1":{"190":1}}],["print",{"0":{"647":1,"649":1}}],["principle",{"1":{"189":1}}],["privacy",{"1":{"607":1}}],["private",{"1":{"486":1,"823":1}}],["priority和stops",{"1":{"283":1}}],["priority",{"1":{"283":5}}],["preconditions",{"1":{"1044":1}}],["precision",{"1":{"570":1,"571":1,"866":1}}],["pre",{"1":{"971":1,"977":1}}],["prefabtype=ghostprefabtype",{"1":{"1020":1}}],["prefab都已经准备就绪",{"1":{"965":1}}],["prefab组件",{"1":{"965":1}}],["prefabspawncharacteritemauthoring",{"1":{"1011":1}}],["prefabs",{"1":{"964":1,"1011":1}}],["prefab",{"0":{"870":1,"959":1,"965":1,"966":1,"1002":1,"1029":1},"1":{"901":1,"940":1,"943":1,"959":1,"960":7,"964":14,"965":14,"966":8,"967":1,"968":1,"969":3,"970":3,"1003":1,"1005":1,"1020":1}}],["prefer",{"1":{"189":1}}],["prebake",{"1":{"868":1}}],["preserialize",{"1":{"489":1}}],["preloader",{"1":{"471":1}}],["prepare",{"1":{"185":1}}],["predictingtick",{"1":{"1013":1}}],["predictingtick以确保可以在客户端和服务器上运行完全相同的代码",{"1":{"1013":1}}],["prediction",{"1":{"71":1,"81":1}}],["predict",{"1":{"84":1}}],["preview",{"1":{"841":1}}],["previous",{"1":{"28":1,"191":1}}],["prevents",{"1":{"24":1}}],["pretty",{"1":{"22":1,"189":1}}],["pro",{"1":{"839":2}}],["profiling",{"1":{"815":1,"878":1}}],["profiler不会追踪那些没有发生在主线程的内存分配",{"1":{"815":1}}],["profiler中的列表题分别为",{"1":{"878":1}}],["profiler中",{"1":{"815":1}}],["profiler",{"0":{"878":1},"1":{"700":2,"701":1,"878":2}}],["produce",{"1":{"601":1}}],["produced",{"1":{"571":1}}],["product",{"1":{"532":1}}],["proto",{"1":{"489":1}}],["protocontract",{"1":{"488":1}}],["protocol",{"1":{"50":1,"81":1}}],["protobuf",{"0":{"489":1},"1":{"486":1,"487":1,"489":2}}],["protobuff",{"1":{"484":1}}],["protomember",{"1":{"485":1}}],["protoinclude",{"1":{"484":1,"485":2}}],["proxy表示代理端",{"1":{"801":1}}],["proxy",{"1":{"707":1,"804":1,"968":1,"969":1}}],["proxying",{"1":{"532":1}}],["proxylist",{"1":{"473":1}}],["proxychains",{"0":{"471":1},"1":{"471":3,"472":1,"474":1},"2":{"472":1,"473":1,"474":1,"475":1}}],["proxies",{"1":{"471":1}}],["proc",{"1":{"467":1}}],["procedurally",{"1":{"225":1}}],["processtouchpress",{"0":{"670":1}}],["processstartinfo",{"1":{"424":1}}],["process",{"1":{"27":1,"131":1,"189":1,"424":1,"576":1,"720":1}}],["processing",{"1":{"27":1,"223":1}}],["props的说明",{"1":{"439":1}}],["propertieshttps",{"1":{"140":1}}],["properties",{"0":{"140":1},"1":{"487":1}}],["propertytoid",{"1":{"858":1}}],["property",{"0":{"485":1},"1":{"27":1,"485":1,"487":1,"720":1}}],["probabilistic",{"1":{"225":1}}],["problem",{"1":{"28":3,"488":1,"974":1,"1043":1}}],["programdata",{"1":{"498":1}}],["programsc",{"1":{"498":1}}],["programs",{"1":{"471":1,"498":1}}],["program",{"1":{"131":1,"425":1}}],["programmer",{"1":{"81":1}}],["provider",{"1":{"151":2,"152":1}}],["provide",{"1":{"25":1,"195":1}}],["provides",{"1":{"22":1}}],["projection",{"1":{"975":1}}],["project",{"1":{"23":2,"126":1,"183":1,"184":1,"532":1,"721":1,"868":5,"964":1,"965":1,"1034":1}}],["proof",{"1":{"15":1}}],["p",{"1":{"15":1,"21":1,"131":2,"211":2,"225":1,"587":1,"606":1,"719":4,"812":1,"850":2,"984":1}}],["甚至还会警告你把已经没用的",{"1":{"971":1}}],["甚至还存在根据不同的环境选择执行不同的子技能",{"1":{"794":1}}],["甚至",{"1":{"967":1}}],["甚至在你没有",{"1":{"955":1}}],["甚至现在你都没法使用所见即所得的编辑器了",{"1":{"945":1}}],["甚至占主导地位",{"1":{"858":1}}],["甚至技能只能创建法术场",{"1":{"799":1}}],["甚至可以包括condition节点",{"1":{"794":1}}],["甚至整个系统的造成影响",{"1":{"453":1}}],["甚至上万条",{"1":{"453":1}}],["甚至不会失血",{"1":{"377":1}}],["甚至是上下左右四个点的上下左右总共12个点",{"1":{"207":1}}],["甚至更小的鹅卵石块",{"1":{"204":1}}],["甚至理解错误了的",{"1":{"130":1}}],["甚至比用反射还慢",{"1":{"111":1}}],["甚至能够消除这种延迟",{"1":{"66":1}}],["甚至跳转",{"1":{"15":1}}],["甚至前面提到的",{"1":{"15":1}}],["通信中可能会遇到的一些问题",{"1":{"661":1}}],["通信",{"0":{"660":1},"1":{"707":1}}],["通信的一种规范",{"1":{"578":1}}],["通信是瞬发的",{"1":{"64":1}}],["通俗来说",{"1":{"572":1}}],["通用apk",{"1":{"586":1}}],["通用网关接口",{"1":{"572":1}}],["通用的读写方法",{"1":{"15":1}}],["通讯协议的格式保存",{"1":{"457":1}}],["通讯协议格式的命令文本",{"1":{"452":1}}],["通路",{"1":{"224":1}}],["通道",{"1":{"220":1}}],["通知unity我们会重写物体的渲染深度排序",{"1":{"976":1}}],["通知gpu进行渲染",{"1":{"876":1}}],["通知的范围",{"1":{"106":1}}],["通知玩家出生的格子集合",{"1":{"103":1}}],["通常不會寫",{"1":{"978":1}}],["通常只有透明物件會關閉",{"1":{"975":1}}],["通常無法搭配",{"1":{"975":1}}],["通常條件會設定為深度資訊比原本更接近攝影機時",{"1":{"974":1}}],["通常它会影响",{"1":{"958":1,"1001":1}}],["通常",{"1":{"936":1,"965":1}}],["通常我们会用下面的",{"1":{"927":1}}],["通常我们会使用",{"1":{"660":1}}],["通常比通过",{"1":{"864":1}}],["通常绑定在",{"1":{"686":1}}],["通常是矩形",{"1":{"862":1}}],["通常是ugui自己对输入进行处理并且输出的",{"1":{"678":1}}],["通常是",{"1":{"576":1,"970":1}}],["通常是最爱的礼物或喜欢的礼物",{"1":{"300":1}}],["通常是30",{"1":{"82":1}}],["通常也被称为",{"1":{"197":1}}],["通常使用最通用的指令集",{"1":{"130":1}}],["通常来说",{"1":{"127":1,"765":1}}],["通常调用windows",{"1":{"127":1}}],["通常通过",{"1":{"127":1}}],["通常将虚拟节点数设置为",{"1":{"96":1}}],["通常生产环境需要两组配置",{"1":{"88":1}}],["通常情况下",{"1":{"718":1}}],["通常情况下客户端接收每秒约20个快照更新",{"1":{"83":1}}],["通常情况下球在这两种状态之间",{"1":{"46":1}}],["通常服务器返回的结果和客户端的执行的结果是一致的",{"1":{"67":1}}],["通过代码加载dll",{"1":{"1050":1}}],["通过filesystemwatcher监控目录检查改变的文件",{"0":{"1047":1}}],["通过filter",{"1":{"987":2}}],["通过声明",{"1":{"964":1}}],["通过正确增加额外的",{"1":{"963":1}}],["通过继承",{"1":{"957":1}}],["通过以上可以看到明显的缺点只支持monobehavior若想支持非monobehavior可能需要自己进行处理",{"1":{"1049":1}}],["通过以下方法可以一次创建一个entity",{"1":{"907":1}}],["通过以静态变量的方式保持对象的引用",{"1":{"898":1}}],["通过批处理节省的drawcallsetpass",{"1":{"877":1}}],["通过网格合并可以实现游戏中的换装",{"1":{"848":1}}],["通过网络连接的多人游戏是超级有趣的",{"1":{"65":1}}],["通过rgb颜色通道来标记法线的方向",{"1":{"845":1}}],["通过包含对所用纹理的引用",{"1":{"844":1}}],["通过拓展表头实现一个技能同时执行多件事情",{"1":{"795":1}}],["通过向量之间的对比",{"1":{"777":1}}],["通过将一个多边形上的每个顶点与原点",{"1":{"763":1}}],["通过将两个物体在",{"1":{"759":1}}],["通过检测两个物体的速度矢量是否存在交点",{"1":{"760":1}}],["通过上述方法即可找出矩形上离圆心最近的点了",{"1":{"755":1}}],["通过找出矩形上离圆心最近的点",{"1":{"755":1}}],["通过out关键字来输出碰撞到的物体的信息",{"1":{"750":1}}],["通过动画来改变trigger的大小",{"1":{"748":1}}],["通过滚动移动多个连续的背景精灵形成滚动",{"1":{"725":1}}],["通过移动一个四边形顶点的",{"1":{"725":1}}],["通过射线raycast来检测我们的射线数据中包含哪些东西",{"1":{"675":1}}],["通过size",{"1":{"626":1}}],["通过反射",{"1":{"1050":1}}],["通过反射机制来运作的代码",{"1":{"592":1}}],["通过反射来读写",{"1":{"15":1}}],["通过uwsgi协议和nginx服务器实现http的动态请求和转发以及结果问题",{"1":{"581":1}}],["通过wsgi协议连接uwsgi服务器",{"1":{"581":1}}],["通过启用服务就能完成数据的恢复",{"1":{"441":1}}],["通过备份原文件到本机外的其他主机上",{"1":{"441":1}}],["通过converentitys",{"1":{"264":1}}],["通过判断任意两个",{"1":{"761":1}}],["通过判断任意两个圆形的圆心距离是否小于两圆半径之和",{"1":{"754":1}}],["通过判断",{"1":{"241":1}}],["通过配置有以下",{"1":{"228":1}}],["通过定量的统计结果可以看出",{"1":{"215":1}}],["通过查询约束矩阵",{"1":{"209":1}}],["通过两向量点积",{"1":{"197":1}}],["通过",{"1":{"167":1,"510":1,"695":1,"700":1,"781":1,"849":1,"947":1}}],["通过这一列的信息值来排序",{"1":{"878":1}}],["通过这样可以将勾人和攻击作为两个子技能构成技能树",{"1":{"795":1}}],["通过这个标识在元数据表methoddef里找到main方法的偏移位置",{"1":{"131":1}}],["通过这两个确定了程序的入口地址",{"1":{"131":1}}],["通过一趟排序将要排序的数据分割成独立的两部分",{"1":{"107":1}}],["通过一个回滚接口",{"1":{"15":1}}],["通过灯塔法",{"1":{"104":1}}],["通过计算以这个格子的为中心的九个格子",{"1":{"103":1}}],["通过在一定时间",{"1":{"84":1}}],["通过ack确认",{"1":{"82":1}}],["通过调整参数",{"1":{"50":1}}],["通过优化",{"1":{"15":1}}],["通过优化的预测技术",{"1":{"15":1}}],["通过插值和一些平滑方式",{"1":{"15":1}}],["期的实现方案",{"1":{"15":1}}],["时指定",{"1":{"1022":1}}],["时指定了射线检测层",{"1":{"689":1}}],["时移动",{"1":{"971":1}}],["时的行为",{"1":{"971":1}}],["时的状态",{"1":{"971":1}}],["时的参数",{"1":{"923":1}}],["时依然保持在",{"1":{"971":1}}],["时你就可以不用再重新运行转换过程",{"1":{"971":1}}],["时查看",{"1":{"971":1}}],["时能高效地添加",{"1":{"965":1}}],["时有两个不同的参数模式",{"1":{"964":1}}],["时传入",{"1":{"964":1}}],["时同时会禁用整个层级树",{"1":{"958":1,"1001":1}}],["时按钮会在正常和禁用状态之间闪烁",{"1":{"955":1}}],["时也会同时销毁",{"1":{"958":1,"1001":1}}],["时也会有一些变化",{"1":{"952":1}}],["时也会删除",{"1":{"931":1}}],["时不添加",{"1":{"948":1}}],["时代的感觉",{"1":{"945":1}}],["时预先合并",{"1":{"940":1}}],["时才返回",{"1":{"695":1}}],["时可能会遇到问题",{"1":{"604":1}}],["时发生故障",{"1":{"449":1}}],["时武功招是攻击力",{"1":{"378":1}}],["时生命会以最大生命的5",{"1":{"378":1}}],["时恢复到最大生命的60",{"1":{"378":1}}],["时则是高等物品",{"1":{"270":1}}],["时比较慢而后面就快的原因",{"1":{"131":1}}],["时",{"1":{"127":1,"167":1,"199":1,"270":1,"275":1,"685":1,"687":1,"688":1,"695":1,"701":1,"890":1,"898":1,"928":1,"931":2,"934":1,"943":1,"951":1,"965":1,"969":1,"971":3}}],["时获取的",{"1":{"85":1}}],["时差不该查过三分钟",{"1":{"56":1}}],["时刻要注意",{"1":{"15":1}}],["时间消耗",{"1":{"878":1}}],["时间很短",{"1":{"373":1}}],["时间观念",{"0":{"371":1}}],["时间与日期",{"0":{"291":1}}],["时间较长",{"1":{"118":1}}],["时间步长为15ms",{"1":{"82":1}}],["时间差",{"1":{"54":2,"55":1}}],["时间节点",{"1":{"12":2}}],["时间",{"1":{"12":1,"155":1}}],["注",{"1":{"846":1}}],["注入后不改变目标程序集",{"1":{"717":1}}],["注入后生成新的程序集",{"1":{"717":1}}],["注册mysql服务",{"1":{"434":1}}],["注册成services后",{"1":{"9":1}}],["注意模型上的粒子特效由于alpha透明通道",{"1":{"1032":1}}],["注意destroy销毁",{"1":{"1032":1}}],["注意lsv应从entitymanager",{"1":{"993":1}}],["注意如果飞船以",{"1":{"968":1}}],["注意如果buffer",{"1":{"958":1,"1001":1}}],["注意我们这里并没有定义",{"1":{"967":1}}],["注意并非",{"1":{"964":1}}],["注意下方拥有",{"1":{"961":1}}],["注意convert调用是递归的",{"1":{"961":1}}],["注意实例化并不一定和ecs中的",{"1":{"958":1,"1001":1}}],["注意到",{"1":{"952":1}}],["注意添加或移除component时",{"1":{"908":1}}],["注意占用5ms以上的选项",{"1":{"878":1}}],["注意每帧都具有20b以上内存分配的选项",{"1":{"878":1}}],["注意它是否运行性能消耗较大的每帧代码",{"1":{"860":1}}],["注意回退了index",{"1":{"712":1}}],["注意gameobject的layer也要与camera和raycaster一致",{"1":{"664":1}}],["注意anchoredposition是相对于锚点的位置",{"1":{"645":1}}],["注意offsetmax`是",{"1":{"645":1}}],["注意文件后期不能删除",{"1":{"556":1}}],["注意点",{"0":{"541":1}}],["注意powershell是不支持mklink的https",{"1":{"527":1}}],["注意这个servertick和serversimulationsystemgroup",{"1":{"1014":1}}],["注意这个结果是",{"1":{"841":1}}],["注意这个等级不是使用装备需要的等级",{"1":{"269":1}}],["注意这里要重启unity才会生效",{"1":{"834":1}}],["注意这是默认布局真实的布局是存在与注册表中",{"1":{"497":1}}],["注意正则式中包含空格",{"1":{"438":1}}],["注意mysql8密码可能认证有错误my",{"1":{"434":1}}],["注意背景植物可能是松树或者这种桦树",{"1":{"287":1}}],["注意植物可能是仙人掌",{"1":{"287":1}}],["注意子节点",{"1":{"280":1}}],["注意其上的",{"1":{"264":1}}],["注意后面两行是有秒数的",{"1":{"175":1}}],["注意多语言abp使用了缓存",{"1":{"146":1}}],["注意域名为ssl证书申请时用到的域名",{"1":{"135":1}}],["注意避免无限循环引用",{"1":{"111":1}}],["注意",{"0":{"718":1},"1":{"47":1,"111":2,"120":1,"172":1,"197":2,"220":1,"405":1,"449":2,"452":1,"476":1,"628":1,"642":1,"705":1,"759":1,"782":1,"807":1,"861":1,"878":1,"885":1,"890":1,"905":1,"910":2,"920":1,"921":1,"924":1,"944":1,"965":1,"977":1,"994":1}}],["注意处理好list",{"1":{"15":1}}],["注意write和read的顺序",{"1":{"15":1}}],["简化同步信息",{"1":{"795":1}}],["简书",{"1":{"631":1,"863":1}}],["简称",{"1":{"406":2,"573":1}}],["简称观察者",{"1":{"104":1}}],["简称为怪物的tc",{"1":{"267":1}}],["简称为",{"1":{"102":1}}],["简单地说",{"1":{"724":1}}],["简单来说",{"1":{"847":1}}],["简单来说就是由于一个assetbundle中包含有多个资源",{"1":{"701":1}}],["简单来说有两个步骤",{"1":{"118":1}}],["简单问题可用二分法完成",{"1":{"107":1}}],["简单过一下",{"1":{"103":1}}],["简单的来说",{"1":{"171":1}}],["简单的查找指定文化的字符串",{"1":{"155":1}}],["简单的说",{"1":{"92":1,"625":1,"703":1,"795":1}}],["简单的数值回滚复制的列表回滚和调用子模块回滚思路理顺以后",{"1":{"15":1}}],["简单有效",{"1":{"38":1}}],["简言之",{"1":{"13":1,"945":1}}],["定位和释放未使用的内存的过程被称为垃圾回收",{"1":{"827":1}}],["定位到他的所在的灯塔",{"1":{"104":1}}],["定则",{"1":{"781":1}}],["定压定频",{"1":{"551":1}}],["定压定频的功率会高与pbo的功率",{"1":{"551":1}}],["定好",{"1":{"376":1}}],["定义处理系统",{"0":{"1043":1}}],["定义处理特效之间的关系",{"1":{"233":1}}],["定义实体和组件",{"0":{"1042":1}}],["定义在使用lwrp或者hwrp时",{"1":{"982":1}}],["定义在使用",{"1":{"980":1,"981":1}}],["定义在dotnet",{"1":{"166":1}}],["定义标明为",{"1":{"979":1}}],["定义的",{"1":{"966":1}}],["定义缓冲",{"0":{"938":1}}],["定义某类状态和另一类状态之间的规则",{"1":{"800":1}}],["定义如下",{"1":{"683":1,"684":1}}],["定义了rendermesh组件来达成这个目的",{"1":{"905":1}}],["定义了一些tag用来释放前进行检查是否能释放该技能例如检查自身是否能够匹配",{"1":{"239":1}}],["定义了特效的使用效果与条件",{"1":{"233":1}}],["定义",{"0":{"163":1}}],["定义表包括应用所有的类型",{"1":{"131":1}}],["定义接口",{"1":{"15":1}}],["定时不等待",{"1":{"12":1}}],["各种资源的分布方差均比对照组小",{"1":{"215":1}}],["各顶点上的梯度向量随机选取结果请注意",{"1":{"197":1}}],["各自生成一个伪随机的梯度向量",{"1":{"197":1}}],["各自处理自己的保存快照和回滚",{"1":{"15":1}}],["各位读者有兴趣的",{"1":{"170":1}}],["各平台gc算法",{"0":{"123":1}}],["各个坐标系所代表的意思也可以从字面含义中理解出来",{"1":{"841":1}}],["各个坐标系各有特别",{"1":{"840":1}}],["各个部分还是较为清晰的",{"1":{"682":1}}],["各个等级的",{"1":{"287":1}}],["各个距离向量接着",{"1":{"197":1}}],["各个客户端计算结果是否一致等等",{"1":{"15":1}}],["各个peer按照自己的预测先行显示",{"1":{"13":1}}],["需要一些设定才会执行这个",{"1":{"1044":1}}],["需要一段时间",{"1":{"615":1}}],["需要找数据的时候就会从",{"1":{"929":1}}],["需要依赖前一个job的结果",{"1":{"922":1}}],["需要读权限的job需要等待前面写权限的job执行完",{"1":{"916":1}}],["需要占用更多的内存来存储合并后的几何结构",{"1":{"876":1}}],["需要保证它们指向光照纹理中的同一位置",{"1":{"876":1}}],["需要物体有相同的材质",{"1":{"876":1}}],["需要和技能模块外部交互",{"1":{"805":1}}],["需要同步的有两个时间点",{"1":{"803":1}}],["需要配置的内容也比较多",{"1":{"798":1}}],["需要不断计算两直线的交点",{"1":{"760":1}}],["需要以像素级别检测物体是否碰撞",{"1":{"759":1}}],["需要避免在外界持有entity或通过持有uuid间接从context中持有这个entity",{"1":{"739":1}}],["需要基于主相机的正交尺寸来设置视差的相机视角区域",{"1":{"737":1}}],["需要基于相机的距离来缩放每一个对象并放在适当的位置",{"1":{"737":1}}],["需要预先构建完整的背景而导致场景中存在过多的背景精灵带来的额外性能开销",{"1":{"729":1}}],["需要几张图片用于介绍",{"1":{"725":1}}],["需要完成两个主要工作",{"1":{"724":1}}],["需要实现",{"1":{"718":1}}],["需要实验下看看",{"1":{"704":1}}],["需要创建",{"1":{"718":1}}],["需要创建配置文件",{"1":{"467":1,"475":1}}],["需要collider",{"1":{"664":1}}],["需要子节点也实现ipointerdownhandler这个接口才行",{"1":{"657":1}}],["需要利用canvas",{"1":{"640":1}}],["需要每个语言具体去实现",{"1":{"576":1}}],["需要安装",{"1":{"477":1}}],["需要对所有的背景精灵进行移动",{"1":{"727":1}}],["需要对",{"1":{"453":1}}],["需要使用官方提供的api",{"1":{"402":1}}],["需要使用new方法并设置时区转成datetimeoffset",{"1":{"31":1}}],["需要在设计ui的时候",{"1":{"626":1}}],["需要在主工程中显式调用过",{"1":{"600":1}}],["需要在",{"1":{"537":1,"962":1}}],["需要在tsconfig",{"1":{"401":1}}],["需要在销毁land的时候",{"1":{"264":1}}],["需要自己去写一个",{"1":{"398":1}}],["需要去这个网站搜一下",{"1":{"398":1}}],["需要ts声明文件",{"1":{"398":1}}],["需要魅力高的外门去代理点当主持",{"1":{"391":1}}],["需要注意的一点是",{"1":{"751":1}}],["需要注意的是这些参数可能会在以后的unity版本中有所变化",{"1":{"592":1}}],["需要注意的是",{"1":{"46":1,"701":1}}],["需要注重的是",{"1":{"380":1}}],["需要床",{"1":{"369":1}}],["需要柜台",{"1":{"369":1}}],["需要8",{"1":{"287":1}}],["需要",{"1":{"286":1}}],["需要做一些小修改",{"1":{"223":1}}],["需要记录一个类似数据库的ahead",{"1":{"210":1}}],["需要回退",{"1":{"210":1}}],["需要回滚",{"1":{"89":1}}],["需要4个约束矩阵",{"1":{"209":1}}],["需要老年代来分担",{"1":{"120":1}}],["需要重启服务器",{"1":{"146":1}}],["需要重新在链表的头部开始遍历寻找z的位置",{"1":{"106":1}}],["需要重开",{"1":{"12":1}}],["需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求",{"1":{"88":1}}],["需要提前考虑数据库与应用部署同步迁移",{"1":{"88":1}}],["需要妥当处理未完成的业务和新的业务",{"1":{"88":1}}],["需要服务器才能使用不开服务器直接可以使用",{"1":{"746":1}}],["需要服务器和客户端都有更多可用的cpu和带宽资源",{"1":{"82":1}}],["需要服务器更新信息间隔固定",{"1":{"46":1}}],["需要考虑那个时候玩家的状态",{"1":{"47":1}}],["需要数据回滚的部分",{"1":{"15":1}}],["一对一",{"1":{"1054":1}}],["一次性提交整个合并模型的顶点数据",{"1":{"979":1}}],["一次交易量是1000",{"1":{"376":1}}],["一边实时",{"1":{"971":1}}],["一如",{"1":{"955":1}}],["一是动态批处理",{"1":{"876":1}}],["一长串也不好读",{"1":{"862":1}}],["一种可行性方案是使用析构函数",{"1":{"898":1}}],["一种可以避免进行强制类型转换的方式是提供你自己的类型安全的clone方法",{"1":{"111":1}}],["一种是使用baseeventdata类型",{"1":{"657":1}}],["一种是使用int",{"1":{"657":1}}],["一两个小时就好了",{"1":{"607":1}}],["一级属性",{"0":{"395":1}}],["一级一级的",{"1":{"131":1}}],["一共7级",{"1":{"380":1}}],["一开场绝对要各项生产设施都建设",{"1":{"376":1}}],["一开始的状态",{"1":{"88":1}}],["一支无名魔教的教众占据着此地",{"1":{"297":1}}],["一伙狡猾的贼人隐匿于此地",{"1":{"297":1}}],["一伙恶丐群聚于此地",{"1":{"297":1}}],["一时间曼珠沙华成为潮流",{"1":{"296":1}}],["一件白色的",{"1":{"273":1}}],["一起决定掉落的",{"1":{"271":1}}],["一定得明白它们前后都做了些什么事儿",{"1":{"949":1}}],["一定要设置清华大学的",{"1":{"567":1}}],["一定要设置一个",{"1":{"528":1}}],["一定要确保你有一个好的散热风扇",{"1":{"551":1}}],["一定要注意温度",{"1":{"551":1}}],["一定要尽早盖起来并且设定好",{"1":{"376":1}}],["一定要从那个表示长度的字节开始读",{"1":{"39":1}}],["一定是低级的产物",{"1":{"301":1}}],["一定程度上决定了装备可能的质量",{"1":{"269":1}}],["一条随机话语",{"1":{"255":1}}],["一条根据地图上所有物体的y坐标从小到大依次插入链表",{"1":{"105":1}}],["一条根据地图上所有物体的x坐标从小到大依次插入链表",{"1":{"105":1}}],["一组相互连通的房间",{"1":{"218":1}}],["一组是inactive的配置",{"1":{"88":1}}],["一组是active的生产环境的配置",{"1":{"88":1}}],["一旦它发现可以被",{"1":{"965":1}}],["一旦超过这个数量",{"1":{"960":1}}],["一旦你开始转换层级结构",{"1":{"960":1}}],["一旦安排了job后",{"1":{"921":1}}],["一旦调用了runner里getstats",{"1":{"898":1}}],["一旦我们开始执行该方法",{"1":{"885":1}}],["一旦切换到",{"1":{"721":1}}],["一旦资源的引用记数为0",{"1":{"697":1}}],["一旦检测到某个节点添加实现了",{"1":{"691":1}}],["一旦本机发生宕机",{"1":{"441":1}}],["一旦总舵被人攻占",{"1":{"380":1}}],["一旦不再满足条件",{"1":{"283":1}}],["一旦不再满足该条件",{"1":{"283":1}}],["一旦启动",{"1":{"283":2}}],["一旦条件满足",{"1":{"283":3}}],["一旦物品拥有了某个词缀",{"1":{"270":1}}],["一旦在根节点发生回退说明",{"1":{"210":1}}],["一旦掉线基本这局就废了",{"1":{"12":1}}],["一文中写了一个泛型生成器",{"1":{"176":1}}],["一样我们实例化的结果也拥有linkedentitygroup",{"1":{"966":1}}],["一样",{"1":{"451":1,"944":1,"969":1,"1000":1,"1023":1,"1040":1}}],["一样的",{"1":{"176":1}}],["一样先jit",{"1":{"131":1}}],["一切交給",{"1":{"978":1}}],["一切都很清楚了",{"1":{"173":1}}],["一切没问题后先检查类型方法表里这个方法的存根",{"1":{"131":1}}],["一块为eden",{"1":{"120":1}}],["一致",{"1":{"610":1,"982":1}}],["一致时",{"1":{"207":1}}],["一致性哈希是将整个哈希值空间组织成一个虚拟的圆环",{"1":{"92":1}}],["一致性哈希算法引入了",{"1":{"96":1}}],["一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可",{"1":{"95":1}}],["一致性哈希算法",{"0":{"92":1}}],["一致性哈希算法由此而生~",{"1":{"91":1}}],["一致哈希",{"1":{"92":1}}],["一台服务器无法发送每个时钟周期的一个以上的更新",{"1":{"86":1}}],["一词起源于航海",{"1":{"75":1}}],["一点也不可怕",{"1":{"941":1}}],["一点",{"1":{"75":1}}],["一秒钟后",{"1":{"75":1}}],["一秒钟可能发出10个以上的操作指令",{"1":{"73":1}}],["一辆速度非常快的汽车是可以预测的",{"1":{"75":1}}],["一般用于渲染背景",{"1":{"1036":1}}],["一般用于服务器调试",{"1":{"578":1}}],["一般添加",{"1":{"955":1}}],["一般优化",{"1":{"864":1}}],["一般我们会保持相机宽高比不变",{"1":{"841":1}}],["一般我们只需要一个动作判定一次",{"1":{"751":1}}],["一般视口坐标系主要用在相机显示中",{"1":{"841":1}}],["一般可以让法术场支持每次使用不同的结算参数来结算即可",{"1":{"807":1}}],["一般通过拓展法术场功能使用一个法术场来实现",{"1":{"807":1}}],["一般取判定点的坐标的话我们同样可以利用动画事件",{"1":{"751":1}}],["一般情况下不建议频繁使用",{"1":{"701":1}}],["一般情况下不超过",{"1":{"451":1}}],["一般作为基准坐标",{"1":{"640":1}}],["一般pc上会使用这种方式",{"1":{"627":1}}],["一般都会创建一个",{"1":{"510":1}}],["一般都会继承于该类",{"1":{"226":1}}],["一般建2座就够了",{"1":{"380":1}}],["一般以3个为宜",{"1":{"380":1}}],["一般以5个为宜",{"1":{"380":1}}],["一般的计算公式为",{"1":{"303":1}}],["一般画地形的时候都会像下面几种方式设计",{"1":{"287":1}}],["一般把sequence",{"1":{"281":1}}],["一般叫做",{"1":{"273":1}}],["一般只有",{"1":{"220":1}}],["一般你都会有一个地图编辑器",{"1":{"217":1}}],["一般会用瓦片",{"1":{"207":1}}],["一般是覆盖自己的",{"1":{"1013":1}}],["一般是通过标准输入",{"1":{"574":1}}],["一般是把堆分为新生代",{"1":{"122":1}}],["一般是取出一个或者多个服务器停止服务",{"1":{"89":1}}],["一般来说只有一个子节点",{"1":{"277":1}}],["一般来说是没上锁的两倍",{"1":{"274":1}}],["一般来说",{"1":{"74":1,"174":1,"224":1,"746":1,"793":1,"796":1,"799":2,"839":1}}],["一般在进游戏之初做",{"1":{"51":1}}],["一些记录",{"0":{"1051":1}}],["一些团队在一个数组返回值的函数需要返回一个空值时",{"1":{"825":1}}],["一些脚本函数在editor中运行会导致内存分配",{"1":{"815":1}}],["一些注意点",{"0":{"702":1}}],["一些术语解释",{"0":{"638":1},"2":{"639":1,"640":1,"641":1,"642":1,"643":1,"644":1}}],["一些城市有特殊产出",{"1":{"301":1}}],["一些左道异士结庐居于此地",{"1":{"297":1}}],["一些室内参考图",{"1":{"287":1}}],["一些模拟恶劣网络环境工具",{"0":{"60":1}}],["一些人错误地认为参数pushlatency应该设为实际网络延迟的一半",{"1":{"50":1}}],["一些工作",{"0":{"45":1}}],["一些我所收集到的情况吧",{"1":{"33":1}}],["一",{"0":{"36":1,"113":1,"405":1,"840":1},"1":{"876":1}}],["一直在不停喝水的男子",{"1":{"296":1}}],["一直到最后一排",{"1":{"224":1}}],["一直使用的是quartz",{"1":{"30":1}}],["一直快速执行到1000帧",{"1":{"15":1}}],["一个设为蓝色代表unity",{"1":{"1034":1}}],["一个设计良好的分布式哈希方案应该具有良好的单调性",{"1":{"91":1}}],["一个character到底有哪些东东了",{"1":{"1011":1}}],["一个独立的buffer",{"1":{"982":1}}],["一个批次超过125个物体",{"1":{"981":1}}],["一个非",{"1":{"965":1}}],["一个常见的情况是一个",{"1":{"961":1}}],["一个常见的错误是",{"1":{"644":1}}],["一个方块是",{"1":{"954":1}}],["一个方法的多个分支需要的内存也可能不一样",{"1":{"113":1}}],["一个来自",{"1":{"951":1}}],["一个system根据什么来决定处理哪些实体呢",{"1":{"915":1}}],["一个soft",{"1":{"707":1}}],["一个实体必须有一个或多个这样的组件类型",{"1":{"910":1}}],["一个实体必须具有所有这些组件类型",{"1":{"910":1}}],["一个实体的原型是什么",{"1":{"905":1}}],["一个块只包含一种原型",{"1":{"905":1}}],["一个栈结构包含方法调用地址",{"1":{"890":1}}],["一个指针占有一小块内存",{"1":{"883":1}}],["一个指针",{"1":{"883":1}}],["一个层级为1的texte",{"1":{"862":1}}],["一个层级为1的imageb",{"1":{"862":1}}],["一个层级为0的textd",{"1":{"862":1}}],["一个层级为0的imagea",{"1":{"862":1}}],["一个相机对应一个视口",{"1":{"841":1}}],["一个足够大的堆不应该在游戏中的暂停期间完全被填满",{"1":{"831":1}}],["一个完整的新字符串被分配到包含原来的部分",{"1":{"828":1}}],["一个小的",{"1":{"826":1}}],["一个例外情况要考虑那就是当返回的数组需要改变长度时",{"1":{"825":1}}],["一个更有害且难于发现的是由于重复使用unity返回数组的api造成的虚拟的数组内存分配",{"1":{"824":1}}],["一个更好的办法是",{"1":{"73":1}}],["一个普遍的造成装箱的问题是使用枚举类型来作为字典的键",{"1":{"822":1}}],["一个普通的个人网站",{"1":{"581":1}}],["一个具体的技能",{"1":{"794":1}}],["一个技能执行节点的执行流程中",{"1":{"803":1}}],["一个技能以一定的时间间隔创建是个法术场",{"1":{"801":1}}],["一个技能常常由多个子技能以一定的模式组合而成",{"1":{"794":1}}],["一个技能可能由多个子技能以一定的模式组合起来",{"1":{"794":1}}],["一个论坛成员写的分离轴定理碰撞检测系统",{"1":{"789":1}}],["一个向量在平行于另一个向量方向上的投影的数值乘积",{"1":{"763":1}}],["一个射线返回raycasthit",{"1":{"750":1}}],["一个可加载并浏览现有程序集并进行动态修改并保存的",{"1":{"717":1}}],["一个继承自monobehaviour",{"1":{"716":1}}],["一个不继承自monobehaviour",{"1":{"716":1}}],["一个程序在它运行的时候创建并且运行了全新的代码",{"1":{"709":1}}],["一个assembly可以被多个appdomain加载",{"1":{"707":1}}],["一个appdomain可以加载多个assembly",{"1":{"707":1}}],["一个appdomain就会为之产生一个soft",{"1":{"707":1}}],["一个appdomain内可以创建多个线程",{"1":{"707":1}}],["一个appdomain只能属于一个进程",{"1":{"707":1}}],["一个进程内可以有多个appdomain",{"1":{"707":1}}],["一个进程中可以有多个appdomain",{"1":{"707":1}}],["一个进行",{"1":{"588":1}}],["一个名称",{"1":{"701":1}}],["一个场景中只能有一个eventsystem组件",{"1":{"654":1}}],["一个支持虚拟机的运行时库",{"0":{"589":1}}],["一个介于网络协议服务和python应用之间的标准接口",{"1":{"583":1}}],["一个django应用",{"1":{"581":1}}],["一个uwsgi的web服务器",{"1":{"577":1}}],["一个约定",{"1":{"577":1}}],["一个新场景的打开会关闭当前的场景",{"1":{"698":1}}],["一个新进程处理",{"1":{"575":1}}],["一个新的快照更新到达时大约每50毫秒",{"1":{"83":1}}],["一个新的游戏状态从服务器获得",{"1":{"69":1}}],["一个",{"1":{"509":1,"575":1,"945":1,"960":1,"965":1,"970":1}}],["一个脚本重置应用以解决冲突",{"1":{"428":1}}],["一个帮补专掌法腿法消耗对方敏捷的方针开补血",{"1":{"377":1}}],["一个月的支出就是支薪1240元",{"1":{"371":1}}],["一个月份结算薪资4次",{"1":{"371":1}}],["一个月分4天",{"1":{"371":1}}],["一个大tc目录中可能包含有多个子tc目录",{"1":{"267":1}}],["一个招式洗练可以修改额外属性",{"1":{"251":1}}],["一个菱形的房间",{"1":{"221":1}}],["一个规划比较好的地牢会有很多规矩的房间",{"1":{"220":1}}],["一个出口",{"1":{"218":1}}],["一个入口",{"1":{"218":1}}],["一个地牢",{"1":{"218":1}}],["一个地图中的怪物状态",{"1":{"17":1}}],["一个同步块索引",{"1":{"131":1}}],["一个对象类型指针",{"1":{"131":1}}],["一个对象在地图上面运动",{"1":{"104":1}}],["一个文件是否是pe文件与其扩展名无关",{"1":{"131":1}}],["一个测试类",{"0":{"112":1}}],["一个是预测开始的tick服务端predictedghostcomponent其中appliedtick和predictionstarttick永远为0让我们看下ghostpredictionsystemgroup的源代码",{"1":{"1014":1}}],["一个是应用tick",{"1":{"1014":1}}],["一个是readtableheap",{"1":{"713":1}}],["一个是readmetadatastream",{"1":{"713":1}}],["一个是传递的gameobject",{"1":{"678":1}}],["一个是使用clr绑定",{"1":{"599":1}}],["一个是网络协议都是序列化数据odin",{"1":{"598":1}}],["一个是scriptobject的asset",{"1":{"598":1}}],["一个是数据迁移的dbcontext我们看到他们共同执行了",{"1":{"136":1}}],["一个是程序运行的dbcontext",{"1":{"136":1}}],["一个是获得这个新增对象的坐标在x",{"1":{"106":1}}],["一个是本格子内所有的对象集合",{"1":{"104":1}}],["一个玩家在10",{"1":{"85":1}}],["一个玩家实际上已经死了",{"1":{"70":1}}],["一个作弊玩家不仅仅给自己带来了更好的体验",{"1":{"62":1}}],["一个作弊的玩家可能并不会按你设计的套路去进行游戏",{"1":{"62":1}}],["一个目标时间",{"1":{"46":1}}],["一个命令通常会被客户端多次执行",{"1":{"43":1}}],["一个字节为8bit",{"1":{"33":1}}],["一个模块如何回滚",{"1":{"15":1}}],["一篇文章",{"1":{"15":1}}],["云风提的那种六边形灯塔区域减少查询灯塔个数是特指视野半径<=六边形边长的一半这种情况",{"1":{"104":1}}],["云风博客截图",{"1":{"15":1}}],["云风的解释",{"1":{"15":1}}],["提升了性能",{"1":{"575":1}}],["提升效率",{"1":{"206":1}}],["提示xxxxcommad不可用",{"1":{"417":1}}],["提高属性",{"1":{"247":1}}],["提高了游戏玩家的游戏体验",{"1":{"55":1}}],["提供中止条件",{"1":{"1043":1}}],["提供三个接口",{"1":{"793":1}}],["提供技能调用的接口供ai或玩家操作调用",{"1":{"793":1}}],["提供大家参考",{"1":{"726":1}}],["提供了一个检测是否点击在ui上的方法",{"1":{"658":1}}],["提供高质量bug的用户社区被证明是一个无价之宝",{"1":{"594":1}}],["提供允许数据能够在任意的时候",{"1":{"583":1}}],["提供的构建能力",{"1":{"535":1}}],["提供的静态网站托管服务",{"1":{"507":1}}],["提供门徒弟子休息",{"1":{"380":1}}],["提供两种方法来执行此转换",{"1":{"128":1}}],["提供给服务器以便发现游戏中的同步问题",{"1":{"15":1}}],["提到ecs在这个方式下的应用",{"1":{"15":1}}],["g2m3",{"1":{"1039":2}}],["g2m2",{"1":{"1039":2}}],["g2m1",{"1":{"1039":2}}],["g2",{"1":{"1039":1}}],["g1m3",{"1":{"1039":2}}],["g1m2",{"1":{"1039":2}}],["g1m1",{"1":{"1039":2}}],["g1",{"1":{"1039":2}}],["ghostcomponent",{"1":{"1020":1}}],["ghostauthoringcomponent验证的时候会生成prefabidghostauthoringconversion",{"1":{"1020":1}}],["ghostauthoringcomponenteditor中添加了translation和rotation的转换",{"1":{"1016":1}}],["ghost",{"0":{"1020":1}}],["ghostsystemstatecomponent",{"1":{"1020":1}}],["ghosts",{"1":{"1019":1}}],["ghostsendsystem",{"0":{"1019":1},"2":{"1020":1}}],["ghost数据",{"1":{"1013":1}}],["ghostreceivesystem",{"1":{"1013":1}}],["ghproxy",{"1":{"569":1}}],["gsv++",{"1":{"991":1}}],["g你可以看到还有一些",{"1":{"952":1}}],["gpu你画去吧但是显然把所有图片打成一张图集是不合理的",{"1":{"861":1}}],["gpu处理起来会快很多",{"1":{"861":1}}],["gpu",{"0":{"859":1,"981":1},"1":{"849":2,"859":1,"942":2,"952":1,"975":1,"981":2,"982":1,"1037":2}}],["gpwiki",{"1":{"789":1}}],["glsl",{"1":{"726":1}}],["gl",{"1":{"726":6}}],["gltexparameteri",{"1":{"726":2}}],["globalsystemversion为记录一个世界所有系统更新信息的版本号",{"1":{"991":1}}],["global",{"0":{"491":1},"1":{"488":1,"491":1,"526":2}}],["gyj",{"1":{"611":1}}],["gui",{"1":{"841":7,"845":1,"863":1}}],["gui界面坐标系",{"1":{"841":1}}],["guide",{"1":{"719":1}}],["guides",{"1":{"398":1}}],["gunicorn都是实现了wsgi",{"1":{"578":1}}],["gulp",{"1":{"134":1}}],["gb",{"1":{"181":1}}],["gmcs",{"1":{"126":1}}],["gc发现对象4有终结器",{"1":{"898":1}}],["gc需要执行特定代码去清理非托管资源",{"1":{"898":1}}],["gc需要修复指针",{"1":{"898":1}}],["gc对一直管理一个指针指向新对象将被放置的地址",{"1":{"898":1}}],["gc原则",{"1":{"898":1}}],["gc垃圾清理compacting现在我们有了一张需要保留对象的关系图",{"1":{"898":1}}],["gc会保留从jit和clr那收到的一个根",{"1":{"898":1}}],["gc会识别所有堆里剩下的对象并分配内存空间给它们",{"1":{"887":1}}],["gc停止所有当前运行线程",{"1":{"887":1}}],["gc就会开始运行",{"1":{"887":1}}],["gc运行完毕",{"1":{"813":1}}],["gc必须清扫全部的托管堆",{"1":{"813":1}}],["gc算法",{"1":{"813":1}}],["gcm",{"0":{"470":1}}],["gc触发时首先认为所有的对象都是垃圾",{"1":{"131":1}}],["gc的对象引用跟踪还有我们常用的反射都需要用到元数据",{"1":{"131":1}}],["gc的工作区域",{"0":{"113":1},"1":{"113":1}}],["gc有一些",{"1":{"124":1}}],["gc采用的是gc",{"1":{"116":1}}],["gc",{"1":{"116":1,"591":1,"815":2,"857":2,"878":3,"879":1,"937":1}}],["gc难以避免",{"1":{"15":1}}],["group则是一紧挨着运行",{"1":{"949":1}}],["group也是一种system",{"1":{"917":1}}],["group和collect",{"0":{"745":1}}],["group和group所过滤到的entities会被缓存下来",{"1":{"740":1}}],["group具有事件",{"1":{"744":1}}],["groups",{"1":{"740":1,"949":1}}],["group",{"0":{"740":1,"963":1},"1":{"738":1,"949":3,"963":1,"965":2}}],["great",{"1":{"188":1}}],["green",{"0":{"88":1},"1":{"90":4}}],["grain未激活完成的时候",{"1":{"161":1}}],["grain永远是运行在服务端的",{"1":{"159":1}}],["grain代码的执行将始终是单线程的",{"1":{"158":1}}],["grain激活体是单线程的",{"1":{"158":1}}],["grain",{"1":{"90":2}}],["graphics",{"0":{"693":1},"1":{"687":1,"688":1,"689":1,"692":1,"868":1,"941":2,"942":1,"974":1}}],["graphic",{"0":{"676":1,"686":1,"691":1,"692":1},"1":{"656":1,"686":2,"687":2,"688":1,"690":3,"691":7,"693":6,"694":3,"695":3,"868":1},"2":{"687":1,"688":1,"689":1,"690":1,"691":1,"692":1,"693":1,"694":1,"695":1}}],["graphicraycaster",{"0":{"688":1,"690":1},"1":{"654":1,"687":2,"689":1,"695":6},"2":{"689":1,"690":1,"691":1,"692":1,"693":1,"694":1,"695":1}}],["graph",{"0":{"86":1},"1":{"83":1,"86":1}}],["gac",{"1":{"707":2}}],["gateway",{"1":{"572":1,"573":1,"578":1}}],["garbage",{"1":{"193":1,"591":1}}],["gabrielgambetta",{"1":{"65":1,"71":1,"77":1,"81":2}}],["gamasutra",{"1":{"737":1}}],["gaming",{"1":{"15":1}}],["gametorrahod",{"1":{"965":1,"998":1}}],["gamedev",{"1":{"789":1}}],["gameentity",{"1":{"742":1}}],["gameobejct以及其父节点",{"1":{"657":1}}],["gameobject之间如果有镜像变换不能进行合批",{"1":{"980":1}}],["gameobject共享的模型会在应用程序包内或者内存中只存在一份",{"1":{"979":1}}],["gameobject并添加subscenecomponent",{"1":{"971":1}}],["gameobject才行",{"1":{"970":1}}],["gameobject字段",{"1":{"969":1}}],["gameobjectentity",{"1":{"968":1,"969":1}}],["gameobjectexportgroup",{"1":{"965":1}}],["gameobjectbeforeconversiongroup",{"1":{"966":1}}],["gameobjectdeclarereferencedobjectsgroup",{"1":{"964":2}}],["gameobjectconversionutility",{"0":{"970":1},"1":{"970":1}}],["gameobjectconversionmappingsystem",{"0":{"950":1},"1":{"999":1}}],["gameobjectconversionsystem",{"0":{"948":1},"1":{"1054":1}}],["gameobject的实例化相对其它的资源有些特殊",{"1":{"699":1}}],["gameobject的实例化",{"0":{"699":1}}],["gameobject",{"0":{"953":1},"1":{"657":1,"660":1,"940":1,"946":3,"952":1,"954":3,"961":2,"962":1,"963":1,"964":1,"965":1,"970":1,"971":2,"980":2,"999":1,"1002":1,"1054":1}}],["gameobject所有monobehavior实现onmouse的函数都会调用",{"1":{"652":1}}],["gameplayeffecttags",{"1":{"233":1}}],["gameplayeffectdefinitioncontainer",{"1":{"233":1}}],["gameplayeffectscriptableobject",{"0":{"233":1}}],["gameplayeffectspec",{"1":{"231":1}}],["gamefw",{"1":{"103":1}}],["gameinstitute",{"1":{"15":1,"984":2}}],["gamespublic",{"1":{"410":1}}],["gamessearches",{"1":{"409":1}}],["gamestdio",{"1":{"81":1}}],["games",{"1":{"15":1,"189":1}}],["game",{"0":{"969":1},"1":{"15":2,"50":1,"65":1,"81":2,"225":1,"720":3,"737":1,"841":1,"951":1,"952":1,"954":1,"961":1,"968":1,"969":8,"971":2,"1005":1}}],["gen",{"1":{"1016":1}}],["general",{"0":{"927":1}}],["generally",{"1":{"22":1}}],["generator",{"1":{"607":1}}],["generatorstats",{"1":{"228":1}}],["generation",{"1":{"471":1}}],["generateauthoringcomponent",{"0":{"967":1}}],["generate",{"0":{"227":1},"1":{"485":1,"585":1}}],["generatedlevel",{"1":{"228":1}}],["generated",{"1":{"225":1}}],["generics",{"0":{"489":1}}],["genericbucket",{"1":{"436":1}}],["generic",{"1":{"22":1,"25":1,"26":1,"188":1,"189":1,"193":1,"489":2,"823":6}}],["geometrylast",{"1":{"976":1}}],["geometry",{"1":{"976":1,"1036":2}}],["getarch因此",{"1":{"991":1}}],["getcomponentdata",{"1":{"966":1}}],["getcomponent就是最普遍的例子",{"1":{"815":1}}],["getprimaryentity",{"1":{"1054":1}}],["getprimaryentity显然是能够正常工作的",{"1":{"966":1}}],["getprimaryentity来传入",{"1":{"964":1}}],["getpixels",{"1":{"864":1}}],["getrawtexturedata",{"1":{"858":1}}],["getentityquery会在系统注册",{"1":{"997":1}}],["getenumerator",{"1":{"823":1}}],["geteventhandler",{"1":{"679":1}}],["gethashcode函数是一个引用类型",{"1":{"822":1}}],["gethashcode",{"1":{"822":2}}],["getdesireddivisor",{"1":{"818":1}}],["getmethod",{"1":{"715":1}}],["gettouch",{"1":{"824":1}}],["gettrigger使用collector根据event建立一个group的entity列表如上代码",{"1":{"742":1}}],["gettype和",{"1":{"715":1}}],["gettypes是如何操作的",{"1":{"714":1}}],["getting",{"1":{"147":2,"195":1,"404":1,"512":1}}],["getbytes",{"1":{"39":2}}],["get",{"1":{"28":1,"189":1,"424":5,"543":1,"598":1,"687":1,"823":1,"949":1}}],["gitforwindows",{"1":{"566":1}}],["gitbook",{"0":{"514":1},"1":{"500":2,"503":1,"505":1}}],["git会从windows凭证中查找",{"1":{"420":1}}],["git会让你输入一次用户明和密码",{"1":{"420":1}}],["gitcredentialstore",{"1":{"411":1}}],["git",{"0":{"415":1,"416":1,"521":1},"1":{"411":4,"412":1,"414":1,"415":1,"416":1,"419":1,"423":2,"500":1,"566":1}}],["git密钥存储相关",{"0":{"411":1}}],["github上看了issue上大家都有遇到这个问题768",{"1":{"568":1}}],["githubhere",{"1":{"189":1}}],["github",{"0":{"507":1,"517":1,"566":1},"1":{"10":2,"29":3,"60":1,"81":4,"90":1,"96":1,"103":1,"104":3,"105":1,"137":2,"147":2,"162":1,"166":1,"211":2,"398":1,"412":2,"415":1,"416":1,"427":3,"436":1,"437":1,"483":1,"490":1,"491":1,"507":7,"509":2,"510":3,"512":1,"515":2,"532":1,"533":2,"541":1,"542":1,"543":1,"544":1,"569":2,"719":1,"737":1,"747":2,"850":1,"939":1}}],["givequesttoquester",{"1":{"253":1}}],["given",{"1":{"22":1,"26":1}}],["g",{"1":{"22":1,"952":2,"977":1,"978":2}}],["goes",{"1":{"193":1}}],["go",{"1":{"185":2,"195":1,"510":2,"571":1,"585":1,"971":2}}],["googleplay",{"1":{"609":1}}],["google",{"1":{"55":1,"57":1,"59":1,"585":1,"607":1,"608":1,"611":1}}],["good",{"1":{"22":1,"189":1}}],["going",{"1":{"22":1,"24":1}}],["u3d优化批处理",{"1":{"981":1}}],["u>或withnone向查询添加参数列表中的组件",{"1":{"910":1}}],["ulong",{"1":{"881":1}}],["uv1和切向量",{"1":{"980":1}}],["uv0",{"1":{"980":1}}],["uv偏移",{"1":{"849":1,"981":1,"982":2}}],["uv就是将",{"1":{"846":1}}],["uv",{"0":{"726":1},"1":{"725":2,"726":14,"731":2,"732":1,"734":1,"846":2,"847":1}}],["ugui上显示模型",{"0":{"1032":1},"1":{"1032":1}}],["ugui中的ui默认使用的是ui",{"1":{"976":1}}],["ugui层级合并规则与批次生成规则",{"0":{"862":1}}],["ugui",{"0":{"977":1},"1":{"658":1,"661":1,"851":1,"863":1,"955":1,"977":1,"978":1}}],["ugui的层叠顺序是按照hierarchy中的顺序从上往下进行的",{"1":{"862":1}}],["ugui的合图是在什么时候发生的",{"0":{"703":1}}],["ugui的屏幕自适应原理和应用",{"1":{"631":1}}],["ugui的适配",{"0":{"624":1},"2":{"625":1,"626":1,"627":1,"628":1,"629":1}}],["utilizing",{"1":{"851":1}}],["utility",{"1":{"585":1,"971":1}}],["utf8",{"1":{"965":1}}],["utf",{"1":{"39":1}}],["uwp",{"1":{"720":1}}],["uwgsi",{"1":{"581":1}}],["uwsgi是一种通信协议",{"1":{"582":1}}],["uwsgi是使用c编写的",{"1":{"580":1}}],["uwsgi服务器实现wsgi",{"1":{"581":1}}],["uwsgi实现了wsgi协议",{"1":{"580":1}}],["uwsgi和wsgi都是基于cgi扩展出来的",{"1":{"582":1}}],["uwsgi和",{"1":{"578":1}}],["uwsgi等服务器",{"1":{"578":1}}],["uwsgi",{"0":{"577":2,"579":1,"580":1},"1":{"575":1,"577":2,"580":2,"581":3}}],["url",{"1":{"507":1}}],["umd",{"1":{"401":1}}],["umd类库",{"0":{"401":1}}],["umd库有两种使用方式",{"1":{"401":1}}],["umd库",{"1":{"397":1,"398":1}}],["u",{"1":{"225":1}}],["uk",{"1":{"153":1}}],["uint",{"1":{"881":1}}],["ui和sprites",{"1":{"872":1}}],["ui优化参考",{"0":{"863":1}}],["ui中出现最多的就是image与text组件",{"1":{"862":1}}],["ui元素必须拥有一样的材质和纹理",{"1":{"860":1}}],["ui可控制",{"1":{"797":1}}],["ui等上层逻辑使用",{"1":{"793":1}}],["uibehaviour",{"1":{"683":1}}],["uiscalemode一般选择scale",{"1":{"628":1}}],["ui作为canvas的子物体",{"1":{"626":1}}],["ui控件",{"1":{"624":1}}],["uic",{"1":{"153":1}}],["uiculture",{"1":{"152":1}}],["ui",{"0":{"860":1},"1":{"152":2,"153":3,"571":1,"592":1,"639":1,"657":1,"663":1,"666":1,"845":1,"863":1,"978":1,"998":1,"1041":2},"2":{"861":1,"862":1,"863":1}}],["ui=mvc",{"1":{"147":1}}],["udp",{"1":{"37":1,"51":1}}],["unmarshal",{"1":{"707":2}}],["unmanaged",{"1":{"127":1,"193":7}}],["under",{"1":{"585":1}}],["understand",{"1":{"486":1}}],["understanding那篇文章做的是模拟器游戏",{"1":{"15":1}}],["understanding",{"1":{"15":1,"833":1}}],["uncheck",{"1":{"571":1}}],["unet",{"1":{"571":1}}],["unrestricted",{"1":{"424":1}}],["universal",{"1":{"720":3}}],["unitview",{"1":{"999":1}}],["unite",{"1":{"864":1,"899":1}}],["unit创建时",{"1":{"792":1}}],["units值为100",{"1":{"618":1}}],["unity5",{"1":{"1038":1}}],["unityhttps",{"1":{"998":1}}],["unity提供给我们一些默认的渲染队列",{"1":{"976":1}}],["unity提供了一个方式来告诉unity引擎",{"1":{"603":1}}],["unityeditor",{"1":{"973":1}}],["unityengine",{"1":{"592":2}}],["unity中的ecs编程",{"1":{"919":1}}],["unityapi",{"1":{"864":1}}],["unity排序后的批次为textd",{"1":{"862":1}}],["unity排序后的批次为textc",{"1":{"862":1}}],["unity自身就提供了一个算法去决定哪些层应该合并到一起",{"1":{"862":1}}],["unity最终会将托管堆上那部分空的内存页释放回操作系统",{"1":{"814":1}}],["unity并不总是释放分配到托管堆的内存页",{"1":{"814":1}}],["unity的filesystemwatcher有点问题",{"1":{"1047":1}}],["unity的forward",{"1":{"980":1}}],["unity的ui渲染顺序的确定有2个步骤",{"1":{"862":1}}],["unity的垃圾收集是",{"1":{"813":1}}],["unity的事件处理",{"0":{"657":1}}],["unity混合模式2",{"0":{"736":1}}],["unity混合模式1",{"0":{"735":1}}],["unity默认的",{"0":{"720":1},"2":{"721":1,"722":1,"723":1}}],["unity工程在执行的时候",{"1":{"708":1}}],["unity将常量存储在4m的缓冲池里",{"1":{"984":1}}],["unity将选定的纹理打包到sprite",{"1":{"703":1}}],["unity将精灵打包到sprite",{"1":{"703":1}}],["unity合大图的时机是根据设置来的",{"1":{"703":1}}],["unity内部提供的各类raycaster我们这里就只着重看一下graphic",{"1":{"675":1}}],["unityのuguiのレイアウト調整機能について解説してみる",{"1":{"651":1}}],["unity记录",{"1":{"631":1}}],["unity会在运行时对于正在视野中的符合要求的所有对象使用",{"1":{"982":1}}],["unity会在运行时对于",{"1":{"980":1,"981":1}}],["unity会基于对象距离摄像机的远近来排序你的对象",{"1":{"976":1}}],["unity会自动完成",{"1":{"876":1}}],["unity会再做一个优化",{"1":{"862":1}}],["unity会将每一层的所有元素进行一个排序",{"1":{"862":1}}],["unity会根据当前屏幕实际的宽高比和摄像机的orthographicsize值来计算出摄像机的宽度值",{"1":{"618":1}}],["unity会生成aab文件",{"1":{"585":2}}],["unity编辑器中只能直接调整摄像机的高度",{"0":{"618":1}}],["unity版本号跨越4",{"1":{"594":1}}],["unity运行的是这个可执行文件",{"1":{"592":1}}],["unity官方自带生成柏林函数的函数",{"1":{"214":1}}],["unity3d",{"0":{"489":1,"835":1},"1":{"111":1,"601":1,"606":4,"701":1,"723":1,"825":1,"839":1,"840":2,"841":1,"855":2,"859":1,"863":1,"864":3,"903":1,"926":1,"941":1,"942":1,"984":1,"998":1},"2":{"836":1,"837":1}}],["unity",{"0":{"205":1,"656":1,"878":1},"1":{"81":1,"526":2,"527":2,"585":1,"587":2,"601":2,"604":5,"606":1,"632":1,"651":1,"656":1,"666":1,"683":1,"706":1,"720":30,"721":5,"722":6,"723":1,"737":1,"815":1,"835":3,"836":1,"838":1,"839":1,"840":3,"841":3,"850":2,"854":2,"855":1,"857":1,"858":2,"859":1,"863":3,"864":6,"876":1,"878":2,"919":3,"926":1,"927":2,"929":1,"930":2,"937":1,"939":1,"940":2,"941":2,"942":3,"944":2,"946":1,"947":1,"949":1,"951":1,"952":2,"955":1,"957":1,"959":1,"960":1,"964":1,"965":1,"971":1,"974":2,"975":2,"977":1,"984":1,"998":2,"1000":1,"1005":2,"1011":1,"1016":1,"1021":1,"1022":1,"1023":1,"1035":1,"1036":5,"1041":1,"1051":1,"1052":3},"2":{"657":1,"658":1}}],["unique",{"1":{"266":3}}],["unloadunusedassets",{"1":{"701":1}}],["unless",{"1":{"195":1,"196":1}}],["unlikely",{"1":{"195":1}}],["unsafety",{"1":{"193":1}}],["unfortunately",{"1":{"25":2,"28":1}}],["upcast",{"1":{"571":2}}],["upload",{"1":{"510":1}}],["upgrade",{"1":{"90":1,"606":1,"723":1}}],["upmove和buttons",{"1":{"42":1}}],["up",{"1":{"25":1,"27":2,"191":1}}],["update系统比较activeslot和lastactiveinventoryslot",{"1":{"1008":1}}],["update三个事件",{"1":{"739":1}}],["updated",{"1":{"654":1}}],["update之前",{"1":{"652":1}}],["updaterate增加",{"1":{"86":1}}],["updaterate为20",{"1":{"86":1}}],["updaterate你也可以降低画面插值延迟",{"1":{"86":1}}],["updaterate最高的客户价值",{"1":{"86":1}}],["updaterate的当前值",{"1":{"86":1}}],["updaterate的值",{"1":{"83":1}}],["updaterate",{"1":{"82":1,"86":2}}],["update",{"0":{"7":1,"89":1},"1":{"195":1,"817":2,"858":1,"934":1,"935":1,"947":1,"964":1,"1012":1}}],["ushort它们都衍生于system",{"1":{"881":1}}],["usage",{"1":{"196":1,"878":1}}],["us",{"1":{"153":1,"155":1,"188":2,"190":1,"192":1,"193":1,"499":1,"606":1}}],["usually",{"1":{"90":1}}],["usejournal",{"1":{"607":1}}],["user",{"1":{"571":1}}],["username",{"1":{"460":1,"497":1,"523":1,"526":1}}],["users",{"1":{"181":1,"421":1,"497":1,"498":1,"523":1,"526":1}}],["useshellexecute",{"1":{"424":1}}],["uses",{"1":{"192":1}}],["use",{"1":{"22":3,"24":1,"26":1,"27":1,"28":3,"29":1,"90":1,"181":2,"186":2,"187":1,"188":4,"193":3,"195":1,"196":1,"485":1,"488":1,"571":2,"719":1,"720":1,"737":1,"817":2}}],["used",{"1":{"22":2,"26":2,"90":2,"188":1,"489":1,"662":1}}],["using",{"0":{"28":1,"1023":1},"1":{"22":2,"23":1,"24":1,"25":2,"27":2,"29":2,"187":1,"189":1,"190":1,"193":4,"195":2,"485":1,"486":3,"489":1,"515":1,"571":2,"720":1,"764":1,"851":1,"998":1,"1023":1}}],["存入unity工程中的streamingassets文件夹下",{"1":{"708":1}}],["存档",{"0":{"289":1}}],["存根是用于标识是否被jit编译过",{"1":{"131":1}}],["存根将控件传递给",{"1":{"129":1}}],["存储了多个ability定义了技能类型",{"1":{"1007":1}}],["存储场景中所有渲染物体的材质信息",{"1":{"982":1}}],["存储在最终生成的vertex",{"1":{"979":1}}],["存储在新构建的大vertex",{"1":{"979":1}}],["存储大约",{"1":{"960":1}}],["存储库",{"1":{"510":1}}],["存储",{"1":{"127":1}}],["存储下每一帧的状态",{"1":{"15":1}}],["存在于",{"1":{"656":1}}],["存在于codegen",{"1":{"591":1}}],["存在",{"1":{"207":1}}],["存在相同编译器的各种版本",{"1":{"126":1}}],["存在对应帧的操作数据中",{"1":{"15":1}}],["存放到低地址",{"1":{"36":1}}],["守望先锋网络",{"1":{"15":1}}],["守望先锋的处理方式",{"1":{"15":1}}],["守护进程",{"1":{"3":1}}],["进而拥有并管理自己的entity和componentdata",{"1":{"1054":1}}],["进而写出高性能代码",{"1":{"887":1}}],["进而导致cpu的过载",{"1":{"876":1}}],["进而方便gpu高速处理",{"1":{"876":1}}],["进而达到优化的目的",{"1":{"876":1}}],["进而执行相关的操作",{"1":{"708":1}}],["进而实现在远程编程",{"1":{"545":1}}],["进程主要负责动态执行",{"1":{"576":1}}],["进程进行处理",{"1":{"576":1}}],["进程负责与",{"1":{"576":1}}],["进程太多时",{"1":{"575":1}}],["进程等着",{"1":{"575":1}}],["进程还可以根据配置预先启动几个",{"1":{"575":1}}],["进程不够用时",{"1":{"575":1}}],["进程将其会传递给一个",{"1":{"575":1}}],["进程",{"1":{"575":3,"707":1,"835":1}}],["进阶所改变",{"1":{"384":1}}],["进入",{"1":{"748":1,"968":1,"969":1}}],["进入entry",{"1":{"707":1}}],["进入系统后立即黑屏",{"1":{"551":1}}],["进入页面后点击上方的修改",{"1":{"460":1}}],["进入深处看人品+修为或者",{"1":{"295":1}}],["进入深处被打伤",{"1":{"295":1}}],["进入地图后",{"1":{"252":1}}],["进入下一个turn",{"1":{"11":1}}],["进一步来讲",{"1":{"824":1}}],["进一步说",{"1":{"815":1,"819":1}}],["进一步跟踪",{"1":{"711":1}}],["进一步降低你的插补周期",{"1":{"86":1}}],["进一步减少这些后",{"1":{"15":1}}],["进行predictedghostcomponent的设置",{"1":{"1019":1}}],["进行转换",{"1":{"971":1}}],["进行转换生成的点",{"1":{"259":1}}],["进行修改",{"1":{"971":1}}],["进行销毁",{"1":{"958":1,"1001":1}}],["进行组件的开发",{"1":{"955":1}}],["进行存储比如",{"1":{"901":1}}],["进行排序",{"1":{"862":1}}],["进行技能的操作",{"1":{"811":1}}],["进行一次compute",{"1":{"713":1}}],["进行实例化",{"1":{"699":1}}],["进行资源的加载",{"1":{"699":1}}],["进行场景切换时",{"1":{"701":1}}],["进行场景的卸载",{"1":{"698":1}}],["进行场景的加载",{"1":{"698":1}}],["进行场景的的释放",{"1":{"696":1}}],["进行场景创建时",{"1":{"696":1}}],["进行比较",{"1":{"695":1}}],["进行射线检测时",{"1":{"689":1}}],["进行查看",{"1":{"536":1}}],["进行打包",{"0":{"536":1},"1":{"536":1}}],["进行打包来减少插件体积",{"1":{"534":1}}],["进行编译",{"1":{"535":1}}],["进行上传",{"1":{"510":1}}],["进行参数传递",{"1":{"510":1}}],["进行的是按位拷贝",{"1":{"111":1}}],["进行",{"1":{"107":1}}],["进行升级",{"1":{"89":1}}],["进行更新",{"1":{"73":1}}],["进行传播的",{"1":{"64":1}}],["进行差值得到结果",{"1":{"46":1}}],["平铺信息",{"1":{"844":1}}],["平行于边缘法向量",{"1":{"762":1}}],["平行节点不行",{"1":{"655":1}}],["平均性能",{"0":{"731":1}}],["平均传入带宽和每秒接收的数据包的字节大小",{"1":{"86":1}}],["平台",{"1":{"737":1}}],["平台上均受支持",{"1":{"721":1}}],["平台等等",{"1":{"607":1}}],["平台可能会由于使用了反射而遇到序列化和反序列化问题",{"1":{"598":1}}],["平台无法实现",{"1":{"597":1}}],["平台為範例來說明",{"1":{"566":1}}],["平台游戏",{"1":{"225":1}}],["平平无奇的石料+修为",{"1":{"295":1}}],["平滑过渡视野等等",{"1":{"842":1}}],["平滑客户端时钟差值可以有很多方法",{"1":{"50":1}}],["平滑问题",{"1":{"46":1}}],["平滑等",{"1":{"15":1}}],["平常也可用于不同步debug",{"1":{"15":1}}],["都不一样",{"1":{"1040":1}}],["都不会为层级结构添加linkedentitygroupbuffer",{"1":{"971":1}}],["都不会互相影响",{"1":{"15":1}}],["都一样",{"1":{"1040":1}}],["都一笔带过了快照的说明",{"1":{"15":1}}],["都包含",{"1":{"966":1}}],["都已经完成",{"1":{"965":1}}],["都有支援此參數",{"1":{"975":2}}],["都有效",{"1":{"965":1,"1003":1}}],["都有",{"1":{"952":1}}],["都按从上往下的顺序被装在一个list中",{"1":{"862":1}}],["都没有发现任何间隙",{"1":{"784":1}}],["都将得到一个唯一的实例",{"1":{"699":1}}],["都将是",{"1":{"695":1}}],["都被设置为了",{"1":{"695":1}}],["都为1",{"1":{"952":1}}],["都为",{"1":{"695":1,"841":1}}],["都射线检测成功或是不需要使用",{"1":{"691":1}}],["都未设置",{"1":{"691":1}}],["都可以成为一个job",{"1":{"920":1}}],["都可以接收射线碰撞检测",{"1":{"684":1}}],["都可以使用eventtrigger这个component",{"1":{"657":1}}],["都可以检测子节点的collider",{"1":{"655":1}}],["都可以认为是以像素为单位",{"1":{"640":1}}],["都可将它变为自己的分舵",{"1":{"380":1}}],["都能处理请求",{"1":{"581":1}}],["都能搭配任意一个框架呢",{"1":{"577":1}}],["都需要到厢房进行休息",{"1":{"380":1}}],["都需要优化好",{"1":{"15":1}}],["都会在目标世界中自动创建一个主要实体",{"1":{"1054":1}}],["都会记录该system的lsv",{"1":{"991":1}}],["都会添加",{"1":{"965":1}}],["都会有",{"1":{"952":1}}],["都会和最初的类似",{"1":{"952":1}}],["都会这样",{"1":{"819":1}}],["都会为其重新生成",{"1":{"722":1}}],["都会工作",{"1":{"695":1}}],["都会默认安装",{"1":{"500":1}}],["都会被执行",{"1":{"448":1,"450":1}}],["都会只剩1",{"1":{"374":1}}],["都会先停止子节点",{"1":{"283":1}}],["都会令输出结果完全不一样下面代码就是柏林噪声算法所使用的哈希函数",{"1":{"201":1}}],["都会改变怪物的状态",{"1":{"17":1}}],["都用到了线程池",{"1":{"170":1}}],["都难免会这样写",{"1":{"124":1}}],["都作为服务器的状态",{"1":{"44":1}}],["都无字节序问题",{"1":{"39":1}}],["都方便很多",{"1":{"15":1}}],["都是使用了",{"1":{"1054":1}}],["都是3500",{"1":{"1039":1}}],["都是被扫描以及归集到一起的",{"1":{"949":1}}],["都是返回物体的世界坐标值",{"1":{"841":1}}],["都是单位向量",{"1":{"781":1}}],["都是在各自射线检测器中根据",{"1":{"695":1}}],["都是",{"1":{"33":1,"38":1,"1039":3}}],["都是能保存下每一帧的状态",{"1":{"15":1}}],["都是基于对每一帧状态可以处理快照",{"1":{"15":1}}],["都是b看a的抖动",{"1":{"15":1}}],["根节点exit",{"1":{"805":1}}],["根本不会发生碰撞",{"1":{"766":1}}],["根本不是什么语言",{"1":{"573":1}}],["根據",{"1":{"564":1,"975":4}}],["根骨",{"1":{"395":1}}],["根",{"1":{"124":2,"898":1}}],["根据query为",{"1":{"1043":1}}],["根据实际测试",{"1":{"1037":1}}],["根据不同硬件平台",{"1":{"1037":1}}],["根据不同的key",{"1":{"901":1}}],["根据ghostid实例化ghost",{"1":{"1020":1}}],["根据ghostid",{"1":{"1020":1}}],["根据引擎的场景管理系统判断各个子模型的可见性",{"1":{"979":1}}],["根据其摆放在场景中的位置等最终状态信息",{"1":{"979":1}}],["根据其保存的信息",{"1":{"849":1}}],["根据模式的不同",{"1":{"970":1}}],["根据模拟时间将移动命令打包发送给服务器",{"1":{"41":1}}],["根据system的顺序",{"1":{"916":1}}],["根据server的new",{"1":{"69":1}}],["根据red查询出来的资源有c",{"1":{"903":1}}],["根据cube查询出来的资源有a",{"1":{"903":1}}],["根据以上规则",{"1":{"862":1}}],["根据以上说明可以知道",{"1":{"449":1}}],["根据光照输入和材质配置来计算每个像素渲染的颜色",{"1":{"844":1}}],["根据单位身上已有的原子状态判定新的原子状态应该使用何种行为处理",{"1":{"800":1}}],["根据两条线的交点位置来判定是否发生碰撞",{"1":{"760":1}}],["根据下图",{"1":{"756":1}}],["根据情况使用",{"1":{"750":1}}],["根据情况返回true和false",{"1":{"283":1}}],["根据它来在",{"1":{"695":1}}],["根据得到的射线的方向以及",{"1":{"684":1}}],["根据屏幕大小进行缩放",{"0":{"628":1}}],["根据屏幕的分辨率",{"1":{"626":1}}],["根据场景位置设置ui位置",{"0":{"623":1}}],["根据app的名称",{"1":{"607":1}}],["根据你的python版本修改",{"1":{"476":1}}],["根据键的类型",{"1":{"454":1}}],["根据命令",{"1":{"452":1}}],["根据条件",{"1":{"446":2}}],["根据采集资源的不同生产出来的武器",{"1":{"380":1}}],["根据素材决定会有哪些作物",{"1":{"303":1}}],["根据land或者house",{"1":{"258":1}}],["根据latency调整",{"1":{"15":1}}],["根据",{"1":{"224":1,"1025":1}}],["根据用户设定的植被",{"1":{"214":1}}],["根据用户设置的水体占比来制定海平面高度",{"1":{"214":1}}],["根据玩家的偏好定制地图参数在新建游戏之前",{"1":{"214":1}}],["根据玩家的偏好定制参数",{"1":{"213":1}}],["根据玩家坐标",{"1":{"103":1}}],["根据记录矩阵在该点的瓦片集合以及随机数为该节点选择一个瓦片",{"1":{"210":1}}],["根据权重和生成的随机数以及选择一个节点",{"1":{"210":1}}],["根据约束矩阵",{"1":{"208":1}}],["根据这个随机数去遍历所有的可能性并找到一个合适的解",{"1":{"208":1}}],["根据这些因素",{"1":{"20":1}}],["根据新增对象的x",{"1":{"106":1}}],["根据二维地图",{"1":{"106":1}}],["根据前面的思路就变得非常简单https",{"1":{"105":1}}],["根据y方向的视野范围找出需要识别的对象",{"1":{"105":1}}],["根据x方向的视野范围找出需要识别的对象",{"1":{"105":1}}],["根据对象的当前位置和对象的感知距离",{"1":{"104":1}}],["根据当前位置的格子",{"1":{"103":1}}],["根据移动前位置的格子",{"1":{"103":1}}],["根据一致性哈希算法",{"1":{"92":1}}],["根据h确定在环中的具体位置",{"1":{"92":1}}],["根据许多因素",{"1":{"75":1}}],["根据每一个具体的时间点进行插值",{"1":{"46":1}}],["根据客户端的具体情况进行归一",{"1":{"47":1}}],["根据客户端当前时间",{"1":{"46":1}}],["根据客户端操作执行逻辑运算",{"1":{"41":1}}],["根据服务器数据包的内容决定可见物体及其状态",{"1":{"41":1}}],["根据保存的操作指令",{"1":{"15":1}}],["根据动态的latency",{"1":{"15":1}}],["根绝不同的需求",{"1":{"15":1}}],["还处于开发中",{"1":{"971":1}}],["还隐含着一个",{"1":{"969":1}}],["还隐含着一个事情就是",{"1":{"665":1}}],["还记得这是为",{"1":{"965":1}}],["还不存在",{"1":{"934":1}}],["还包含了",{"1":{"916":1}}],["还需要确定一条垂直于边缘向量的法向量",{"1":{"762":1}}],["还需要对entity的component做独立的判断",{"1":{"739":1}}],["还需要把连接地址发送给测试人员",{"1":{"610":1}}],["还需要跟新玩家的视野队列",{"1":{"104":1}}],["还节约了系统资源",{"1":{"575":1}}],["还会通过事件将这个添加传递给context",{"1":{"738":1}}],["还会追加到这个缓存中",{"1":{"455":1}}],["还会有自己专属的成品qlvl",{"1":{"273":1}}],["还原",{"1":{"452":1}}],["还原时所使用的命令来自于",{"1":{"452":1}}],["还得查看",{"1":{"417":1}}],["还向周边散播着恶毒与疾病",{"1":{"297":1}}],["还可以根据具体需要来实现其他行为",{"1":{"765":1}}],["还可以编写或者使用一些编辑器工具来帮助你保存和自动完成对象层级设置",{"1":{"737":1}}],["还可以通过继承dungeongeneratorpostprocessbase写你自己的后处理函数",{"1":{"228":1}}],["还可以用画笔工具",{"1":{"0":1}}],["还能处理小数",{"1":{"199":1}}],["还没有加入到任务队列",{"1":{"161":1}}],["还没看到如何用",{"1":{"148":1}}],["还要把",{"1":{"840":1}}],["还要看一下展示案例的视频",{"1":{"737":1}}],["还要看他的学习力",{"1":{"374":1}}],["还要整理所有存活对象的引用地址",{"1":{"119":1}}],["还要在克隆引用对象指向原始对象的时候",{"1":{"111":1}}],["还和场景大小成正比",{"1":{"110":1}}],["还有记得重启unity然后",{"1":{"1021":1}}],["还有什么值得注意的呢",{"1":{"841":1}}],["还有是通过枚举器实现的容器迭代的函数调用消耗比常规的for或者while循环的迭代要慢的多",{"1":{"823":1}}],["还有就是必须满足",{"1":{"748":1}}],["还有就是不要混用",{"0":{"31":1}}],["还有event能够监听到",{"1":{"745":1}}],["还有event应该在什么地方添加",{"0":{"745":1}}],["还有collect",{"1":{"745":1}}],["还有触发gameobject树结构中所有挂载事件的物体",{"1":{"680":1}}],["还有",{"1":{"509":1,"737":1,"858":1,"967":1}}],["还有其他的几个坐标系也非常常用",{"1":{"840":1}}],["还有其他",{"1":{"287":1}}],["还有其他办法可以令噪声结果更加自然吗",{"1":{"204":1}}],["还有一些建议用透视相机和对象的z轴深度",{"1":{"737":1}}],["还有一个很常用的调整渲染顺序的选项",{"1":{"1041":1}}],["还有一个小技巧是可以生成",{"1":{"967":1}}],["还有一个非常特别的系统附加在所有可用的",{"1":{"950":1}}],["还有一个",{"1":{"510":1,"841":1}}],["还有一种",{"1":{"411":1}}],["还有一种特殊情况",{"1":{"270":1}}],["还有一般来说是fixedlevelgraphinputtask",{"1":{"228":1}}],["还有会实例化",{"1":{"228":1}}],["还有比如",{"1":{"225":1}}],["还有对角线上的4个点",{"1":{"207":1}}],["还有这种技术存在的必要吗",{"1":{"206":1}}],["还有16bit的short型",{"1":{"33":1}}],["还是插值",{"1":{"1019":1}}],["还是一个结构体",{"1":{"927":1}}],["还是即将销毁的实体",{"1":{"906":1}}],["还是",{"1":{"841":1}}],["还是将两者分开",{"1":{"765":1}}],["还是让我们一同来偷师一下",{"1":{"380":1}}],["还是有可能导致服务停止",{"1":{"88":1}}],["还是有客户端的预测和服务器不吻合的情况",{"1":{"70":1}}],["还是客户端采样并生成命令发送到服务器",{"1":{"43":1}}],["还是运行效率上的",{"1":{"15":1}}],["还是要等服务器的返回",{"1":{"15":1}}],["还是预测的逻辑帧",{"1":{"15":1}}],["即渲染时renderqueue大的会挡住renderqueue小的",{"1":{"976":1}}],["即在scene里被实例化的",{"1":{"964":1}}],["即便你为它们添加了inject模式的",{"1":{"956":1}}],["即便你对",{"1":{"955":1}}],["即我们所说的深复制",{"1":{"896":1}}],["即将溢出",{"1":{"887":1}}],["即将大地图划分成有限的小格子",{"1":{"104":1}}],["即如果相邻间的两个批次正好可以batch的话就会进行batch",{"1":{"862":1}}],["即第一个submesh使用第一个",{"1":{"847":1}}],["即问题在于表达三个点的坐标",{"1":{"846":1}}],["即顺时针旋转",{"1":{"846":1}}],["即editor文件夹中script",{"1":{"839":1}}],["即法术场在每次结算时使用不同的参数",{"1":{"807":1}}],["即玩家a看玩家b的效果为",{"1":{"804":1}}],["即能进入结算逻辑",{"1":{"803":1}}],["即此单位是由客户端和还是服务端控制",{"1":{"801":1}}],["即判断上一个子技能是否成功",{"1":{"795":1}}],["即当单位正在冲锋时",{"1":{"795":1}}],["即当在发送输入信息的时候",{"1":{"67":1}}],["即长度",{"1":{"756":1}}],["即不能旋转",{"1":{"755":1}}],["即关于水平和垂直方向上对称",{"1":{"753":1}}],["即视差层会和正交透视有同样的移动速度",{"1":{"737":1}}],["即四种方式所实现的背景可以有多复杂",{"1":{"732":1}}],["即所谓的",{"1":{"726":1}}],["即只有一份mscorlib代码在内存中",{"1":{"707":1}}],["即实现了",{"1":{"657":1}}],["即实例化",{"1":{"228":1}}],["即一个100",{"1":{"627":1}}],["即一种分目标完成程序算法",{"1":{"107":1}}],["即0~1",{"1":{"625":1}}],["即0x0011中",{"1":{"33":1}}],["即0x0010中",{"1":{"33":1}}],["即摄像机和canvas的z的距离用3d视图看下这个时候是看不到cube的注意",{"1":{"622":1}}],["即asgi是wsgi的扩展",{"1":{"584":1}}],["即代理服务器",{"1":{"581":1}}],["即用来接受客户端请求",{"1":{"577":1}}],["即处理这些业务逻辑",{"1":{"577":1}}],["即动态请求",{"1":{"573":1}}],["即开始对插件进行打包",{"1":{"535":1}}],["即为类库添加自定义的方法其中umd库和模块类库的添加插件方法一致",{"1":{"402":1}}],["即精英怪身边的与其同类的喽啰怪物",{"1":{"266":1}}],["即ipipelinetask的上下文",{"1":{"227":1}}],["即图中那些暗红色的格子",{"1":{"224":1}}],["即输入模型矩阵",{"1":{"208":1}}],["即维护两天链表",{"1":{"105":1}}],["即自身感兴趣的所有对象",{"1":{"104":1}}],["即发生了跨格子的操作",{"1":{"103":1}}],["即每个对象都能看到以自己所在patch为中心前后左右各两个patch",{"1":{"102":1}}],["即对每个节点计算多个哈希值",{"1":{"96":1}}],["即服务节点的变更不会造成大量的哈希重定位",{"1":{"91":1}}],["即部署新版本应用",{"1":{"88":1}}],["即使可用空间总量高于要分配的空间量",{"1":{"857":1}}],["即使反复连接也不会引起太多麻烦",{"1":{"828":1}}],["即使其导致了无意识的内存分配",{"1":{"820":1}}],["即使这些被分配内存的一些或全部在随后的帧中被复用",{"1":{"815":1}}],["即使这个玩家的血量降到负的了",{"1":{"70":1}}],["即使托管堆中包含的许多这些对象马上就会被释放",{"1":{"815":1}}],["即使托管堆大部分是空的",{"1":{"814":1}}],["即使矩形以其中心为旋转轴进行了旋转",{"1":{"756":1}}],["即使不再使用后也不是立即卸载的",{"1":{"701":1}}],["即使一个资源的不再被引用也不代表此资源被卸载了",{"1":{"701":1}}],["即使一个快照丢失",{"1":{"83":1}}],["即使在",{"1":{"455":1}}],["即使我编写了一些",{"1":{"125":1}}],["即使玩家已经在目标准确瞄准",{"1":{"85":1}}],["即使是瘦子也可挡",{"1":{"377":1}}],["即使是当在等待服务器处理出入",{"1":{"71":1}}],["即使是internet上的数据",{"1":{"64":1}}],["即使世界是绝对的确定的",{"1":{"70":1}}],["即延迟+",{"1":{"55":1}}],["即可使用",{"1":{"756":2}}],["即可判断是否发生碰撞",{"1":{"755":1}}],["即可判断客户端之间是否保持同步",{"1":{"15":1}}],["即可以有多个实现wsgi",{"1":{"578":1}}],["即可看到整个插件是由哪些文件构成了",{"1":{"535":1}}],["即可切换为清华大学的镜像",{"1":{"480":1}}],["即可切换为中科大的镜像",{"1":{"479":1}}],["即可通过代理访问网络",{"1":{"473":1}}],["即可批准入门",{"1":{"380":1}}],["即可方便的计算出其所属的patch以及对应的对象链表",{"1":{"101":1}}],["即可",{"1":{"51":1,"133":1,"726":1}}],["即时编译",{"1":{"709":1}}],["即时编译器",{"1":{"131":1}}],["即时",{"1":{"45":1}}],["即大端还是小端一些封装另外c",{"1":{"38":1}}],["即",{"1":{"37":1,"266":1,"618":1,"695":1,"756":1,"827":1,"831":1,"975":1}}],["即job执行并发数控制",{"1":{"30":1}}],["即谁最先发消息给服务器申请怪物的ai锁定",{"1":{"19":1}}],["即网络不好的玩家",{"1":{"15":1}}],["即99帧",{"1":{"15":1}}],["做一个",{"1":{"966":1}}],["做一个跟直接调用的方法功能一模一样的委托",{"1":{"175":1}}],["做主要用途的示例",{"1":{"933":1}}],["做圆周运动",{"1":{"756":1}}],["做相应的检查",{"1":{"715":1}}],["做google",{"1":{"610":1}}],["做为后端服务器",{"1":{"581":1}}],["做为代理服务器",{"1":{"581":1}}],["做饭和招呼客人的时候增加经验",{"1":{"368":1}}],["做了一系列的房间设计",{"1":{"225":1}}],["做了小小的改动",{"1":{"198":1}}],["做数据预处理时",{"1":{"204":1}}],["做个标记",{"1":{"118":1}}],["做得还不够好",{"1":{"15":1}}],["做逻辑回滚",{"1":{"15":2}}],["做网络对时",{"1":{"12":1}}],["包缓存太大",{"0":{"526":1}}],["包管理工具",{"1":{"500":1}}],["包的版本号",{"1":{"439":1}}],["包含对于",{"1":{"965":1,"1003":1}}],["包含层级树下的所有对象以及自己",{"1":{"965":1}}],["包含进来了",{"1":{"963":1}}],["包含那些并不高效的",{"1":{"947":1}}],["包含一些预定义的group组",{"1":{"917":1}}],["包含数据显式创建使用指定数量的实体填充的块",{"1":{"907":1}}],["包含变异品下面等游戏一测做完再做吧",{"1":{"287":1}}],["包含了",{"1":{"689":1}}],["包含了ability的scriptobject",{"1":{"234":1}}],["包含了其他数据等级",{"1":{"231":1}}],["包含两个参数",{"1":{"164":1}}],["包括在调用scenemanager",{"1":{"971":1}}],["包括",{"1":{"965":2,"1002":1}}],["包括它里面的数据也可以创建一个空的entity",{"1":{"907":1}}],["包括移动",{"1":{"905":1}}],["包括市面上不少其他热更方案",{"1":{"718":1}}],["包括加载的assetbundle及加载的资源等等",{"1":{"700":1}}],["包括以下几个",{"1":{"685":1}}],["包括鼠标在哪",{"1":{"657":1}}],["包括http",{"1":{"583":1}}],["包括uwsgi和gunicorn",{"1":{"578":1}}],["包括聚气",{"1":{"270":6}}],["包括三个",{"1":{"227":1}}],["包括一些静态和概率tile的组合",{"1":{"225":1}}],["包括两边的空间",{"1":{"221":1}}],["包括地图的尺寸",{"1":{"214":1}}],["包括类型和数量",{"1":{"213":1}}],["包括无状态的",{"1":{"159":1}}],["包括基类的",{"1":{"131":1}}],["包括代码节",{"1":{"131":1}}],["包括每种类型的定义",{"1":{"127":1}}],["包括有关加载",{"1":{"127":1}}],["包括观察者",{"1":{"104":3}}],["包括服务器",{"1":{"82":1}}],["包括武器开火等",{"1":{"47":1}}],["包括用来渲染的位置信息",{"1":{"43":1}}],["包括预测的操作",{"1":{"15":1}}],["包做超时校验机制",{"1":{"12":1}}],["他定义了参数",{"1":{"1043":1}}],["他首先是算出predicttargettick然后减去一个插值它是根据网络延迟算出一个tick",{"1":{"1017":1}}],["他继承于scriptobject",{"1":{"972":1}}],["他时把原来的顶点copy多份进行实现的",{"1":{"860":1}}],["他也是通过screen",{"1":{"852":1}}],["他也毁了其他的玩家的游戏",{"1":{"62":1}}],["他是一个具有原子属性的顺序技能",{"1":{"795":1}}],["他是正对着别的玩家开火的",{"1":{"48":1}}],["他默认使用的git是不是全局的",{"1":{"417":1}}],["他这是以六力为表示",{"1":{"374":1}}],["他快领悟出来的时候就帮他换掉",{"1":{"373":1}}],["他不会执行已经执行过的任务",{"1":{"278":1}}],["他会向上下扩充",{"1":{"639":1}}],["他会向下扩充",{"1":{"639":1}}],["他会鉴定出+2职业技能么",{"1":{"270":1}}],["他会按照顺序copy到sharedtilemaps",{"1":{"230":1}}],["他会从github直接拉取而不会经过数据库缓存",{"1":{"144":1}}],["他可以做的更快",{"1":{"737":1}}],["他可以看到1",{"1":{"103":1}}],["他可以把角色放在他想要的任何地方",{"1":{"67":1}}],["他可能在进入掩体后几毫秒被射击",{"1":{"79":1}}],["他永远都很开心",{"1":{"79":1}}],["他按下两次向右按钮后",{"1":{"68":1}}],["他们是通过entity和component进行目标查找的",{"1":{"1045":1}}],["他们是一个封闭系统",{"1":{"45":1}}],["他们也能够进行dynamic",{"1":{"980":1}}],["他们去做相应的同步",{"1":{"803":1}}],["他们的行为由服务端控制",{"1":{"801":1}}],["他们的positioncomponent被添加或替换",{"1":{"741":1}}],["他们为了壮大自身的声势",{"1":{"297":1}}],["他们设坛祭鬼",{"1":{"297":1}}],["他们或为复仇",{"1":{"297":1}}],["他们总在夜间行动",{"1":{"297":1}}],["他们不仅时常骚扰附近的百姓与旅人",{"1":{"297":1}}],["他们都应该从一个表中调用",{"1":{"810":1}}],["他们都作为一个entity",{"1":{"807":1}}],["他们都是从以下12个向量里随机挑选一个作为梯度向量",{"1":{"202":1}}],["他们都位于过去某个时间的位置",{"1":{"46":1}}],["他们在命令执行时间",{"1":{"85":1}}],["他们有权利去选择怎么去玩",{"1":{"62":1}}],["他们只需要专注于得到更多的射击技能来武装他们",{"1":{"48":1}}],["他们说的快照",{"1":{"15":1}}],["他们肯定比我做得好很多",{"1":{"15":1}}],["他们会各自保存100帧的状态快照",{"1":{"15":1}}],["他感觉自己是平滑的",{"1":{"15":1}}],["他的代码和",{"1":{"1054":1}}],["他的扩展名是",{"1":{"972":1}}],["他的意思就是如果ios的垂直同步是每秒60帧",{"1":{"855":1}}],["他的词缀等级应该是",{"1":{"270":1}}],["他的词缀就是51级",{"1":{"270":1}}],["他的魔法等级是3",{"1":{"270":1}}],["他的最低物等",{"1":{"270":1}}],["他的品质等级",{"1":{"270":1}}],["他的对象类型指针指向自己",{"1":{"131":1}}],["他的操作体验",{"1":{"15":1}}],["他的启动目录是c",{"1":{"9":1}}],["他开始广播数据给ab",{"1":{"15":1}}],["可將",{"1":{"978":1}}],["可",{"1":{"978":1}}],["可透過",{"1":{"978":1}}],["可視為畫在畫布",{"1":{"977":1}}],["可視問題",{"1":{"974":1}}],["可參考",{"1":{"975":1}}],["可不管物件算繪順序",{"1":{"974":1}}],["可被选中",{"1":{"971":1}}],["可被忽略的",{"1":{"224":1}}],["可访问的对象",{"1":{"955":1}}],["可达队列freachable",{"1":{"898":1}}],["可达性分析算法",{"0":{"116":1}}],["可调试",{"1":{"836":2}}],["可重复使用的对象池",{"0":{"832":1}}],["可重入的grain可能会看到不同请求交错执行的代码",{"1":{"158":1}}],["可重入的grain代码永远不会并行运行多段grain代码",{"1":{"158":1}}],["可重入的激活体",{"1":{"158":1}}],["可用内存",{"1":{"857":1}}],["可用空间可能会迅速消耗",{"1":{"828":1}}],["可用于从visual",{"1":{"125":1}}],["可查看以下案例",{"1":{"764":1}}],["可直接套用的公式",{"1":{"756":1}}],["可得出旋转后的坐标",{"1":{"756":1}}],["可将",{"1":{"722":1}}],["可在",{"1":{"721":1,"722":1}}],["可见",{"1":{"715":1,"854":1}}],["可是这样构建游戏实在是太痛苦了",{"0":{"945":1}}],["可是",{"1":{"818":1}}],["可是我们在查看代码的时候并没有发生任何改变",{"1":{"717":1}}],["可是轮询也可以是消息驱动",{"1":{"652":1}}],["可是那短短",{"1":{"373":1}}],["可存在于项目范围",{"1":{"524":1}}],["可使用",{"1":{"475":1,"721":1}}],["可选",{"1":{"475":1,"910":1}}],["可作为脚本文件",{"1":{"430":1}}],["可召唤1个图腾",{"1":{"384":1}}],["可拥有5个地雷xvi",{"1":{"384":1}}],["可拥有3个陷阱xv",{"1":{"384":1}}],["可依据炼丹所需药材进行建造",{"1":{"380":1}}],["可视化",{"1":{"208":1}}],["可免费使用",{"1":{"198":1}}],["可到达",{"1":{"124":1}}],["可即刻回收垃圾",{"1":{"115":1}}],["可靠的特点",{"1":{"88":1}}],["可配置的定时任务但是为什么要换hangfire",{"1":{"30":1}}],["可能没有实现对某component",{"1":{"1054":1}}],["可能",{"1":{"960":1}}],["可能在",{"1":{"947":1}}],["可能尝试合并",{"1":{"940":1}}],["可能有点奇怪",{"1":{"938":1}}],["可能就会有三个iresourcelocationenter为key的iresourcelocation",{"1":{"901":1}}],["可能这个算法会有更多优点和不足之处",{"1":{"788":1}}],["可能存在精度不足的问题",{"1":{"753":1}}],["可能是gc噩梦",{"1":{"828":1}}],["可能是我还没有立即好这个接口",{"1":{"657":1}}],["可能是缓存已经被写满",{"1":{"448":1}}],["可能是html中引入的路径是相对路径",{"1":{"399":1}}],["可能包括",{"1":{"287":1}}],["可能包括的其他物品",{"1":{"287":2}}],["可能出现的词缀就越好",{"1":{"269":1}}],["可能我还需要解释一下那五行数据的含义",{"1":{"175":1}}],["可能会在相邻两动画帧之间快速穿越",{"1":{"753":1}}],["可能会导致一个entity被销毁然后又从池子中重新取出来",{"1":{"739":1}}],["可能会导致意外的结果",{"1":{"85":1}}],["可能会出现以下四种情况",{"1":{"449":1}}],["可能会触发不同的逻辑",{"1":{"102":1}}],["可能也是唯一有意义的",{"1":{"62":1}}],["可能带来性能问题",{"1":{"15":1}}],["可能略有不同",{"1":{"15":1}}],["可能导致预测错",{"1":{"15":1}}],["可能预测错误的帧有5帧",{"1":{"15":1}}],["可能客户端只领先2~3帧",{"1":{"15":1}}],["可能a的99帧也是攻击",{"1":{"15":1}}],["可以获得无数个平行的矩形面",{"1":{"1025":1}}],["可以获取到指定",{"1":{"510":1}}],["可以获取到该对象能观察到的所有灯塔",{"1":{"104":1}}],["可以获取当前的",{"1":{"509":1}}],["可以控制服务端和客户端是否添加该组件他会同步ghost",{"1":{"1020":1}}],["可以接收多个光源的shader",{"1":{"980":1}}],["可以接收检测碰撞",{"1":{"684":1}}],["可以说是",{"1":{"969":1}}],["可以一次性完成工作",{"1":{"965":1}}],["可以关联到",{"1":{"964":1}}],["可以让你自由控制conversion",{"1":{"957":1}}],["可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术",{"1":{"72":1}}],["可以清楚地看到",{"1":{"952":1}}],["可以清晰的描述技能流程",{"1":{"795":1}}],["可以忽略掉一些矩阵运算",{"1":{"952":1}}],["可以批量绘制可不是快速的重绘",{"1":{"942":1}}],["可以迭代所有拥有相同",{"1":{"930":1}}],["可以包含的多个实体的数据",{"1":{"905":1}}],["可以提高gc清理的效率",{"1":{"898":1}}],["可以跟踪执行这些分配的方法",{"1":{"878":1}}],["可以batch的ui上下叠在一块不会影响性能",{"1":{"862":1}}],["可以遵循以下思路",{"1":{"861":1}}],["可以去除fill",{"1":{"860":1}}],["可以参考下面的扩展资料",{"1":{"848":1}}],["可以参看源码",{"1":{"713":1}}],["可以参看源码阅读理解",{"1":{"712":1}}],["可以参看",{"1":{"15":1,"652":1}}],["可以得到在存活的实体中",{"1":{"930":1}}],["可以得到以下结果",{"1":{"847":1}}],["可以得到如下的约束规则",{"1":{"209":1}}],["可以快速设置相机视口到当前场景窗口的视口位置",{"1":{"841":1}}],["可以把这个列表非常简单的从这个函数中提出来放入函数所在的类中",{"1":{"817":1}}],["可以把其他线程中的代码切换到主线程中执行来进行调试",{"1":{"815":1}}],["可以把pivot设置在左上角",{"1":{"639":1}}],["可以知道",{"1":{"781":1}}],["可以使原来相撞的两物体彼此弹开",{"1":{"765":1}}],["可以使用localtoworld",{"1":{"1053":1}}],["可以使用blittable类型或者nativecontainer类型",{"1":{"920":1}}],["可以使用shader进行实现",{"1":{"860":1}}],["可以使用screen",{"1":{"859":1}}],["可以使用两个法术场",{"1":{"807":1}}],["可以使用分类的思想解决",{"1":{"800":1}}],["可以使用的情况一般有",{"1":{"701":1}}],["可以使用google提供的bundletool",{"1":{"585":1}}],["可以使用这个模型",{"1":{"568":1}}],["可以使用",{"1":{"508":1,"698":2,"946":1}}],["可以使用时间轮算法触发关键事件",{"1":{"58":1}}],["可以结合linerender来渲染子弹飞过的特效",{"1":{"750":1}}],["可以结合这两种技术",{"1":{"737":1}}],["可以定义各种属性",{"1":{"1042":1}}],["可以定义两个向量作为攻击范围",{"1":{"749":1}}],["可以定为640",{"1":{"103":1}}],["可以移动角色",{"1":{"737":1}}],["可以从github下载案例工程",{"1":{"737":1}}],["可以",{"1":{"718":1}}],["可以静态注入程序集",{"1":{"717":1}}],["可以调用",{"1":{"924":1}}],["可以调用其中类的各自方法",{"1":{"716":1}}],["可以调整带宽和更新频率设置",{"1":{"86":1}}],["可以继续深入研究一下代码",{"1":{"715":1}}],["可以继承",{"1":{"264":1}}],["可以表示为",{"1":{"714":1}}],["可以不是强命名",{"1":{"707":1}}],["可以被所有的",{"1":{"707":1}}],["可以理解为开发模式",{"1":{"703":1}}],["可以理解为生产模式",{"1":{"703":1}}],["可以将上面类的实例传递给字典的构造函数",{"1":{"822":1}}],["可以将不再使用的资源给卸载掉",{"1":{"701":1}}],["可以将ip配置成",{"1":{"550":1}}],["可以打开addressable的分析工具",{"1":{"700":1}}],["可以打开防掉压",{"1":{"551":1}}],["可以考虑开启prebake",{"1":{"868":1}}],["可以考虑将字体直接印在下面的图片上",{"1":{"862":1}}],["可以考虑将webgl构建设置中的",{"1":{"592":1}}],["可以考虑使用一个局部变量来代替常量2",{"1":{"818":1}}],["可以考虑使用addressable进行资源的加载",{"1":{"699":1}}],["可以考虑使用",{"1":{"699":1}}],["可以卸载掉实例化的对象",{"1":{"699":1}}],["可以加入射线加测结果中",{"1":{"693":1}}],["可以设置",{"1":{"689":1}}],["可以设置cl",{"1":{"86":1}}],["可以尝试在unity的主工程中随便写一个static的方法",{"1":{"600":1}}],["可以看成一个有默认大小的数组",{"1":{"937":1}}],["可以看到从开始值不断的改变predictingtick进行预测",{"1":{"1014":1}}],["可以看到他有两个tick",{"1":{"1014":1}}],["可以看到手动实例化了",{"1":{"972":1}}],["可以看到现在",{"1":{"969":1}}],["可以看到",{"1":{"652":1,"943":1,"956":1,"969":1,"971":1}}],["可以看到它围绕着",{"1":{"645":1}}],["可以看看这个目录中产生的文件",{"1":{"592":1}}],["可以看出",{"1":{"688":1}}],["可以看出我们项目依赖的",{"1":{"537":1}}],["可以看出其中的",{"1":{"535":1}}],["可以看出在这两种情况下依然能够保证所生成地图的平衡性",{"1":{"214":1}}],["可以看出来这些问题是和ssl证书有关",{"1":{"135":1}}],["可以禁用应用程序包的生成功能",{"1":{"586":1}}],["可以避免外部程序直接攻击web服务器负载均衡根据请求情况和服务器负载情况",{"1":{"581":1}}],["可以避免任意两个玩家之间的距离过近导致游戏平衡性被破坏",{"1":{"214":1}}],["可以根据项目实际情况搭配使用",{"1":{"578":1}}],["可以针对用户请求",{"1":{"573":1}}],["可以先退出账号试试",{"1":{"562":1}}],["可以长期信赖的稳定服务器",{"0":{"528":1}}],["可以直接对组的更改做出反应",{"1":{"744":1}}],["可以直接调用system",{"1":{"714":1}}],["可以直接得到对应的gameobject",{"1":{"699":1}}],["可以直接设置其对自己产生的事件的handler",{"1":{"657":1}}],["可以直接由反向代理处理",{"1":{"581":1}}],["可以直接使用命令行2",{"1":{"524":1}}],["可以直接跳到1000帧",{"1":{"15":1}}],["可以查看",{"1":{"523":1}}],["可以查看某个命令的path",{"1":{"424":1}}],["可以执行以下命令查看服务的状态",{"1":{"475":1}}],["可以由用户手动触发",{"1":{"457":1}}],["可以对应于游戏世界中的点相对于某个截面的位置",{"1":{"1025":1}}],["可以对",{"1":{"438":1}}],["可以自行查阅相关信息",{"1":{"767":1}}],["可以自己查阅api",{"1":{"750":1}}],["可以自己添加",{"1":{"739":1}}],["可以自定义存放密码的文件路径",{"1":{"413":1}}],["可以自由的创建地图",{"1":{"217":1}}],["可以生产衣服",{"1":{"380":1}}],["可以增加他们对门派的忠诚度",{"1":{"380":1}}],["可以拿之前的房屋和树进行组合",{"1":{"287":1}}],["可以同时存在",{"1":{"285":1}}],["可以构成一个新动作conditionbase",{"1":{"284":1}}],["可以当门派帮主之类的有额外加成",{"1":{"393":1}}],["可以当作if来看",{"1":{"282":1}}],["可以当做gc",{"1":{"116":1}}],["可以进入掉落判定阶段",{"1":{"275":1}}],["可以进一步减少a和b的预测错误率",{"1":{"15":1}}],["可以穿过的走廊",{"1":{"225":1}}],["可以添加元素",{"1":{"221":1}}],["可以更好的模拟自然界中的地形分布与地表装饰物分布",{"1":{"214":1}}],["可以更好地理解上图数据的含义",{"1":{"175":1}}],["可以稍加修改以便适应这种泛型类",{"1":{"176":1}}],["可以极大的提高服务器的吞吐量",{"1":{"170":1}}],["可以详细阅读源代码",{"1":{"170":1}}],["可以在截帧工具比如xcode或者snapdragon上看到",{"1":{"984":1}}],["可以在子线程中处理数据",{"1":{"916":1}}],["可以在人物前面放置一个大小合适trigger当做攻击范围",{"1":{"748":1}}],["可以在z轴移动主相机",{"1":{"737":1}}],["可以在简单的平铺背景之上加入一些其他背景精灵元素",{"1":{"732":1}}],["可以在unity主工程中得到输出",{"1":{"716":1}}],["可以在unity工程中直接调用来实现对热更新dll中类的方法的调用",{"1":{"715":1}}],["可以在打包的时候合",{"1":{"703":1}}],["可以在避免锁的情况下",{"1":{"455":1}}],["可以在",{"1":{"411":1,"601":1}}],["可以在上一个请求尚未完成处理的情况下",{"1":{"158":1}}],["可以在任何受支持的基础结构上进行",{"1":{"127":1}}],["可以在任何时间回滚到老版本",{"1":{"88":1}}],["可以在任意角度作用不现实的加速度",{"1":{"46":1}}],["可以充分利用这些附加指令集进行编译",{"1":{"130":1}}],["可以事先将",{"1":{"130":1}}],["可以编译您的c",{"1":{"125":1}}],["可以采用标记",{"1":{"122":1}}],["可以用流程图表示这四种情况",{"1":{"449":1}}],["可以用来处理比较复杂的情况",{"1":{"916":1}}],["可以用来进行武器的制造和升级",{"1":{"300":1}}],["可以用来创建当前对象的拷贝",{"1":{"111":1}}],["可以用一个滑动窗口完成这项工作",{"1":{"43":1}}],["可以想象成一个十字架",{"1":{"105":1}}],["可以为每个服务节点增加三个虚拟节点",{"1":{"96":1}}],["可以通过shader",{"1":{"1032":1}}],["可以通过实现",{"1":{"927":1}}],["可以通过",{"1":{"901":1,"937":1,"938":1}}],["可以通过framedebugger来查看drawcall",{"1":{"877":1}}],["可以通过触发器也可以遍历你的敌人列表",{"1":{"749":1}}],["可以通过vector3",{"1":{"749":1}}],["可以通过其实现aop等高级功能unity的代码在修改之后会自动编译到library",{"1":{"717":1}}],["可以通过设置环境变量的方式解决",{"1":{"526":1}}],["可以通过启动一个",{"1":{"474":1}}],["可以通过负载均衡器指向快速回滚到绿色环境",{"1":{"88":1}}],["可以通过调整网络设置以获得更好的体验",{"1":{"82":1}}],["可以适用大多数客户机",{"1":{"86":1}}],["可以注入",{"1":{"85":1}}],["可以帮助大家更方便的理解相关概念",{"1":{"81":1}}],["可以方便地以内存快照的方式来做",{"1":{"15":1}}],["可以动态调整",{"1":{"15":1}}],["可以这样理解",{"1":{"15":1}}],["或稱為",{"1":{"974":1}}],["或monobehaviour",{"1":{"964":1}}],["或许得等",{"1":{"965":1}}],["或许你也想通过",{"1":{"964":1}}],["或许你过去常常使用一种",{"1":{"955":1}}],["或许可以去掉非必须的步骤比如",{"1":{"942":1}}],["或多或少负责跟踪程序对象或数据",{"1":{"879":1}}],["或多或少负责跟踪正在程序中运行的代码",{"1":{"879":1}}],["或使用",{"1":{"878":1}}],["或使用beginthreadprofiling这个api来在profiler的timeline选项卡中来显示样本",{"1":{"815":1}}],["或使用bundletool",{"1":{"586":1}}],["或简称gc",{"1":{"827":1}}],["或空间哈希映射",{"1":{"767":1}}],["或execute时不能直接依赖collector的收集条件",{"1":{"739":1}}],["或为空",{"1":{"524":1}}],["或为奸恶目的",{"1":{"297":1}}],["或仍有提供的最接近版本",{"1":{"477":1}}],["或更高版本重新安装",{"1":{"477":1}}],["或新的",{"1":{"449":1}}],["或是",{"1":{"975":2}}],["或是隐式",{"1":{"819":1}}],["或是撰写出武功秘籍",{"1":{"380":1}}],["或是练武3领悟2种田3工作2",{"1":{"375":1}}],["或是当你用赫拉迪克方块合成新的物品时",{"1":{"270":1}}],["或是当人物把物品从商人那里买下来时",{"1":{"270":1}}],["或是当人物离开城镇导致商店里的商品更新时",{"1":{"270":1}}],["或",{"1":{"153":1,"446":1,"449":1,"524":2,"526":1,"577":1,"657":1,"726":1,"864":1,"884":1,"952":1,"955":1}}],["或特定于平台的类库",{"1":{"129":1}}],["或本机代码以及元数据的这种文件格式使操作系统能够识别公共语言运行时映像",{"1":{"127":1}}],["或代码模块",{"1":{"125":1}}],["或客户端的网络处理能力",{"1":{"86":1}}],["或rtt",{"1":{"82":1}}],["或其他值",{"1":{"50":1}}],["或者移除a组件的时候",{"1":{"987":1}}],["或者双击",{"1":{"971":1}}],["或者创建更多的",{"1":{"950":1}}],["或者使用",{"1":{"942":1,"971":1}}],["或者其他未指定",{"1":{"960":1}}],["或者其他常见的值类型来说",{"1":{"938":1}}],["或者其他更优化的预测方案",{"1":{"15":1}}],["或者改变",{"1":{"929":1}}],["或者您想要处理的实体的块",{"1":{"912":1}}],["或者模型顶点数要尽可能少",{"1":{"876":1}}],["或者相对于z值不会又任何变化的元素",{"1":{"872":1}}],["或者手机上的触摸反馈",{"1":{"841":1}}],["或者把手机屏幕的二维坐标系转化成游戏世界中的三维坐标系等",{"1":{"840":1}}],["或者所有断点",{"1":{"837":1}}],["或者它们是现在超出范围的局部变量",{"1":{"827":1}}],["或者用debug",{"1":{"751":1}}],["或者一定距离后就会返回",{"1":{"750":1}}],["或者碰到指定laymask层的物体",{"1":{"750":1}}],["或者触发器在目标内",{"1":{"748":1}}],["或者可以改变主相机的正交尺寸",{"1":{"737":1}}],["或者可以自己想象",{"1":{"287":1}}],["或者堆",{"1":{"709":1}}],["或者换个句式讲",{"1":{"709":1}}],["或者clone",{"1":{"707":1}}],["或者不包含",{"1":{"691":1}}],["或者不要在onactivateasync中registertimer",{"1":{"161":1}}],["或者我们要自己魔改一个组件出来都可以通过看源码来进行解决",{"1":{"682":1}}],["或者monobehavior所在的gameobject存在guielement",{"1":{"652":1}}],["或者transform",{"1":{"640":1}}],["或者无法通过此帐号使用",{"0":{"611":1}}],["或者声明序列化字段网络协议json",{"1":{"598":1}}],["或者继续加电压",{"1":{"551":1}}],["或者在组件上添加",{"1":{"1054":1}}],["或者在",{"1":{"975":1}}],["或者在相关组件被添加或者被删除的时候",{"1":{"932":1}}],["或者在生成静态网页时",{"1":{"507":1}}],["或者在你的游戏中玩家朝一个方向跑的时候可以看到别的方向",{"1":{"48":1}}],["或者打开新场景时使用",{"1":{"698":1}}],["或者打开",{"1":{"490":1}}],["或者由操作系统触发",{"1":{"451":1}}],["或者定期保存操作被执行",{"1":{"448":1}}],["或者事件处理器被执行时",{"1":{"446":1}}],["或者直接打开",{"1":{"407":1}}],["或者直接缩写为",{"1":{"199":1}}],["或者作为连续跳的点",{"1":{"287":1}}],["或者背景有水",{"1":{"287":1}}],["或者底部有水",{"1":{"287":1}}],["或者有瀑布",{"1":{"287":1}}],["或者说着色器生成的材质",{"1":{"847":1}}],["或者说在基础逻辑中没有技能的设计",{"1":{"811":1}}],["或者说",{"1":{"286":1}}],["或者说gc过程开始时",{"1":{"121":1}}],["或者经过另一种",{"1":{"273":1}}],["或者发送邮件提示之类的",{"1":{"252":1}}],["或者为空",{"1":{"225":1}}],["或者7",{"1":{"224":1}}],["或者从一个有趣的角度去看如何解决一个问题",{"1":{"222":1}}],["或者从性能上看通过",{"1":{"180":1}}],["或者",{"1":{"152":1,"225":1,"270":1,"287":1,"465":1,"509":1,"559":1,"687":2,"694":1,"697":1,"698":1,"737":1,"858":1,"947":1,"965":1,"970":2,"982":1,"1003":1,"1037":1}}],["或者清空缓存",{"1":{"146":1}}],["或者是一个能左右扳动的开关",{"1":{"287":1}}],["或者是砖块",{"1":{"225":2}}],["或者是其它相同处理器或者几乎一样处理器的计算机上",{"1":{"127":1}}],["或者是电磁波",{"1":{"64":1}}],["或者每10ms发送一次",{"1":{"76":1}}],["或者向右或向左转了一点",{"1":{"75":1}}],["或者减速器",{"1":{"51":1}}],["或者如果起始点与目标点距离过长",{"1":{"46":1}}],["或者正在碰地板",{"1":{"46":1}}],["或者上一帧渲染位置",{"1":{"46":1}}],["或者进入主动怪物的视野范围内时",{"1":{"19":1}}],["或者激怒怪物的操作后",{"1":{"17":1}}],["或提前",{"1":{"15":1}}],["攻击速度等",{"1":{"809":1}}],["攻击子技能有一个condition过程",{"1":{"795":1}}],["攻击范围应该是竖着的一条线",{"1":{"750":1}}],["攻击范围是可以确定的",{"1":{"749":1}}],["攻击类型多样",{"1":{"750":1}}],["攻击加成",{"1":{"394":1}}],["攻击躲避几率xi",{"1":{"384":1}}],["攻击动作",{"0":{"243":1}}],["攻击的判断完全由锁定怪物ai的客户端进行处理",{"1":{"19":1}}],["攻击",{"1":{"15":1,"378":2,"381":1}}],["b站圈毛君翻译教程",{"0":{"1026":1}}],["b也将被纳入层级的事实",{"1":{"952":1}}],["b状态挂不上去",{"1":{"800":1}}],["b|",{"1":{"781":1}}],["b等于单位向量",{"1":{"780":1}}],["bgsave",{"1":{"456":1}}],["bgrewriteaof",{"1":{"455":1,"456":2}}],["bc",{"1":{"287":3}}],["b1",{"1":{"287":4}}],["bind",{"1":{"719":1}}],["binding",{"0":{"705":1}}],["binaryreaderthese",{"1":{"190":1}}],["binaryreader",{"0":{"190":1},"2":{"191":1,"192":1}}],["binarywriter",{"0":{"190":1},"1":{"190":1},"2":{"191":1,"192":1}}],["binaryformatter",{"0":{"188":1},"1":{"188":1,"189":1},"2":{"189":1,"190":1,"191":1,"192":1,"193":1,"194":1,"195":1,"196":1}}],["binary",{"1":{"187":1,"188":1,"195":7}}],["billing",{"1":{"615":1}}],["bilibili",{"0":{"1027":1,"1028":1,"1029":1,"1030":1},"1":{"385":1,"864":1,"899":1}}],["bitbucketbitbucket",{"1":{"666":1}}],["bit",{"1":{"202":1,"567":1}}],["bigger",{"1":{"644":1}}],["big",{"1":{"28":2,"32":2,"33":3}}],["brush",{"0":{"1029":1}}],["bridge",{"1":{"1005":1}}],["brings",{"1":{"26":1}}],["brtrue",{"1":{"823":1}}],["br",{"1":{"823":1}}],["branch",{"1":{"594":1}}],["brewfile",{"0":{"481":1},"1":{"481":2}}],["brevity",{"1":{"193":1}}],["broad",{"0":{"767":1},"1":{"766":1,"767":1}}],["broadcastmessage",{"1":{"660":1}}],["browser",{"1":{"181":1,"544":1}}],["brookshi",{"1":{"131":1}}],["b被c和a引了",{"1":{"124":1}}],["bouncing",{"1":{"940":1,"968":1}}],["bounding",{"0":{"753":1}}],["bounds",{"1":{"592":1}}],["bound",{"1":{"192":1}}],["boehm",{"1":{"591":1,"813":1,"857":1}}],["boehm算法采用标记清除法",{"1":{"123":1}}],["box",{"0":{"753":1},"1":{"405":1,"821":4,"823":1}}],["boxed",{"1":{"189":1}}],["boss会执行一个攻击子技能",{"1":{"795":1}}],["boss怪物87级",{"1":{"265":1}}],["boss",{"1":{"254":1,"266":1,"950":1}}],["boss攻击的延迟补偿",{"0":{"58":1}}],["boristhebrave",{"1":{"211":1}}],["bottom",{"1":{"633":1,"636":2,"637":1}}],["bottleneck",{"1":{"195":1}}],["both",{"1":{"90":2,"188":1,"189":1,"192":1,"193":1,"283":5,"486":1}}],["book",{"1":{"423":1,"506":1}}],["bookstore",{"1":{"184":1}}],["bookstack",{"1":{"103":1}}],["booleans",{"1":{"190":1}}],["bool",{"1":{"131":2,"822":1,"823":1,"864":1,"881":1}}],["blend混合处理",{"1":{"1032":1}}],["blinking",{"1":{"955":1}}],["blockingobjects",{"1":{"689":3}}],["blocked",{"0":{"689":2},"1":{"689":4,"694":2}}],["block本身也会由一些概率tile组成",{"1":{"225":1}}],["block由",{"1":{"225":1}}],["block",{"1":{"193":1,"225":2,"689":1}}],["blobassetstore",{"1":{"970":1}}],["blobassetstore我猜测是当你需要产生某些有blobassetreference字段的component时需要用到的东西",{"1":{"970":1}}],["blob",{"1":{"147":1}}],["blogs",{"1":{"606":1,"737":1}}],["blogread",{"1":{"225":1}}],["blog",{"1":{"15":1,"132":1,"133":1,"607":1,"850":3,"941":1,"984":1}}],["blue",{"0":{"88":1,"647":1,"649":1},"1":{"90":6}}],["bug",{"1":{"984":1,"1038":1}}],["bug修复等",{"1":{"88":1}}],["burst",{"1":{"940":1,"955":1,"957":1}}],["buff可能修改单位属性",{"1":{"809":1}}],["buff是附加在unit身上的东西",{"1":{"808":1}}],["buff同步",{"0":{"808":1}}],["buff",{"1":{"806":1,"809":1}}],["buff结算",{"1":{"802":1}}],["buff模块有个需要注意的是buff之间的相互关系",{"1":{"800":1}}],["buff就是挂在单位身上持续一定时间的有益或者有害的状态",{"1":{"800":1}}],["buff就是挂在单位身上的一个具有持续时间的状态",{"1":{"799":1}}],["buff状态",{"0":{"800":1},"2":{"801":1}}],["buff之间的功能界定并不是很固定",{"1":{"799":1}}],["buffer的大小要严格限制",{"1":{"981":1}}],["buffer数据在构建的大index",{"1":{"979":1}}],["buffer中的起始及结束位置",{"1":{"979":1}}],["buffer中",{"1":{"979":2}}],["buffer和index",{"1":{"979":2}}],["buffering",{"0":{"974":2},"1":{"974":2,"975":1,"978":1}}],["buffers",{"0":{"937":1},"1":{"937":1,"984":1},"2":{"938":1}}],["buffer",{"1":{"186":1,"188":1,"908":1,"937":1,"958":5,"959":2,"960":1,"965":1,"974":6,"975":2,"978":1,"979":2,"981":1,"982":3,"984":1,"1001":5,"1002":2,"1003":1}}],["bundles",{"1":{"586":1}}],["bundle",{"0":{"537":1},"1":{"534":1,"536":1,"537":6,"585":1,"587":1}}],["bundle你首先需要在之前的电脑中执行",{"1":{"481":1}}],["buildplayeroptions",{"1":{"973":1}}],["buildplayer",{"1":{"973":1}}],["buildplayerstep",{"0":{"973":1}}],["buildpipeline",{"1":{"973":1}}],["buildconfiguration",{"0":{"972":1},"1":{"972":1}}],["build后",{"1":{"704":1}}],["build到底干了什么",{"0":{"704":1}}],["builds",{"1":{"703":2}}],["buildtools",{"1":{"591":1}}],["build目录内",{"1":{"590":1}}],["builder",{"1":{"136":1,"535":1}}],["build",{"0":{"705":1},"1":{"125":1,"439":1,"535":1,"585":3,"705":1,"979":1,"998":2}}],["built",{"1":{"25":1,"26":1}}],["bullet",{"1":{"88":1}}],["button",{"1":{"956":1}}],["buttons这个字段包含一个或多个比特",{"1":{"42":1}}],["but",{"1":{"22":1,"26":1,"27":1,"90":1,"191":2,"195":1,"488":1,"984":1}}],["buckets",{"1":{"427":1}}],["bucket",{"0":{"12":1},"1":{"12":7,"427":1}}],["batcher与gpu",{"0":{"983":1}}],["batcher不会降低draw",{"1":{"982":1}}],["batcher的本质并不会降低draw",{"1":{"982":1}}],["batcher的情况下",{"1":{"982":1}}],["batcher加速",{"1":{"982":1}}],["batcher",{"0":{"982":1},"1":{"984":1}}],["batchers",{"1":{"952":1}}],["batched",{"1":{"980":1}}],["batches",{"1":{"877":1,"941":2}}],["batchrenderergroup",{"1":{"941":3}}],["batching的机会",{"1":{"980":1}}],["batching的原理也很简单",{"1":{"980":1}}],["batching更加高效",{"1":{"980":1}}],["batching在这一点要比dynamic",{"1":{"980":1}}],["batching在降低draw",{"1":{"980":1}}],["batching会带来一些运行时cpu性能消耗",{"1":{"980":1}}],["batching会导致应用打包之后体积增大",{"1":{"979":1}}],["batching不需要预先复制模型顶点",{"1":{"980":1}}],["batching相对于static",{"1":{"980":1}}],["batching很可能不能获得性能提升",{"1":{"980":1}}],["batching才会有意义",{"1":{"980":1}}],["batching只能处理一些小模型",{"1":{"980":1}}],["batching也会带来一些性能的负面影响",{"1":{"979":1}}],["batching并",{"1":{"979":1}}],["batching",{"1":{"877":1,"940":2,"941":1,"952":1,"979":2,"980":3,"984":1}}],["bat就可以了查看所有命令",{"1":{"746":1}}],["bat",{"1":{"746":1}}],["ba2",{"1":{"287":1}}],["ba3",{"1":{"287":1}}],["ba1",{"1":{"287":1}}],["bandwidth",{"1":{"189":1}}],["backend",{"1":{"585":1,"720":1}}],["back",{"1":{"188":1,"191":1,"192":1,"193":1,"489":1}}],["backgroundparallax",{"1":{"736":1}}],["background",{"1":{"22":6,"24":1,"27":3,"29":1,"737":1,"1036":1}}],["bash",{"1":{"474":1,"500":1}}],["basically",{"1":{"489":1}}],["basic",{"0":{"1027":1},"1":{"127":1,"651":1}}],["basics",{"1":{"22":1}}],["basetype",{"1":{"714":1}}],["baseraycaster",{"0":{"683":1},"1":{"683":4,"684":1,"687":1}}],["baseraycaster负责确定目标对象",{"1":{"654":1}}],["baseraycaster也是一个基类",{"1":{"654":1}}],["baseinputmodule负责输入",{"1":{"654":1}}],["baseinputmodule是一个基类模块",{"1":{"654":1}}],["base的平台游戏中",{"1":{"225":1}}],["base",{"0":{"484":1},"1":{"27":1,"484":1,"568":1}}],["based",{"1":{"22":2,"186":1,"571":1,"662":1,"851":1}}],["benzzzx和",{"1":{"931":1}}],["beginthreadprofiling",{"1":{"878":1}}],["beta版本的渠道",{"1":{"615":1}}],["betazhong",{"1":{"587":1}}],["between",{"1":{"26":1,"187":2,"188":1,"193":2,"196":1,"486":1,"644":1,"1005":1}}],["becomes",{"1":{"489":1}}],["because",{"1":{"25":1,"181":1,"186":1,"487":1,"571":2}}],["before",{"1":{"189":1,"193":1,"949":1}}],["behaviour",{"1":{"187":1}}],["bestpracticeunderstandingperformanceinunity4",{"1":{"825":1}}],["bestpoker",{"1":{"104":1}}],["best",{"0":{"997":1},"1":{"29":1,"162":1,"195":1,"196":1,"214":1,"863":1,"1005":1}}],["below",{"1":{"27":1,"183":1,"485":1}}],["being",{"1":{"25":1,"486":1,"489":1}}],["be",{"1":{"22":1,"23":1,"26":2,"27":1,"90":1,"131":1,"186":4,"187":1,"188":1,"189":2,"190":1,"191":1,"193":2,"195":1,"196":1,"287":4,"484":1,"487":1,"488":3,"489":1,"571":2,"662":1,"980":1}}],["bytecodestripping",{"1":{"606":1}}],["bytes",{"1":{"189":2,"190":1,"193":1,"708":1,"960":2}}],["byte",{"0":{"186":1},"1":{"82":1,"186":1,"187":1,"188":3,"189":3,"193":2,"194":1,"195":5,"196":1,"489":2,"708":1,"881":1}}],["by",{"1":{"15":1,"22":2,"25":3,"26":1,"27":2,"181":1,"187":1,"191":2,"193":1,"195":1,"196":1,"197":1,"427":1,"489":1,"585":1,"877":1,"998":1}}],["b的操作手感良好",{"1":{"15":1}}],["b的感受是很好的",{"1":{"15":1}}],["b的感受是不会有太大区别的",{"1":{"15":1}}],["b的消息",{"1":{"15":1}}],["b可能在100帧不会击中a",{"1":{"15":1}}],["b因为延迟",{"1":{"15":1}}],["b就回滚到上一个确认一样的帧",{"1":{"15":1}}],["b预测的是攻击",{"1":{"15":1}}],["b对a的预测",{"1":{"15":1}}],["b来到了103帧",{"1":{"15":1}}],["b执行了攻击",{"1":{"15":1}}],["b",{"0":{"19":1,"635":1},"1":{"15":3,"92":1,"124":2,"384":1,"567":1,"633":1,"756":2,"771":2,"780":3,"781":2,"822":1,"903":3,"952":4,"980":1,"984":2,"987":1}}],["我觉得有几点应该记录下来",{"1":{"997":1}}],["我猜想",{"1":{"971":1}}],["我得到了一个正常支持",{"1":{"969":1}}],["我得到了一个正确转换且拥有纯粹ecs数据后的方块",{"1":{"951":1}}],["我继续使用前面说到的魔法",{"1":{"969":1}}],["我没有增加太多非",{"1":{"969":1}}],["我没试过",{"1":{"420":1}}],["我试着",{"1":{"956":1}}],["我依然会得到",{"1":{"954":1}}],["我像之前一样正常得到了",{"1":{"954":1}}],["我有",{"1":{"954":1}}],["我有一块地",{"1":{"288":1}}],["我有一件地狱a1冰冷之原掉的装备",{"1":{"270":1}}],["我会得到两个",{"1":{"966":1}}],["我会得到渲染在同一位置的两个方块",{"1":{"954":1}}],["我会得到这些ecs的",{"1":{"951":1}}],["我会将自己在开发一款名为",{"1":{"217":1}}],["我假设你已经知道了",{"1":{"946":1}}],["我之所以之前介绍",{"1":{"946":1}}],["我同时添加了",{"1":{"944":1}}],["我现在已经在使用ecs并且我有3个",{"1":{"941":1}}],["我举个例子",{"1":{"841":1}}],["我个人的经验",{"1":{"810":1}}],["我上篇文章",{"1":{"805":1}}],["我用这些代码作为编写自己代码的基础",{"1":{"789":1}}],["我深表歉意",{"1":{"789":1}}],["我绝不是数学方面的专家",{"1":{"789":1}}],["我绝不是这个方面的专家",{"1":{"782":1}}],["我已经在",{"1":{"969":1}}],["我已经尽可能地不提供过多的信息并讲解得十分简明了",{"1":{"789":1}}],["我已经执行到100帧",{"1":{"15":1}}],["我希望这篇文章能帮助你了解到分离轴定理算法",{"1":{"789":1}}],["我希望它对你有用",{"1":{"222":1}}],["我所听到过分离轴定理的最好类比方式是这样的",{"1":{"783":1}}],["我还在下文引入了一个使用分离轴定理实现的demo",{"1":{"782":1}}],["我可费了不少功夫",{"1":{"782":1}}],["我碰巧地遇到了一个叫",{"1":{"782":1}}],["我应该把我所学到的分享给大家",{"1":{"782":1}}],["我应该是拿起我的斧头",{"1":{"219":1}}],["我做了大量的阅读并最终在actionscript",{"1":{"782":1}}],["我做得比较早了",{"1":{"15":1}}],["我要做攻击判定的话",{"1":{"748":1}}],["我要强调的一点是",{"1":{"15":1}}],["我和我的同事jaroslav",{"1":{"737":1}}],["我想要的结果粒子随着飞船能上下弹跳",{"1":{"968":1}}],["我想要用",{"1":{"955":1}}],["我想我会使用",{"1":{"943":1}}],["我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍",{"1":{"782":1}}],["我想",{"1":{"782":1}}],["我想介绍最简单的设置",{"1":{"737":1}}],["我想到的方法是动态的加载assembly",{"1":{"707":1}}],["我想指出il2cpp有一向挑战我们没有接受",{"1":{"593":1}}],["我挂载在相机上",{"1":{"663":1}}],["我这里只需要对physics2d检测",{"1":{"663":1}}],["我改变gameview的分辨率为800",{"1":{"625":1}}],["我对锚点定义为",{"1":{"625":1}}],["我只是这么一说",{"1":{"594":1}}],["我给你什么",{"1":{"573":1}}],["我测试的仓库地址是",{"1":{"510":1}}],["我就可以获取prefab在",{"1":{"966":1}}],["我就可以在剑上挂一个触发器",{"1":{"748":1}}],["我就能得到",{"1":{"962":1}}],["我就是这么做的",{"1":{"562":1}}],["我就以我自己的使用经验分享给大家",{"1":{"553":1}}],["我就在想如果能用",{"1":{"510":1}}],["我就不一一介绍了",{"1":{"15":1}}],["我当初就是没看中这个",{"1":{"376":1}}],["我自己写了一个随机方法来决定建造哪一种元素",{"1":{"220":1}}],["我发现",{"1":{"220":1}}],["我并不会将我的地下城建造成一个一个看起来不错的小房间",{"1":{"219":1}}],["我尝试了很多种不同的算法来生成地图",{"1":{"219":1}}],["我尝试举个例子说明下",{"1":{"15":1}}],["我愿意将它分享给大家",{"1":{"217":1}}],["我怀疑这可能只能算是一个原型",{"1":{"217":1}}],["我建立了一颗树来记录搜索的路径",{"1":{"210":1}}],["我时常认为ken",{"1":{"202":1}}],["我该如何查找周围玩家呢",{"1":{"107":1}}],["我订阅某一块区域表示对这一块区域感兴趣",{"1":{"104":1}}],["我选用了一些比较特例的数字来让所有事情看起都很完美",{"1":{"68":1}}],["我按下了向右的按键",{"1":{"64":1}}],["我在这个页面上学到了很多",{"1":{"789":1}}],["我在",{"1":{"63":2,"176":1}}],["我在x位置",{"1":{"45":1}}],["我爆了玩家2的脑袋",{"1":{"45":1}}],["我见到的都是用",{"1":{"33":1}}],["我后续做的很多优化",{"1":{"15":1}}],["我早",{"1":{"15":1}}],["我的微信号是",{"1":{"983":1}}],["我的另一篇文章有详解",{"1":{"979":1,"980":1,"981":1,"982":1}}],["我的",{"1":{"943":1}}],["我的灵感来自于此",{"1":{"219":1}}],["我的算法版本跟zucker的版本会有些不同",{"1":{"197":1}}],["我的思路是",{"1":{"15":1}}],["我的战斗也没有基于ecs",{"1":{"15":1}}],["我的操作是移动",{"1":{"15":1}}],["我看过他开源的demo",{"1":{"15":1}}],["我们也可以主动设置这个值为某一种",{"1":{"1037":1}}],["我们也可以使用msbuild",{"1":{"125":1}}],["我们也就将屏幕坐标转换为了世界坐标",{"1":{"1025":1}}],["我们新建一个场景查看分析器",{"1":{"1000":1}}],["我们别无选择",{"1":{"981":1}}],["我们自动获取到了名为",{"1":{"967":1}}],["我们当然可以创建gameobjectconversionsystem来完成相同的工作",{"1":{"967":1}}],["我们期望我们人工添加的",{"1":{"965":1,"1003":1}}],["我们无法获取到linkedentitygroup",{"1":{"965":1}}],["我们无法确定",{"1":{"89":1}}],["我们永远得关注数据本身",{"1":{"952":1}}],["我们更希望得到更优的基于",{"1":{"947":1}}],["我们想要运行时的",{"1":{"945":1}}],["我们修改其中一个实体的",{"1":{"929":1}}],["我们开始进行下一阶段",{"1":{"898":1}}],["我们开始编写柏林噪声函数",{"1":{"199":1}}],["我们保留电脑就不能扔掉显示器键盘鼠标",{"1":{"898":1}}],["我们保留电视就不要扔掉电视遥控器",{"1":{"898":1}}],["我们让dude类实现iconeable代替使用copydude",{"1":{"897":1}}],["我们是希望克隆引用类型并复制值类型的",{"1":{"897":1}}],["我们是以字节为单位的",{"1":{"33":1}}],["我们直接使用color",{"1":{"896":1}}],["我们直接使用即可",{"1":{"896":1}}],["我们创建了一个新的shoe",{"1":{"896":1}}],["我们创建一个有子集的",{"1":{"737":1}}],["我们并没有复制指针真正对应的对象",{"1":{"896":1}}],["我们并不具体的使用指针",{"1":{"883":1}}],["我们用如下系统来玩一玩",{"1":{"969":1}}],["我们用pvalue改变myint的myvalue的值时",{"1":{"892":1}}],["我们用上面的方法计算目标时间",{"1":{"46":1}}],["我们怎么才能回避这样的问题呢",{"1":{"891":1}}],["我们叫它栈结构stack",{"1":{"890":1}}],["我们得到",{"1":{"955":1}}],["我们得到了期望的结果",{"1":{"895":1,"896":1}}],["我们得到的值是４而不是３",{"1":{"889":1}}],["我们得出了8个顶点的影响值",{"1":{"203":1}}],["我们定义一个引用类型",{"1":{"887":1}}],["我们定义它是一个引用类型",{"1":{"883":1}}],["我们主要有4种类型的东西放进堆和栈里",{"1":{"880":1}}],["我们希望做到drawcall尽可能少",{"1":{"861":1}}],["我们认识到",{"1":{"854":1}}],["我们",{"1":{"841":1}}],["我们简单的进行",{"1":{"841":1}}],["我们简短地描述了三种",{"1":{"451":1}}],["我们则建议研发团队可以将一些长时间不需要改动的脚本代码",{"1":{"839":1}}],["我们强烈的建议所有开发者当项目在交互状态时最小化托管堆内存分配",{"1":{"815":1}}],["我们游戏使用的是技能树来管理技能流程",{"1":{"805":1}}],["我们游戏仅保存一个新的技能调用信息",{"1":{"793":1}}],["我们优化了法术场结算的实现机制",{"1":{"801":1}}],["我们项目引入一个技能树概念来描述这种数据结构",{"1":{"794":1}}],["我们设",{"1":{"756":1}}],["我们设计了一套地图自动扩张算法",{"1":{"215":1}}],["我们不能滥用",{"1":{"929":1}}],["我们不想扔掉那些程序线程始终需要的对象",{"1":{"898":1}}],["我们不需要指定当一个entity何时应当被收集的事件",{"1":{"742":1}}],["我们不会真的删除或者添加一个component",{"1":{"739":1,"744":1}}],["我们不可以稍后更改它",{"1":{"737":1}}],["我们显示所有摄像机的渲染纹理",{"1":{"737":1}}],["我们肯定会用这个设置",{"1":{"737":1}}],["我们没有意识到那些并在视差设置中出现一些错误",{"1":{"737":1}}],["我们没有尝试重写整个c",{"1":{"593":1}}],["我们依然不需要移动背景取景区域",{"1":{"727":1}}],["我们区域采样的方式就是通过",{"1":{"726":1}}],["我们有一个接口可以帮我们实现",{"1":{"896":1}}],["我们有一个copydude",{"1":{"895":1}}],["我们有一个类thing",{"1":{"893":1}}],["我们有成千上万个buff状态",{"1":{"800":1}}],["我们有四种常规方式可以实现背景的滚动",{"1":{"725":1}}],["我们有由两个文件组成的一个列表和一个目录在这个长长的命令行中",{"1":{"592":1}}],["我们发现在输出原来的语句之前多了一句",{"1":{"717":1}}],["我们首先要构建多层背景",{"1":{"734":1}}],["我们首先使用背景精灵拼接出背景取景区域覆盖到的背景区域",{"1":{"727":1}}],["我们首先将我们所需要的函数导入",{"1":{"717":1}}],["我们首先看",{"1":{"717":1}}],["我们首先来看下这两个定义",{"1":{"163":1}}],["我们最终回到了文章二中对于il虚拟机中的tableheap的引用",{"1":{"714":1}}],["我们最终选用米切尔最佳候选",{"1":{"214":1}}],["我们后续会讨论到",{"1":{"708":1}}],["我们运行一个",{"1":{"707":1}}],["我们都无法得到prefab或linkedentitygroup",{"1":{"964":1}}],["我们都知道",{"1":{"667":1}}],["我们都会调用定义在optionsservicecollectionextensions类上的扩展方法addoptions",{"1":{"173":1}}],["我们看下ghostupdatesystem预测使用的是predictedtargettick",{"1":{"1016":1}}],["我们看下安卓建立的配置",{"1":{"972":1}}],["我们看这句",{"1":{"852":1}}],["我们看看其中的实现",{"1":{"679":1}}],["我们看一下值类型",{"1":{"895":1}}],["我们看一下获取eventlist的规则",{"1":{"678":1}}],["我们看一个官方文档的说明",{"1":{"662":1}}],["我们看到他的最终执行仍然使用了api",{"1":{"973":1}}],["我们看到",{"1":{"170":1,"680":1}}],["我们看到字符发生了改变",{"1":{"147":1}}],["我们看到服务器不会再等到搜集完所有用户输入再进行下一帧",{"1":{"12":1}}],["我们正在招人",{"1":{"594":1}}],["我们非常努力的让il2cpp既快又稳定",{"1":{"594":1}}],["我们非常感谢用户的反馈来帮助我们改进il2cpp",{"1":{"594":1}}],["我们现在假设当前代码产生的栈存储会放到所有既有项",{"1":{"885":1}}],["我们现在所面对的大部分bug并不是意想不到的行为产生的",{"1":{"594":1}}],["我们现在还没有稳定到把il2cpp",{"1":{"592":1}}],["我们时常使用",{"1":{"594":1}}],["我们内部只保留一份最新的开发代码在主干分之",{"1":{"594":1}}],["我们已经连续发布了6个unity版本和7个补丁",{"1":{"594":1}}],["我们如何开发",{"0":{"594":1}}],["我们基本上是用c++代码来实现整个运行时库的",{"1":{"591":1}}],["我们同时使用",{"1":{"590":1}}],["我们说的il2cpp包含了两部分",{"1":{"588":1}}],["我们一般需要",{"1":{"581":1}}],["我们经常使用",{"1":{"577":1}}],["我们经过网络发送整型数值0x12345678时",{"1":{"37":1}}],["我们使用一条从",{"1":{"762":1}}],["我们使用一个黄框精灵代表屏幕取景区域",{"1":{"725":1}}],["我们使用libgc垃圾收集器",{"1":{"591":1}}],["我们使用",{"1":{"537":1,"940":1,"944":1,"959":1,"969":1,"1002":1}}],["我们使用当前的瓦片id去查询就可以得到相邻瓦片允许填入的瓦片id了",{"1":{"209":1}}],["我们启动恭候多时的",{"1":{"504":1}}],["我们称之为",{"1":{"762":2}}],["我们称呼这种记录过程为同步",{"1":{"443":1}}],["我们称为turn",{"1":{"11":1}}],["我们放置一个exit",{"1":{"224":1}}],["我们试着为第二个房间增加一个通道元素",{"1":{"221":1}}],["我们增加一个新的通道元素",{"1":{"221":1}}],["我们来一个例子吧",{"1":{"221":1}}],["我们来看下定义的iuser接口dbcontext中的配置字段dbcontext中的user表是如何创建",{"1":{"138":1}}],["我们来看下exe文件的格式",{"1":{"131":1}}],["我们来看看具体的执行流程",{"1":{"11":1}}],["我们利用种子生长与泛洪填充等启发式生成方法生成地图",{"1":{"214":1}}],["我们利用柏林噪声的采样尺度来决定地图的类型是连续的大陆型地图还是离散的大洲型地图",{"1":{"214":1}}],["我们按照玩家设置的参数",{"1":{"214":1}}],["我们对每位玩家的玩家区域内定额分配植被",{"1":{"214":1}}],["我们对导弹不进行延迟补偿",{"1":{"50":1}}],["我们在看下他生成的code我们看到在读取快照的时候使用了snapshotinterpolationfactor进行插值",{"1":{"1016":1}}],["我们在copydude",{"1":{"896":1}}],["我们在和指向引用类型的指针打交道",{"1":{"888":1}}],["我们在游戏开发中会遇到这种情况",{"1":{"841":1}}],["我们在游戏开发过程中",{"1":{"841":1}}],["我们在控制相机的时候",{"1":{"841":1}}],["我们在",{"1":{"742":1}}],["我们在移动背景取景区域的同时",{"1":{"729":1}}],["我们在上面的touch事件处理的地方会看到这么一段代码",{"1":{"675":1}}],["我们在生成游戏地形后",{"1":{"214":1}}],["我们在插值的过程中采用了一个不同的算法",{"1":{"46":1}}],["我们引用了柏林噪声js库来进行地形的实现",{"1":{"214":1}}],["我们参考",{"1":{"213":1}}],["我们参考文明的4x要素",{"1":{"212":1}}],["我们通过",{"1":{"199":1}}],["我们通过最新收到的位置信息和前100ms的位置信息",{"1":{"46":1}}],["我们再重复填充一次数组的值",{"1":{"199":1}}],["我们给4个顶点",{"1":{"197":1}}],["我们取3个输入值",{"1":{"197":1}}],["我们回到最开始的代码的第10行",{"1":{"173":1}}],["我们留意到ioptionsmonitor<>的实现是optionsmanager<>",{"1":{"173":1}}],["我们继续看第二次修改",{"1":{"173":1}}],["我们观察addoptions方法的实现",{"1":{"173":1}}],["我们仅注册了一次testoptions",{"1":{"172":1}}],["我们先猜猜a",{"1":{"952":1}}],["我们先约定以下变量",{"1":{"755":1}}],["我们先来看看eventmanager之前unity处理事件的方法",{"1":{"652":1}}],["我们先来看看aspnetcore是怎么实现的",{"1":{"150":1}}],["我们先不考虑那些障碍物",{"0":{"225":1},"1":{"224":1}}],["我们先从一小段代码着手",{"1":{"172":1}}],["我们先看一下",{"1":{"167":1}}],["我们会得到",{"1":{"965":1}}],["我们会得到值",{"1":{"889":1}}],["我们会声明一个clone",{"1":{"896":1}}],["我们会需要更多的堆空间",{"1":{"887":1}}],["我们会去raycaster",{"1":{"675":1}}],["我们会将il2cpp的改动挂到一个特定的分之下",{"1":{"594":1}}],["我们会在后续的一篇中专门的讨论",{"1":{"591":1}}],["我们会在稍后的部分进行详细的介绍",{"1":{"164":1}}],["我们会以",{"1":{"535":1}}],["我们会让玩家根据自己的喜好定制地图参数",{"1":{"214":1}}],["我们会介绍我们怎么围绕权威服务器来建立一个系统",{"1":{"65":1}}],["我们调用loadlibrary传递了一个文件名",{"1":{"131":1}}],["我们应该知道的一点是",{"1":{"125":1}}],["我们应该提供给玩家良好的游戏",{"1":{"40":1}}],["我们只是将变量放在",{"1":{"1023":1}}],["我们只是用一个和照相机取景区域一样大的精灵作为背景渲染区域",{"1":{"726":1}}],["我们只能使用栈中叠在最上面的盒子里的东西",{"1":{"879":1}}],["我们只需将圆形投射到一条投影轴上即可",{"1":{"764":1}}],["我们只需求出画布旋转后的圆心位置",{"1":{"756":1}}],["我们只需要把",{"1":{"535":1}}],["我们只需要遍历a格子里面的数据找到自己位置就可以了",{"1":{"107":1}}],["我们只要设置图形",{"1":{"726":1}}],["我们只要把这个文件夹移动到其他驱动器就可以",{"1":{"524":1}}],["我们只要明白",{"1":{"202":1}}],["我们只有在程序处于运行期间才能知道会创建哪些对象",{"1":{"113":1}}],["我们要定义缓冲中元素的结构而不是",{"1":{"938":1}}],["我们要小心并清醒的使用它",{"1":{"891":1}}],["我们要去管理堆是否干净",{"1":{"879":1}}],["我们要控制它的垃圾回收",{"1":{"879":1}}],["我们要注意在平时工作中需要注意哪些地方养成一套流程规范",{"1":{"856":1}}],["我们要重视相机的宽高比",{"1":{"841":1}}],["我们要防止类似于pointclick这类事件",{"1":{"681":1}}],["我们要到控制面板",{"1":{"420":1}}],["我们要把4x4的网格中的空余部分放上类型为0的房间",{"1":{"224":1}}],["我们要尝试向下",{"1":{"224":1}}],["我们要按照从小到大进行插入",{"1":{"106":1}}],["我们要跳到1000帧",{"1":{"15":1}}],["我们能马上根据其当前位置",{"1":{"104":1}}],["我们能够清晰地知道老版本是ok的",{"1":{"89":1}}],["我们展示了一种客户端预测和服务器调和的技术",{"1":{"77":1}}],["我们将飞船先变成一个",{"1":{"969":1}}],["我们将保持一个主列表去绘制一张图",{"1":{"898":1}}],["我们将有另一个方法呈现在栈结构的",{"1":{"890":1}}],["我们将地图单元格分为两种类型",{"1":{"214":1}}],["我们将问题降维到2维空间来讨论",{"1":{"197":1}}],["我们将在下面的文章中来讨论这个问题",{"1":{"77":1}}],["我们将会讨论在在同一台服务器上有",{"1":{"72":1}}],["我们将找到减小这种延迟感的方法",{"1":{"66":1}}],["我们提出了两种解决方案",{"1":{"77":1}}],["我们提出了",{"1":{"72":1}}],["我们介绍了关于权威服务器及其反作弊特性",{"1":{"72":1}}],["我们介绍了一种权威服务器的c",{"1":{"66":1}}],["我们假设这就是关于一个上下弹跳的方块的游戏",{"1":{"943":1}}],["我们假设任何没有正在被使用的东西都是垃圾",{"1":{"898":1}}],["我们假设传送到服务器的输入都能够成功执行",{"1":{"67":1}}],["我们假设数据从客户端到服务器需要50ms",{"1":{"64":1}}],["我们假定客户端跟服务器之间已经建立连接",{"1":{"41":1}}],["我们知道能够进行合批的前提是多个gameobject共享同一材质",{"1":{"980":1}}],["我们知道我们想用背景和前景做丰富的视差层",{"1":{"737":1}}],["我们知道gc在回收内存时先默认认为所有对象都是垃圾",{"1":{"131":1}}],["我们知道",{"1":{"55":1,"684":1}}],["我们需要把",{"1":{"1035":1}}],["我们需要判断哪些是垃圾",{"1":{"898":1}}],["我们需要制定一个有效的",{"1":{"898":1}}],["我们需要进行一下类型转换",{"1":{"896":1}}],["我们需要根据每一层背景的距离决定其在移动过程中的移动速度",{"1":{"734":1}}],["我们需要预先将整个背景全部拼接",{"1":{"728":1}}],["我们需要使用背景精灵拼接出完整的背景",{"1":{"728":1}}],["我们需要调用此函数来完成包装类型的设置",{"1":{"726":1}}],["我们需要让一张纹理重复出现",{"1":{"726":1}}],["我们需要向其中传3个参数",{"1":{"678":1}}],["我们需要在根目录下新建一个",{"1":{"536":1}}],["我们需要保存一个记录矩阵",{"1":{"210":1}}],["我们需要得到一个约束矩阵",{"1":{"208":1}}],["我们需要设定输出模型的大小比如一个10",{"1":{"208":1}}],["我们需要通过一个样例模型",{"1":{"208":1}}],["我们需要先声明一个排列表",{"1":{"199":1}}],["我们需要采用一种更为平滑",{"1":{"197":1}}],["我们需要对4个顶点的影响值做插值",{"1":{"197":1}}],["我们需要求出另外4个向量",{"1":{"197":1}}],["我们需要稍稍改变一些key存入redis的规则",{"1":{"91":1}}],["我们需要更新100个实例",{"1":{"89":1}}],["我们需要的就是",{"1":{"54":1}}],["我们需要这样决定",{"1":{"48":1}}],["我们可能就需要等待比如61ms",{"1":{"50":1}}],["我们可以直接在",{"1":{"966":1}}],["我们可以直接绘制这些数据而无需",{"1":{"941":1}}],["我们可以从",{"1":{"947":1}}],["我们可以重用已有的缓冲元素的结构",{"1":{"938":1}}],["我们可以用",{"1":{"930":1}}],["我们可以用process",{"1":{"592":1}}],["我们可以为需要共享的材质创建",{"1":{"928":1}}],["我们可以看到程序的崩溃即将来临",{"1":{"898":1}}],["我们可以看到第一次通过代码修改ioptions<>和ioptionsmonitor<>的值后",{"1":{"173":1}}],["我们可以把这些顶点数据合并在一起",{"1":{"876":1}}],["我们可以先通过运算得到两者",{"1":{"759":1}}],["我们可以先在",{"1":{"537":1}}],["我们可以基本理出热更dll和unity主工程的交互本质",{"1":{"716":1}}],["我们可以将",{"1":{"938":1}}],["我们可以将我们思想的范围进行扩大",{"1":{"756":1}}],["我们可以将il的汇编码存储到image中",{"1":{"713":1}}],["我们可以将两者同时进行",{"1":{"67":1}}],["我们可以通过",{"1":{"929":1}}],["我们可以通过选择列标题",{"1":{"878":1}}],["我们可以通过实现以下接口来实现事件捕捉",{"1":{"667":1}}],["我们可以通过继承baseinputmodule实现自己的输入模块",{"1":{"654":1}}],["我们可以很肯定的说问题出在aot编译器或者运行时库这两个地方而不是在其他地方",{"1":{"593":1}}],["我们可以很轻松的切换源",{"1":{"478":1}}],["我们可以依赖健壮的且久经考验的c",{"1":{"593":1}}],["我们可以多来几台",{"1":{"581":1}}],["我们可以修改",{"1":{"536":1}}],["我们可以利用它为",{"1":{"509":1}}],["我们可以利用这一点",{"1":{"67":1}}],["我们可以在别处得知这个entity何时被添加",{"1":{"987":1}}],["我们可以在",{"1":{"509":1}}],["我们可以在某一点填入一个特定的瓦片id",{"1":{"209":1}}],["我们可以安装",{"1":{"412":1}}],["我们可以知道在当前瓦片id下",{"1":{"209":1}}],["我们可以使用",{"1":{"951":1}}],["我们可以使用不同的频率",{"1":{"204":1}}],["我们可以使用redis作为缓存机制",{"1":{"91":1}}],["我们可以部分部署",{"1":{"89":1}}],["我们可以控制预测过程中的延迟",{"1":{"50":1}}],["我们可以如上面所述",{"1":{"43":1}}],["我们可以有个案例",{"1":{"30":1}}],["我们相信采用延迟补偿是正确的游戏决定",{"1":{"48":1}}],["我们就是在和值类型本身打交道",{"1":{"888":1}}],["我们就必须关注视口坐标体系了",{"1":{"841":1}}],["我们就需要用上视口坐标系了",{"1":{"841":1}}],["我们就避免了内存的分配以及模拟了一个在使用",{"1":{"739":1,"744":1}}],["我们就得改变我们当前所在的房间了",{"1":{"224":1}}],["我们就能得到以下结果",{"1":{"204":1}}],["我们就知道该顶点的影响值是正还是负的",{"1":{"197":1}}],["我们就可以来做游戏了",{"1":{"943":1}}],["我们就可以得出每个顶点的影响值",{"1":{"197":1}}],["我们就可以使用哈希函数h计算值为key的数据在哈希环的具体位置h",{"1":{"92":1}}],["我们就可以将采样点平滑处理",{"1":{"46":1}}],["我们就认为数据不正常",{"1":{"46":1}}],["我们就创建一条包含时间戳的记录",{"1":{"46":1}}],["我们就将插值时间延长到200ms",{"1":{"46":1}}],["我们每收到一个服务器的更新",{"1":{"46":1}}],["我们每收到一个物体位置的更新信息",{"1":{"46":1}}],["我们还可以注销这个collectorcollector",{"1":{"741":1}}],["我们还可能对系统进行动态伸缩",{"1":{"89":1}}],["我们还要限制坐标在",{"1":{"199":1}}],["我们还会详细介绍系统默认的",{"1":{"170":1}}],["我们还需判断到底哪个节点使用的是哪个代码",{"1":{"89":1}}],["我们还是选择采用服务器模式来做校验",{"1":{"45":1}}],["我们还讨论了如何通过一个预测模型来掩饰延迟带来的影响",{"1":{"40":1}}],["我们描述了客户端的运动预测",{"1":{"43":1}}],["我们把这个monobehaviour称为",{"1":{"967":1}}],["我们把运行时库称之为libli2cpp",{"1":{"591":1}}],["我们把redis编号设置成0",{"1":{"91":1}}],["我们把时间往后推算的时候",{"1":{"47":1}}],["我们把服务器确认的移动信息作为开始",{"1":{"43":1}}],["我们把游戏的前进分为一帧帧",{"1":{"11":1}}],["我们采用以下方法",{"1":{"43":1}}],["我们这里并不是利用",{"1":{"759":1}}],["我们这里针对2d",{"1":{"726":1}}],["我们这里以横向滚动来介绍背景滚动",{"1":{"725":1}}],["我们这里也主要聊聊如果通过多层次背景滚动的方式实现视差效果",{"1":{"724":1}}],["我们这里的预测执行",{"1":{"15":1}}],["我们这样简化有利于分析预测和延迟补偿",{"1":{"41":1}}],["我们常用的x86结构是小端模式",{"1":{"33":1}}],["我们的弹跳系统先在主线程检查空格是否按下",{"1":{"944":1}}],["我们的远景必须真的是一个非常大的背景",{"1":{"724":1}}],["我们的背景就会形成类似于透视视差的效果",{"1":{"724":1}}],["我们的assembly是不能单独执行的",{"1":{"707":1}}],["我们的il2cpp研发组有很强烈的",{"1":{"594":1}}],["我们的qa和维护工作组为此付出了惊人的努力才得以保证发布版本的快速迭代",{"1":{"594":1}}],["我们的电脑中会有大量的软件",{"1":{"481":1}}],["我们的地图生成结果能够保证对称性多人对抗战略游戏的平衡性",{"1":{"215":1}}],["我们的方法生成的地图",{"1":{"215":1}}],["我们的的系统有两台redis",{"1":{"96":1}}],["我们的服务器的实现非常简单",{"1":{"73":1}}],["我们的逻辑之所以能回滚",{"1":{"15":1}}],["我们的游戏因为是从单机版改造过来的",{"1":{"15":1}}],["我们测试在200~300毫秒随机延迟的情况下",{"1":{"15":1}}],["自然而然的",{"1":{"1054":1}}],["自然是你想要",{"1":{"970":1}}],["自然你是想要在编辑器中快速地迭代玩法",{"1":{"945":1}}],["自然可以完全发挥显卡的实力",{"1":{"854":1}}],["自从开了垂直同步后",{"1":{"854":1}}],["自从我们在一月份的4",{"1":{"594":1}}],["自制bucket",{"0":{"436":1},"2":{"437":1,"438":1}}],["自动生成一个新的entity",{"1":{"939":1}}],["自动生成多个类型的泛型",{"1":{"176":1}}],["自动内存管理通常会等于或击败手动分配的整体性能",{"1":{"828":1}}],["自动创建项目release",{"0":{"510":1}}],["自动不受控制的闲逛",{"1":{"391":1}}],["自求多福方是活命之选",{"1":{"383":1}}],["自身节点",{"1":{"283":1,"660":1}}],["自定义事件处理建立一個",{"1":{"657":1}}],["自定义tag",{"1":{"241":1}}],["自定义的帧",{"1":{"11":1}}],["自己先跑一下servertick",{"1":{"1013":1}}],["自己在逻辑代码里面进行动态合批",{"1":{"849":1}}],["自己在此总结一下",{"1":{"840":1}}],["自己不能做",{"1":{"573":1}}],["自己特产什麼该样物资就可以减少人手去挖",{"1":{"376":1}}],["自己慢慢摸索才能领悟",{"1":{"375":1}}],["自己附加状态",{"1":{"246":1}}],["自己的表",{"1":{"142":1}}],["自己",{"1":{"78":1}}],["自己去处理自己的takesnapshot和rollback",{"1":{"15":1}}],["自己和其他玩家预测的操作",{"1":{"15":1}}],["和上面类似",{"1":{"1054":1}}],["和处理条件",{"1":{"1043":1}}],["和我们上面的",{"1":{"969":1}}],["和我们的逻辑方法一致",{"1":{"32":1}}],["和meshrenderer建造一个飞船",{"1":{"968":1}}],["和prefab",{"1":{"966":1}}],["和disabled组件的行为很相似",{"1":{"964":1}}],["和另外两个新增的",{"1":{"962":1}}],["和它那些朋友们",{"1":{"960":1}}],["和会将所有子层级提交到",{"1":{"956":1}}],["和一个实体关联起来",{"1":{"937":1}}],["和一个层级为0的imagef",{"1":{"862":1}}],["和一个层级为0的textc",{"1":{"862":1}}],["和哈希表",{"1":{"929":1}}],["和身份证一样用于实体与实体之间区分",{"1":{"906":1}}],["和三角图元0是一样的",{"1":{"846":1}}],["和因此收集",{"1":{"831":1}}],["和java",{"1":{"825":1}}],["和java中的循环引用",{"0":{"124":1}}],["和其他的碰撞检测技术一样",{"1":{"786":1}}],["和其他数据通过",{"1":{"573":1}}],["和攻击动画和攻击特效有出入",{"1":{"750":1}}],["和相机",{"1":{"737":1,"1032":1}}],["和照相机移动方式一样",{"1":{"729":1}}],["和动态注入程序集",{"1":{"717":1}}],["和前面有点类似",{"1":{"715":1}}],["和事件处理",{"0":{"656":1},"2":{"657":1,"658":1}}],["和google",{"1":{"612":1}}],["和gui程序集",{"1":{"592":1}}],["和版本号与你上传的apk的包的一样",{"1":{"610":1}}],["和反向代理服务器正向代理",{"1":{"581":1}}],["和反射方法一样",{"1":{"111":1}}],["和语言解释器",{"1":{"575":1}}],["和标准输出",{"1":{"574":1}}],["和给",{"1":{"572":1}}],["和带网络连接的客户端执行命令的效果",{"1":{"452":1}}],["和模式",{"1":{"451":1}}],["和垂直的交叉轴",{"1":{"406":1}}],["和现实中的人一样",{"1":{"382":1}}],["和铸造房一样",{"1":{"380":1}}],["和徒手武场一样",{"1":{"380":1}}],["和总舵一样",{"1":{"380":1}}],["和桌子",{"1":{"369":1}}],["和着笛声沉沉睡去",{"1":{"296":1}}],["和城市地块以及城市等级没有关系",{"1":{"292":1}}],["和彩虹岛的地图都可以参考",{"1":{"287":1}}],["和sequence的区别就是",{"1":{"282":1}}],["和随机精英怪",{"1":{"266":1}}],["和随着业务的扩展",{"1":{"91":1}}],["和与角色由关系的npc",{"1":{"260":1}}],["和y轴正向",{"1":{"209":1}}],["和振幅",{"1":{"204":1}}],["和普通win32的exe文件格式一样",{"1":{"131":1}}],["和历来用于可执行内容的通用对象文件格式",{"1":{"127":1}}],["和元数据包含在一个可移植的可执行",{"1":{"127":1}}],["和老年代",{"1":{"122":1}}],["和两块较小的survivor",{"1":{"120":1}}],["和场景大小无关",{"1":{"110":1}}],["和用户命令速率",{"1":{"86":1}}],["和converttoentity",{"1":{"971":1}}],["和clr",{"1":{"898":1}}],["和c",{"1":{"38":1}}],["和linux",{"1":{"33":1,"38":1}}],["和快照数据的reader和writer然后",{"1":{"15":1}}],["和真实逻辑的预测执行",{"1":{"15":1}}],["和很多介绍帧同步文章提到的预测是不同的",{"1":{"15":1}}],["和",{"0":{"641":1,"643":1,"689":1,"721":1,"843":2,"968":1},"1":{"15":1,"51":1,"88":1,"132":1,"152":1,"153":1,"155":1,"164":1,"176":1,"225":1,"226":1,"228":2,"241":1,"285":1,"405":1,"412":1,"424":2,"444":1,"445":1,"446":1,"449":1,"450":1,"452":3,"467":1,"503":1,"510":2,"536":1,"573":1,"577":1,"581":1,"592":1,"599":1,"600":1,"604":3,"640":2,"642":2,"649":1,"650":1,"660":1,"683":1,"684":1,"687":1,"689":2,"694":2,"695":4,"722":1,"740":1,"781":1,"833":1,"841":2,"858":4,"884":1,"904":1,"916":1,"917":1,"931":1,"933":1,"940":3,"941":2,"942":4,"943":1,"944":1,"946":2,"947":1,"948":3,"949":1,"951":5,"952":3,"953":1,"954":4,"957":1,"958":2,"959":1,"960":1,"964":2,"965":2,"969":1,"971":1,"1001":2,"1002":1,"1004":1,"1036":1,"1040":3,"1053":1},"2":{"722":1}}],["和a一致",{"1":{"15":1}}],["和a是一致的",{"1":{"15":1}}],["和消息通知的优化",{"1":{"15":1}}],["和网络不好的玩家",{"1":{"15":1}}],["和服务器确认的a的操作",{"1":{"15":1}}],["和自己预测的一样",{"1":{"15":1}}],["和之前执行的一样",{"1":{"15":1}}],["和不透明",{"1":{"0":1}}],["领先服务器多一些",{"1":{"15":1}}],["领先服务器",{"1":{"15":1}}],["将调用dots预置的或我们自定义的convert接口",{"1":{"1054":1}}],["将球体改为红色",{"1":{"1034":1}}],["将来会起作用吗",{"1":{"1023":1}}],["将自动释放变量",{"1":{"1023":1}}],["将自身从附近灯塔的观察者队列中移除",{"1":{"104":1}}],["将自身预测的状态和服务器发送来的状态进行同步",{"1":{"78":1}}],["将永久保留",{"1":{"1022":1}}],["将更新predictedghostcomponent",{"1":{"1014":1}}],["将item和character关联起来inventory",{"1":{"1008":1}}],["将inspector面板右上角的static勾选",{"1":{"876":1}}],["将材质信息保存在保存在显存中的",{"1":{"982":1}}],["将查询spawnhereecsentity",{"1":{"966":1}}],["将占据",{"1":{"960":1}}],["将运行在",{"1":{"949":1}}],["将在",{"1":{"948":1}}],["将数据转存回",{"1":{"945":1}}],["将让",{"1":{"929":1}}],["将共享组件的实体分到一个内存块中会提高处理他们的速度",{"1":{"905":1}}],["将结果更新到",{"1":{"904":1}}],["将音频文件设置为",{"1":{"867":1}}],["将生成一个匿名类",{"1":{"864":1}}],["将生成一个此类的副本",{"1":{"818":1}}],["将对象隐藏起来",{"1":{"860":1}}],["将对象的坐标值按照从小到大相应的排列在相应的坐标轴上面",{"1":{"106":1}}],["将释放其内存",{"1":{"857":1}}],["将帽子的网格合并到人物模型上",{"1":{"848":1}}],["将它们的albedo分别设置为红色和绿色",{"1":{"847":1}}],["将meshrenderer的material的size设为2的话",{"1":{"847":1}}],["将上述代码挂载到一个空节点上运行",{"1":{"847":1}}],["将信息同步给服务端",{"1":{"805":1}}],["将地图",{"1":{"758":1}}],["将矩形的旋转看作是整个画布的旋转",{"1":{"756":1}}],["将视差相机放在主相机的下边",{"1":{"737":1}}],["将引用和使用",{"1":{"722":1}}],["将test绑定到场景物体上",{"1":{"717":1}}],["将dll和pdb的bytes都存入到内存流中后",{"1":{"711":1}}],["将dll文件读取出来",{"1":{"708":1}}],["将dll改为bytes文件",{"1":{"708":1}}],["将该球体设为unity",{"1":{"1034":1}}],["将该prefab组件删掉",{"1":{"964":1}}],["将该工程导出为dll",{"1":{"708":1}}],["将该接收者作为参数执行",{"1":{"657":1}}],["将该对象添加为其观察者",{"1":{"104":1}}],["将尝试在",{"1":{"604":1}}],["将游戏导出到",{"1":{"604":1}}],["将游标移动到该节点",{"1":{"210":1}}],["将代码中没有引用到的类型裁剪掉",{"1":{"603":1}}],["将需要的scriptobject放在该场景",{"1":{"598":1}}],["将请求分配给不同的web服务器",{"1":{"581":1}}],["将处理结果返回给",{"1":{"576":1}}],["将下载好的",{"1":{"556":1}}],["将执行剩下的插件打包操作",{"1":{"535":1}}],["将执行完的命令",{"1":{"443":1}}],["将使用其",{"1":{"604":1}}],["将使用",{"1":{"524":1}}],["将使用你传递一个值来设置这两个参数",{"1":{"152":1}}],["将保存的目录指定为然后直接推送到",{"1":{"507":1}}],["将brew装在非系统盘",{"0":{"477":1}}],["将b对象",{"1":{"102":1}}],["将协议文本追加到",{"1":{"445":1}}],["将协议文本发送给",{"1":{"444":1}}],["将命令还原成",{"1":{"445":1}}],["将命令从字符串对象转换回原来的协议文本",{"1":{"445":1}}],["将命令转换为网络通讯协议的格式",{"1":{"443":1}}],["将客户端的命令指针指向实现",{"1":{"444":1}}],["将客户端的输入信息缓存起来",{"1":{"73":1}}],["将写命令追加到",{"1":{"455":1}}],["将写命令追加到现有的",{"1":{"455":1}}],["将写入的内容真正地保存到磁盘中",{"1":{"443":1}}],["将写好的声明文件与js库放在同一文件夹下",{"1":{"399":1}}],["将内存中的数据复制一份给子进程",{"1":{"442":1}}],["将prefab引用添加到conversion",{"1":{"939":1}}],["将pwsh添加到terminal中",{"1":{"435":1}}],["将playload赋值给各个pipelinetask然后执行pipelinetask的",{"1":{"227":1}}],["将全局应用安装到自定义目录",{"1":{"429":1}}],["将scoop安装到自定义目录",{"1":{"429":1}}],["将声明文件放在相同的目录下",{"1":{"400":1}}],["将具有56点闪避",{"1":{"385":1}}],["将影响弟子的练功效率",{"1":{"381":1}}],["将会被",{"1":{"947":1}}],["将会被卸载掉",{"1":{"701":1}}],["将会是噩梦般的开发旅程",{"1":{"945":1}}],["将会得到如下图所示的运行结果",{"1":{"847":1}}],["将会得到一个指向同一个操作的",{"1":{"699":1}}],["将会从托管堆中分配更多空间",{"1":{"813":1}}],["将会使其依赖的所有资源的引用记数均增加为3",{"1":{"699":1}}],["将会前往徒手武场进行练习",{"1":{"380":1}}],["将会同样设置",{"1":{"152":1}}],["将他灌醉",{"1":{"296":1}}],["将物品扔进女神之泉即可",{"1":{"290":1}}],["将generated",{"1":{"228":1}}],["将rooms下的tile复制到sharedtilemaps",{"1":{"228":1}}],["将整个地图填满土",{"1":{"220":1}}],["将随机取到的连续噪声均衡化作为地图的高度图",{"1":{"214":1}}],["将这些模型的顶点数据变换到世界空间下",{"1":{"979":1}}],["将这些静态的物件如植被等全部从场景中剔除",{"1":{"849":1}}],["将这些结果逐一加入到result当中",{"1":{"676":1}}],["将这些程序集转换成c++代码",{"1":{"590":1}}],["将这些节点加入当前节点后面",{"1":{"210":1}}],["将这个数据广播给ab",{"1":{"15":1}}],["将反射出来的方法创建一个委托",{"1":{"175":1}}],["将授权地址配置为域名",{"1":{"135":1}}],["将所有的引用记数全部增加",{"1":{"699":1}}],["将所有拥有事件的对象通通都调用一遍就是这个事件链的本质",{"1":{"680":1}}],["将所有对数据库进行过写入的命令",{"1":{"443":1}}],["将所有包都会将自己的资源复制到wwwroot",{"1":{"134":1}}],["将所有移动的",{"1":{"47":1}}],["将三个项目copy到程序中",{"1":{"133":1}}],["将正在使用的那份内存中存活的对象复制到另一份空白的内存中",{"1":{"120":1}}],["将玩家从对应的格子里面删除",{"1":{"103":1}}],["将玩家状态复制到共享数据结构中",{"1":{"43":1}}],["将由某些提供程序",{"1":{"90":1}}],["将流量从版本1切换到版本2",{"1":{"88":1}}],["将是66",{"1":{"86":1}}],["将最后计算的结果更新到所有客户端",{"1":{"73":1}}],["将",{"0":{"128":1},"1":{"69":2,"130":2,"446":2,"455":1,"507":1,"592":1,"815":1,"858":2},"2":{"129":1,"130":1}}],["将位置更新为",{"1":{"63":1}}],["将启动点作为一个变量",{"1":{"50":1}}],["将其位置",{"1":{"981":1,"982":1}}],["将其作为组件加入到main",{"1":{"592":1}}],["将其分成x轴和y轴两个链表",{"1":{"106":1}}],["将其他客户端控制的实体插值到过去的状态从玩家的角度来看",{"1":{"78":1}}],["将其拉回到这个更新时间",{"1":{"47":1}}],["将其转换成大端法存放的数值",{"1":{"37":1}}],["将指向0x12345678的指针传给了java程序",{"1":{"34":1}}],["将不做任何改变",{"1":{"15":1}}],["将经常发生不同步的客户端标记出来",{"1":{"15":1}}],["将图片处理成透明",{"1":{"0":1}}],["4f1",{"1":{"1038":1}}],["4bhxtm",{"1":{"984":1}}],["4bef7f66aefd",{"1":{"719":1}}],["45",{"1":{"960":1}}],["450",{"1":{"297":1}}],["41",{"1":{"823":1}}],["4211964",{"1":{"719":1}}],["4278947",{"1":{"719":1}}],["468分辨率下的实际屏幕高度为",{"1":{"625":1}}],["468后",{"1":{"625":1}}],["468",{"1":{"625":2}}],["4g",{"1":{"564":1}}],["4个时辰",{"1":{"382":1}}],["4|热血|受到伤害可以累加增加出招速度|",{"1":{"378":1}}],["480",{"1":{"287":1}}],["48s",{"1":{"195":1}}],["4x4",{"1":{"224":1,"944":1,"1000":1}}],["4000毫秒",{"1":{"1051":1}}],["4000",{"1":{"506":1,"1036":1}}],["400",{"1":{"297":1,"532":1}}],["40l6000000",{"1":{"225":1}}],["40",{"1":{"220":1,"297":5}}],["404",{"0":{"149":1}}],["47s",{"1":{"195":2}}],["47",{"1":{"194":1}}],["4",{"0":{"43":1,"64":1,"69":1,"75":1,"96":1,"121":1,"569":1,"721":1,"722":1,"751":1,"797":1,"809":1,"980":1},"1":{"15":1,"46":1,"50":1,"88":2,"89":1,"91":1,"116":2,"126":3,"181":1,"189":1,"191":1,"195":1,"214":2,"220":1,"221":1,"224":1,"225":2,"266":1,"275":1,"296":1,"297":4,"302":1,"304":1,"374":1,"452":1,"477":1,"509":1,"528":2,"529":1,"618":1,"720":1,"721":5,"722":2,"739":1,"836":1,"841":1,"850":1,"878":1,"898":1,"953":1,"965":3,"1022":1,"1054":1},"2":{"722":1}}],["3100",{"1":{"1036":1}}],["3106",{"1":{"567":1}}],["3个前述chunk",{"1":{"952":1}}],["3是通过递归查询找到",{"1":{"898":1}}],["3被1引用",{"1":{"898":1}}],["3g上的垃圾收集大约需要5ms",{"1":{"830":1}}],["36",{"1":{"823":1}}],["3600",{"1":{"1039":1}}],["360143",{"1":{"984":1}}],["360",{"1":{"103":1,"297":1}}],["3源代码",{"1":{"782":1}}],["3中实现了它",{"1":{"782":1}}],["3f1制作的",{"1":{"737":1}}],["3秒钟",{"1":{"671":1}}],["333​",{"1":{"625":1}}],["3m",{"1":{"534":1}}],["35830868",{"1":{"984":1}}],["35m",{"1":{"534":1,"535":1}}],["35244",{"1":{"532":1}}],["350",{"1":{"68":1,"297":2}}],["3a",{"1":{"412":1}}],["3|",{"1":{"378":6}}],["3支蜡烛大约最高经验值上限可以学到7000才会喊不",{"1":{"372":1}}],["3c瘸子掉了一个头环",{"1":{"270":1}}],["345",{"1":{"850":1}}],["34",{"1":{"270":2}}],["344或10",{"1":{"83":1}}],["3类型都有左右出口",{"1":{"224":1}}],["3d",{"1":{"656":1,"684":1,"840":4,"978":3}}],["3d物品会根据ui的位置改变而改变然后可能会出现看不到3d对象的问题",{"1":{"622":1}}],["3d形象如何展现在ui中",{"0":{"622":1}}],["3dmgame",{"1":{"296":1}}],["3dm单机",{"1":{"296":1}}],["3d则是一个有特定形状的物体",{"1":{"206":1}}],["3d游戏顺势扩展即可",{"1":{"105":1}}],["3维下是",{"1":{"207":1}}],["3维",{"1":{"197":1}}],["3的格子要总比客户端显示范围要大一点为原则",{"1":{"103":1}}],["3上",{"1":{"92":1}}],["32bit",{"1":{"872":1}}],["32bit的long型",{"1":{"33":1}}],["32",{"1":{"390":1,"533":1}}],["320",{"1":{"297":1}}],["32s",{"1":{"195":1}}],["32位系统",{"1":{"131":1}}],["32甚至更大",{"1":{"96":1}}],["32减去0",{"1":{"83":1}}],["30日",{"1":{"371":1}}],["30",{"1":{"297":3}}],["3000",{"1":{"975":1,"1036":2,"1039":1}}],["300",{"1":{"220":1,"297":1}}],["30秒",{"1":{"83":1}}],["30am",{"1":{"22":1}}],["3步",{"1":{"51":1}}],["38468615",{"1":{"15":1}}],["3",{"0":{"42":1,"63":1,"68":1,"74":1,"80":1,"93":1,"94":1,"95":1,"120":1,"185":1,"492":1,"568":1,"750":1,"794":1,"795":1,"796":1,"806":1,"995":1,"1034":1},"1":{"15":1,"22":1,"45":1,"50":1,"81":1,"88":3,"89":1,"91":1,"96":2,"97":1,"103":1,"126":4,"131":1,"181":2,"189":1,"191":1,"195":1,"197":1,"209":1,"213":1,"214":1,"220":4,"221":1,"224":2,"266":1,"267":1,"270":1,"275":1,"296":1,"297":2,"302":1,"304":1,"451":2,"452":1,"467":1,"507":1,"537":1,"560":1,"567":2,"586":1,"587":1,"618":1,"628":2,"707":1,"737":1,"739":1,"795":1,"802":1,"803":1,"804":1,"836":1,"841":1,"846":1,"889":1,"920":1,"921":1,"941":1,"943":1,"952":2,"953":3,"955":1,"965":3,"976":1,"979":1,"992":1,"1003":1,"1023":1,"1038":1},"2":{"81":1,"94":1,"95":1,"493":1,"494":1,"495":1,"795":1,"796":1,"797":1,"798":1,"799":1,"800":1,"801":1,"802":1,"803":1,"804":1,"805":1,"806":1,"807":2,"808":2,"809":1}}],["3人及以上",{"1":{"15":1}}],["能和什么类型一起运行",{"1":{"1007":1}}],["能降低",{"1":{"975":1}}],["能使得",{"1":{"975":1}}],["能在預設的",{"1":{"975":2}}],["能工作",{"1":{"965":1}}],["能容纳",{"1":{"943":1}}],["能为你提供有可能碰撞的实体列表",{"1":{"767":1}}],["能看到登录页面",{"1":{"531":1}}],["能量球",{"1":{"384":1}}],["能盖住",{"1":{"285":2}}],["能找到的说明还在使用就去掉垃圾标记",{"1":{"131":1}}],["能够工作",{"1":{"966":1}}],["能够正常用于实例化",{"1":{"966":1}}],["能够正确生成",{"1":{"592":1}}],["能够看到",{"1":{"701":1}}],["能够从",{"1":{"661":1}}],["能够处理多种通用的协议类型",{"1":{"583":1}}],["能够生产的物品等级也会越来越高",{"1":{"380":1}}],["能够生产的物品等级也就越高",{"1":{"380":1}}],["能够更好地发展自身建设",{"1":{"213":1}}],["能够和配置文件一起更新",{"1":{"174":1}}],["能够通过创建一个新对象",{"1":{"111":1}}],["能够最小的减少玩家的延迟体验",{"1":{"65":1}}],["能够求得发包的时间",{"1":{"56":1}}],["能够恢复到断线前的状态",{"1":{"12":1}}],["能很好地解决大部分问题",{"1":{"15":1}}],["能体会更深",{"1":{"15":1}}],["能做到绝佳的操作手感",{"1":{"15":1}}],["能做到这一点的话",{"1":{"15":1}}],["再按照",{"1":{"1039":1}}],["再是gpu",{"1":{"980":1}}],["再畫透明物件",{"1":{"975":1}}],["再存回去",{"1":{"944":1}}],["再放到",{"1":{"928":1}}],["再次执行主方法main",{"1":{"896":1}}],["再次打印都被更新了",{"1":{"173":1}}],["再把合并后模型数据传递给gpu",{"1":{"876":1}}],["再把int",{"1":{"131":1}}],["再一起发送给gpu",{"1":{"876":1}}],["再一次连续接",{"1":{"377":1}}],["再回顾下黑体字",{"1":{"862":1}}],["再举个栗子",{"1":{"862":1}}],["再调试",{"1":{"837":1}}],["再测试了一下",{"1":{"836":1}}],["再在最后加上新的部分",{"1":{"828":1}}],["再用linecast进行判定",{"1":{"751":1}}],["再结合动画事件进行攻击判定",{"1":{"748":1}}],["再之后",{"1":{"746":1}}],["再加上反射传递函数参数时需要使用",{"1":{"718":1}}],["再加上django这样的web框架",{"1":{"577":1}}],["再通过",{"1":{"699":1}}],["再使用",{"1":{"695":1}}],["再计算",{"1":{"689":1}}],["再由",{"1":{"576":1}}],["再将请求转发给",{"1":{"576":1}}],["再将结果上报至服务器",{"1":{"15":1}}],["再不行就重装idea",{"1":{"562":1}}],["再进入bin目录",{"1":{"559":1}}],["再进行打包",{"1":{"537":1}}],["再根据",{"1":{"510":1}}],["再根据子节点的返回状态判断该并行节点的状态",{"1":{"280":1}}],["再下按",{"1":{"464":1}}],["再然后重复输入密码回车",{"1":{"463":1}}],["再考虑这样一个例子",{"1":{"454":1}}],["再重新执行成功显示",{"1":{"404":1}}],["再ping一下",{"1":{"404":1}}],["再开打声望要一下子满很简单",{"1":{"377":1}}],["再借不难",{"1":{"372":1}}],["再旅馆吃饭",{"1":{"290":1}}],["再往里面扔一个宝箱",{"1":{"221":1}}],["再从中选出最小距离最大的红色点作为本轮采样的结果",{"1":{"214":1}}],["再好不要使用超过几组倍频",{"1":{"204":1}}],["再乘以两向量夹角余弦",{"1":{"197":1}}],["再检查",{"1":{"151":1}}],["再运行jenny",{"1":{"746":1}}],["再运行",{"1":{"131":1}}],["再到客户端接收此命令对应的服务器响应被称为延迟或ping",{"1":{"82":1}}],["再来说说",{"1":{"33":1}}],["再去通知广播client更新",{"1":{"12":1}}],["26",{"1":{"954":1}}],["268657",{"1":{"737":1}}],["2个",{"1":{"954":1,"955":1}}],["2个text可batch",{"1":{"862":1}}],["2个image可batch",{"1":{"862":1}}],["2主相机会渲染除正交模式中视差层级之外的所有东西",{"1":{"737":1}}],["2=",{"1":{"625":1}}],["2d",{"1":{"656":2,"726":2,"737":1,"770":2,"840":2,"845":1,"858":1,"975":1,"978":1}}],["2d场景和3d摄像机的适配",{"0":{"620":1}}],["2d柏林噪声的影响值下一步",{"1":{"197":1}}],["2h",{"1":{"615":1}}],["2或更高版本",{"1":{"586":1}}],["2g",{"1":{"564":1}}],["223",{"1":{"529":2}}],["22和所有实体及其动画都可以基于快照340和342做正确的插值处理",{"1":{"83":1}}],["29",{"1":{"529":3}}],["2984毫秒http",{"1":{"111":1}}],["2如果你使用win10",{"1":{"528":1}}],["2customizing",{"1":{"527":1}}],["2ct1",{"0":{"52":1},"2":{"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1}}],["2|魔身|除非发生重击否则不会受到任何伤害|",{"1":{"378":1}}],["2|金身|对所有负面状态免疫|",{"1":{"378":1}}],["2|色诱|都受到异性攻击时伤害力减少25",{"1":{"378":1}}],["2|",{"1":{"378":4}}],["2700",{"1":{"960":1}}],["270",{"1":{"297":1}}],["280",{"1":{"297":2}}],["210",{"1":{"297":2}}],["21",{"1":{"295":1}}],["218",{"1":{"189":1,"195":2}}],["2条额外属性的蓝色",{"1":{"273":1}}],["2维下则是",{"1":{"207":1}}],["2维空间下的解法",{"1":{"197":1}}],["2450",{"1":{"975":1,"1036":1}}],["2453",{"1":{"137":1}}],["24个",{"1":{"954":1}}],["24h",{"1":{"615":1}}],["24点",{"0":{"365":1}}],["240实际上没多大复杂的事情",{"1":{"1013":1}}],["240",{"1":{"297":2,"1013":3}}],["2464毫秒使用序列化进行克隆克隆一个对象的最简单的方法是将它序列化并立刻反序列化为一个新对象",{"1":{"111":1}}],["2大一些",{"1":{"103":1}}],["2上",{"1":{"92":1}}],["2^32",{"1":{"92":1}}],["2重新计算",{"1":{"91":1}}],["2来保存对应hash计算出来的值",{"1":{"91":1}}],["2可以启用相关的视图",{"1":{"86":1}}],["254",{"1":{"529":1}}],["256",{"0":{"470":1}}],["255",{"1":{"199":1,"201":1}}],["255这些数值",{"1":{"199":1}}],["25秒才会触发",{"1":{"83":1}}],["2500的物体前面",{"1":{"976":1}}],["2500的物体绝对会在renderqueue",{"1":{"976":1}}],["2500是关键值",{"1":{"976":1}}],["2500以上",{"1":{"976":1}}],["2500以下3",{"1":{"976":1}}],["2500",{"1":{"975":2}}],["250的时候",{"1":{"69":1}}],["250",{"1":{"68":1,"103":6,"297":1}}],["239predictingtick",{"1":{"1013":1}}],["238predictingtick",{"1":{"1013":1}}],["235servertick",{"1":{"1013":1}}],["235predictingtick",{"1":{"1013":1}}],["234predictingtick",{"1":{"1013":1}}],["233predictingtick",{"1":{"1013":1}}],["232predictingtick",{"1":{"1013":1}}],["231predictingtick",{"1":{"1013":1}}],["230predictingtick",{"1":{"1013":1}}],["23",{"1":{"81":2,"295":1,"823":1}}],["2请求之前的请求都丢弃",{"1":{"69":1}}],["2请求的回复发过来",{"1":{"69":1}}],["2输入",{"1":{"69":1}}],["2输入来计算当前的状态",{"1":{"69":1}}],["2的拷贝",{"1":{"69":1}}],["2步甚至只做第2步",{"1":{"51":1}}],["2020年2月13日",{"0":{"983":1}}],["2020",{"1":{"850":1,"854":2}}],["202",{"1":{"529":1}}],["2022",{"0":{"552":1},"1":{"287":4,"553":1,"554":1},"2":{"553":1,"554":1,"555":1,"556":1,"557":1,"558":1,"559":1,"560":1,"561":1,"562":1,"563":1}}],["20日",{"1":{"371":1}}],["20原文链接最好用chrome打开",{"1":{"225":1}}],["20s",{"1":{"195":1}}],["2015",{"1":{"606":1}}],["2019",{"1":{"606":1,"723":1,"941":2}}],["2018",{"1":{"587":1,"850":1,"975":1}}],["20160323",{"1":{"737":1}}],["2016",{"1":{"155":1}}],["2017",{"1":{"15":1,"585":1,"770":1}}],["2000",{"1":{"975":1,"1036":1}}],["2000个",{"1":{"960":1}}],["2008",{"1":{"961":1}}],["200",{"1":{"297":3,"378":1}}],["2002",{"1":{"197":1}}],["2002发布之前所创建的代码",{"1":{"127":1}}],["200ms",{"1":{"64":1}}],["200ms前做一个",{"1":{"14":1}}],["20",{"1":{"63":1,"83":1,"191":1,"287":1,"297":3,"378":1,"384":1,"393":12}}],["20th",{"1":{"26":1}}],["2与3对游戏的框架要求比较高",{"1":{"15":1}}],["2",{"0":{"41":1,"52":1,"62":1,"67":1,"73":1,"79":1,"92":1,"95":1,"116":1,"119":1,"184":1,"491":1,"552":1,"567":1,"721":1,"749":1,"793":1,"796":1,"801":1,"805":1,"988":1,"994":1,"1033":1},"1":{"15":1,"22":2,"23":1,"50":1,"69":1,"88":3,"89":1,"96":3,"97":1,"103":1,"113":2,"115":1,"118":2,"119":1,"121":1,"126":2,"131":1,"172":1,"209":3,"213":2,"214":1,"220":1,"221":1,"224":1,"225":1,"266":1,"270":5,"275":1,"283":1,"290":1,"296":1,"297":2,"302":1,"304":1,"390":1,"449":5,"451":3,"452":1,"455":1,"528":4,"529":1,"544":1,"553":2,"554":1,"571":3,"618":1,"625":2,"701":1,"707":1,"712":1,"720":2,"721":5,"722":1,"739":1,"749":1,"795":2,"802":1,"803":1,"804":1,"810":1,"818":1,"823":8,"836":1,"841":2,"854":1,"920":1,"921":1,"926":1,"943":1,"952":1,"953":1,"954":2,"965":1,"971":1,"976":3,"979":1,"992":1,"998":1},"2":{"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1,"553":1,"554":1,"555":1,"556":1,"557":1,"558":1,"559":1,"560":1,"561":1,"562":1,"563":1,"722":1,"989":1,"990":1,"991":1,"992":1,"993":1,"994":1,"995":1,"996":1,"997":1,"998":1}}],["应当相应地执行一些代码",{"1":{"957":1}}],["应根据功用的不同",{"1":{"382":1}}],["应邀做客",{"1":{"295":1}}],["应用数据",{"1":{"1013":2}}],["应用快照",{"1":{"1013":1}}],["应用运行时所占用的内存体积也会增大",{"1":{"979":1}}],["应用收到请求后处理数据并渲染相应的返回页面给",{"1":{"581":1}}],["应用返回信息转发给",{"1":{"581":1}}],["应用以及接收",{"1":{"581":1}}],["应用程序包还可以从android",{"1":{"586":1}}],["应用程序",{"1":{"580":1,"858":1}}],["应用程序可以存取它们",{"1":{"574":1}}],["应用场景",{"0":{"91":1},"2":{"92":1,"93":1,"94":1,"95":1,"96":1}}],["应用始终在线",{"1":{"88":1}}],["应用图层蒙版是不能执行的",{"0":{"1":1}}],["应该做一些操作",{"1":{"997":1}}],["应该对这个功能有所帮助",{"1":{"971":1}}],["应该也能工作",{"1":{"968":1}}],["应该也是题主最关心的类型",{"1":{"15":1}}],["应该尽量不去更改",{"1":{"930":1}}],["应该尽量避免装箱",{"1":{"820":1}}],["应该取消勾选那些没有必要的格子",{"1":{"868":1}}],["应该是更有利的",{"1":{"824":1}}],["应该使用recttransform",{"1":{"642":1}}],["应该能够顺利通过这一层",{"1":{"218":1}}],["应该包含以下要点",{"1":{"218":1}}],["应该没有什么比直接调用函数本身更有性能优势的吧",{"1":{"175":1}}],["应该在客户端上进行调整",{"1":{"86":1}}],["应该在100帧击中a",{"1":{"15":1}}],["应该自己决定下一个包什么时候发",{"1":{"50":1}}],["应该还是demo阶段",{"1":{"15":1}}],["当entity触发了ontriggerenter事件会增加到这个列表中",{"1":{"1045":1}}],["当有多个变量时",{"1":{"1023":1}}],["当有角色攻击被动怪物",{"1":{"19":1}}],["当您离开块时",{"1":{"1023":1}}],["当数据在b系统被写入",{"1":{"992":1}}],["当sortinglayer跟sortingorder相同时",{"1":{"976":1}}],["当system",{"1":{"898":1}}],["当两个的renderqueue都在同一侧时",{"1":{"976":1}}],["当加载",{"1":{"971":1}}],["当实例化时",{"1":{"965":1}}],["当实体在小区域堆积严重时效率更差",{"1":{"110":1}}],["当序列化存储",{"1":{"965":1}}],["当进入",{"1":{"951":1,"971":1}}],["当调用",{"1":{"923":1}}],["当调用一个函数时",{"1":{"826":1}}],["当执行job时",{"1":{"920":1}}],["当执行完后卸载这个新的appdomain即可",{"1":{"707":1}}],["当job调度后",{"1":{"916":1}}],["当创建一个实体或者实体的原型发生变化时",{"1":{"905":1}}],["当创建一个充满值的新数组时",{"1":{"828":1}}],["当下次gc清理时会把它移除掉",{"1":{"898":1}}],["当它处理完对象4在freachable",{"1":{"898":1}}],["当dude类实现它时",{"1":{"896":1}}],["当处理器循环复制它并循环占有栈空间时将会非常耗资源",{"1":{"891":1}}],["当代码执行时",{"1":{"891":1}}],["当程序执行完方法",{"1":{"890":1}}],["当程序执行时",{"1":{"880":1}}],["当程序读入这个",{"1":{"452":1}}],["当最上面的盒子不再使用时",{"1":{"879":1}}],["当某一最上面的盒子里的代码执行完毕",{"1":{"879":1}}],["当某段il代码被第一次运行的时候",{"1":{"130":1}}],["当重新启用时",{"1":{"860":1}}],["当重复的值发生变化时",{"1":{"142":1}}],["当函数返回数组值时",{"1":{"828":1}}],["当请求一个新的内存块时",{"1":{"827":1}}],["当通过unity的c",{"1":{"823":1}}],["当这种情况不可避免时",{"1":{"819":1}}],["当这9个格子里的有玩家或者怪物的状态改变时",{"1":{"103":1}}],["当作",{"1":{"966":1}}],["当作为一个参数传递预定义的函数时",{"1":{"819":1}}],["当作if",{"1":{"281":1}}],["当闭包被传入sort函数时",{"1":{"818":1}}],["当给一个复杂计算分配临时的",{"1":{"817":1}}],["当给定一个屏幕坐标系中的位置",{"1":{"656":1}}],["当清除容器的值时不会释放分配给容器的内存",{"1":{"817":1}}],["当托管堆扩张时",{"1":{"814":1}}],["当分配一个对象时",{"1":{"813":1}}],["当另外的值被需要时",{"1":{"813":1}}],["当服务端发现造成伤害时",{"1":{"809":1}}],["当服务端的法术场时间到了进行destroy时",{"1":{"807":1}}],["当服务器更新到达时",{"1":{"75":1}}],["当服务器在发送更新的时候",{"1":{"69":1}}],["当服务器收到客户端命令并执行的过程中",{"1":{"47":1}}],["当服务器通知某个命令被接受并执行以后",{"1":{"43":1}}],["当法术场结算时检测到攻击目标时",{"1":{"807":1}}],["当技能前摇结束开始生效时",{"1":{"799":1}}],["当技能开始时",{"1":{"795":1}}],["当技能被强制打断时",{"1":{"793":1}}],["当满足以下两个条件时",{"1":{"760":1}}],["当待检测碰撞物体为两个时",{"1":{"759":1}}],["当动画播放时",{"1":{"751":1}}],["当射线碰到物体",{"1":{"750":1}}],["当敌人体积过大时",{"1":{"749":1}}],["当播放动画时",{"1":{"748":1}}],["当目标进入触发器时触发",{"1":{"748":1}}],["当group和collector比较少时",{"1":{"738":1}}],["当git服务器修改密码后",{"1":{"421":1}}],["当为视差使用透视相机时",{"1":{"737":1}}],["当初始化的时候都进行执行",{"1":{"717":1}}],["当hard",{"1":{"707":1}}],["当该进程消灭时",{"1":{"707":1}}],["当该点可填入瓦片id集合为空集时",{"1":{"210":1}}],["当此ui界面关闭时可以调用",{"1":{"701":1}}],["当资源",{"1":{"701":1}}],["当想要打开一个新场景时可以使用上述addressables提供的方法或者使用",{"1":{"698":1}}],["当存在多个时",{"1":{"695":1}}],["当所有的不透明物体都渲染完了再渲染这个",{"1":{"1036":1}}],["当所有对象画完后",{"1":{"898":1}}],["当所有对象都遍历过后没有标识的对象就会被清掉",{"1":{"131":1}}],["当所有节点",{"1":{"691":1}}],["当组件是",{"1":{"691":1}}],["当平台支持",{"1":{"688":1}}],["当中是不可重复也不可被外部修改的",{"1":{"965":1}}],["当中基本的坐标体系主要有下面这四种",{"1":{"841":1}}],["当中的坐标系和相关用法",{"1":{"840":1}}],["当中",{"1":{"668":1,"969":1}}],["当多个raycaster被使用的时候",{"1":{"662":1}}],["当鼠标按下并抬起的时候",{"1":{"657":1}}],["当在多个光源开启gpu",{"1":{"981":1}}],["当在执行drawcall操作后",{"1":{"981":1}}],["当在有collider的子节点都挂载onmouse或eventsystem事件的时候",{"1":{"655":1}}],["当在垃圾回收复制时候如果一块survivor不够时候",{"1":{"120":1}}],["当addfive",{"1":{"887":1,"891":1}}],["当anchor不重合时",{"1":{"640":1}}],["当a没有再被其他类引用",{"1":{"124":1}}],["当锚点全部重合时",{"1":{"640":1}}],["当构建应用程序包时",{"1":{"585":1}}],["当构建行为树的时候",{"1":{"276":1}}],["当空闲",{"1":{"575":1}}],["当配制好",{"1":{"537":1}}],["当步骤",{"1":{"455":2}}],["当子进程完成",{"1":{"455":1}}],["当子进程在执行",{"1":{"455":1}}],["当命令被传播到",{"1":{"445":1}}],["当一个函数返回一个长度为0的数组时",{"1":{"825":1}}],["当一个对象离摄像机越近",{"1":{"976":1}}],["当一个对象被释放时",{"1":{"813":1}}],["当一个对象到gc",{"1":{"116":1}}],["当一个hard",{"1":{"707":1}}],["当一个",{"1":{"444":1}}],["当可以进行分舵扩张时",{"1":{"382":1}}],["当地土壤的好坏会影响到药材的数量与品质",{"1":{"380":1}}],["当地的玩家会移动到新位置",{"1":{"84":1}}],["当总舵或分舵建造在有药材资源的地点时",{"1":{"380":1}}],["当门徒弟子的某项武功经验值较高时",{"1":{"380":1}}],["当门徒弟子安排有徒手方面的武功练习时",{"1":{"380":1}}],["当攻下对手门派的地盘或到了一个尚未被人控制的地点",{"1":{"380":1}}],["当场作画",{"1":{"296":1}}],["当成",{"1":{"282":1}}],["当判定为",{"1":{"275":1}}],["当判定为暗金或者绿色时",{"1":{"275":1}}],["当怪物等级qlvl≥物品成品qlvl时",{"1":{"275":1}}],["当怪物tc",{"1":{"275":1}}],["当装备从怪物身上掉落时",{"1":{"270":1}}],["当装备两把武器时可在一次攻击中击中两个敌人或者攻击一个敌人两次",{"1":{"244":1}}],["当生成器移到下一个房间",{"1":{"224":1}}],["当critical",{"1":{"224":1}}],["当counter为0时",{"1":{"115":1}}],["当5时",{"1":{"224":1}}],["当3或4时",{"1":{"224":1}}],["当1或2时",{"1":{"224":1}}],["当水体比例过高时",{"1":{"214":1}}],["当发生这样的暂停时",{"1":{"831":1}}],["当发生一致性冲突时",{"1":{"14":1}}],["当发现更新后记录矩阵存在空集便会回退",{"1":{"210":1}}],["当游标在正方形节点上时",{"1":{"210":1}}],["当游戏开始时或客户端在发生非常严重的数据包丢失时",{"1":{"82":1}}],["当游戏需要高速离散的准确性的时候",{"1":{"77":1}}],["当产生回退时",{"1":{"210":2}}],["当对应的",{"1":{"695":1}}],["当对最终生成图片存在外界约束时",{"1":{"207":1}}],["当对象2和4没有被程序引用要被gc清理时会发生什么情况",{"1":{"898":1}}],["当对象离开的时候",{"1":{"104":1}}],["当对象开始移动的时候",{"1":{"104":1}}],["当对象进入地图的时候",{"1":{"104":1}}],["当距离向量在梯度向量上的投影为反方向",{"1":{"197":1}}],["当距离向量在梯度向量上的投影为同方向",{"1":{"197":1}}],["当用户创建",{"1":{"169":1}}],["当设置了",{"1":{"167":1}}],["当每有一个新的http请求通过tcp协议或其他协议和服务器成功简历连接后",{"1":{"167":1}}],["当",{"1":{"155":1,"270":2,"575":1,"644":1,"657":1,"689":1,"693":1,"695":2,"931":1,"965":1,"968":1}}],["当线程进入lock后检查同步块的m",{"1":{"131":1}}],["当项目选择名字以mfc",{"1":{"127":1}}],["当编译器生成",{"1":{"127":1}}],["当角色",{"1":{"391":1}}],["当角色移动后通知aoi",{"1":{"109":1}}],["当角色a移动到角色b所在的格子",{"1":{"103":1}}],["当角色a在格子6中时",{"1":{"103":1}}],["当我发现我需要在flash中检测多边形碰撞时",{"1":{"782":1}}],["当我将屏幕分辨率切换为800",{"1":{"625":1}}],["当我切换到webgl平台进行项目生成的时候",{"1":{"592":1}}],["当我从一个城市到另一个城市时",{"1":{"287":1}}],["当我需要为我的小怪物们提供更多空间的时候",{"1":{"219":1}}],["当我使用msbuild使用",{"1":{"125":1}}],["当我知道我的位置的情况下",{"1":{"107":1}}],["当我们在",{"1":{"1036":1}}],["当我们在第二次轮到a系统的时候监测是否component被改动",{"1":{"992":1}}],["当我们删除entity",{"1":{"987":1}}],["当我们添加a组件的时候",{"1":{"987":1}}],["当我们进行复制时仅是复制了指针",{"1":{"896":1}}],["当我们把shoe改成引用类型时",{"1":{"896":1}}],["当我们执行下面的方法时",{"1":{"895":1}}],["当我们传递一个值类型变量时",{"1":{"891":1}}],["当我们调用一个方法时会发生以下情形",{"1":{"890":1}}],["当我们调用field的getvalue和setvalue的时候",{"1":{"15":1}}],["当我们使用值类型时",{"1":{"888":1}}],["当我们使用引用类型时",{"1":{"888":1}}],["当我们的程序所占内存到达临界值时",{"1":{"887":1}}],["当我们的代码执行一次方法调用",{"1":{"885":1}}],["当我们坐在车上向车窗外看时",{"1":{"724":1}}],["当我们观察星空时",{"1":{"724":1}}],["当我们要使用一个类库时",{"1":{"398":1}}],["当我们为输出模型布局时",{"1":{"209":1}}],["当我们打开optionsmanager的源代码时",{"1":{"173":1}}],["当我们需要使用options模式时",{"1":{"173":1}}],["当我们需要给新对象分配内存时",{"1":{"119":1}}],["当我们拿到一个对象时",{"1":{"105":1}}],["当我们有了快照",{"1":{"15":1}}],["当滚动发布到第80个实例时",{"1":{"89":1}}],["当切换到蓝色环境时",{"1":{"88":1}}],["当预测误差发生",{"1":{"84":1}}],["当预测不一样的时候",{"1":{"15":1}}],["当不满足这种情况的时候",{"1":{"77":1}}],["当使用这些时",{"1":{"824":1}}],["当使用这种技术的时候",{"1":{"76":1}}],["当使用闭包和匿名函数时",{"1":{"818":1}}],["当使用c",{"1":{"817":1}}],["当使用addressable异步加载spriteatlas的时候",{"1":{"705":1}}],["当使用",{"1":{"699":1}}],["当使用脚本直接改变大小后他的宽和高经过了运算使其分别为1500",{"1":{"645":1}}],["当使用权威服务器的时候",{"1":{"71":1}}],["当收到服务器的回复时",{"1":{"71":1}}],["当收到来自服务器的游戏状态更新的时候再将结果渲染出来",{"1":{"66":1}}],["当text叠在image上面",{"1":{"862":1}}],["当taskb持续状态时",{"1":{"278":1}}],["当t=350的时候",{"1":{"69":1}}],["当t",{"1":{"69":1}}],["当接收到新的游戏状态时",{"1":{"68":1}}],["当接收端收到第一个字节的时候",{"1":{"37":1}}],["当你调用instantiate时",{"1":{"965":1}}],["当你调用job的schedule方法后",{"1":{"924":1}}],["当你用这种方式构建游戏",{"1":{"944":1}}],["当你为一个实体添加一个",{"1":{"928":1}}],["当你使用终结器时一定要确保你确实需要使用它",{"1":{"898":1}}],["当你使用il2cpp后端构建unity项目的时候",{"1":{"593":1}}],["当你同时获取到",{"1":{"841":1}}],["当你有了较小的实体列表",{"1":{"768":1}}],["当你git",{"1":{"420":1}}],["当你想执行",{"1":{"950":1}}],["当你想在60fps下模拟火焰特效时",{"1":{"204":1}}],["当你想要升级到version2",{"1":{"88":1}}],["当你正在修改配置文件的时候",{"1":{"174":1}}],["当你写完书的时候",{"1":{"145":1}}],["当你创建一个项目",{"1":{"127":1}}],["当你插入的坐标是2的时候",{"1":{"107":1}}],["当你扣下扳机的时候他早就走远了",{"1":{"79":1}}],["当你需要时间和空间的准确性的时候",{"1":{"76":1}}],["当你在纽约而服务器在东京呢",{"1":{"64":1}}],["当你开枪的时候",{"1":{"59":1}}],["当客户端告知服务器他要往右动一格的时候",{"1":{"63":1}}],["当客户端有操作的时候及时的发送服务器",{"1":{"12":1}}],["当玩家松开按钮",{"1":{"793":1}}],["当玩家攻击其他玩家的时候",{"1":{"70":1}}],["当玩家按下向右的按钮",{"1":{"66":1}}],["当玩家被攻击的时候它还是会死掉",{"1":{"63":1}}],["当玩家施加攻击",{"1":{"17":1}}],["当前状态当然还没准备好绘制",{"1":{"951":1}}],["当前任务自身",{"1":{"878":1}}],["当前任务在当前帧内的耗时总时间",{"1":{"878":1}}],["当前任务在当前帧内进行过内存回收和分配的次数",{"1":{"878":1}}],["当前任务在当前帧内被调用的次数",{"1":{"878":1}}],["当前任务的时间消耗占当前帧cpu消耗的时间比例",{"1":{"878":1}}],["当前一个技能正在执行时新的技能调用启动",{"1":{"793":1}}],["当前运行在wsgi协议之上的web框架有bottle",{"1":{"578":1}}],["当前遇到的问题",{"0":{"571":1}}],["当前执行",{"1":{"509":1}}],["当前",{"1":{"456":2}}],["当前对象所位于的patch",{"1":{"102":1}}],["当前大部分玩家的网络延迟高于150ms",{"1":{"46":1}}],["当前客户端",{"1":{"15":1}}],["当需要使用datetimeoffset的date等字段的时候",{"1":{"31":1}}],["当第二个玩家进入该地图之后",{"1":{"17":1}}],["当第一个玩家进入该地图之后",{"1":{"17":1}}],["当时守望先锋的文章还没出",{"1":{"15":1}}],["当然disabled的",{"1":{"965":1}}],["当然具体情况具体分析",{"1":{"960":1}}],["当然你也不想使用",{"1":{"971":1}}],["当然你也可以删除你要请求的远程的凭证",{"1":{"420":1}}],["当然你不能在这时候继续",{"1":{"965":1}}],["当然你依然可以在层级任何位置添加",{"1":{"953":1}}],["当然引用类型只存放指针",{"1":{"885":1}}],["当然object就是system",{"1":{"882":1}}],["当然如何转变",{"1":{"841":1}}],["当然也包含转换过程中新增的",{"1":{"954":1}}],["当然也可以传入任一",{"1":{"947":1}}],["当然也可以用profiler",{"1":{"877":1}}],["当然也可以放在uicamera上面",{"1":{"663":1}}],["当然也增加了程序占用的内存",{"1":{"707":1}}],["当然最终结果的筛选规则会有更多",{"1":{"676":1}}],["当然除了graphic",{"1":{"675":1}}],["当然是我们的eventtrigger了",{"1":{"667":1}}],["当然可能某个时间点你会意识到不如最开始就使用ideclarereferencedprefabs",{"1":{"964":1}}],["当然可能有人会有这样的疑问",{"1":{"206":1}}],["当然可以",{"1":{"957":1}}],["当然可以同一顶帽子制作适配于不同种族的模型",{"1":{"848":1}}],["当然可以由",{"1":{"581":1}}],["当然我们可以继续使用魔法生成代码",{"1":{"968":1}}],["当然我们也可以在onmouse中使用input",{"1":{"653":1}}],["当然我们也可以平滑地将物体移动一段较长的距离",{"1":{"46":1}}],["当然我们的",{"1":{"536":1}}],["当然这样一个一个地画效率肯定是不能接受的",{"1":{"862":1}}],["当然这个说法很可能是和clr的实现相关的",{"1":{"707":1}}],["当然这个结果可能是成功合成贴图",{"1":{"207":1}}],["当然这是针对xp系统的",{"1":{"131":1}}],["当然会有人说我在每个格子之间用链表进行连接就可以了",{"1":{"107":1}}],["当然会看",{"1":{"97":1}}],["当然灯塔的格子大小划分要因地制宜",{"1":{"104":1}}],["当然快照更新同步频率都受到sv",{"1":{"82":1}}],["当然延迟半秒不仅仅是显而易见",{"1":{"64":1}}],["当然他们也是需要瞄准的",{"1":{"48":1}}],["当然没法避免",{"1":{"46":1}}],["当然还有其它的方法也可以完成这个功能",{"1":{"41":1}}],["当然世界的游戏系统有更多组件",{"1":{"41":1}}],["当然其他玩家发生了攻击",{"1":{"17":1}}],["当然",{"1":{"15":3,"34":1,"46":1,"47":1,"48":2,"63":1,"204":1,"451":1,"574":1,"724":1,"729":1,"756":1,"799":1,"825":1,"842":1,"971":1}}],["1做对比",{"1":{"992":1}}],["1mb",{"1":{"960":2}}],["1版本里",{"1":{"960":1}}],["1来回的值",{"1":{"944":1}}],["1parallax",{"1":{"737":1}}],["1s",{"1":{"537":1}}],["1备用",{"1":{"528":1}}],["1全抗",{"1":{"395":1}}],["1日",{"1":{"371":1}}],["1点击上方的pivot可以切换pivot的所在位置center",{"1":{"639":1}}],["1点",{"1":{"368":7}}],["1536901270",{"1":{"854":1}}],["15344",{"1":{"645":1}}],["1520729748",{"1":{"854":1}}],["15754187",{"1":{"617":1}}],["150",{"1":{"297":2,"384":1,"625":2}}],["150毫秒后",{"1":{"84":1}}],["15",{"1":{"296":1,"384":1,"390":1,"903":1}}],["1920",{"1":{"628":2}}],["192",{"1":{"287":1}}],["1998",{"1":{"137":1}}],["1是砖块",{"1":{"225":1}}],["1321401",{"1":{"617":1}}],["13",{"1":{"221":1,"295":1,"296":1}}],["17",{"1":{"195":1,"437":3}}],["147681650",{"1":{"812":1}}],["140",{"1":{"297":2}}],["14159",{"1":{"197":1}}],["14s",{"1":{"195":1}}],["14",{"1":{"191":1,"195":1,"296":1}}],["182",{"1":{"529":1}}],["18183",{"1":{"385":1}}],["180",{"1":{"297":2,"529":1}}],["18",{"1":{"155":1}}],["1也是有问题的",{"1":{"135":1}}],["1概要文件库",{"1":{"126":1}}],["1个技能包",{"1":{"97":1}}],["1上",{"1":{"92":1}}],["1在零点中方向重合",{"1":{"92":1}}],["1秒内",{"1":{"854":1}}],["1秒",{"1":{"86":1}}],["1秒的画面插值延迟10",{"1":{"83":1}}],["1开启",{"1":{"84":1}}],["1检查您的最终线性插值",{"1":{"83":1}}],["1的状态和input",{"1":{"69":1}}],["1的new",{"1":{"69":1}}],["1的输入之后",{"1":{"69":1}}],["1的输入请求",{"1":{"69":1}}],["1之后的所有缓存的操作都应用到",{"1":{"69":1}}],["1里的缓存状态",{"1":{"69":1}}],["1输入的拷贝丢弃掉",{"1":{"69":1}}],["12345",{"1":{"891":1,"892":1}}],["125",{"1":{"625":1,"943":1}}],["120",{"1":{"297":4}}],["1280",{"1":{"628":1}}],["128",{"1":{"195":2,"225":1,"287":1,"943":1,"960":1}}],["127",{"1":{"135":1,"943":1}}],["12这三个格子里的地图内容",{"1":{"103":2}}],["12",{"1":{"68":2,"74":1,"221":1,"290":1,"296":1,"477":1,"960":1}}],["114323",{"1":{"984":2}}],["116",{"1":{"529":2}}],["119",{"1":{"529":1}}],["1111111111每个模板由10x8",{"1":{"225":1}}],["11176575",{"1":{"131":1}}],["11l5000000",{"1":{"225":1}}],["11l0000000",{"1":{"225":1}}],["11p0000000",{"1":{"225":1}}],["1100000000",{"1":{"225":3}}],["11s",{"1":{"195":1}}],["11这9个格子里的内容",{"1":{"103":1}}],["11",{"1":{"63":2,"67":1,"68":2,"74":1,"191":1,"221":1,"287":4,"296":1,"437":1,"567":1}}],["117819",{"1":{"15":1}}],["16kb",{"1":{"943":1,"960":2}}],["160",{"1":{"297":3,"955":1}}],["160字节",{"1":{"97":1}}],["16个模板",{"1":{"225":1}}],["16是用两个字节表示一个字符",{"1":{"39":1}}],["16的编码单元是word",{"1":{"39":1}}],["16",{"1":{"39":1,"189":4,"190":1,"193":1,"195":1,"224":1,"770":1,"823":1,"960":1}}],["10far",{"1":{"737":1}}],["10depth",{"1":{"737":1}}],["1080由于设备的高为900所以会导致高度上的一部分不会被显示出来2",{"1":{"628":1}}],["1050ti",{"1":{"564":1}}],["10点气血值",{"1":{"395":1}}],["10元很好起手",{"1":{"373":1}}],["10元起手",{"1":{"372":1}}],["10只是中间普通的而已",{"1":{"372":1}}],["10日",{"1":{"371":1}}],["10套",{"1":{"287":1}}],["10的位置",{"1":{"737":1}}],["10的",{"1":{"210":1}}],["10的这个记录矩阵也是10",{"1":{"210":1}}],["10的矩阵",{"1":{"208":1}}],["107毫秒",{"1":{"111":1}}],["10",{"0":{"49":1},"1":{"22":1,"26":1,"48":1,"50":1,"63":7,"67":3,"74":3,"81":1,"88":1,"103":1,"220":1,"221":1,"296":1,"297":2,"384":1,"477":1,"567":1,"720":3,"941":1}}],["104",{"1":{"15":1}}],["101",{"1":{"15":1,"977":1}}],["103的帧逻辑",{"1":{"15":1}}],["1000",{"1":{"1036":1}}],["1000+的",{"1":{"941":1}}],["100的像素",{"1":{"627":1}}],["100的图片在任何的分辨率下都占用100",{"1":{"627":1}}],["1002",{"0":{"608":1}}],["100次负面效果会有一次极大的正面效果",{"1":{"294":1}}],["100",{"1":{"175":1,"297":2,"390":2,"625":1}}],["100运行的服务器的负载大概是tickrate",{"1":{"86":1}}],["1007",{"1":{"81":1}}],["100毫秒后",{"1":{"75":1}}],["100帧的操作",{"1":{"15":1}}],["100ms后又跳到",{"1":{"74":1}}],["100ms",{"1":{"14":1,"46":1,"64":1,"73":1,"79":1}}],["1和4是任何帧同步游戏都可以做的",{"1":{"15":1}}],["1",{"0":{"40":1,"61":1,"66":1,"72":1,"78":1,"94":1,"115":1,"118":1,"183":1,"288":1,"490":1,"552":1,"566":1,"748":1,"792":1,"795":1,"800":1,"803":1,"979":1,"985":1,"990":1,"1032":1},"1":{"15":1,"43":1,"50":1,"64":1,"69":3,"83":2,"84":1,"85":1,"88":3,"89":1,"91":1,"92":1,"96":2,"97":1,"113":3,"116":2,"118":2,"119":1,"120":2,"121":1,"126":2,"131":1,"181":1,"195":1,"209":4,"212":1,"213":1,"214":1,"220":1,"221":1,"224":1,"225":1,"266":1,"275":1,"283":1,"295":1,"296":1,"297":5,"302":1,"303":1,"304":1,"378":1,"385":1,"437":5,"449":4,"451":3,"455":1,"456":1,"476":2,"529":1,"553":2,"554":1,"571":3,"592":1,"594":1,"625":3,"628":2,"639":2,"645":1,"688":2,"701":1,"707":1,"726":2,"738":1,"739":1,"795":2,"802":1,"804":1,"810":1,"820":1,"823":4,"825":1,"836":1,"841":2,"850":1,"854":3,"903":2,"920":1,"921":1,"926":1,"943":5,"944":1,"951":1,"953":1,"975":1,"976":2,"980":1,"992":2,"998":1},"2":{"553":1,"554":1,"555":1,"556":1,"557":1,"558":1,"559":1,"560":1,"561":1,"562":1,"563":1,"801":1,"804":1}}],["1或少量几个指令",{"1":{"14":1}}],["对现有的对象进行销毁",{"1":{"1050":1}}],["对两个机器人进行同样的操作",{"1":{"1034":1}}],["对localplayer进行初始化",{"1":{"1013":1}}],["对自己的系统做了一些单元测试后",{"1":{"997":1}}],["对srp",{"0":{"983":1}}],["对实体来说是低开销的",{"1":{"929":1}}],["对实体的更改导致结构性更改",{"1":{"908":1}}],["对它们进行遍历",{"1":{"912":1}}],["对它们所调用的命令可能有成百上千",{"1":{"453":1}}],["对内存的增加是非常大的",{"1":{"849":1}}],["对游戏的影响最小",{"1":{"830":1}}],["对第二个多边形做同样的处理",{"1":{"784":1}}],["对单componet的matcher进行了缓存",{"1":{"739":1}}],["对此我们还有一些",{"1":{"737":1}}],["对此做了一些研究",{"1":{"534":1}}],["对复杂背景的支持",{"0":{"732":1}}],["对应材质球的",{"1":{"1036":1}}],["对应一个",{"1":{"961":1}}],["对应vertex",{"1":{"846":1}}],["对应顶点vertex",{"1":{"846":1}}],["对应可以得到dll中该类的构造函数的调用",{"1":{"714":1}}],["对应的shader中的渲染队列是transparent",{"1":{"976":1}}],["对应的上传地址",{"1":{"510":1}}],["对应的",{"1":{"507":1,"695":1}}],["对同一",{"1":{"699":1}}],["对同一个",{"1":{"697":1}}],["对就应的底层操作的引用记数会变成3",{"1":{"697":1}}],["对所有受到影响的group进行修改",{"1":{"738":1}}],["对所有的",{"1":{"695":1}}],["对所有射线检测成功的",{"1":{"692":1}}],["对结果进行",{"1":{"694":1}}],["对通用方法进行共享",{"1":{"592":1}}],["对你的",{"1":{"538":1}}],["对源码进行压缩",{"1":{"537":1}}],["对插件进行打包",{"1":{"536":1}}],["对插件源代码",{"1":{"535":1}}],["对用户的体验不太友好了",{"1":{"534":1}}],["对新的",{"1":{"455":1}}],["对外暴露api",{"1":{"398":1}}],["对外交涉",{"0":{"383":1}}],["对了",{"1":{"376":1,"785":1,"841":1}}],["对话",{"1":{"255":1}}],["对照组是根据水体与各种资源的比例随机采样地形",{"1":{"215":1}}],["对称的零和游戏",{"1":{"212":1}}],["对称性对抗游戏是指参与游戏的玩家所拥有的资源",{"1":{"212":1}}],["对称性对抗游戏简介",{"0":{"212":1}}],["对称差集",{"0":{"179":1}}],["对persistence的定义使用如下",{"1":{"204":1}}],["对包围着输入坐标",{"1":{"201":1}}],["对输入坐标使用求余运算符",{"1":{"199":1}}],["对预先配置的ip地址或终结点",{"1":{"167":1}}],["对c",{"1":{"131":1}}],["对client2来说",{"1":{"74":1}}],["对",{"1":{"129":1,"225":1,"453":1,"687":1,"691":1,"968":1}}],["对象都加上converttoentity",{"1":{"970":1}}],["对象都挂在上面",{"1":{"124":1}}],["对象转换为高性能",{"1":{"946":1}}],["对象这步操作会增加一些",{"1":{"940":1}}],["对象存储在一个",{"1":{"910":1}}],["对象表示",{"1":{"905":1}}],["对象2会被以常规模式清理掉",{"1":{"898":1}}],["对象5到原来3的位置",{"1":{"898":1}}],["对象3到2的位置",{"1":{"898":1}}],["对象3则是电视遥控器",{"1":{"898":1}}],["对象1是我们的电视",{"1":{"898":1}}],["对象1",{"1":{"898":1}}],["对象引用列表",{"1":{"898":1}}],["对象拥有一样的clipping",{"1":{"860":1}}],["对象物体",{"1":{"686":1}}],["对象处理本次请求",{"1":{"165":1}}],["对象决定了和文化相关的函数",{"1":{"155":1}}],["对象里除了类型对象指针还有实例字段",{"1":{"131":1}}],["对象类型指针从字面上就很容易知道跟类型有关",{"1":{"131":1}}],["对象被清除之后",{"1":{"118":1}}],["对象就会把自己作为空闲空间连接到空闲链表",{"1":{"115":1}}],["对象死去的时候才需要回收",{"1":{"114":1}}],["对象",{"1":{"104":3,"155":1,"165":2,"696":1,"707":1,"826":1,"831":1,"965":1}}],["对象从一个点到另一个店",{"1":{"104":1}}],["对象b是怪物",{"1":{"102":1}}],["对象a是玩家",{"1":{"102":1}}],["对玩家来说去理解诸如此类问题依然是一件很有趣的事情",{"1":{"80":1}}],["对几乎所有的玩家都是友好的",{"1":{"79":1}}],["对比服务器接收到包的时间以及延迟",{"1":{"56":1}}],["对每个顶点的梯度向量和距离向量做",{"1":{"197":1}}],["对每个玩家",{"1":{"47":1}}],["对每一个连接的客户端",{"1":{"41":1}}],["对于转换世界中的每个游戏对象",{"1":{"1054":1}}],["对于实体来说",{"1":{"929":1}}],["对于静态批处理",{"1":{"876":1}}],["对于动态批处理",{"1":{"876":1}}],["对于使用同一个材质的物体",{"1":{"876":1}}],["对于一些ui",{"1":{"861":1}}],["对于一个tickrate66服务器",{"1":{"86":1}}],["对于一个多字节数值",{"1":{"37":1}}],["对于mesh的readwrite属性是要求开启的",{"1":{"849":1}}],["对于metadata的填充",{"1":{"714":1}}],["对于合批要求挺多的",{"1":{"849":1}}],["对于新手来说我们经常使用一个相机就够了",{"1":{"841":1}}],["对于堆来说",{"1":{"831":1}}],["对于程序员来说",{"1":{"828":1}}],["对于枚举作为键的字典来说",{"1":{"822":1}}],["对于64位程序来说",{"1":{"814":1}}],["对于32位程序来说",{"1":{"814":1}}],["对于伤害结算来说",{"1":{"809":1}}],["对于纯根节点",{"1":{"805":1}}],["对于proxy端",{"1":{"805":1}}],["对于玩家控制的单位来说",{"1":{"802":1}}],["对于玩家a来说",{"1":{"801":1}}],["对于玩家avatar",{"1":{"801":1}}],["对于玩家的方向和速度可以瞬间改变的都不行",{"1":{"76":1}}],["对于技能",{"1":{"799":1}}],["对于buff也类似",{"1":{"798":1}}],["对于法术场的特效",{"1":{"798":1}}],["对于第一个子节点",{"1":{"795":1}}],["对于第一人称射击游戏",{"1":{"48":1}}],["对于循环技能玩家可以按住按钮一直释放",{"1":{"793":1}}],["对于下述抛小球入桶的案例",{"1":{"760":1}}],["对于旋转后的矩形",{"1":{"756":1}}],["对于包含着图案",{"1":{"753":1}}],["对于结构复杂元素较多的背景需要占用更多的性能",{"1":{"727":1}}],["对于有着复杂结构或是效果的滚动背景没有办法使用",{"1":{"726":1}}],["对于unity执行热更dll中的调用",{"1":{"716":1}}],["对于utf",{"1":{"39":1}}],["对于热更新dll",{"1":{"716":1}}],["对于ilruntime的反射基本就先研究到这儿",{"1":{"715":1}}],["对于ios为什么不能热更新",{"1":{"708":1}}],["对于dll文件的热更新",{"1":{"708":1}}],["对于节点对象",{"1":{"691":1}}],["对于",{"1":{"687":1,"695":2,"755":1,"858":1,"938":1,"964":1}}],["对于垃圾回收器这一点",{"1":{"591":1}}],["对于osx平台",{"1":{"590":1}}],["对于某些想体验最新版idea却暂时没法入正的开发者来说",{"1":{"553":1}}],["对于定频定压没有效果",{"1":{"551":1}}],["对于三种",{"1":{"451":1}}],["对于非绿色非暗金装备",{"1":{"271":1}}],["对于连接处",{"0":{"230":1}}],["对于这些边界情况",{"1":{"214":1}}],["对于自然区",{"1":{"214":1}}],["对于搜索算法的前进和回退",{"1":{"210":1}}],["对于记录矩阵的回退",{"1":{"210":1}}],["对于输入模型矩阵",{"1":{"209":1}}],["对于正方形瓦片来说就和上面的解释完全一致了",{"1":{"207":1}}],["对于任何ui组件",{"1":{"657":1}}],["对于任何字符编码",{"1":{"39":1}}],["对于任意组相同的输入",{"1":{"197":1}}],["对于asp",{"1":{"173":1}}],["对于a而言",{"1":{"15":1}}],["对于不同的代",{"1":{"122":1}}],["对于引用类型的域",{"1":{"111":1}}],["对于值类型的域",{"1":{"111":1}}],["对于对象在地图上的enter",{"1":{"105":1}}],["对于数据定位的hash算法仍然不变",{"1":{"96":1}}],["对于经常使用的数据",{"1":{"91":1}}],["对于快速移动的物体甚至几毫秒的误差也会导致几英寸的误差",{"1":{"85":1}}],["对于其他玩家没法做有效预测",{"1":{"84":1}}],["对于每次的访问都可以通过计算hash来求得hash值",{"1":{"91":1}}],["对于每100毫秒发送一次更新的服务器",{"1":{"75":1}}],["对于每一个玩家",{"1":{"47":1}}],["对于每一个周围的玩家",{"1":{"46":1}}],["对于发射导弹的武器",{"1":{"50":1}}],["对于把那条命",{"1":{"49":1}}],["对于高延时玩家来说",{"1":{"48":1}}],["对于即时击中武器",{"1":{"48":1}}],["对于大多数情况这是有效并合适的",{"1":{"976":1}}],["对于大型项目来说",{"1":{"839":1}}],["对于大部分玩家",{"1":{"48":1}}],["对于大端模式",{"1":{"33":1}}],["对于半条命",{"1":{"48":1}}],["对于半条命来说不可以这样做",{"1":{"45":1}}],["对于所谓的",{"1":{"46":1}}],["对于我们的游戏来说这样做奉献太大",{"1":{"45":1}}],["对于字符串型",{"0":{"39":1}}],["对于位数大于8位的处理器",{"1":{"33":1}}],["对于手机游戏里",{"1":{"17":1}}],["对于网络游戏",{"1":{"86":1}}],["对于网络不好的玩家",{"1":{"15":1}}],["对于网络好的玩家",{"1":{"15":2}}],["对于帧同步防外挂",{"1":{"15":1}}],["对timewrap",{"1":{"14":1}}],["对收集到的",{"1":{"12":1}}],["以选中它",{"1":{"1021":1}}],["以角色配置为例说明下述具体用法同样的item和character都可以拥有part",{"1":{"1010":1}}],["以控制",{"1":{"978":1}}],["以用于后面的",{"1":{"966":1}}],["以构建更多玩法",{"1":{"944":1}}],["以构建moonlight应用程序",{"1":{"126":1}}],["以",{"1":{"941":1}}],["以作重用然而",{"1":{"936":1}}],["以作备忘和学习",{"1":{"840":1}}],["以减少内存使用",{"1":{"872":1}}],["以减少over",{"1":{"860":1}}],["以此类推",{"1":{"847":1,"858":1}}],["以此达到记录数据库状态的目的",{"1":{"443":1}}],["以此达到整个数据变成有序",{"1":{"107":1}}],["以决定表面纹理贴图的位置",{"1":{"846":1}}],["以确保它真正减少了游戏的收集时间",{"1":{"830":1}}],["以法术场为例",{"1":{"807":1}}],["以玩家点击技能按钮开始释放技能为例介绍技能同步流程",{"1":{"803":1}}],["以玩着荣耀的王昭君大招为例子",{"1":{"776":1}}],["以我们游戏中战士普攻三段击为例",{"1":{"795":1}}],["以我常用应用为例",{"1":{"430":1}}],["以任一点为中心的矩形区域",{"0":{"774":1}}],["以较高抽象层次判断两个凸多边形是否碰撞",{"1":{"761":1}}],["以像素级别检测物体之间是否存在重叠",{"1":{"759":1}}],["以矩形中心为旋转轴",{"0":{"756":1}}],["以vstudio为例",{"1":{"746":1}}],["以实现纹理连续显示",{"1":{"726":1}}],["以表示addressable无法释放此实例使用",{"1":{"699":1}}],["以前是如何制作游戏的",{"0":{"940":1}}],["以前",{"1":{"615":1}}],["以前在openssl",{"1":{"476":1}}],["以达到减小发布后ipa包的尺寸的目的",{"1":{"603":1}}],["以便进行之后的实例化",{"1":{"1054":1}}],["以便后面的使用",{"1":{"906":1}}],["以便达到最优的性能",{"1":{"906":1}}],["以便被闭包中的实际代码所使用",{"1":{"818":1}}],["以便客户端请求能够触发",{"1":{"573":1}}],["以便该进程上下文中的后续调用可以对其进行访问",{"1":{"129":1}}],["以使用",{"1":{"536":1}}],["以正则表达式搜索",{"1":{"438":1}}],["以方便后续安装",{"1":{"438":1}}],["以列表形式列出所有path",{"1":{"424":1}}],["以项目目录为根目录",{"1":{"399":1}}],["以提高铸造房的等级",{"1":{"380":1}}],["以迅速提升阅读者该武功的经验值",{"1":{"380":1}}],["以月份为单位",{"1":{"373":1}}],["以5张脸来说",{"1":{"372":1}}],["以下皆为脑补",{"1":{"1019":1}}],["以下就是完整的过程",{"1":{"964":1}}],["以下就来介绍",{"1":{"453":1}}],["以下的伪代码有些偷懒",{"1":{"862":1}}],["以下的参考图只是表达概念",{"1":{"287":1}}],["以下一律使用aot缩写",{"1":{"588":1}}],["以下两种方法都行",{"1":{"524":1}}],["以下三个小节将分别讨论这三种保存模式",{"1":{"447":1}}],["以下小节就来介绍",{"1":{"446":1}}],["以下几个小节将详细地介绍这三个步骤",{"1":{"443":1}}],["以下数值都可能被一些暗金装备",{"1":{"384":1}}],["以下⼀样",{"1":{"378":1}}],["以下随意画",{"1":{"287":1}}],["以下是我们的结果",{"1":{"966":1}}],["以下是我们在水体占比过低与水体占比过高时生成的地图",{"1":{"214":1}}],["以下是其一些优点和不足的简要概述",{"1":{"786":1}}],["以下是基本的步骤",{"1":{"784":1}}],["以下是向量对象的部分实现",{"1":{"762":1}}],["以下是google",{"0":{"614":1},"2":{"615":1,"616":1}}],["以下是一些支持",{"1":{"946":1}}],["以下是一些帮助我理解分离轴定理算法的页面",{"1":{"789":1}}],["以下是一些参考资料包括文章和源码之类的",{"1":{"81":1}}],["以下是一个简短的",{"1":{"452":1}}],["以下是该过程的流程图",{"1":{"444":1}}],["以下是测试代码",{"1":{"175":1}}],["以揭露要扩张的土地",{"1":{"212":1}}],["以贴图合成为例",{"1":{"207":1}}],["以这些结构作为特征",{"1":{"207":1}}],["以接口的形式注入到",{"1":{"164":1}}],["以2",{"1":{"126":1}}],["以更好地控制资源",{"1":{"125":1}}],["以3",{"1":{"103":1}}],["以patch为单位",{"1":{"100":1}}],["以每秒20快照为例",{"1":{"83":1}}],["以告诉服务器其收到的带宽容量",{"1":{"82":1}}],["以66",{"1":{"82":1}}],["以上结论是通过",{"1":{"1040":1}}],["以上只是我工作中的一些小总结",{"1":{"983":1}}],["以上内容在",{"1":{"971":1}}],["以上和以下代码是完全等同的当然",{"1":{"967":1}}],["以上意味着",{"1":{"943":1}}],["以上的实现方式有个问题",{"1":{"800":1}}],["以上的相关配置可以点击",{"1":{"536":1}}],["以上",{"1":{"564":1}}],["以上就是",{"1":{"455":1}}],["以上就是一个简单的c",{"1":{"131":1}}],["以上情况之外",{"1":{"270":1}}],["以上公式",{"1":{"204":1}}],["以上代码当duetime设置为0的时候",{"1":{"161":1}}],["以上几个数值",{"1":{"103":1}}],["以上行为会导致两个重要的结果",{"1":{"78":1}}],["以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下",{"1":{"72":1}}],["以毫秒为单位表示预测过程中的延迟",{"1":{"50":1}}],["以100ms为时间窗口进行插值",{"1":{"46":1}}],["以后会有文章专门介绍",{"1":{"898":1}}],["以后会有文章专门介绍gc原理",{"1":{"898":1}}],["以后的文章里会介绍参数传递",{"1":{"885":1}}],["以后每次请求",{"1":{"420":1}}],["以后每次执行一个玩家命令预测完成后",{"1":{"43":1}}],["以后发送下一个更新包",{"1":{"50":1}}],["以后可能零散地再谈",{"1":{"15":1}}],["以服务器第一条消息作为起点进行预测得到下一帧状态",{"1":{"43":1}}],["以字节为单位编码的",{"1":{"39":1}}],["以备万一预测错误",{"1":{"15":1}}],["以及effects和reward",{"1":{"1043":1}}],["以及预测未执行的命令使用客户端使用服务端的快照时",{"1":{"1014":1}}],["以及用来接收服务器快照后",{"1":{"1014":1}}],["以及里面的",{"1":{"965":1}}],["以及相应",{"1":{"957":1}}],["以及相应的组件",{"1":{"945":1}}],["以及是非常有用了",{"1":{"955":1}}],["以及是否立即使用",{"1":{"233":1}}],["以及3个包含",{"1":{"952":1}}],["以及存储entities",{"1":{"947":1}}],["以及支持",{"1":{"941":1}}],["以及重叠了多少",{"1":{"784":1}}],["以及其lod",{"1":{"1010":1}}],["以及其他碰撞算法",{"1":{"783":1}}],["以及其它我们需要插值计算的数据",{"1":{"46":1}}],["以及供大家下载并使用的actionscript",{"1":{"782":1}}],["以及一些物理和其他的转换规则",{"1":{"1004":1,"1053":1}}],["以及一些判定比较精细的游戏",{"1":{"751":1}}],["以及一些基于quake3引擎和虚幻引擎的游戏",{"1":{"41":1}}],["以及当中类型的所有信息",{"1":{"710":1}}],["以及需要检测的层",{"1":{"684":1}}],["以及不同的block模式进行判断",{"1":{"676":1}}],["以及这个类型关联的处理函数",{"1":{"657":1}}],["以及让不同的协议被分配到不同的进程中",{"1":{"583":1}}],["以及在这些模式下",{"1":{"446":1}}],["以及参数的个数",{"1":{"445":1}}],["以及掉落概率",{"1":{"301":1}}],["以及心情",{"1":{"301":1}}],["以及战斗相关的buff",{"1":{"300":1}}],["以及招式将qe的提示改成左右键",{"1":{"251":1}}],["以及下面的房间",{"1":{"228":1}}],["以及充满陷阱的通道",{"1":{"221":1}}],["以及每个玩家与多少数量的玩家领土相邻",{"1":{"215":1}}],["以及随机数去搜索输出模型",{"1":{"208":1}}],["以及服务器是否已经启动",{"1":{"167":1}}],["以及服务器本身运行的开销",{"1":{"88":1}}],["以及有关算术和逻辑运算",{"1":{"127":1}}],["以及通知玩家移动的格子集合",{"1":{"103":1}}],["以及",{"0":{"90":1},"1":{"444":1,"457":1,"509":1,"634":1,"635":1,"636":1,"637":1,"687":1,"975":4,"977":1,"978":1}}],["以及的cl",{"1":{"86":1}}],["以及游戏中其它物体",{"1":{"46":1}}],["以及100帧各自的操作",{"1":{"15":1}}],["以及输入固定",{"1":{"11":1}}],["以指令数量",{"1":{"14":1}}],["以获得正确的当前状态",{"1":{"13":1}}],["并覆盖awake",{"1":{"1054":1}}],["并传入job",{"1":{"993":1}}],["并每帧循环池",{"1":{"984":1}}],["并切换渲染状态",{"1":{"980":1}}],["并经过计算变化到最终在世界空间中",{"1":{"979":1}}],["并",{"1":{"971":1}}],["并关联好相应的",{"1":{"969":1}}],["并能",{"1":{"969":1}}],["并从",{"1":{"966":1}}],["并得到正确的",{"1":{"964":1}}],["并得到最小的一个",{"1":{"689":1}}],["并期望",{"1":{"960":1}}],["并包含所有子对象",{"1":{"959":1,"1002":1}}],["并判断是否实现",{"1":{"957":1}}],["并没出现在",{"1":{"956":1}}],["并没有选择这样做",{"1":{"952":1}}],["并没有找到合适的输出模型",{"1":{"210":1}}],["并没有命中数据已存在的库",{"1":{"91":1}}],["并没有修改老版本的任何内容",{"1":{"88":1}}],["并获取到",{"1":{"949":1}}],["并声明相关变量",{"1":{"944":1}}],["并非100",{"1":{"942":1}}],["并非使用",{"1":{"604":1}}],["并取决于",{"1":{"940":1}}],["并解析了方块",{"1":{"940":1}}],["并提供内部状态",{"1":{"933":1}}],["并提高了插件的启动速度",{"1":{"534":1}}],["并允许你合适地创建和删除某些资源",{"1":{"931":1}}],["并添加到预定义的group中",{"1":{"917":1}}],["并避免cpu的缓存丢失ecs",{"1":{"909":1}}],["并给我们一个他们需要保留的东西列表",{"1":{"898":1}}],["并对",{"1":{"862":1}}],["并对其攻击结算",{"1":{"799":1}}],["并用它来选择你想保留的组件",{"1":{"969":1}}],["并用新的对象替换它们",{"1":{"832":1}}],["并用一个指针nextobjptr指到开始位置",{"1":{"131":1}}],["并注意profiler统计数据",{"1":{"831":1}}],["并检查profiler统计信息",{"1":{"830":1}}],["并检测是否有投影重叠",{"1":{"785":1}}],["并检测这两段投影是否重叠",{"1":{"784":1}}],["并找出它的法向量",{"1":{"784":1}}],["并都找不到任何的间隙",{"1":{"783":1}}],["并参看了一些代码示例后",{"1":{"782":1}}],["并因此被对应的collector收集到对应的reactive",{"1":{"742":1}}],["并未就绪",{"1":{"966":1}}],["并未被卸载",{"1":{"701":1}}],["并未真正的实例化",{"1":{"699":1}}],["并默认返回",{"1":{"691":1}}],["并设置好设计分辨率",{"1":{"628":1}}],["并设置github的pages为该分支",{"1":{"517":1}}],["并与有效的付款方式相关联",{"1":{"616":1}}],["并选择",{"1":{"586":1}}],["并希望手动安装应用程序到设备上",{"1":{"585":1}}],["并发存在",{"1":{"574":1}}],["并发送至服务器",{"1":{"84":1}}],["并增加以下的内容",{"1":{"536":1}}],["并讲解如何通过使用",{"1":{"534":1}}],["并更改了打包策略",{"1":{"534":1}}],["并更新所有的对象状态",{"1":{"82":1}}],["并更新客户端",{"1":{"79":1}}],["并重新计算视差相机的视角区域",{"1":{"737":1}}],["并重新计算裁剪平面",{"1":{"737":1}}],["并重新将其投入使用",{"1":{"89":1}}],["并重新将指令序列在基于回滚后的快照的基础上再",{"1":{"13":1}}],["并重启网络",{"1":{"494":1}}],["并执行",{"1":{"481":1}}],["并完成以下工作",{"1":{"455":1}}],["并根据系统将localplayer和character和player进行绑定",{"1":{"1012":1}}],["并根据此并行修改查询到的",{"1":{"944":1}}],["并根据内容还原出命令",{"1":{"452":1}}],["并根据约束矩阵更新记录矩阵",{"1":{"210":2}}],["并创建三个",{"1":{"444":1}}],["并全部替换成",{"1":{"438":1}}],["并以什么样的顺序进行绘制",{"1":{"862":1}}],["并以此为下一次悟出更强的武功作为基础",{"1":{"380":1}}],["并以这个位置为起始点进行插值",{"1":{"46":1}}],["并会因过度劳累而病到",{"1":{"380":1}}],["并命令父组合立即重启装饰器",{"1":{"283":1}}],["并命令父组合立即重启此装饰器",{"1":{"283":1}}],["并让父组合继续处理它的下一个节点",{"1":{"283":1}}],["并行",{"0":{"280":1}}],["并随机获得一些特殊属性",{"1":{"266":1}}],["并去除",{"1":{"251":1}}],["并计算最终值",{"1":{"236":1}}],["并尽可能保证水体与各种战略特征的资源逼近用户的设定",{"1":{"214":1}}],["并返回给",{"1":{"684":1}}],["并返回一个离当前屏幕最近的对象",{"1":{"656":1}}],["并返回第2步",{"1":{"210":1}}],["并返回0",{"1":{"197":1}}],["并集",{"0":{"177":1},"1":{"177":1,"903":1}}],["并使用createchunk创建给定原型",{"1":{"907":1}}],["并使用它显示背景贴图",{"1":{"726":1}}],["并使用常规的apk文件",{"1":{"586":1}}],["并使用该类处理用户请求",{"1":{"169":1}}],["并使用该参数在本地运行汽车物理",{"1":{"75":1}}],["并使用",{"1":{"168":1,"510":2,"957":1}}],["并把地址给到线程栈上的变量中",{"1":{"131":1}}],["并把所有当前对象中的非静态域复制到新对象中",{"1":{"111":1}}],["并在这些位置执行实例化",{"1":{"966":1}}],["并在它们的",{"1":{"950":1}}],["并在其中运行特定的",{"1":{"947":1}}],["并在内存中存储生成的本机代码",{"1":{"129":1}}],["并在此之前的快照之间内插",{"1":{"83":1}}],["并支持c",{"1":{"126":1}}],["并公开完整的c",{"1":{"126":2}}],["并不希望传达出",{"1":{"971":1}}],["并不能连锁地销毁相关联的entity",{"1":{"959":1,"1002":1}}],["并不能得到",{"1":{"959":1,"1002":1}}],["并不能继承",{"1":{"955":1}}],["并不一样",{"1":{"958":1,"1001":1}}],["并不优秀",{"1":{"947":1}}],["并不容易",{"1":{"945":1}}],["并不断生成的新垃圾",{"1":{"828":1}}],["并不需要完备的技能树信息",{"1":{"805":1}}],["并不会更新",{"1":{"1036":1}}],["并不会按照它们创建的顺序",{"1":{"917":1}}],["并不会把所有新的技能调用信息保存下来",{"1":{"793":1}}],["并不会带来卡顿和延迟感",{"1":{"15":1}}],["并不推荐频繁使用",{"1":{"701":1}}],["并不影响子控件的缩放",{"1":{"628":1}}],["并不执行",{"1":{"449":1}}],["并不是比scene",{"1":{"971":1}}],["并不是因为把技能作为实体才导致它的混乱",{"1":{"810":1}}],["并不是天30",{"1":{"371":1}}],["并不是说并行",{"1":{"280":1}}],["并不是说滚动发布不好",{"1":{"89":1}}],["并不完全合适用蓝绿发布来实现",{"1":{"88":1}}],["并进行测试",{"1":{"88":1}}],["并通过rpc",{"1":{"1013":1}}],["并通过了valve反作弊保护",{"1":{"85":1}}],["并通过客户端在游戏过程",{"1":{"55":1}}],["并确认命中",{"1":{"85":1}}],["并正确地检测命中",{"1":{"85":1}}],["并开始前进",{"1":{"84":1}}],["并尝试基于其已知的历史",{"1":{"83":1}}],["并且计算的模型顶点数量不宜太多",{"1":{"980":1}}],["并且记录每一个子模型的index",{"1":{"979":1}}],["并且你需要访问job使用的nativecontainer中的数据时",{"1":{"924":1}}],["并且把该方法的参数存放到当前线程栈里",{"1":{"885":1}}],["并且把对应编译好之后的文件上传到",{"1":{"510":1}}],["并且mask里面的图片不会和外面的图片合批",{"1":{"860":1}}],["并且mesh包含submesh",{"1":{"847":1}}],["并且蒙皮至人物头部的骨骼上",{"1":{"848":1}}],["并且它们的绘制关系是一一对应的",{"1":{"847":1}}],["并且它不能在不使用无参数构造器的时候",{"1":{"111":1}}],["并且知道每三个点构成一个三角图元",{"1":{"846":1}}],["并且可用于后续分配",{"1":{"827":1}}],["并且可能导致客户端的视图不规则跳动",{"1":{"84":1}}],["并且要求这个枚举器被装箱",{"1":{"823":1}}],["并且传递这个类的实例到字典的比较器中",{"1":{"822":1}}],["并且用于所有接受key的函数",{"1":{"822":1}}],["并且unity的垃圾回收器也不是世代的",{"1":{"820":1}}],["并且这些子模型共享材质",{"1":{"979":1}}],["并且这些对象被引用到该操作完成",{"1":{"815":1}}],["并且这个类的副本通过整数desireddivisor的值来初始化",{"1":{"818":1}}],["并且也不能被依靠",{"1":{"814":1}}],["并且也点到了一些实实在在的痛点",{"1":{"15":1}}],["并且没有足够的连续空间来容纳这个对象",{"1":{"813":1}}],["并且没有玩家在作弊",{"1":{"70":1}}],["并且性能会随着堆的扩张而降低",{"1":{"813":1}}],["并且通知客户端",{"1":{"807":1}}],["并且将其状态同步",{"1":{"805":1}}],["并且将结算结果通知客户端",{"1":{"803":1}}],["并且他可以自己调整层级",{"1":{"737":1}}],["并且还不能使用优化技术和其他想在mimpidreams中使用的透视相机的特性",{"1":{"737":1}}],["并且支持",{"1":{"721":1}}],["并且运行程序",{"1":{"717":1}}],["并且默认appdomain是不能被卸载的",{"1":{"707":1}}],["并且其",{"1":{"691":1}}],["并且设置了platform",{"1":{"972":1}}],["并且设置了",{"1":{"689":1}}],["并且当",{"1":{"687":1}}],["并且当前",{"1":{"456":1}}],["并且取其中的第一个并且进行事件触发",{"1":{"675":1}}],["并且触发",{"1":{"672":1}}],["并且gameobject和相机的距离决定了collider的层级",{"1":{"664":1}}],["并且需要baseinputmodule类型组件的协助才能工作",{"1":{"654":1}}],["并且physics",{"1":{"652":1}}],["并且希望这类反馈越多越好",{"1":{"594":1}}],["并且同样描述了一个新的",{"1":{"583":1}}],["并且越来越多的不遵循这种模式的协议逐渐成为web变成的标准之一",{"1":{"583":1}}],["并且配置https",{"1":{"550":1}}],["并且做对应的编译和上传",{"1":{"510":1}}],["并且保存这些状态所使用的命令数量",{"1":{"454":1}}],["并且尽量减少所使用的命令数",{"1":{"454":1}}],["并且永不过期",{"1":{"411":2}}],["并且永远不会停止任何正在运行的节点",{"1":{"283":1}}],["并且使用抛物线落到指定点的一个特殊动作",{"1":{"244":1}}],["并且每个回合仅代表激活体的一个请求执行",{"1":{"158":1}}],["并且选择名字以m",{"1":{"127":1}}],["并且部分支持c",{"1":{"126":1}}],["并且想要编译它们以输出",{"1":{"125":1}}],["并且在此段时间内",{"1":{"799":1}}],["并且在每个update周期通过接口updatemodules接口调用这些基本输入模块的updatemodule接口",{"1":{"654":1}}],["并且在通常情况下",{"1":{"451":1}}],["并且在15分钟后从内存中清除",{"1":{"411":1}}],["并且在整个部署中都不应更改",{"1":{"90":1}}],["并且在延迟增大的情况下",{"1":{"15":1}}],["并且漫长的过程",{"1":{"89":1}}],["并且风险较小",{"1":{"88":1}}],["并且不会",{"1":{"1022":1}}],["并且不会更新timedata结构",{"1":{"1013":1}}],["并且不改变车速",{"1":{"75":1}}],["并且不和别人的程序打交道",{"1":{"34":1}}],["并且绝大部分情况下",{"1":{"67":1}}],["并且处理很多中间状态",{"1":{"45":1}}],["并且",{"1":{"15":1,"88":2,"449":2,"652":1,"687":1}}],["并且我找到",{"1":{"15":1}}],["并可以回滚到任何一帧的状态",{"1":{"15":1}}],["并将结果存入",{"1":{"947":1}}],["并将当前内存块的空位补上",{"1":{"908":1}}],["并将渲染图元传递给gpu所以如果drawcall数量过多就会导致cpu进行大量计算",{"1":{"876":1}}],["并将另一个帧推入栈",{"1":{"858":1}}],["并将攻击信息发给客户端",{"1":{"807":1}}],["并将它们所指的块标记为",{"1":{"827":1}}],["并将它们投影到这个轴上",{"1":{"784":1}}],["并将它们进行平滑插值",{"1":{"203":1}}],["并将其layer设为minimap",{"1":{"1034":1}}],["并将其他所有对象移出该层",{"1":{"737":1}}],["并将其放在根节点下边",{"1":{"210":1}}],["并将返回的句柄做为参数",{"1":{"699":1}}],["并将存储在服务器上的",{"1":{"573":1}}],["并将存根修改为直接指向生成的本机代码",{"1":{"129":1}}],["并将编译好的文件上传",{"1":{"510":1}}],["并将各个参数从字符串文本转换为",{"1":{"444":1}}],["并将tc目录简化为一个数字等级",{"1":{"267":1}}],["并将该资源提供给",{"1":{"705":1}}],["并将该节点标为禁止通行",{"1":{"210":1}}],["并将该snapshot到",{"1":{"14":1}}],["并将游戏世界的信息发给客户端显示出来",{"1":{"41":1}}],["并将更新推送到所有的",{"1":{"12":1}}],["但static",{"1":{"979":1}}],["但spelunky完全不是这样",{"1":{"225":1}}],["但僅有",{"1":{"975":2}}],["但你得先拿到",{"1":{"970":1}}],["但你需要配置的其实是",{"1":{"969":1}}],["但你可以人工声明它",{"1":{"965":1}}],["但从",{"1":{"968":1}}],["但同时我也得到了",{"1":{"954":1}}],["但同时有一个",{"1":{"944":1,"1000":1}}],["但有",{"1":{"952":1}}],["但记住这个方块绘制效率极高",{"1":{"945":1}}],["但相信还是有很多人不知道原理的",{"1":{"889":1}}],["但后者不能查看drawcall的具体情况",{"1":{"877":1}}],["但打成一张大图就可以",{"1":{"861":1}}],["但却是我们最常用的坐标系",{"1":{"841":1}}],["但唯一的问题是",{"1":{"782":1}}],["但当检测碰撞的需求出现在我面前之后",{"1":{"782":1}}],["但当访问量增大",{"1":{"574":1}}],["但只有两个entities拥有positioncomponent",{"1":{"740":1}}],["但只使用其中一份",{"1":{"120":1}}],["但已经可能不是自己持有的那个entity了",{"1":{"739":1}}],["但缺点是发生背景移动时",{"1":{"727":1}}],["但此",{"1":{"721":1}}],["但精灵图集未绑定为默认图集",{"1":{"705":1}}],["但对于使用反射的库",{"1":{"604":1}}],["但对忠诚没有影响",{"1":{"382":1}}],["但使用第三方",{"1":{"604":1}}],["但他们不是必须的",{"1":{"592":1}}],["但他们的底材都是",{"1":{"273":1}}],["但好处是可以让c++编译器运行的更快",{"1":{"592":1}}],["但图的质量会更好",{"1":{"570":1}}],["但登录后",{"1":{"531":1}}],["但会被任何用户级或项目级设置覆盖",{"1":{"524":1}}],["但会消耗更多的服务器cpu资源",{"1":{"86":1}}],["但可以通过将颜色变化等变量加入常量缓冲器中实现",{"1":{"981":1}}],["但可以通过减小视图内插值延迟来减小",{"1":{"86":1}}],["但可自行定義",{"1":{"975":1}}],["但可被任何项目级的设置替代",{"1":{"524":1}}],["但新",{"1":{"453":1}}],["但性能确实是会非常好",{"1":{"945":1}}],["但性能也是最差的",{"1":{"451":1}}],["但性情乖戾",{"1":{"297":1}}],["但保存操作完成的快慢会影响写入操作的阻塞时长",{"1":{"451":1}}],["但",{"1":{"448":1,"567":1,"864":1,"966":1,"1023":2}}],["但也不会有额外的作用",{"1":{"952":1}}],["但也不是说客户端可以像没有中央服务器的p2p游戏完全自治",{"1":{"43":1}}],["但也有办法",{"1":{"385":1}}],["但实际上这会让",{"1":{"965":1}}],["但实际上它又只是一个光滑的平面",{"1":{"845":1}}],["但实际上无论是正是邪",{"1":{"383":1}}],["但实例还是developer",{"1":{"131":1}}],["但考虑到生产或练功的需要",{"1":{"382":1}}],["但非凡要注重",{"1":{"382":1}}],["但必须有足够的原料资源",{"1":{"380":1}}],["但假如你进行过厢房拆除或房主指定等改变",{"1":{"380":1}}],["但假象一种情况",{"1":{"70":1}}],["但要求linux内核在3",{"1":{"467":1}}],["但要提醒大家的是",{"1":{"381":1}}],["但要提醒一下的是",{"1":{"380":1}}],["但要记住java8以后",{"1":{"122":1}}],["但丸子真好吃",{"1":{"296":1}}],["但它是否和",{"1":{"968":1}}],["但它们可能会被反复地遇到",{"1":{"832":1}}],["但它有一条",{"1":{"785":1}}],["但它会掉出更多的东西",{"1":{"274":1}}],["但它并不依赖于visual",{"1":{"125":1}}],["但严格地说",{"1":{"273":1}}],["但我们玩家在日常口头交流时",{"1":{"267":1}}],["但我们要向下走",{"1":{"224":1}}],["但隐藏有带领它的精英怪的部分特殊属性",{"1":{"266":1}}],["但仍然是可以实现的",{"1":{"785":1}}],["但仍没有完全表现出自然噪声的不规律性",{"1":{"204":1}}],["但仍需要显示它们的运行情况",{"1":{"75":1}}],["但噪声效果不好",{"1":{"197":1}}],["但如果我们",{"1":{"971":1}}],["但如果你这时候使用",{"1":{"964":1}}],["但如果你想按照具体类型来转换呢",{"1":{"957":1}}],["但如果你继承了",{"1":{"950":1}}],["但如果内部所占内存空间太大",{"1":{"937":1}}],["但如果在第一个text下放一个透明的图片",{"1":{"862":1}}],["但如果没有间隙",{"1":{"784":1}}],["但如果抽取小数点后1位",{"1":{"197":1}}],["但如果",{"1":{"155":1}}],["但如果有很多个坐标比如1w个坐标",{"1":{"106":1}}],["但查找范围内的坐标就变的很困难了",{"1":{"107":1}}],["但由于并没有conversion",{"1":{"954":1}}],["但由于增加了redis4",{"1":{"95":1}}],["但由于怪物随机移动的范围较小",{"1":{"18":1}}],["但确实很实用",{"1":{"88":1}}],["但主要是由网络包的传输时间确定",{"1":{"82":1}}],["但需要更多的出口带宽",{"1":{"82":1}}],["但服务器永远不会发送比tickerate更多的更新或超过请求的客户端带宽限制",{"1":{"82":1}}],["但服务器知道这是他的头部在你当前客户端所在的位置",{"1":{"79":1}}],["但服务器知道血量只有10",{"1":{"63":1}}],["但不知为何点击",{"1":{"971":1}}],["但不想要按这样的方式来开发游戏",{"1":{"945":1}}],["但不",{"1":{"914":1}}],["但不是屏幕",{"1":{"759":1}}],["但不执行",{"1":{"449":1}}],["但不执行新的",{"1":{"449":1}}],["但不同的职位对门派的发展却有着不小的影响",{"1":{"381":1}}],["但不同游戏可以指定更新频率",{"1":{"82":1}}],["但不会升级到更高的版本",{"1":{"477":1}}],["但不会进入下一tick",{"1":{"278":1}}],["但不会超过更新tickrate",{"1":{"86":1}}],["但不影响超强",{"1":{"275":1}}],["但不能容忍实际网络延迟这么大的延迟",{"1":{"50":1}}],["但依然有着另一部分读者对此很感兴趣",{"1":{"80":1}}],["但即使是快速的游戏",{"1":{"76":1}}],["但这种模式提升了代码的扩展性",{"1":{"944":1}}],["但这两者某种程度上是互斥的",{"1":{"861":1}}],["但这些块将仅在短时间内使用",{"1":{"830":1}}],["但这些逻辑会提升了时间复杂度",{"1":{"107":1}}],["但这样需要告诉其他proxy播放什么动作",{"1":{"805":1}}],["但这样的缺点是",{"1":{"653":1}}],["但这样看起来会有抖动",{"1":{"74":1}}],["但这不是太大的问题",{"1":{"199":1}}],["但这是大家接受程度最高的解决方案了",{"1":{"79":1}}],["但这就是你要为此付出的代价",{"1":{"79":1}}],["但这并不会影响到服务器",{"1":{"67":1}}],["但这实际是最乐观的情况",{"1":{"64":1}}],["但在大多数代码中",{"1":{"858":1}}],["但在",{"1":{"695":1,"954":1,"969":1}}],["但在同一个gameobject上挂载多个脚本",{"1":{"655":1}}],["但在因特网上是没法接受的",{"1":{"42":1}}],["但在发生一致性冲突的情况下",{"1":{"13":1}}],["但更多的时候他们不得不面对高延迟和高丢包率",{"1":{"40":1}}],["但就有字节序问题了",{"1":{"39":1}}],["但是使用代码控制转换的时机",{"1":{"1054":1}}],["但是使用iconvertgameobjecttoentity无疑是更精简的方式",{"1":{"967":1}}],["但是请注意",{"1":{"1036":1}}],["但是只要它们的材质中给shadow",{"1":{"980":1}}],["但是只能闪避近战和远程攻击",{"1":{"385":1}}],["但是dynamic",{"1":{"980":1}}],["但是debugmessagesystem仍然收集着呢",{"1":{"742":1}}],["但是正如converttoentity名字所隐含的意义",{"1":{"971":1}}],["但是记得要dispose",{"1":{"970":1}}],["但是更加简洁和官方",{"1":{"969":1}}],["但是粒子没有上下弹跳是因为没有什么其他系统在使用它的localtoworld",{"1":{"968":1}}],["但是回忆一下linkedentitygroup和prefab",{"1":{"966":1}}],["但是结果是只有三个cubes",{"1":{"966":1}}],["但是强制被转换成了",{"1":{"957":1}}],["但是依托",{"1":{"955":1}}],["但是依然令人心惊胆战",{"1":{"89":1}}],["但是你可以看到",{"1":{"951":1}}],["但是你不应该在收到服务器回复之前直接更新玩家的血量",{"1":{"70":1}}],["但是方块却出现了",{"1":{"943":1}}],["但是存储数据超过默认大小也没关系",{"1":{"937":1}}],["但是他们都有同样的组件",{"1":{"905":1}}],["但是c并没有",{"1":{"904":1}}],["但是cpu和16xx显卡必须开启",{"1":{"570":1}}],["但是静态批处理可以通过合并网格来提高性能",{"1":{"877":1}}],["但是限制条件很少",{"1":{"876":1}}],["但是动态批处理有许多限制条件",{"1":{"876":1}}],["但是却叠在其它ui上面了",{"1":{"862":1}}],["但是其",{"1":{"861":1}}],["但是其他的玩家都是过去的",{"1":{"76":1}}],["但是不要忘记",{"1":{"854":1}}],["但是不能用来做判定比较严格的游戏",{"1":{"750":1}}],["但是不能限定这些线程只能在本appdomain内执行代码",{"1":{"707":1}}],["但是不能部分卸载assetbundle",{"1":{"701":1}}],["但是不能被映射",{"1":{"140":1}}],["但是通过网格合并",{"1":{"848":1}}],["但是从整体出发的话",{"1":{"848":1}}],["但是从可读性上",{"1":{"180":1}}],["但是和mesh不一样的是",{"1":{"847":1}}],["但是现在有一个要求是",{"1":{"847":1}}],["但是现在有了",{"1":{"503":1}}],["但是话又说回来",{"1":{"841":1}}],["但是当需要使用到多个视口的时候",{"1":{"841":1}}],["但是当项目构建后就不会再产生内存分配",{"1":{"815":1}}],["但是收集过程实际上需要大量的cpu时间",{"1":{"828":1}}],["但是枚举值始终是一个值类型",{"1":{"822":1}}],["但是尝试在低内存设备上运行时每分钟分配3",{"1":{"815":1}}],["但是托管堆找不到一块足够大的连续内存来适配这次分配",{"1":{"813":1}}],["但是可以根据entity关联的component将他们分组",{"1":{"906":1}}],["但是可能其中的部分或全部的可分配空间对象之间存在小的",{"1":{"857":1}}],["但是可能一部分或者所有这些可用空间是被分配对象间的小空隙",{"1":{"813":1}}],["但是可控性更强",{"1":{"15":1}}],["但是被释放的空间不会变成一个大的可用内存池的一部分",{"1":{"813":1}}],["但是没有实现具体的方法",{"1":{"1043":1}}],["但是没有垂直同步信号的到达",{"1":{"854":1}}],["但是没有unit可能有法术场",{"1":{"808":1}}],["但是没有设置raycast",{"1":{"657":1}}],["但是技能流程已经正式结束了",{"1":{"796":1}}],["但是技能真正的结算流程还没开始",{"1":{"796":1}}],["但是冲锋节点还包括了一个condition",{"1":{"795":1}}],["但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点",{"1":{"756":1}}],["但是postion没有进入攻击范围",{"1":{"749":1}}],["但是该实体已经没有了组件debugmessage",{"1":{"742":1}}],["但是group",{"1":{"738":1}}],["但是也有部分",{"1":{"1037":1}}],["但是也有一定的隐患",{"1":{"738":1}}],["但是也会发现如果全部实现了接口但是不实现的话可能会影响上层例如scrollview的监听",{"1":{"667":1}}],["但是为了使用此方法",{"1":{"728":1}}],["但是缺点就是只能处理简单的平铺背景",{"1":{"726":1}}],["但是此时由于assetbundle对应的",{"1":{"701":1}}],["但是此实例不是由addressable创建或者说在使用addressable创建时设置了",{"1":{"699":1}}],["但是与三次调用",{"1":{"699":1}}],["但是并不实例化它",{"1":{"697":1}}],["但是点击到窗口内部",{"1":{"657":1}}],["但是如果",{"1":{"971":1}}],["但是如果不能batch的ui元素叠在一块",{"1":{"862":1}}],["但是如果要冰火雷毒水电风魔奥术神圣",{"1":{"807":1}}],["但是如果父节点实现了ipointerdownhandler和ipointerclickhandler接口",{"1":{"657":1}}],["但是如果他在掩体附近",{"1":{"79":1}}],["但是如果他在移动的话",{"1":{"79":1}}],["但是相对的是自身的anchor关于",{"1":{"640":1}}],["但是相对的是自身的anchor",{"1":{"640":1}}],["但是会执行",{"1":{"914":1}}],["但是会影响其布局",{"1":{"628":1}}],["但是会有弟子一喊不爽就马上跑",{"1":{"372":1}}],["但是aot就不能使用了",{"1":{"598":1}}],["但是谁来分配客户端的请求连接和",{"1":{"581":1}}],["但是一旦访问量过大",{"1":{"581":1}}],["但是要与第三做个约定",{"1":{"573":1}}],["但是要持久化的数据是一段时间内的整个数据集的状态",{"1":{"442":1}}],["但是由于场景中所有符合该合批条件的渲染物体的信息每帧都要被重新创建",{"1":{"981":1}}],["但是由于我们预先把所有的子模型的顶点变换到了世界空间下",{"1":{"979":1}}],["但是由于我们无法检测到此操作",{"1":{"701":1}}],["但是由于程序集的静态变量仍然在各个appdomain中",{"1":{"707":1}}],["但是由于此接口过于耗时",{"1":{"701":1}}],["但是由于国内的网络环境",{"1":{"569":1}}],["但是由于怪物等级mlvl",{"1":{"275":1}}],["但是文档中使用方法写的有些模糊",{"1":{"553":1}}],["但是文档没有明确的说明",{"1":{"111":1}}],["但是我不清楚这是什么",{"1":{"965":1}}],["但是我们只需要使用最顶层的那个",{"1":{"965":1}}],["但是我们的",{"1":{"537":1}}],["但是我想这应该是最主要的几个了",{"1":{"788":1}}],["但是我之前也没有见过什么一本正经讲述生成",{"1":{"217":1}}],["但是领悟期间所得经验值没加六力",{"1":{"373":1}}],["但是6000就开始变脸了",{"1":{"372":1}}],["但是投资比率太不敷出",{"1":{"372":1}}],["但是留下了勾玉袋",{"1":{"296":1}}],["但是运气并没有变好",{"1":{"296":2}}],["但是需要对其增加格外的管理",{"1":{"699":1}}],["但是需要了解",{"1":{"271":1}}],["但是需要处理数据复制问题",{"1":{"142":1}}],["但是随机地图却不是那么容易生成的",{"1":{"217":1}}],["但是首先还是需要将问题重新描述一下",{"1":{"207":1}}],["但是本文的初衷是为了能够生2d游戏的地图",{"1":{"207":1}}],["但是实际上根本没有看起来那么复杂",{"1":{"206":1}}],["但是它们将被快速处理",{"1":{"830":1}}],["但是它们的",{"1":{"695":1}}],["但是它表示的是该recttransform对应的矩形的相关信息",{"1":{"642":1}}],["但是它可能会带来轻微的性能上的损失",{"1":{"174":1}}],["但是它不支持前面两者所支持的场景",{"1":{"174":1}}],["但是它不能跨范围通过代码的方式更改值",{"1":{"174":1}}],["但是它通过ioptionschangetokensource<>",{"1":{"174":1}}],["但是ioptionssnapshot<>没有",{"1":{"173":1}}],["但是ssl证书是以域名形式申请的",{"1":{"135":1}}],["但是事实上",{"1":{"130":1}}],["但是计算机是如何执行这个中间代码的",{"1":{"130":1}}],["但是hash算法也会面临容错性和扩展性的问题",{"1":{"91":1}}],["但是hangfire只能支持分钟及以上的定时任务处理原因在于hangfire用的是开源的",{"1":{"30":1}}],["但是再次访问redis数据库",{"1":{"91":1}}],["但是报文可以被截获修改然后发送到游戏服务器",{"1":{"85":1}}],["但是对象4并不被清理掉",{"1":{"898":1}}],["但是对组合component的matcher没有进行缓存",{"1":{"739":1}}],["但是对相关概念有了清晰理解以后再看也并不是那么困难",{"1":{"80":1}}],["但是对于shadow",{"1":{"980":1}}],["但是对于照相机移动方式来说",{"1":{"733":1}}],["但是对于涉及数据表结构变更等等不可逆转的升级",{"1":{"88":1}}],["但是对于时间和空间非常敏感的事件就会造成很大的问题",{"1":{"78":1}}],["但是对于一些对实时性要求很高的游戏",{"1":{"64":1}}],["但是还有一份并没有得到服务器返回的",{"1":{"69":1}}],["但是客户端知道服务器还需要将",{"1":{"69":1}}],["但是因为surface",{"1":{"982":1}}],["但是因为",{"1":{"971":1}}],["但是因为玩家一般也不会过分关注其他玩家的动作",{"1":{"804":1}}],["但是因为延迟",{"1":{"69":1}}],["但是因为预测错误a的操作",{"1":{"15":1}}],["但是紧接着",{"1":{"68":1}}],["但是服务器并不能直接运行",{"1":{"573":1}}],["但是服务器认为最新的坐标是",{"1":{"68":1}}],["但是服务器收到的时候已经是st4而服务器st2的时候boss发动了攻击",{"1":{"58":1}}],["但是大部分时候服务器是处理有效访问的",{"1":{"67":1}}],["但是直接用这种方法会让游戏的响应变得迟缓",{"1":{"65":1}}],["但是引入了一系列的难题和挑战",{"1":{"65":1}}],["但是什么事都没发生",{"1":{"64":1}}],["但是最重要最",{"1":{"62":1}}],["但是游戏是他的",{"1":{"62":1}}],["但是补偿了之后减少了延迟",{"1":{"57":1}}],["但是是使用",{"1":{"411":1}}],["但是是被加密的",{"1":{"411":1}}],["但是是在击中以后",{"1":{"48":1}}],["但是是不清晰的",{"1":{"0":1}}],["但是仍然有可能我们采样不到球在地面的点跟最高点",{"1":{"46":1}}],["但是每个包含生成时间的命令在客户端本地存起来并在预测算法中使用",{"1":{"43":1}}],["但是在编辑器时由于计算方法区别draw",{"1":{"979":1}}],["但是在编译时强制执行类型安全原则",{"1":{"822":1}}],["但是在一些特殊情况下",{"1":{"976":1}}],["但是在图像的连续性上势必打折扣",{"1":{"854":1}}],["但是在调用该函数时不会产生任何新的垃圾",{"1":{"828":1}}],["但是在构建好的项目中就不会",{"1":{"815":1}}],["但是在战斗中",{"1":{"811":1}}],["但是在运行逻辑上有很大的不同",{"1":{"795":1}}],["但是在touch",{"1":{"658":1}}],["但是在多人接入同一个服务器的时候就会发生",{"1":{"70":1}}],["但是在没有收到服务器确认之前他使用了药包",{"1":{"70":1}}],["但是在实际应用中效果差强人意",{"1":{"42":1}}],["但是在c语言中除了8bit的char之外",{"1":{"33":1}}],["但是开发者还是需要考虑网络延迟和其它网络特性",{"1":{"40":1}}],["但是utf",{"1":{"39":1}}],["但是这并不意味着这不是",{"1":{"942":1}}],["但是这样说易于理解",{"1":{"877":1}}],["但是这样做有个弊端",{"1":{"748":1}}],["但是这样会发现一个问题",{"1":{"106":1}}],["但是这些需求都异曲同工",{"1":{"219":1}}],["但是这个接口的实例又是谁呢",{"1":{"173":1}}],["但是这个方法也有一个很大的问题",{"1":{"107":1}}],["但是这个方法在其他方面也可以使用",{"1":{"70":1}}],["但是这种类型的组件确实是关联到",{"1":{"946":1}}],["但是这种方式有个问题",{"1":{"801":1}}],["但是这种方式有着明显的弊端",{"1":{"718":1}}],["但是这种方法难以理解和维护",{"1":{"111":1}}],["但是这种方法有个难以回避的问题",{"1":{"15":1}}],["但是这种操作方式不会造成adressables的引用记数发生变化",{"1":{"697":1}}],["但是这种策略会引发如下两个问题",{"1":{"91":1}}],["但是这就不属于我们要谈论的范围了",{"1":{"63":1}}],["但是这两个字节内部如何排序",{"1":{"39":1}}],["但是所做的转换是没有意义的",{"1":{"36":1}}],["但是跨平台进行网络数据通信时必须进行字节序转换",{"1":{"36":1}}],["但是",{"1":{"34":1,"63":1,"77":2,"90":1,"129":1,"130":1,"158":1,"173":1,"453":1,"455":1,"703":1,"707":1,"722":1,"828":2,"830":1,"831":1,"857":1,"858":1,"898":1,"910":1,"952":1,"957":1,"969":1}}],["但是坏处是",{"1":{"17":1}}],["但是思路",{"1":{"15":1}}],["但是逻辑是不会提前执行的",{"1":{"15":1}}],["但是网速慢的玩家不会卡到快的玩家",{"1":{"12":1}}],["有助于提升性能",{"1":{"1036":1}}],["有系统获得了写入权限",{"1":{"991":1}}],["有b无a",{"1":{"987":1}}],["有a无b",{"1":{"987":1}}],["有想一起进步的小伙伴可以加微信逛逛圈",{"1":{"983":1}}],["有非",{"1":{"951":1}}],["有如下一些",{"1":{"949":1}}],["有这样特殊的行为",{"1":{"932":1}}],["有其自己的",{"1":{"929":1}}],["有同样",{"1":{"928":1,"929":1}}],["有个资源是ui",{"1":{"901":1}}],["有个梯子可以爬到那",{"1":{"225":1}}],["有终结器的对象在创建时",{"1":{"898":1}}],["有必要提醒的是",{"1":{"885":1}}],["有必要写一个自定义的类实现iequalitycomparer接口",{"1":{"822":1}}],["有什么不正确的地方可以在评论告诉我",{"1":{"983":1}}],["有什么不同",{"0":{"879":1}}],["有什么不对的或者可以加强的请给我留言",{"1":{"842":1}}],["有相同材质和纹理的ui元素是可以batch的",{"1":{"862":1}}],["有多少个submesh",{"1":{"847":1}}],["有朋友做过测试",{"1":{"839":1}}],["有数组值的unity",{"0":{"824":1}}],["有两点需要考虑",{"1":{"818":1}}],["有两种批处理",{"1":{"876":1}}],["有两种方式可以得到三角图元",{"1":{"846":1}}],["有两种选项",{"1":{"721":1}}],["有两种典型情况",{"1":{"48":1}}],["有不错的讲解和代码示例",{"1":{"789":1}}],["有不同的处理方式",{"1":{"74":1}}],["有更多详细的表述以及很多很酷的示例",{"1":{"789":1}}],["有间隙",{"1":{"784":1}}],["有几个图层来管理",{"1":{"737":1}}],["有几个不支持的",{"1":{"604":1}}],["有利于尺寸受限的平台",{"1":{"721":1}}],["有兴趣的可以持续跟踪",{"1":{"715":1}}],["有以下几种比较流程",{"1":{"695":1}}],["有3个参数",{"1":{"661":1}}],["有33",{"1":{"225":1}}],["有三的关键点需要注意",{"1":{"819":1}}],["有三种模式",{"1":{"628":1}}],["有三台redis",{"1":{"91":1}}],["有了堆",{"1":{"879":1}}],["有了层级号之后",{"1":{"862":1}}],["有了上面的工作",{"1":{"734":1}}],["有了社区的帮助",{"1":{"594":1}}],["有了它",{"1":{"576":1}}],["有了这个东西",{"1":{"578":1}}],["有了这个",{"1":{"83":1}}],["有了这些信息",{"1":{"44":1}}],["有点倒退回",{"1":{"945":1}}],["有点类似禁用",{"1":{"958":1,"1001":1}}],["有点类似修改了实体的原型",{"1":{"905":1}}],["有点类似hl的做法",{"1":{"13":1}}],["有点像",{"1":{"575":1}}],["有就把它关了",{"1":{"563":1}}],["有",{"1":{"476":1,"581":1,"633":2,"931":2,"953":1,"970":1,"974":1,"1039":1}}],["有序集",{"1":{"454":1}}],["有需要再去开采",{"1":{"376":1}}],["有19",{"1":{"290":1}}],["有看到能用的我再补上",{"1":{"287":1}}],["有难度吗",{"1":{"287":1}}],["有村庄",{"1":{"287":1}}],["有山",{"1":{"287":1}}],["有田地",{"1":{"287":1}}],["有大海",{"1":{"287":1}}],["有关被disable的组件不会被foreach到",{"1":{"1004":1}}],["有关对象池的更多信息可以在",{"1":{"833":1}}],["有关字节码裁剪的",{"1":{"604":1}}],["有关完整详细信息",{"1":{"604":1}}],["有关此主题的详细信息",{"1":{"604":1}}],["有关",{"1":{"275":1,"756":1,"1053":1}}],["有时候可以以规则的帧间隔请求垃圾回收",{"1":{"830":1}}],["有时候声明文件在源码中",{"1":{"398":1}}],["有时候它们能从其名字的前缀",{"1":{"266":1}}],["有时候爬到梯子顶上旁边就没有这玩意",{"1":{"225":1}}],["有时你爬到一个梯子顶部",{"1":{"225":1}}],["有经验的spelunky玩家会一下认出这个",{"1":{"225":1}}],["有趣",{"1":{"219":1}}],["有生成这么多样本的劲",{"1":{"206":1}}],["有的技能树只有一个节点",{"1":{"805":1}}],["有的技能不能自己结束",{"1":{"793":1}}],["有的特效挂在场景里",{"1":{"798":1}}],["有的话直接运行",{"1":{"131":1}}],["有的时候我们想人为的控制每一次渲染",{"1":{"1033":1}}],["有的时候",{"1":{"89":1}}],["有人要问了",{"1":{"131":1}}],["有人可能有这样的疑问",{"1":{"45":1}}],["有可能策划需求做一个结算十次而且每次结算的参数都不同的法术场",{"1":{"801":1}}],["有可能身体的一部分已经进入攻击范围",{"1":{"749":1}}],["有可能有个小砖块让你落脚不用踩到尖刺",{"1":{"225":1}}],["有可能会出现需要同时处理",{"1":{"88":1}}],["有可能产生较大误差",{"1":{"46":1}}],["有着不确定的服务器更新和网络延迟",{"1":{"77":1}}],["有许多情况航位推是没法处理的",{"1":{"76":1}}],["有很多事可以去做",{"1":{"62":1}}],["有2种处理方法",{"1":{"46":1}}],["有一点要记住的是",{"1":{"891":1}}],["有一点需要注意",{"1":{"174":1}}],["有一些臭名昭著的算法",{"1":{"828":1}}],["有一些相对简单的技术来使托管堆内存分配降低",{"1":{"816":1}}],["有一些关于把icloneable从",{"1":{"111":1}}],["有一半是场景一半是ui",{"1":{"623":1}}],["有一定的时间",{"1":{"247":2}}],["有一种情况除外",{"1":{"76":1}}],["有一种方法可以改善这种情况",{"1":{"43":1}}],["有一个converttoentity",{"1":{"971":1}}],["有一个专门处理freachable",{"1":{"898":1}}],["有一个可选参数",{"1":{"699":1}}],["有一个",{"1":{"610":1}}],["有一个章节专门讲解了如何使用",{"1":{"536":1}}],["有一个最简单的办法就是",{"1":{"74":1}}],["有一个非常简单的解决方案",{"1":{"63":1}}],["有一个更简单的方式",{"1":{"15":1}}],["有一个致命的缺陷就是",{"1":{"12":1}}],["有些则真正拥有",{"1":{"952":1}}],["有些既有类已经实现了icloneable",{"1":{"896":1}}],["有些情况可以考虑人为增加层级从而减少drawcall",{"1":{"862":1}}],["有些特效挂在模型上",{"1":{"798":1}}],["有些技能的执行流程和行为树类似",{"1":{"795":1}}],["有些项目在发布新版本时",{"1":{"510":1}}],["有些被频繁操作的键",{"1":{"453":1}}],["有些地下城主可能想要用吊桥呀",{"1":{"219":1}}],["有些arm处理器还可以由硬件来选择是大端模式还是小端模式",{"1":{"33":1}}],["有些文章介绍的预测执行",{"1":{"15":1}}],["有图有真相",{"1":{"32":1}}],["有空另辟文章再细谈吧",{"1":{"15":1}}],["tw",{"1":{"850":1}}],["two",{"1":{"22":1,"188":2,"190":1,"192":1,"486":1,"489":1,"899":1}}],["tv",{"1":{"720":1}}],["tvos",{"1":{"720":1}}],["tls中的这些引用也会改变",{"1":{"707":1}}],["tls",{"1":{"707":1}}],["tutorial",{"1":{"512":1}}],["turns",{"1":{"191":1}}],["tsts中使用umd库",{"1":{"401":1}}],["tsts中使用类库",{"1":{"400":1}}],["ts在ts文件中使用该库",{"1":{"399":1}}],["ts",{"1":{"399":1}}],["ts社区都有声明文件",{"1":{"398":1}}],["tclearculling",{"1":{"737":1}}],["tc判定过程",{"1":{"275":1}}],["tc",{"1":{"271":1,"272":2,"275":1}}],["tc是一个包含了众多物品清单的多层目录",{"1":{"267":1}}],["tcp",{"1":{"37":1,"51":1,"467":1}}],["typora",{"1":{"504":1,"505":1}}],["typecache",{"1":{"1051":1}}],["type设置成streaming",{"1":{"867":1}}],["type设置成decompress",{"1":{"867":1}}],["type的getconstructor方法",{"1":{"714":1}}],["type才能继续使用反射接口",{"1":{"714":1}}],["type以及其nestedtypes",{"1":{"714":1}}],["type来直接获取热更新dll中的类",{"1":{"714":1}}],["typeof",{"1":{"484":1}}],["typesearch",{"1":{"398":1}}],["types",{"1":{"190":1,"225":1,"398":1,"488":2,"489":2}}],["type=repositorieshttps",{"1":{"81":2}}],["type",{"1":{"26":2,"187":1,"189":1,"488":1,"489":3,"571":1,"579":1,"707":2,"867":1,"975":2}}],["tyrant",{"1":{"217":1,"219":1,"220":4}}],["tg123",{"1":{"96":1}}],["tier中应相同",{"1":{"868":1}}],["tiers",{"1":{"868":1}}],["tiered=no",{"1":{"147":1}}],["tizen",{"1":{"720":2}}],["title",{"0":{"551":1,"843":1}}],["tinysubversions",{"1":{"225":2}}],["tilebase",{"0":{"1031":1}}],["tilemap",{"0":{"1030":1}}],["tile就像传统关卡编辑器里一样",{"1":{"225":1}}],["tile",{"0":{"1028":1},"1":{"225":3}}],["tiles",{"1":{"207":1,"225":1}}],["tips",{"0":{"87":1,"739":1},"1":{"863":1}}],["tickrate",{"1":{"86":1}}],["timeout",{"1":{"467":1}}],["time是单线程的",{"1":{"160":1}}],["timeline",{"1":{"81":1,"878":1}}],["times",{"1":{"22":1,"189":4,"191":2}}],["timed",{"1":{"22":1}}],["timer",{"1":{"22":2,"26":2}}],["time",{"0":{"73":1,"160":1},"1":{"15":2,"22":2,"28":1,"90":1,"131":1,"189":1,"191":2,"195":1,"489":1,"588":1,"709":1,"878":1,"1052":1},"2":{"161":1}}],["timewrap方案中建立snapshot是",{"1":{"14":1}}],["timewrap",{"0":{"13":1}}],["t2",{"1":{"51":1}}],["t1",{"1":{"51":1}}],["t0",{"1":{"51":1}}],["t结构中变量lerp",{"1":{"50":1}}],["tangents",{"1":{"869":1}}],["tangent",{"1":{"846":1}}],["tank",{"1":{"701":3}}],["targe",{"1":{"657":1}}],["targettexture上",{"1":{"1032":1}}],["targetframerate",{"1":{"855":1}}],["targetframerate是起作用的以上仅参考文档推测",{"1":{"855":1}}],["target",{"1":{"585":1,"657":3,"977":1}}],["target=http",{"1":{"412":1}}],["tags",{"0":{"485":1},"1":{"485":1,"1034":1}}],["tag",{"0":{"249":1},"1":{"510":2,"927":4,"944":1,"955":2,"966":2,"975":1}}],["table",{"1":{"195":1,"199":1}}],["take",{"1":{"193":1}}],["takes",{"1":{"25":1,"189":3,"194":1}}],["talking",{"1":{"187":1}}],["talk",{"1":{"90":1}}],["task",{"1":{"22":1,"27":1}}],["tasks",{"1":{"22":6}}],["temp",{"1":{"1022":1}}],["tempjob",{"1":{"1022":2}}],["templates",{"1":{"225":1}}],["template",{"0":{"148":1},"1":{"23":1}}],["terraformer",{"1":{"1011":3}}],["terser",{"1":{"537":1}}],["tech",{"1":{"1005":1}}],["technologies",{"1":{"666":1}}],["technique",{"1":{"489":1}}],["tensor",{"1":{"571":1}}],["tencent",{"1":{"532":1}}],["ten",{"1":{"191":1}}],["text组件会排在image组件之前渲染",{"1":{"862":1}}],["texture上",{"1":{"1032":1}}],["textures",{"1":{"844":1}}],["texture",{"0":{"845":1,"872":1},"1":{"206":1,"726":4}}],["text",{"1":{"39":2,"186":3,"828":1}}],["tell",{"1":{"25":1}}],["testplus",{"1":{"981":1}}],["test​",{"1":{"823":1}}],["tests",{"1":{"189":1,"194":1,"195":1}}],["testing",{"1":{"188":1,"193":1,"611":1}}],["testoptions类只有一个字符串属性name",{"1":{"172":1}}],["test",{"1":{"23":1,"189":1,"191":1,"195":1,"594":1,"823":2}}],["t",{"1":{"22":1,"25":2,"27":1,"28":3,"29":1,"68":2,"488":1,"862":1,"930":1,"965":2,"975":1}}],["thousands",{"1":{"189":2}}],["those",{"1":{"22":1,"186":1}}],["than",{"1":{"188":1,"189":1,"190":1,"191":2}}],["that",{"1":{"22":4,"24":2,"25":5,"26":4,"27":1,"28":3,"29":1,"184":1,"187":3,"188":4,"189":13,"190":1,"191":1,"192":3,"193":4,"195":4,"196":2,"486":1,"487":2,"488":2,"489":1,"571":2}}],["thread穿越到另外一个appdomain时",{"1":{"707":1}}],["thread当前对应appdomain引用以及softthread引用",{"1":{"707":1}}],["thread有thread",{"1":{"707":1}}],["thread访问到某个appdomain时",{"1":{"707":1}}],["thread只属于一个appdomain",{"1":{"707":1}}],["thread对象其实是个soft",{"1":{"707":1}}],["threading",{"1":{"707":1}}],["threads",{"1":{"527":1,"984":1}}],["thread",{"1":{"191":1,"707":4}}],["three",{"1":{"27":1,"196":1,"899":1}}],["through",{"1":{"27":1,"194":1,"471":1}}],["thinktecture",{"1":{"185":1}}],["things",{"0":{"487":1},"1":{"26":1,"28":1}}],["thisisdb",{"1":{"385":1}}],["this",{"1":{"22":5,"23":2,"24":1,"25":3,"26":1,"27":1,"28":4,"29":4,"90":3,"131":1,"173":1,"181":1,"187":2,"188":4,"189":6,"190":2,"191":3,"193":1,"195":2,"196":1,"197":1,"410":1,"486":2,"488":1,"489":3,"571":4,"585":1,"644":1,"737":1,"823":1}}],["theorem",{"0":{"761":1},"1":{"764":4,"789":1},"2":{"762":1,"763":1,"764":1,"765":1,"766":1,"767":1,"768":1,"769":1,"770":1}}],["then",{"1":{"90":2,"184":1,"571":1,"585":1,"662":1}}],["they",{"1":{"27":1,"90":2,"190":1,"662":1,"851":1}}],["them",{"1":{"26":1,"186":2,"191":2,"192":1,"193":1,"662":1}}],["therefore",{"1":{"851":1}}],["there",{"1":{"25":1,"26":1,"28":1,"186":1,"187":1,"189":2,"191":1,"193":1,"195":1,"196":1,"486":1,"489":1,"571":1,"585":1}}],["these",{"1":{"22":1,"186":1,"188":2,"190":1,"192":1,"193":1,"194":1,"486":1}}],["their",{"1":{"22":1}}],["the",{"0":{"26":1,"27":1,"1027":1},"1":{"10":2,"15":1,"22":10,"23":4,"24":8,"25":21,"26":16,"27":34,"28":6,"29":2,"90":13,"118":1,"121":1,"181":3,"183":1,"184":1,"186":6,"187":2,"188":8,"189":16,"190":3,"191":6,"192":2,"193":16,"194":1,"195":19,"196":5,"225":1,"485":2,"486":5,"487":5,"488":3,"489":7,"499":1,"527":1,"542":1,"544":1,"571":4,"585":2,"644":10,"662":2,"720":6,"737":1,"764":1,"817":2,"851":1,"863":1,"896":1,"1005":1}}],["touchcount",{"1":{"824":4}}],["touch",{"1":{"824":4}}],["touches",{"1":{"824":2,"864":1}}],["touches属性时",{"1":{"824":1}}],["touches这个api的行为与上述类似",{"1":{"824":1}}],["tony",{"1":{"789":1}}],["toby",{"1":{"737":1}}],["tooling",{"1":{"950":1}}],["tool",{"1":{"490":1}}],["took",{"1":{"196":1}}],["tostring",{"1":{"488":1}}],["top",{"1":{"195":1,"633":1,"636":2,"637":1,"641":1}}],["total",{"1":{"189":1,"878":1}}],["tower",{"1":{"104":2}}],["together",{"1":{"26":1,"644":1,"980":1}}],["to",{"0":{"182":1,"487":1},"1":{"15":1,"22":5,"23":1,"24":5,"25":7,"26":7,"27":7,"28":2,"29":2,"43":1,"81":1,"90":6,"131":1,"184":1,"185":2,"186":7,"187":4,"188":10,"189":11,"190":5,"191":7,"192":9,"193":17,"194":1,"195":9,"196":2,"471":1,"485":1,"486":1,"488":1,"489":2,"542":1,"567":1,"571":9,"585":7,"606":1,"607":1,"618":1,"644":2,"662":1,"720":1,"737":1,"851":1,"867":1,"953":1,"965":1,"968":1,"998":2,"1005":1},"2":{"183":1,"184":1,"185":1}}],["tr",{"1":{"951":1}}],["trees",{"1":{"767":2}}],["tree",{"1":{"701":8,"851":1}}],["tris并被hybrid",{"1":{"954":1}}],["tris是蓝色的背景所占用的",{"1":{"954":1}}],["tris",{"1":{"954":2,"971":1}}],["triangles信息",{"1":{"847":1}}],["triangle",{"1":{"846":1}}],["tries",{"1":{"25":1}}],["trigger",{"1":{"22":1}}],["triggers",{"1":{"22":1}}],["trygetvalue",{"1":{"822":1}}],["try",{"1":{"25":1,"193":1,"571":1,"823":2}}],["trying",{"1":{"24":1}}],["traits",{"1":{"1042":1}}],["trailing",{"0":{"14":1}}],["traces",{"1":{"1021":1}}],["traffic",{"1":{"191":1}}],["transparency",{"1":{"1041":1}}],["transparencysortmode",{"0":{"1038":1}}],["transparent",{"1":{"975":2,"976":1,"1036":1}}],["translation和rotation的转换",{"0":{"1016":1}}],["translation有效",{"1":{"968":1}}],["translation",{"1":{"765":1,"944":2,"971":1}}],["transforms",{"1":{"1016":1}}],["transform",{"0":{"944":1},"1":{"940":1,"941":1,"942":1,"944":2,"946":2,"952":2,"961":1,"965":2,"968":1,"969":1,"971":1,"977":3,"978":1,"1000":2}}],["transformpoint等坐标转换函数进行坐标转换",{"1":{"640":1}}],["transform属性",{"1":{"622":1}}],["transfer",{"1":{"193":1}}],["trans",{"1":{"111":1}}],["transexpv2",{"1":{"111":1}}],["transient",{"1":{"25":1,"28":1,"29":1}}],["transmission",{"1":{"15":1}}],["trunk",{"1":{"594":1}}],["true",{"1":{"693":1}}],["true或false",{"1":{"467":1}}],["truesync",{"1":{"15":1}}],["trusting",{"1":{"15":1}}],["限制最大可用连接数",{"1":{"167":1}}],["限制客户端的上行请求频率",{"1":{"82":1}}],["限制",{"1":{"12":1,"876":1}}],["执行instantiation",{"1":{"958":1,"1001":1}}],["执行顺序就变得很重要了",{"1":{"949":1}}],["执行同样上面的main",{"1":{"896":1}}],["执行下面的go",{"1":{"893":1}}],["执行下面的方法",{"1":{"885":1,"887":1}}],["执行行到dosomething",{"1":{"892":1}}],["执行节点的技能流程",{"0":{"796":1}}],["执行removedebugmessage",{"1":{"742":1}}],["执行其内部实现的loadassembly方法",{"1":{"711":1}}],["执行命令后会对",{"1":{"506":1}}],["执行完",{"1":{"891":1}}],["执行完成",{"1":{"891":1}}],["执行完成后",{"1":{"535":1,"887":1}}],["执行完后",{"1":{"503":1}}],["执行完毕之后",{"1":{"455":2}}],["执行以下命令安装",{"1":{"500":1}}],["执行以下命令启动",{"1":{"475":1}}],["执行如下命令",{"1":{"479":1,"480":1}}],["执行了以下命令",{"1":{"454":1}}],["执行了以下四条命令",{"1":{"454":1}}],["执行期间",{"1":{"450":1}}],["执行后报错解决",{"1":{"404":1}}],["执行低优先级代码stops",{"1":{"283":1}}],["执行阶段",{"1":{"242":1}}],["执行仍然限于单个线程",{"1":{"158":1}}],["执行",{"1":{"134":1,"403":1,"452":1}}],["执行它",{"1":{"131":1}}],["执行对象进入怪物视野的逻辑",{"1":{"102":1}}],["执行更新",{"1":{"89":1}}],["执行是一种消除这种延迟的方法",{"1":{"84":1}}],["执行运动补偿以后",{"1":{"47":1}}],["执行玩家命令",{"1":{"47":1}}],["执行玩家操作",{"1":{"43":1}}],["执行hlsdk中pm",{"1":{"43":1}}],["执行几帧后",{"1":{"15":1}}],["执行到100帧",{"1":{"15":1}}],["执行一次",{"1":{"13":1}}],["执行每一帧的时间是固定的",{"1":{"12":1}}],["执行收集到的所有",{"1":{"12":1}}],["改变renderer",{"1":{"980":1}}],["改变recttransform的pos",{"1":{"645":1}}],["改变recttransform的width",{"1":{"645":1}}],["改变recttransform的bottom3",{"1":{"645":1}}],["改变recttransform的top",{"1":{"645":1}}],["改变当前的",{"1":{"971":1}}],["改变",{"1":{"955":1}}],["改变正交尺寸是更自然的选择",{"1":{"737":1}}],["改进的消息系统",{"0":{"659":1},"2":{"660":1,"661":1}}],["改进的是",{"1":{"12":1}}],["改變",{"1":{"639":1}}],["改为你想要的名称",{"1":{"459":1}}],["改为掉落黄色品质的",{"1":{"275":1}}],["改成",{"1":{"1039":2}}],["改成绝对路径即可",{"1":{"399":1}}],["改成白色",{"1":{"2":1}}],["改",{"1":{"111":1}}],["与query的排除效果类似",{"1":{"995":1}}],["与quartz",{"0":{"30":1}}],["与gpu",{"1":{"982":1}}],["与栈类似",{"1":{"879":1}}],["与图片a可batch",{"1":{"862":1}}],["与底下的ui层级一样",{"1":{"862":1}}],["与基于数组的等价代码相比cpu性能差距依旧存在",{"1":{"823":1}}],["与之相关的是",{"1":{"759":1}}],["与之前说的将客户端的输入发送到客户端然后等待服务器的响应再在客户端做出反应",{"1":{"67":1}}],["与上传到开发者控制台的版本号相同",{"1":{"616":1}}],["与平台无关的线程",{"1":{"589":1}}],["与web应用",{"1":{"578":1}}],["与此同时",{"1":{"981":1}}],["与此同时出现了很多模块构建工具",{"1":{"536":1}}],["与此同时记录矩阵也要回退上一个圆形节点之后的操作",{"1":{"210":1}}],["与边框的交叉点",{"1":{"406":1}}],["与护甲和能量护盾一样",{"1":{"385":1}}],["与人为善本是处事之道",{"1":{"383":1}}],["与其它调用方法的另外一个区别在于",{"1":{"699":1}}],["与其同游+修为11",{"1":{"295":1}}],["与其等待服务器来更新自己的位置",{"1":{"84":1}}],["与场景等级无太大关系",{"1":{"265":1}}],["与椒盐噪声相比",{"1":{"214":1}}],["与java中",{"1":{"116":1}}],["与mid相邻的patch",{"1":{"102":1}}],["与near相邻的patch",{"1":{"102":1}}],["与常见的九宫格不同",{"1":{"102":1}}],["与增加的cl",{"1":{"86":1}}],["与本文相关性最高的文章如下http",{"1":{"81":1}}],["与服务器接收到来自客户端的数据包的时间做差值可以获得客户端在游",{"1":{"55":1}}],["与endian无关",{"1":{"39":1}}],["与",{"0":{"953":1},"1":{"12":1,"572":1,"575":1,"701":1,"754":1,"755":1,"756":1,"861":1,"937":1,"957":1,"971":1,"987":1,"992":1}}],["就说明component在此时至上一帧的某个时间点被写入",{"1":{"991":1}}],["就说明该component被修改了",{"1":{"991":1}}],["就绪的prefabentity了",{"1":{"969":1}}],["就我们目前所知",{"1":{"968":1}}],["就行了",{"1":{"965":1}}],["就行",{"1":{"964":1}}],["就做了这样的事儿",{"1":{"945":1}}],["就做最坏的打算",{"1":{"62":1}}],["就把它扔掉并继续去使用下一个盒子",{"1":{"879":1}}],["就首先要了解一下他的工作原理",{"1":{"876":1}}],["就没有必要设置帧率到60",{"1":{"860":1}}],["就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种",{"1":{"840":1}}],["就skill和buff的边界问题",{"0":{"811":1}}],["就返回true",{"1":{"751":1}}],["就要",{"1":{"862":1}}],["就要创建很多空子物体来设定trigger范围",{"1":{"748":1}}],["就要先理解它是怎么算出来的",{"1":{"644":1}}],["就叫jit",{"1":{"709":1}}],["就被自己扼杀了",{"1":{"709":1}}],["就被称之为time",{"1":{"73":1}}],["就只能访问堆上的引用项",{"1":{"827":1}}],["就只能卸载其appdomain",{"1":{"707":1}}],["就只会有一次消息广播了",{"1":{"19":1}}],["就使用",{"1":{"693":1}}],["就起到了阻挡的作用",{"1":{"689":1}}],["就无法在判断对ui的点击了",{"1":{"665":1}}],["就去搜索实现了ipointerclickhandler这个接口的控件",{"1":{"657":1}}],["就去执行input逻辑",{"1":{"73":1}}],["就来分析一下各个类型",{"1":{"656":1}}],["就引擎使用而言可以看成是",{"1":{"652":1}}],["就沒有",{"1":{"633":2}}],["就已经可以实现网站的功能了",{"1":{"577":1}}],["就代表这位门人弟子所需要进行这项工作的时间要求",{"1":{"382":1}}],["就必须建造多个兵器武场才能满足需要",{"1":{"380":1}}],["就必须建造多个徒手武场才能满足需要",{"1":{"380":1}}],["就必须建造相应数量的厢房供他们休息",{"1":{"380":1}}],["就必须显式地调用操作系统的接口",{"1":{"127":1}}],["就方便练下一阶武功",{"1":{"374":1}}],["就几乎都浸在练舞场和领悟室了",{"1":{"373":1}}],["就属于",{"1":{"273":1}}],["就变成了暗金物品",{"1":{"273":1}}],["就这样啦",{"1":{"220":1}}],["就能看到如下关系图cube",{"1":{"1000":1}}],["就能調整該物件在算繪結果的物件前後",{"1":{"975":1}}],["就能夠覆蓋原本結果",{"1":{"974":1}}],["就能将备份文件复制到redis安装目录下",{"1":{"441":1}}],["就能匹配的上",{"1":{"229":1}}],["就能在随机地图生成器中还原出所生成的地形",{"1":{"214":1}}],["就能解决服务节点少时数据不平均的问题",{"1":{"96":1}}],["就很容易设置它们了",{"1":{"737":1}}],["就很适合使用多组倍频叠加来模拟更自然的噪声",{"1":{"204":1}}],["就很难获得足够的反馈判断",{"1":{"45":1}}],["就调用了state",{"1":{"161":1}}],["就最近的情况来看",{"1":{"127":1}}],["就证明此对象是不可用的",{"1":{"116":1}}],["就算是你能完成这个链表的连接",{"1":{"107":1}}],["就算你在listenserver",{"1":{"83":1}}],["就可得到原问题的解",{"1":{"107":1}}],["就可以启用srp",{"1":{"982":1}}],["就可以给job一个真正的定义了",{"1":{"920":1}}],["就可以让这个job和其他job并行运行了",{"1":{"920":1}}],["就可以完成一次批处理",{"1":{"876":1}}],["就可以得出一些",{"1":{"862":1}}],["就可以得到一个有序的批次序列了",{"1":{"862":1}}],["就可以避免生成垃圾",{"1":{"832":1}}],["就可以经常使用数据的一个副本",{"1":{"826":1}}],["就可以了",{"1":{"746":1}}],["就可以执行对于的参数检验",{"1":{"715":1}}],["就可以由反向代理完整接受该请求",{"1":{"581":1}}],["就可以轻松地部署在不同的web",{"1":{"578":1}}],["就可以順利運行了",{"1":{"564":1}}],["就可以通过",{"1":{"467":1}}],["就可以还原",{"1":{"452":1,"454":1}}],["就可以建造药圃进行采药",{"1":{"380":1}}],["就可以",{"1":{"281":1}}],["就可以设置parent",{"1":{"264":1}}],["就可以进到下一个房间",{"1":{"225":1}}],["就可以表示为单元空间里的一个点了",{"1":{"197":1}}],["就可以标注出哪些对象是被使用的",{"1":{"124":1}}],["就可以理解的",{"1":{"103":1}}],["就可以删除version1",{"1":{"88":1}}],["就可以把负载均衡器",{"1":{"88":1}}],["就可以支持回滚",{"1":{"15":1}}],["就可以很方便地处理了",{"1":{"15":1}}],["就删除版本1正在使用的资源",{"1":{"88":1}}],["就完成了回滚",{"1":{"88":1}}],["就越容易做平滑处理",{"1":{"74":1}}],["就得抖动一次",{"1":{"74":1}}],["就当作它们已经正确执行",{"1":{"67":1}}],["就当作超时包丢弃",{"1":{"12":1}}],["就像上面演示的一样",{"1":{"897":1}}],["就像上一节介绍的一样",{"1":{"887":1}}],["就像用水杯不断的接水早晚会溢出一样",{"1":{"891":1}}],["就像管理床上的脏衣服",{"1":{"879":1}}],["就像是",{"1":{"828":1}}],["就像我们预期的一样",{"1":{"717":1}}],["就像我们序列化一个复杂的配置",{"1":{"15":1}}],["就像在玩单机游戏一样顺畅",{"1":{"65":1}}],["就更难了",{"1":{"45":1}}],["就需要一个命令缓冲区",{"1":{"876":1}}],["就需要有多少个material",{"1":{"847":1}}],["就需要不断进行铸造",{"1":{"380":1}}],["就需要同步给在这9个格子里的所有玩家",{"1":{"103":1}}],["就需要更大的提前量",{"1":{"45":1}}],["就需要从第一帧",{"1":{"15":1}}],["就开始按照与服务器相同的逻辑执行本地消息队列中的5个命令",{"1":{"43":1}}],["就用",{"1":{"41":1}}],["就拿上面的",{"1":{"34":1}}],["就将0x11放在低地址中",{"1":{"33":1}}],["就不能再中断job执行了",{"1":{"921":1}}],["就不能使用上面的方法解决了",{"1":{"726":1}}],["就不继续深入贴图了",{"1":{"715":1}}],["就不会再被父节点的监听处理",{"1":{"657":1}}],["就不会释放",{"1":{"116":1}}],["就不会很准确",{"1":{"74":1}}],["就不用消息广播进行同步了",{"1":{"18":1}}],["就不需要每个模块自己去实现自己的方法了",{"1":{"15":1}}],["就解决了大部分问题",{"1":{"15":1}}],["就执行操作",{"1":{"15":1}}],["就会发生",{"1":{"965":1}}],["就会报错",{"1":{"964":1}}],["就会在床上变臭",{"1":{"879":1}}],["就会在这个固定位置的周围走来走去",{"1":{"18":1}}],["就会至少多2个drawcall",{"1":{"862":1}}],["就会无故多许多drawcall",{"1":{"862":1}}],["就会增加drawcall开销",{"1":{"862":1}}],["就会被画在越底部",{"1":{"862":1}}],["就会一直等待并且无其他响应",{"1":{"835":1}}],["就会检测不到",{"1":{"750":1}}],["就会出现差错",{"1":{"750":1}}],["就会出现服务器暂停客户端请求",{"1":{"442":1}}],["就会范围false",{"1":{"750":1}}],["就会返回ture",{"1":{"750":1}}],["就会生效",{"1":{"689":1}}],["就会生成一个适合你自己app的privacy",{"1":{"607":1}}],["就会永远先出发ui上的事件",{"1":{"663":1}}],["就会利用射线检测寻找潜在的对象",{"1":{"656":1}}],["就会触发多次",{"1":{"655":1}}],["就会触发自动的",{"1":{"456":1}}],["就会新建一个用户名",{"1":{"422":1}}],["就会有应征者前来此处报道",{"1":{"380":1}}],["就会调用",{"1":{"167":1}}],["就会诱导玩家破解客户端",{"1":{"45":1}}],["就会尽量减少回滚",{"1":{"15":1}}],["就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧",{"1":{"15":1}}],["就是从后往前渲染",{"1":{"1037":1}}],["就是从前往后渲染",{"1":{"1037":1}}],["就是可以用来管理角色模型",{"1":{"1010":1}}],["就是可以通过",{"1":{"912":1}}],["就是character",{"1":{"1008":1}}],["就是component是否在提供的版本号之后的时间被更新",{"1":{"991":1}}],["就是你去掉移除对象的",{"1":{"955":1}}],["就是由",{"1":{"942":1}}],["就是由cpu向其中添加命令",{"1":{"876":1}}],["就是系统分配的",{"1":{"933":1}}],["就是用一个单独的相机",{"1":{"1041":1}}],["就是用户分配的",{"1":{"933":1}}],["就是用强类型的类来表达配置项",{"1":{"171":1}}],["就是设置对象需要的材质纹理等",{"1":{"876":1}}],["就是0",{"1":{"862":1}}],["就是合并网格",{"1":{"848":1}}],["就是视口坐标系的设置",{"1":{"841":1}}],["就是某人拿起一个石头",{"1":{"811":1}}],["就是取消技能在逻辑中的的概念",{"1":{"811":1}}],["就是抹除这个边界",{"1":{"811":1}}],["就是一个法术场每次结算可能使用不同的参数进行结算",{"1":{"801":1}}],["就是一种",{"1":{"509":1}}],["就是类似于龙之谷的操作方式",{"1":{"750":1}}],["就是当发生移动时",{"1":{"724":1}}],["就是第一部分的反射实例",{"1":{"716":1}}],["就是获取到一个il的解释器",{"1":{"715":1}}],["就是对maptype中存储的获取",{"1":{"715":1}}],["就是对每个操作指令的执行后保存一个状态快照",{"1":{"13":1}}],["就是根据不同的标识符来新建不同的存储结构",{"1":{"713":1}}],["就是继承自",{"1":{"695":1}}],["就是所在",{"1":{"695":1}}],["就是所谓的obstacle",{"1":{"225":1}}],["就是摄像机设置的渲染的所有层",{"1":{"684":1}}],["就是需要检测的",{"1":{"684":1}}],["就是定位",{"1":{"625":1}}],["就是垃圾收集器",{"1":{"591":1}}],["就是这样一个管家的存在",{"1":{"581":1}}],["就是这种后果",{"1":{"34":1}}],["就是实现",{"1":{"576":1}}],["就是握把请求参数发送给你",{"1":{"573":1}}],["就是来看看怎么编写",{"1":{"500":1}}],["就是致命破绽",{"1":{"377":1}}],["就是该节点后面的",{"1":{"283":1}}],["就是",{"1":{"283":1,"576":1,"684":1,"695":1,"713":1,"950":1,"1039":1}}],["就是观察某个变量",{"1":{"283":1}}],["就是两个不想干的node不断的执行",{"1":{"280":1}}],["就是每个ability都需要建立cost和cooldown的object",{"1":{"235":1}}],["就是每个模块",{"1":{"15":1}}],["就是走廊和房间选中同一个锁",{"1":{"229":1}}],["就是probabilistic",{"1":{"225":1}}],["就是前面所示的小蓝点",{"1":{"199":1}}],["就是将内存根据对象存活的周期划分为几块",{"1":{"122":1}}],["就是语法中变量作用域的相关内容",{"1":{"121":1}}],["就是通过冗余来解决问题",{"1":{"88":1}}],["就是准确的",{"1":{"41":1}}],["就是字符编码内部的字节序了",{"1":{"39":1}}],["就是尽量减少消息的广播",{"1":{"20":1}}],["就是gc",{"1":{"15":1}}],["就是给属性打attribute",{"1":{"15":1}}],["就是我们解决问题的方案",{"1":{"15":1}}],["就好像拿一块板子蒙着你的眼睛一样",{"1":{"0":1}}],["上次",{"1":{"991":1}}],["上次成功执行",{"1":{"449":2}}],["上方是",{"1":{"971":1}}],["上方有出口",{"1":{"224":1}}],["上进行移动",{"1":{"969":1}}],["上使用setenable",{"1":{"965":1}}],["上文例子中将所有的",{"1":{"956":1}}],["上文提到了会创建一个堆内存来存储多的数据",{"1":{"937":1}}],["上就如同",{"1":{"955":1}}],["上添加",{"1":{"953":1}}],["上构建了",{"1":{"951":1}}],["上几节已经介绍过当一个方法被调用时会产生的基本情况",{"1":{"890":1}}],["上每一个点精确对应到模型物体的表面",{"1":{"846":1}}],["上找到",{"1":{"833":1}}],["上调用接口函数需要把它们装箱",{"1":{"823":1}}],["上行",{"1":{"803":2}}],["上的",{"1":{"946":2,"965":1}}],["上的投影",{"1":{"780":1}}],["上的每个仓库都可以拥有一个",{"1":{"507":1}}],["上运动",{"1":{"756":1}}],["上边的案例实在编辑模式下执行的",{"1":{"737":1}}],["上述代码有几个需要解决的地方",{"1":{"761":1}}],["上述描述中的",{"1":{"701":1}}],["上述插值方法",{"1":{"46":1}}],["上产生的事件都会被舍弃",{"1":{"688":1}}],["上传文件",{"1":{"510":1}}],["上传文件速度简直不能忍",{"1":{"510":1}}],["上依次点击",{"1":{"509":1}}],["上访问敏感数据",{"1":{"509":1}}],["上安装过的最新",{"1":{"477":1}}],["上一节中介绍的",{"1":{"886":1}}],["上一节展示的",{"1":{"455":1}}],["上一部分我们了解了spelunky有4种基本房间类型",{"1":{"225":1}}],["上限为200",{"1":{"391":1}}],["上集市购买了一束纸花",{"1":{"296":1}}],["上下同理editorrenderdata",{"1":{"971":1}}],["上下都缩减了1806",{"1":{"645":1}}],["上下爬动",{"1":{"287":1}}],["上下左右四个点的颜色分别是",{"1":{"207":1}}],["上色",{"1":{"273":2,"275":2}}],["上级",{"1":{"251":1}}],["上执行蓝绿部署",{"1":{"88":1}}],["上玩游戏",{"1":{"83":1}}],["上面这些",{"1":{"966":1}}],["上面这个例子并不是",{"1":{"954":1}}],["上面引用的网络同步的例子中",{"1":{"933":1}}],["上面列表中的许多遍历方法都使用entityquery",{"1":{"912":1}}],["上面列举的四个命令在",{"1":{"443":1}}],["上面两个方法分别返回",{"1":{"687":1}}],["上面定义的",{"1":{"684":1}}],["上面是否有实现了ipointerdownhandler的接口的控件",{"1":{"657":1}}],["上面模板里的",{"1":{"225":1}}],["上面有个小缺口",{"1":{"225":1}}],["上面的声明过程实际上会调用",{"1":{"965":1}}],["上面的解释可能略显苍白",{"1":{"937":1}}],["上面的图显示了一个内存片段的例子",{"1":{"813":1}}],["上面的例子里传递了5个参数给il2cpp",{"1":{"592":1}}],["上面的6组噪声被称之为噪声的不同",{"1":{"204":1}}],["上面的两种实现并没有实质差别",{"1":{"202":1}}],["上面的代码",{"1":{"172":1,"823":1}}],["上面的处理方式对于回合制的游戏非常适合",{"1":{"64":1}}],["上面说的情况在单人游戏中不会出现",{"1":{"70":1}}],["上面讨论的例子里只讨论了移动",{"1":{"70":1}}],["上面提到的不一致并不明显",{"1":{"48":1}}],["上面提到的插值方法使用的时候",{"1":{"46":1}}],["上面提到的插值法",{"1":{"46":1}}],["上面描述的系统可以很自然地用于武器开火效果预测",{"1":{"44":1}}],["上图的结构中",{"1":{"952":1}}],["上图的例子是一个简化流程",{"1":{"12":1}}],["上图这些系统",{"1":{"944":1,"1000":1}}],["上图对象1",{"1":{"898":1}}],["上图并不上真正的内存运行情况",{"1":{"879":1}}],["上图为内存碎片化示例",{"1":{"857":1}}],["上图所示的梯度向量并不是完全准确的",{"1":{"197":1}}],["上图中可以看到",{"1":{"119":1}}],["上图中",{"1":{"12":1,"947":1}}],["上图中我们可以明显看到",{"1":{"11":1}}],["上",{"1":{"12":1,"465":1,"594":1,"841":1,"864":1,"899":1,"951":2,"961":1,"964":1,"969":1}}],["会创建一个conversionworld",{"1":{"1054":1}}],["会更新它的",{"1":{"1036":1}}],["会更平缓一点",{"1":{"57":1}}],["会给这个材质设置一个默认",{"1":{"1036":1}}],["会给删除",{"1":{"935":1}}],["会为prefab根据client和server添加各种组件ghost",{"1":{"1020":1}}],["会为ability加上不同的组件abilityautorifleauthoring",{"1":{"1006":1}}],["会打断什么类型一个技能可能会有多个触发button",{"1":{"1007":1}}],["会递归所有child",{"1":{"999":1}}],["会转换所有child",{"1":{"999":1}}],["会不参与加速",{"1":{"981":2}}],["会不参与合批",{"1":{"980":1}}],["会降低draw",{"1":{"980":1}}],["会缓存绘制命令",{"1":{"979":1}}],["会缺失",{"1":{"968":1}}],["会用到的东西",{"1":{"965":1}}],["会很快耗光这些预算",{"1":{"960":1}}],["会得到该",{"1":{"959":1,"1002":1}}],["会告知",{"1":{"958":1,"1001":1}}],["会同时实例化所有",{"1":{"958":1,"1001":1}}],["会迭代",{"1":{"957":1}}],["会变为",{"1":{"954":1}}],["会相对更加高效一点",{"1":{"952":1}}],["会占用多少",{"1":{"952":1}}],["会返回",{"1":{"946":1}}],["会返回一个从",{"1":{"944":1}}],["会返回一个",{"1":{"923":1}}],["会额外划分一个堆内存",{"1":{"937":1}}],["会加上",{"1":{"934":1}}],["会加载很多小模块",{"1":{"535":1}}],["会取所有key查询到的资源的",{"1":{"903":2}}],["会取第一个key查询到的资源",{"1":{"903":1}}],["会去先查询每一个地址",{"1":{"903":1}}],["会执行jit编译",{"1":{"885":1}}],["会自动给父实体添加child组件",{"1":{"1053":1}}],["会自动添加linkedentitygroup",{"1":{"965":1}}],["会自动被扔掉",{"1":{"879":1}}],["会自动创建一个",{"1":{"138":1}}],["会自我管理",{"1":{"879":1}}],["会构造一个通用值类型的枚举器来遍历值集合",{"1":{"864":1}}],["会构建一个默认的appdomain",{"1":{"708":1}}],["会影响批次处理",{"1":{"860":1}}],["会影响到事件传递的顺序",{"1":{"663":1}}],["会发生",{"1":{"965":1}}],["会发生这种情况",{"1":{"892":1}}],["会发生另一个潜在的问题",{"1":{"828":1}}],["会发现onmouse事件是一个独立的input",{"1":{"652":1}}],["会明确表明这些api有临时内存分配",{"0":{"824":1}}],["会清扫堆上的所有对象",{"1":{"813":1}}],["会每隔一段时间或是在每一个",{"1":{"742":1}}],["会移除entity身上所有的component",{"1":{"739":1}}],["会产生更多的draw",{"1":{"737":1}}],["会造成entity原型变化的操作不能在job里面执行",{"1":{"908":1}}],["会造成浪费",{"1":{"766":1}}],["会造成资源双份",{"1":{"704":1}}],["会造成人物移动后",{"1":{"620":1}}],["会阻挡",{"1":{"687":1}}],["会跟随者把这个事件包装成一个pointereventdata类型的参数送进来",{"1":{"657":1}}],["会和之前存下来的newpressd进行比较",{"1":{"657":1}}],["会依次地向父节点层层搜索",{"1":{"657":1}}],["会把所有带有同样",{"1":{"928":1}}],["会把它移除",{"1":{"898":1}}],["会把子节点所有的collider统一检测和处理",{"1":{"655":1}}],["会把他存在7z格式的文件夹例如上面旧会被存在scoop",{"1":{"437":1}}],["会遮挡事件的传递",{"1":{"652":1}}],["会生成一个供外部访问的链接",{"1":{"570":1}}],["会生成相同的地貌",{"1":{"214":1}}],["会让你很头疼",{"1":{"897":1}}],["会让你的插件有更小的体积",{"1":{"538":1}}],["会让玩家针对这个障碍来思考自己的策略",{"1":{"225":1}}],["会使用",{"1":{"537":1}}],["会先于",{"1":{"655":1}}],["会先对",{"1":{"535":1}}],["会先停止优先级较低的节点",{"1":{"283":1}}],["会查找",{"1":{"505":1}}],["会维持以下三个变量",{"1":{"456":1}}],["会调用一个信号处理函数",{"1":{"455":1}}],["会比平时阻塞更长时间",{"1":{"449":1}}],["会重置环境变量",{"1":{"428":1}}],["会引发一系列的问题",{"1":{"391":1}}],["会进入该场景",{"1":{"287":1}}],["会从行为树的激活任务中移除",{"1":{"277":1}}],["会在",{"1":{"934":1,"935":1}}],["会在堆上进行分配",{"1":{"864":1}}],["会在每一次循环中同步tick",{"1":{"277":1}}],["会在数据库中创建字段我们来看看生成的迁移表它时如何被添加到迁移dbcontext中的",{"1":{"141":1}}],["会将这些组件的改动反应到",{"1":{"944":1,"1000":1}}],["会将job的nativecontainer所有权还给主线程",{"1":{"924":1}}],["会将",{"1":{"592":1}}],["会将节点添加到该root下行为树的构建如下",{"1":{"276":1}}],["会将接收到得网络字节序进行转换",{"1":{"36":1}}],["会存储",{"1":{"258":1,"261":1,"262":1}}],["会存储必要数据",{"1":{"257":1}}],["会触发questgiver",{"1":{"253":1}}],["会问我们最后创建的那个房间",{"1":{"224":1}}],["会由于陆地单元格分布不均导致出生在不同规模大小的岛屿上的玩家能够得到的战略资源再度失衡",{"1":{"214":1}}],["会导致实体的组件数据需要复制到其他的内存块中",{"1":{"930":1}}],["会导致提交代码失败",{"1":{"421":1}}],["会导致修炼严重受挫",{"1":{"391":1}}],["会导致怠工",{"1":{"391":1}}],["会导致水体不够划分不出海岛地形",{"1":{"214":1}}],["会导致玩家移动顿挫",{"1":{"46":1}}],["会线性地增加代码执行时间",{"1":{"204":1}}],["会再次调用",{"1":{"169":1}}],["会立即调用",{"1":{"169":1}}],["会根据某些条件",{"1":{"1022":1}}],["会根据上面的计算公式重新计算得出width和height",{"1":{"645":1}}],["会根据用户请求声明的http协议版本",{"1":{"169":1}}],["会根据游戏的状态计算出一个hash值",{"1":{"15":1}}],["会有开火键和装弹键updateabilityownership系统",{"1":{"1007":1}}],["会有一个存放",{"1":{"929":1}}],["会有显著不同的托管堆内存分配量级的不同",{"1":{"819":1}}],["会有点点奇异",{"1":{"785":1}}],["会有更大的可能性失败",{"1":{"207":1}}],["会有类型的错误原因猜测",{"1":{"161":1}}],["会有明显的延迟感",{"1":{"84":1}}],["会被销毁",{"1":{"971":1}}],["会被",{"1":{"964":1}}],["会被带进",{"1":{"954":1}}],["会被加上一个",{"1":{"953":1}}],["会被禁用",{"1":{"585":1}}],["会被略过",{"1":{"448":1}}],["会被采光",{"0":{"352":1}}],["会被使用来判断请求使用的文化",{"1":{"151":1}}],["会被网络不好的玩家lock住",{"1":{"15":1}}],["会被网速快的玩家给秒了",{"1":{"12":1}}],["会直接影响到hash值",{"1":{"91":1}}],["会是一个比较麻烦的问题",{"1":{"88":1}}],["会消耗很多的cpu和bandwidth",{"1":{"73":1}}],["会出现莫名其妙的事情",{"1":{"702":1}}],["会出现时区问题",{"1":{"31":1}}],["会出现怪物静止",{"1":{"17":1}}],["会设置一个",{"1":{"12":1}}],["会对所有",{"1":{"12":1}}],["c就是a和b的法向量",{"1":{"781":1}}],["c点积",{"1":{"780":1}}],["cmera",{"1":{"688":1}}],["cmd",{"0":{"518":1}}],["cmdrate",{"1":{"86":1}}],["cmdrate命令速率",{"1":{"82":1}}],["cgi的一个扩展",{"1":{"575":1}}],["cgi只是接口协议",{"1":{"573":1}}],["cgi",{"0":{"572":1},"1":{"572":2,"573":3,"574":12,"575":1}}],["cgo",{"1":{"510":1}}],["ckpt如果显存不够的",{"1":{"568":1}}],["ckpt这个模型需要生成的图片在768",{"1":{"568":1}}],["cd",{"1":{"509":1}}],["cil",{"1":{"823":1}}],["circular",{"1":{"770":1}}],["circle",{"0":{"754":1},"1":{"770":1}}],["ci",{"1":{"509":1}}],["ctrl",{"1":{"459":1}}],["ceil",{"1":{"717":1}}],["ceil库来读取dll的pe信息以及当中类型的所有信息",{"0":{"711":1}}],["cecil库对进行c",{"1":{"717":1}}],["cecil库来读取dll的pe信息",{"1":{"710":1}}],["center",{"1":{"860":1,"975":2}}],["centergrid",{"1":{"228":1}}],["centos",{"0":{"548":1}}],["cells",{"1":{"225":1}}],["c=",{"1":{"153":2}}],["c++原生代码直接访问托管代码结构",{"1":{"589":1}}],["c++可以创建非托管程序",{"1":{"127":1}}],["c++",{"1":{"127":1,"223":1,"604":1,"940":1}}],["c++语言在x86平台下编写的程序跟别人的java程序互通时会产生什么结果",{"1":{"34":1}}],["c++语言编写的程序里数据存储顺序是跟编译平台所在的cpu相关的",{"1":{"34":1}}],["c++语言编写的程序里数据存储顺序是跟编译平台",{"1":{"33":1}}],["cpu进行的操作具体就是",{"1":{"876":1}}],["cpu需要向gpu发送很多内容",{"1":{"876":1}}],["cpu在传送资源信息给gpu时",{"1":{"861":1}}],["cpu核心温度超过100就会黑屏",{"1":{"551":1}}],["cpu寄存器指针",{"1":{"898":1}}],["cpu寄存器",{"1":{"131":1}}],["cpu",{"0":{"858":1},"1":{"127":2,"129":1,"878":1,"940":1,"942":1,"969":1,"975":1,"1037":1}}],["cpu消耗高",{"1":{"110":1}}],["cpu消耗小",{"1":{"110":1}}],["c都变成了被回收的对象",{"1":{"124":1}}],["c都应该被垃圾回收",{"1":{"124":1}}],["c的入口",{"1":{"124":1}}],["c被b引了",{"1":{"124":1}}],["cubeconverttoentity",{"1":{"971":1}}],["cubeinside",{"1":{"971":1}}],["cube和",{"1":{"968":1}}],["cubes",{"1":{"966":1}}],["cubemultiple",{"1":{"962":1}}],["cubehead",{"1":{"961":1,"963":1,"965":3,"1003":1}}],["cube",{"1":{"944":3,"953":5,"965":4,"966":2,"971":2,"1003":1}}],["cullingmask",{"1":{"737":1}}],["culling",{"1":{"737":1,"942":1}}],["cultureinfo",{"1":{"155":2}}],["cultures",{"0":{"155":1}}],["culture和",{"1":{"153":1}}],["culture中的一个",{"1":{"153":1}}],["culture",{"1":{"152":3,"153":3}}],["culture=es",{"1":{"152":3}}],["cursor",{"1":{"845":1}}],["curses",{"1":{"223":2}}],["curl",{"1":{"471":1}}],["curve下的float值的精度",{"1":{"866":1}}],["curve的值会用来计算前面代码里的u和v",{"1":{"197":1}}],["curveease",{"1":{"197":1}}],["curve",{"1":{"197":1,"866":1}}],["current",{"1":{"658":1,"823":4}}],["currentuiculture",{"1":{"155":1}}],["currentculture",{"1":{"155":2}}],["curaoi",{"1":{"103":1}}],["curaoi不是同一个格子",{"1":{"103":1}}],["curaoi为同一个格子",{"1":{"103":1}}],["customaxis",{"1":{"975":1}}],["customize",{"1":{"499":1}}],["customizing",{"1":{"140":1}}],["customise",{"1":{"27":1}}],["custom",{"1":{"25":1,"939":1}}],["cnnic中国互联网络信息中心",{"1":{"529":1}}],["cnblogs",{"1":{"131":2,"719":3}}],["cn",{"1":{"60":1,"103":1,"131":2,"499":1,"515":1,"533":1,"543":1,"606":1,"719":1,"723":1,"850":5}}],["cn102739608a",{"1":{"59":1}}],["cn102404279a",{"1":{"57":1}}],["cn101577715a",{"1":{"55":1}}],["csdn",{"1":{"850":3,"984":1}}],["csdn博客",{"1":{"631":1}}],["css",{"1":{"535":1,"581":1}}],["cs",{"1":{"425":1,"927":1,"930":1}}],["cs中",{"1":{"264":2}}],["cs然后中间件是中间件使用的是abprequestlocalizationmiddleware",{"1":{"156":1}}],["csharp中",{"1":{"739":1,"744":1}}],["csharp的引用",{"1":{"716":1}}],["csharp",{"1":{"126":1,"592":1,"747":2}}],["cs文件和其他文件",{"1":{"125":1}}],["cs文件和一个自定义项目文件",{"1":{"125":1}}],["cs文件",{"1":{"125":1}}],["csc",{"1":{"125":1}}],["cs这样的游戏",{"1":{"49":1}}],["csproj",{"1":{"23":1,"722":1}}],["c51则为大端模式",{"1":{"33":1}}],["capacity",{"1":{"960":1}}],["captive",{"1":{"28":1}}],["category",{"1":{"850":1}}],["catalog",{"1":{"210":1}}],["camera让其culling",{"1":{"1034":1}}],["camera并确保其culling",{"1":{"1034":1}}],["camera相机拍照分享",{"0":{"1033":1}}],["camera主相机clear",{"1":{"737":1}}],["camera的层级",{"1":{"663":1}}],["camera的模式和world",{"1":{"640":1}}],["camera",{"0":{"1037":1,"1038":1,"1041":1},"1":{"663":1,"684":4,"687":1,"688":1,"693":5,"694":2,"695":6,"737":4,"841":1,"975":7,"976":1,"977":2,"1037":1}}],["camera层级高于game",{"1":{"663":1}}],["camera上",{"1":{"592":1}}],["card",{"1":{"571":1}}],["care",{"1":{"189":1,"195":1}}],["cache这个文件夹特别大",{"1":{"526":1}}],["cache",{"1":{"411":1,"437":1,"486":1,"526":2,"527":1}}],["cause",{"1":{"193":2}}],["cases",{"1":{"186":1,"188":1,"189":1,"196":1}}],["case",{"1":{"186":1,"190":2,"191":1,"195":1}}],["caster",{"1":{"980":1}}],["casters使用不同的材质",{"1":{"980":1}}],["casters的渲染是个例外",{"1":{"980":1}}],["casting",{"0":{"760":1},"1":{"662":1}}],["cast",{"1":{"25":1,"189":1,"859":1}}],["call的同时会导致额外的cpu性能消耗",{"1":{"980":1}}],["call的数量",{"1":{"979":1}}],["call绘制多个模型",{"1":{"980":1}}],["call内绘制",{"1":{"980":1}}],["call调用之间并没有渲染状态的切换",{"1":{"979":1}}],["call数量是会显示减少了的",{"1":{"979":1}}],["call分别绘制每一个子模型",{"1":{"979":1}}],["callback",{"1":{"931":1}}],["callvirt指令在执行这个函数前在内存中发现idisposable",{"1":{"823":1}}],["callvirt",{"1":{"823":2}}],["calls之间的gpu设置成本无法参与加速情况对象不可以是粒子或蒙皮网格",{"1":{"982":1}}],["calls之间的gpu设置成本",{"1":{"982":1}}],["calls的数量",{"1":{"982":2}}],["calls我们介绍了和mimpi",{"1":{"737":1}}],["calls",{"1":{"194":1,"471":1,"877":1,"878":1,"980":1,"984":1}}],["call",{"1":{"27":3,"189":1,"191":1,"823":2,"877":1,"940":5,"941":1,"942":2}}],["called",{"1":{"26":1,"27":1,"911":1}}],["calling",{"1":{"25":1,"720":3}}],["canvasrenderer",{"1":{"977":3}}],["canvasgroup",{"1":{"691":3}}],["canvasgraphics",{"1":{"688":1}}],["canvas",{"0":{"626":1},"1":{"656":2,"686":2,"687":5,"688":1,"689":1,"691":2,"695":8,"756":1,"759":8,"770":1,"860":1,"956":1,"977":8,"978":3},"2":{"627":1,"628":1,"629":1}}],["candidate",{"1":{"214":1}}],["cannot",{"1":{"131":1,"190":1,"980":1}}],["can",{"1":{"22":5,"23":1,"25":2,"26":1,"27":4,"28":5,"90":1,"186":2,"187":1,"188":1,"189":2,"191":3,"192":1,"193":2,"195":1,"488":3,"489":2,"585":2,"965":1}}],["chunk检查",{"0":{"990":1}}],["chunks",{"1":{"928":1,"952":1,"960":1,"965":1}}],["chunk",{"1":{"911":1,"927":2,"929":3,"942":3,"943":3,"944":1,"945":1,"952":4,"955":1,"960":6,"961":1,"966":2,"971":2}}],["child和相关组件会根据parent组件在一轮",{"1":{"965":1}}],["child",{"1":{"952":3}}],["chi",{"1":{"587":1}}],["chinaz",{"1":{"490":1}}],["characters",{"1":{"1011":1}}],["character",{"0":{"1009":1}}],["char",{"1":{"881":1,"1011":1}}],["chan的子对象",{"1":{"1034":1}}],["chan",{"1":{"1034":1}}],["channel",{"1":{"845":1}}],["changefilter",{"0":{"995":1}}],["change",{"1":{"192":2,"195":1,"585":1,"998":1}}],["changes",{"1":{"181":2,"1052":1}}],["champion",{"1":{"266":1}}],["challenge型任务",{"1":{"254":1}}],["choose",{"1":{"195":1,"585":1}}],["chose",{"1":{"23":1}}],["chrome",{"1":{"181":1}}],["chrome浏览器可以再语言里设置",{"1":{"154":1}}],["chest",{"1":{"221":1}}],["check这三个参数加入il2cpp",{"1":{"592":1}}],["checks",{"1":{"592":1}}],["checked",{"1":{"571":1}}],["checkbox",{"1":{"571":1,"585":1}}],["checkgameplaytags",{"0":{"240":1}}],["check",{"1":{"26":1,"571":2,"585":1}}],["cheat",{"1":{"15":1}}],["credentials",{"1":{"419":1}}],["credential",{"0":{"414":1,"415":1,"416":1},"1":{"411":1,"412":1,"414":1,"415":1,"416":1},"2":{"415":1,"416":1,"417":1}}],["creation",{"1":{"939":1}}],["creating",{"0":{"24":1,"25":1,"27":1},"1":{"22":2,"26":1,"27":1,"489":1}}],["createplayerentity",{"1":{"1012":1}}],["createentity",{"1":{"961":1}}],["createadditionalentity",{"1":{"961":1}}],["createlistofrandomnumbers",{"1":{"818":2}}],["createinstance方法来创建一个相同类型的新对象",{"1":{"111":1}}],["created",{"1":{"23":1,"25":1,"28":1,"193":1}}],["create",{"1":{"22":1,"25":4,"26":1,"27":1,"28":2,"183":1,"191":1,"489":1,"510":1}}],["cross",{"1":{"406":1,"571":2,"606":1,"723":1}}],["cronos",{"1":{"29":1}}],["cron",{"1":{"22":1,"26":4}}],["critical",{"1":{"196":1,"224":3,"225":1}}],["crash",{"1":{"193":1}}],["clippingplane平行的平面截取这个平截头体",{"1":{"1025":1}}],["clippingplane或者far",{"1":{"1025":1}}],["clipping",{"1":{"737":1}}],["click",{"1":{"571":1}}],["cli",{"1":{"535":1,"536":1}}],["clientservertickrate",{"0":{"1017":1}}],["clientsimulationsystemgroup的tick又来自networktimesystem",{"1":{"1016":1}}],["clientsimulationsystemgroup",{"1":{"1014":1,"1016":1}}],["client表现一般",{"1":{"804":1}}],["client1的位置最开始再p",{"1":{"74":1}}],["client",{"1":{"12":6,"50":1,"51":5,"65":1,"71":1,"78":1,"79":1,"81":2,"452":1,"1020":1}}],["cloud",{"1":{"532":1}}],["closer",{"1":{"195":1}}],["clone方法的以满足icloneable接口的要求",{"1":{"111":1}}],["clone",{"1":{"111":1,"707":1,"896":2,"897":1}}],["clear",{"1":{"186":1,"187":2,"196":2,"817":1,"975":2}}],["cleaner",{"1":{"28":1}}],["clr绑定借助了ilruntime的clr重定向机制来实现",{"1":{"718":1}}],["clr中的system",{"1":{"707":1}}],["clr",{"1":{"131":1}}],["clr会维护一个同步块数组",{"1":{"131":1}}],["clr会给托管堆上的每个对象包括对象类型都添加两个字段",{"1":{"131":1}}],["clr刚开始运行时就分配了一个type的对象类型",{"1":{"131":1}}],["clr检查main方法里面是否有没加载的类型",{"1":{"131":1}}],["clr运行后从clr头里找到应用程序入口标识",{"1":{"131":1}}],["clr运行时会分配一个连续的地址空间用作托管堆",{"1":{"131":1}}],["clr开始运行",{"1":{"131":1}}],["clr头具体可以参考corhdr",{"1":{"131":1}}],["clr主要是管理程序集",{"1":{"131":1}}],["clr是什么呢",{"1":{"131":1}}],["cl",{"1":{"83":3,"84":2,"86":4}}],["clusters",{"1":{"90":1}}],["cluster",{"1":{"90":3}}],["clusterid",{"1":{"90":1}}],["clustered",{"1":{"22":2}}],["clumsy",{"1":{"29":1,"60":1}}],["classes",{"0":{"484":1},"1":{"190":2,"487":1}}],["class",{"1":{"27":2,"184":1,"188":4,"193":1,"484":3,"487":1,"601":1,"822":1,"823":2,"850":1,"882":1,"896":1,"927":1,"947":1}}],["c",{"0":{"20":1,"38":1,"41":1,"636":1,"1046":1},"1":{"33":1,"34":1,"38":1,"92":1,"116":1,"124":1,"126":5,"131":2,"153":1,"176":1,"193":2,"221":1,"223":1,"421":1,"425":1,"459":1,"497":1,"498":1,"523":1,"573":1,"633":1,"720":2,"747":1,"756":9,"781":2,"800":1,"818":1,"820":1,"822":1,"864":2,"899":8,"903":1,"926":1,"1023":2,"1052":1},"2":{"39":1,"1047":1,"1048":1,"1049":1,"1050":1}}],["coordinate",{"1":{"974":1}}],["cookie",{"1":{"153":3,"845":1}}],["cookierequestcultureprovider",{"0":{"153":1},"1":{"153":1}}],["coco",{"1":{"1023":1}}],["cocos2d",{"1":{"945":1}}],["cockpit",{"1":{"532":3}}],["color足够用了就不要使用",{"1":{"872":1}}],["collider",{"0":{"1030":1}}],["collider或guielement的层级顺序",{"1":{"652":1}}],["collision",{"0":{"754":1},"1":{"764":3,"770":4,"868":3}}],["collector提供了一种简单的方法来处理group中entity变化的反应",{"1":{"741":1}}],["collector是group的一个观察者类",{"1":{"741":1}}],["collector会持有这个被销毁的entity",{"1":{"739":1}}],["collector很多",{"1":{"738":1}}],["collector",{"0":{"741":1},"1":{"591":1,"738":1}}],["collect型任务",{"1":{"254":1}}],["collections",{"0":{"486":1},"1":{"487":1,"823":6}}],["collection",{"1":{"193":1,"486":1,"487":2,"489":2}}],["cos",{"1":{"756":16,"780":1}}],["cow",{"1":{"701":1}}],["count",{"1":{"486":1,"487":1}}],["could",{"1":{"28":1,"29":1,"90":1,"188":1,"189":1,"192":1,"571":1,"601":1}}],["copytilestosharedtilemaps",{"1":{"228":1}}],["copy",{"1":{"193":3,"969":1}}],["corbindtoruntimeex方法来实现",{"1":{"707":1}}],["corners",{"1":{"644":1}}],["corridor",{"1":{"225":1}}],["corrected",{"1":{"485":1}}],["correct",{"1":{"189":1,"485":1}}],["correspondence",{"1":{"187":1}}],["cor20",{"1":{"131":1}}],["core下载安装完后可以通过命令进行查看是否生效",{"1":{"416":1}}],["core解决",{"0":{"416":1}}],["core应用中ioptionsmonitor可能会导致同一个请求中选项的值不一致",{"1":{"174":1}}],["core应用程序中",{"1":{"164":1}}],["core来说不能跨请求",{"1":{"173":1}}],["core引入了options模式",{"1":{"171":1}}],["core是如何将http转发到controller和action",{"1":{"170":1}}],["core提供了默认的",{"1":{"166":1}}],["core定义了两个基本的接口",{"1":{"163":1}}],["corexemain或者",{"1":{"707":1}}],["corexemain",{"1":{"131":4}}],["core",{"1":{"22":5,"23":1,"25":1,"28":1,"29":1,"30":1,"132":1,"155":1,"166":2,"176":1,"181":1,"720":3}}],["coff",{"1":{"127":1}}],["codegen",{"1":{"591":1}}],["coder",{"1":{"544":2}}],["codeplex",{"1":{"411":1}}],["code",{"1":{"26":1,"27":1,"29":1,"127":1,"189":1,"190":1,"192":2,"193":3,"195":3,"196":1,"534":2,"535":3,"537":1,"538":2,"544":3,"545":1,"569":1,"707":1,"720":13}}],["codingnow",{"1":{"15":1}}],["conponent",{"1":{"964":1}}],["connect",{"1":{"587":1,"706":1,"876":1}}],["conditionbase",{"1":{"284":1}}],["condition",{"1":{"282":1}}],["conditionalgameplayeffects",{"1":{"233":1}}],["convertgameobjecthierarchy",{"1":{"999":1}}],["convertgameobejct对游戏对象进行转换",{"1":{"264":1}}],["converted",{"1":{"971":1}}],["converttoentitysystem运行在默认世界中",{"1":{"999":1}}],["converttoentity或",{"1":{"971":1}}],["converttoentity且被禁用的gameobject",{"1":{"970":1}}],["converttoentity就会在内部默认使用该值",{"1":{"970":1}}],["converttoentity之所以方便是因为你添加时就选择了该对象",{"1":{"970":1}}],["converttoentity",{"0":{"951":1},"1":{"961":1,"968":2,"971":2}}],["convert",{"0":{"954":1},"1":{"946":1,"953":2,"954":2,"955":1,"956":1,"957":1,"964":1,"965":6,"966":1,"967":1,"970":5,"971":4,"1005":1}}],["convertscene",{"1":{"971":1}}],["converts",{"1":{"489":2}}],["converting",{"1":{"188":1,"189":2,"194":1,"196":1}}],["conversion过程让",{"1":{"965":1}}],["conversions",{"1":{"191":1}}],["conversion",{"0":{"946":1,"947":1,"949":1,"952":1,"953":1,"956":1,"959":1,"965":1,"1002":1},"1":{"188":1,"947":6,"948":2,"949":4,"950":4,"951":8,"952":4,"954":4,"955":2,"956":1,"957":6,"960":1,"962":1,"963":1,"964":7,"965":9,"966":4,"967":1,"968":1,"969":4,"970":3,"971":6,"999":1,"1003":1}}],["conf配置",{"0":{"530":1}}],["conf",{"0":{"557":1,"558":1},"1":{"473":1}}],["config",{"0":{"464":1},"1":{"524":1,"525":1,"537":1}}],["configurationchangetokensource",{"1":{"173":1}}],["configurationextensions",{"1":{"173":1}}],["configuration",{"1":{"27":1,"499":1}}],["configure扩展方法还有其他重载可以满足你的更多需求",{"1":{"174":1}}],["configureplayground",{"1":{"136":1}}],["configured",{"1":{"27":2}}],["configure",{"1":{"26":1,"27":1,"472":1,"526":1}}],["configuring",{"0":{"26":1},"1":{"515":1}}],["conflict",{"1":{"90":1}}],["conclusion",{"0":{"196":1}}],["concept",{"0":{"933":1},"2":{"934":1,"935":1,"936":1}}],["concepts",{"1":{"22":1}}],["concerns",{"0":{"192":1}}],["concurrently",{"1":{"24":1}}],["constant",{"0":{"627":1,"629":1},"1":{"981":1,"982":1,"984":1}}],["construct",{"1":{"193":1}}],["constructor",{"1":{"24":1,"25":2,"950":1}}],["consists",{"1":{"896":1}}],["consisted",{"1":{"189":1}}],["consistentsharp",{"1":{"96":1}}],["consistent",{"1":{"90":1,"96":1}}],["consideration",{"1":{"186":1}}],["consuming",{"1":{"29":1}}],["console的证书相同",{"1":{"616":1}}],["console",{"1":{"24":1,"27":1,"720":1}}],["context遍历所有group",{"1":{"738":1}}],["contexts",{"1":{"509":1}}],["content",{"1":{"737":1}}],["contents",{"0":{"408":1},"2":{"409":1,"410":1}}],["contactsdocumentsdesktopdownloadsfavoriteslinksmusicpicturesrecentsaved",{"1":{"409":1}}],["container",{"1":{"25":2,"26":1,"27":2,"406":1}}],["contains",{"1":{"24":1,"187":1}}],["contributing",{"1":{"398":1}}],["controllable",{"1":{"187":1}}],["control",{"1":{"15":1,"27":1,"720":1,"851":1}}],["continuously",{"1":{"192":1}}],["com无法参与加速情况缩放为负值的情况下",{"1":{"981":1}}],["combining",{"1":{"737":1,"984":1}}],["combination",{"1":{"22":1}}],["com的账号",{"1":{"422":1}}],["comes",{"1":{"187":1,"189":1}}],["computer",{"1":{"974":1}}],["compression",{"1":{"869":1}}],["component记录的信息cv",{"1":{"992":1}}],["component就记住了b的gsv",{"1":{"992":1}}],["componentver",{"1":{"991":1}}],["components",{"0":{"928":1,"931":1},"1":{"928":7,"929":7,"932":1,"936":1,"954":1,"961":1,"969":1},"2":{"929":1,"930":1,"931":1,"932":2,"933":2,"934":2,"935":2,"936":2,"937":1,"938":1,"939":1}}],["component的块",{"1":{"910":1}}],["component的感觉",{"1":{"739":1,"744":1}}],["component",{"0":{"908":1,"918":1,"927":1},"1":{"661":2,"851":1,"919":1,"927":1,"928":1,"929":1,"931":1,"946":3,"947":2,"951":2,"952":3,"953":2,"954":2,"955":4,"956":3,"958":2,"960":1,"962":1,"964":3,"967":1,"968":3,"969":2,"971":1,"1001":2}}],["completely",{"1":{"193":1,"489":1}}],["complex",{"1":{"26":1}}],["companionlink指定的",{"1":{"969":1}}],["companiongameobjectupdatetransformsystem",{"1":{"969":1}}],["companion",{"0":{"969":1},"1":{"969":8}}],["compareto",{"1":{"818":2}}],["comparer",{"1":{"695":1}}],["compared",{"1":{"644":1}}],["comparison",{"0":{"195":1}}],["compact",{"1":{"186":1,"441":1}}],["compatibility",{"1":{"181":1,"721":1}}],["compile也勾掉我们可以看到这里使用了ghostfiled并且将其设置为interpolate",{"1":{"1016":1}}],["compiler",{"0":{"1046":1},"1":{"131":1},"2":{"1047":1,"1048":1,"1049":1,"1050":1}}],["compiling",{"1":{"131":1,"720":8}}],["compensation",{"1":{"81":1}}],["compensating",{"1":{"50":1,"81":1}}],["comment",{"1":{"459":1,"489":1}}],["commandline",{"1":{"571":2}}],["command",{"1":{"424":5,"979":1}}],["common",{"1":{"27":1,"572":1,"573":1}}],["community",{"1":{"15":1,"984":2}}],["com",{"0":{"1027":1,"1028":1,"1029":1,"1030":1},"1":{"10":2,"15":3,"21":1,"29":3,"50":1,"55":1,"57":1,"59":1,"65":1,"71":1,"77":1,"81":7,"87":1,"90":1,"96":1,"103":1,"104":3,"105":1,"111":1,"126":1,"131":4,"137":2,"147":2,"181":1,"185":1,"211":4,"225":4,"296":1,"385":5,"411":1,"412":3,"415":1,"416":1,"423":1,"436":1,"437":1,"483":2,"490":3,"491":1,"499":2,"510":1,"515":2,"527":1,"532":2,"533":3,"542":1,"543":1,"544":2,"569":3,"587":1,"601":1,"606":6,"607":2,"611":2,"615":1,"617":1,"631":1,"701":1,"706":1,"719":5,"723":2,"737":2,"747":3,"812":1,"825":1,"833":1,"839":1,"850":2,"855":2,"859":1,"863":2,"864":3,"899":4,"903":1,"926":1,"927":1,"930":1,"939":1,"941":1,"942":2,"965":1,"984":6,"998":2}}],["也在同一個",{"1":{"974":1}}],["也在其他一些地方执行这一过程",{"1":{"959":1}}],["也无法显示那些橙色的轮廓线",{"1":{"971":1}}],["也无法被使用",{"1":{"946":1}}],["也许你觉得这无所谓",{"1":{"965":1}}],["也许是为了让你自己处理asset的转换过程",{"1":{"964":1}}],["也许是一个不错的选择",{"1":{"174":1}}],["也拥有",{"1":{"947":1}}],["也即这里的",{"1":{"968":1}}],["也即transform矩阵",{"1":{"942":1}}],["也即",{"1":{"940":1,"951":1,"961":1,"969":1}}],["也即是",{"1":{"455":1}}],["也即是说",{"1":{"67":1,"456":1}}],["也关闭",{"1":{"869":1}}],["也使用了",{"1":{"858":1}}],["也存在所有",{"1":{"858":1}}],["也称左手螺旋",{"1":{"846":1}}],["也相应回返回",{"1":{"954":1}}],["也相对来说是最简单的",{"1":{"841":1}}],["也相同",{"1":{"695":1}}],["也避免了照相机移动方式中",{"1":{"729":1}}],["也只有在",{"1":{"695":1}}],["也包含了",{"1":{"689":1}}],["也因为不会对法术产生影响",{"1":{"385":1}}],["也有",{"1":{"958":1,"1001":1}}],["也有相关的",{"1":{"946":1}}],["也有可能没有一个目标",{"1":{"797":1}}],["也有可能除了小台阶",{"1":{"225":1}}],["也有一个固定的执行流程",{"1":{"794":1}}],["也有成功運行的報告",{"1":{"564":1}}],["也有草药",{"1":{"287":1}}],["也有树木",{"1":{"287":1}}],["也有很多可以优化的点",{"1":{"15":1}}],["也一定有上方出口",{"1":{"224":1}}],["也确保了所有的区域都可以到达",{"1":{"220":1}}],["也可提高下一阶武功的最高上限经验值",{"1":{"374":1}}],["也可用20级道家的技能",{"0":{"251":1}}],["也可能是失败了",{"1":{"207":1}}],["也可以作为相同结果来添加",{"1":{"967":1}}],["也可以用来",{"1":{"965":1}}],["也可以用于获取",{"1":{"947":1}}],["也可以自由使用",{"1":{"955":1}}],["也可以使用preconditions代替",{"1":{"1044":1}}],["也可以使用",{"1":{"955":1}}],["也可以使用命令行参数",{"1":{"815":1}}],["也可以通过",{"1":{"955":1}}],["也可以分配",{"1":{"951":1}}],["也可以调用依赖joba的jobb的complete方法",{"1":{"924":1}}],["也可以调用依赖此job的jobhandle上的complete方法",{"1":{"924":1}}],["也可以移除一个entity的nativearray中的组件",{"1":{"908":1}}],["也可以根据需要添加其他组件",{"1":{"907":1}}],["也可以提前创建",{"1":{"906":1}}],["也可以不提供让技能自己查找",{"1":{"793":1}}],["也可以不同层背景使用不同的滚动方式",{"1":{"734":1}}],["也可以让他们黏在一起",{"1":{"765":1}}],["也可以编辑器运行的时候就合",{"1":{"703":1}}],["也可以接受加载时返回的操作句柄",{"1":{"696":1}}],["也可以有多个实现wsgi",{"1":{"578":1}}],["也可以忽略掉",{"1":{"536":1}}],["也可以由服务器自动触发",{"1":{"457":1}}],["也可以模块化引用",{"1":{"397":1}}],["也可以规避其他有害影响",{"1":{"385":1}}],["也可以单独存在点我下载服装制作模板衣服到时候我们一个一个商讨着画",{"1":{"285":1}}],["也可以在非常短的时间内把再做一次切换",{"1":{"88":1}}],["也可以把cl",{"1":{"86":1}}],["也可以工作在小端模式",{"1":{"33":1}}],["也可以手动的触发执行定时任务",{"1":{"30":1}}],["也作为缓动函数在游戏中广泛使用",{"1":{"197":1}}],["也能正常工作",{"1":{"966":1}}],["也能清理关联着实体",{"1":{"936":1}}],["也能看到这个mesh有两个submesh",{"1":{"847":1}}],["也能通过代码的方式更改值",{"1":{"174":1}}],["也能做到相对",{"1":{"96":1}}],["也要加载进来",{"1":{"131":1}}],["也把类型对象创建好",{"1":{"131":1}}],["也就完全不会有",{"1":{"970":1}}],["也就会消耗更多资源影响程序性能",{"1":{"898":1}}],["也就达到了同一个模型",{"1":{"848":1}}],["也就需要六个点的坐标",{"1":{"846":1}}],["也就可以表示为下面的代码",{"1":{"846":1}}],["也就不再需要自己手动去调用射线去检测physics碰撞了",{"1":{"665":1}}],["也就不需要增加多余的同步块",{"1":{"131":1}}],["也就是离相机越近",{"1":{"1037":1}}],["也就是碰撞器范围的坐标点",{"1":{"1024":1}}],["也就是上一节讲的实体原型",{"1":{"906":1}}],["也就是上面提到的",{"1":{"42":1}}],["也就是设置对象的材质",{"1":{"876":1}}],["也就是越靠上的组件",{"1":{"862":1}}],["也就是通过一定的冗余",{"1":{"861":1}}],["也就是技能效果应该是触发了某个buff",{"1":{"810":1}}],["也就是不考虑角度",{"1":{"771":1}}],["也就是一个group",{"1":{"738":1}}],["也就是最开始的流程图中的第三步",{"1":{"695":1}}],["也就是挂载事件的对象",{"1":{"678":1}}],["也就是我们看到的屏幕矩形",{"1":{"1025":1}}],["也就是我们平时所说的关闭垂直同步",{"1":{"854":1}}],["也就是我们平时所说的垂直同步打开",{"1":{"854":1}}],["也就是我们可以看到的standaloneinputmodule以及touchinputmodule",{"1":{"668":1}}],["也就是我们成功打包出来的插件",{"1":{"535":1}}],["也就是实现上线的接口中的函数",{"1":{"667":1}}],["也就是事件阻挡关系",{"1":{"664":1}}],["也就是depth",{"1":{"663":1}}],["也就是强制某个handler执行",{"1":{"657":1}}],["也就是静态",{"1":{"573":1}}],["也就是使用32位浮点运算而不是使用16位浮点运算",{"1":{"570":1}}],["也就是你必须在48个时辰内凑到1240元来维持支出",{"1":{"371":1}}],["也就是刚才我们头顶上那个",{"1":{"224":1}}],["也就是x轴正方向",{"1":{"209":1}}],["也就是x=11",{"1":{"69":1}}],["也就是",{"1":{"199":1,"841":1}}],["也就是在当数值趋近于整数时",{"1":{"197":1}}],["也就是在对象变成垃圾的同时就会被回收",{"1":{"115":1}}],["也就是main",{"1":{"131":1}}],["也就是俗称的虚拟机",{"1":{"130":1}}],["也就是version2",{"1":{"88":1}}],["也就是旧版本应用version1",{"1":{"88":1}}],["也就是其他玩家也不会受到他的影响",{"1":{"67":1}}],["也就是将所有的移动",{"1":{"45":1}}],["也就是单个字来进行编码的",{"1":{"39":1}}],["也就是从左到右发送",{"1":{"38":1}}],["也就是说submesh使用自身的",{"1":{"847":1}}],["也就是说在玩家固定施法半径以内可随意放一个圆形的技能",{"1":{"776":1}}],["也就是说如果原来目标就在触发器范围内",{"1":{"748":1}}],["也就是说整个ecs系统的内部数据维护",{"1":{"738":1}}],["也就是说",{"1":{"37":2,"50":1,"76":1,"111":1,"158":1,"207":1,"275":1,"655":1,"783":1,"796":1,"847":1,"947":1,"1025":2}}],["也就是输入确定了之后",{"1":{"11":1}}],["也消除了复制算法当中",{"1":{"119":1}}],["也需要管理其他系统所造成的的状态改变",{"1":{"932":1}}],["也需要同步",{"1":{"805":1}}],["也需要一些小小的配置调整",{"1":{"578":1}}],["也需要都同步给角色a",{"1":{"103":1}}],["也需要重新发起对时",{"1":{"51":1}}],["也会受到同样的影响",{"1":{"958":1,"1001":1}}],["也会",{"1":{"947":1}}],["也会减慢游戏开发的进度",{"1":{"848":1}}],["也会有这样的感觉",{"1":{"724":1}}],["也会有丘陵和蚀坑",{"1":{"204":1}}],["也会触发spriteatlas",{"1":{"705":1}}],["也会跟随着一起变化",{"1":{"626":1}}],["也会关掉一些",{"1":{"575":1}}],["也会会在每一次循环中同步tick",{"1":{"277":1}}],["也会大大减少性能消耗",{"1":{"97":1}}],["也会广播这个消息",{"1":{"17":1}}],["也不是什么好主意",{"1":{"945":1}}],["也不是最高点",{"1":{"46":1}}],["也不要求时间一致",{"1":{"807":1}}],["也不使用原有的",{"1":{"457":1}}],["也不会回收其实体的",{"1":{"936":1}}],["也不会有任何数据丢失",{"1":{"455":1}}],["也不会高于95",{"1":{"384":1}}],["也不会被网络延迟lock住",{"1":{"15":1}}],["也不用调来调去",{"1":{"372":1}}],["也这样做了",{"1":{"15":1}}],["也是完全可行的",{"1":{"955":1}}],["也是组件的一种类型",{"1":{"937":1}}],["也是非压缩的",{"1":{"857":1}}],["也是非常高效的",{"1":{"740":1}}],["也是不行的",{"1":{"750":1}}],["也是通过这种方式来对clr方接口进行调用的",{"1":{"718":1}}],["也是空的",{"1":{"592":1}}],["也是目前游戏中使用的那个",{"1":{"219":1}}],["也是最困难的",{"1":{"208":1}}],["也是类似域名",{"1":{"135":1}}],["也是所有自动化的深",{"1":{"111":1}}],["也是用的这种方式来做",{"1":{"15":1}}],["也是",{"1":{"12":1,"510":1}}],["mp",{"1":{"984":1}}],["mcs",{"1":{"722":2}}],["mb",{"1":{"456":1}}],["mf只和",{"1":{"275":1}}],["mf值开始介入",{"1":{"275":1}}],["mf值会分别增加暗金",{"1":{"275":1}}],["mlvl为70",{"1":{"275":1}}],["mlvl",{"1":{"275":1}}],["mlvl判定过程",{"1":{"275":1}}],["ml",{"1":{"270":2}}],["m中一点",{"1":{"207":1}}],["m中任意一点",{"1":{"207":1}}],["m与",{"1":{"207":1}}],["murongxiaopifu",{"1":{"719":2}}],["multiworldbootstrap",{"1":{"939":1}}],["multidomainhost",{"1":{"707":1}}],["multidomain",{"1":{"707":1}}],["multidisplay",{"1":{"688":2}}],["multiplayer",{"1":{"87":1}}],["multiple",{"1":{"22":1,"90":1,"662":1,"939":1}}],["multiparty",{"1":{"15":1}}],["must",{"1":{"484":1}}],["musicpublic",{"1":{"410":1}}],["much",{"1":{"187":1,"190":1,"191":2,"195":2,"644":1}}],["mxgmn",{"1":{"211":1}}],["mx如果你仅仅使用",{"1":{"152":1}}],["mx",{"1":{"152":2}}],["mz",{"1":{"131":1}}],["mdn",{"1":{"770":1}}],["mdmarkdow中使用生成的html当切换ui的值后的显示",{"1":{"147":1}}],["md",{"1":{"103":1,"503":4,"504":1,"505":1}}],["myspriteatlas",{"1":{"964":1}}],["mysqldump",{"1":{"424":1}}],["mysql数据库的表明可能会有大小写敏感的问题",{"1":{"8":1}}],["mysql",{"0":{"8":1,"434":1},"1":{"132":1}}],["myint会被放到堆里因为它是一个引用类型",{"1":{"892":1}}],["mylist",{"1":{"823":2}}],["mydictionary",{"1":{"822":2}}],["myenumcomparer",{"1":{"822":1}}],["myenum",{"1":{"822":5}}],["mybook",{"1":{"502":1,"503":1,"505":1}}],["my",{"1":{"90":1,"189":1,"191":2,"967":2}}],["msil",{"0":{"127":1,"128":1},"1":{"127":8,"128":1,"129":5,"130":3,"131":1},"2":{"129":1,"130":1}}],["mscorlib始终是process级别的",{"1":{"707":1}}],["mscorlib",{"1":{"126":1,"707":1,"823":7}}],["mscorlib为目标的编译器",{"1":{"126":1}}],["mscorlib为目标",{"1":{"126":1}}],["msdn文档似乎暗示clone方法是进行的深拷贝",{"1":{"111":1}}],["ms",{"1":{"68":1,"131":1,"878":2}}],["msec前面描述过",{"1":{"50":1}}],["msec表示这个命令执行对应的毫秒数",{"1":{"42":1}}],["msbuild",{"1":{"125":2}}],["msb",{"1":{"32":1}}],["m",{"1":{"26":1,"207":1,"270":1,"817":3,"866":1,"1014":1,"1016":1}}],["mediumhow",{"1":{"998":1}}],["mergemode是intersection时",{"1":{"903":1}}],["mergemode是union时",{"1":{"903":1}}],["mergemode",{"0":{"903":1},"1":{"903":1}}],["mere",{"1":{"194":1}}],["merely",{"1":{"189":1}}],["meshfilter+meshrenderer=rendermesh设计地那样一样绘制",{"1":{"971":1}}],["meshfilter",{"1":{"968":1,"1054":1}}],["meshfilter和meshrenderer",{"1":{"966":1,"969":1}}],["meshfilter的",{"1":{"847":1}}],["meshreander",{"1":{"859":1}}],["meshrenderer负责对meshfilter中的mesh进行绘制",{"1":{"847":1}}],["mesh合并的优缺点",{"0":{"849":1}}],["mesh提供了相关的api",{"1":{"848":1}}],["meshcombine",{"0":{"848":1},"1":{"848":1},"2":{"849":1}}],["mesh属性",{"1":{"847":1}}],["mesh上的顶点信息",{"1":{"847":1}}],["mesh的不同部分",{"1":{"847":1}}],["meshes的设置",{"1":{"868":1}}],["meshes选项",{"1":{"868":1}}],["meshes",{"1":{"844":1}}],["mesh",{"0":{"843":3,"846":1,"869":1},"1":{"824":5,"850":1,"864":1,"940":2,"941":1,"942":2,"945":1,"952":1}}],["messaging",{"0":{"661":1},"1":{"661":3,"695":1}}],["message",{"0":{"659":1,"660":1},"1":{"661":1},"2":{"660":1,"661":1}}],["message1",{"1":{"657":1}}],["messages",{"1":{"187":1,"189":1}}],["messy",{"1":{"28":1}}],["menu",{"1":{"498":2}}],["mentioned",{"1":{"186":1}}],["me",{"1":{"196":1}}],["memcpy",{"1":{"898":2}}],["memorymanagement",{"1":{"833":1}}],["memory",{"1":{"193":10,"196":1,"833":1,"867":1,"927":1,"937":1}}],["member",{"1":{"489":1}}],["memberwiseclone进行的是浅拷贝",{"1":{"111":1}}],["membership",{"1":{"90":1}}],["measured",{"1":{"191":1}}],["measure",{"1":{"191":1}}],["measurements",{"1":{"195":2}}],["measurement",{"1":{"189":1}}],["means",{"1":{"28":1,"187":1,"189":2,"190":1}}],["metal",{"1":{"980":1}}],["meta",{"1":{"186":1}}],["methods中取出",{"1":{"715":1}}],["methods",{"1":{"27":1,"50":1,"81":1,"188":4,"189":1,"190":1,"192":2,"193":3,"194":1,"195":1,"196":1,"488":1,"489":1,"714":1,"720":2}}],["method",{"0":{"470":1},"1":{"24":1,"25":3,"27":1,"111":1,"184":1,"185":1,"187":1,"188":1,"189":2,"191":2,"193":1,"195":1,"196":1,"467":1,"823":2,"885":1,"890":1,"896":1}}],["mechanism",{"1":{"15":1,"25":1}}],["mechanisms",{"1":{"15":1}}],["most",{"1":{"186":2,"188":1,"189":1,"195":1}}],["module输入模式下不正常参考网络资料",{"1":{"658":1}}],["module",{"1":{"400":1,"499":1,"695":1}}],["modules",{"1":{"140":1,"535":2,"571":1}}],["modifiers可以有多条",{"1":{"236":1}}],["modifiers",{"1":{"233":1}}],["modifying",{"1":{"193":1}}],["modify",{"1":{"188":1}}],["mode下的内存供运行时使用",{"1":{"971":1}}],["mode中一般选择expand",{"1":{"628":1}}],["mode选的是scale",{"1":{"625":1}}],["mode为weight",{"1":{"625":1}}],["mode",{"0":{"628":1,"647":2,"649":1,"650":1},"1":{"131":1,"687":2,"694":1,"951":1,"969":1,"971":11,"975":1,"977":1,"978":1}}],["model下是正常的",{"1":{"658":1}}],["models",{"1":{"571":2}}],["model",{"1":{"90":2,"206":1,"571":2}}],["motives",{"1":{"1044":1}}],["motivation",{"0":{"932":1}}],["motion",{"1":{"131":1}}],["motorola的",{"1":{"33":1}}],["moonlight应用程序的编译器",{"1":{"126":1}}],["monkeywie",{"1":{"510":1}}],["mono运行时会自动避免扩展堆",{"1":{"831":1}}],["mono脚本后端不是这种情况",{"1":{"819":1}}],["mono或者il2cpp",{"1":{"813":1}}],["monobleedingedge",{"1":{"722":1}}],["monobehavior所在的gameobject需要有collider碰撞组件",{"1":{"652":1}}],["monobehaviours",{"1":{"1005":1}}],["monobehaviourcomponent",{"1":{"967":1}}],["monobehaviour",{"0":{"955":1},"1":{"652":1,"955":1,"966":1,"967":1}}],["mono自身的jit编译器就会禁止",{"1":{"709":1}}],["mono",{"1":{"126":3,"722":1,"867":1}}],["mono系列",{"0":{"126":1}}],["month",{"1":{"26":1}}],["movenext",{"1":{"823":1}}],["moveto型任务",{"1":{"254":1}}],["move",{"1":{"103":2,"104":2,"105":1,"109":1}}],["movement",{"1":{"43":1}}],["more",{"1":{"22":1,"27":3,"186":1,"187":1,"188":2,"189":1,"190":2,"193":1,"195":3,"471":1}}],["moment",{"1":{"22":1}}],["mask只包括minimap这一层",{"1":{"1034":1}}],["mask中不包括minimap这一层",{"1":{"1034":1}}],["mask会增加一个drawcall",{"1":{"860":1}}],["maskprojectionclipping",{"1":{"737":2}}],["mask",{"0":{"689":1},"1":{"663":1,"689":3,"694":1,"737":1}}],["mask来过滤射线",{"1":{"655":1}}],["master",{"1":{"12":6,"147":1,"575":3,"576":1}}],["matrix的设置",{"1":{"868":1}}],["material将会造成一份材质的拷贝",{"1":{"979":1,"980":1}}],["material赋给meshrenderer",{"1":{"847":1}}],["material绘制",{"1":{"847":1}}],["material只负责一个mesh的一次绘制",{"1":{"847":1}}],["material",{"1":{"847":1,"858":2,"940":1,"941":1,"942":2,"945":1,"975":6,"977":4,"1036":2}}],["materials",{"1":{"844":1,"952":1}}],["match",{"0":{"628":1},"1":{"625":1,"628":2}}],["matt",{"1":{"197":1}}],["marketplacehttps",{"1":{"515":1}}],["marked",{"1":{"484":1,"488":1}}],["markdown",{"1":{"505":1,"506":1}}],["marshalbyrefobject才能被marshal",{"1":{"707":1}}],["marshal",{"1":{"193":3}}],["marshalling",{"0":{"193":1},"1":{"193":2,"195":4,"196":2},"2":{"194":1}}],["macos",{"1":{"477":4}}],["mac",{"1":{"411":1,"477":3,"524":3,"720":3}}],["mac下host配置路径",{"1":{"404":1}}],["mappingsystem",{"1":{"999":1}}],["mapping",{"1":{"950":3,"957":1,"959":1,"961":1,"962":1,"964":6,"965":1,"969":1,"1002":1}}],["map",{"1":{"225":1,"845":1}}],["majority",{"1":{"196":1}}],["make",{"1":{"187":1,"188":1,"189":1,"191":1,"192":1,"193":1,"195":1,"472":1}}],["makes",{"1":{"29":1}}],["made",{"1":{"181":1,"189":1}}],["may",{"1":{"181":1,"193":2,"196":2}}],["maxim",{"1":{"998":1}}],["maxstack",{"1":{"823":1}}],["max",{"1":{"86":1,"385":1,"633":1}}],["maxupdaterate",{"1":{"82":1}}],["maxrate",{"1":{"82":1}}],["manual",{"0":{"912":1},"1":{"191":1,"606":3,"651":1,"706":1,"723":1,"825":1,"839":1,"850":2,"984":1}}],["manually",{"1":{"190":1,"193":1,"195":1,"196":1}}],["management",{"1":{"700":1,"833":1}}],["manager优化",{"1":{"955":1}}],["manager中现在就明白graphic",{"1":{"675":1}}],["manager中寻找所有的raycaster",{"1":{"675":1}}],["manager即php",{"1":{"576":1}}],["manager",{"0":{"412":1,"414":1,"415":1,"416":1,"420":1},"1":{"412":2,"414":1,"415":1,"416":1,"526":1,"929":1,"955":1,"957":1,"961":1,"975":1,"998":1},"2":{"413":1,"414":1,"415":2,"416":2,"417":2}}],["manages",{"1":{"191":1}}],["managed",{"1":{"131":1,"193":2,"823":1,"868":1,"927":1}}],["managing",{"1":{"26":1,"515":1}}],["many",{"1":{"22":1,"186":1,"188":1}}],["main为key的iresourcelocation",{"1":{"901":1}}],["maintainable",{"1":{"195":1}}],["maintain",{"1":{"192":1,"193":1,"195":1}}],["main",{"1":{"22":1,"406":1,"687":1,"737":1}}],["mit",{"0":{"765":1},"1":{"765":1}}],["michalberlinger",{"1":{"737":2}}],["microseconds",{"1":{"189":1}}],["microsoftstorehttps",{"1":{"533":1}}],["microsoft",{"1":{"127":2,"128":1,"131":2,"166":1,"181":1,"398":1,"415":1,"416":1,"497":1,"498":2,"499":2,"525":2,"533":1,"591":1,"606":1,"719":1,"723":1}}],["mimpi",{"1":{"737":1}}],["mike",{"1":{"217":1}}],["million",{"1":{"189":2,"191":1,"194":1}}],["middile",{"1":{"102":1}}],["middle",{"1":{"102":2}}],["miss",{"1":{"79":1}}],["missing",{"1":{"26":1}}],["min",{"1":{"385":1,"633":1}}],["minimum",{"1":{"765":1}}],["minimization",{"1":{"15":1}}],["minion",{"1":{"266":1}}],["minupdaterate和sv",{"1":{"82":1}}],["minutes",{"1":{"22":1}}],["minrate和sv",{"1":{"82":1}}],["mirrored",{"1":{"15":1}}],["的物体在这个队列渲染",{"1":{"1036":1}}],["的物品",{"1":{"270":1}}],["的字面值",{"1":{"1036":1}}],["的关键属性",{"1":{"1036":1}}],["的类型而异",{"1":{"1022":1}}],["的描述",{"0":{"983":1}}],["的其他物体",{"1":{"982":1}}],["的其余部分是可接受的",{"1":{"597":1}}],["的材质",{"1":{"982":1}}],["的材质属性",{"1":{"979":1,"980":1}}],["的符合条件的动态对象在一个draw",{"1":{"980":1}}],["的条件下",{"1":{"979":1}}],["的静态物件",{"1":{"979":1}}],["的静态资源支持下面",{"1":{"507":1}}],["的元件",{"1":{"977":1}}],["的元素类型包含在",{"1":{"938":1}}],["的距離排序",{"1":{"975":2}}],["的距离",{"1":{"641":2,"645":1,"755":1}}],["的使用量",{"1":{"975":1}}],["的知識",{"1":{"974":1}}],["的生命周期管理很有帮助",{"1":{"971":1}}],["的完整",{"1":{"971":1}}],["的完整功能",{"1":{"126":1}}],["的状态",{"1":{"971":1}}],["的状态在",{"1":{"68":1}}],["的好处都能获得",{"1":{"971":1}}],["的环境里运行了",{"1":{"971":1}}],["的另一个好处是",{"1":{"969":1}}],["的衔接也更加无缝",{"1":{"969":1}}],["的混合转换方式",{"1":{"969":1}}],["的示例",{"0":{"966":1}}],["的prefab",{"1":{"965":1,"1003":1}}],["的碎片变多",{"1":{"965":1}}],["的update",{"1":{"965":1}}],["的规则",{"1":{"965":1}}],["的任何位置发现了被禁用的gameobject",{"1":{"965":1}}],["的任务时",{"1":{"277":1}}],["的顶层对象会得到linkedentitygroup",{"1":{"965":1}}],["的declarereferencedprefab",{"1":{"964":1}}],["的机会",{"1":{"964":1}}],["的例子里",{"1":{"969":1}}],["的例子在自己身上调用declarelinkedentitygroup",{"1":{"963":1}}],["的例子来说",{"1":{"929":1}}],["的容量",{"1":{"960":1}}],["的容器类或者数组时",{"1":{"817":1}}],["的buffer",{"1":{"960":2}}],["的层级结构",{"1":{"959":1,"1002":1}}],["的层级关系",{"1":{"952":1}}],["的查询系统忽略它们",{"1":{"958":1,"1001":1}}],["的查询能力",{"1":{"955":1}}],["的查询能力可以获得",{"1":{"955":1}}],["的味道",{"1":{"957":1}}],["的过程",{"1":{"957":1}}],["的过程也非常容易",{"1":{"947":1}}],["的游戏",{"1":{"955":1}}],["的游戏中",{"1":{"217":1}}],["的能力让声明",{"1":{"955":1}}],["的system",{"0":{"955":1}}],["的sendmessage没什么区别",{"1":{"657":1}}],["的行为在",{"1":{"952":1}}],["的行为由一个或多个",{"1":{"524":1}}],["的cube",{"1":{"953":1}}],["的chunk",{"1":{"952":1}}],["的cl",{"1":{"86":2}}],["的计算",{"1":{"952":1}}],["的计算总是基于",{"1":{"952":1}}],["的顺序",{"0":{"949":1}}],["的顺序排列",{"1":{"695":1}}],["的地方",{"1":{"948":1}}],["的地方在于其核心问题其实是人类和物理",{"1":{"61":1}}],["的特点是你可以通过原始的",{"1":{"947":1}}],["的特殊文本文件",{"1":{"722":1}}],["的组件",{"1":{"947":1,"967":1}}],["的组成",{"1":{"537":1}}],["的高性能",{"1":{"945":1}}],["的模式觉得有些不安",{"1":{"944":1}}],["的模板",{"1":{"508":1}}],["的数量",{"1":{"980":1}}],["的数量还会继续增加",{"1":{"952":1}}],["的数量来绘制的是同样数量的",{"1":{"942":1}}],["的数据排除了各自的位置",{"1":{"982":1}}],["的数据库里面查询",{"1":{"955":1}}],["的数据库",{"1":{"947":1}}],["的数据库状态了",{"1":{"452":1}}],["的数据库状态",{"1":{"452":1}}],["的数据",{"1":{"930":1}}],["的数据也会影响实体会被存在哪个内存块",{"1":{"905":1}}],["的操作",{"1":{"941":1}}],["的操作在三个方面不同于",{"1":{"130":1}}],["的优势",{"1":{"941":1}}],["的优点是它是全自动的",{"1":{"111":1}}],["的世界里",{"1":{"956":1}}],["的世界里做游戏",{"0":{"941":1}}],["的世界中是非常独特的存在",{"1":{"930":1}}],["的相关的资源和状态",{"1":{"936":1}}],["的相对",{"1":{"841":1}}],["的同步",{"1":{"931":1}}],["的同步算法",{"1":{"13":1}}],["的所有的泛型",{"1":{"930":1}}],["的所有对象的一旦被射线检测成功并得到",{"1":{"689":1}}],["的消耗都是可以忽略不计的",{"1":{"930":1}}],["的消息到网络数据包而不被vac被检测",{"1":{"85":1}}],["的消息一直打到什么样的玩家",{"1":{"85":1}}],["的索引",{"1":{"930":1}}],["的引用",{"1":{"927":1,"962":1,"966":1}}],["的引用记数将会减少为0",{"1":{"701":1}}],["的引用记数均为1",{"1":{"701":1}}],["的引用记数也是1",{"1":{"701":1}}],["的引用记录会是1",{"1":{"701":1}}],["的东西",{"1":{"915":1}}],["的设置",{"1":{"868":1}}],["的设置就可以了",{"1":{"841":1}}],["的垃圾回收器",{"1":{"864":1}}],["的垃圾收集",{"1":{"857":1}}],["的分配器实际会使用不同的内存池进行小型和大型分配",{"1":{"864":1}}],["的技巧",{"1":{"862":1}}],["的非分配版本",{"1":{"858":1}}],["的现象",{"1":{"854":1}}],["的法线",{"1":{"846":1}}],["的属性中看到",{"1":{"841":1}}],["的桌面或者手机系统中",{"1":{"840":1}}],["的ide和编译器通常不会对装箱发出警告",{"1":{"820":1}}],["的il代码",{"1":{"131":1}}],["的表",{"1":{"800":1}}],["的文章",{"1":{"789":1}}],["的文件夹",{"1":{"502":1}}],["的文件",{"1":{"441":1}}],["的投影轴",{"1":{"785":1}}],["的用途就是去检测并判断两个图形之间是否有间隙",{"1":{"783":1}}],["的向量来表示多边形的某条边",{"1":{"762":1}}],["的判断方法了",{"1":{"756":1}}],["的情形",{"1":{"756":1}}],["的情况下",{"1":{"412":1,"980":1,"981":1}}],["的情况",{"1":{"72":1,"88":1,"965":1}}],["的情况发生",{"1":{"48":1}}],["的矩形进行碰撞检测",{"1":{"753":1}}],["的包装模式设置为重复出现的方式",{"1":{"726":1}}],["的包管理工具",{"1":{"465":1}}],["的纹理包装类型",{"1":{"726":1}}],["的新文本文件",{"1":{"722":1}}],["的某些部分并非在所有",{"1":{"721":1}}],["的访问权限",{"1":{"721":1}}],["的对经常使用的clr接口进行直接调用",{"1":{"718":1}}],["的对象时",{"1":{"971":1}}],["的对象依然可以选中转换前的状态",{"1":{"971":1}}],["的对象",{"1":{"970":1}}],["的对象之下的层级会被单独摘出来并保留",{"1":{"952":1}}],["的对象越排在前面",{"1":{"695":1}}],["的对象过滤掉",{"1":{"693":1}}],["的对象在这里就会就行射线检测",{"1":{"689":1}}],["的对象存活",{"1":{"120":1}}],["的对象作为起始点",{"1":{"116":1}}],["的可执行权限",{"1":{"709":1}}],["的工作",{"1":{"963":1}}],["的工作方式",{"1":{"575":1}}],["的工程",{"1":{"708":1}}],["的记录将会被删除",{"1":{"701":1}}],["的记数会是2",{"1":{"701":1}}],["的assetbundle中包含有三个资源",{"1":{"701":1}}],["的实体",{"1":{"930":2,"1008":1}}],["的实体会被一起放到同样的内存块",{"1":{"929":1}}],["的实体放到一个同样的内存块中",{"1":{"928":1}}],["的实例化感觉一样了",{"1":{"964":1}}],["的实例",{"1":{"697":1}}],["的实现https",{"1":{"10":1}}],["的资源",{"1":{"931":1}}],["的资源调用",{"1":{"699":1}}],["的资源调用了3次",{"1":{"697":1}}],["的资源列表中",{"1":{"510":1}}],["的位置和射线碰撞点之间的距离",{"1":{"695":1}}],["的正常工作了",{"1":{"959":1,"1002":1}}],["的正是",{"1":{"952":1}}],["的正方向比较是否相交",{"1":{"693":1}}],["的正方向与",{"1":{"693":1}}],["的正方向",{"1":{"693":1}}],["的正的右侧",{"1":{"209":1}}],["的范围",{"1":{"688":1}}],["的宽高除以",{"1":{"688":1}}],["的近裁剪面处出发",{"1":{"684":1}}],["的group里面",{"1":{"742":1}}],["的gameobject",{"1":{"965":1}}],["的game",{"1":{"657":1}}],["的gc并没有用引用计数",{"1":{"124":1}}],["的源码来看看其的工作流程",{"1":{"656":1}}],["的影响设置的高度是根据povit进行上下缩小的上面同样的示例",{"1":{"645":1}}],["的影響",{"1":{"637":1}}],["的锚点并非全部重合时",{"1":{"644":1}}],["的结果一样",{"1":{"970":1}}],["的结果上面回溯原有对象的情况下才有用",{"1":{"954":1}}],["的结果是调用object",{"1":{"822":1}}],["的结果",{"1":{"644":1,"965":1,"971":1,"1003":1}}],["的坐标点",{"1":{"1024":1}}],["的坐标",{"1":{"640":1,"756":1}}],["的中心点pivot的点所在位置这同样适用于layout",{"1":{"639":1}}],["的中心点到各条边中点的向量组成",{"1":{"197":1}}],["的尺寸",{"1":{"644":1}}],["的尺寸影響",{"1":{"635":1,"636":1}}],["的尺寸而變化",{"1":{"633":1}}],["的過程中",{"1":{"633":1}}],["的控制精髓",{"0":{"633":1},"2":{"634":1,"635":1,"636":1,"637":1}}],["的权限",{"1":{"608":1}}],["的编译器",{"1":{"588":1}}],["的基本工作原理",{"1":{"576":1}}],["的一种存在",{"1":{"1010":1}}],["的一种改进",{"1":{"107":1}}],["的一些检测",{"1":{"688":1}}],["的一个进程则处理完一个请求后退出",{"1":{"574":1}}],["的版本更新到了",{"1":{"567":1}}],["的依赖模块组成具体如下图",{"1":{"537":1}}],["的大小超过10m的时候",{"1":{"537":1}}],["的内部状态",{"1":{"932":1}}],["的内容现在全都不在了",{"1":{"969":1}}],["的内容",{"1":{"536":2,"971":1}}],["的内存留在",{"1":{"941":1}}],["的内存用来存储",{"1":{"940":1}}],["的内存消耗几乎可以忽略不计",{"1":{"929":1}}],["的内存管理器自动管理的部分",{"1":{"813":1}}],["的内存是浪费的",{"1":{"120":1}}],["的内存",{"1":{"120":1}}],["的核心模块",{"1":{"536":1}}],["的后缀改成",{"1":{"535":1}}],["的体积",{"1":{"534":1}}],["的输出",{"1":{"510":1}}],["的信息",{"1":{"509":2}}],["的镜像源",{"1":{"478":1}}],["的帮助文档",{"1":{"475":1}}],["的配置要与上面的",{"1":{"473":1}}],["的官方介绍",{"1":{"471":1}}],["的命令只能在客户端的上下文中被执行",{"1":{"452":1}}],["的安全性是最高的",{"1":{"451":1}}],["的安装时代码生成",{"0":{"130":1}}],["的保存操作只会在aof",{"1":{"451":1}}],["的性能优势",{"1":{"759":1}}],["的性能有很大的影响",{"1":{"457":1}}],["的性能就越好",{"1":{"451":1}}],["的性能会比",{"1":{"180":1}}],["的写入必须等待子线程先完成",{"1":{"449":1}}],["的调用并不是每秒一次",{"1":{"449":1}}],["的调用条件",{"1":{"446":1}}],["的导出列表进行额外处理",{"1":{"438":1}}],["的存在",{"1":{"412":1,"947":1,"951":1,"966":1}}],["的区别很明显",{"1":{"412":1}}],["的辅助工具",{"1":{"411":1,"412":1}}],["的自动填写是相同的",{"1":{"411":1}}],["的选项",{"1":{"411":1}}],["的缩写",{"1":{"405":1}}],["的伤害否则不会受到任何伤害|",{"1":{"378":1}}],["的经验值能撑越高",{"1":{"372":1}}],["的节点会截止此次检测",{"1":{"691":1}}],["的节点",{"1":{"283":1}}],["的执行状态",{"1":{"509":1}}],["的执行时间未超过",{"1":{"449":1}}],["的执行",{"1":{"283":1}}],["的成品qlvl",{"1":{"275":2}}],["的掉落判定顺序",{"1":{"275":1}}],["的掉落过程",{"1":{"275":1}}],["的随机构成",{"1":{"266":1}}],["的几率是个尖刺",{"1":{"225":1}}],["的几率会出现个尖刺",{"1":{"225":1}}],["的几率会是一个能推动的障碍物",{"1":{"225":1}}],["的tile网格组成",{"1":{"225":2}}],["的教学文章",{"1":{"224":1}}],["的网格组成",{"1":{"224":1}}],["的做法是",{"1":{"220":1}}],["的墙壁",{"1":{"220":1}}],["的房间",{"1":{"219":1}}],["的周围8个单元正方形的索引坐标进行了哈希计算",{"1":{"201":1}}],["的小数部分值",{"1":{"199":1}}],["的小数部分中随机抽取某一位数字",{"1":{"197":1}}],["的小数点部分",{"1":{"197":1}}],["的小端序相反",{"1":{"38":1}}],["的值了",{"1":{"965":1}}],["的值呢",{"1":{"930":1}}],["的值都会导致这种操作的发生",{"1":{"929":1}}],["的值都为",{"1":{"841":1}}],["的值",{"1":{"841":2,"929":1,"952":1}}],["的值跟編輯器中",{"1":{"641":1}}],["的值是",{"1":{"524":1}}],["的值取决于倍频数量",{"1":{"204":1}}],["的值为",{"1":{"157":1}}],["的值与abp值是不一样的",{"1":{"157":1}}],["的每个线程都会拥有",{"1":{"155":1}}],["的格式是",{"1":{"153":1}}],["的形式配置的授权地址",{"1":{"135":1}}],["的代码差不多",{"1":{"1054":1}}],["的代码发现了",{"1":{"951":1}}],["的代码",{"1":{"127":1}}],["的链路可达性分析算法解决的gc标记问题",{"1":{"116":1}}],["的不同之处是在返回构造",{"1":{"685":1}}],["的不同",{"1":{"111":1}}],["的回调通知",{"1":{"104":1}}],["的改变平均只需要对",{"1":{"92":1}}],["的改良算法",{"1":{"12":1}}],["的恒定视图",{"1":{"83":1}}],["的速率发送命令包",{"1":{"82":1}}],["的限制",{"1":{"82":1}}],["的方块同时又选择了inject模式",{"1":{"954":1}}],["的方向",{"1":{"781":1}}],["的方式就是前文提到的声明过程",{"1":{"966":1}}],["的方式还要快",{"1":{"942":1}}],["的方式为",{"1":{"438":1}}],["的方式来传输数据的",{"1":{"33":1}}],["的方法",{"1":{"201":1,"708":1,"756":1,"782":1}}],["的方案来克服这个困难",{"1":{"72":1}}],["的问题",{"1":{"68":1,"610":1,"981":1}}],["的时候会新建另一个加速流程",{"1":{"981":1}}],["的时候unity会自动地提取这些共享材质的静态模型的vertex",{"1":{"979":1}}],["的时候",{"1":{"219":1,"510":1,"574":1,"840":1,"841":1,"955":1,"959":1,"964":1}}],["的时候就会面临一个非常",{"1":{"68":1}}],["的时间到达",{"1":{"68":1}}],["的时间",{"1":{"51":1}}],["的事非常简单",{"1":{"62":1}}],["的延迟补偿",{"0":{"59":1}}],["的因素",{"1":{"51":1}}],["的",{"1":{"33":1,"85":1,"151":1,"153":1,"155":1,"217":1,"505":1,"508":1,"510":1,"536":1,"564":2,"573":1,"581":1,"634":1,"642":1,"661":1,"684":2,"685":2,"687":7,"693":1,"695":9,"721":1,"726":1,"759":1,"835":1,"864":1,"878":1,"916":1,"928":1,"941":3,"942":2,"943":1,"944":4,"945":1,"947":7,"948":3,"949":2,"950":2,"951":1,"954":1,"955":2,"956":2,"957":2,"958":1,"960":3,"961":2,"963":1,"964":6,"965":2,"966":2,"969":1,"970":1,"971":1,"977":2,"1000":2,"1001":1,"1003":1,"1036":2}}],["的概念來排版",{"1":{"635":1,"636":1}}],["的概念",{"1":{"12":1}}],["的乐观方式在每次interval时钟发生时固定将操作广播给所有用户",{"1":{"12":1}}],["是材质",{"1":{"1036":1}}],["是针对其他玩家的本地显示",{"1":{"1013":1}}],["是根據以下參數進行排序",{"1":{"975":1}}],["是按照组件来识别的",{"1":{"969":1}}],["是被完美",{"1":{"969":1}}],["是无法被区分的",{"1":{"966":1}}],["是啥我们还漏掉了一个",{"1":{"965":1}}],["是什么",{"1":{"965":1}}],["是什么呢",{"1":{"903":1}}],["是需要遍历",{"1":{"965":1}}],["是需要通过反射接口来调用的",{"1":{"718":1}}],["是如何被组织的",{"1":{"952":1}}],["是关键点",{"1":{"952":1}}],["是可以获取到",{"1":{"949":1}}],["是可继承的",{"1":{"948":1}}],["是普通的",{"1":{"942":1}}],["是因为需要实例化",{"1":{"965":1}}],["是因为这转换过程并非是一对一的过程",{"1":{"947":1}}],["是因为转换过程实际上是将编辑时方便的",{"1":{"946":1}}],["是因为",{"1":{"932":1,"942":1}}],["是自动引用计数的",{"1":{"930":1}}],["是怎么消耗掉很多资源的",{"1":{"898":1}}],["是batch的关键",{"1":{"861":1}}],["是用于",{"1":{"858":2}}],["是非常快的",{"1":{"942":1}}],["是非常直观的",{"1":{"846":1}}],["是非分代的",{"1":{"857":1}}],["是非世代和非压缩的",{"1":{"813":1}}],["是位图图像",{"1":{"844":1}}],["是unity的主要图形基元",{"1":{"844":1}}],["是客户端和服务端同时管理技能树",{"1":{"805":1}}],["是有方向",{"1":{"781":1}}],["是扇形角度范围内计算怪物是否在你的视野范围内其实可以这么看avatar的正方向向量与avatar到enemy之间向量的夹角大小是否小于于视线大小的一半",{"1":{"771":1}}],["是扇形的伤害范围",{"1":{"18":1}}],["是在扇形距离范围内",{"1":{"771":1}}],["是单位向量",{"1":{"763":1}}],["是单次延迟",{"1":{"55":1}}],["是旋转一定角度后",{"1":{"756":1}}],["是最简单的方法",{"1":{"916":1}}],["是最核心的操作",{"1":{"711":1}}],["是最终处理http请求的应用程序入口点",{"1":{"164":1}}],["是构建一个全局的appdomain",{"1":{"711":1}}],["是通过canvas",{"1":{"626":1}}],["是设置canvas如何根据屏幕进行缩放ugui的屏幕自适应",{"1":{"626":1}}],["是设备上的主要帐户",{"1":{"616":1}}],["是相对于父节点的偏移量",{"1":{"625":1}}],["是做不到的",{"1":{"622":1}}],["是两个完全不同的方法",{"1":{"600":1}}],["是两个完全没有关系的类型",{"1":{"599":1}}],["是外部应用程序",{"1":{"572":1}}],["是所见即所得",{"1":{"505":1}}],["是时候研究一下这三个模式在安全性和性能方面的区别了",{"1":{"451":1}}],["是由",{"1":{"450":1,"635":1,"636":1,"944":1}}],["是由很多因素决定的",{"1":{"82":1}}],["是我的凭证配置",{"1":{"420":1}}],["是10",{"1":{"372":1}}],["是不包含在conversion",{"1":{"965":1}}],["是不会有效果的",{"1":{"952":1}}],["是不会触发函数的",{"1":{"748":1}}],["是不同于引用类型的",{"1":{"883":1}}],["是不是有点晕",{"1":{"862":1}}],["是不是看到了",{"1":{"854":1}}],["是不想再呆在最下面的三太郎",{"1":{"296":1}}],["是不一样的",{"1":{"15":1}}],["是任性妄为的一太郎",{"1":{"296":1}}],["是镰刀还是执政官甲",{"1":{"271":1}}],["是34级",{"1":{"270":1}}],["是多个则击中两个",{"1":{"244":1}}],["是特效的runtime包含了特效的双方和target",{"1":{"231":1}}],["是个有趣的小结构",{"1":{"225":1}}],["是爬梯子上去的平台",{"1":{"225":1}}],["是梯子",{"1":{"225":1}}],["是砖块",{"1":{"225":1}}],["是ok的",{"1":{"224":1}}],["是空的",{"1":{"221":1}}],["是交错执行的",{"1":{"158":1}}],["是microsoft",{"1":{"125":1}}],["是c",{"1":{"125":1}}],["是对于查询隐藏的",{"1":{"966":1}}],["是对属性范围和方法范围的设置",{"1":{"714":1}}],["是对cgi的开放的扩展",{"1":{"575":1}}],["是对",{"1":{"107":1}}],["是为了预留资源加载的时间",{"1":{"103":1}}],["是否將渲染結果覆蓋原本的",{"1":{"974":1}}],["是否蓝色名字",{"1":{"965":1}}],["是否从",{"1":{"965":1}}],["是否发生碰撞",{"1":{"768":1}}],["是否可以无限延伸",{"0":{"733":1}}],["是否可以有木头",{"1":{"301":1}}],["是否可以有食材",{"1":{"301":1}}],["是否可以有药材",{"1":{"301":1}}],["是否相交",{"1":{"693":1}}],["是否大于最大射线距离等等",{"1":{"676":1}}],["是否阻塞",{"1":{"451":2}}],["是否连通ping通后",{"1":{"404":1}}],["是否连通如果不通",{"1":{"404":1}}],["是否保持练武成效50以上",{"1":{"373":1}}],["是否要做",{"1":{"287":1}}],["是否有接取条件",{"1":{"252":1}}],["是否有故障和异常",{"1":{"88":1}}],["是否自动开始",{"1":{"252":1}}],["是否隐身",{"1":{"241":1}}],["是否变身",{"1":{"241":1}}],["是否装备指定武器",{"1":{"241":1}}],["是否满足阈值等等",{"1":{"51":1}}],["是否需要把每个玩家往后拉一段时间的",{"1":{"50":1}}],["是否采用这种方法取决于游戏设计者",{"1":{"49":1}}],["是这样的",{"1":{"46":1,"225":1}}],["是开始",{"1":{"43":1}}],["是动作游戏能否成功的一个重要因素",{"1":{"40":1}}],["是的",{"1":{"34":1,"107":2,"108":1,"886":1}}],["是指数据的高字节保存在内存的高地址中",{"1":{"32":1}}],["是指数据的高字节",{"1":{"32":1}}],["是一堆converttoentity的结果",{"1":{"971":1}}],["是一些包含数学计算和算法的小脚本",{"1":{"844":1}}],["是一些参数的数量",{"1":{"821":1}}],["是一些其他类或者结构体的名字",{"1":{"821":1}}],["是一项用于检测凸多边形碰撞的技术",{"1":{"782":1}}],["是一只灵活的白色小狗",{"1":{"296":1}}],["是一只壮硕的橘色大猫",{"1":{"296":1}}],["是一种更加",{"1":{"969":1}}],["是一种特殊的组件",{"1":{"928":1}}],["是一种特殊的哈希算法",{"1":{"92":1}}],["是一种web服务器网关接口",{"1":{"578":1}}],["是一种访问代理的方式",{"1":{"471":1}}],["是一种公平",{"1":{"212":1}}],["是一种以可预测的方式发布应用的技术",{"1":{"88":1}}],["是一个ibufferelementdata",{"1":{"1007":1}}],["是一个interpreter",{"1":{"130":1}}],["是一个不太可能达到的值",{"1":{"960":1}}],["是一个很好的资源",{"1":{"833":1}}],["是一个很费时的操作",{"1":{"701":1}}],["是一个具有循环属性的顺序节点",{"1":{"795":1}}],["是一个",{"1":{"581":1,"958":1,"965":1,"1001":1}}],["是一个协议",{"1":{"572":1}}],["是一个功能集合",{"1":{"164":1}}],["是一个比较有意义的问题",{"1":{"37":1}}],["是一个难点",{"1":{"15":1}}],["是一样的",{"1":{"15":2}}],["是完全可行的",{"1":{"944":1}}],["是完全由服务器的怪物ai系统触发",{"1":{"17":1}}],["是完全不是一个概念的",{"1":{"15":1}}],["是完全和pve",{"1":{"15":1}}],["是真实逻辑的预测",{"1":{"15":1}}],["是",{"1":{"12":1,"207":2,"405":1,"465":1,"507":1,"536":2,"575":1,"641":2,"644":1,"932":1,"952":2,"970":2,"1036":1}}],["是要等到所有玩家都输入之后",{"1":{"12":1}}],["是运行在后台的一种特殊进程",{"1":{"3":1}}],["在所有东西上方",{"1":{"1041":1}}],["在之前的所有渲染队列都渲染完了之后渲染",{"1":{"1036":1}}],["在之前的文章中",{"1":{"73":1}}],["在屏幕上",{"1":{"1025":1}}],["在函数中没有",{"1":{"1022":1}}],["在函数调用树中提供一个清晰界面来显示托管内存分配是在哪里发生的",{"1":{"815":1}}],["在确保本机",{"1":{"1022":1}}],["在声明query的时候",{"1":{"994":1}}],["在声明之后",{"1":{"964":1}}],["在当前系统请求lsv的结果是上一帧该系统的版本号",{"1":{"991":1}}],["在当前节点上添加一个组件canvasgroup",{"1":{"657":1}}],["在当前节点激活的时候",{"1":{"283":1}}],["在当前节点未激活的时候",{"1":{"283":2}}],["在添加后手动加入b组件",{"1":{"987":1}}],["在删除entity后",{"1":{"986":1}}],["在受到多个光源是无法合批流程原理",{"1":{"980":1}}],["在批次间的消耗降低了很多",{"1":{"980":1}}],["在茂密的森林级别将树标记为静态会严重影响内存",{"1":{"979":1}}],["在很多不同的gameobject引用同一模型的情况下",{"1":{"979":1}}],["在很多地方例如click事件触发的时候往往不是在该射线检测到的gameobject上",{"1":{"679":1}}],["在后续的绘制过程中",{"1":{"979":1}}],["在后台被作为像一个整数来对待",{"1":{"822":1}}],["在进入",{"1":{"971":1}}],["在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中",{"1":{"980":1}}],["在进行射线检测的时候会用到",{"1":{"688":1}}],["在进行射线检测的时候",{"1":{"685":1}}],["在进行",{"1":{"456":1}}],["在进行行程安排时",{"1":{"382":1}}],["在进行网络传输的时候",{"1":{"37":1}}],["在进行网络通信时是否需要进行字节序转换",{"0":{"36":1}}],["在0~10之间的随机位置上实例化该",{"1":{"969":1}}],["在被转换后的",{"1":{"969":1}}],["在前例的情况中",{"1":{"965":1}}],["在创建",{"1":{"964":1}}],["在查询上更加灵活",{"1":{"955":1}}],["在但",{"1":{"954":1}}],["在改变用于绘制的数据这方面",{"1":{"940":1}}],["在绘制之前",{"1":{"940":1}}],["在内部",{"1":{"940":1,"947":1}}],["在内存上的位置可能会发生变化",{"1":{"131":1}}],["在内存上",{"1":{"131":1}}],["在内存中因该是以大端法存放的",{"1":{"37":1}}],["在内存中的地址为0x0010",{"1":{"33":1}}],["在它们没被删除的时候",{"1":{"936":1}}],["在主线程获取dynamicbuffer的长度时",{"1":{"997":1}}],["在主线程中如何等待job执行完毕呢",{"1":{"924":1}}],["在主线程访问job数据的唯一方法就是写入",{"1":{"920":1}}],["在主方法main",{"1":{"897":1}}],["在结构体中添加一个execute方法",{"1":{"920":1}}],["在包含这些组件的原型中查询符合要求的实体",{"1":{"915":1}}],["在job执行完成后执行这个command",{"1":{"908":1}}],["在需要的时候在加上components",{"1":{"907":1}}],["在需要渲染的时候",{"1":{"849":1}}],["在代码层面",{"1":{"906":1}}],["在代码运行时负责跟踪每一个线程的所在",{"1":{"885":1}}],["在代码生成时",{"1":{"739":1}}],["在时间轴性能分析器",{"1":{"878":1}}],["在面板的下半部分显示了我们选中的profilers当前帧的详细内容",{"1":{"878":1}}],["在面板中并没有表现",{"1":{"809":1}}],["在紧凑循环中运行较小的方法时",{"1":{"858":1}}],["在紧凑循环中尽量少用",{"1":{"858":1}}],["在刷新垂直同步的时候",{"1":{"855":1}}],["在显示一帧画面时",{"1":{"854":1}}],["在同一帧中这是同一块操作",{"1":{"940":1}}],["在同一个场景中显示多个视口的时候",{"1":{"841":1}}],["在同步块索引上修改一位标识",{"1":{"131":1}}],["在他们的项目中经过上面的改动",{"1":{"839":1}}],["在那个单例类的构造",{"1":{"836":1}}],["在那一秒内",{"1":{"75":1}}],["在ios上使用此策略时",{"1":{"830":1}}],["在il2cpp脚本后端下",{"1":{"819":1}}],["在il2cpp脚本后端下所有使用匿名函数的情况都会分配托管堆内存",{"1":{"819":1}}],["在il2cpp中",{"1":{"819":1}}],["在ilruntime中",{"1":{"714":1,"715":1}}],["在ilruntime中解决这个问题有两种方式",{"1":{"599":1}}],["在搜索结束时",{"1":{"827":1}}],["在参数传递期间直接存储和复制的类型称为值类型",{"1":{"826":1}}],["在参考分辨率下",{"1":{"625":1}}],["在持续的循环中重复的访问它们会导致性能热点",{"1":{"824":1}}],["在值类型对象",{"1":{"823":1}}],["在性能敏感的代码中应该尽量最小化使用匿名函数和函数引用",{"1":{"818":1}}],["在性能方面要优于模式",{"1":{"451":1}}],["在conversion",{"1":{"964":1,"1054":1}}],["在context中可以对entity进行快速过滤",{"1":{"740":1}}],["在c处转换就停止了",{"1":{"952":1}}],["在c++中如果数据排布不佳依然不一定能高效迭代",{"1":{"940":1}}],["在clone",{"1":{"896":1}}],["在cpu",{"1":{"878":1}}],["在c",{"1":{"818":1,"898":1}}],["在分类思路上",{"1":{"861":1}}],["在分析过程中深度分析器按钮保持灰色",{"1":{"815":1}}],["在分离轴定理中",{"1":{"762":1,"785":1}}],["在深度分析模式",{"1":{"815":1}}],["在深处挖一无所得3",{"1":{"295":1}}],["在目标设备上使用开发模式构建可以分析托管内存分配",{"1":{"815":1}}],["在托管代码中创造的所有对象必须被分配在托管堆上",{"1":{"813":1}}],["在概念里",{"1":{"811":1}}],["在弹道命中敌人时候",{"1":{"811":1}}],["在新的设计中",{"1":{"811":1}}],["在给单位挂一个新的buff的之前",{"1":{"800":1}}],["在给一个entity添加一个component时",{"1":{"738":1}}],["在执行每遍收集时必须扫描整个堆",{"1":{"857":1}}],["在执行某个技能的时候",{"1":{"791":1}}],["在执行这个程序的时候",{"1":{"455":1}}],["在阅读了大量有关碰撞检测的资料",{"1":{"782":1}}],["在半径之内的敌人受伤",{"1":{"776":1}}],["在半条命引擎中",{"1":{"50":1}}],["在半条命中",{"1":{"44":1,"46":1,"50":1}}],["在半条命这个游戏中",{"1":{"43":1}}],["在程序中",{"1":{"761":1}}],["在任意角度下的投影是否均存在重叠",{"1":{"761":1}}],["在任何转换系统运行之前",{"1":{"1054":1}}],["在任何一款称得上是",{"1":{"217":1}}],["在任何的有竞争关系的游戏中",{"1":{"62":1}}],["在小球飞行的过程中",{"1":{"760":1}}],["在小端模式下",{"1":{"32":1}}],["在线运行案例",{"1":{"756":1}}],["在线运行示例",{"1":{"753":1,"754":1,"755":1,"758":1}}],["在系统中的构造函数中",{"1":{"745":1}}],["在replacecomponent时",{"1":{"739":1}}],["在移除component时可能会通过group把这个移除事件发送到监听remove行为的collector中",{"1":{"739":1}}],["在移植maplestroy的过程中",{"1":{"17":1}}],["在销毁一个entity时",{"1":{"739":1}}],["在视差层设置对象最好的方法是在编辑模式下去播放游戏",{"1":{"737":1}}],["在mimpi",{"1":{"737":1}}],["在maplestroy的设计当中",{"1":{"17":1}}],["在z",{"1":{"737":1}}],["在正交视差中",{"1":{"737":1}}],["在正常战斗中",{"1":{"48":1}}],["在system申请写入权限的时候",{"1":{"991":1}}],["在sortinglayer高的绝对会在sortinglayer前面",{"1":{"976":1}}],["在steam版本中",{"1":{"737":1}}],["在screentoworldpoint这个方法中",{"1":{"1025":1}}],["在screen",{"1":{"640":2}}],["在空文本文件的第一行",{"1":{"722":1}}],["在热更新dll中调用",{"1":{"716":1}}],["在获取到类和方法的相关信息后",{"1":{"715":1}}],["在获取其屏幕坐标时",{"1":{"640":1}}],["在工程运行的时候",{"1":{"708":1}}],["在其中实现对应的类和方法",{"1":{"708":1}}],["在其他几种",{"1":{"695":1}}],["在其他时候",{"1":{"455":1}}],["在渲染诸如建筑",{"1":{"849":1}}],["在渲染中",{"1":{"695":1}}],["在渲染与文化相关的函数的时候会检视这些对象值",{"1":{"155":1}}],["在循环中对每一个",{"1":{"690":1}}],["在射线检测物体时会用到",{"1":{"683":1}}],["在放入到result之前会将这些graphic根据深度进行排序",{"1":{"676":1}}],["在ngui中我们都知道事件触发靠射线检测",{"1":{"675":1}}],["在npc那里通过赌博得到",{"1":{"269":1}}],["在npc那里买到",{"1":{"269":1}}],["在刚刚enable的时候会更新输入模块列表",{"1":{"668":1}}],["在相机上添加physics2draycaster",{"1":{"663":1}}],["在entitan的system初始化initialize前因为初始化系统大多会有add",{"1":{"745":1}}],["在entitas",{"1":{"739":1}}],["在eventsystem的标准输入standalone",{"1":{"658":1}}],["在edit",{"1":{"653":1}}],["在编辑器上可以填写当事件发生时传什么参数",{"1":{"657":1}}],["在编译时进行优化",{"1":{"130":1}}],["在update中輪詢input物件",{"0":{"653":1}}],["在unity执行build的时候",{"1":{"979":1}}],["在unity5中",{"1":{"876":1}}],["在unity官方文档中",{"0":{"824":1}}],["在unity官方2d游戏demo中已使用到了视差滚动技术",{"1":{"736":1}}],["在unity版本的mono的c",{"1":{"823":1}}],["在unity运行时使用c",{"1":{"820":1}}],["在unity的cpu",{"1":{"815":1}}],["在unity主工程中",{"1":{"714":1}}],["在unity中",{"1":{"876":2}}],["在unity中应该避免使用foreach循环",{"1":{"823":1}}],["在unity中有好多使用一个正交相机并用脚本移动图层来设置视差层级的教程",{"1":{"737":1}}],["在unity中通过使用",{"1":{"701":1}}],["在unity中使用",{"1":{"699":1}}],["在unity",{"1":{"591":1}}],["在锚点完全不重合的情况下",{"1":{"644":1}}],["在锚点全部重合的情况下",{"1":{"644":1}}],["在中间位置添加panel",{"1":{"639":1}}],["在透過快速設定器修改",{"1":{"633":1}}],["在編輯器中快速設定",{"0":{"632":1}}],["在此期间您可以执行一些操作",{"1":{"699":1}}],["在此維度的值才會剛好等於最後顯示的",{"1":{"644":1}}],["在此模式下不会留黑边但是会导致显示不完全",{"1":{"628":1}}],["在此方案中",{"1":{"604":1}}],["在网上搜了些答案",{"1":{"610":1}}],["在没有必要的情况下经常访问有数组值的unity的api效果非常不理想",{"1":{"824":1}}],["在没有进行足够全面的测试的情况下",{"1":{"594":1}}],["在没有elk的时候相当不方便",{"1":{"30":1}}],["在你日常的",{"1":{"965":1}}],["在你的",{"1":{"950":1}}],["在你的c程序传给java程序之前有必要进行字节序的转换工作",{"1":{"34":1}}],["在你删除实体时",{"1":{"936":1}}],["在你审视这些代码前",{"1":{"592":1}}],["在生成c++代码时为里面的类型和方法使用更短的名字",{"1":{"592":1}}],["在生产环境下进行打包时",{"1":{"537":1}}],["在windows环境并且建立一个全新的空项目",{"1":{"592":1}}],["在windows平台你可以在unity安装路径的editor",{"1":{"590":1}}],["在windows平台上是小端字节序",{"1":{"38":1}}],["在开始的0",{"1":{"854":1}}],["在开始菜单中点击",{"1":{"407":1}}],["在开发mimpidreams时",{"1":{"737":1}}],["在开发il2cpp的过程中",{"1":{"590":1}}],["在开发期间",{"1":{"586":1}}],["在国外",{"1":{"569":1}}],["在最左上角",{"1":{"841":1}}],["在最后一行添加此处需要根据你自己解压的路径去修改",{"1":{"559":1}}],["在最坏的情况下",{"1":{"82":1}}],["在页面的右上角",{"1":{"542":1}}],["在官方文档中",{"1":{"536":1}}],["在加载",{"1":{"940":1}}],["在加载clr时会创建一个默认的appdomain",{"1":{"707":1}}],["在加载我们的插件的过程中",{"1":{"535":1}}],["在加载和执行程序集的内容时",{"1":{"129":1}}],["在项目的根目录下执行以下命令",{"1":{"535":1}}],["在项目没有引入hangfire之前",{"1":{"30":1}}],["在解决方案文件夹中",{"1":{"524":1}}],["在控制台执行以下命令安装",{"1":{"465":1,"466":1}}],["在整个视差背景实现过程中",{"1":{"724":1}}],["在整个",{"1":{"455":1}}],["在数据库中的值就为",{"1":{"454":1}}],["在服务器上",{"1":{"1013":1}}],["在服务器载入数据的过程中",{"1":{"452":1}}],["在服务端创建",{"1":{"807":1}}],["在服务端",{"1":{"73":1}}],["在上图中",{"1":{"905":1}}],["在上面的图中",{"1":{"898":1}}],["在上面的图表中",{"1":{"813":1}}],["在上面的代码中使用了",{"1":{"684":1}}],["在上面的例子",{"1":{"69":1}}],["在上面的例子里",{"1":{"68":1}}],["在上面挂一个animatorcontroller",{"1":{"601":1}}],["在上面这个例子中",{"1":{"592":1}}],["在上一个小节",{"1":{"451":1}}],["在上一句的说明里面使用了词语",{"1":{"449":1}}],["在physics2d设置中layercollisionmatrix中的格子不应该都勾选上",{"1":{"868":1}}],["在physics设置中layercollisionmatrix中的格子不应该都勾选上",{"1":{"868":1}}],["在powershell命令控制台中运行",{"1":{"429":2}}],["在pe",{"1":{"131":1}}],["在运行对话框中输入",{"1":{"407":1}}],["在运行时",{"1":{"960":1}}],["在运行时都很有可能遇到问题",{"1":{"603":1}}],["在运行时会剥离去除get属性",{"1":{"598":1}}],["在运行时再去从外部获取依赖",{"1":{"537":1}}],["在运行时已经确定是developer",{"1":{"131":1}}],["在运行时读取il汇编代码",{"1":{"130":1}}],["在ts中使用jquery",{"1":{"401":1}}],["在ts中引入声明文件",{"1":{"400":1}}],["在使用",{"1":{"971":1}}],["在使用坐标系过程中我们还要关注其他方方面面",{"1":{"842":1}}],["在使用此策略时应该小心",{"1":{"831":1}}],["在使用此工具前需要将配置中的",{"1":{"700":1}}],["在使用较大的",{"1":{"722":1}}],["在使用全局类库的引入方式时",{"1":{"401":1}}],["在使用一致哈希算法后",{"1":{"92":1}}],["在html文件标签中引入该库",{"1":{"399":1}}],["在100级时有353点闪避的基础值",{"1":{"385":1}}],["在100帧的时候",{"1":{"15":1}}],["在不同的任务栏内放入对应数量的小铜人",{"1":{"382":1}}],["在风光的背后天天进行着怎样的工作呢",{"1":{"382":1}}],["在3d游戏中",{"1":{"748":1}}],["在3种职位中",{"1":{"381":1}}],["在3维空间则是8个",{"1":{"197":2}}],["在3维空间则是8个顶点",{"1":{"197":1}}],["在有空厢房时",{"1":{"380":1}}],["在江湖上开帮立派",{"1":{"380":1}}],["在领悟室里所得练武经验值非常高",{"1":{"373":1}}],["在於不怕讨伐受伤休息太久而不高兴",{"1":{"372":1}}],["在庭院廊下安静听完",{"1":{"296":1}}],["在附近设下结界",{"1":{"296":1}}],["在路边检到了勾玉袋和一盆丸子串",{"1":{"296":1}}],["在海边钓鱼1",{"1":{"290":1}}],["在返回失败的时候被repeatuntilsuccess",{"1":{"284":1}}],["在噩梦和地狱的难度中",{"1":{"265":1}}],["在普通难度上",{"1":{"265":1}}],["在link的时候",{"0":{"264":1}}],["在传统的",{"1":{"940":1}}],["在传统的2d",{"1":{"225":1}}],["在传统的游戏中",{"1":{"217":1}}],["在浏览器里面运行它",{"1":{"223":1}}],["在看了半天算法之后",{"1":{"221":1}}],["在写ts声明文件的时候",{"1":{"398":1}}],["在写任何代码之前",{"1":{"218":1}}],["在写代码的时候",{"1":{"124":1}}],["在陆地上对玩家初始占位符进行均匀采样",{"1":{"214":1}}],["在游戏开发中",{"1":{"841":1}}],["在游戏开发领域",{"1":{"214":1}}],["在游戏中需要魅力高的内门弟子去各大门派攻破长老心防",{"1":{"391":1}}],["在游戏中外观和普通怪一样",{"1":{"266":1}}],["在游戏运行时使用噪声算法",{"1":{"204":1}}],["在2d游戏上",{"1":{"748":1}}],["在2d游戏开发中",{"1":{"207":1}}],["在2d情况下",{"1":{"208":1}}],["在2d里",{"1":{"206":1}}],["在初始化过程中",{"1":{"169":1}}],["在每一个系统更新",{"1":{"991":1}}],["在每次调用drawcall之前",{"1":{"876":1}}],["在每次循环整个结束的时候这个值会被装箱一次",{"1":{"823":1}}],["在每次请求里",{"1":{"151":1}}],["在每个小格子中间放一个灯塔",{"1":{"104":1}}],["在每个更新周期内服务器处理传入的用户命令",{"1":{"82":1}}],["在每个更新循环迭代中",{"1":{"73":1}}],["在每个",{"1":{"12":1}}],["在大多数平台上",{"1":{"814":1}}],["在大多数时间里",{"1":{"383":1}}],["在大多数情况下",{"1":{"130":1}}],["在大端模式下",{"1":{"32":1}}],["在命令行中使用msbuild",{"1":{"125":1}}],["在命令行中",{"1":{"125":1}}],["在做循环引用的时候是不会出现垃圾回收问题的",{"1":{"124":1}}],["在gc线程开启时",{"1":{"121":1}}],["在垃圾回收时",{"1":{"120":1}}],["在对象头处维护一个counter计数器",{"1":{"115":1}}],["在堆中存储对象时",{"1":{"115":1}}],["在y链表上找到该节点",{"1":{"105":1}}],["在x链表上找到该节点",{"1":{"105":1}}],["在地图的随机点上安排上楼和下楼的楼梯",{"1":{"220":1}}],["在地图中间挖一个房间出来",{"1":{"220":1}}],["在地图上随机选择一个方块",{"1":{"220":1}}],["在地图上",{"1":{"18":1}}],["在地格上记录观察者就可以模拟这种灯塔模型",{"1":{"104":1}}],["在环空间上的位置如下",{"1":{"92":1}}],["在某系统更新",{"1":{"991":1}}],["在某些大资源被销毁时",{"1":{"701":1}}],["在某一次发布中",{"1":{"89":1}}],["在某种程度上相当于你在一个光速非常非常慢的宇宙中进行游戏",{"1":{"79":1}}],["在非隔离基础架构",{"1":{"88":1}}],["在部署期间",{"1":{"88":1}}],["在部署的过程中",{"1":{"88":1}}],["在蓝色环境",{"1":{"88":1}}],["在绿色环境",{"1":{"88":1}}],["在现实世界中",{"1":{"85":1}}],["在客户端没有关于其他实体的正确信息和环境时",{"1":{"84":1}}],["在客户端接收到的最后一个快照是在tick",{"1":{"83":1}}],["在权威服务器的环境中",{"1":{"77":1}}],["在接下来的100毫秒内",{"1":{"75":1}}],["在接下来的场景中",{"1":{"73":1}}],["在高速行驶时",{"1":{"75":1}}],["在本节开始前我需要重申一遍",{"1":{"198":1}}],["在本文所介绍的改进版柏林噪声中",{"1":{"197":1}}],["在本文中将使用",{"1":{"465":1}}],["在本文中",{"1":{"72":1}}],["在本地客户端只是预测自己的用户命令的结果",{"1":{"84":1}}],["在本系列的",{"1":{"72":1}}],["在我们添加了",{"1":{"951":1}}],["在我们系统中",{"1":{"805":1}}],["在我们的例子下一个渲染帧的时间是10",{"1":{"83":1}}],["在我们的例子中",{"1":{"69":1}}],["在我們這次使用的網頁介面實作項目",{"1":{"564":1}}],["在我写",{"1":{"219":1}}],["在我参考的论文里没有提及具体的方式",{"1":{"210":1}}],["在我的简体中文系统上是以gb2312的编码",{"1":{"39":1}}],["在实践中",{"1":{"897":1}}],["在实际运行中",{"1":{"449":1}}],["在实际应用中",{"1":{"96":1}}],["在实际的网络环境中",{"1":{"66":1}}],["在实现逻辑的过程中",{"1":{"15":1}}],["在实现中客户端需要计算一些关键信息的hash值",{"1":{"15":1}}],["在第二篇中",{"1":{"77":1}}],["在第二帧的时候",{"1":{"11":1,"12":1}}],["在第一篇文章中",{"1":{"66":1}}],["在下面这个",{"1":{"969":1}}],["在下面的文章",{"1":{"65":1}}],["在下一个工程中",{"1":{"737":1}}],["在下载目录按住",{"1":{"533":1}}],["在下载时速度可能会比较慢",{"1":{"478":1}}],["在下行协议包中带上",{"1":{"51":1}}],["在计算机网络里的属于叫做hops",{"1":{"64":1}}],["在真实情况下",{"1":{"64":1}}],["在发布各个版本之前",{"1":{"594":1}}],["在发完一个更新包以后就需要等待一个固定更新周期时间以后再发下一个包",{"1":{"50":1}}],["在发送之前需要使用系统提供的字节序转换函数htonl",{"1":{"37":1}}],["在这次的项目中",{"1":{"811":1}}],["在这以后就是按套路遍历另一个多边形的每条投影轴",{"1":{"785":1}}],["在这儿",{"1":{"714":1}}],["在这些发布中我们修正了超过100个bug",{"1":{"594":1}}],["在这之前tc表还有一系列的pick过程",{"1":{"275":1}}],["在这一点上",{"1":{"827":1}}],["在这一步才加入游戏中大多数的怪兽",{"1":{"220":1}}],["在这一秒你告诉服务器",{"1":{"63":1}}],["在这步",{"1":{"220":1}}],["在这个例子当中",{"1":{"885":1}}],["在这个例子中",{"1":{"817":1}}],["在这个循环中每次迭代不会装箱",{"1":{"823":1}}],["在这个极度简单的例子中",{"1":{"820":1}}],["在这个版本中",{"1":{"817":1}}],["在这个函数中我们可以看到",{"1":{"717":1}}],["在这个算法里面",{"1":{"220":1}}],["在这个记录矩阵中",{"1":{"210":1}}],["在这篇文章里",{"1":{"217":1}}],["在这篇文章中",{"1":{"66":1,"77":1}}],["在这几个区域不需要过多考虑回收的问题",{"1":{"113":1}}],["在这是",{"1":{"69":1}}],["在这种方式下",{"1":{"728":1}}],["在这种模式中",{"1":{"449":1}}],["在这种模式下",{"1":{"448":2,"450":1,"451":1}}],["在这种模型中",{"1":{"66":1}}],["在这种类型编辑器里",{"1":{"225":1}}],["在这种假设下",{"1":{"67":1}}],["在这种情况下返回的result为",{"1":{"696":1}}],["在这种情况下你不需要处理迁移问题",{"1":{"142":1}}],["在这种情况下你还要给玩家平滑的移动",{"1":{"77":1}}],["在这种情况下数据的格式可以很好的优化一下",{"1":{"76":1}}],["在这种情况下",{"1":{"64":1,"76":1,"83":1,"125":1,"813":1,"832":1}}],["在这种极端情况下",{"1":{"48":1}}],["在这里你可以通过添加",{"1":{"964":1}}],["在这里你可以做任何相关联的事儿",{"1":{"957":1}}],["在这里对比",{"1":{"412":1}}],["在这里可进行人事方面的任免",{"1":{"380":1}}],["在这里",{"1":{"264":1,"964":1}}],["在这里不做详细的介绍",{"1":{"170":1}}],["在这里需要理解可能会产生一些矛盾和不一致",{"1":{"48":1}}],["在这里我想说说两种语言",{"1":{"34":1}}],["在角落里被击中",{"1":{"48":1}}],["在插值过程中",{"1":{"46":1}}],["在判断目标的时候需要考虑到延迟",{"1":{"45":1}}],["在世界上其它国家可能需要更长的一段时间",{"1":{"40":1}}],["在多个不同系统架构都用",{"1":{"39":1}}],["在80x86平台中",{"1":{"37":1}}],["在appdomain中内嵌了一套invoke的实现",{"1":{"715":1}}],["在addressables中也是这样的",{"1":{"699":1}}],["在asp",{"1":{"164":1,"174":1}}],["在activate后再registertimer",{"1":{"161":1}}],["在arm上",{"1":{"33":1}}],["在a和b执行完100帧后",{"1":{"15":1}}],["在两种不同字节序cpu中的存储顺序如下图",{"1":{"32":1}}],["在手机上是可以接受的",{"1":{"18":1}}],["在一分钟之内",{"1":{"815":1}}],["在一般情况下",{"1":{"451":1}}],["在一个",{"1":{"965":1}}],["在一个实体被删除的时候",{"1":{"936":1}}],["在一个函数或类中声明",{"1":{"819":1}}],["在一个更大的空间上生成满足样本结构约束的新数据",{"1":{"207":1}}],["在一个良好的网络环境中",{"1":{"86":1}}],["在一个回合制的游戏里",{"1":{"70":1}}],["在一个地图当中",{"1":{"16":1}}],["在一定延迟后",{"1":{"15":1}}],["在处理快照上",{"1":{"15":1}}],["在",{"0":{"721":1},"1":{"15":1,"72":1,"126":1,"127":1,"176":1,"225":1,"412":1,"449":2,"505":1,"510":1,"535":1,"537":1,"576":1,"577":1,"610":1,"635":1,"636":1,"650":1,"656":2,"661":1,"683":2,"684":1,"685":2,"695":2,"699":1,"701":1,"722":2,"726":3,"742":1,"780":1,"835":1,"841":1,"878":1,"937":1,"939":1,"947":1,"949":2,"951":2,"959":1,"960":1,"961":1,"964":2,"966":1,"967":1,"968":1,"971":4,"974":2,"975":2,"977":1,"979":1,"1002":1,"1022":1,"1036":1},"2":{"722":1}}],["在启动之初",{"1":{"12":1}}],["在玩家断线重连的时候",{"1":{"12":1}}],["你懒得点",{"1":{"971":1}}],["你太懒了",{"1":{"971":1}}],["你完全可以使用下述static方法自行",{"1":{"970":1}}],["你完全可以用",{"1":{"955":1}}],["你便同时添加了prefab和linkedentitygroup",{"1":{"964":1}}],["你便拥有了基于",{"1":{"955":1}}],["你依然可以在conversion",{"1":{"964":1}}],["你依然要提供icloneable",{"1":{"111":1}}],["你有另一个声明",{"1":{"964":1}}],["你有一些数据",{"1":{"940":1}}],["你无法在",{"1":{"964":1}}],["你无法把嵌套",{"1":{"960":1}}],["你无需担心它们是否已经被创建了或者担心convert",{"1":{"962":1}}],["你最多可以放进去",{"1":{"960":1}}],["你最好复习一下这方面的内容",{"1":{"782":1}}],["你想在发布游戏时",{"1":{"971":1}}],["你想保留原始的",{"1":{"954":1}}],["你想要",{"1":{"945":1}}],["你如果要放在这两个",{"1":{"949":1}}],["你如果想模拟出一百倍于近景的远景",{"1":{"724":1}}],["你得确保你的",{"1":{"949":1}}],["你得推它",{"1":{"225":1}}],["你应该使用renderer",{"1":{"979":1,"980":1}}],["你应该已经注意到",{"1":{"945":1}}],["你应该在表中同步相同的变化",{"1":{"142":1}}],["你甚至可以使用",{"1":{"944":1,"946":1,"1000":1}}],["你还可以注意到",{"1":{"966":1}}],["你还可以增加一些有趣的元素",{"1":{"220":1}}],["你还能添加",{"1":{"943":1}}],["你已经使用了该",{"1":{"943":1}}],["你已经在t=900收到了一次位置信息",{"1":{"76":1,"1015":1}}],["你拥有",{"1":{"943":1}}],["你就可以使用",{"1":{"964":1}}],["你就可以制作",{"1":{"955":1}}],["你就可以在主线程中安全地访问job中使用的",{"1":{"924":1}}],["你就可以了解到",{"1":{"906":1}}],["你一定要注意内存的占用问题",{"1":{"898":1}}],["你一般不会去担心有人在你的单人游戏中去作弊",{"1":{"62":1}}],["你通过",{"1":{"841":1}}],["你通常复制原始实体的一些值",{"1":{"142":1}}],["你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和",{"1":{"783":1}}],["你所显示的都是玩家的真实数据",{"1":{"76":1,"1015":1}}],["你或许会想做成动作模式不就完了吗",{"1":{"750":1}}],["你设置的值和实际的值是有很大区别的例如",{"1":{"645":1}}],["你设计的目标是100ms的某个目标",{"1":{"76":1}}],["你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖",{"1":{"633":1}}],["你当然也可以把这些放入列表中",{"1":{"592":1}}],["你能在",{"1":{"960":1}}],["你能通过查看随unity一起发布的libil2cpp头文件来窥探其代码组织方式",{"1":{"591":1}}],["你能看出来",{"1":{"225":1}}],["你首先要做的是在",{"1":{"503":1}}],["你会在",{"1":{"964":1}}],["你会得到",{"1":{"953":1}}],["你会得到一个关联",{"1":{"964":1}}],["你会得到一个",{"1":{"481":1}}],["你会注意到",{"1":{"943":1}}],["你会发现stirng类型在图中并不是一个针指向另一个内存对象",{"1":{"898":1}}],["你会发现另外一个三角图元也出现了",{"1":{"847":1}}],["你会看到多了两个文件",{"1":{"503":1}}],["你会看到在服务器时间绘制的玩家包围盒",{"1":{"83":1}}],["你会新建一个",{"1":{"502":1}}],["你调再高的薪资给他也都只是普通心情",{"1":{"372":1}}],["你懂了http",{"1":{"225":1}}],["你让这里有个砖块",{"1":{"225":1}}],["你用关卡编辑器做出的地图可能看起来像这样",{"1":{"225":1}}],["你需要在",{"1":{"964":1}}],["你需要用",{"1":{"955":1}}],["你需要显式地指定",{"1":{"950":1}}],["你需要拿走最上面的盒子才能拿到下一个盒子",{"1":{"879":1}}],["你需要继续检测直到把两个多边形的每条边都检测完",{"1":{"784":1}}],["你需要检测的角度数量就正是这个多边形的边数",{"1":{"783":1}}],["你需要考虑正交相机的尺寸和视角设置的透视区域",{"1":{"737":1}}],["你需要使用android",{"1":{"586":1}}],["你需要知道它会占用的空间大小",{"1":{"220":1}}],["你需要给玩家即时的响应",{"1":{"71":1}}],["你不想让这些",{"1":{"971":1}}],["你不必担心你只是在操作一个指针",{"1":{"898":1}}],["你不必发十倍的数据",{"1":{"76":1}}],["你不手动扔掉它",{"1":{"879":1}}],["你不能随意的寻找一个方块区域去添加你的元素",{"1":{"220":1}}],["你只要",{"1":{"841":1}}],["你只要显示玩家t=900到t=1000的位置",{"1":{"76":1,"1015":1}}],["你只需要检测其中几个关键的角度",{"1":{"783":1}}],["你只需要提及那些根程序集",{"1":{"592":1}}],["你只需在基类中定义一次clone方法",{"1":{"111":1}}],["你很可能会忘记更新clone方法",{"1":{"111":1}}],["你马上会发现",{"1":{"107":1}}],["你必须再次打开它",{"1":{"86":1}}],["你",{"1":{"85":1}}],["你仍然暴露给了攻击者",{"1":{"85":1}}],["你瞄准的是敌人过去的位置",{"1":{"79":1}}],["你瞄准的是",{"1":{"79":1}}],["你看其他玩家的位置和服务器的位置不一致",{"1":{"77":1}}],["你现在已经实现混用两种模式了",{"1":{"968":1}}],["你现在拥有的是每100ms由服务器传送过来的权威数据",{"1":{"76":1}}],["你现在在",{"1":{"64":1}}],["你也会得到包含它自己的linkedentitygroup",{"1":{"965":1,"1002":1}}],["你也可以选中",{"1":{"971":1}}],["你也可以读读这篇更深入的文章",{"1":{"930":1}}],["你也可以通过其重载的方法获得所有值的索引",{"1":{"930":1}}],["你也可以通过下面的方法一次创建多个entity",{"1":{"907":1}}],["你也可以通过在运行时添加或者移除component来改变一个实体的原型",{"1":{"905":1}}],["你也可以在发现不同步后马上中断游戏",{"1":{"15":1}}],["你也许希望只有再收到服务器确认的时候才将一个玩家杀死",{"1":{"70":1}}],["你可在unity安装目录中的",{"1":{"585":1}}],["你可以将这个摄像机disable掉",{"1":{"1033":1}}],["你可以将前面说的这几种操作放进",{"1":{"908":1}}],["你可以选中它然后在",{"1":{"971":1}}],["你可以选择在接到服务器的请求的时候直接更新玩家的位置",{"1":{"76":1}}],["你可以点击",{"1":{"971":1}}],["你可以用还未销毁的",{"1":{"970":1}}],["你可以用net",{"1":{"83":1}}],["你可以正常混搭entity或float字段在一起",{"1":{"967":1}}],["你可以思考一下为什么这种方法无法正确工作然后再继续往下看几乎",{"1":{"966":1}}],["你可以按照",{"1":{"966":1}}],["你可以利用这里的机会来使用",{"1":{"957":1}}],["你可以利用精细阶段的算法",{"1":{"768":1}}],["你可以不断添加查询不同种类",{"1":{"955":1}}],["你可以在conversion",{"1":{"964":1}}],["你可以在inspector里通过序列化的",{"1":{"964":1}}],["你可以在",{"1":{"955":1}}],["你可以在网络中搜索关于微服务设计的数据共享",{"1":{"142":1}}],["你可以想象成如果没有parent组件",{"1":{"952":1}}],["你可以想像这是非常耗资源的",{"1":{"887":1}}],["你可以",{"1":{"950":1}}],["你可以把任何逻辑都放在这里",{"1":{"957":1}}],["你可以把",{"1":{"955":1}}],["你可以把某些特殊的需要共享的值放到",{"1":{"928":1}}],["你可以把它想像成一个线程",{"1":{"885":1}}],["你可以把它理解成与原凹凸表面平行的另一个不同的表面",{"1":{"845":1}}],["你可以调用joba的complete方法",{"1":{"924":1}}],["你可以调用",{"1":{"924":1}}],["你可以指定同一个group中system的update的执行顺序",{"1":{"917":1}}],["你可以添加或者移除component",{"1":{"908":1}}],["你可以迅速拿到你想要拿的衣服",{"1":{"879":1}}],["你可以参照下图理解il2cpp工具链的作用",{"1":{"590":1}}],["你可以使用这个",{"1":{"923":1}}],["你可以使用",{"1":{"911":1,"915":1,"951":1}}],["你可以使用已有的",{"1":{"906":1}}],["你可以使用player",{"1":{"586":1}}],["你可以使用本地或分布式",{"1":{"142":1}}],["你可以像访问",{"1":{"424":1}}],["你可以安装一个叫做",{"1":{"411":1}}],["你可以简单地理解为",{"1":{"273":1}}],["你可以继承",{"1":{"228":1}}],["你可以继续使用ioptions",{"1":{"174":1}}],["你可以看出",{"1":{"225":1}}],["你可以通过返回的句柄或者",{"1":{"696":1}}],["你可以通过",{"1":{"223":1}}],["你可以自己定义它们",{"1":{"220":1}}],["你可以创建",{"1":{"142":1,"946":1}}],["你可以轻松",{"1":{"83":1}}],["你可以播放飙血的特效和伤害值",{"1":{"70":1}}],["你可能注意到上图中橙色的轮廓线不见了",{"1":{"971":1}}],["你可能想要自己控制对象的绘制顺序",{"1":{"976":1}}],["你可能想要一边修改内容",{"1":{"971":1}}],["你可能想要在",{"1":{"971":1}}],["你可能意识的到使用",{"1":{"961":1}}],["你可能觉得每个",{"1":{"960":1}}],["你可能对这种每次都查询",{"1":{"944":1}}],["你可能还听过一种组件是不包含数据",{"1":{"927":1}}],["你可能会想要介于二者之间部分地",{"1":{"968":1}}],["你可能会猜测所有",{"1":{"952":1}}],["你可能会说",{"1":{"848":1}}],["你可能会这样做",{"1":{"63":1}}],["你可能需要考虑用组合模式来替代了",{"1":{"955":1}}],["你可能需要自定义一些东西",{"1":{"737":1}}],["你可能需要服务器发送更加详细的移动信息了",{"1":{"76":1}}],["你可能希望避免出现这样的情况",{"1":{"62":1}}],["你可能发现玩家设计方向不对",{"1":{"48":1}}],["你可能这么问",{"1":{"34":1}}],["你按下了向右的按键",{"1":{"64":1}}],["你在获取时会得到一个",{"1":{"946":1}}],["你在硬盘上新建了一个叫",{"1":{"502":1}}],["你在普通难度下也无法获得",{"1":{"275":1}}],["你在",{"1":{"63":1}}],["你游戏的客户端把输入",{"1":{"63":1}}],["你将游戏中所有的逻辑都放在你控制的服务器来做",{"1":{"63":1}}],["你自己的位置也是最新的",{"1":{"45":1}}],["你注意",{"1":{"39":1}}],["你的",{"1":{"949":1}}],["你的相机如果直接放到世界中那么必然会需要调整它的旋转角度才能达到满意的视口位置",{"1":{"841":1}}],["你的相机要把两个移动的玩家随时放置在屏幕显示中",{"1":{"841":1}}],["你的玩家在契而不舍的努力之后",{"1":{"218":1}}],["你的瞄准其实是有100ms的延迟的",{"1":{"76":1}}],["你的位置是11",{"1":{"69":1}}],["你的客户端将输入",{"1":{"64":1}}],["你的服务器还是可能被发现漏洞",{"1":{"63":1}}],["你的程序传递给别人的一个数据",{"1":{"34":1}}],["你的等级",{"1":{"12":1}}],["你的初始状态和大家不一致",{"1":{"12":1}}],["你先要栅格化之后",{"1":{"1":1}}],["势必会影响其他玩家的体验",{"1":{"12":1}}],["囚徒模式的帧同步",{"1":{"12":1}}],["乐观锁",{"0":{"12":1}}],["从转换系统中根据component获取实体",{"1":{"1054":1}}],["从后往前渲染",{"1":{"1036":1}}],["从显存中取出实例的部分共享信息与从gpu常量缓冲器中取出对应对象的相关信息一并传递到下一渲染阶段",{"1":{"981":1}}],["从单一源得到",{"0":{"962":1}}],["从父",{"1":{"960":1}}],["从非",{"0":{"959":1,"1002":1}}],["从现在开始",{"1":{"955":1}}],["从前文截图你可以看到它运行在",{"1":{"949":1}}],["从前面所列出的12个梯度向量中挑选",{"1":{"199":1}}],["从纯数据的角度来审视游戏非常重要",{"1":{"940":1}}],["从一个实体中增加或者移除一个组件",{"1":{"929":1}}],["从图中可以知道",{"1":{"966":1}}],["从图中你可以看到",{"1":{"904":1}}],["从图中也可以得出以下结论",{"1":{"756":1}}],["从下面的预览窗口",{"1":{"847":1}}],["从下往上进行遍历",{"1":{"680":1}}],["从名字也能看出",{"1":{"847":1}}],["从堆中分配的所有内存仍然在使用中是非常不可能的",{"1":{"827":1}}],["从中分配该块",{"1":{"827":1}}],["从那时起",{"1":{"826":1}}],["从这个意义上说",{"1":{"810":1}}],["从这些节点开始向下搜索",{"1":{"116":1}}],["从需要检测的多边形中取出一条边",{"1":{"784":1}}],["从每个可能的角度上去检测会使处理变得十分密集",{"1":{"783":1}}],["从编程的角度来讲",{"1":{"783":1}}],["从根本上来讲",{"1":{"783":1}}],["从mono中加载模块",{"1":{"711":1}}],["从小到大排过序的",{"1":{"695":1}}],["从小到大排序",{"1":{"692":1}}],["从整个",{"1":{"691":1}}],["从当前",{"1":{"691":1}}],["从技术层面上来说",{"1":{"588":1}}],["从land中读取",{"1":{"257":1}}],["从上次该系统更新后到这次更新后的一帧",{"1":{"991":1}}],["从上面所讲的屏幕坐标系转换成世界坐标系也是非常简单的",{"1":{"841":1}}],["从上面可以看出",{"1":{"535":1}}],["从上面的代码我们可以得知",{"1":{"173":1}}],["从上到下",{"1":{"224":1}}],["从1到5",{"1":{"224":1}}],["从选中的墙处增加新的元素",{"1":{"220":1}}],["从头开始反射然后调用得到的方法",{"1":{"175":1}}],["从数据上看",{"1":{"175":1}}],["从历史上看",{"1":{"126":1}}],["从",{"1":{"124":1,"155":1,"176":1,"947":1,"959":1,"969":1,"971":1,"1002":1,"1023":1}}],["从效率上来说",{"1":{"119":1}}],["从时间复杂度等等所有方便都是这个最佳",{"1":{"107":1}}],["从性能上考虑",{"1":{"97":1}}],["从此位置沿顺时针滚动",{"1":{"92":1}}],["从此正式用版本2",{"1":{"88":1}}],["从过程不难发现",{"1":{"88":1}}],["从客户端发送命令到服务器响应",{"1":{"82":1}}],["从客户端来看",{"1":{"74":1}}],["从某种程度上来说这是不公平的",{"1":{"79":1}}],["从缓存buffer里删除",{"1":{"69":1}}],["从玩家的角度来看",{"1":{"68":1}}],["从你的视角来看",{"1":{"64":1}}],["从游戏设计的角度来讲",{"1":{"48":1}}],["从服务器历史信息中找到发送给玩家信息和收到玩家响应的信息",{"1":{"47":1}}],["从窗口中查找服务器处理的是哪条命令并将相应的数据传到下一个帧的",{"1":{"43":1}}],["从而附加了多个pass导致无法合批",{"1":{"980":1}}],["从而更方便地与这些实体交互",{"1":{"937":1}}],["从而知道要删除",{"1":{"930":1}}],["从而在实体中与其他组件划分开",{"1":{"928":1}}],["从而做到让ui只依赖于",{"1":{"861":1}}],["从而导致不会渲染结果",{"1":{"969":1}}],["从而导致垃圾收集频繁",{"1":{"828":1}}],["从而导致效率的降低",{"1":{"801":1}}],["从而导致所有玩家都在等待",{"1":{"11":1}}],["从而将和技能强相关的ai逻辑放在技能模块使技能模块和ai模块降低耦合",{"1":{"795":1}}],["从而得出旋转后的圆心坐标",{"1":{"756":1}}],["从而判断是否碰撞",{"1":{"753":1,"759":1}}],["从而尽可能的消除反射调用开销以及额外的",{"1":{"718":1}}],["从而控制了input的处理顺序",{"1":{"653":1}}],["从而根据终端用户设备的cpu架构提供apk文件",{"1":{"586":1}}],["从而保证服务器性能",{"1":{"581":1}}],["从而构建起",{"1":{"576":1}}],["从而可以让这个程序跑在",{"1":{"572":1}}],["从而解决上述的问题呢",{"1":{"536":1}}],["从而提升我们的下载速度",{"1":{"478":1}}],["从而实现了数据库状态的记录",{"1":{"453":1}}],["从而让玩家在其中流连忘返",{"1":{"217":1}}],["从而创建一",{"1":{"111":1}}],["从而较好的保持了游戏的公平性",{"1":{"55":1}}],["从而简化了mmo游戏的开发难度",{"1":{"20":1}}],["从而网络不再受最差的",{"1":{"12":1}}],["从windows迁移到linux时",{"1":{"8":1}}],["而实际上",{"1":{"1025":1}}],["而实际a的操作是移动",{"1":{"15":1}}],["而无法合并",{"1":{"982":1}}],["而碍于缓存区的大小限制",{"1":{"981":1}}],["而新一代图形api",{"1":{"980":1}}],["而新的命令可能对现有的数据进行修改",{"1":{"455":1}}],["而使用tags",{"1":{"976":1}}],["而使用滚动发布",{"1":{"89":1}}],["而同时你又禁止它这样做",{"1":{"971":1}}],["而同一类组件的情况下排序规则未知",{"1":{"862":1}}],["而现在你只能传入",{"1":{"970":1}}],["而遇到",{"1":{"969":1}}],["而获取该",{"1":{"966":1}}],["而只是单纯地通过dstmanager",{"1":{"963":1}}],["而只得到了",{"1":{"956":1}}],["而只会更新自上次确认更新",{"1":{"82":1}}],["而用于操作",{"1":{"955":1}}],["而用户命令被行进到服务器",{"1":{"85":1}}],["而负责计算",{"1":{"952":1}}],["而添加",{"1":{"952":1}}],["而中间三个",{"1":{"949":1}}],["而复制一个方块也不再是复制",{"1":{"945":1}}],["而所有这些绘制都来自于对于数据某些形式的迭代",{"1":{"940":1}}],["而所有的伤害都是通过buff来结算",{"1":{"799":1}}],["而有",{"1":{"935":1}}],["而有了快照",{"1":{"15":1}}],["而没有",{"1":{"934":1}}],["而每一个线程都有它自己的栈",{"1":{"885":1}}],["而浮点数学比矢量",{"1":{"858":1}}],["而保存其位置",{"1":{"849":1}}],["而绘制依赖于着色器",{"1":{"847":1}}],["而如果我们选择不等待垂直同步信号",{"1":{"854":1}}],["而如果要绘制四边形",{"1":{"846":1}}],["而如何做到这点又取决于加载的资源的类型与使用加载的方法",{"1":{"696":1}}],["而右图则通过两个三角形得到了一个四边形",{"1":{"846":1}}],["而右图中的黄色玩家在游戏前期缺少竞争",{"1":{"213":1}}],["而三角形的三个点就是顶点坐标里的点",{"1":{"846":1}}],["而服务端每隔一段时间根据飞行速度等使用胶囊攻击盒去检测目标碰撞",{"1":{"807":1}}],["而服务器仍然可以看到他在老地方",{"1":{"84":1}}],["而服务器帧率又足够高",{"1":{"50":1}}],["而弹道是一个移动的子弹",{"1":{"807":1}}],["而技能真正的结算主要是由其创生体结算的",{"1":{"799":1}}],["而对于根部的",{"1":{"952":1}}],["而对于其他节点",{"1":{"805":1}}],["而对于怪物",{"1":{"801":1}}],["而对于子技能1",{"1":{"795":1}}],["而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和",{"1":{"764":1}}],["而对于前一种简单类型",{"1":{"657":1}}],["而我们不可能按照这些边一一进行投影与测试",{"1":{"764":1}}],["而第二种只需一个",{"1":{"759":1}}],["而再近一点细节较多的背景层可以考虑后几种滚动方式构建背景",{"1":{"734":1}}],["而另外三种方式都是循环利用同一个背景",{"1":{"733":1}}],["而照相机移动方式对背景的构建没有要求",{"1":{"732":1}}],["而纵向滚动则未必都会有",{"1":{"725":1}}],["而近处的稻田却在飞速掠过",{"1":{"724":1}}],["而并非那些最初作为这个程序的一部分保存在硬盘上的固有的代码",{"1":{"709":1}}],["而pointclick则是使用的向上查找",{"1":{"681":1}}],["而具体处理则是放在了",{"1":{"668":1}}],["而eventsystem的脚本则不依赖于rigidbody",{"1":{"655":1}}],["而onmouse事件先于update调用",{"1":{"655":1}}],["而此物件的實際顯示區域則會受到",{"1":{"634":1}}],["而依照上述邏輯",{"1":{"633":1}}],["而快速設定器其實也只是在幫你快速的調整這兩個錨點的值",{"1":{"633":1}}],["而asgi的诞生则是为了解决python常用的wsgi不支持当前web开发中的一些新的协议标准",{"1":{"584":1}}],["而abp的简体中文的值为首先修改配置文件appsettings",{"1":{"157":1}}],["而通过反向代理",{"1":{"581":1}}],["而unity3d是左手坐标系在渲染时默认只渲染正面",{"1":{"846":1}}],["而uwsgi是实现了uwsgi和wsgi两种协议的web服务器百度百科上说uwsgi是一种线路协议而不是通信协议",{"1":{"582":1}}],["而uwsgi",{"1":{"577":1}}],["而utf",{"1":{"39":1}}],["而fastcgi",{"1":{"575":1}}],["而文件里面包含的都是符合",{"1":{"452":1}}],["而浏览器报错not",{"1":{"399":1}}],["而闪避攻击的几率是根据防御者的闪避与攻击者的命中相比得出的",{"1":{"385":1}}],["而法术则会自动命中",{"1":{"385":1}}],["而分舵的就需要自己来指定了",{"1":{"381":1}}],["而铸造房正是为此而设",{"1":{"380":1}}],["而门主恰恰在总舵中",{"1":{"380":1}}],["而你绝对有时间帮他换秘笈",{"1":{"372":1}}],["而你的对手又在不断躲避",{"1":{"45":1}}],["而噩梦",{"1":{"293":1}}],["而怪物等级mlvl不足以掉落该物品的绿色形态或者该物品绿色形态不存在",{"1":{"275":1}}],["而怪物等级mlvl不足以掉落该物品的暗金形态或者该物品暗金形态不存在",{"1":{"275":1}}],["而暗金军帽",{"1":{"273":1}}],["而底材也分为了普通级",{"1":{"273":1}}],["而洞穴则可能有一堆打洞以及曲折的小道等等",{"1":{"220":1}}],["而黄色玩家的出生点附近几乎没有矿产资源",{"1":{"213":1}}],["而在运行时",{"1":{"946":1}}],["而在unity中通常意味着帧更新",{"1":{"828":1}}],["而在",{"1":{"685":1,"975":1}}],["而在做贴图或者模型合成时",{"1":{"206":1}}],["而在发送端发送数据时",{"1":{"37":1}}],["而伪随机是指",{"1":{"197":1}}],["而前者更像",{"1":{"176":1}}],["而这种模式也能配合",{"1":{"963":1}}],["而这种情况在分布式系统中是十分糟糕的",{"1":{"91":1}}],["而这些条件由",{"1":{"446":1}}],["而这个一整个流程",{"1":{"811":1}}],["而这个弹道上附着一个buff",{"1":{"811":1}}],["而这个规则之一就是座次的排定",{"1":{"381":1}}],["而这个类型就是应该转成的委托的类型",{"1":{"176":1}}],["而ioptions<>的值没有更新",{"1":{"173":1}}],["而ioptionssnapshot<>被注册为范围服务",{"1":{"173":2}}],["而",{"1":{"164":1,"207":1,"452":1,"841":1,"940":1,"944":1,"954":1,"958":1,"960":1,"965":1,"1001":1}}],["而之后也立即同时调用了state这个时候就会报错",{"1":{"161":1}}],["而运行的dbcontext使用了appuser进行了对其的映射",{"1":{"137":1}}],["而new出来的对象的对象类型指针就指向它的类型",{"1":{"131":1}}],["而jit知道cpu的具体类型",{"1":{"130":1}}],["而java编写的程序则唯一采用big",{"1":{"34":1}}],["而支撑根搜索算法可以正常工作的理论依据",{"1":{"121":1}}],["而未被标记的内存会被清理掉",{"1":{"119":1}}],["而地图上的每个对象",{"1":{"104":1}}],["而companionlink组件则指向了这个隐藏对象",{"1":{"969":1}}],["而canvas",{"1":{"624":1}}],["而c",{"1":{"92":1}}],["而发布的最小维度是应用",{"1":{"88":1}}],["而其他看到的entity都是过去的某个时刻",{"1":{"77":1}}],["而客户端看到的就是网上其他的玩家每100ms跳一下",{"1":{"76":1}}],["而客户端只是游戏的旁观者",{"1":{"63":1}}],["而高延时玩家看到的是过去的信息",{"1":{"48":1}}],["而世界本身是连续的",{"1":{"46":1}}],["而剩下的",{"1":{"39":1}}],["而相同平台进行通信时",{"1":{"36":1}}],["而被发送方网络协议函数发送时会首先去低地址取数据",{"1":{"36":1}}],["而keil",{"1":{"33":1}}],["而数据从高位往低位放",{"1":{"32":1}}],["而数据的低字节保存在内存的低地址中",{"1":{"32":1}}],["而数据的低字节",{"1":{"32":1}}],["而little",{"1":{"32":1}}],["而且有",{"1":{"1038":1}}],["而且有的一些简单的事情",{"1":{"581":1}}],["而且需要保存进",{"1":{"982":1}}],["而且也不能访问整个层级树",{"1":{"968":1}}],["而且也是整个算法的核心",{"1":{"220":1}}],["而且猜想它一定和",{"1":{"965":1}}],["而且物体是可以移动的",{"1":{"876":1}}],["而且通过枚举器遍历集合的方法调用成本更高",{"1":{"864":1}}],["而且文件末被使用除非你关掉作业管理服务器",{"1":{"707":1}}],["而且实现方式与touch也太像了",{"1":{"674":1}}],["而且我们也高兴我们忽略了它",{"1":{"593":1}}],["而且当",{"1":{"575":1}}],["而且插件在",{"1":{"534":1}}],["而且最蛋疼的是对于国内的网络环境来说",{"1":{"510":1}}],["而且",{"1":{"217":1,"955":1,"971":1}}],["而且使用者并没有调教的可能性",{"1":{"206":1}}],["而且还可以构建",{"1":{"125":1}}],["而且在早期就可迅速完成门派核心设施的建设",{"1":{"380":1}}],["而且在很多语言版本的运行效率都优于前面一种",{"1":{"202":1}}],["而且在部",{"1":{"111":1}}],["而且在internet环境中",{"1":{"64":1}}],["而且同时在线的只有一个版本",{"1":{"88":1}}],["而且游戏状态的更新也是按照预期的",{"1":{"67":1}}],["而且大部分的传播速度都达不到光速",{"1":{"64":1}}],["而且宽带网络在美国被广泛采用还需要一段时间",{"1":{"40":1}}],["而且比较重要",{"1":{"20":1}}],["而且你的状态信息都是丢失状态的",{"1":{"12":1}}],["而不仅仅是",{"1":{"964":1}}],["而不带任何",{"1":{"956":1}}],["而不像栈只能访问最上面的盒子",{"1":{"879":1}}],["而不该是一个实体",{"0":{"810":1},"2":{"811":1}}],["而不能再使用真实的gameobject做为参数进行释放了",{"1":{"699":1}}],["而不再需要同级的collider",{"1":{"655":1}}],["而不需要把整个地图文件保存到本地再分享",{"1":{"214":1}}],["而不需要计算一个提前量",{"1":{"47":1}}],["而不会干扰到其他的数据",{"1":{"94":1}}],["而不是单个entity层级的",{"1":{"994":1}}],["而不是在运行时分开来完成这一切",{"1":{"966":1}}],["而不是前面说到的空结果",{"1":{"964":1}}],["而不是它变成了多个",{"1":{"963":1}}],["而不是过去地狱般的",{"1":{"955":1}}],["而不是桥接回",{"1":{"945":1}}],["而不是",{"1":{"942":1,"944":1,"946":1,"952":1,"965":1}}],["而不是一个接一个的调用",{"1":{"965":1}}],["而不是一个类",{"1":{"927":1}}],["而不是一次编译一种方法",{"1":{"130":1}}],["而不是引用类型本身",{"1":{"888":1}}],["而不是游戏对象本身",{"1":{"860":1}}],["而不是移动到屏幕外边",{"1":{"860":1}}],["而不是破坏旧对象",{"1":{"832":1}}],["而不是仅仅假定它具有所期望的效果",{"1":{"831":1}}],["而不是因为系统内存太少而导致操作系统杀死你的应用程序",{"1":{"831":1}}],["而不是只发送了update事件",{"1":{"739":1}}],["而不是真正内存中内容的变化",{"1":{"701":1}}],["而不是轮询了",{"1":{"653":1}}],["而不是使用属性",{"1":{"598":1}}],["而不是使用时间和内存来将",{"1":{"129":1}}],["而不是python的模块",{"1":{"577":1}}],["而不是网络",{"1":{"452":1}}],["而不是创建新实体并映射到同一表",{"1":{"142":1}}],["而不是开枪的时候的玩家的头",{"1":{"79":1}}],["而不是快速移动",{"1":{"46":1}}],["而不同词缀又是有不同等级的",{"1":{"270":1}}],["而不同平台进行通信时必须进行转换",{"1":{"36":1}}],["而不同步每一次的攻击",{"1":{"19":1}}],["而不必等到收到所有的",{"1":{"12":1}}],["而网络不好的b",{"1":{"15":1}}],["而buff并不需要通知逻辑服务器",{"1":{"809":1}}],["而buff属性只在战斗中有效",{"1":{"809":1}}],["而b又引用了a",{"1":{"124":1}}],["而b核对后",{"1":{"15":1}}],["而b执行攻击",{"1":{"15":1}}],["而是使用rendertexture提供的gettemporary和releasetemporary",{"1":{"1033":1}}],["而是使用getcomponentsinchildren",{"1":{"864":1}}],["而是动态更新",{"1":{"982":1}}],["而是一个近似的排序",{"1":{"1037":1}}],["而是一个",{"1":{"971":1}}],["而是一个内在的等级数据",{"1":{"269":1}}],["而是被设计为可以嵌套进普通",{"1":{"971":1}}],["而是加载",{"1":{"971":1}}],["而是加多他的领悟时间",{"1":{"373":1}}],["而是它们本就该是",{"1":{"964":1}}],["而是直接复制",{"1":{"952":1}}],["而是直接读取",{"1":{"454":1}}],["而是为了尽可能的简单",{"1":{"898":1}}],["而是在一个引用类型里",{"1":{"886":1}}],["而是提供流程中需要的数据",{"1":{"810":1}}],["而是技能生成了法术场",{"1":{"803":1}}],["而是基于回调的",{"1":{"795":1}}],["而是以一定的策略将技能树从头到尾遍历执行一遍",{"1":{"795":1}}],["而是利用",{"1":{"759":1}}],["而是通过滚动移动所有的背景精灵来实现背景移动的效果",{"1":{"727":1}}],["而是会向上查找handler",{"1":{"679":1}}],["而是由意想不到的特殊情况产生的",{"1":{"594":1}}],["而是由12条单位正方体",{"1":{"197":1}}],["而是作为一个外部扩展",{"1":{"537":1}}],["而是这样一个过程",{"1":{"197":1}}],["而是说不需要在进行即时编译这个过程了",{"1":{"130":1}}],["而是分派给其他模块来做",{"1":{"580":1}}],["而是分代收集的算法",{"1":{"122":1}}],["而是分为三个部分",{"1":{"120":1}}],["而是不确定的并且高",{"1":{"46":1}}],["而是指一个多字节编码在机器中的表示方式问题",{"1":{"39":1}}],["而是服务器根据某种策略来控制",{"1":{"20":1}}],["而是玩家输入",{"1":{"15":1}}],["而是按照固定频率来同步玩家的输入信息到每一个c端",{"1":{"12":1}}],["而tss方案则以某种延迟值",{"1":{"14":1}}],["而导致第二帧的同步时间发生延迟",{"1":{"11":1}}],["而半透明玻璃你能看到后面",{"1":{"0":1}}],["这大约需要",{"1":{"1051":1}}],["这大大减少了程序占用的内存",{"1":{"707":1}}],["这与不透明物体是相反的",{"1":{"976":1}}],["这与给定帧期间临时分配的字节数不同",{"1":{"878":1}}],["这套机制就是",{"1":{"971":1}}],["这和常规的",{"1":{"971":1}}],["这和上面说的",{"1":{"411":1}}],["这感觉就和",{"1":{"969":1}}],["这让它",{"1":{"969":1}}],["这基本相当于魔法",{"1":{"967":1}}],["这被称之为",{"1":{"964":1}}],["这被称为",{"1":{"947":1}}],["这下我的",{"1":{"956":1}}],["这不像那些被默认转换的component",{"1":{"961":1}}],["这不仅是可以添加到",{"1":{"946":1}}],["这不是一个高消耗操作",{"1":{"738":1}}],["这已经类似于cpu版本的",{"1":{"942":1}}],["这句话包含了几个要点",{"1":{"929":1}}],["这利用了cpu的多核性能",{"1":{"909":1}}],["这项设置可以减少加载",{"1":{"868":1}}],["这导致了内存碎片化这个核心问题",{"1":{"857":1}}],["这导致了内存碎片的核心问题",{"1":{"813":1}}],["这能够减少那些因为内存原因而不能合批的大批量相同物件的渲染时间",{"1":{"849":1}}],["这无疑也增大了内存的占用",{"1":{"849":1}}],["这次就总结介绍了这几个坐标系",{"1":{"842":1}}],["这四种坐标系可以说没有一个是完全相同的",{"1":{"841":1}}],["这四个操作",{"1":{"711":1}}],["这确实是大家经常遇到的情况",{"1":{"839":1}}],["这似乎有些不雅",{"1":{"828":1}}],["这只是用新值替换数组的现有内容",{"1":{"828":1}}],["这通常会使垃圾收集发生的次数比严格的需要的更多",{"1":{"830":1}}],["这通常发生在传递原始的值类型变量",{"1":{"820":1}}],["这通常对项目性能是非常有害的",{"1":{"815":1}}],["这段代码使用了一个简单的匿名函数来控制第一行创建的列表成员的排序方式",{"1":{"818":1}}],["这段代码的输入是玩家操作和客户端的初始状态",{"1":{"43":1}}],["这避免了每帧分配一个新的列表",{"1":{"817":1}}],["这在更复杂的转换过程中可能有用",{"1":{"947":1}}],["这在有些场景中使用起来很方便",{"1":{"841":1}}],["这在包含下面的类似代码的项目中也非常普遍",{"1":{"824":1}}],["这在内存中增加了3",{"1":{"815":1}}],["这在减小网络延迟给玩家带来的不爽上面迈出了一大步",{"1":{"44":1}}],["这用来避免当有更大的内存分配发生时需要重新扩大托管堆",{"1":{"814":1}}],["这类的思想也出现在dynamic",{"1":{"952":1}}],["这类同步消息往往并不是由技能本身去同步",{"1":{"803":1}}],["这类法术场策划可以配置法术场每次结算之间的时间间隔以及每次结算所使用的法术场参数",{"1":{"801":1}}],["这类游戏都有一个用来执行游戏逻辑的服务器以及连接到这个服务器的多个客户端",{"1":{"41":1}}],["这条轴就是途经圆心和多边形上离圆心最近的顶点的直线",{"1":{"785":1}}],["这条轴就是圆心与多边形顶点中最近的一点的连线",{"1":{"764":1}}],["这点很重要",{"1":{"737":1}}],["这需要熟练使用",{"1":{"737":1}}],["这儿附上开源的相关文档",{"1":{"715":1}}],["这儿重点说说方法是如何获取的",{"1":{"715":1}}],["这儿不是程序域的意思",{"1":{"711":1}}],["这步比较简单readmetadata核心是两个操作",{"1":{"713":1}}],["这一问题同样影响实例化过程",{"1":{"965":1}}],["这一点同样适用于getprimaryentity",{"1":{"962":1}}],["这一点就能看出其在",{"1":{"930":1}}],["这一点和其他组件是一样的",{"1":{"928":1}}],["这一点听听美术们的意见是比较合适的",{"1":{"734":1}}],["这一行显示着在某一帧分配到托管堆的比特数",{"1":{"815":1}}],["这一步也是顺其自然就可以完成",{"1":{"734":1}}],["这一步是如何实现的",{"1":{"711":1}}],["这一步的代码为",{"1":{"708":1}}],["这一次",{"1":{"221":1}}],["这上面的代码中",{"1":{"689":1}}],["这么做会移除",{"1":{"592":1}}],["这么做的一个主要的好处是可以使得整个il2cpp技术是简单并且是可移植的",{"1":{"591":1}}],["这么个小障碍块",{"1":{"225":1}}],["这将节省你和你的团队多少时间",{"1":{"839":1}}],["这将",{"1":{"455":1}}],["这将带来巨大的帮助",{"1":{"15":1}}],["这比之前的四条命令调用要大大减少",{"1":{"454":1}}],["这比维护一个空闲列表显然少了许多开销",{"1":{"119":1}}],["这三种情况下的",{"1":{"448":1}}],["这三个",{"1":{"283":1}}],["这三个接口初看起来很类似",{"1":{"171":1}}],["这边的重点",{"1":{"376":1}}],["这之前他就会开始提示了",{"1":{"373":1}}],["这适用在快攻",{"1":{"372":1}}],["这关系到什麼呢",{"1":{"372":1}}],["这件衣服最大孔数就是4孔",{"1":{"269":1}}],["这有一半的几率是空的",{"1":{"225":1}}],["这有33",{"1":{"225":1}}],["这有个问题",{"1":{"224":1}}],["这每个房间类型有8",{"1":{"225":1}}],["这对于",{"1":{"971":1}}],["这对于运行时间不超过人类平均寿命的程序来说基本不会发生",{"1":{"814":1}}],["这对于b来说",{"1":{"15":1}}],["这对编程很有帮助",{"1":{"218":1}}],["这款算法的目标",{"0":{"218":1}}],["这说明每位玩家的出生点占位符设置更加平衡",{"1":{"215":1}}],["这会打破其跟其他物体进行dynamic",{"1":{"980":1}}],["这会为每一个conversion",{"1":{"947":1}}],["这会导入",{"1":{"947":1}}],["这会导致重复绘制对象的问题",{"1":{"971":1}}],["这会导致地址空间",{"1":{"814":1}}],["这会导致这个地区的玩家在游戏前期相互碾压",{"1":{"213":1}}],["这会导致游戏初期黄色玩家的发展受限",{"1":{"213":1}}],["这会返回以托管数组方式存储托管组件的结果",{"1":{"946":1}}],["这会影响到程序的性能",{"1":{"887":1}}],["这会增加编译时间和包体积",{"1":{"868":1}}],["这会增加cpu的负担",{"1":{"868":1}}],["这会造成多次",{"1":{"860":1}}],["这会使得c++代码难以阅读",{"1":{"592":1}}],["这会让你回避很多不易察觉的错误",{"1":{"897":1}}],["这会让你的地牢有自己的特点和侧重点",{"1":{"220":1}}],["这会让当前数据库的数据和重写后的",{"1":{"455":1}}],["这会产生一种情况",{"1":{"96":1}}],["这都属于地形的一部分",{"1":{"204":1}}],["这正是算法所需要的值",{"1":{"197":1}}],["这可能对于小孩子来讲非常有趣",{"1":{"943":1}}],["这可能会非常低效",{"1":{"891":1}}],["这可能会成为一个高消耗操作",{"1":{"738":1}}],["这可能会引发一些奇怪的bug",{"1":{"174":1}}],["这可通过一些特殊的数据结构实现",{"1":{"767":1}}],["这可不是随随便便找几个人胡乱演练一下就能成功",{"1":{"380":1}}],["这可以通过copy",{"1":{"968":1}}],["这可以通过普通的重构来使其只有一次数组内存分配",{"1":{"824":1}}],["这可以通过看调用栈很方便来定位出问题的具体原因",{"1":{"131":1}}],["这可以提高响应速度",{"1":{"82":1}}],["这带来了很多好处",{"1":{"171":1}}],["这本书https",{"1":{"131":1}}],["这部分生成代码会和我们手写有类似",{"1":{"967":1}}],["这部分垃圾都会被回收",{"1":{"115":1}}],["这部分内存的分配和回收都是动态的",{"1":{"113":1}}],["这",{"1":{"111":1}}],["这便是玩家视野范围内的对象",{"1":{"105":1}}],["这九个格子内的玩家就要被通知有新玩家初始化",{"1":{"103":1}}],["这表明",{"1":{"84":1}}],["这同时也会受限于服务器tickrate",{"1":{"83":1}}],["这意味着尽管已经被convert",{"1":{"971":1}}],["这意味着每次实例化时",{"1":{"969":1}}],["这意味着关联该",{"1":{"958":1,"1001":1}}],["这意味着如果我有一个关联",{"1":{"954":1}}],["这意味着你得到了一个可以追溯回原始",{"1":{"954":1}}],["这意味着被复制时默认是通过值而不是通过引用",{"1":{"927":1}}],["这意味着您可以在第一次执行lambda函数之前使用查询",{"1":{"910":1}}],["这意味着这些模型数据不可以在运行时刻被移动",{"1":{"876":1}}],["这意味着除非你修改了你在",{"1":{"411":1}}],["这意味着",{"1":{"176":1,"599":1,"960":1}}],["这意味着将不需要类型库或接口定义语言",{"1":{"127":1}}],["这意味着他们在前进的线性插值时期所呈现的播放器模式",{"1":{"83":1}}],["这意味着两个或更多个用户的命令在同一包内传输",{"1":{"82":1}}],["这意味着服务器可以准确地知道你开枪的那一刻你的武器瞄准了什么",{"1":{"79":1}}],["这篇文章中",{"1":{"937":1}}],["这篇文章里有具体讲解",{"1":{"197":1}}],["这篇文章是快节奏多人游戏同步这个系列的最后一篇了",{"1":{"80":1}}],["这篇文章的思路是很清晰的",{"1":{"15":1}}],["这100ms的延迟都不是那么明显",{"1":{"76":1}}],["这又带来了一个有趣的问题",{"1":{"70":1}}],["这并不是我们期望的结果",{"1":{"896":1}}],["这并不是说你必须提前预判动画去瞄准射击",{"1":{"83":1}}],["这并不是一个非常严重的问题",{"1":{"69":1}}],["这并不意味着客户端不进行声音预测",{"1":{"50":1}}],["这接近最好的场景了",{"1":{"64":1}}],["这听起来可能很快",{"1":{"64":1}}],["这时是等价的",{"1":{"971":1}}],["这时因为我开启了下面的选项",{"1":{"971":1}}],["这时我们检查一下conversion",{"1":{"965":1,"1003":1}}],["这时所有的子层级将被忽略",{"1":{"956":1}}],["这时你已经可以直接从数据来绘制了",{"1":{"941":1}}],["这时对象4可以被清理了",{"1":{"898":1}}],["这时就需要3个drawcall了",{"1":{"862":1}}],["这时",{"1":{"796":1,"862":1}}],["这时输入域名",{"1":{"531":1}}],["这时游戏就有点感觉延迟了",{"1":{"66":1}}],["这时可以优化到",{"1":{"51":1}}],["这时预测就是完全的预测",{"1":{"50":1}}],["这时候橙色轮廓线就能够显示了",{"1":{"971":1}}],["这时候你会被告知需要添加一个新的",{"1":{"971":1}}],["这时候你无法通过cube",{"1":{"965":1}}],["这时候你可以结合",{"1":{"964":1}}],["这时候可以用",{"1":{"923":1}}],["这时候如何调度呢",{"1":{"922":1}}],["这时候需要调度job",{"1":{"921":1}}],["这时候会用到一个叫实体查询",{"1":{"915":1}}],["这时候会有个空位",{"1":{"905":1}}],["这时候entitymanager需要将entity移到其他内存块",{"1":{"908":1}}],["这时候ecs会将实体的组件数据移到另外一个块中",{"1":{"905":1}}],["这时候相机的",{"1":{"841":1}}],["这时候选择always",{"1":{"703":1}}],["这时候它是这样的",{"1":{"505":1}}],["这时候慢指针开始向前移动一个一个的对比位置就可以了",{"1":{"108":1}}],["这时候",{"1":{"15":1,"504":1,"934":1,"935":1,"964":1}}],["这就导致了打包的体积及运行时内存的占用增大",{"1":{"979":1}}],["这就意味着",{"1":{"905":1}}],["这就需要我们做一些额外的工作使引用类型shoe像值类型一样工作",{"1":{"896":1}}],["这就需要用到最小平移向量",{"1":{"765":1}}],["这就可以追踪这些内存分配是在哪些函数中发生的",{"1":{"815":1}}],["这就好比qt的signal和slot连接",{"1":{"657":1}}],["这就造成了2d角色在相机移动后会发生偏移的问题",{"1":{"620":1}}],["这就造成了ssl证书不能验证通过",{"1":{"135":1}}],["这就产生了wsgi协议",{"1":{"577":1}}],["这就有意思了",{"1":{"225":1}}],["这就涉及到pe文件结构了c",{"1":{"131":1}}],["这就是gc怎么决定去保留对象的",{"1":{"898":1}}],["这就是为什么我们需要理解和注意堆栈的使用",{"1":{"887":1}}],["这就是为什么需要用同一个source",{"1":{"861":1}}],["这就是c",{"1":{"708":1}}],["这就是加载过慢的原因",{"1":{"535":1}}],["这就是",{"1":{"454":1,"576":1}}],["这就是我的算法",{"1":{"222":1}}],["这就是我们的计划",{"1":{"219":1}}],["这就是整个柏林噪声算法的原理了",{"1":{"197":1}}],["这就是常说的权威服务器",{"1":{"63":1}}],["这就是半条命中的滑动窗口",{"1":{"43":1}}],["这就要求发送端发送的第一个字节是高位字节",{"1":{"37":1}}],["这些entity拥有的组件仍然是我们熟知的传统unity组件",{"1":{"1054":1}}],["这些entity用同样的原型使用",{"1":{"907":1}}],["这些队列不是随便创建的",{"1":{"976":1}}],["这些内置的渲染队列被称为background",{"1":{"976":1}}],["这些烘焙好的值又会",{"1":{"965":1}}],["这些结果也会添加进",{"1":{"963":1}}],["这些过程在具体执行当中也有一些细微不同",{"1":{"958":1,"1001":1}}],["这些过程中不依赖独立的回调",{"1":{"931":1}}],["这些拥有component",{"1":{"947":1}}],["这些数据",{"1":{"971":1}}],["这些数据在内存中都是连续排列的",{"1":{"943":1}}],["这些数据结构可以是",{"1":{"767":1}}],["这些属性时都会发生分配",{"1":{"864":1}}],["这些作为共享资源",{"1":{"861":1}}],["这些所有步骤都发生在堆内存上",{"1":{"858":1}}],["这些整形不存储真正的数据",{"1":{"846":1}}],["这些点与3d模型是相互联系的",{"1":{"846":1}}],["这些点会给平滑掉",{"1":{"46":1}}],["这些我想我会在后面的文章总结中写道吧",{"1":{"842":1}}],["这些原始数据都是屏幕坐标系相关的",{"1":{"841":1}}],["这些包括整数",{"1":{"826":1}}],["这些规则可以让策划填一个名字叫",{"1":{"800":1}}],["这些文件是我们下一个讨论的主题",{"1":{"592":1}}],["这些转换出的c++代码最终由部署目标平台上的c++编译器进行编译",{"1":{"590":1}}],["这些模块构建工具的出发点之一是",{"1":{"536":1}}],["这些模板具备一个房间的基本布局",{"1":{"225":1}}],["这些异士虽身怀绝技",{"1":{"297":1}}],["这些怪物有且仅有6个",{"1":{"266":1}}],["这些房间在任何方向都不一定有出口",{"1":{"224":1}}],["这些房间并不在critical",{"1":{"224":1}}],["这些梯度向量并不是完全随机的",{"1":{"197":1}}],["这些是在mscorlib",{"1":{"131":1}}],["这些程序集可以进行",{"1":{"129":1}}],["这些代码只能运行在编译出它们的计算机上",{"1":{"127":1}}],["这些代码位于hlsdk中的pm",{"1":{"43":1}}],["这些子问题相互独立且与原问题性质相同",{"1":{"107":1}}],["这些节点",{"1":{"96":1}}],["这些",{"1":{"85":1,"604":1,"688":1,"695":1,"960":1,"961":1}}],["这些通常是不可能的",{"1":{"64":1}}],["这些问题是需要考虑的",{"1":{"50":1}}],["这些时间戳可以决定目标时间在过去的时间间隙中的情况",{"1":{"46":1}}],["这些状态会通知给客户端用来预测武器状态",{"1":{"44":1}}],["这些命令执行以后得到当前状态",{"1":{"43":1}}],["这5条信息被用来执行客户端预测",{"1":{"43":1}}],["这主要是由于客户端完全没有逻辑操作",{"1":{"42":1}}],["这是很简单",{"1":{"889":1}}],["这是不必要的",{"1":{"826":1}}],["这是为了节省cpu在执行属性get方法时的消耗",{"1":{"824":1}}],["这是通过在进入循环前存储vertices数组来实现的",{"1":{"824":1}}],["这是通过一个或多个量级的指令实现的",{"1":{"819":1}}],["这是我们为什么要用",{"1":{"940":1}}],["这是我们将要更加详细介绍的部分",{"1":{"890":1}}],["这是我们在编辑器下进行注入的函数",{"1":{"717":1}}],["这是我们常遇到的问题",{"1":{"598":1}}],["这是普通的assembly",{"1":{"707":1}}],["这是每个",{"1":{"707":1}}],["这是因为通过unity的c",{"1":{"823":1}}],["这是因为c",{"1":{"820":1}}],["这是因为我们只修改了dll而并非修改源代码",{"1":{"717":1}}],["这是因为每一个",{"1":{"699":1}}],["这是因为",{"1":{"695":1,"876":1}}],["这是因为在",{"1":{"695":1}}],["这是因为在计算机系统中",{"1":{"33":1}}],["这是官方的例子",{"1":{"653":1}}],["这是引擎本身回调的",{"1":{"652":1}}],["这是gui事件的一部分",{"1":{"652":1}}],["这是导致插件体积过大的问题",{"1":{"535":1}}],["这是由于vs的默认nuget包路径",{"1":{"523":1}}],["这是由于客户端使用了插值算法造成的比如fps游戏",{"1":{"59":1}}],["这是个小台阶",{"1":{"225":1}}],["这是",{"1":{"176":1,"510":1,"948":1,"960":1}}],["这是根据来自另一个微服务的数据推荐的方法",{"1":{"142":1}}],["这是程序执行的入口地址",{"1":{"131":1}}],["这是用于创建silverlight",{"1":{"126":1}}],["这是您的应用程序的唯一id",{"1":{"90":1}}],["这是orleans集群的唯一id",{"1":{"90":1}}],["这是客户最重要的网络参数",{"1":{"82":1}}],["这是你的敌人过去的头部位置",{"1":{"79":1}}],["这是关键的一步",{"1":{"79":1}}],["这是如何工作的",{"1":{"75":1}}],["这是正确的",{"1":{"69":1}}],["这是经常发生的",{"1":{"48":1}}],["这是一系列的onmouse开头的回调函数",{"1":{"652":1}}],["这是一种发射线",{"1":{"1024":1}}],["这是一种兼顾性能和安全性的保存方案",{"1":{"451":1}}],["这是一种很自然的方法",{"1":{"41":1}}],["这是一组独立于",{"1":{"127":1}}],["这是一个详细的解释",{"1":{"1022":1}}],["这是一个真正的",{"1":{"971":1}}],["这是一个二维的坐标体系",{"1":{"841":1}}],["这是一个简易但比较啰嗦的方法",{"1":{"784":1}}],["这是一个查询域名映射关系的工具",{"1":{"490":1}}],["这是一个搜索的过程",{"1":{"207":1}}],["这是一个定义在microsoft",{"1":{"173":1}}],["这是一个广泛的主题",{"1":{"142":1}}],["这是一个不提供源代码的自定义",{"1":{"111":1}}],["这是一个经典问题",{"1":{"46":1}}],["这两者就可以被保留",{"1":{"954":1}}],["这两个方法在",{"1":{"970":1}}],["这两个方法是什么",{"1":{"970":1}}],["这两个类型与",{"1":{"931":1}}],["这两个概念是基于单位unit的基础上进行的区分",{"1":{"801":1}}],["这两个函数是为了在打包时进行注入而存在的",{"1":{"717":1}}],["这两个unity主工程中的类以及其中的方法",{"1":{"716":1}}],["这两个字节的顺序是固定的",{"1":{"39":1}}],["这两种情况下",{"1":{"924":1}}],["这两种方式都可以告诉il2cpp保留这个类型的代码供运行中使用",{"1":{"599":1}}],["这两种预测执行",{"1":{"15":1}}],["这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因",{"1":{"854":1}}],["这也就增加了一些开销",{"1":{"846":1}}],["这也就是由",{"1":{"581":1}}],["这也就是为什么",{"1":{"130":1}}],["这也就是说",{"1":{"17":2,"452":1}}],["这也产生了一个副作用",{"1":{"199":1}}],["这也保证了在梯度向量在生成函数不变的情况下",{"1":{"197":1}}],["这也是physics的一个方法",{"1":{"751":1}}],["这也是为社区贡献的好机会",{"1":{"398":1}}],["这也是为什么第一次运行c",{"1":{"131":1}}],["这也是这个系统比较蛋疼的地方",{"1":{"235":1}}],["这也是很多随机地图生成器中会暴露",{"1":{"214":1}}],["这也是我",{"1":{"15":1}}],["这也会导致",{"1":{"118":1}}],["这也意味着服务器收到大部分的输入都是有效的",{"1":{"67":1}}],["这块内存指向另一块内存",{"1":{"883":1}}],["这块区域可以每隔一段时间进行一次检测",{"1":{"801":1}}],["这块优化",{"1":{"15":1}}],["这块",{"1":{"15":1}}],["这种检查是component层级",{"1":{"994":1}}],["这种特性就让我们可以通过不同的query去获得结构变化的消息",{"1":{"986":1}}],["这种查询能力也让其成为非常便捷的",{"1":{"955":1}}],["这种",{"1":{"955":1}}],["这种设计也适用于你自己的游戏",{"1":{"950":1}}],["这种粗暴的绘制方式甚至可能比花费",{"1":{"942":1}}],["这种操作开销十分低",{"1":{"930":1}}],["这种错误有时不易被调试出来",{"1":{"897":1}}],["这种现象表现在游戏里就是跳帧",{"1":{"854":1}}],["这种函数非常优雅和方便",{"1":{"828":1}}],["这种编码模式在许多托管语言中非常常见",{"1":{"825":1}}],["这种是比较基础的做法",{"1":{"748":1}}],["这种解决方案的优势",{"1":{"737":1}}],["这种解决方案就会出问题了",{"1":{"64":1}}],["这种做法显然是做不到的",{"1":{"724":1}}],["这种行为进而报告这个异常",{"1":{"709":1}}],["这种同步方式会造成一个问题",{"1":{"453":1}}],["这种性能的提高是以降低安全性为代价的",{"1":{"451":1}}],["这种性能降低的程度是可以接受的",{"1":{"130":1}}],["这种加密方式与存放",{"1":{"411":1}}],["这种注意创建的实体和parent没有关系",{"1":{"264":1}}],["这种预编译模式使用",{"1":{"130":1}}],["这种算法的基本思路是通过一系列名为",{"1":{"116":1}}],["这种算法中我们对每一个可能插值的物体记录了一个完整的",{"1":{"46":1}}],["这种部署方式相对于蓝绿部署",{"1":{"89":1}}],["这种部署方式具有安全",{"1":{"88":1}}],["这种效果是不可避免的",{"1":{"86":1}}],["这种不一致问题不能通过一般化的防范解决",{"1":{"85":1}}],["这种不一致导致射击很不真实",{"1":{"48":1}}],["这种延迟对于高频动作游戏",{"1":{"84":1}}],["这种延迟在局域网通常可以接受",{"1":{"42":1}}],["这种就会造成显示的entity总是过去的某个时刻",{"1":{"77":1}}],["这种模式要求你有一个",{"1":{"967":1}}],["这种模式下",{"1":{"640":1}}],["这种模式最多丢失不多于",{"1":{"451":1}}],["这种模式只需要为写入阻塞",{"1":{"451":1}}],["这种模拟需要entity的位置能够通过前一个时候的位置",{"1":{"77":1}}],["这种模型可以准确描述某些玩家",{"1":{"46":1}}],["这种逻辑不能很好地使用带宽",{"1":{"50":1}}],["这种情况比较特殊",{"1":{"979":1,"980":1,"981":1,"982":1}}],["这种情况",{"1":{"947":1,"965":1,"1002":1}}],["这种情况可以产生一种难以置信的无缝体验",{"1":{"77":1}}],["这种情况它说",{"1":{"69":1}}],["这种情况下玩家移动仍然有网络延迟一半的延迟",{"1":{"50":1}}],["这种情况下玩家感觉不到任何延迟",{"1":{"50":1}}],["这种情况下的解决问题的原理与刚才不同",{"1":{"48":1}}],["这种情况下",{"1":{"48":2,"857":1}}],["这种情况下我们需要将预测的中间结果存起来",{"1":{"43":1}}],["这种情况我们就将物体直接拉过去",{"1":{"46":1}}],["这种限制使得在客户端收到玩家正确位置以后",{"1":{"46":1}}],["这种方法适合于动作游戏",{"1":{"751":1}}],["这种方法调试的时候最好用linerender把攻击轨迹渲染出来",{"1":{"751":1}}],["这种方法需要在武器或者拳头或者其他的需要攻击判定的地方设定一个点",{"1":{"751":1}}],["这种方法是射击游戏的常用判断方法",{"1":{"750":1}}],["这种方法的局限在于1",{"1":{"749":1}}],["这种方法可以提高效率但是需要更多格外的代码来实现",{"1":{"699":1}}],["这种方法可以称为客户端预测",{"1":{"43":1}}],["这种方法",{"1":{"76":1,"111":1,"1015":1}}],["这种方案是游戏中的权衡设计",{"1":{"47":1}}],["这种方式带来的好处十分明显",{"1":{"738":1}}],["这种方式结合了精灵滚动方式和照相机移动方式",{"1":{"729":1}}],["这种方式在移动过程中由于只需要移动背景照相机",{"1":{"728":1}}],["这种方式与精灵滚动方式正好相反",{"1":{"728":1}}],["这种方式实现简单直接",{"1":{"727":1}}],["这种方式应该是比较直接的",{"1":{"727":1}}],["这种方式就不适合了",{"1":{"574":1}}],["这种方式将凭证存放在磁盘中",{"1":{"411":1}}],["这种方式创建一个动态方法",{"1":{"111":1}}],["这种方式的缺点是你的密码是用明文的方式存放在你的",{"1":{"411":1}}],["这种方式的缺点是麻烦而且容易出错",{"1":{"111":1}}],["这种方式的好处在你可以始终很放心的去部署inactive环境",{"1":{"88":1}}],["这种方式也有很多缺点",{"1":{"89":1}}],["这种方式不好的地方还在于冗余产生的额外维护",{"1":{"88":1}}],["这种方式很难处理",{"1":{"46":1}}],["这种方式非常简单",{"1":{"42":1}}],["这种方式",{"1":{"15":1}}],["这种存储模式将地址的高低和数据位权有效地结合起来",{"1":{"32":1}}],["这种囚徒模式的帧同步",{"1":{"11":1}}],["这样让我们可以查询到它们",{"1":{"962":1}}],["这样看起来转换cubemultiple",{"1":{"963":1}}],["这样看起来物体移动很快",{"1":{"46":1}}],["这样看来或许45",{"1":{"960":1}}],["这样更加随心的修改每个",{"1":{"957":1}}],["这样完全或者部分移植到",{"1":{"955":1}}],["这样对于在团队中分割工作量更容易",{"1":{"955":1}}],["这样昂贵的操作",{"1":{"945":1}}],["这样子代码会更加清晰",{"1":{"944":1}}],["这样它会表现得像拥有一个组件一样",{"1":{"938":1}}],["这样它们会一起移动",{"1":{"737":1}}],["这样允许系统",{"1":{"936":1}}],["这样系统中能更容易通过组件的类型来筛选我们想要的实体",{"1":{"927":1}}],["这样能支持多种",{"1":{"938":1}}],["这样能省下一半的磁盘和内存",{"1":{"867":1}}],["这样能减少画布再次出现的时间",{"1":{"860":1}}],["这样fps自然要受到操作系统刷新率运行值的制约",{"1":{"854":1}}],["这样以后",{"1":{"848":1}}],["这样这些代码只需要编译一次",{"1":{"839":1}}],["这样并不一定好",{"1":{"799":1}}],["这样并不能代理移动和设计精准度提升优化设置可能不会对每个客户端都有效如果是你是在游戏里或者sourcetv里第一视角观看你看到的画面和玩家可能不一样观战者的画面没有延迟补偿https",{"1":{"87":1}}],["这样即可表示一个多边形在某投影轴上的投影了",{"1":{"763":1}}],["这样也是可以做出不错效果的",{"1":{"748":1}}],["这样导致同时存在过多的背景精灵在场景中",{"1":{"728":1}}],["这样不管x",{"1":{"1025":1}}],["这样不可避免的每次调用都会产生不少gc",{"1":{"718":1}}],["这样不仅提高了性能",{"1":{"575":1}}],["这样不仅发展潜力很大",{"1":{"380":1}}],["这样得到的一个类",{"1":{"714":1}}],["这样获得的一个类",{"1":{"714":1}}],["这样我们就无需",{"1":{"966":1}}],["这样我们就进入下一个步骤",{"1":{"711":1}}],["这样我们就可以平滑跟踪到包含所有采样点的曲线",{"1":{"46":1}}],["这样我们就可以忽略一次更新",{"1":{"46":1}}],["这样提高了静态变量的访问速度",{"1":{"707":1}}],["这样你最终可能会至少得到",{"1":{"952":1}}],["这样你会得到一个新的",{"1":{"947":1}}],["这样你会发现传递给il2cpp",{"1":{"592":1}}],["这样你需要瞄准玩家前方50单位才能准确击中",{"1":{"45":1}}],["这样在访问量很少没有并发的情况也行",{"1":{"574":1}}],["这样在客户端收到服务器的确认命令的时候",{"1":{"43":1}}],["这样下面你在连接的时候可以使用比较熟悉的username",{"1":{"459":1}}],["这样处理的最大好处是",{"1":{"455":1}}],["这样才能在方便治理的同时",{"1":{"382":1}}],["这样才能随机创建无限的动态地图",{"1":{"217":1}}],["这样可进行分配的小铜人还有8个",{"1":{"382":1}}],["这样可以容纳一次收集",{"1":{"831":1}}],["这样可以方便调整我们取判定点的时间节点",{"1":{"751":1}}],["这样可以有效的与ai和ui进行解耦",{"1":{"793":1}}],["这样可以有效的使用内存",{"1":{"576":1}}],["这样可以有效的减少人工作业",{"1":{"206":1}}],["这样可以使得",{"1":{"471":1}}],["这样可以保证每位玩家在游戏初始时能够得到数量一致的战略特征",{"1":{"214":1}}],["这样可以减小客户端预测跟服务器之间的误差",{"1":{"43":1}}],["这样他会保留1000肉和1000药",{"1":{"376":1}}],["这样是不对的",{"0":{"251":1}}],["这样会导致这个实体会被移动到一个新的内存块中",{"1":{"929":1}}],["这样会导致明显的位置漂移",{"1":{"43":1}}],["这样会比在所有的实体中查找效率高很多",{"1":{"905":1}}],["这样会生成两个matcher相同的group实例",{"1":{"739":1}}],["这样会使得连接看起来比较不错",{"1":{"220":1}}],["这样当",{"1":{"937":1}}],["这样当他们有所需要的时候就会增加一些新房间",{"1":{"219":1}}],["这样当高延时玩家的命令传到服务器的时候",{"1":{"48":1}}],["这样插值变化不再是单调的线性变化",{"1":{"197":1}}],["这样设计是为了节省内存",{"1":{"131":1}}],["这样所有对象都能找到自己的类型使clr在运行时能确保类型安全",{"1":{"131":1}}],["这样函数的本地代码开始执行",{"1":{"131":1}}],["这样内存就泄露了",{"1":{"124":1}}],["这样便把地图上的所有对象按序分配到了x",{"1":{"105":1}}],["这样避免了遍历地图上所有玩家进行处理的方式",{"1":{"104":1}}],["这样根据对象的世界坐标",{"1":{"101":1}}],["这样风险很小",{"1":{"88":1}}],["这样一旦你instantiate",{"1":{"965":1}}],["这样一来可以保证",{"1":{"455":1}}],["这样一来",{"1":{"83":1,"130":1,"665":1}}],["这样一个怪去攻击一个玩家",{"1":{"19":1}}],["这样爆头就不可能发生了",{"1":{"77":1}}],["这样就保证",{"1":{"1041":1}}],["这样就不会产出",{"1":{"952":1}}],["这样就不会有",{"1":{"48":1}}],["这样就实现了通过cpu准备数据",{"1":{"876":1}}],["这样就能节省内存并提升内存使用效率唯一需要注意的是传递引用时我们在访问原始变量x的值",{"1":{"891":1}}],["这样就能判断是否在视线范围内",{"1":{"771":1}}],["这样就能确定其在哈希环的位置",{"1":{"92":1}}],["这样就变成了消息驱动",{"1":{"653":1}}],["这样就避免了重复的初始化操作",{"1":{"575":1}}],["这样就开始陆续执行所有的代码",{"1":{"131":1}}],["这样就可以触发ontriggerentry函数一次或者多次",{"1":{"748":1}}],["这样就可以在把上传的文件带上版本号",{"1":{"510":1}}],["这样就可以找到main",{"1":{"131":1}}],["这样就可以穿过一堵墙或者超快速的移动",{"1":{"63":1}}],["这样进行插值通常不会有什么问题",{"1":{"46":1}}],["这样本地玩家就差不多可以正确瞄准",{"1":{"46":1}}],["这样客户端就可以确定服务器执行上次命令以后游戏中玩家的准确信息",{"1":{"43":1}}],["这样的观念",{"1":{"971":1}}],["这样的游戏通常会频繁地分配小块",{"1":{"830":1}}],["这样的服务和抽象层",{"1":{"589":1}}],["这样的噪声结果更加令人信服",{"1":{"204":1}}],["这样的性能提升是很可观的",{"1":{"130":1}}],["这样的性能是非常差的",{"1":{"73":1}}],["这样的情况下效率就很高了",{"1":{"108":1}}],["这样的话十字链就没有什么用了",{"1":{"107":1}}],["这样的方案让玩家能够得到即时的反馈",{"1":{"77":1}}],["这样的体验是很差的",{"1":{"74":1}}],["这样的延迟是显而易见的",{"1":{"64":1}}],["这样的存储模式有点儿类似于把数据当作字符串顺序处理",{"1":{"32":1}}],["这样的好处是节约流量",{"1":{"17":1}}],["这样做我确实会得到一个包含",{"1":{"968":1}}],["这样做无疑增加了游戏容量的大小",{"1":{"848":1}}],["这样做的效果就是",{"1":{"841":1}}],["这样做的好处是",{"1":{"107":1,"220":1}}],["这样做是可以的",{"1":{"45":1}}],["这样做",{"1":{"19":1}}],["这样怪物的随机移动",{"1":{"18":1}}],["这样",{"1":{"15":1,"44":1,"45":2,"46":3,"50":1,"96":1,"105":1,"724":1,"805":1,"952":1,"954":1,"1023":1}}],["这个渲染队列是大多数物体的默认队列",{"1":{"1036":1}}],["这个渲染队列最先渲染",{"1":{"1036":1}}],["这个信息时效性只有一帧",{"1":{"991":1}}],["这个信号处理函数执行完毕之后",{"1":{"455":1}}],["这个池子被绑定到gpu上",{"1":{"984":1}}],["这个组件同时也需要你添加",{"1":{"968":1}}],["这个对象确实是有destroy",{"1":{"968":1}}],["这个对象通常是无状态的",{"1":{"822":1}}],["这个视图仅仅包含你算法或者程序中需要的特定的数据",{"1":{"912":1}}],["这个实体会被移到另外一个块中",{"1":{"905":1}}],["这个根的构成如下",{"1":{"898":1}}],["这个初始列表我们叫它",{"1":{"898":1}}],["这个引用通常被叫作指针",{"1":{"883":1}}],["这个设置的过程依赖于mesh中的api是",{"1":{"847":1}}],["这个额外的存储开销是完全可以去除的",{"1":{"846":1}}],["这个图中",{"1":{"904":1}}],["这个图元是不可见的",{"1":{"846":1}}],["这个图是我拷贝来的",{"1":{"122":1}}],["这个在游戏场景中应用的还是比较多的",{"1":{"841":1}}],["这个在edit",{"1":{"652":1}}],["这个按钮",{"1":{"841":1}}],["这个策略对于分配",{"1":{"831":1}}],["这个策略通常最适合长期游戏的游戏",{"1":{"830":1}}],["这个策略用在il2cpp项目上非常的棒",{"1":{"594":1}}],["这个属性的访问",{"1":{"824":1}}],["这个枚举器实现的idisposable接口",{"1":{"823":1}}],["这个内存分配不管是使用匿名函数或者是预先定义好的函数来传递都会发生",{"1":{"818":1}}],["这个数据容器",{"1":{"941":1}}],["这个数据我们可以具体看raycastresult这个类",{"1":{"675":1}}],["这个数字与在制定帧分配的临时比特数不相同",{"1":{"815":1}}],["这个发生的间隔时间是不能保证的",{"1":{"814":1}}],["这个新释放的空间只能用于存储与它完全相同或者更小大小的对象",{"1":{"813":1}}],["这个空隙在上图中由红圈标明",{"1":{"813":1}}],["这个与表象共享技能id",{"1":{"810":1}}],["这个技能只要玩家点着按钮不放开",{"1":{"795":1}}],["这个技巧在很早的时候我在雨松的文章第一次看到",{"1":{"667":1}}],["这个流程一般为",{"1":{"794":1}}],["这个树形结构非常类似行为树",{"1":{"794":1}}],["这个算法基本就是如此的",{"1":{"784":1}}],["这个向量将会是我们的一个",{"1":{"784":1}}],["这个条件",{"1":{"748":1}}],["这个entity会",{"1":{"742":1}}],["这个原始的content会被删除",{"1":{"737":1}}],["这个原因是如果使用透视投影来产生视差的话",{"1":{"724":1}}],["这个content是在播放模式下编辑和复制过的",{"1":{"737":1}}],["这个callstack也就是方法的栈帧的具体显示",{"1":{"131":1}}],["这个案例中为z",{"1":{"737":1}}],["这个标签的意思是",{"1":{"717":1}}],["这个maptype是什么时候装配的",{"1":{"714":1}}],["这个存储区被clr用来存储这个hard",{"1":{"707":1}}],["这个默认的appdomain是唯一且不能被卸载的",{"1":{"707":1}}],["这个加载一般是通过调用",{"1":{"707":1}}],["这个同样为当前对象",{"1":{"685":1}}],["这个值有可能是",{"1":{"1037":1}}],["这个值的默认值是",{"1":{"1037":1}}],["这个值越大",{"1":{"877":1}}],["这个值是当前对象",{"1":{"685":1}}],["这个值是摄像机到射线检测碰撞点的距离",{"1":{"685":1}}],["这个值很容易被错误地使用",{"1":{"644":1}}],["这个代理",{"1":{"684":1}}],["这个参数就是自定义设定的",{"1":{"689":1}}],["这个参数最终会传给事件处理函数",{"1":{"678":1}}],["这个参数pushlatency是一个负数",{"1":{"50":1}}],["这个函数在创建jobcomponentsystem时将entityquery实例分配给您的字段",{"1":{"910":1}}],["这个函数在editor中运行时总是会产生内存分配",{"1":{"815":1}}],["这个函数用于为字典的键获得合适的散列码",{"1":{"822":1}}],["这个函数帮助我们检测画布上被射线触发的地方并且返回结果",{"1":{"676":1}}],["这个函数执行以下两个工作",{"1":{"446":1}}],["这个例子中自然就是aaa物体",{"1":{"661":1}}],["这个接口",{"1":{"661":1}}],["这个调用将执行target身上所有继承",{"1":{"657":1}}],["这个trigger放置在产生事件的ui组件上",{"1":{"657":1}}],["这个模块也是可以自己继承baseraycaster实现个性化定制",{"1":{"654":1}}],["这个模板",{"1":{"225":1}}],["这个处理方式有以下几个特点",{"1":{"652":1}}],["这个是强命名的公用程序集",{"1":{"707":1}}],["这个是针对锚点的",{"1":{"643":1}}],["这个是固定的无异议的",{"1":{"39":1}}],["这个点的世界坐标就会变化",{"1":{"751":1}}],["这个点的会在",{"1":{"639":1}}],["这个点开始的位置",{"1":{"46":1}}],["这个偏移量随屏幕分辨率变化而按比例变化",{"1":{"625":1}}],["这个可能和canvas的plane",{"1":{"622":1}}],["这个可以减少代码并降低最后二进制文件的尺寸确保和unity",{"1":{"592":1}}],["这个可以通过",{"1":{"204":1}}],["这个真是老太太的裹脚布",{"1":{"592":1}}],["这个只要你知我知便好",{"1":{"591":1}}],["这个协议可以用",{"1":{"573":1}}],["这个场景下的服务器一般被称为",{"1":{"573":1}}],["这个进程",{"1":{"563":1}}],["这个工具",{"1":{"535":1}}],["这个缓存在",{"1":{"455":1}}],["这个",{"1":{"449":2,"452":1,"944":1,"948":1,"950":1,"954":1,"968":1,"1000":1}}],["这个执行并传播命令的过程可以用以下伪代码表示",{"1":{"444":1}}],["这个有点西式",{"1":{"287":1}}],["这个概念",{"1":{"273":1}}],["这个位置就是我们所讨论的坐标系",{"1":{"841":1}}],["这个位置是草的tile",{"1":{"225":1}}],["这个位置可能既不在地面上",{"1":{"46":1}}],["这个关卡由16个房间按照4x4的网格方式组成",{"1":{"224":1}}],["这个地区也可以",{"1":{"221":1}}],["这个地址指向mscoree",{"1":{"131":1}}],["这个矩阵等于它的转置矩阵",{"1":{"209":1}}],["这个名字看起来是来自量子力学",{"1":{"206":1}}],["这个范围内",{"1":{"199":1}}],["这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式",{"1":{"197":1}}],["这个一般是根据浏览器的设置进行访问的",{"1":{"154":1}}],["这个表可以让gc在回收内存时方便从根找到所有引用",{"1":{"131":1}}],["这个程序就跟c++编译的一模一样了",{"1":{"130":1}}],["这个太要命了",{"1":{"120":1}}],["这个框架能够创建对象及其引用的对象的深拷贝",{"1":{"111":1}}],["这个灯塔管理两个队列",{"1":{"104":1}}],["这个错误需要由服务器侧进行延迟补偿校正",{"1":{"85":1}}],["这个世界状态的变化传送到所有客户端的下一个快照的更新",{"1":{"84":1}}],["这个问题再移动设备上非常普遍",{"1":{"824":1}}],["这个问题很容易解决",{"1":{"726":1}}],["这个问题我们下一篇会进行讨论",{"1":{"76":1}}],["这个问题会在下面的文章中进行讨论",{"1":{"70":1}}],["这个方法比给每个",{"1":{"970":1}}],["这个方法可以用来",{"1":{"936":1}}],["这个方法可以让你专注于vs而无需切换回unity",{"1":{"746":1}}],["这个方法会启动job的执行",{"1":{"924":1}}],["这个方法总算被我领悟了",{"1":{"782":1}}],["这个方法需要定义一个raycasthit类型的变量来接收返回数据",{"1":{"751":1}}],["这个方法还有很多重载",{"1":{"750":1}}],["这个方法还会计算一个射线检测使用的最大距离",{"1":{"684":1}}],["这个方法来发射射线",{"1":{"750":1}}],["这个方法供子类覆写以实现对不同类别的物体进行射线检测",{"1":{"683":1}}],["这个方法无需被调用",{"1":{"600":1}}],["这个方法运行的很平滑",{"1":{"74":1}}],["这个方法的缺点主要在于3人以下或者单机模式的话就没法使用了",{"1":{"15":1}}],["这个玩家看不到正在射击他的那个人",{"1":{"48":1}}],["这个玩家沿与你实现垂直的方向奔跑",{"1":{"45":1}}],["这个时候可以使用组件从conversionsystem中获取",{"1":{"1054":1}}],["这个时候如果获取世界坐标",{"1":{"1053":1}}],["这个时候translation代表的是相对于父对象的坐标",{"1":{"1053":1}}],["这个时候time的callback",{"1":{"161":1}}],["这个时候首先想到的是降低帧率",{"1":{"855":1}}],["这个时候我们就需要稍微动点脑子了",{"1":{"841":1}}],["这个时候我们需要编写一个简单的",{"1":{"726":1}}],["这个时候内存中可能会存在两份资源的引用",{"1":{"705":1}}],["这个时候就需要使用submesh了",{"1":{"847":1}}],["这个时候就有了我们上面看到的",{"1":{"680":1}}],["这个时候就出来了分布式服务器",{"1":{"581":1}}],["这个时候的缩放比是由宽度决定的",{"1":{"625":1}}],["这个时候需要将2d角色始终面向相机",{"1":{"620":1}}],["这个时候你该怎么处理",{"1":{"70":1}}],["这个时候",{"1":{"48":1,"58":1}}],["这个时候纠正信息通常已经过期",{"1":{"43":1}}],["这个这种事游戏设计决定的",{"1":{"48":1}}],["这个回退时间需要考虑到命令执行的时候的网络延时和插值量",{"1":{"47":1}}],["这个系统需要注意一点",{"1":{"45":1}}],["这个系统中有几个需要注意的地方",{"1":{"43":1}}],["这个确认命令也会有一定延迟",{"1":{"43":1}}],["这个无字节序问题",{"1":{"39":1}}],["这个随机的移动设定由每个客户端自己控制",{"1":{"18":1}}],["这个操作手感",{"1":{"15":1}}],["这里阅读更多内容",{"1":{"965":1}}],["这里支持",{"1":{"964":1}}],["这里你可以执行",{"1":{"950":1}}],["这里指的是最普通的组件",{"1":{"927":1}}],["这里指向的是",{"1":{"131":1}}],["这里也给一下伪代码",{"1":{"862":1}}],["这里也是利用ghproxy进行代理",{"1":{"569":1}}],["这里可以使用poolmanager代替",{"1":{"858":1}}],["这里明明只有一个三角面片",{"1":{"847":1}}],["这里需要新建一个layer",{"1":{"1034":1}}],["这里需要注意的是",{"1":{"846":1}}],["这里需要仔细地区分",{"1":{"15":1}}],["这里状态＝buff",{"1":{"800":1}}],["这里截取出演示",{"1":{"726":1}}],["这里以",{"1":{"726":1}}],["这里以2d游戏为例",{"1":{"105":1}}],["这里我添加了",{"1":{"971":1}}],["这里我要告诉大家的是",{"1":{"841":1}}],["这里我也有个简单的判断方法",{"1":{"840":1}}],["这里我们需要注意的是",{"1":{"717":1}}],["这里我用在gamecamera上面",{"1":{"663":1}}],["这里面又分为两种情况",{"1":{"693":1}}],["这里假设为物体aaa在任何脚本中使用executeevents静态类发送message",{"1":{"661":1}}],["这里使用unity的版本是5",{"1":{"592":1}}],["这里使用了两个表达式",{"1":{"510":1}}],["这里真的踩了坑了",{"1":{"537":1}}],["这里是一个按照",{"1":{"427":1}}],["这里提供了一些写声明文件的方法",{"1":{"398":1}}],["这里就不多说了",{"1":{"591":1}}],["这里就得跳到那个台阶上面避开尖刺",{"1":{"225":1}}],["这里就没画了",{"1":{"131":1}}],["这里只是为了举例",{"1":{"224":1}}],["这里所讲的是我能做到的最好的一个",{"1":{"219":1}}],["这里所说的技能执行流程指的是技能树的一个执行节点的流程",{"1":{"803":1}}],["这里所说的技能模块包括",{"1":{"801":1}}],["这里所说的只是算法的规则",{"1":{"220":1}}],["这里所说的",{"1":{"206":1}}],["这里所谈的外挂仅指会更改游戏逻辑执行或数值的外挂",{"1":{"15":1}}],["这里不是说可以脱离",{"1":{"130":1}}],["这里不要混淆了",{"1":{"130":1}}],["这里和这里",{"1":{"111":1}}],["这里做的是四边形灯塔区域",{"1":{"104":1}}],["这里的关键细节是",{"1":{"828":1}}],["这里的关键词是",{"1":{"75":1}}],["这里的条件筛选包括",{"1":{"690":1}}],["这里的",{"1":{"684":2}}],["这里的拉伸的含义仅仅是设置panel的宽",{"1":{"628":1}}],["这里的蛇和宝石并不像其他敌人那样随机生成",{"1":{"224":1}}],["这里的链表为双向链表",{"1":{"105":1}}],["这里的帧和游戏的渲染帧率并不是一个",{"1":{"11":1}}],["这里有一段可以设置缩放的代码",{"1":{"737":1}}],["这里有一个统一的处理方式",{"1":{"69":1}}],["这里有4种不同的房间类型",{"1":{"224":1}}],["这里有",{"1":{"224":1}}],["这里有两个目的",{"1":{"106":1}}],["这里有很多的可以优化的点",{"1":{"15":1}}],["这里",{"1":{"15":2}}],["每個所生成的",{"1":{"974":1}}],["每块用一个",{"1":{"905":1}}],["每三个整型表示一个图元",{"1":{"846":1}}],["每三个顶点表示一个三角图元",{"1":{"846":1}}],["每帧列表的内存会被保持和重用",{"1":{"817":1}}],["每隔一段时间服务端执行检测逻辑",{"1":{"807":1}}],["每隔一段时间进行一次伤害结算",{"1":{"799":1}}],["每隔一段时间法术场检测此区域的敌人",{"1":{"799":1}}],["每隔一段时间生成客人",{"1":{"369":1}}],["每执行一个命令保存一次",{"0":{"450":1},"1":{"447":1,"451":1}}],["每增加5点敏捷",{"1":{"385":1}}],["每级额外获得3点闪避",{"1":{"385":1}}],["每秒执行一次垃圾回收器会降低性能",{"1":{"815":1}}],["每秒20",{"1":{"384":3}}],["每秒1",{"1":{"384":1,"390":1}}],["每秒10个更新意味着每100ms收到一个更新",{"1":{"46":1}}],["每升1级",{"1":{"380":1}}],["每日情报资料更新後都要看弟子工作效率",{"1":{"375":1}}],["每日杀人取乐",{"1":{"297":1}}],["每提升一点则减少消耗体力0",{"1":{"368":5}}],["每小时额外扣除体力",{"1":{"301":1}}],["每小时7点",{"1":{"290":1}}],["每天6点会触发新的一天的事件",{"1":{"291":1}}],["每天晚上睡觉会自动存档",{"1":{"289":1}}],["每分钟回复体力1点增加体力总值",{"1":{"290":1}}],["每分钟回复体力1点",{"1":{"290":1}}],["每层的图片宽高480",{"1":{"287":1}}],["每当出现某component相关的结构性变化的时候",{"1":{"988":1}}],["每当转换执行时",{"1":{"957":1}}],["每当交换或关联算术允许时",{"1":{"858":1}}],["每当我们修改代码之后我们注入的结果会被覆盖掉",{"1":{"717":1}}],["每当客户请求",{"1":{"574":1}}],["每当",{"1":{"449":1}}],["每当服务器常规任务函数被执行",{"1":{"446":1}}],["每当命令函数成功执行之后",{"1":{"444":1}}],["每当一个room被创建",{"1":{"224":1}}],["每当物体发生变化",{"1":{"104":1}}],["每项由一个指向同步块的指针和对象指针组成",{"1":{"131":1}}],["每种类型的成员的签名",{"1":{"127":1}}],["每100ms更新一次坐标",{"1":{"74":1}}],["每次update的时候会处理converttoentity添加到system中的gameobject最终调用的时候是使用",{"1":{"999":1}}],["每次我按下",{"1":{"969":1}}],["每次",{"1":{"940":1}}],["每次cpu准备数据并通知gpu的过程就称之为一个drawcall",{"1":{"876":1}}],["每次访问",{"1":{"864":1}}],["每次循环",{"1":{"828":1}}],["每次函数调用都会至少一次对键进行装箱",{"1":{"822":1}}],["每次打开",{"1":{"722":1}}],["每次运行unity都会发现自己的c盘空间在急剧缩小",{"1":{"526":1}}],["每次都要编译出各个操作系统对应的发行包再进行上传",{"1":{"510":1}}],["每次当用户点击触发事件时",{"1":{"860":1}}],["每次当",{"1":{"456":1}}],["每次执行完一个命令之后",{"1":{"450":1}}],["每次调用update将分配新字符串",{"1":{"828":1}}],["每次调用后对应的资源的引用记数都会增加1",{"1":{"697":1}}],["每次调用",{"1":{"448":1}}],["每次进行rdb时",{"1":{"442":1}}],["每次升级身法+10",{"1":{"392":1}}],["每次升级元气+10",{"1":{"392":2}}],["每次升级元气+5",{"1":{"392":1}}],["每次升级力道身法+5",{"1":{"392":1}}],["每次升级力道+10",{"1":{"392":1}}],["每次使用+3主要回复方法",{"1":{"290":1}}],["每次使用+4",{"1":{"290":1}}],["每次使用+2",{"1":{"290":1}}],["每次使用+1",{"1":{"290":1}}],["每次使用eden和其中的一块survivor",{"1":{"120":1}}],["每次重新生成一个新的范围时",{"1":{"173":1}}],["每次通过指向mutator生成垃圾时",{"1":{"115":1}}],["每次移动都需要计算视野差",{"1":{"110":1}}],["每次redis请求会随机发送到其中一台",{"1":{"91":1}}],["每次部署需要5分钟",{"1":{"89":1}}],["每次更新10个实例",{"1":{"89":1}}],["每次更新的时间间隔",{"1":{"73":1}}],["每次更新的时候客户端收到服务器发过来的时间被直接当做客户端的时间使用",{"1":{"50":1}}],["每次直接使用收到的坐标进行更新",{"1":{"74":1}}],["每次导弹准备发射的时候",{"1":{"50":1}}],["每把武器都还剩多少弹药",{"1":{"44":1}}],["每个系统更新之前+1",{"1":{"992":1}}],["每个",{"1":{"960":1}}],["每个只能容纳",{"1":{"960":1}}],["每个方块的",{"1":{"940":1}}],["每个内存块",{"1":{"929":1}}],["每个都有自己的性能影响和限制",{"1":{"909":1}}],["每个3d物体对应一个实体",{"1":{"905":1}}],["每个模块使用1~2张图集",{"1":{"861":1}}],["每个mesh都由若干个三角形组成",{"1":{"846":1}}],["每个技能对应独立的脚本",{"1":{"811":1}}],["每个法术场结算一次",{"1":{"801":1}}],["每个程序集的代码会分别装载到各个appdomain中",{"1":{"707":1}}],["每个appdomain会单独保持一个类的静态变量",{"1":{"707":1}}],["每个appdomain引用到某个类型的时候需要把相应的assembly在各自的appdomain中初始化",{"1":{"707":1}}],["每个泛型实例实际上都是一个独立的类型",{"1":{"599":1}}],["每个小铜人代表1个时辰",{"1":{"382":1}}],["每个分舵都必须最少任命一位舵主",{"1":{"380":1}}],["每个产物每样工作都1点的话会比较平均",{"1":{"376":1}}],["每个装备固有的一个品质等级",{"1":{"271":1}}],["每个npc身上都有",{"1":{"252":1}}],["每个特效可以授予角色tag",{"1":{"249":1}}],["每个等级可以解锁额外的词条",{"1":{"248":1}}],["每个房间类型都有一堆不同的模板",{"1":{"225":1}}],["每个候选点都选出与之前轮采样点中距离最近的距离",{"1":{"214":1}}],["每个元素会是一个集合",{"1":{"210":1}}],["每个约束矩阵的长度为总的瓦片id数",{"1":{"209":1}}],["每个坐标的梯度向量都是确定不变的",{"1":{"197":1}}],["每个对象都知道自己的被引用数",{"1":{"115":1}}],["每个对象可以自己定制自己的通知范围",{"1":{"106":1}}],["每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的",{"1":{"113":1}}],["每个格子记录格子内的玩家",{"1":{"103":1}}],["每个patch都对应有一个对象链表",{"1":{"101":1}}],["每个land就是一个大小固定的正方形",{"1":{"99":1}}],["每个计算结果位置都放置在对应节点中",{"1":{"96":1}}],["每个人都在你身边看到同一个世界",{"1":{"85":1}}],["每个更新包包含生成的服务器时间戳",{"1":{"46":1}}],["每个玩家以出生点占位符为种子",{"1":{"215":1}}],["每个玩家占位符附近距离n以内的单元格为玩家区域",{"1":{"214":1}}],["每个玩家的aoi范围是以自己为中心范围内的九个格子",{"1":{"103":1}}],["每个玩家的延迟都等于延迟最高的那个人",{"1":{"11":1}}],["每个玩家游戏的过程中感觉不到明显延迟",{"1":{"48":1}}],["每个玩家根据服务器发过来的数据包控制自己的移动",{"1":{"41":1}}],["每个地址单元都对应着一个字节",{"1":{"33":1}}],["每个配置各自序列化自己的部分",{"1":{"15":1}}],["每一种component",{"1":{"991":1}}],["每一秒钟保存一次",{"0":{"449":1},"1":{"447":1,"449":2,"451":1}}],["每一次调用一个方法就会在最上面叠一个盒子",{"1":{"879":1}}],["每一次连接都会询问你的用户名和密码",{"1":{"411":1}}],["每一次模拟更新tick之后服务器会决定是否更新当前时间快照以及每个客户端当前是否需更新",{"1":{"82":1}}],["每一位门徒弟子感到疲惫时",{"1":{"380":1}}],["每一个constant",{"1":{"981":1}}],["每一个对应一个唯一的值",{"1":{"976":1}}],["每一个",{"1":{"960":1}}],["每一个元素的",{"1":{"952":1}}],["每一个uwsgi",{"1":{"579":1}}],["每一个玩家都和游戏世界有一点点不同步",{"1":{"76":1}}],["每一个玩家的turn推进速度一致",{"1":{"11":1}}],["每一个有延迟的玩家都有一个朝向别的玩家的直的视线",{"1":{"48":1}}],["每一帧把可以进行批处理的模型网格进行合并",{"1":{"876":1}}],["每一帧不断的检测",{"1":{"653":1}}],["每一帧都执行update",{"1":{"277":1}}],["每一帧渲染的时候",{"1":{"46":1}}],["每一帧只有当服务器集齐了所有玩家的操作指令",{"1":{"11":1}}],["其概念可想像是",{"1":{"977":1}}],["其尺寸大小與最後成像尺寸相同",{"1":{"974":1}}],["其目的显然是为了实例化",{"1":{"965":1}}],["其目的是让你可以使用",{"1":{"957":1}}],["其行为不会发生变化",{"1":{"953":1}}],["其行为和性能都和",{"1":{"937":1}}],["其",{"1":{"952":1,"977":3}}],["其监控一个",{"1":{"931":1}}],["其索引存储在内存块而非实体中",{"1":{"929":1}}],["其用途也很广",{"1":{"927":1}}],["其它诸位看上面那段文字脑补下吧",{"1":{"862":1}}],["其它非重用ui按照功能模块进行划分",{"1":{"861":1}}],["其性能会下降",{"1":{"857":1}}],["其函数原型为",{"1":{"847":1}}],["其主要分为以下四个步骤",{"1":{"839":1}}],["其肯定会在循环终止时被调用",{"1":{"823":1}}],["其内存也会被清空",{"1":{"813":1}}],["其次",{"1":{"795":2,"818":1}}],["其次是混合滚动方式",{"1":{"731":1}}],["其次是第二步",{"1":{"208":1}}],["其次是ai生成的不一定能满足业务需求",{"1":{"206":1}}],["其余区域都变成透明",{"1":{"759":1}}],["其余流程与前面一致",{"1":{"275":1}}],["其作者也在知乎的回答中简单说明了原理",{"1":{"717":1}}],["其原理是使用mono",{"1":{"717":1}}],["其调用unity主工程",{"1":{"716":1}}],["其对于的封装来自昱这个iltype封装的reflectiontype",{"1":{"714":1}}],["其在update中去轮询检测处理input的输入",{"1":{"655":1}}],["其在任何时间点的位置都高度依赖于其先前的位置",{"1":{"75":1}}],["其實你已經完全掌握了",{"1":{"633":1}}],["其實全部都取決於控制",{"1":{"633":1}}],["其状态设置为活动",{"1":{"615":1}}],["其完全由c",{"1":{"590":1}}],["其代表了门派的存在",{"1":{"380":1}}],["其qlvl都是84",{"1":{"271":1}}],["其相邻对应位置瓦片允许的值",{"1":{"209":1}}],["其值为bool或者是0或1",{"1":{"209":1}}],["其实还是会造成不必要的内存与cpu占用",{"1":{"867":1}}],["其实在上面视口坐标系介绍中的图中我已经把",{"1":{"841":1}}],["其实在之前的内容已经提到过很多次",{"1":{"273":1}}],["其实不然",{"1":{"841":1}}],["其实屏幕坐标系处理起来很简单直接",{"1":{"841":1}}],["其实如果仅仅只有",{"1":{"840":1}}],["其实两种判断都很简单",{"1":{"776":1}}],["其实两者本来没什么好对比的",{"1":{"707":1}}],["其实这些",{"1":{"969":1}}],["其实这些小算法基本上用的全是向量的计算",{"1":{"779":1}}],["其实这样在",{"1":{"938":1}}],["其实这个分为两部分",{"1":{"771":1}}],["其实这关系到基础武学和六力",{"1":{"374":1}}],["其实任何时候filter都需要对entity的component做判断",{"1":{"739":1}}],["其实只是将prefab的数据加载到了内存中",{"1":{"699":1}}],["其实也只是判断了一下是否为ieventsystemhandler这么简单",{"1":{"678":1}}],["其实也就只是应用程序的聚焦状态",{"1":{"668":1}}],["其实就是shader中tags中的queue默认情况下",{"1":{"976":1}}],["其实就是在这个程序域上加载dll",{"1":{"708":1}}],["其实就是普通的射线检测",{"1":{"676":1}}],["其实就是ps运用黑",{"1":{"0":1}}],["其实是圆形范围内",{"1":{"771":1}}],["其实是",{"1":{"759":1}}],["其实是依次调用所有的raycaster中的射线检测",{"1":{"675":1}}],["其实是一个有歧义的词语",{"1":{"454":1}}],["其实里面还是有一些和平台相关的代码使用了程序集",{"1":{"591":1}}],["其实",{"1":{"376":1,"756":1,"761":1}}],["其实我觉得这地方最有学问",{"1":{"375":1}}],["其实并不确定这个解释对不对",{"1":{"206":1}}],["其实它只是对aspnetcore的requestlocalizationmiddleware进行了一层包装",{"1":{"156":1}}],["其中谁是插值",{"1":{"1019":1}}],["其中有几个方法可以用来声明",{"1":{"964":1}}],["其中每一个线程会运行时会使用",{"1":{"944":1}}],["其中只是把指针重新指向缓冲",{"1":{"937":1}}],["其中包含",{"1":{"916":1}}],["其中包含的是符合条件的实体",{"1":{"911":1}}],["其中包含原始位置",{"1":{"46":1}}],["其中最大的那个作为自己的",{"1":{"862":1}}],["其中平滑的帧速率是主要的关注点",{"1":{"830":1}}],["其中技能结算包括",{"1":{"803":1}}],["其中hasgen是为了防止重复注入而定义的flag",{"1":{"717":1}}],["其中horizontal和vertical分别对应宽和高",{"1":{"645":1}}],["其中的特定",{"1":{"947":1}}],["其中的ilruntimetype继承自type类",{"1":{"714":1}}],["其中的readmodule为",{"1":{"713":1}}],["其中的多个资源被加载出来后",{"1":{"701":1}}],["其中imagereader最终来自binaryreader",{"1":{"711":1}}],["其中核心方法就是",{"1":{"679":1}}],["其中核心组件包含进程管理",{"1":{"580":1}}],["其中中间是针对navigation也就是类似于通过键盘上下左右或者手柄进行ui位置切换的操作",{"1":{"668":1}}],["其中第一个参数代表对齐方式",{"1":{"645":1}}],["其中会用到",{"1":{"510":1}}],["其中魔杖属于远程武器",{"1":{"384":1}}],["其中瓦片会有特定的几何形状",{"1":{"207":1}}],["其中又有哪些精妙的代码呢",{"1":{"170":1}}],["其中主要是辅助接受用户请求和解析http协议的代码",{"1":{"170":1}}],["其中可以包含所有应用程序需要的",{"1":{"164":1}}],["其中根据上面代码可见",{"1":{"138":1}}],["其中一个有3个",{"1":{"955":1}}],["其中一个缺少",{"1":{"955":1}}],["其中一个将成为",{"1":{"947":1}}],["其中一部分的所有数据都比另外一部分的所有数据都要小",{"1":{"107":1}}],["其中一台宕机后",{"1":{"94":1}}],["其中k是关键字的数量",{"1":{"92":1}}],["其中",{"1":{"15":1,"43":1,"207":1,"535":1,"536":1,"798":1,"929":1,"943":1,"953":1,"1039":1}}],["其他三者都是",{"1":{"971":1}}],["其他有趣的方法和convertgameobjecthierarchy几乎一样",{"1":{"970":1}}],["其他任意类型的",{"1":{"964":1}}],["其他获取值的方法可以参考",{"1":{"930":1}}],["其他要点",{"0":{"930":1}}],["其他客户端收到指令后可是播放技能表现",{"1":{"803":1}}],["其他的就很好理解了",{"1":{"976":1}}],["其他的一些参考",{"0":{"790":1}}],["其他的都随机分布",{"1":{"301":1}}],["其他两个选项都是固定像素大小",{"1":{"628":1}}],["其他模型加载都会报错",{"1":{"568":1}}],["其他路径",{"0":{"498":1}}],["其他命令一律返回错误",{"1":{"452":1}}],["其他命令都是之前我们在终端里执行的命令",{"1":{"443":1}}],["其他",{"0":{"421":1,"602":1,"757":1},"1":{"523":1},"2":{"758":1,"759":1}}],["其他人很容易通过",{"1":{"412":1}}],["其他人还没发现有过",{"1":{"378":1}}],["其他贵重材料慢慢卖或是不卖",{"1":{"376":1}}],["其他都要打开并且设",{"1":{"376":1}}],["其他牧场",{"1":{"376":1}}],["其他物品",{"1":{"287":1}}],["其他动作",{"0":{"244":1}}],["其他爆炸物的释放",{"1":{"242":1}}],["其他4个点则是单元正方形的各顶点接着",{"1":{"197":1}}],["其他数据不会受到影响",{"1":{"95":1}}],["其他玩家",{"1":{"78":1}}],["其他玩家的同步还是一个问题",{"1":{"77":1}}],["其他玩家的行为动作要模拟的话",{"1":{"74":1}}],["其他玩家的输入",{"1":{"15":1}}],["其他玩家控制的角色",{"1":{"72":1}}],["其他玩家必须等待该玩家跟上之后再继续计算",{"1":{"11":1}}],["其他游戏也差不多",{"1":{"12":1}}],["如linkedentitygroup",{"1":{"965":1}}],["如不要使用",{"1":{"964":1}}],["如非特殊",{"1":{"970":1}}],["如非特别指定",{"1":{"949":1}}],["如非必要",{"1":{"964":1}}],["如前文中提到的",{"1":{"954":1}}],["如前摇锁定",{"1":{"797":1}}],["如文件操作",{"1":{"898":1}}],["如黄色箭头",{"1":{"898":1}}],["如角落里堆积的破旧纸张",{"1":{"898":1}}],["如string",{"1":{"896":1}}],["如第一节所说",{"1":{"885":1}}],["如方法执行完成",{"1":{"879":1}}],["如石头或者房子",{"1":{"869":1}}],["如背景音乐",{"1":{"867":1}}],["如button",{"1":{"862":1}}],["如button的onpointerclick",{"1":{"657":1}}],["如一些边框",{"1":{"861":1}}],["如有意外概不负责unity",{"1":{"855":1}}],["如vertices",{"1":{"847":1}}],["如抛射体",{"1":{"832":1}}],["如同上图所示",{"1":{"813":1}}],["如攻击力",{"1":{"809":1}}],["如受击特效等",{"1":{"809":1}}],["如法术场受击特效等",{"1":{"807":1}}],["如对于怪物来说",{"1":{"801":1}}],["如减速",{"1":{"800":1}}],["如状态a排斥状态b",{"1":{"800":1}}],["如排斥等",{"1":{"800":1}}],["如排斥",{"1":{"800":1}}],["如玩家控制单位",{"1":{"797":1}}],["如被攻击",{"1":{"793":1}}],["如若转载",{"1":{"770":1}}],["如上例",{"1":{"960":1}}],["如上图",{"1":{"940":1}}],["如上图所示",{"1":{"210":1}}],["如上一节所讲栈开始清理",{"1":{"887":1}}],["如上所述",{"1":{"829":1}}],["如上述讲述的碰撞算法",{"1":{"768":1}}],["如各种球类碰撞",{"1":{"754":1}}],["如游戏中常用的postion和name等component",{"1":{"739":1}}],["如主界面",{"1":{"628":1}}],["如之前",{"1":{"604":1}}],["如flask框架写的程序",{"1":{"578":1}}],["如nginx",{"1":{"578":1}}],["如查询数据库",{"1":{"577":1}}],["如使用",{"1":{"509":1}}],["如拳法要臂力和腰力",{"1":{"374":1}}],["如安达里尔",{"1":{"266":1}}],["如chrome",{"1":{"157":1}}],["如日期",{"1":{"155":1}}],["如下代码所示",{"1":{"969":1}}],["如下所示",{"1":{"953":1}}],["如下面所示",{"1":{"846":1}}],["如下面的代码所示",{"1":{"848":1}}],["如下面的代码",{"1":{"742":1}}],["如下表",{"1":{"836":1}}],["如下述的案例中",{"1":{"759":1}}],["如下圖",{"1":{"639":1}}],["如下方左侧是实验组生成的地图",{"1":{"215":1}}],["如下",{"1":{"131":1,"420":1,"507":1,"693":1,"695":1,"896":1}}],["如下图两个",{"1":{"982":1}}],["如下图想用绿色盖住cube",{"1":{"622":1}}],["如下图显示传入世界快照的到达时间",{"1":{"83":1}}],["如下图所示",{"1":{"63":1,"74":1,"103":1,"212":1,"214":3,"215":1,"574":1,"762":1,"1039":1}}],["如下图",{"1":{"12":1,"841":1,"898":1,"954":1,"980":1}}],["如",{"1":{"131":1,"212":1,"266":1,"509":3,"574":1,"577":1,"739":1,"891":1,"898":1,"946":1,"961":1,"1022":1}}],["如需要内存管理等服务",{"1":{"127":1}}],["如图所示",{"1":{"764":1,"803":1}}],["如图顺序所示",{"1":{"224":1}}],["如图2所示的梯度向量就是最初版算法所随机出来的梯度向量",{"1":{"197":1}}],["如图",{"1":{"124":1,"625":1,"657":1}}],["如老年代",{"1":{"119":1,"120":1}}],["如假设哈希函数h的值空间为0",{"1":{"92":1}}],["如公式",{"1":{"91":1}}],["如版本2测试正常",{"1":{"88":1}}],["如何建立从ibuildpipelinecomponent组件中获取pipeline",{"1":{"972":1}}],["如何影响",{"0":{"963":1}}],["如何执行一个job呢",{"1":{"921":1}}],["如何执行事件",{"0":{"677":1}}],["如何不让相机产生任何旋转就能把世界中的游戏物体放到合适的视口位置呢",{"1":{"841":1}}],["如何通过宽高比获取摄像机视口尺寸呢",{"1":{"841":1}}],["如何得到向量在投影轴上的长度",{"1":{"763":1}}],["如何检测两段投影是否发生重叠",{"1":{"761":1}}],["如何将多边形投射到某条投影轴上",{"1":{"761":1}}],["如何确定多边形的各个投影轴",{"1":{"761":1}}],["如何获取到我们需要的",{"1":{"943":1}}],["如何获取到敌人的游戏物体",{"1":{"749":1}}],["如何获取纹理",{"1":{"726":1}}],["如何变焦相机有两个选择",{"1":{"737":1}}],["如何评价腾讯在unity下的xlua",{"1":{"717":1}}],["如何让ui去准确的盖住场景使用",{"1":{"623":1}}],["如何做到任意一个web服务器",{"1":{"577":1}}],["如何解决",{"0":{"524":1}}],["如何解压exe的程序",{"0":{"437":1}}],["如何发现的",{"0":{"522":1},"2":{"523":1}}],["如何在unity显示线框图",{"1":{"847":1}}],["如何在代码中实现",{"0":{"784":1},"2":{"785":1}}],["如何在",{"0":{"941":1},"1":{"509":1}}],["如何在ts文件中使用三种类库",{"1":{"398":1}}],["如何开酒楼和医院",{"0":{"369":1}}],["如何实现",{"0":{"176":1}}],["如何修改默认语言",{"0":{"157":1}}],["如何给identityuser添加额外的属性",{"0":{"139":1},"2":{"140":1,"141":1,"142":1}}],["如何继承了iupdateuserdata则会更新更新还可以通过eventbus",{"1":{"138":1}}],["如何共用user",{"0":{"138":1}}],["如何为user添加属性",{"1":{"137":1}}],["如何改善游戏体验呢",{"1":{"74":1}}],["如何进行处理呢",{"1":{"74":1}}],["如位置",{"1":{"46":1}}],["如支持ioc",{"1":{"30":1}}],["如此重复把所有变量都放到栈上",{"1":{"885":1}}],["如此一来",{"1":{"119":1,"689":1}}],["如此帧率的时钟在由服务器控制",{"1":{"12":1}}],["如此才能保证帧一致",{"1":{"11":1}}],["如果给这个材质球换了",{"1":{"1036":1}}],["如果频繁的要new一个rt出来",{"1":{"1033":1}}],["如果涉及version",{"1":{"997":1}}],["如果component被写入时的版本号大于该系统上一帧的版本号",{"1":{"991":1}}],["如果cl",{"1":{"84":1}}],["如果場景中其他物件",{"1":{"974":1}}],["如果root",{"1":{"970":2}}],["如果前述的",{"1":{"970":1}}],["如果前面三个条件都已经满足",{"1":{"456":1}}],["如果缺失了",{"1":{"969":1}}],["如果添加cube到飞船的根对象上",{"1":{"968":1}}],["如果添加不存在的组件",{"1":{"946":1}}],["如果人肉单纯修改",{"1":{"944":1}}],["如果人物的攻击范围大小不一",{"1":{"748":1}}],["如果现在检查",{"1":{"943":1}}],["如果和前一次调用一样则无需初始化",{"1":{"940":1}}],["如果实体没有",{"1":{"935":1}}],["如果实体只有",{"1":{"934":1}}],["如果只是",{"1":{"1040":1}}],["如果只是单纯的createsystem",{"1":{"914":1}}],["如果只有",{"1":{"51":2}}],["如果以前的方法不足",{"1":{"912":1}}],["如果关联到我们之前的假设",{"1":{"898":1}}],["如果执行下面代码中的go",{"1":{"892":1}}],["如果执行方法",{"1":{"889":1}}],["如果执行以下命令",{"1":{"443":1}}],["如果方法是第一次被触发",{"1":{"885":1}}],["如果shader中需要使用顶点位置",{"1":{"876":1}}],["如果能在一次drawcall完成所有绘制就会大大提高运行效率",{"1":{"876":1}}],["如果16bit",{"1":{"872":1}}],["如果材质没用到",{"1":{"869":1}}],["如果开启unity会存储两份mesh",{"1":{"869":1}}],["如果时静音模式则销毁audiosourcecomponent组件",{"1":{"867":1}}],["如果中型文件>=200kb",{"1":{"867":1}}],["如果小型文件<200kb",{"1":{"867":1}}],["如果同时用到",{"1":{"861":1}}],["如果同一个网站有多个账号",{"1":{"422":1}}],["如果texture是中心镂空且切图为九宫格时",{"1":{"860":1}}],["如果tick和行为树不一样",{"1":{"277":2}}],["如果可以",{"1":{"860":1}}],["如果可能",{"1":{"831":1}}],["如果可能最好避免在c",{"1":{"818":1}}],["如果可能考虑重用或者缓存分配的容器或者数组",{"1":{"817":1}}],["如果ui元素改变数值或是位置",{"1":{"860":1}}],["如果存在显卡的帧的时候则会显示帧",{"1":{"855":1}}],["如果存在一点颜色为",{"1":{"207":1}}],["如果从应用的角度来看的话",{"1":{"848":1}}],["如果从反方向看的话",{"1":{"846":1}}],["如果双击",{"1":{"847":1}}],["如果双方玩家正在移动",{"1":{"86":1}}],["如果双方都进行转换最后虽然能够正确收发数据",{"1":{"36":1}}],["如果单纯使用顶点来表示",{"1":{"846":1}}],["如果相机的宽高比设置的和屏幕宽高比不一样的话",{"1":{"841":1}}],["如果堆增加到1mb",{"1":{"830":1}}],["如果反复调用",{"1":{"828":1}}],["如果正确使用",{"1":{"828":1}}],["如果对内存块的所有引用都消失了",{"1":{"827":1}}],["如果对象上挂载有",{"1":{"695":1}}],["如果对象b进入对象a的视野范围",{"1":{"102":1}}],["如果内存分配发生在没有交互操作的时候",{"1":{"815":1}}],["如果托管堆扩张收缩多次",{"1":{"814":1}}],["如果垃圾收集器还没有运行",{"1":{"813":1}}],["如果碰撞之后",{"1":{"765":1}}],["如果圆心在矩形的正左右两侧",{"1":{"755":1}}],["如果圆心在矩形的正上下方",{"1":{"755":1}}],["如果圆心在矩形的下方",{"1":{"755":1}}],["如果圆心在矩形的上方",{"1":{"755":1}}],["如果圆心在矩形的右侧",{"1":{"755":1}}],["如果圆心在矩形的左侧",{"1":{"755":1}}],["如果线段中间有物体",{"1":{"751":1}}],["如果直直的往前发射",{"1":{"750":1}}],["如果直接使用上述代码",{"1":{"197":1}}],["如果挥舞速度太快",{"1":{"748":1}}],["如果背景使用的背景贴图只有一张的话",{"1":{"726":1}}],["如果要做一套响应式系统循环触发",{"1":{"997":1}}],["如果要实现一个火球",{"1":{"811":1}}],["如果要从热更dll中调用unity主工程或者unity的接口",{"1":{"718":1}}],["如果要应用到自己的项目中",{"1":{"715":1}}],["如果要进行大规模数据的恢复",{"1":{"441":1}}],["如果通过则返回",{"1":{"715":1}}],["如果程序集被加载到默认应用程序域中",{"1":{"707":1}}],["如果图集是assetbundle包管理的",{"1":{"704":1}}],["如果平时开发enabled",{"1":{"703":1}}],["如果调用",{"1":{"699":1}}],["如果您有兴趣了解更多信息",{"1":{"833":1}}],["如果您需要实例化同一个对象很多次",{"1":{"699":2}}],["如果您在加载时将",{"1":{"699":1}}],["如果您使用",{"1":{"697":1}}],["如果将实体b的renderer组件移除",{"1":{"905":1}}],["如果将其设置为false",{"1":{"699":1}}],["如果将分辨率的宽",{"1":{"625":1}}],["如果指定使用",{"1":{"698":1}}],["如果资源加载成功",{"1":{"697":1}}],["如果组件是实现了",{"1":{"691":1}}],["如果检测结果",{"1":{"689":1}}],["如果找不到可以处理的相应事件则直接返回null",{"1":{"679":1}}],["如果找不到该事件的话就触发pointerclick事件",{"1":{"671":1}}],["如果找不到该用户",{"1":{"138":1}}],["如果找到则返回",{"1":{"679":1}}],["如果handler的数量大于0则返回true",{"1":{"678":1}}],["如果多次点击的话还会增加pointereventdata的clicktime",{"1":{"671":1}}],["如果按下的对象并不是之前hover的对象",{"1":{"671":1}}],["如果他有父节点",{"1":{"657":1}}],["如果他站在原地被你爆头那就是他的问题",{"1":{"79":1}}],["如果两者为同一个gameobject的话就会触发click事件",{"1":{"657":1}}],["如果两向量指向同一方向",{"1":{"197":1}}],["如果此时该接收对象",{"1":{"657":1}}],["如果此时进程有可用的线程",{"1":{"167":1}}],["如果想查询给定的一组component类型的所有实体",{"1":{"905":1}}],["如果想在z轴移动相机",{"1":{"737":1}}],["如果想测试spritepacker是否生效以及代码相关",{"1":{"703":1}}],["如果想要获取一个recttransform的矩形信息",{"1":{"642":1}}],["如果想跟好朋友分享某个生成结果比较好的地图",{"1":{"214":1}}],["如果采用宽进行匹配那么可以通过公式计算出此时应该缩放多少倍",{"1":{"628":1}}],["如果采用固定更新间隔",{"1":{"50":1}}],["如果提示的id的是editor的",{"1":{"601":1}}],["如果提交的时候仍有问题",{"1":{"417":1}}],["如果仅通过反射将某个类型或方法作为序列化或反序列化的一部分使用",{"1":{"598":1}}],["如果仅指定",{"1":{"153":1}}],["如果目标商店不支持android",{"1":{"586":1}}],["如果选择build",{"1":{"585":3}}],["如果打开了全屏ui",{"1":{"860":2}}],["如果打开另一个应用程序域来加载和执行程序集",{"1":{"707":1}}],["如果打开sv",{"1":{"83":1}}],["如果打包出来的插件的体积过大",{"1":{"538":1}}],["如果大家在打包",{"1":{"538":1}}],["如果配置文件位于项目文件夹中",{"1":{"524":1}}],["如果",{"1":{"445":1,"524":1,"687":1,"688":1,"689":2,"694":1,"721":1,"780":1,"813":1,"952":1,"1039":2,"1040":1}}],["如果设置成0的话",{"1":{"867":1}}],["如果设置了",{"1":{"693":1}}],["如果设定的",{"1":{"443":1}}],["如果设计的好的话",{"1":{"225":1}}],["如果数据集庞大",{"1":{"442":1}}],["如果数据库后端无法处理",{"1":{"88":1}}],["如果重新安装系统",{"1":{"428":1}}],["如果都是蓝的就表",{"1":{"373":1}}],["如果用户删除",{"1":{"935":1}}],["如果用户添加",{"1":{"934":1}}],["如果用户操作的不是当前的",{"1":{"688":1}}],["如果用户要求更新20次每秒",{"1":{"50":1}}],["如果用收学费的",{"1":{"373":1}}],["如果很在意想让弟子每天绿脸的话",{"1":{"373":1}}],["如果收学费制的话",{"1":{"372":1}}],["如果收到的",{"1":{"12":1}}],["如果等候时间到了",{"1":{"369":1}}],["如果等候区满了",{"1":{"369":1}}],["如果满足",{"1":{"283":1}}],["如果使用了localtoparent",{"1":{"1053":1}}],["如果使用了服务器校对不补偿也并没有什么太大的问题",{"1":{"57":1}}],["如果使用引用类型",{"1":{"892":1}}],["如果使用的游戏引擎没有场景管理器或是场景管理器性能不佳的情况下",{"1":{"728":1}}],["如果使用的是",{"1":{"722":1}}],["如果使用",{"1":{"280":1,"954":1}}],["如果getupdate",{"1":{"277":1}}],["如果onupdate",{"1":{"277":1}}],["如果oldaoi",{"1":{"103":2}}],["如果子节点中有",{"1":{"277":1}}],["如果怪物c的tc为67",{"1":{"275":1}}],["如果怪物b的tc为57",{"1":{"275":1}}],["如果物品成色被判定为绿色",{"1":{"275":1}}],["如果物品成色被判定为暗金",{"1":{"275":1}}],["如果进入地图",{"1":{"260":1}}],["如果条件满足直接触发任务",{"1":{"252":1}}],["如果包含则检查失败",{"1":{"240":1}}],["如果后面的会覆盖前面的最终的合成则是下图",{"1":{"230":1}}],["如果运气不好",{"1":{"225":1}}],["如果运行时",{"1":{"847":1}}],["如果运行的中途发生停机",{"1":{"451":1}}],["如果运行出现了问题",{"1":{"88":1}}],["如果运行良好",{"1":{"88":1}}],["如果到了底部这一行",{"1":{"224":1}}],["如果放了某个物品到地图上的某个空间",{"1":{"218":1}}],["如果发现当前节点在根节点",{"1":{"210":1}}],["如果更新中发现某相邻点可选瓦片为空",{"1":{"210":1}}],["如果为0的时候",{"1":{"161":1}}],["如果当前",{"1":{"684":1}}],["如果当前请求数已经达到最大可接受连接数",{"1":{"167":1}}],["如果当前线程的区域性设置为",{"1":{"155":1}}],["如果当前平台是小端",{"1":{"36":1}}],["如果当前平台是大端",{"1":{"36":1}}],["如果已经有其他线程则等待",{"1":{"131":1}}],["如果已经有同一个线程进去则把计数器加1",{"1":{"131":1}}],["如果非托管代码需要进行内存管理等服务",{"1":{"127":1}}],["如果创建项目文件",{"1":{"125":1}}],["如果我添加",{"1":{"968":1}}],["如果我添加了一个",{"1":{"965":1,"1003":1}}],["如果我用transform",{"1":{"968":1}}],["如果我",{"1":{"966":1}}],["如果我有一个gameobject",{"1":{"962":1}}],["如果我把模式切回",{"1":{"956":1}}],["如果我不销毁掉原对象",{"1":{"951":1}}],["如果我修改一下",{"1":{"951":1}}],["如果我是地下城的一个居民",{"1":{"219":1}}],["如果我只有几个",{"1":{"125":1}}],["如果我们在排气孔位置增加一个粒子效果对象",{"1":{"968":1}}],["如果我们在别处",{"1":{"954":1}}],["如果我们",{"1":{"965":1}}],["如果我们有两个存储在同样的内存块中的两个实体",{"1":{"929":1}}],["如果我们有一个非常庞大的值类型",{"1":{"891":1}}],["如果我们给一个内存块",{"1":{"927":1}}],["如果我们负责",{"1":{"898":1}}],["如果我们回头去看上面的图解中",{"1":{"898":1}}],["如果我们把shoe换成引用类型呢",{"1":{"895":1}}],["如果我们把appsettings",{"1":{"172":1}}],["如果我们不是用ref传递的",{"1":{"893":1}}],["如果我们用引用的方式传递一个引用类型变量呢",{"1":{"892":1}}],["如果我们需要渲染一千个三角形",{"1":{"876":1}}],["如果我们选择等待垂直同步信号",{"1":{"854":1}}],["如果我们的ui编写当中遇到了问题",{"1":{"682":1}}],["如果我们要保存这个列表的当前状态",{"1":{"454":1}}],["如果我们要生成蛇窝的话",{"1":{"224":1}}],["如果我们打到了一个白色",{"1":{"273":1}}],["如果我们向左或右移动",{"1":{"224":1}}],["如果我们只插值上一个位置",{"1":{"46":1}}],["如果我们以这种方法封装状态数据",{"1":{"45":1}}],["如果判断该对象是否需要被回收的依据是基于引用计数的",{"1":{"124":1}}],["如果一列中有3或者4个room",{"1":{"224":1}}],["如果一直没有找到大于的节点",{"1":{"108":1}}],["如果一个实体要被移出当前原型的内存块",{"1":{"905":1}}],["如果一个块的内存满了",{"1":{"905":1}}],["如果一个值类型不是在方法中定义的",{"1":{"886":1}}],["如果一个项目想要在il2cpp脚本后端上发布",{"1":{"819":1}}],["如果一个程序员想要重用这段代码",{"1":{"818":1}}],["如果一个程序每帧分配1kb的临时内存",{"1":{"815":1}}],["如果一个程序可用内存的地址空间",{"1":{"814":1}}],["如果一个大的对象被分配",{"1":{"813":1}}],["如果一个顺序节点具有原子属性",{"1":{"795":1}}],["如果一个物体没有父节点的话",{"1":{"657":1}}],["如果一个物体相对于屏幕位置左上角",{"1":{"625":1}}],["如果一个对象的counter变为0",{"1":{"115":1}}],["如果一个对象增加了一个引用与之相连",{"1":{"115":1}}],["如果一个引用关系失效则counter",{"1":{"115":1}}],["如果一个延时比较大的玩家击中一个延时比较小的玩家并且得到一分",{"1":{"48":1}}],["如果一个更新包没有收到",{"1":{"46":1}}],["如果每次都需要从头部开始查找效率就很低",{"1":{"106":1}}],["如果是手动选择了",{"1":{"1037":1}}],["如果是",{"1":{"940":2,"1037":1}}],["如果是使用了模拟器",{"1":{"852":1}}],["如果是右手",{"1":{"840":1}}],["如果是左手",{"1":{"840":1}}],["如果是动作游戏",{"1":{"750":1}}],["如果是3d",{"1":{"724":1}}],["如果是3d就用physics3draycaster",{"1":{"663":1}}],["如果是在",{"1":{"625":1}}],["如果是在land中",{"1":{"264":1}}],["如果是uwsgi+app",{"1":{"580":1}}],["如果是nginx+uwsgi+app",{"1":{"580":1}}],["如果是生成512",{"1":{"568":1}}],["如果是的话",{"1":{"456":1}}],["如果是分舵主殿要12000肉8000木",{"1":{"376":1}}],["如果是高于25级怪物掉落的",{"1":{"269":1}}],["如果是指定目标则检查目标身上是否能够匹配",{"1":{"239":1}}],["如果是25级以下怪物掉落的",{"1":{"269":1}}],["如果是2",{"1":{"224":1}}],["如果是三维地图",{"1":{"106":1}}],["如果是这样",{"1":{"50":1}}],["如果节点较少就会出现节点分布不均衡造成数据倾斜问题",{"1":{"96":1}}],["如果新增一台服务器",{"1":{"91":1}}],["如果部署期间",{"1":{"89":1}}],["如果需要发起射线检测",{"1":{"695":1}}],["如果需要触发事件就调用该方法吧",{"1":{"678":1}}],["如果需要",{"1":{"657":1}}],["如果需要管理的坐标少还可以",{"1":{"106":1}}],["如果需要回滚",{"1":{"89":1}}],["如果需要在不同的帧之间切换",{"1":{"15":1}}],["如果切换后出现问题",{"1":{"88":1}}],["如果出错并不影响生产环境的服务",{"1":{"88":1}}],["如果测试没问题",{"1":{"88":1}}],["如果游戏中不是所有人物模型都是标准的人型呢",{"1":{"848":1}}],["如果游戏服务器使用较高tickrate运行时",{"1":{"86":1}}],["如果游戏世界的确定性足够",{"1":{"67":1}}],["如果它们是不同的",{"1":{"84":1}}],["如果它以每秒100米的速度行驶",{"1":{"75":1}}],["如果连续多个快照丢失",{"1":{"83":1}}],["如果快照342由于丢包缺失",{"1":{"83":1}}],["如果世界中的对象",{"1":{"83":1}}],["如果不想转换可以在code",{"1":{"1016":1}}],["如果不开启static",{"1":{"979":1}}],["如果不需要使用mipmaps",{"1":{"872":1}}],["如果不需要立体声",{"1":{"867":1}}],["如果不需要噪声重复",{"1":{"201":1}}],["如果不存在的话那就查看是否存在drag事件并且执行",{"1":{"672":1}}],["如果不在则进行手动添加如果使用的是sourcetree",{"1":{"417":1}}],["如果不满足",{"1":{"283":3}}],["如果不同的职业技能都能升级到20级",{"0":{"251":1}}],["如果不为空",{"1":{"210":1}}],["如果不合适接着考虑ioptionssnapshot<>",{"1":{"174":1}}],["如果不进行视野管理",{"1":{"97":1}}],["如果不是这种方法",{"1":{"76":1}}],["如果不一样",{"1":{"15":1}}],["如果玩家不在附近则stop",{"1":{"283":1}}],["如果玩家撞到什么东西",{"1":{"75":1}}],["如果玩家把车保持在直线上",{"1":{"75":1}}],["如果在使用",{"1":{"979":1}}],["如果在",{"1":{"965":1}}],["如果在项目中启用了physics",{"1":{"868":1}}],["如果在一个繁重的资源加载过程中生成了大量的临时对象",{"1":{"815":1}}],["如果在意这一点的话可以自己对matcher进行缓存",{"1":{"739":1}}],["如果在ios上实际运行遇到报错",{"1":{"600":1}}],["如果在运行时无法通过jit来创建新类型的话",{"1":{"599":1}}],["如果在情况",{"1":{"449":2}}],["如果在还没有触发快照时",{"1":{"442":1}}],["如果在蓝绿部署中协调不好这两者",{"1":{"88":1}}],["如果在客户端进行命中检查",{"1":{"85":1}}],["如果在执行用户的命令",{"1":{"85":1}}],["如果在游戏过程中发现有网络波动过大的情况",{"1":{"51":1}}],["如果在定时任务处理方面没有很高的要求",{"1":{"30":1}}],["如果激活了带宽限制",{"1":{"50":1}}],["如果带宽不够",{"1":{"50":1}}],["如果这些类型的数据被定期复制",{"1":{"826":1}}],["如果这些命令在客户端第一次执行",{"1":{"43":1}}],["如果这么做了",{"1":{"737":1}}],["如果这样被频繁操作的键有很多的话",{"1":{"453":1}}],["如果这个使用手动操作的话",{"1":{"510":1}}],["如果这个待确定的空间包含有除了土之外的内容",{"1":{"220":1}}],["如果这个对你很重要",{"1":{"174":1}}],["如果这个值大于",{"1":{"50":1}}],["如果高延迟玩家延迟比较大",{"1":{"48":1}}],["如果偶尔发生丢包",{"1":{"46":1}}],["如果计算得到的目标时间在上一个更新时间和上上个更新时间之间",{"1":{"46":1}}],["如果服务启动成功",{"1":{"475":1}}],["如果服务器对集合键",{"1":{"454":1}}],["如果服务器对键",{"1":{"454":1}}],["如果服务器执行了以下命令",{"1":{"453":1}}],["如果服务器的数据更新发送频率超过了客户端的带宽处理限制",{"1":{"82":1}}],["如果服务器每秒同步10次世界信息",{"1":{"46":1}}],["如果服务端每收到某个玩家的一条指令",{"1":{"73":1}}],["如果服务确认的操作",{"1":{"15":1}}],["如果别的玩家因为外推错误",{"1":{"46":1}}],["如果延迟也不断变化",{"1":{"45":1}}],["如果延迟比较大",{"1":{"45":1}}],["如果客户端和服务器没有足够cpu和网络资源",{"1":{"87":1}}],["如果客户端渲染延迟50毫秒",{"1":{"83":1}}],["如果客户端帧率比服务器更新频率大",{"1":{"46":1}}],["如果客户端可信的话",{"1":{"45":1}}],["如果客户端跟服务器有500ms的延迟",{"1":{"42":1}}],["如果没有用到blendshapes",{"1":{"869":1}}],["如果没有使用动画",{"1":{"869":1}}],["如果没有任何ui在它的底下",{"1":{"862":1}}],["如果没有它",{"1":{"722":1}}],["如果没有会自动添加",{"1":{"663":1}}],["如果没有在自身上找到的话",{"1":{"657":1}}],["如果没有则会将其创建",{"1":{"505":1}}],["如果没有",{"1":{"373":1,"398":1,"657":1,"715":1}}],["如果没有床npc固定时间没有接待则走人",{"1":{"369":1}}],["如果没有包含则检查失败",{"1":{"240":1}}],["如果没有新的节点可以选择",{"1":{"210":1}}],["如果没有非空的",{"1":{"151":1}}],["如果没有这种类型的数据",{"1":{"43":1}}],["如果没有快照",{"1":{"15":1}}],["如果网络有延迟",{"1":{"43":1}}],["如果帧率恒定",{"1":{"41":1}}],["如果你点击",{"1":{"971":1}}],["如果你添加一个",{"1":{"964":1}}],["如果你添加更多的方块",{"1":{"945":1}}],["如果你调用getprimaryentity",{"1":{"964":1}}],["如果你有更多的",{"1":{"952":1}}],["如果你有一个关联",{"1":{"942":1}}],["如果你不喜欢声明和创建",{"1":{"970":1}}],["如果你不清楚",{"1":{"966":1}}],["如果你不这样做",{"1":{"964":1}}],["如果你不想要默认的行为",{"1":{"951":1}}],["如果你不需要支持上面的场景",{"1":{"174":1}}],["如果你在",{"1":{"971":1}}],["如果你在这个conversion过程之中试图添加",{"1":{"964":1}}],["如果你在主线程中等待job执行完毕",{"1":{"924":1}}],["如果你在类中增",{"1":{"111":1}}],["如果你没有指定顺序",{"1":{"917":1}}],["如果你修改了共享组件中的数据",{"1":{"905":1}}],["如果你修改了实体的组件",{"1":{"905":1}}],["如果你需要该",{"1":{"959":1,"1002":1}}],["如果你需要连接多个字符串",{"1":{"828":1}}],["如果你需要迁移环境",{"1":{"481":1}}],["如果你记录了哪个轴上的投影重叠值最小",{"1":{"784":1}}],["如果你检测完每条边后",{"1":{"784":1}}],["如果你发现了这两个投影到轴上的",{"1":{"784":1}}],["如果你找到了一个间隙",{"1":{"783":1}}],["如果你用这个方式从每一个角度上对这两个图形进行处理",{"1":{"783":1}}],["如果你用到的话",{"1":{"607":1}}],["如果你用c",{"1":{"34":1}}],["如果你对我刚才说的这些有兴趣",{"1":{"594":1}}],["如果你还保持着一颗好奇的心",{"1":{"592":1}}],["如果你已经安装了任意版本的idea",{"1":{"554":1}}],["如果你是一个前端项目",{"1":{"508":1}}],["如果你是在app启动的时候自己构造options",{"1":{"174":1}}],["如果你使用的是",{"1":{"411":2}}],["如果你依赖配置文件",{"1":{"174":1}}],["如果你增加快照率遇到",{"1":{"86":1}}],["如果你的着色器需要使用顶点位置",{"1":{"980":1}}],["如果你的着色器使用顶点位置",{"1":{"980":1}}],["如果你的",{"1":{"942":1,"965":1}}],["如果你的游戏跑到60帧",{"1":{"855":1}}],["如果你的电脑上装有cs",{"1":{"854":1}}],["如果你的代码没有性能问题推荐使用",{"1":{"180":1}}],["如果你的托管代码调用特定于平台的本机",{"1":{"129":1}}],["如果你的角色在",{"1":{"67":1}}],["如果你的程序要跟别人的程序产生交互呢",{"1":{"34":1}}],["如果你开发的是一个坦克游戏",{"1":{"48":1}}],["如果你射击一个玩家",{"1":{"45":1}}],["如果你写的程序只在单机环境下面运行",{"1":{"34":1}}],["如果去处理快照",{"1":{"15":1}}],["如果有一个ui在其底下但是无法与它batch",{"1":{"862":1}}],["如果有一个ui在其底下且该ui可以和它batch",{"1":{"862":1}}],["如果有一个ui元素",{"1":{"862":1}}],["如果有个静态的ui",{"1":{"860":1}}],["如果有",{"1":{"795":1}}],["如果有静态构造函数",{"1":{"715":1}}],["如果有相对应的处理方法iinitializepotentialdraghandler的话就一起触发",{"1":{"671":1}}],["如果有的的话",{"1":{"657":1}}],["如果有的话紧接着便会去触发onpointerdown和ondrag方法",{"1":{"657":1}}],["如果有的话",{"1":{"266":1,"855":1}}],["如果有的话检查是否变成可接状态questindicatormanager不是单例相当于控制器",{"1":{"252":1}}],["如果有的话继续",{"1":{"220":1}}],["如果有实现了的就把newpressed赋值为这个控件的gameobject",{"1":{"657":1}}],["如果有登录账号",{"1":{"562":1}}],["如果有练防3盘防守招",{"1":{"377":1}}],["如果有任何失败了将会reset并行需要等待子节点全部完成",{"1":{"280":1}}],["如果有任务",{"1":{"255":1}}],["如果有对话",{"1":{"255":1}}],["如果有2号room在上方",{"1":{"224":1}}],["如果有多个ui都在其下面",{"1":{"862":1}}],["如果有多个的话",{"1":{"220":1}}],["如果有多个玩家在一起玩",{"1":{"73":1}}],["如果有良好的带宽和cpu可用",{"1":{"82":1}}],["如果有作弊的客户端发送无用的消息",{"1":{"67":1}}],["如果有些逻辑是纯客户端的",{"1":{"43":1}}],["如果有玩家网络延迟",{"1":{"12":1}}],["如果有人延迟比较高",{"1":{"11":1}}],["如果a服务器一直没有输入同步过来",{"1":{"12":1}}],["如今包括王者荣耀",{"1":{"12":1}}],["才看renderqueue的高低",{"1":{"976":1}}],["才可以绘制",{"1":{"854":1}}],["才可以进行计算",{"1":{"11":1}}],["才能正常工作",{"1":{"958":1,"1001":1}}],["才能正确的得到需要的gameobject",{"1":{"699":1}}],["才能正确被检测到",{"1":{"664":1}}],["才能基于此构建出整个层级树",{"1":{"952":1}}],["才能使得游戏进程和显示器刷新率同步",{"1":{"854":1}}],["才能继续处理请求",{"1":{"451":1}}],["才能执行你需要的操作~",{"1":{"1":1}}],["才都玩不起来",{"1":{"376":1}}],["才特别编排武场2点",{"1":{"375":1}}],["才会调用其",{"1":{"690":1}}],["才会执行下一个tick",{"1":{"278":1}}],["才会处理下一个请求",{"1":{"158":1}}],["才一定能获得一个结果",{"1":{"207":1}}],["只支持一盏实时光",{"1":{"981":1}}],["只不过针对的是",{"1":{"970":1}}],["只不过这些对象使用了hideflags",{"1":{"969":1}}],["只不过这时候不能使用",{"1":{"955":1}}],["只不过修改了一下转换相关的代码",{"1":{"969":1}}],["只不过你无法在",{"1":{"946":1}}],["只使用",{"1":{"942":1}}],["只储存数据",{"1":{"927":1}}],["只选择拥有特定值的share",{"1":{"910":1}}],["只选择子上次",{"1":{"910":1}}],["只在运行开始阶段",{"1":{"876":1}}],["只在运行时改变程序集行为",{"1":{"717":1}}],["只占用几个字节的数据类型可以非常快速方便地复制",{"1":{"826":1}}],["只与旋转前的坐标",{"1":{"756":1}}],["只用来标记的",{"1":{"927":1}}],["只用了透视相机来创建",{"1":{"737":1}}],["只用于演示",{"1":{"131":1}}],["只丢失",{"1":{"449":1}}],["只看红剑图示",{"1":{"377":1}}],["只准悬挂一种许可证",{"1":{"369":1}}],["只运行ai的npc",{"0":{"260":1}}],["只能切换到延迟渲染路径",{"1":{"981":1}}],["只能在主线程中调用",{"1":{"921":1}}],["只能在当前范围",{"1":{"174":1}}],["只能舍弃一部分画面",{"1":{"854":1}}],["只能结束",{"1":{"835":1}}],["只能挂buff",{"1":{"799":1}}],["只能说明你是特别厉害的狙击手",{"1":{"79":1}}],["只需处理一个就行了",{"1":{"599":1}}],["只需使用msbuild的详细程度开关即可",{"1":{"125":1}}],["只需要",{"1":{"955":1}}],["只需要添加更多",{"1":{"945":1}}],["只需要用",{"1":{"941":1}}],["只需要几行代码就能实现",{"1":{"916":1}}],["只需要传一张大图就可以了",{"1":{"861":1}}],["只需要在这些原型中搜索即可",{"1":{"905":1}}],["只需要在主端确保技能流程无误即可后来这里进行了进一步的优化",{"1":{"805":1}}],["只需要在客户端和服务器使用的命令里面加上玩家开火的按键信息",{"1":{"44":1}}],["只需要判断敌人和skillposition之间的距离是否小于半径即可",{"1":{"776":1}}],["只需要将shime路径添加到环境变量path中使用第二种方法",{"1":{"428":1}}],["只需要编辑下即可",{"1":{"420":1}}],["只需要共享",{"1":{"214":1}}],["只需要沿着这log向前恢复就可以",{"1":{"210":1}}],["只需要封装在一个包含几个关键成员的结构中",{"1":{"42":1}}],["只需要跳转即可",{"1":{"15":1}}],["只考虑了起点和终点",{"1":{"104":1}}],["只会在所有",{"1":{"936":1}}],["只会在以下任意一种情况中被执行",{"1":{"448":1}}],["只会触发一次事件",{"1":{"655":1}}],["只会让用户访问active的服务器集群",{"1":{"88":1}}],["只会感觉自己操作延迟而已",{"1":{"12":1}}],["只做1",{"1":{"51":1}}],["只要物体的",{"1":{"982":1}}],["只要在",{"1":{"965":1}}],["只要在该对象加上一个eventtrigger起就可以了",{"1":{"657":1}}],["只要检测到",{"1":{"958":1,"1001":1}}],["只要你将",{"1":{"941":1}}],["只要你创建好地图就可以去做到",{"1":{"220":1}}],["只要减少创建和销毁对象的数量",{"1":{"832":1}}],["只要还存在可以找到它的引用变量",{"1":{"827":1}}],["只要运行时系统能够定位指针标识的项",{"1":{"826":1}}],["只要间隙一旦被检测出来",{"1":{"787":1}}],["只要我们设定mono的编译模式为full",{"1":{"709":1}}],["只要精灵打包到任何精灵图集内",{"1":{"705":1}}],["只要编译器可以推断通过反射使用的代码需要在运行时存在",{"1":{"597":1}}],["只要web服务器和web框架满足wsgi协议",{"1":{"577":1}}],["只要有",{"1":{"564":1}}],["只要根据",{"1":{"452":1}}],["只要能让双方的友好度保持在40以上",{"1":{"383":1}}],["只要找好地点",{"1":{"380":1}}],["只要给他领悟後",{"1":{"372":1}}],["只要是涉及到的对象不能从gc",{"1":{"124":1}}],["只要移动堆顶指针",{"1":{"120":1}}],["只要老版本的资源不被删除",{"1":{"88":1}}],["只要用户愿意",{"1":{"46":1}}],["只要涂抹为黑白就可以",{"1":{"0":1}}],["只同步怪物在攻击哪个玩家",{"1":{"19":1}}],["只是存放的值既不是内存地址也不是空null",{"1":{"883":1}}],["只是为了让大家区分堆和栈",{"1":{"879":1}}],["只是它是用来保存信息而不是跟踪执行",{"1":{"879":1}}],["只是接受播放动作",{"1":{"805":1}}],["只是起展示作用",{"1":{"759":1}}],["只是适用条件有限",{"1":{"748":1}}],["只是取其名字意思",{"1":{"718":1}}],["只是取其名字意思来表示",{"1":{"711":1}}],["只是限定了对象的边界",{"1":{"707":1}}],["只是在此模式下会保证设计分辨率下的东西能够全部显示出来",{"1":{"628":1}}],["只是用来告诉il2cpp我们需要这个方法",{"1":{"600":1}}],["只是一个协议规范",{"1":{"576":1}}],["只是直到今天才有了一个比较霸气的名字而已",{"1":{"206":1}}],["只是通过",{"1":{"155":1}}],["只是少了入口函数",{"1":{"131":1}}],["只是增加了虚拟节点到实际节点的映射",{"1":{"96":1}}],["只是使用服务器传来的数据",{"1":{"77":1}}],["只是有100ms的延迟",{"1":{"76":1,"1015":1}}],["只是实际的导弹不进行延迟补偿",{"1":{"50":1}}],["只是客户端稍微晚一点",{"1":{"50":1}}],["只是view层面的预测",{"1":{"15":1}}],["只是借鉴了帧的概念",{"1":{"11":1}}],["只有被转换的才会被传输",{"1":{"1016":1}}],["只有被指名要求删除的时候才会被删除",{"1":{"986":1}}],["只有在sortinglayer相同的前提下",{"1":{"976":1}}],["只有在从",{"1":{"965":1}}],["只有在场景切换时进行调用此段文字有些绕口",{"1":{"701":1}}],["只有内存块中对应的原型会修改",{"1":{"927":1}}],["只有等75单位的信号到达",{"1":{"854":1}}],["只有指针在参数传递过程中需要被复制",{"1":{"826":1}}],["只有全部子节点执行结束才可以end",{"1":{"795":1}}],["只有第一次会遍历所有的entity生成这个group",{"1":{"738":1}}],["只有基于唯一的appdomain实例",{"1":{"714":1}}],["只有gac代码是共享的",{"1":{"707":1}}],["只有打包的时候才构建",{"1":{"703":1}}],["只有所有的资源均不再使用时才会正确的卸载掉assetbundle",{"1":{"701":1}}],["只有assetbundle中的任何资源都不再被使用时",{"1":{"701":1}}],["只有最后的写入缓存和改名操作会造成主进程阻塞",{"1":{"455":1}}],["只有和数据库无关的订阅与发布功能可以正常使用",{"1":{"452":1}}],["只有两盘的话封印会有一盘没效用",{"1":{"377":1}}],["只有自己产地没有生产的才不打开设定",{"1":{"376":1}}],["只有自己理顺逻辑来做了",{"1":{"15":1}}],["只有6个人的话",{"1":{"375":1}}],["只有当分数变化时才更新文本",{"1":{"828":1}}],["只有当列表需要被扩大时内存才会被分配",{"1":{"817":1}}],["只有当对象上有",{"1":{"661":1}}],["只有当有任务失败或者成功",{"1":{"278":1}}],["只有当我们搜索了所有的可能性时",{"1":{"207":1}}],["只有10",{"1":{"120":1}}],["只有客户端才有的一些数据",{"1":{"43":1}}],["只有2~3帧",{"1":{"15":1}}],["只有俩",{"1":{"12":1}}],["l5paffav8co4xw",{"1":{"984":1}}],["lzhq1982",{"1":{"984":1}}],["ltw",{"1":{"945":1,"951":1}}],["lts",{"1":{"585":1}}],["ltsb",{"1":{"533":1}}],["ldloc",{"1":{"823":3}}],["ldloca",{"1":{"823":2}}],["ldfld",{"1":{"823":1}}],["ldarg",{"1":{"823":1}}],["ldc",{"1":{"823":1}}],["lua",{"1":{"580":1}}],["lunet",{"1":{"147":1}}],["lsv",{"1":{"991":1,"992":2}}],["ls",{"1":{"424":5}}],["lsb",{"1":{"32":1}}],["legacy",{"1":{"845":1}}],["level的设置",{"1":{"868":1}}],["level",{"1":{"721":1}}],["level下的子对象设置为0",{"1":{"228":1}}],["leveldescription",{"1":{"228":1}}],["left",{"1":{"193":1,"633":2,"635":2,"637":1}}],["leak",{"1":{"1021":1}}],["leaks",{"1":{"193":1}}],["learnopengl",{"1":{"850":1}}],["leave",{"1":{"103":1,"104":2,"105":1,"823":1}}],["leaveenter",{"1":{"103":1}}],["length",{"1":{"189":1,"824":3}}],["less",{"1":{"188":1,"189":2,"191":1}}],["let",{"1":{"25":1,"196":1}}],["l",{"1":{"103":2,"225":1}}],["l=c",{"1":{"81":2}}],["loadscene",{"1":{"971":2}}],["loadasset",{"1":{"903":1}}],["load",{"1":{"571":1,"705":1,"708":2,"867":4}}],["loaderoptimization属性可以设置三个不同的枚举值",{"1":{"707":1}}],["loader加载pe文件并解析",{"1":{"131":1}}],["loader已经可以判断出这个pe是否包含clr头来决定是否运行mscoree",{"1":{"131":1}}],["lowvram和medvram",{"1":{"570":1}}],["lower",{"1":{"195":1,"283":6}}],["loser",{"1":{"196":1}}],["long",{"1":{"190":1,"193":1,"575":1,"881":1}}],["lot",{"1":{"188":1,"189":1,"193":1}}],["log",{"1":{"997":1}}],["log的东西",{"1":{"210":1}}],["login",{"1":{"181":1}}],["logging",{"1":{"27":1}}],["logger",{"1":{"24":1}}],["locations",{"1":{"527":1}}],["location",{"1":{"526":1}}],["localtoparent组件",{"1":{"1053":1}}],["localtoworld是一个矩阵如果人肉单纯修改",{"1":{"1000":1}}],["localtoworld了",{"1":{"944":1}}],["localtoworld",{"1":{"944":3,"968":1,"971":1,"1000":3,"1053":1}}],["locals",{"1":{"823":1}}],["local",{"0":{"1011":1},"1":{"421":1,"467":4,"497":1,"526":1,"649":2,"707":1}}],["localhost",{"1":{"152":2,"506":1}}],["localhost使用的是开发证书",{"1":{"135":1}}],["lock时同样改变标识位",{"1":{"131":1}}],["lock时用到",{"1":{"131":1}}],["lockstep的游戏是严格按照turn向前推进的",{"1":{"11":1}}],["lock",{"0":{"11":1},"1":{"12":2}}],["loop",{"1":{"27":1}}],["looks",{"1":{"188":1}}],["looking",{"1":{"186":1,"196":1}}],["look",{"1":{"23":1,"191":1,"192":1,"193":1,"196":1}}],["ll",{"1":{"22":1,"26":2,"27":2,"28":2,"29":1,"896":1}}],["lambda",{"1":{"944":1,"966":1}}],["label",{"1":{"901":1}}],["layer2",{"1":{"1039":2}}],["layer3",{"1":{"1039":1}}],["layers新建layer命名为minimap",{"1":{"1034":1}}],["layer=0",{"1":{"976":1}}],["layer=default",{"1":{"976":1}}],["layerprojectiondepth",{"1":{"737":1}}],["layer",{"1":{"571":2,"684":2,"687":1,"689":1,"695":2,"868":1,"975":9,"976":4,"977":2,"978":4}}],["layout",{"1":{"187":1,"499":2,"651":1}}],["launch",{"1":{"569":1}}],["lastsystemversion取得",{"1":{"993":1}}],["lastsystemversion为系统记录自己的版本号",{"1":{"991":1}}],["last",{"1":{"187":1,"193":1}}],["langcode",{"1":{"153":2}}],["langs",{"1":{"146":1}}],["language",{"1":{"131":1}}],["languages",{"1":{"126":1}}],["landing",{"1":{"225":1}}],["land的边长为land",{"1":{"101":1}}],["land的边长是2的整数次幂",{"1":{"100":1}}],["land进一步被划分为若干个patch",{"1":{"100":1}}],["land",{"0":{"99":1}}],["lag",{"1":{"81":1}}],["latest下载安装完后可以通过命令进行查看是否生效",{"1":{"415":1}}],["latest",{"1":{"132":1,"140":1,"147":1,"942":1}}],["later",{"1":{"27":1}}],["latency",{"1":{"15":2,"50":1}}],["large",{"1":{"22":1,"195":1}}],["light产生多余的模型提交和绘制",{"1":{"980":1}}],["lightmap的偏移和缩放系数等",{"1":{"979":1,"980":1}}],["lightmapindex",{"1":{"849":1,"981":1,"982":2}}],["lightmap",{"1":{"845":1}}],["list`1",{"1":{"823":5}}],["listofnumbers",{"1":{"818":4}}],["lists",{"1":{"486":1}}],["list",{"1":{"486":1,"571":1,"817":6,"818":2,"823":1,"864":1,"964":2}}],["listed",{"1":{"27":1}}],["libil2cpp目录中",{"1":{"591":1}}],["libil2cpp",{"1":{"591":1}}],["libraries",{"1":{"591":1}}],["lib",{"1":{"399":1,"400":1,"401":1,"722":1}}],["libs文件夹中",{"1":{"134":1}}],["linecast每一帧都会进行判定",{"1":{"751":1}}],["linecast",{"1":{"751":2}}],["line",{"1":{"184":1,"190":1}}],["linkedentitygroup和prefab",{"1":{"966":1}}],["linkedentitygroup即可",{"1":{"965":1}}],["linkedentitygroup如下所示的",{"1":{"965":1}}],["linkedentitygroup",{"0":{"958":1,"1001":1,"1003":1,"1004":1},"1":{"965":4,"1002":1,"1003":1,"1004":1,"1053":1}}],["linked",{"0":{"963":1},"1":{"471":1,"960":1,"963":1}}],["link",{"1":{"81":1,"412":1,"604":1,"963":1,"965":2,"970":1,"971":1}}],["linux则需要用到特定的文本编辑器",{"1":{"569":1}}],["linux标准安装方式",{"0":{"547":1}}],["linux环境",{"0":{"494":1}}],["linux系统的大多数服务器就是通过守护进程实现的",{"1":{"3":1}}],["linux",{"0":{"520":1},"1":{"3":1,"524":3,"720":3}}],["lives",{"1":{"193":1}}],["live",{"1":{"81":1,"575":1,"963":1,"965":2,"970":1,"971":5}}],["life引擎的游戏用户消息都很简单",{"1":{"42":1}}],["lifetime",{"1":{"22":1}}],["little",{"1":{"28":2,"32":1,"33":2,"38":1,"188":1,"189":1,"190":1,"192":1}}],["likely",{"1":{"196":1}}],["like",{"1":{"23":1,"26":1,"27":1,"28":1,"186":1,"188":1,"190":1,"192":1}}],["likec",{"1":{"10":1}}],["f",{"1":{"952":3}}],["fpm有更好的状态输出和slowlog日志",{"1":{"576":1}}],["fpm还可以平滑的重载php配置",{"1":{"576":1}}],["fpm能根据访问的压力动态的唤起cgi进程和销毁以到达动态的调整cgi数量",{"1":{"576":1}}],["fpm全称是php",{"1":{"576":1}}],["fpm",{"0":{"576":1},"1":{"576":4}}],["float",{"1":{"824":2,"881":1}}],["float32",{"1":{"571":2}}],["flags",{"1":{"737":3,"975":1}}],["flask框架都有自己实现的简单的wsgi",{"1":{"578":1}}],["flask是实现了wsgi",{"1":{"578":1}}],["flask",{"1":{"577":1,"578":1}}],["flexible",{"1":{"405":1}}],["flex",{"0":{"405":1},"1":{"405":4,"406":5}}],["flipping",{"1":{"202":1}}],["fulfils",{"1":{"195":1}}],["full和no",{"1":{"570":1}}],["full四种视野范围",{"1":{"102":1}}],["full",{"0":{"10":1},"1":{"22":1,"27":1,"102":1,"189":1,"592":1,"1021":1}}],["further",{"1":{"191":1,"192":1,"193":1}}],["function类型的变量会分配一个新的对象",{"1":{"819":1}}],["function",{"1":{"424":1,"720":1}}],["functionality",{"1":{"188":1,"193":1,"196":1}}],["fundamental",{"1":{"186":1}}],["fedora",{"0":{"548":1}}],["feel",{"1":{"196":1}}],["feature",{"1":{"213":1,"984":1}}],["features",{"1":{"189":1}}],["featured",{"1":{"22":1}}],["febrero",{"1":{"155":1}}],["fc",{"1":{"127":1}}],["fronttoback",{"1":{"975":2,"1037":2}}],["from",{"1":{"22":1,"24":1,"27":1,"185":1,"190":1,"191":1,"193":1,"195":2,"487":2,"720":3}}],["frequency",{"1":{"868":1}}],["frequencies",{"1":{"204":1}}],["freelist",{"1":{"929":1}}],["freed",{"1":{"193":1}}],["free",{"1":{"193":2,"196":1}}],["frame",{"1":{"890":1,"1035":1,"1040":1}}],["frametime",{"1":{"41":3,"42":1}}],["frameworks",{"1":{"590":1,"591":1}}],["framework",{"1":{"27":1,"128":3,"132":1,"176":1,"719":1,"721":1}}],["foosystem",{"1":{"934":2,"935":2}}],["foostatecomponent",{"1":{"933":1,"934":3,"935":3}}],["foocomponent",{"1":{"933":1,"934":2,"935":3}}],["folder",{"1":{"527":1}}],["folders",{"0":{"408":1},"1":{"487":1},"2":{"409":1,"410":1}}],["following",{"1":{"28":1,"184":1,"193":1}}],["foundation",{"1":{"721":1}}],["found",{"1":{"188":1,"193":1,"196":1}}],["four",{"1":{"26":1,"644":1,"899":1}}],["force",{"1":{"867":1}}],["foreach中的query有结果才会执行",{"1":{"914":1}}],["foreach生成的",{"1":{"910":1}}],["foreach",{"0":{"910":1},"1":{"823":1,"966":1}}],["foreach循环",{"0":{"823":1}}],["forumunity",{"1":{"1005":1}}],["forum",{"1":{"527":1,"601":1,"789":1,"984":1,"1005":1,"1052":1}}],["fork",{"1":{"427":1,"455":1,"542":1,"543":1,"575":4}}],["forget",{"1":{"192":1,"193":1}}],["format=compact命令行参数从而让c++代码中的类型和方法的名字更加可读",{"1":{"592":1}}],["formatter",{"1":{"195":2}}],["formatting",{"1":{"186":1}}],["format",{"1":{"186":1,"188":1}}],["forward的右偏45度",{"1":{"749":1}}],["forward的左偏45度",{"1":{"749":1}}],["forward",{"1":{"42":2}}],["for",{"0":{"408":1,"409":1,"410":1,"415":1,"566":1},"1":{"15":3,"22":6,"23":2,"24":1,"25":1,"26":6,"27":5,"28":3,"29":2,"90":3,"186":2,"187":3,"188":3,"189":2,"191":5,"193":1,"194":1,"195":3,"412":1,"415":1,"485":2,"486":1,"487":1,"488":2,"489":2,"509":1,"566":1,"585":1,"703":2,"720":27,"737":1,"764":1,"824":4,"863":1,"939":1},"2":{"409":1,"410":1}}],["filtering",{"1":{"930":1}}],["filter",{"0":{"843":1}}],["filename",{"1":{"424":1}}],["file",{"1":{"131":1,"186":2,"188":1,"585":1,"927":1}}],["files",{"1":{"50":1,"186":3,"720":2}}],["fix",{"1":{"571":1,"607":1}}],["first",{"1":{"187":1,"188":2,"191":1,"193":1}}],["firebase等等",{"1":{"607":1}}],["firebaseapp",{"1":{"607":1}}],["fire",{"1":{"26":1}}],["fields",{"1":{"190":1,"192":1,"714":1}}],["field",{"1":{"111":1,"192":1,"486":1}}],["finializer",{"1":{"898":1}}],["finaleventmask",{"1":{"684":4}}],["finally",{"1":{"27":1,"193":1,"823":3}}],["finddistancestonearestneighbors",{"1":{"817":2}}],["find",{"1":{"25":1,"131":1,"189":2,"192":1}}],["fit",{"1":{"27":1}}],["fits",{"1":{"25":1}}],["fighting",{"1":{"15":1}}],["facebook",{"1":{"720":2}}],["fact",{"1":{"191":1,"193":1,"195":1}}],["factory",{"1":{"25":3}}],["fake",{"1":{"452":1}}],["fakelag设置",{"1":{"85":1}}],["false",{"1":{"424":1,"859":1}}],["fade函数",{"0":{"200":1},"1":{"197":1}}],["fastcgi进程管理器",{"1":{"576":1}}],["fastcgi",{"0":{"575":1},"1":{"575":1,"576":3}}],["fastly",{"1":{"491":1}}],["fastly地址",{"0":{"491":1}}],["fastopen上述配置需要根据情况进行修改",{"1":{"467":1}}],["fastest",{"1":{"195":1}}],["faster",{"1":{"191":1}}],["fast",{"1":{"192":1,"196":1,"467":1,"1052":1}}],["fastpacedmultiplayerhttps",{"1":{"81":1}}],["fashion",{"1":{"22":1}}],["far远距离视差相机clear",{"1":{"737":1}}],["farclipplane",{"1":{"684":1}}],["farm型任务",{"1":{"254":1}}],["far不过在实际开发中",{"1":{"102":1}}],["far",{"1":{"22":1,"102":2,"195":1}}],["fanrice123",{"1":{"10":1}}],["hybrid",{"0":{"942":1},"1":{"942":4,"943":3,"954":1,"955":1,"971":2,"1005":1}}],["hierachy",{"1":{"969":1}}],["hierarchy",{"0":{"952":1},"1":{"940":1,"943":1,"947":1,"969":1,"970":1,"971":4,"978":1}}],["hideinhierarchy",{"1":{"969":1}}],["hidebysig",{"1":{"823":1}}],["hiding",{"1":{"15":1}}],["hit为null",{"1":{"750":1}}],["hit",{"1":{"750":2,"751":1}}],["hitdistance",{"1":{"689":6,"694":1}}],["h这个文件中",{"1":{"591":1}}],["hunt型任务",{"1":{"254":1}}],["hundreds",{"1":{"189":1}}],["hugo",{"1":{"204":1}}],["h中的image",{"1":{"131":1}}],["h里的结构",{"1":{"131":1}}],["h",{"1":{"91":1,"642":1,"952":3}}],["h的值等于redis对应的编号",{"1":{"91":1}}],["h=hash",{"1":{"91":1}}],["hack",{"1":{"969":3,"978":1}}],["harverycartel",{"1":{"789":1}}],["hard",{"1":{"707":1}}],["hard问题",{"1":{"207":1}}],["happen",{"1":{"662":1}}],["having",{"1":{"191":1}}],["have",{"1":{"27":1,"28":1,"90":2,"187":1,"188":2,"191":1,"192":2,"196":1,"484":1,"486":1,"585":3,"662":1}}],["hand",{"1":{"193":1,"195":1}}],["handle",{"1":{"189":1,"1005":1}}],["handles",{"1":{"26":1}}],["hans",{"1":{"132":1,"140":1,"147":2}}],["hangfire对于这种分布式的应用处理也是适用的",{"1":{"30":1}}],["hangfire优势太明显了",{"1":{"30":1}}],["hangfire值得拥有",{"1":{"30":1}}],["hangfire控制面板不仅提供监控",{"1":{"30":1}}],["hangfire",{"0":{"30":1},"1":{"29":1,"30":1}}],["hangfireio",{"1":{"29":2}}],["half",{"1":{"26":1,"196":1,"570":1,"571":2}}],["hasflag",{"1":{"180":3}}],["has",{"1":{"22":2,"25":1,"27":1,"90":2,"189":1,"193":1}}],["hashmap",{"1":{"767":1}}],["hashcode在lock之后不能直接存到索引了",{"1":{"131":1}}],["hashcode岂不是丢了",{"1":{"131":1}}],["hashing",{"1":{"96":1}}],["hash对战斗的同步情况进行记录",{"1":{"15":1}}],["hash判断具体哪一个客户端发生了不同步",{"1":{"15":1}}],["hash与其他客户端不一致",{"1":{"15":1}}],["hash",{"0":{"15":1},"1":{"15":1,"91":2}}],["hashedwheeltimer",{"1":{"10":2}}],["heap",{"1":{"899":4,"937":1}}],["header里找到基地址和rva",{"1":{"131":1}}],["header结构",{"1":{"131":1}}],["header则包含了文件的版本号以及重要的基地址和addressofentrypoint",{"1":{"131":1}}],["header",{"1":{"131":1}}],["header的大小等等",{"1":{"131":1}}],["header包含了这个文件的一些信息",{"1":{"131":1}}],["header和ms",{"1":{"131":1}}],["height",{"1":{"633":1,"634":1,"635":1,"636":1,"644":1,"645":1,"859":1}}],["height根据宽或者高来对canvas进行缩放",{"1":{"628":1}}],["hexo",{"0":{"513":1}}],["helps",{"1":{"585":1}}],["helper是否在path中",{"1":{"417":1}}],["helper",{"1":{"27":1}}],["help",{"1":{"26":1}}],["hello",{"1":{"24":1,"510":1}}],["here",{"1":{"24":1,"26":1,"27":1,"181":1,"188":2,"193":1,"195":2,"896":1}}],["hence",{"1":{"24":1}}],["homebrew",{"1":{"478":2,"481":2,"483":2}}],["home",{"1":{"411":1}}],["hope",{"1":{"193":1,"585":1}}],["hopefully",{"1":{"22":1}}],["hoare在1962年提出",{"1":{"107":1}}],["hours",{"1":{"26":1}}],["hour",{"1":{"26":1}}],["hooks",{"1":{"25":1,"471":1}}],["however",{"1":{"90":1,"186":1,"189":3,"191":1,"192":1,"195":1,"196":1}}],["how",{"0":{"182":1},"1":{"25":1,"27":1,"29":1,"187":1,"189":1,"191":1,"192":1,"195":1,"607":1,"644":1,"896":1,"998":1},"2":{"183":1,"184":1,"185":1}}],["host",{"1":{"22":1}}],["hosted",{"1":{"22":4,"26":1,"27":1}}],["html5",{"1":{"770":1}}],["htmlwhat",{"1":{"81":1}}],["htmlhttp",{"1":{"81":1}}],["html",{"1":{"60":1,"65":1,"71":1,"77":1,"131":2,"162":1,"398":1,"506":1,"512":1,"535":1,"573":3,"606":3,"701":1,"719":4,"723":1,"825":1,"839":1,"850":3,"941":1,"984":1}}],["htmlecs是一个好的处理方式",{"1":{"15":1}}],["http2和websocket",{"1":{"583":1}}],["http2协议解析完成后",{"1":{"169":1}}],["http等协议",{"1":{"580":2,"581":1}}],["httpd",{"1":{"573":1}}],["http1协议解析完成后",{"1":{"169":1}}],["http1和http2处理http协议的方式有所不同",{"1":{"169":1}}],["http版本控制",{"0":{"169":1}}],["httpconnection",{"0":{"168":1,"169":1},"2":{"169":1,"170":1}}],["httpconnectionmiddleware<servicecontext>",{"0":{"168":1},"2":{"169":1,"170":1}}],["http应用程序",{"0":{"165":1}}],["http",{"1":{"22":2,"50":1,"60":1,"65":1,"71":1,"77":1,"152":2,"163":1,"166":1,"181":3,"225":1,"398":2,"412":1,"471":1,"490":2,"491":1,"506":1,"573":2,"575":1,"576":2,"581":1,"719":1,"722":2,"737":1}}],["https",{"0":{"1027":1,"1028":1,"1029":1,"1030":1},"1":{"10":1,"15":3,"21":1,"29":3,"50":1,"55":1,"57":1,"81":1,"96":2,"103":2,"104":3,"126":1,"131":3,"132":1,"137":2,"147":3,"162":1,"181":1,"185":1,"211":4,"225":2,"411":2,"412":2,"415":1,"416":1,"423":1,"436":1,"437":1,"483":1,"499":2,"510":1,"512":1,"515":1,"532":1,"560":1,"566":1,"567":1,"569":3,"587":1,"606":6,"607":2,"611":1,"617":1,"701":1,"706":1,"719":5,"723":2,"737":1,"747":3,"770":1,"812":1,"825":1,"839":1,"850":8,"941":2,"942":1,"965":1,"984":7,"998":1}}],["iresourcelocation",{"0":{"902":1},"2":{"903":1}}],["iresourcelocator",{"0":{"901":1}}],["i++",{"1":{"824":4}}],["i4",{"1":{"823":1}}],["iequalitycomparer",{"1":{"822":1}}],["ienumerable",{"1":{"486":1}}],["ignoreparentgroups",{"1":{"691":1}}],["ignores",{"1":{"487":1}}],["iab",{"1":{"615":1}}],["iab测试的要求清单",{"0":{"614":1},"2":{"615":1,"616":1}}],["iconverttogameobjecttoentity",{"1":{"964":1}}],["iconvertgameobjecttoentity",{"0":{"957":1},"1":{"964":1}}],["icomponentdata",{"1":{"927":1,"987":1}}],["icustombootstrap",{"1":{"939":1}}],["icustommessagetarget",{"1":{"657":1}}],["iceworks",{"1":{"535":1}}],["icloneable",{"1":{"896":2}}],["icloneable的问题是clone方法并不会显式地指定是执行浅拷贝或深拷贝",{"1":{"111":1}}],["icloneable接口包含一个成员方法",{"1":{"111":1}}],["icloneable接口包含一个clone方法",{"1":{"111":1}}],["icloneable接口",{"0":{"111":1},"2":{"112":1}}],["ihttpapplication<tcontext>",{"0":{"163":1,"165":1}}],["iphone",{"1":{"720":1,"830":1}}],["iphone4的屏幕像素为640",{"1":{"618":1}}],["ipc等功能",{"1":{"580":1}}],["ipaddress",{"1":{"490":1,"491":1}}],["ipv4",{"1":{"467":1}}],["ip",{"1":{"135":1,"467":1}}],["ip协议规定",{"1":{"37":1}}],["img",{"1":{"965":1}}],["immutable",{"1":{"739":1,"744":1}}],["immediate",{"1":{"283":8}}],["image图集的原因",{"1":{"861":1}}],["images",{"1":{"287":4,"854":2}}],["image",{"1":{"131":1,"795":1,"803":1}}],["importing",{"1":{"947":1}}],["import",{"1":{"499":1,"746":1}}],["important",{"1":{"25":2,"186":2,"187":1,"189":1}}],["improving",{"1":{"197":1,"1052":1}}],["improve",{"1":{"22":1}}],["impact",{"1":{"181":1,"189":1}}],["implements",{"1":{"25":1}}],["implement",{"1":{"24":1,"27":1,"896":1}}],["implementations",{"1":{"25":1}}],["implementation",{"1":{"24":1,"25":2,"26":3,"27":1,"28":2}}],["ilforeach",{"1":{"823":2}}],["il指令是",{"1":{"821":1}}],["ilruntime通过clr方法绑定机制",{"1":{"718":1}}],["ilruntime中继承unity项目中的类",{"1":{"718":1}}],["ilruntime中使用unity项目的委托",{"1":{"718":1}}],["ilruntime中的反射",{"1":{"715":1}}],["ilruntime并没有创建一个appdomain",{"1":{"718":1}}],["ilruntime借助mono",{"1":{"710":1}}],["ilruntime",{"0":{"710":1},"1":{"719":1},"2":{"711":1,"712":1,"713":1,"714":1,"715":1,"716":1}}],["ilcpp",{"1":{"606":1}}],["il2cpp中此过程必须执行查找和验证以便将脚本引用转换为对原生代码的引用",{"1":{"858":1}}],["il2cpp下的匿名函数",{"0":{"819":1}}],["il2cpp限制",{"0":{"604":1}}],["il2cpp在打包时会自动对unity工程的dll进行裁剪",{"1":{"603":1}}],["il2cpp才能够完整保留",{"1":{"600":1}}],["il2cpp没做的事情",{"0":{"593":1}}],["il2cpp是如何执行的",{"0":{"592":1}}],["il2cpp的另外一个部分就是对虚拟机提供支持的运行时库",{"1":{"591":1}}],["il2cpp目录下找到",{"1":{"590":1}}],["il2cpp",{"0":{"489":1,"596":1},"1":{"585":1,"590":4,"591":2,"592":4,"598":1,"604":3,"606":2},"2":{"597":1,"598":1,"599":1,"600":1,"601":1,"602":1}}],["il2cpp也是实现了boehm算法",{"1":{"123":1}}],["ilvl",{"1":{"270":1}}],["il",{"1":{"176":1,"589":1,"604":1,"823":26,"864":1,"967":1}}],["il放在这里面",{"1":{"131":1}}],["ilgenerator",{"1":{"111":1}}],["idisposable",{"1":{"823":1}}],["ideclarereferencedprefabs",{"1":{"964":1}}],["ideclarereferencedprefabs在",{"1":{"964":1}}],["idea无法启动",{"0":{"563":1}}],["idea提示激活码无效",{"0":{"562":1}}],["idea会提示你激活",{"1":{"560":1}}],["ideas",{"1":{"489":1}}],["ideally",{"1":{"192":1}}],["ideal",{"1":{"29":1}}],["identityserver",{"1":{"185":1}}],["identity",{"1":{"181":1,"185":1}}],["idl",{"1":{"127":1}}],["id",{"1":{"103":5,"533":2,"601":3,"607":1,"610":1,"858":2,"936":5,"965":2}}],["idy",{"1":{"103":4}}],["idx",{"1":{"103":4}}],["ios下使用adpcm和mp3格式",{"1":{"867":1}}],["ios是根据vblank",{"1":{"855":1}}],["ios忽略",{"1":{"855":1}}],["ios封了内存",{"1":{"709":1}}],["ios并非把jit禁止了",{"1":{"709":1}}],["ios不能基于以上热更的原因",{"0":{"709":1}}],["ios不包括",{"1":{"708":1}}],["ios",{"1":{"601":1,"604":1,"720":3,"855":1}}],["io以及内部调用",{"1":{"589":1}}],["ioptions可以用来支持options模式",{"1":{"174":1}}],["ioptionssnapshot在需要对每个请求重新计算选项的场景中非常有用",{"1":{"174":1}}],["ioptionssnapshot<>是范围",{"1":{"174":1}}],["ioptionssnapshot<>被注册为范围服务",{"1":{"173":1}}],["ioptions<>最简单",{"1":{"174":1}}],["ioptions<>是单例",{"1":{"174":1}}],["ioptions<>好理解",{"1":{"173":1}}],["ioptions<>和ioptionsmonitor<>被注册为单例服务",{"1":{"173":1}}],["ioptionsmonitor用于检索选项和管理toptions实例的选项通知",{"1":{"174":1}}],["ioptionsmonitor就会跟着更新",{"1":{"173":1}}],["ioptionsmonitor<>也是单例",{"1":{"174":1}}],["ioptionsmonitor<>呢",{"1":{"173":1}}],["ioptionsmonitor<>和ioptionssnapshot<>接口来获取testoptions的值",{"1":{"172":1}}],["ioptionsmonitor<>和ioptionssnapshot<>的值",{"1":{"172":1}}],["ioptionsmonitor以及ioptionssnapshot",{"1":{"171":1}}],["ioptions",{"1":{"171":1}}],["io",{"1":{"60":1,"132":1,"140":1,"147":2,"162":1,"398":1,"512":1,"541":1,"719":1,"770":1,"850":1}}],["ijobforeach中使用",{"0":{"995":1}}],["ijobforeach更复杂的操作",{"1":{"911":1}}],["ijobfactory",{"0":{"25":1}}],["ijobchunk",{"0":{"911":1},"1":{"911":1,"998":1}}],["ijob",{"0":{"24":1}}],["if",{"1":{"23":1,"27":3,"28":1,"90":3,"188":2,"192":3,"193":2,"195":1,"196":2,"282":1,"484":1,"486":1,"487":1,"571":1,"644":2,"662":1,"991":1}}],["i",{"1":{"22":2,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":2,"186":1,"187":1,"188":1,"189":4,"195":3,"270":2,"384":2,"824":16,"846":4}}],["iteration",{"0":{"912":1},"1":{"1052":1}}],["itementry组件的buff中",{"1":{"1008":1}}],["itementry",{"1":{"1008":1}}],["items",{"1":{"487":2}}],["item",{"0":{"1008":1},"1":{"406":1,"424":1,"1008":1}}],["itself",{"1":{"26":1,"186":1}}],["its",{"1":{"26":1,"192":1,"484":1,"644":1}}],["it",{"0":{"182":1},"1":{"22":5,"23":2,"25":2,"27":4,"29":1,"90":1,"186":1,"187":1,"188":2,"189":5,"191":2,"192":1,"193":1,"195":1,"471":1,"571":1,"585":3,"896":1},"2":{"183":1,"184":1,"185":1}}],["ing",{"1":{"899":8}}],["innerdictionary",{"1":{"714":1}}],["inputmodule",{"1":{"668":1}}],["input",{"1":{"658":2,"695":1,"824":5,"864":1}}],["input中",{"1":{"653":1}}],["input的信息由引擎自己设置的",{"1":{"653":1}}],["input拥有各种输入设备的数据信息",{"1":{"653":1}}],["information",{"1":{"579":1}}],["inherit",{"1":{"487":1}}],["inherits",{"1":{"487":1}}],["inherent",{"1":{"186":1}}],["inventory",{"1":{"1008":1}}],["investment",{"1":{"22":1}}],["invalid",{"0":{"562":1}}],["invoke",{"1":{"424":1}}],["individual",{"1":{"931":1}}],["indices就是这么一回事",{"1":{"846":1}}],["indices",{"1":{"846":1}}],["indie",{"1":{"225":1}}],["indienova",{"1":{"225":2}}],["indeed",{"1":{"190":1,"193":1}}],["index表示这个实体的id",{"1":{"906":1}}],["index",{"1":{"60":1,"111":1,"695":1}}],["including",{"1":{"720":1}}],["includeinactive",{"1":{"864":1}}],["include目录中",{"1":{"591":1}}],["include",{"0":{"704":1},"1":{"188":1,"705":1,"964":2}}],["increase",{"1":{"191":2}}],["incserver支持near",{"1":{"102":1}}],["incserver的aoi",{"0":{"102":1}}],["incserver将每个场景看做是由n个land",{"1":{"99":1}}],["inactive",{"1":{"88":1,"964":2}}],["insubscene1什么都没有但是位于",{"1":{"971":1}}],["inspector",{"1":{"650":2,"964":1,"967":1,"971":1,"975":2,"978":1}}],["inside",{"1":{"28":1,"186":1,"193":1}}],["instead",{"1":{"25":1,"27":1,"186":1,"190":1,"191":1,"489":1,"720":1,"851":1}}],["instantiate",{"1":{"966":1,"969":1}}],["instantiate方法则会将实例化出的",{"1":{"964":1}}],["instantiate再经常更新的代码",{"1":{"858":1}}],["instancing的实现原理进行了比较大的修改",{"0":{"983":1}}],["instancing相比",{"1":{"982":1}}],["instancing实现的原理相近",{"1":{"982":1}}],["instancing批处理中断情况位置不相邻且中间夹杂着不同材质的其他物体",{"1":{"981":1}}],["instancing了解一下zhuanlan",{"1":{"981":1}}],["instancing可以",{"1":{"981":1}}],["instancing可以一次渲染",{"1":{"849":1}}],["instancing",{"0":{"981":1},"1":{"942":2,"952":1,"980":1,"981":1}}],["instancing很有用",{"1":{"849":1}}],["instance",{"1":{"22":1,"25":1,"26":1,"27":2,"823":5,"849":1}}],["instances",{"1":{"22":1,"25":2,"26":1}}],["installer",{"1":{"567":1}}],["install",{"1":{"23":2}}],["installing",{"0":{"23":1}}],["injected",{"1":{"27":3}}],["inject",{"0":{"954":1,"956":1,"968":1},"1":{"24":1,"28":2,"717":1,"954":3,"955":4,"956":1,"968":3,"969":1,"970":1,"971":1,"1005":1}}],["injection",{"1":{"24":1,"25":2}}],["int32",{"1":{"823":3}}],["int",{"1":{"818":5,"820":1,"822":2,"823":2,"824":5,"881":1,"930":1}}],["intel",{"1":{"720":1}}],["intel的",{"1":{"33":1}}],["integration",{"1":{"566":1}}],["integers",{"1":{"190":1}}],["internal",{"1":{"936":1}}],["internals",{"1":{"606":1}}],["internet",{"1":{"15":1}}],["interest",{"1":{"188":1}}],["interested",{"1":{"187":1,"188":1,"193":1}}],["interesting",{"1":{"61":1,"68":1}}],["interp为0",{"1":{"83":1,"86":1}}],["interp",{"1":{"83":2,"86":3}}],["interpolation",{"1":{"77":1}}],["interchangeable",{"1":{"26":1}}],["interfaces",{"1":{"657":1}}],["interface",{"1":{"24":1,"25":1,"571":1,"572":1,"573":1,"578":1,"882":1}}],["interactive",{"1":{"15":1}}],["introduced",{"1":{"29":1}}],["introduction",{"0":{"22":1,"181":1},"1":{"606":1}}],["into",{"1":{"22":1,"24":1,"25":2,"28":1,"186":2,"187":1,"188":2,"189":1,"196":1,"486":1}}],["in",{"0":{"28":1,"704":1,"705":1},"1":{"15":1,"22":8,"23":1,"25":4,"26":2,"27":4,"28":4,"29":4,"50":2,"81":2,"90":5,"131":2,"181":2,"183":1,"185":1,"186":2,"187":1,"188":4,"189":4,"190":1,"191":5,"192":2,"193":6,"195":3,"196":3,"471":1,"488":1,"489":1,"544":1,"560":1,"571":2,"585":1,"607":1,"644":1,"704":1,"705":1,"707":1,"709":1,"737":1,"823":1,"867":1,"896":1,"899":4,"939":1,"971":2,"975":4,"976":3,"977":1,"978":2,"998":1,"1041":1,"1052":1}}],["initialize会查找所有拥有",{"1":{"1008":1}}],["initializeasync",{"0":{"900":1}}],["initializesharedtilemaps",{"1":{"228":1}}],["init",{"1":{"823":1}}],["ini中需要设置",{"1":{"434":1}}],["ini",{"0":{"408":1},"1":{"8":1},"2":{"409":1,"410":1}}],["isystemstatecomponentdata",{"1":{"987":1}}],["is一个",{"1":{"947":1}}],["isharedcomponentdata",{"1":{"930":2,"971":1}}],["ispointerovergameobject",{"1":{"658":1}}],["isconditionmet",{"1":{"283":2}}],["iservicecollection",{"1":{"173":1}}],["iserver",{"0":{"163":1,"164":1}}],["issuecomment",{"1":{"90":1}}],["issues",{"1":{"90":1,"137":2}}],["issue",{"1":{"28":1,"181":1}}],["isn",{"1":{"28":1,"29":1}}],["is",{"0":{"22":1},"1":{"10":1,"22":5,"23":1,"25":5,"26":2,"27":4,"28":2,"29":2,"90":2,"181":1,"184":1,"186":4,"187":1,"188":3,"189":8,"190":2,"191":4,"192":1,"193":6,"195":10,"196":3,"485":1,"486":1,"487":2,"488":1,"571":1,"644":3,"720":2,"1005":1}}],["svg+xml",{"1":{"965":1}}],["srp",{"0":{"982":1},"1":{"952":1,"984":1}}],["src",{"1":{"535":1}}],["sbyte",{"1":{"881":1}}],["s怎么启动调试都无法关联到unity",{"1":{"834":1}}],["sdk",{"1":{"604":2}}],["sdk所提供的api来实现",{"1":{"127":1}}],["sdk所提供的api来实现内存管理",{"1":{"127":1}}],["sd",{"1":{"571":3}}],["switch",{"1":{"488":1}}],["sschmid",{"1":{"747":1}}],["ssl",{"0":{"491":1},"1":{"491":1}}],["sspai",{"1":{"483":1}}],["ss",{"1":{"467":3,"473":1}}],["ssh命令",{"0":{"511":1}}],["sshd",{"0":{"464":1}}],["ssh",{"0":{"464":1},"1":{"459":1}}],["ss=",{"1":{"111":1}}],["s13新诅咒机制介绍",{"1":{"385":1}}],["s13新的诅咒机制有什么",{"1":{"385":1}}],["skillterm",{"0":{"248":1}}],["skipping",{"1":{"186":1}}],["sln",{"1":{"722":1}}],["slower",{"1":{"195":1}}],["slot",{"1":{"90":5}}],["slightly",{"1":{"195":1}}],["sliver",{"1":{"88":1}}],["smaller",{"1":{"644":1}}],["smallest",{"1":{"22":1}}],["small",{"1":{"189":1,"192":1,"195":2}}],["smcs",{"1":{"126":1}}],["smooth",{"1":{"84":1}}],["smoothtime",{"1":{"84":1}}],["s00530",{"1":{"81":1}}],["spher",{"1":{"1000":1}}],["spherecastnonalloc",{"1":{"858":1}}],["spherecastall",{"1":{"858":1}}],["spawnhereecstag",{"1":{"966":1}}],["spawnhereecs",{"1":{"966":2}}],["spawnhere",{"1":{"966":2,"967":1}}],["spatial",{"1":{"767":1}}],["space下",{"1":{"640":1}}],["spacenpclist",{"1":{"264":1}}],["spacewaterlist",{"1":{"264":1}}],["space",{"1":{"191":1,"192":1,"193":1,"640":2,"841":3,"977":4,"978":1}}],["spriterenderder",{"1":{"975":4}}],["spriterenderer",{"1":{"685":2,"695":2,"975":1}}],["sprite",{"1":{"845":1,"978":1}}],["spriteatlas",{"1":{"705":3,"706":1}}],["sprites将在editor模式期间引用原始未压缩的纹理",{"1":{"703":1}}],["sprite在运行时引用打包的textures",{"1":{"703":1}}],["springer",{"1":{"81":1}}],["spoon",{"1":{"542":1}}],["split",{"1":{"424":1,"585":1}}],["specialcube",{"1":{"965":1,"1003":1}}],["special",{"1":{"487":1}}],["specifically",{"1":{"187":1,"193":1,"196":1,"720":3}}],["specific",{"1":{"22":2}}],["spelunkygen2",{"1":{"225":1}}],["spelunkygen",{"1":{"225":1}}],["spelunky并不像其他大部分游戏",{"1":{"225":1}}],["spelunky",{"1":{"224":1}}],["s模型",{"1":{"66":1}}],["s架构的游戏采用以上数据结构运行如下",{"1":{"42":1}}],["s架构背景",{"1":{"40":1}}],["s游戏引擎通常看起来是这样的为了便于讨论",{"1":{"41":1}}],["s游戏的基本架构",{"0":{"41":1}}],["s结构游戏基础上修改完成的",{"1":{"41":1}}],["shipandco上拥有一个",{"1":{"969":1}}],["ship",{"1":{"969":1}}],["shitangdejiaozi的博客",{"1":{"631":1}}],["shift",{"1":{"533":1}}],["shrink和expand恰好相反",{"1":{"628":1}}],["sharpcorner",{"1":{"899":4}}],["share",{"1":{"90":1,"570":1}}],["sharedghosttypecomponent",{"1":{"1020":1}}],["sharedmaterial来保证材质的共享状态",{"1":{"979":1,"980":1}}],["shared中的共用代码",{"1":{"43":1}}],["shared",{"0":{"928":1},"1":{"43":2,"195":1,"527":1,"928":8,"929":8},"2":{"929":1,"930":1,"931":1,"932":1,"933":1,"934":1,"935":1,"936":1,"937":1,"938":1,"939":1}}],["shadows关闭阴影投射",{"1":{"859":1}}],["shadowsocks连接密码",{"1":{"467":1}}],["shadowsocks服务器端口",{"1":{"467":1}}],["shadowsocks服务器地址",{"1":{"467":1}}],["shadowsocks",{"0":{"466":1},"1":{"465":2,"466":1,"467":1,"475":4}}],["shader中",{"1":{"982":1}}],["shader中变体",{"1":{"982":1}}],["shader通常会导致一个物体要连续绘制多次",{"1":{"980":1}}],["shader的物体会禁用dynamic",{"1":{"980":1}}],["shaders",{"1":{"844":1,"850":1}}],["shader",{"1":{"726":3,"798":1,"858":3,"868":1,"974":2,"975":3,"978":1,"1036":5}}],["shell",{"0":{"408":1},"1":{"497":1},"2":{"409":1,"410":1}}],["shut",{"1":{"27":1}}],["shuts",{"1":{"27":1}}],["shoe",{"1":{"896":1}}],["short",{"1":{"90":1,"881":1}}],["showimpacts",{"1":{"85":1}}],["showing",{"1":{"26":1}}],["showerror",{"1":{"84":1}}],["showed",{"1":{"29":1}}],["showhitboxes",{"1":{"83":1}}],["shown",{"1":{"26":1,"29":1}}],["show",{"1":{"22":1,"28":1,"29":1}}],["should",{"1":{"22":1,"23":2,"24":1,"25":1,"27":1,"189":1,"195":1,"488":1,"571":1}}],["subscene下面两图中",{"1":{"971":1}}],["subscene",{"0":{"971":1},"1":{"971":14}}],["submesh只有triangles信息",{"1":{"847":1}}],["submesh类似于mesh",{"1":{"847":1}}],["submesh",{"0":{"847":1}}],["subnormal",{"1":{"846":1}}],["sudio中找到attach",{"1":{"838":1}}],["suse",{"0":{"548":1}}],["super",{"1":{"266":1}}],["supported",{"0":{"470":1},"1":{"487":1}}],["support",{"1":{"22":1,"90":1,"571":1}}],["supports",{"1":{"22":1,"585":1}}],["suffice",{"1":{"189":1}}],["such",{"1":{"186":1,"193":1}}],["summary",{"0":{"29":1},"1":{"503":2,"504":1,"505":1,"737":1},"2":{"30":1}}],["sure",{"1":{"26":1,"189":1,"192":1,"193":1}}],["semanticquery",{"1":{"1043":1}}],["semanticobject",{"1":{"1042":1}}],["sevenson",{"1":{"789":1}}],["several",{"1":{"187":1,"189":1}}],["sever",{"1":{"51":1}}],["separation",{"1":{"764":1}}],["separating",{"0":{"761":1},"1":{"764":3,"789":1},"2":{"762":1,"763":1,"764":1,"765":1,"766":1,"767":1,"768":1,"769":1,"770":1}}],["send",{"1":{"700":1}}],["sendmessageupwards",{"1":{"660":1}}],["self和优先级较低的节点",{"1":{"283":1}}],["self",{"1":{"283":3,"878":2}}],["select",{"1":{"443":1,"585":1,"966":1}}],["select在执行b前返回的是true",{"1":{"282":1}}],["selector",{"1":{"282":1}}],["sequence",{"1":{"282":1}}],["sequence会记录自己循环过哪些task",{"1":{"278":1}}],["serializer",{"1":{"489":1}}],["serialized",{"1":{"488":1}}],["serialization",{"1":{"195":1,"488":1}}],["serializable",{"1":{"111":1}}],["serialises",{"1":{"189":1}}],["serialise",{"1":{"188":1,"192":1}}],["serialisation",{"1":{"187":1,"192":1}}],["serialising",{"1":{"186":2,"187":1,"191":1}}],["serving",{"1":{"506":1}}],["service启用启动脚本",{"1":{"467":1}}],["serviceid",{"1":{"90":1}}],["service",{"1":{"22":3,"26":1,"27":2,"28":1,"90":1,"607":1}}],["serviceshttps",{"1":{"483":1}}],["services",{"0":{"28":1},"1":{"22":2,"28":2,"29":2,"173":1}}],["servertick标记发送给服务器的命令所在的tick",{"1":{"1014":1}}],["servertick没有多大关系",{"1":{"1014":1}}],["servertick=======================================================================客户端的servertick在不同的两帧之间可能是相同的servertick",{"1":{"1013":1}}],["server协议的服务器",{"1":{"578":1}}],["server的服务器",{"1":{"578":1}}],["server的基本功能",{"1":{"163":1}}],["server上了",{"1":{"578":1}}],["server是一款基于vscode的在线编辑器",{"1":{"545":1}}],["server",{"1":{"50":1,"51":7,"65":1,"71":1,"78":1,"79":1,"81":1,"166":2,"181":1,"467":2,"544":2,"578":3,"746":1}}],["servers",{"1":{"15":1}}],["search",{"1":{"81":2}}],["secretmine的作者lukáš",{"1":{"737":1}}],["secondary",{"1":{"961":1}}],["second",{"1":{"189":1,"190":1}}],["secondly",{"1":{"187":1}}],["seconds",{"1":{"26":1,"27":1,"189":2,"191":2,"194":1}}],["section有很多",{"1":{"131":1}}],["section的数量",{"1":{"131":1}}],["sec17https",{"1":{"81":1}}],["seemingly",{"1":{"191":1}}],["seems",{"1":{"188":1}}],["see",{"1":{"27":2,"90":1,"187":1,"193":1,"195":1,"927":1}}],["setenable",{"1":{"965":1}}],["setresolution",{"1":{"859":1}}],["setpixels32",{"1":{"858":1}}],["setpixels",{"1":{"858":1}}],["settriangles",{"1":{"847":1}}],["settings可以通过",{"1":{"970":1}}],["settings中的",{"1":{"586":1}}],["settings",{"1":{"186":1,"571":3,"585":4,"652":1,"653":1,"721":1,"868":5,"999":1,"1034":1}}],["setting",{"1":{"27":1,"488":1,"571":1}}],["setup",{"1":{"437":1,"737":1}}],["sets",{"1":{"27":1}}],["set",{"1":{"26":1,"90":1,"444":2,"571":1,"598":1,"940":1,"941":1,"942":1}}],["sa",{"1":{"931":4,"933":1}}],["sat",{"1":{"764":3,"789":1}}],["sapi",{"1":{"576":1}}],["save",{"1":{"446":2,"448":3,"449":13,"450":3,"451":2}}],["savechanges",{"1":{"161":1}}],["safari",{"1":{"411":1}}],["safearea进行判断的",{"1":{"852":1}}],["safeadaptation",{"1":{"851":1}}],["safepadding",{"0":{"853":1},"1":{"851":1}}],["safety",{"1":{"191":1}}],["safely",{"1":{"27":1}}],["safe",{"1":{"25":1}}],["say",{"1":{"90":1,"189":1,"195":1}}],["sam2b2b",{"1":{"983":1}}],["samesite",{"1":{"181":1,"185":1}}],["same",{"1":{"24":1,"90":3,"188":1,"191":1,"193":1,"195":2,"196":1,"485":1,"486":1,"489":1,"644":1,"720":1}}],["sample",{"1":{"10":1,"1011":1}}],["sierra",{"1":{"477":1}}],["siggraph",{"1":{"197":1}}],["significantly",{"1":{"195":2}}],["signatures",{"1":{"193":1}}],["sin",{"1":{"756":16}}],["since",{"1":{"195":1,"585":1}}],["singledomain",{"1":{"707":1}}],["singletons",{"1":{"25":1,"26":1}}],["singleton",{"1":{"25":1,"28":1,"29":1,"195":2,"969":1}}],["single",{"1":{"22":1,"24":1,"26":1,"27":1,"186":1,"189":1,"190":1,"845":1}}],["situations",{"1":{"186":1}}],["sized",{"1":{"937":1}}],["sizedelta是个由引擎计算出来的值",{"1":{"644":1}}],["sizedelta",{"0":{"644":1},"1":{"644":6}}],["size随屏幕尺寸变化",{"1":{"625":1}}],["size",{"0":{"627":1,"629":1},"1":{"101":2,"193":1,"195":2,"628":1,"644":3,"872":1}}],["silos",{"1":{"90":2}}],["side和upmove表示玩家是否通过键盘",{"1":{"42":1}}],["side",{"1":{"42":1,"71":1,"81":1}}],["simd指令来更快地迭代数据",{"1":{"941":1}}],["simpler",{"1":{"190":1}}],["simple",{"1":{"26":1,"188":1,"1005":1}}],["similarly",{"1":{"190":1}}],["similar",{"1":{"22":1,"28":2}}],["s",{"0":{"975":1,"977":1},"1":{"22":2,"25":1,"26":1,"28":1,"64":1,"82":1,"111":1,"185":1,"188":1,"191":2,"197":1,"571":1,"726":2,"823":2,"896":1,"903":1,"984":1},"2":{"976":1,"977":1,"978":1}}],["scenemanager",{"1":{"971":1}}],["scenetag是这里最大的区别",{"1":{"971":1}}],["scenesection",{"1":{"971":1}}],["sceneview",{"1":{"971":3}}],["scene中新增的内容",{"1":{"970":1}}],["scene文件中",{"1":{"940":1}}],["scene",{"0":{"871":1},"1":{"737":1,"940":1,"955":1,"964":4,"965":4,"966":1,"969":1,"970":4,"971":20}}],["scenarios",{"1":{"22":1}}],["scenario",{"1":{"22":1}}],["scroll",{"1":{"860":1}}],["screensafearearelative",{"1":{"852":1}}],["screen",{"0":{"628":1},"1":{"625":1,"628":2,"841":2,"977":3}}],["scriptcompileorderfolders",{"1":{"839":1}}],["scriptassemblies下的两个assembly中",{"1":{"717":1}}],["scriptreference",{"1":{"701":1,"941":1}}],["scriptingrestrictions",{"1":{"606":1}}],["scripting",{"1":{"606":1,"720":1,"723":1,"855":2,"941":1}}],["script",{"1":{"585":1,"657":1,"839":2,"955":1,"965":1,"1003":1,"1052":1}}],["scripts",{"1":{"186":1,"535":1,"720":1}}],["scriban具体的示例参见",{"1":{"147":1}}],["scoop",{"0":{"438":1},"1":{"427":1,"438":2}}],["score",{"1":{"427":3}}],["scope",{"1":{"28":2}}],["scoped",{"0":{"28":1},"1":{"28":3,"29":2}}],["scm",{"1":{"423":1}}],["schema",{"1":{"181":1}}],["scheduled",{"1":{"27":1}}],["schedules",{"1":{"27":2}}],["scheduler",{"1":{"22":1,"25":2,"27":4}}],["schedule",{"1":{"22":2,"26":2,"29":1}}],["scheduling",{"1":{"22":2,"24":1,"26":2}}],["scale来控制canvas的变换",{"1":{"626":1}}],["scaler来做的",{"1":{"626":1}}],["scaler",{"0":{"626":1},"2":{"627":1,"628":1,"629":1}}],["scaler主要是设置canvas",{"1":{"624":1}}],["scale",{"1":{"22":1,"625":1,"649":1,"948":1,"951":2,"952":1,"980":2}}],["soringorder高的会在sortingorder低的前面",{"1":{"976":1}}],["sorting",{"1":{"695":2,"975":5,"976":2,"977":1,"1041":1}}],["sortingorder",{"0":{"1040":1},"1":{"685":1,"687":1,"695":7,"1040":3}}],["sortinglayerid",{"1":{"695":2}}],["sortinglayer",{"0":{"1039":1},"1":{"685":1,"695":7,"1039":11,"1040":2}}],["sortinggroup也不会有用处",{"1":{"622":1}}],["sortorderpriority",{"1":{"683":1,"695":2}}],["sorted",{"1":{"662":1,"817":2}}],["sort",{"1":{"22":2,"695":1,"817":2,"818":2,"977":1,"978":2}}],["socket来和服务器通讯",{"1":{"576":1}}],["sockets",{"0":{"229":1},"1":{"471":1}}],["socks",{"1":{"471":1}}],["sock5",{"1":{"467":3}}],["solidcolor",{"1":{"737":1}}],["solve",{"0":{"182":1},"1":{"486":1,"488":1},"2":{"183":1,"184":1,"185":1}}],["solution",{"0":{"851":1},"1":{"22":1,"28":1,"188":1,"192":1,"737":1},"2":{"852":1,"853":1}}],["soap",{"1":{"111":1}}],["somehow",{"1":{"817":2}}],["some",{"0":{"192":1},"1":{"22":1,"195":1,"863":1}}],["something",{"1":{"10":1,"23":1,"28":1,"193":1}}],["so",{"1":{"22":2,"23":1,"25":2,"26":1,"28":1,"189":2,"191":1,"193":1,"485":1,"489":1}}],["sourcemaking",{"1":{"833":1}}],["sourcetree",{"1":{"421":1}}],["sourcetree本地记住的密码",{"1":{"421":1}}],["sourcetree删除git密码",{"0":{"418":1},"2":{"419":1,"420":1,"421":1}}],["sourcetags",{"1":{"239":1}}],["source引擎提供了一些工具来检查您的客户端连接速度和质量",{"1":{"86":1}}],["source默认为100毫秒的插补周期",{"1":{"83":1}}],["source",{"1":{"22":1,"29":1,"87":1}}],["stloc",{"1":{"823":4}}],["stehlík一起开发了这种技术",{"1":{"737":1}}],["step",{"0":{"11":1,"73":1,"183":1,"184":1,"185":1},"1":{"12":6,"73":1}}],["stdout",{"1":{"574":1}}],["stdin",{"1":{"574":1}}],["stretchy",{"1":{"937":1}}],["stream",{"1":{"186":1,"188":3,"190":2}}],["stripping",{"1":{"868":1}}],["string它们都衍生于system",{"1":{"882":1}}],["stringtohash",{"1":{"858":1}}],["stringbuilder",{"1":{"828":1}}],["string简单类型",{"1":{"657":1}}],["strings",{"1":{"488":1}}],["string加到类型对象里",{"1":{"131":1}}],["string",{"1":{"131":1,"488":1,"898":1}}],["strategic",{"1":{"213":1}}],["stranden用扩展方法",{"1":{"111":1}}],["struct类型可以变得非常庞大",{"1":{"891":1}}],["structure",{"1":{"189":1,"190":1,"192":1,"193":2,"195":1}}],["structures",{"0":{"187":1},"1":{"187":4,"188":1,"192":1,"193":2,"195":3}}],["struct",{"1":{"189":2,"195":6,"881":1,"927":1}}],["structs",{"1":{"188":2,"189":1,"193":1,"194":1,"196":1}}],["storytelling型任务",{"1":{"254":1}}],["store的使用",{"0":{"413":1}}],["store",{"0":{"419":1},"1":{"186":1,"411":2,"413":1,"527":1,"533":1,"607":1}}],["storagehttps",{"1":{"90":1}}],["storage",{"1":{"90":1,"186":2,"707":1}}],["stop你不能在",{"1":{"965":1}}],["stops",{"1":{"283":16}}],["stop",{"1":{"118":1,"121":1,"793":1,"952":2,"953":2,"965":2,"968":2}}],["stuff",{"1":{"701":4}}],["stub是为了兼容dos系统存在的",{"1":{"131":1}}],["study",{"1":{"190":1}}],["studio插件可以帮助定位代码中的内存分配",{"1":{"815":1}}],["studio平台的其他编程语言不一样",{"1":{"127":1}}],["studio",{"1":{"125":1,"127":1,"569":1,"586":1,"722":2}}],["studio中的构建系统",{"1":{"125":1}}],["studio生成",{"1":{"125":1,"586":1}}],["studentsecond",{"1":{"111":1}}],["stuck",{"1":{"25":1}}],["still",{"1":{"90":1,"195":2}}],["st0+st2",{"0":{"52":1},"2":{"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1}}],["standalone",{"1":{"720":8}}],["standaloneinputmodule和touchinputmodule组件是系统提供的标准输入模块和触摸输入模块",{"1":{"654":1}}],["standardshaderquality选项在所有graphics",{"1":{"868":1}}],["standard",{"0":{"721":1},"1":{"22":2,"23":1,"131":2,"176":1,"721":5,"722":1,"839":2,"868":1},"2":{"722":1}}],["stack",{"1":{"899":4,"1021":1}}],["stackoverflow",{"1":{"617":1}}],["stacktrace",{"1":{"592":1}}],["stable",{"0":{"569":1},"1":{"564":1,"571":1}}],["stablediffusion",{"1":{"564":1}}],["star",{"1":{"427":1}}],["startlayout",{"1":{"499":2}}],["startinfo",{"1":{"424":2}}],["startdialoguewithplayer",{"1":{"253":1}}],["start",{"1":{"27":2,"224":1,"424":1,"498":2,"499":2}}],["starts",{"1":{"22":1,"27":2}}],["started",{"1":{"22":1,"147":2,"512":1,"543":1}}],["sta",{"1":{"404":1}}],["static即可",{"1":{"876":1}}],["static",{"1":{"191":1,"193":1,"225":2,"940":2,"952":1,"979":3,"980":1,"984":1}}],["statetermination",{"1":{"1043":1}}],["state中进行计算",{"1":{"69":1}}],["state更新",{"1":{"69":1}}],["state",{"0":{"14":1,"15":1,"931":1},"1":{"43":1,"90":2,"931":1,"932":1,"936":2,"971":3},"2":{"932":1,"933":1,"934":1,"935":1,"936":1}}],["staple",{"1":{"22":1}}],["stamp",{"1":{"15":1}}],["snapshotdata和snapshotdatabuffer服务端会添加predictedghostcomponent",{"1":{"1020":1}}],["snapshotdata类中在其中计算了interpolationfactor",{"1":{"1016":1}}],["snapshot默认一定会添加的组件",{"1":{"1020":1}}],["snapshot",{"1":{"13":1,"15":1}}],["syntax",{"1":{"509":1}}],["synthesize",{"1":{"206":2}}],["synchronization的一种改进",{"1":{"14":1}}],["synchronization",{"0":{"12":1,"13":1,"14":1},"1":{"12":3,"15":1}}],["sysytem",{"1":{"959":1,"1002":1}}],["sys",{"1":{"467":1}}],["sys等",{"1":{"131":1}}],["system会处理",{"1":{"954":1}}],["system介绍",{"1":{"926":1}}],["system的update是在主线程中执行的",{"1":{"917":1}}],["system的执行顺序会不太确定",{"1":{"917":1}}],["system的组织",{"0":{"917":1}}],["systembase",{"0":{"910":1}}],["system读取了多个实体的",{"1":{"904":1}}],["system里面",{"1":{"742":1}}],["systemd",{"1":{"467":1}}],["systems准备的么",{"1":{"965":1}}],["systems里面声明在扫描了接口之后",{"1":{"964":1}}],["systemstatecomponent",{"1":{"931":1}}],["systems",{"0":{"944":1},"1":{"22":1,"26":1,"947":1,"949":1,"952":1,"965":1,"969":1,"998":2}}],["system",{"0":{"597":1,"659":1,"661":1,"913":1,"931":1},"1":{"22":1,"39":2,"467":1,"593":1,"656":1,"657":1,"661":4,"684":1,"695":2,"705":2,"722":2,"823":7,"828":1,"841":1,"851":1,"919":1,"926":2,"931":2,"932":1,"936":2,"943":1,"944":2,"947":1,"948":2,"949":6,"950":5,"951":2,"955":9,"957":5,"961":1,"962":1,"963":1,"964":10,"965":2,"966":2,"968":2,"969":5,"971":1,"978":1,"998":1},"2":{"660":1,"661":1,"914":1,"915":1,"916":1,"917":1,"932":1,"933":1,"934":1,"935":1,"936":1}}],["system32",{"1":{"9":1}}],["oym",{"1":{"747":1}}],["obstacle",{"1":{"225":3}}],["objectes",{"1":{"968":1}}],["object的转换接口",{"1":{"1054":1}}],["object的",{"1":{"956":1}}],["object在进阶之前",{"1":{"946":1}}],["object>",{"1":{"822":1}}],["objects导入",{"1":{"951":1}}],["objects",{"0":{"689":1},"1":{"188":1,"195":1,"486":1,"689":2,"694":1,"927":1,"946":2,"951":1,"952":2,"954":2,"955":2,"956":2,"961":1}}],["object",{"0":{"969":1},"1":{"188":1,"189":1,"191":1,"193":1,"487":1,"657":1,"820":2,"822":3,"858":1,"882":3,"947":3,"951":1,"952":1,"954":1,"955":2,"961":1,"964":3,"968":3,"969":9,"971":1,"975":2,"982":1,"1005":1}}],["objectcopier使用il进行克隆一种罕见的解决方案是使用il",{"1":{"111":1}}],["octocat",{"1":{"542":1}}],["octave",{"1":{"204":1}}],["occurs",{"1":{"181":1}}],["ocx",{"1":{"131":1}}],["os会首先建立一个进程",{"1":{"707":1}}],["osx",{"1":{"720":2}}],["osx平台",{"1":{"591":1}}],["osxkeychain",{"1":{"411":2}}],["os",{"1":{"131":1,"524":1,"720":3}}],["other",{"1":{"90":2,"189":2,"190":1,"193":1,"195":1,"196":2,"489":1,"585":1}}],["opaquesortmode",{"0":{"1037":1},"1":{"1037":3}}],["opaque",{"1":{"975":2}}],["optimizingbuildtimes",{"1":{"606":1}}],["optimization",{"1":{"50":1,"81":1,"863":1}}],["optimisation",{"1":{"191":2}}],["option",{"1":{"195":1,"571":1}}],["options不一致",{"1":{"982":1}}],["options",{"1":{"173":1}}],["optional",{"1":{"131":3}}],["opengl",{"1":{"726":3}}],["open以降低延迟",{"1":{"467":1}}],["open",{"1":{"22":1,"184":1,"223":1,"467":1}}],["own",{"1":{"28":1}}],["overlay",{"1":{"976":1,"977":2,"1036":1}}],["overlay的模式下",{"1":{"640":1}}],["overview",{"1":{"878":1}}],["overridesorting",{"1":{"691":1}}],["overall",{"1":{"187":1,"191":1}}],["over",{"1":{"27":1,"532":1}}],["overwatch",{"1":{"15":1}}],["out",{"1":{"191":2,"193":1,"750":1,"751":1}}],["output",{"1":{"10":1,"592":1}}],["ourpalm",{"1":{"719":1}}],["ourselves",{"1":{"489":1}}],["our",{"1":{"26":1,"186":1,"187":5,"188":4,"189":2,"190":2,"191":1,"192":2,"193":8,"195":3,"196":2}}],["oriented",{"1":{"942":2,"943":1,"945":1}}],["orthographic",{"1":{"737":1,"975":1}}],["order關於同一個",{"1":{"977":1}}],["order",{"0":{"975":1,"977":1},"1":{"955":1,"974":1,"975":8,"976":3,"977":8,"978":6},"2":{"976":1,"977":1,"978":1}}],["order越大越在上层",{"1":{"695":1}}],["ordering",{"1":{"195":1}}],["org",{"1":{"96":1,"398":1,"404":1,"566":1,"567":1,"666":1,"789":2,"833":1}}],["orleans",{"1":{"90":2,"162":1}}],["orleans支持",{"0":{"90":1}}],["or",{"0":{"974":1},"1":{"22":2,"25":1,"27":2,"28":1,"29":1,"186":3,"188":3,"191":1,"193":2,"196":1,"206":1,"270":1,"471":1,"571":2,"628":1,"644":1,"652":1,"720":2,"737":1,"872":1}}],["old",{"1":{"22":1}}],["onupdate",{"1":{"1014":1}}],["onscreen",{"1":{"759":1}}],["onmouse依赖于tag为maincamera相机的culling",{"1":{"655":1}}],["onmouse脚本与rigidbody在一起就可以检测所有的子节点collider",{"1":{"655":1}}],["onmouse脚本需要在同一个gameobject上挂载collider才能检测",{"1":{"655":1}}],["onmouse",{"1":{"655":1}}],["onmouse处理函数可以是协程",{"1":{"652":1}}],["onmouse事件会默认依赖main",{"1":{"663":1}}],["onmouse事件会在update之前调用",{"1":{"653":1}}],["onmouse事件在",{"1":{"652":1}}],["onmouse事件",{"0":{"652":1},"2":{"653":1}}],["ondeserialized",{"1":{"486":1}}],["once",{"1":{"27":1}}],["onenable回调",{"1":{"860":1}}],["onentityupdated来直接响应entity的变化",{"1":{"740":1}}],["onentityremoved",{"1":{"740":1}}],["oneyoungmean",{"1":{"747":1}}],["ones",{"1":{"190":1,"191":1,"195":1}}],["one",{"1":{"22":1,"26":1,"27":1,"28":1,"90":1,"187":2,"189":2,"191":2,"192":1,"194":1,"471":1,"720":1,"896":1,"899":1}}],["only",{"1":{"22":3,"25":2,"26":2,"27":1,"28":1,"90":1,"186":1,"188":1,"191":1,"196":1}}],["on",{"0":{"489":1},"1":{"15":1,"22":6,"26":1,"28":1,"29":1,"181":1,"189":1,"193":1,"195":1,"487":1,"506":1,"542":1,"662":1,"720":2,"851":1,"867":1,"1052":1}}],["off",{"1":{"976":1}}],["offscreen",{"1":{"759":6}}],["offsetmax",{"0":{"641":1},"1":{"641":1}}],["offsetmin",{"0":{"641":1}}],["offers",{"1":{"188":1}}],["of",{"1":{"10":1,"15":1,"22":9,"25":3,"26":6,"27":6,"90":1,"181":1,"186":1,"187":2,"188":9,"189":12,"190":1,"192":2,"193":5,"195":5,"196":5,"225":1,"487":2,"489":3,"579":1,"588":1,"644":3,"737":1,"764":1,"823":4,"851":2,"863":1,"896":1}}],["et的热重载",{"0":{"1050":1}}],["etc",{"0":{"464":1},"1":{"467":1,"486":1}}],["ed",{"1":{"971":1}}],["editing",{"1":{"971":1}}],["edition=yidianzixun",{"1":{"211":1}}],["editorsetting",{"0":{"868":1}}],["editorcurves",{"1":{"866":1}}],["editor文件夹以外script",{"1":{"839":1}}],["editor会按照脚本的依赖关系编译代码",{"1":{"839":1}}],["editor勾选掉了",{"1":{"834":1}}],["editor和play模式引用原始源纹理而不是sprite",{"1":{"703":1}}],["editor中合成的大图是放在缓存目录里",{"1":{"703":1}}],["editor",{"1":{"186":1,"720":6,"845":1,"1016":1}}],["edit",{"0":{"647":1,"650":1},"1":{"186":1,"703":1,"721":1,"971":7}}],["equals",{"1":{"820":1,"822":1}}],["equals函数中",{"1":{"820":1}}],["equivalent",{"1":{"720":1}}],["emit和反射",{"1":{"709":1}}],["emit",{"0":{"597":1},"1":{"592":1}}],["ema",{"1":{"568":2}}],["empty",{"0":{"486":1},"1":{"23":1,"486":1}}],["error",{"1":{"485":1}}],["e8e4c3f4280c",{"1":{"747":1}}],["e8",{"1":{"287":7}}],["e6",{"1":{"287":14}}],["e7",{"1":{"287":7}}],["else",{"1":{"737":1}}],["else把select",{"1":{"282":1}}],["elements",{"1":{"662":1}}],["elias",{"1":{"204":1}}],["eboss",{"1":{"266":1}}],["e中一点",{"1":{"207":1}}],["ever",{"1":{"195":1}}],["everything",{"1":{"930":2}}],["every",{"1":{"22":1,"26":3,"27":1,"28":1,"81":1,"186":1,"195":1}}],["eventposition",{"1":{"688":1}}],["eventcamera",{"1":{"683":1,"687":1,"688":1}}],["eventtrigger",{"1":{"657":4}}],["events",{"1":{"700":1}}],["eventsystem处理函数最前面是判断是否处于聚焦状态",{"1":{"668":1}}],["eventsystem的ispointerovergameobject",{"1":{"665":1}}],["eventsystem的supportevents的接口全部被应用到了physics上面",{"1":{"665":1}}],["eventsystem的脚本会根据子节点的collider来触发",{"1":{"655":1}}],["eventsystem则是依赖挂载physics",{"1":{"655":1}}],["eventsystem與onmouse的區別",{"0":{"655":1}}],["eventsystem负责管理",{"1":{"654":1}}],["eventsystem下的所有输入模块都必须继承自baseinputmodule组件",{"1":{"654":1}}],["eventsystem在一开始的时候会把自己所属对象下的baseinputmodule类型组件加到一个内部列表",{"1":{"654":1}}],["eventsystem组件主要负责处理输入",{"1":{"654":1}}],["eventsystem",{"0":{"654":1,"662":1},"1":{"655":1,"658":1,"668":1,"695":1},"2":{"663":1,"664":1,"665":1}}],["events相关的",{"1":{"592":1}}],["event",{"1":{"652":1,"656":1,"657":3,"661":1,"684":1,"695":1}}],["eventfunctions",{"1":{"652":1}}],["eventually",{"1":{"193":1}}],["even",{"1":{"191":1,"193":1,"195":1}}],["either",{"1":{"189":1,"191":1,"571":1,"585":1}}],["esc",{"1":{"464":1}}],["especially",{"1":{"189":1,"192":1}}],["essentially",{"1":{"186":1}}],["es",{"1":{"155":2}}],["ecidevilin",{"1":{"850":1}}],["echo",{"1":{"467":1}}],["ecma",{"1":{"126":1}}],["ecsで配列を格納する",{"1":{"937":1}}],["ecs简单示例",{"1":{"919":1}}],["ecs通过",{"1":{"917":1}}],["ecs提供了",{"1":{"916":1}}],["ecs配合job使用才能发挥多线程的威力",{"1":{"916":1}}],["ecs中有一个",{"1":{"906":1}}],["ecs会创建一个默认的world",{"1":{"917":1}}],["ecs会追踪哪些job在读写哪些组件",{"1":{"916":1}}],["ecs会在主线程调度job",{"1":{"916":1}}],["ecs会把这个内存块最后的实体数据移动到这个空位中",{"1":{"905":1}}],["ecs会将它放到对应原型的第一个还有空间的内存块中",{"1":{"905":1}}],["ecs会分配一个新的块来存储新的实体的components",{"1":{"905":1}}],["ecs在存储实体到内存块中没有特殊的排序",{"1":{"905":1}}],["ecs按块分配内存",{"1":{"905":1}}],["ecs核心概念",{"0":{"904":1},"2":{"905":1,"906":1,"907":1,"908":1,"909":1,"910":1,"911":1,"912":1,"913":1,"914":1,"915":1,"916":1,"917":1,"918":1}}],["ecs",{"0":{"955":1},"1":{"15":1,"919":1,"930":1,"931":1,"932":1,"937":1,"938":1,"939":1,"940":4,"941":1,"942":2,"944":4,"945":3,"946":1,"947":1,"952":2,"953":1,"954":1,"955":8,"956":3,"958":1,"964":1,"967":2,"968":2,"969":2,"971":2,"998":4,"1001":1,"1005":2}}],["eg",{"1":{"90":2}}],["each",{"1":{"27":1,"90":1,"191":2,"484":1,"644":1}}],["earlier",{"1":{"26":1}}],["ease",{"1":{"188":1,"195":2,"196":1,"197":2}}],["easier",{"1":{"29":1,"195":1}}],["easily",{"1":{"22":1,"27":1,"186":2,"188":1,"189":2,"192":1,"195":1}}],["easy",{"1":{"23":1,"188":1,"190":1,"193":1}}],["e",{"1":{"22":1,"25":1,"188":1,"207":3,"800":1,"903":2,"952":3,"977":1,"978":2}}],["except",{"1":{"737":1}}],["exceptions",{"1":{"592":1}}],["exit信息",{"1":{"795":1}}],["exit",{"1":{"793":1,"805":1}}],["exit以及begindrag还有drag等逻辑",{"1":{"673":1}}],["exit时会reset",{"1":{"277":1}}],["ex",{"1":{"575":2}}],["exactly",{"1":{"187":1,"188":1,"189":1,"190":1,"193":1}}],["examples",{"1":{"26":1}}],["example",{"0":{"10":1},"1":{"22":1,"26":1,"28":2,"29":2,"186":1,"187":1,"191":1,"485":2,"486":1,"487":1,"488":1}}],["experimental",{"1":{"868":1}}],["expected",{"1":{"193":1}}],["explanation",{"1":{"764":1,"789":1}}],["explained",{"1":{"181":1}}],["explorer来对il2cpp的命令行进行观察",{"1":{"592":1}}],["explorer",{"1":{"566":1}}],["exploer",{"1":{"566":1}}],["export",{"1":{"499":2,"949":1,"965":2}}],["expand适配的计算公式同上",{"1":{"628":1}}],["expand",{"1":{"188":1}}],["expressions",{"1":{"26":2}}],["expression",{"1":{"26":2,"509":1}}],["exe生成的代码会是个什么样子",{"1":{"595":1}}],["exe代码生成的细节中",{"1":{"595":1}}],["exe命令行",{"1":{"592":1}}],["exe会将最终的c++代码生成到这里",{"1":{"592":1}}],["exe会将在这个文件中出现的基本类型或者数组类型看作是在运行时生成的而不是一开始出现在il代码中来对待",{"1":{"592":1}}],["exe会根据引用关系自动加入",{"1":{"592":1}}],["exe会在内部自动引用这些程序集",{"1":{"592":1}}],["exe工具可以接收一个由il程序集组成的列表",{"1":{"592":1}}],["exe工具本身",{"1":{"592":1}}],["exe的参数也会相应的发生变化",{"1":{"592":1}}],["exe的命令行参数整理固定下来的阶段",{"1":{"592":1}}],["exe的而不是mono",{"1":{"592":1}}],["exe不对生成的c++文件进行copy操作",{"1":{"592":1}}],["exe不仅可以构建c",{"1":{"125":1}}],["exe这个工具是一个托管代码可执行文件",{"1":{"590":1}}],["exe应用商店",{"1":{"533":1}}],["exe还需要安装1",{"1":{"524":1}}],["executing",{"1":{"720":7}}],["executioninfo是需要手动定义的",{"1":{"1043":1}}],["executioninfo",{"1":{"1043":1}}],["executionorder",{"1":{"652":1}}],["executionpolicy",{"1":{"424":1}}],["execution",{"1":{"131":1,"955":1}}],["execute方法会在一个内核上执行完毕",{"1":{"920":1}}],["executehierarchy",{"1":{"680":1}}],["execute<",{"1":{"657":1}}],["executeevents静态类还有其他方法",{"1":{"661":1}}],["executeevents",{"0":{"678":1},"1":{"657":1}}],["execute",{"0":{"678":1},"1":{"131":1,"575":1,"678":1,"911":1}}],["exe或其他内容",{"1":{"125":1}}],["exe就足够了",{"1":{"125":1}}],["exe及其它内容",{"1":{"125":1}}],["exe并使用",{"1":{"125":1}}],["exe",{"0":{"130":1},"1":{"125":2,"128":1,"130":2,"131":1,"424":1,"437":1,"567":1,"574":1,"590":1,"592":2}}],["externals",{"0":{"537":1},"1":{"534":1,"537":2}}],["extention",{"1":{"111":1}}],["extensions",{"1":{"173":1}}],["extension",{"1":{"27":1,"183":1,"939":1}}],["extending",{"1":{"27":1,"140":1}}],["extremely",{"1":{"196":1}}],["extrapolate",{"1":{"83":2}}],["extra",{"0":{"140":1},"1":{"22":1}}],["engity",{"1":{"964":1}}],["engine",{"1":{"125":1}}],["enumerator",{"1":{"823":4}}],["enum",{"1":{"822":1,"881":1}}],["enemy的世界坐标与avatar世界坐标相减",{"1":{"771":1}}],["enable",{"1":{"585":1,"592":3}}],["enabled",{"1":{"181":1,"703":3,"869":1}}],["environment",{"1":{"515":1}}],["env",{"1":{"424":2}}],["enjoy",{"1":{"196":1}}],["encodetojpg",{"1":{"1033":1}}],["encoding",{"1":{"39":2,"186":1}}],["encourage",{"1":{"195":1}}],["enough",{"1":{"189":1,"571":1}}],["en",{"1":{"96":1,"153":2,"155":1,"181":1,"185":1,"499":1,"606":1}}],["enitiy插值平滑",{"0":{"83":1}}],["entire",{"1":{"188":1,"190":1}}],["entitas",{"1":{"747":2}}],["entitas執行流程",{"0":{"738":1}}],["entities",{"0":{"910":1},"1":{"140":1,"914":1,"927":2,"930":3,"960":2,"971":1}}],["entityguid",{"1":{"971":1}}],["entity基本上",{"1":{"969":1}}],["entity字段即可",{"1":{"967":1}}],["entity上",{"1":{"964":1}}],["entityprefab",{"1":{"964":1}}],["entity了",{"1":{"964":1}}],["entity时",{"1":{"959":1,"1002":1}}],["entity占用",{"1":{"943":1}}],["entityquery",{"1":{"910":2,"912":2,"966":1}}],["entitymanager",{"1":{"966":1,"969":1}}],["entitymanageraccesscomponentdata",{"1":{"930":1}}],["entitymanager也提供了方法用来添加",{"1":{"908":1}}],["entitymanager会持续跟踪这些实体原型",{"1":{"906":1}}],["entity的方法",{"1":{"964":1}}],["entity的",{"1":{"944":1,"1000":1}}],["entity的原型会发生变化",{"1":{"908":1}}],["entity的collector",{"1":{"742":1}}],["entityarchetype",{"1":{"906":1}}],["entity不应该被ecs系统外的模块持有",{"1":{"739":1}}],["entityindex",{"1":{"738":1}}],["entityframeworkcore项目中删除之前的迁移目录",{"1":{"132":1}}],["entity",{"0":{"906":1,"947":1,"961":1,"962":1,"963":1},"1":{"77":1,"132":1,"742":1,"915":1,"919":1,"929":1,"931":2,"942":1,"943":2,"944":3,"945":2,"946":3,"947":14,"948":1,"949":1,"950":1,"951":3,"952":1,"953":3,"954":2,"955":4,"956":1,"957":4,"958":6,"959":1,"960":3,"961":6,"962":4,"963":6,"964":12,"965":21,"966":8,"968":2,"969":7,"970":2,"971":3,"1000":3,"1001":6,"1002":1,"1003":4,"1054":2},"2":{"907":1,"908":1,"909":1,"910":1,"911":1,"912":1}}],["enter",{"1":{"103":1,"104":2,"793":1,"805":2}}],["enterprise",{"1":{"22":1}}],["ensures",{"1":{"28":1}}],["ensure",{"1":{"22":1}}],["endfinally",{"1":{"823":1}}],["endpoint",{"1":{"167":1}}],["endian方式来存储数据",{"1":{"34":1}}],["endian方式存储数据",{"1":{"33":2,"34":1}}],["endian",{"1":{"32":2,"33":5,"38":2}}],["endian则是低地址存放最低有效字节",{"1":{"32":1}}],["endian是指低地址存放最高有效字节",{"1":{"32":1}}],["endia",{"0":{"32":1},"2":{"33":1,"34":1}}],["end",{"1":{"15":2,"25":1,"27":1,"195":1,"823":4}}],["ef",{"1":{"28":1}}],["effectiveunity",{"1":{"998":1}}],["effective",{"1":{"998":1}}],["effectively",{"1":{"25":1}}],["effect",{"1":{"737":1}}],["efficient",{"1":{"15":1,"191":1,"998":1}}],["efcore",{"0":{"7":1}}],["aiplanner倒是不需要这个",{"1":{"1045":1}}],["av49115670",{"0":{"1030":1}}],["av49098444",{"0":{"1029":1}}],["av49083381",{"0":{"1028":1}}],["av48965588",{"0":{"1027":1}}],["avoid",{"0":{"485":1},"1":{"489":1}}],["a2",{"1":{"947":1}}],["a1",{"1":{"947":1}}],["a实际上指向原始x声明时所在的内存地址",{"1":{"891":1}}],["austin",{"1":{"1052":1}}],["audio",{"0":{"867":1}}],["authoring",{"1":{"946":1,"967":2}}],["authority客户端表现完美",{"1":{"804":1}}],["authority表示单位的主控端",{"1":{"801":1}}],["authentication",{"1":{"181":1}}],["auto",{"1":{"746":1,"1016":1}}],["automatic1111",{"1":{"564":1,"567":1}}],["automatic",{"1":{"193":1,"833":1}}],["awake",{"1":{"858":1,"970":1}}],["awake中rectangle还没有初始化出来",{"1":{"642":1}}],["a状态清除状态x",{"1":{"800":1}}],["a状态挂上去同时导致b状态消失",{"1":{"800":1}}],["a状态在",{"1":{"800":1}}],["aab",{"1":{"587":1}}],["aes",{"0":{"470":1}}],["aotu",{"1":{"770":1}}],["aot",{"1":{"597":1,"598":2,"709":1}}],["aot编译器实际的执行文件是il2cpp",{"1":{"590":1}}],["aot编译器",{"0":{"590":1}}],["aot编译器将由",{"1":{"589":1}}],["aof",{"0":{"443":1,"447":1,"451":1,"452":1,"453":1,"454":1,"455":1,"456":1},"1":{"443":12,"444":1,"445":3,"446":4,"447":1,"448":1,"449":1,"451":4,"452":11,"453":12,"454":4,"455":27,"456":12,"457":7},"2":{"448":1,"449":1,"450":1}}],["aoi其实就是处理地图视野的一个设计",{"1":{"104":1}}],["aoi的js实现看了一遍",{"1":{"104":1}}],["aoi前几天把pomelo中的tower",{"1":{"104":1}}],["aoi",{"1":{"103":1,"104":2,"105":1}}],["axis",{"0":{"753":1,"761":1},"1":{"406":2,"764":4,"789":1,"975":1},"2":{"762":1,"763":1,"764":1,"765":1,"766":1,"767":1,"768":1,"769":1,"770":1}}],["ahead",{"1":{"588":1}}],["ahjmgzs",{"1":{"385":1}}],["ahuangege",{"1":{"104":1}}],["a4",{"1":{"287":3}}],["a6",{"1":{"287":4}}],["after",{"1":{"486":1,"487":1,"571":1}}],["afterwards",{"1":{"27":1}}],["af",{"1":{"287":7}}],["a=2",{"1":{"270":2}}],["a=",{"1":{"270":2}}],["agree",{"1":{"196":1}}],["against",{"1":{"662":1,"720":2}}],["again",{"1":{"191":1,"193":1,"194":1}}],["ads",{"1":{"720":2}}],["advertising",{"1":{"607":1}}],["advantageous",{"1":{"195":1}}],["advantages",{"1":{"193":1,"737":1}}],["advantage",{"1":{"189":1}}],["adapt",{"1":{"192":1}}],["addgameobjectorprefab",{"1":{"999":1}}],["addhybridcomponent",{"1":{"969":1}}],["addfive",{"1":{"891":1}}],["adddebugmessage就会被debugmessagesystem收集了",{"1":{"742":1}}],["addownloadsfavoritescontactsdesktoplinkssaved",{"1":{"410":1}}],["adding",{"1":{"192":1,"193":1}}],["additionally",{"1":{"720":2}}],["additional",{"1":{"196":1}}],["addition",{"1":{"188":1}}],["addit",{"1":{"185":1}}],["addressables",{"0":{"900":1},"1":{"903":2}}],["addressables是否能够正确的清理内存主要的取决于是否正确的进行镜像资源的加载与卸载",{"1":{"696":1}}],["addressable",{"1":{"701":1}}],["addressableassetsettings",{"1":{"700":1}}],["addressableassetsdata",{"1":{"700":1}}],["addressable分析工具",{"0":{"700":1}}],["addressable会自动实例化",{"1":{"699":1}}],["addressbinder使用",{"1":{"167":1}}],["address",{"1":{"131":1,"467":2}}],["added",{"1":{"27":1}}],["adds",{"1":{"26":1,"571":1}}],["add",{"1":{"26":1,"106":1,"184":1,"192":2,"533":1,"567":1,"739":1,"822":2,"823":1}}],["a|b",{"1":{"177":1}}],["a作为b",{"1":{"124":1}}],["a对象没有被其他引用",{"1":{"124":1}}],["achieving",{"1":{"196":1}}],["acing",{"1":{"196":1}}],["accelerometer",{"1":{"868":1}}],["acceptlanguageheaderrequestcultureprovider",{"0":{"154":1}}],["accum",{"1":{"823":2}}],["accurate",{"1":{"189":1}}],["acme",{"1":{"184":1}}],["action",{"1":{"510":2,"705":2,"805":1,"1043":1}}],["actions",{"0":{"517":1,"1044":1},"1":{"509":1,"510":1,"515":1}}],["activation",{"1":{"90":1}}],["active",{"1":{"88":1,"90":2,"585":1,"695":1}}],["actually",{"1":{"27":1,"189":1}}],["actual",{"1":{"24":1}}],["ack",{"1":{"51":1}}],["amd",{"0":{"551":1}}],["amplitudes",{"1":{"204":1}}],["amount",{"1":{"83":1,"189":1}}],["am",{"1":{"26":2}}],["apk已使用发行证书进行",{"1":{"615":1}}],["apk内置于发行模式",{"1":{"615":1}}],["apk可以使用谷歌提供的测试地址下载",{"1":{"613":1}}],["apk",{"1":{"610":1}}],["apks",{"1":{"585":1}}],["apache",{"0":{"431":1},"1":{"573":1},"2":{"432":1}}],["api提供了多种遍历的方式",{"1":{"909":1}}],["api",{"0":{"722":1,"824":1,"993":1},"1":{"25":1,"129":1,"570":1,"721":4,"722":3,"726":1,"824":1,"851":1,"855":2,"858":4,"878":1,"941":2,"942":3,"946":3,"964":1}}],["appdomain和程序集的源代码是什么关系呢",{"1":{"707":1}}],["appdomain用来隔离对象",{"1":{"707":1}}],["appdomain是个静态概念",{"1":{"707":1}}],["appdomain被创建在进程中",{"1":{"707":1}}],["appdomain",{"0":{"707":1},"1":{"707":5}}],["appdata",{"1":{"421":1,"497":1,"498":1,"526":1}}],["apple",{"1":{"720":1}}],["apply",{"1":{"571":1,"858":1}}],["applied",{"1":{"191":1}}],["application协议的web框架",{"1":{"578":1}}],["application的框架",{"1":{"578":1}}],["application",{"1":{"22":3,"23":1,"27":2,"140":1,"193":1,"855":2}}],["applications",{"1":{"22":1,"189":1,"720":2}}],["applicatins",{"1":{"15":1}}],["approach",{"1":{"27":1,"28":1,"29":1,"191":2,"193":1,"195":1,"489":1}}],["app",{"1":{"22":1,"27":1,"427":1,"585":1,"586":1,"587":1,"607":1,"719":1}}],["appsettings",{"1":{"172":1}}],["apps",{"1":{"22":1,"437":1,"611":1}}],["alphatest",{"1":{"975":1,"976":1,"1036":3}}],["algorithm",{"1":{"975":2}}],["alive",{"1":{"930":1}}],["aligned",{"0":{"753":1}}],["alias",{"1":{"424":2}}],["ali213",{"1":{"385":1}}],["alternative",{"1":{"196":1}}],["alternatives",{"1":{"186":1}}],["almost",{"1":{"188":1,"195":1}}],["already",{"1":{"90":1}}],["always",{"1":{"90":1,"193":1,"703":1}}],["allocator",{"1":{"1022":4}}],["allocated",{"1":{"193":2}}],["allocate",{"1":{"193":2}}],["alloc高意味着在unity中执行会存在较大的性能问题",{"1":{"718":1}}],["alloc",{"1":{"718":1,"815":2,"878":3}}],["allowparseabletypes",{"0":{"488":1},"1":{"488":1}}],["allowing",{"1":{"188":1,"190":1}}],["allow",{"1":{"26":1,"188":1,"195":1}}],["allows",{"1":{"22":1,"90":1}}],["all",{"1":{"26":2,"27":2,"185":1,"188":1,"190":1,"193":1,"484":1,"571":1,"662":1,"915":1}}],["also",{"1":{"22":2,"24":1,"191":1,"487":1}}],["attention",{"1":{"571":2}}],["attribute",{"1":{"24":2,"188":1,"486":1,"948":2}}],["atlas",{"1":{"872":1}}],["atlasrequested只会请求一次无论成功还是失败",{"1":{"705":1}}],["atlasrequested",{"1":{"705":2}}],["atlases中",{"1":{"703":1}}],["atlas中的纹理",{"1":{"703":1}}],["atlas中",{"1":{"703":1}}],["atlassian",{"1":{"421":1}}],["atl或者win32开头的项目类型",{"1":{"127":1}}],["atl",{"1":{"127":1}}],["at",{"1":{"22":3,"25":1,"27":2,"188":1,"193":1,"196":1}}],["arkish",{"1":{"850":1}}],["archetype",{"1":{"952":1}}],["archetypes",{"0":{"905":1}}],["architectureor",{"1":{"585":1}}],["architecture",{"1":{"65":1}}],["architectures",{"1":{"15":1,"720":1}}],["arcsin",{"1":{"781":1}}],["arccos",{"1":{"780":1}}],["arm64",{"1":{"585":1}}],["arm既可以工作在大端模式",{"1":{"33":1}}],["argument",{"1":{"571":2}}],["arguments",{"1":{"424":1}}],["argue",{"1":{"195":1}}],["arbitrary",{"1":{"190":1}}],["array",{"1":{"187":1,"188":2,"189":5,"190":1,"193":2,"195":7,"489":2,"592":1,"1022":1}}],["arrays",{"0":{"186":1},"1":{"186":1,"188":1,"194":1,"196":1}}],["artasccope",{"1":{"103":1}}],["article",{"1":{"81":1,"197":1,"850":2,"984":1}}],["around",{"1":{"28":1,"188":1,"191":1}}],["are",{"1":{"22":1,"24":1,"25":1,"26":1,"27":1,"28":1,"90":3,"185":1,"186":2,"187":4,"188":3,"189":2,"190":1,"192":1,"193":2,"195":2,"486":2,"487":1,"489":2,"644":2,"662":1,"851":1}}],["async",{"1":{"903":1}}],["asynchronous",{"1":{"24":1}}],["asgi对于wsgi原有的模式的支持和websocket的扩展",{"1":{"584":1}}],["asgi尝试保持在一个简单的应用接口的前提下",{"1":{"583":1}}],["asgi",{"0":{"583":1}}],["ash258",{"1":{"436":1}}],["aschasnonetags",{"1":{"240":1}}],["aschasalltags",{"1":{"240":1}}],["assertions",{"1":{"720":2}}],["assembly不能单独执行",{"1":{"707":1}}],["assembly是",{"1":{"707":1}}],["assembly",{"1":{"592":1,"707":3,"708":1}}],["assetentity有某些关系",{"1":{"965":1}}],["asset添加进ideclarereferencedprefabs",{"1":{"964":1}}],["asset在",{"1":{"964":1}}],["assetbundle",{"0":{"874":1}}],["asset",{"0":{"964":1,"965":1,"966":1},"1":{"186":1,"510":1,"527":1,"943":1,"959":1,"964":17,"965":8,"966":2,"967":1,"968":1,"969":1,"970":1,"971":2}}],["assets或plugins文件夹中",{"1":{"839":1}}],["assets和plugins文件夹中的runtime",{"1":{"839":1}}],["assets",{"1":{"186":1,"839":2,"964":1,"1011":1}}],["assume",{"1":{"184":1}}],["assigning",{"1":{"27":1}}],["asp这样的文件",{"1":{"573":1}}],["aspnetcore项目中",{"1":{"166":1}}],["aspnetcore项目中defaultabprequestlocalizationoptionsprovider",{"1":{"156":1}}],["aspnetcore",{"1":{"153":1,"166":2}}],["asp",{"1":{"22":6,"23":1,"25":1,"29":1,"30":1,"155":1,"163":1,"166":1,"171":1}}],["as",{"1":{"22":2,"25":1,"26":2,"27":1,"28":3,"29":1,"186":3,"188":2,"189":2,"193":5,"195":1,"488":1,"489":1,"644":1,"720":1,"737":1}}],["anim动画文件",{"1":{"866":1}}],["anim文件中的浮点精度custom",{"1":{"866":1}}],["animator",{"1":{"858":3}}],["animatorcontroller",{"0":{"601":1},"1":{"601":1}}],["animation",{"0":{"866":1},"1":{"851":1}}],["animalaction",{"1":{"242":1}}],["angle",{"1":{"771":1}}],["angle来计算",{"1":{"749":1}}],["analytics",{"1":{"720":2}}],["analysis",{"1":{"196":1}}],["anchormax",{"0":{"643":1}}],["anchormin",{"0":{"643":1}}],["anchors",{"1":{"633":1,"644":3}}],["anchor",{"0":{"633":1},"1":{"639":1,"650":2},"2":{"634":1,"635":1,"636":1,"637":1}}],["another",{"1":{"189":1,"192":1}}],["any",{"1":{"22":2,"26":1,"28":1,"188":1,"190":1,"193":3,"720":1,"915":1}}],["android设置中的managedstrippinglevel选项应为medium或者high",{"1":{"868":1}}],["android刘海屏适配方案总结",{"1":{"631":1}}],["androidmanifest必须包含",{"1":{"615":1}}],["android",{"1":{"585":1,"587":1,"615":1,"720":2}}],["anderson随机生成的地图是",{"1":{"217":1}}],["and",{"0":{"954":1},"1":{"22":2,"23":1,"24":1,"25":3,"26":5,"27":10,"28":2,"29":1,"50":1,"81":1,"90":1,"186":5,"187":3,"188":4,"189":8,"190":5,"191":5,"192":2,"193":6,"194":2,"195":9,"196":3,"225":1,"471":1,"485":1,"487":1,"488":1,"499":1,"509":1,"515":1,"571":2,"575":1,"585":3,"662":1,"720":4,"737":2,"744":1,"764":1,"770":1,"845":2,"851":1,"869":1,"951":1,"952":2,"953":1,"954":2,"955":1,"956":1,"966":1,"970":2,"980":1,"1005":2,"1034":1,"1041":1}}],["an",{"0":{"24":1,"25":1},"1":{"15":1,"22":1,"23":1,"24":1,"25":2,"26":2,"27":3,"28":2,"188":1,"189":3,"190":1,"191":1,"485":1,"606":1,"998":1}}],["a可能预测错的情况",{"1":{"15":1}}],["a不做任何处理",{"1":{"15":1}}],["abilitycollection",{"0":{"1007":1}}],["abilitymeleeauthoring",{"1":{"1006":1}}],["abilitymovementauthoring",{"1":{"1006":1}}],["abilityselectslotauthoring",{"1":{"1006":1}}],["abilitysprintauthoring",{"1":{"1006":1}}],["abilitydeadauthoring",{"1":{"1006":1}}],["ability",{"0":{"1006":1},"2":{"1007":1}}],["abilitytags",{"0":{"239":1}}],["ability的cost和cooldown都使用了gameplayeffectscriptableobject",{"1":{"235":1}}],["ability的其他数据例如等级",{"1":{"234":1}}],["abstractabilityspec是技能的runtime",{"1":{"234":1}}],["abp的实现",{"0":{"156":1},"2":{"157":1}}],["abp的dbcontext是分成两种的",{"1":{"136":1}}],["abp是依托与aspnetcore的",{"1":{"150":1}}],["abp默认语言规则",{"0":{"150":1},"2":{"151":1,"152":1,"153":1,"154":1,"155":1,"156":1,"157":1}}],["abp使用了scriban文本模板语言引擎",{"1":{"147":1}}],["abpframework",{"1":{"137":2,"147":1}}],["abp",{"1":{"132":2,"137":2,"140":2,"144":1,"147":3,"156":1}}],["about",{"1":{"81":1,"126":1,"187":1,"189":2,"195":1,"485":1,"489":1,"930":2}}],["above",{"1":{"25":1,"190":1,"720":2}}],["able",{"1":{"25":1,"186":1,"189":1}}],["ab可能已经执行到104了",{"1":{"15":1}}],["ab收到了服务器确认的100帧的数据",{"1":{"15":1}}],["a和b各自去核对服务器的数据和自己预测的数据是否相同",{"1":{"15":1}}],["a和b各自预测对方的操作",{"1":{"15":1}}],["a和b都通知服务器",{"1":{"15":1}}],["a执行移动",{"1":{"15":1}}],["a执行了移动",{"1":{"15":1}}],["a",{"0":{"10":1,"18":1,"634":1},"1":{"15":4,"22":19,"23":1,"24":2,"25":3,"26":6,"27":3,"28":9,"29":1,"90":6,"107":1,"186":3,"187":3,"188":6,"189":8,"190":1,"192":3,"193":3,"194":1,"195":3,"196":4,"270":4,"471":1,"485":1,"486":2,"487":1,"488":1,"489":1,"543":1,"567":1,"571":3,"617":1,"633":1,"737":1,"756":4,"771":2,"780":4,"781":1,"822":2,"903":2,"911":1,"931":6,"933":1,"947":3,"952":4,"969":1,"980":1,"984":2,"987":1}}],["最後才處理",{"1":{"977":1}}],["最後一场战斗如果有人失血过多的话要退一下补血",{"1":{"377":1}}],["最上面的",{"1":{"971":1}}],["最底下",{"1":{"862":1}}],["最有关系的代码是靠近最后的",{"1":{"823":1}}],["最节省的方式是proxy根本不接受技能树同步信息",{"1":{"805":1}}],["最简单最暴力的方式",{"1":{"805":1}}],["最简单的方式是在状态a中直接填写状态关系状态字段",{"1":{"800":1}}],["最简单的方法就是随机的去查找方块",{"1":{"220":1}}],["最值得注意的是",{"1":{"785":1}}],["最小平移向量",{"0":{"765":1}}],["最直接有效的还是多层次背景模拟出视差效果",{"1":{"724":1}}],["最突出的一点就是通过反射来调用接口调用效率会比直接调用低很多",{"1":{"718":1}}],["最下面两句才是针对所有的touch以及mouse的操作的处理",{"1":{"668":1}}],["最佳的方式去关联entity和prefab",{"0":{"1005":1}}],["最佳模式新建一个aot场景",{"1":{"598":1}}],["最佳方式是使用模板",{"1":{"436":1}}],["最早的",{"1":{"573":1}}],["最近点",{"1":{"755":1}}],["最近在打包",{"1":{"534":1}}],["最近source引擎的游戏有cl",{"1":{"83":1}}],["最末尾添加两句话保存",{"1":{"493":1}}],["最低限度为50",{"1":{"391":1}}],["最多只丢失一个命令的数据",{"1":{"451":1}}],["最多75",{"1":{"384":2}}],["最多5层爆炸箭矢x",{"1":{"384":1}}],["最多叠加20层腐化之血状态ix",{"1":{"384":1}}],["最多收获次数",{"1":{"303":2}}],["最大检测距离",{"1":{"684":1}}],["最大與最小錨點們",{"1":{"633":1}}],["最大值",{"1":{"393":1}}],["最大生命值+12",{"1":{"392":6}}],["最大生命值",{"1":{"390":1}}],["最大生命偷取速率ii",{"1":{"384":1}}],["最大90",{"1":{"384":1}}],["最大闪电抗性上限viii",{"1":{"384":1}}],["最大火焰抗性上限vii",{"1":{"384":1}}],["最大冰霜抗性上限vi",{"1":{"384":1}}],["最大混沌抗性上限v",{"1":{"384":1}}],["最大格挡值iv",{"1":{"384":1}}],["最大魔力+6",{"1":{"392":6}}],["最大魔力偷取速率iii",{"1":{"384":1}}],["最大魔力上限回复速度ii",{"1":{"384":1}}],["最大能量护盾的充能速度iii",{"1":{"384":1}}],["最大限度提高门派发展的效率",{"1":{"382":1}}],["最大暂停时间短",{"1":{"115":1}}],["最少要4万现金和各2万资源再过去比较好",{"1":{"376":1}}],["最高练武经验上限",{"1":{"374":1}}],["最高效率就是领悟",{"1":{"372":1}}],["最准确的就是看他写秘笈有几根蜡烛",{"1":{"374":1}}],["最基本的生成方法类包括",{"1":{"226":1}}],["最好完全避免在生产代码中使用",{"1":{"858":1}}],["最好尽量避免分配",{"1":{"829":1}}],["最好的方法是获得两者的优势",{"1":{"737":1}}],["最好不要勾选它",{"1":{"704":1}}],["最好不要有空格",{"1":{"556":1}}],["最好不要这么干",{"1":{"204":1}}],["最好是用文件存储",{"1":{"9":1}}],["最新的idea版本为2022",{"1":{"553":1}}],["最新的下载地址为",{"1":{"415":1,"416":1}}],["最新的协议通知客户端这个玩家奔跑速度是500单位每秒",{"1":{"46":1}}],["最新版本的分支名称即可",{"1":{"145":1}}],["最糟糕的是",{"1":{"127":1}}],["最终渲染顺序还是",{"1":{"1039":1}}],["最终渲染顺序是",{"1":{"1039":1}}],["最终以",{"1":{"1036":1}}],["最终是会被销毁的",{"1":{"968":1}}],["最终都被销毁了",{"1":{"956":1}}],["最终几乎每个",{"1":{"944":1}}],["最终你看到的图像很可能是这样的",{"1":{"854":1}}],["最终显示的图像如图",{"1":{"854":1}}],["最终我们所有的成果都会发布到各个平台",{"1":{"841":1}}],["最终得到方法的il汇编码",{"0":{"712":1},"1":{"710":1}}],["最终得到的就是我们最终射线结果",{"1":{"676":1}}],["最终",{"1":{"695":1}}],["最终的技能树基本上是只有顺序",{"1":{"795":1}}],["最终的",{"1":{"695":1}}],["最终的结果就是按照从大到小",{"1":{"695":1}}],["最终执行的是",{"1":{"684":1}}],["最终调用的是另外一个raycast",{"1":{"676":1}}],["最终回调在编辑器中设定的方法",{"1":{"657":1}}],["最终结成一伙",{"1":{"297":1}}],["最终生成的地形结果如下图所示",{"1":{"214":1}}],["最终目标是相同或相近的",{"1":{"212":1}}],["最终会有如下的搜索过程",{"1":{"210":1}}],["最终拿来与梯度向量进行点积",{"1":{"202":1}}],["最终状态就是x=12",{"1":{"69":1}}],["最终合并成一个序列化好的文件",{"1":{"15":1}}],["最坏的情况是直接没法玩了",{"1":{"66":1}}],["最重要的是位置",{"1":{"43":1}}],["最脆弱的法师等",{"1":{"20":1}}],["最后从服务器校正延迟补偿是服务器在做的一件事情",{"1":{"1013":1}}],["最后给出一个最终的总结",{"1":{"976":1}}],["最后在",{"1":{"944":1}}],["最后在每一帧中绘制出来",{"1":{"940":1}}],["最后清理完毕",{"1":{"898":1}}],["最后得到期望的结果",{"1":{"897":1}}],["最后返回新的对象shoe",{"1":{"896":1}}],["最后还是从definition",{"1":{"715":1}}],["最后实现了和文章二的首尾呼应",{"1":{"714":1}}],["最后实际调用的是它的一个重载方法",{"1":{"173":1}}],["最后如果上述情况都不能满足",{"1":{"695":1}}],["最后对检测结果再过滤",{"1":{"693":1}}],["最后经由一个验证函数来获得具体的eventdata",{"1":{"678":1}}],["最后一个参数就是一个传入的delegate",{"1":{"678":1}}],["最后再执行pointerexit事件",{"1":{"672":1}}],["最后再用工具将图片平滑一下",{"1":{"2":1}}],["最后理出来所有事件的入口其实都是放在",{"1":{"668":1}}],["最后的射线检测结果都只会包含这个",{"1":{"689":1}}],["最后的unity执行流程图",{"1":{"652":1}}],["最后的最后",{"1":{"607":1}}],["最后的结果就是玩家的角色总是当前时刻",{"1":{"77":1}}],["最后点击generate",{"1":{"607":1}}],["最后打包的插件体积为",{"1":{"537":1}}],["最后提示",{"1":{"506":1}}],["最后猫的主送你了一些礼物",{"1":{"296":1}}],["最后会在",{"1":{"964":1}}],["最后会在项目根目录下出现一个",{"1":{"535":1}}],["最后会得到",{"1":{"952":1}}],["最后会影响到停止父节点",{"1":{"283":1}}],["最后会给出实现",{"1":{"30":1}}],["最后不得不列一下我觉得还蛮重要的公式",{"1":{"207":1}}],["最后让我们再思考下",{"1":{"204":1}}],["最后考虑ioptions<>",{"1":{"174":1}}],["最后检查acceptlanguage",{"1":{"151":1}}],["最后将其与圆的半径相比",{"1":{"755":1}}],["最后将这些射线检测结果依次拼装成",{"1":{"684":1}}],["最后将讲解如何配置",{"1":{"534":1}}],["最后将正在使用的内存空间的对象清除",{"1":{"120":1}}],["最后将结果发送回客户端",{"1":{"73":1}}],["最后",{"0":{"769":1},"1":{"42":1,"48":1,"167":1,"199":1,"220":1,"592":1,"737":1,"947":1,"960":1}}],["最后改成了现有的方式",{"1":{"15":1}}],["先按大项条件排序",{"1":{"976":1}}],["先畫不透明物件",{"1":{"975":1}}],["先创建一个",{"1":{"971":1}}],["先来看看它对应的",{"1":{"969":1}}],["先假设我们这些对象的",{"1":{"952":1}}],["先从直观的角度来解释",{"1":{"862":1}}],["先冲锋",{"1":{"794":1}}],["先给出可直接套用的公式",{"1":{"756":1}}],["先点击运行示例以获取焦点",{"1":{"753":1}}],["先运行jenny",{"1":{"746":1}}],["先被射线检测到的对象排在前面",{"1":{"695":1}}],["先决条件",{"0":{"615":1}}],["先测试下基本功能",{"1":{"613":1}}],["先使用release版本发布到googleplay",{"1":{"613":1}}],["先要弄清楚",{"1":{"577":1}}],["先超cpu再超内存",{"1":{"551":1}}],["先选择从浏览器打开ssh连接服务器",{"0":{"463":1}}],["先编码执行一个复杂的命令",{"1":{"424":1}}],["先",{"1":{"404":1}}],["先安装jquery及其声明文件使用",{"1":{"401":1}}],["先看看安卓和windows下",{"1":{"708":1}}],["先看哪些设施会卡人先补足",{"1":{"375":1}}],["先看下一套衣服是如何组成的",{"1":{"285":1}}],["先看下查找",{"1":{"138":1}}],["先学会支薪10元",{"1":{"372":1}}],["先反射得到方法",{"1":{"175":1}}],["先检查请求网址",{"1":{"151":1}}],["先传递哪个字节",{"1":{"37":1}}],["先查看错误日志",{"1":{"9":1}}],["先去除大部分的黑色",{"1":{"2":1}}],["wsa",{"1":{"720":4}}],["wsapi",{"1":{"580":1}}],["wsgi是基于http协议模式的",{"1":{"584":1}}],["wsgi是一种通信协议",{"1":{"582":1}}],["wsgi和asgi的区别",{"0":{"584":1}}],["wsgi服务器的选择很多",{"1":{"578":1}}],["wsgi协议其实是定义了一种server与application解耦的规范",{"1":{"578":1}}],["wsgi",{"0":{"577":1,"578":1},"1":{"577":2,"578":1}}],["wsreset",{"1":{"533":1}}],["wnr",{"1":{"437":4}}],["wuxiaoyuan",{"1":{"421":1}}],["wrap",{"1":{"726":2}}],["wrapping",{"1":{"726":1}}],["wrapper",{"1":{"188":1}}],["wrong",{"1":{"193":1}}],["wrote",{"1":{"189":1}}],["writer",{"1":{"195":2}}],["write",{"1":{"186":1,"188":2,"189":2,"190":3,"193":1,"196":1,"446":2,"448":1,"449":6,"450":1,"451":1,"869":1,"872":1}}],["writes",{"1":{"24":1,"189":1}}],["written",{"1":{"90":1,"187":1}}],["writing",{"1":{"27":1,"90":1,"195":1}}],["w",{"1":{"103":2,"195":2,"642":1}}],["would",{"1":{"192":1,"195":3}}],["wonderful",{"1":{"197":1}}],["won",{"1":{"25":1,"965":1}}],["worth",{"1":{"196":1}}],["worse",{"1":{"191":1}}],["word",{"1":{"502":1}}],["word内部的字节排列才会受到endian的影响",{"1":{"39":1}}],["word之间的顺序是编码方案指定的",{"1":{"39":1}}],["world的",{"1":{"1054":1}}],["world中完成的",{"1":{"1054":1}}],["world中",{"1":{"1054":1}}],["world里",{"1":{"951":1}}],["worldcamera",{"1":{"620":1,"640":1,"687":2}}],["world对游戏对象的管理以patch为单位",{"1":{"101":1}}],["world",{"0":{"947":2},"1":{"24":1,"118":1,"121":1,"510":1,"592":1,"841":2,"939":2,"947":13,"948":3,"949":1,"950":5,"951":6,"952":3,"954":3,"956":2,"957":5,"962":1,"963":1,"964":5,"965":1,"968":1,"970":5,"977":1,"978":1}}],["worker",{"1":{"575":5,"576":2,"944":1}}],["workers",{"1":{"467":1}}],["workflows",{"1":{"515":1}}],["workflow",{"0":{"946":1},"1":{"510":1}}],["working",{"1":{"28":1}}],["works",{"1":{"26":1,"27":1,"193":1,"851":1}}],["work",{"1":{"24":1,"25":1,"188":1}}],["weixin",{"1":{"984":1}}],["weiser",{"1":{"591":1}}],["went",{"1":{"191":1}}],["were",{"1":{"189":1}}],["well",{"1":{"186":1,"188":1,"191":1,"489":1}}],["we",{"1":{"24":3,"25":6,"26":4,"27":6,"186":2,"187":5,"188":8,"189":6,"190":2,"191":3,"192":8,"193":9,"195":2,"196":4,"486":1,"488":1,"489":2,"896":1}}],["webgl",{"1":{"720":3}}],["webglsupport",{"1":{"591":1}}],["web开发框架",{"1":{"578":1}}],["web程序与服务器之间交互的通用性",{"1":{"578":1}}],["web框架在讲",{"1":{"577":1}}],["web服务器网关接口",{"1":{"578":1}}],["web服务器即用来接受客户端请求",{"1":{"577":1}}],["web服务器和web框架",{"1":{"577":1}}],["web服务器就请求操作系统生成一个新的cgi解释器进程",{"1":{"574":1}}],["web服务器httpd",{"1":{"3":1}}],["webui",{"1":{"564":1}}],["webview",{"1":{"535":1}}],["webpack",{"0":{"536":1},"1":{"534":1,"536":3,"537":5,"538":1}}],["webkit",{"1":{"405":1}}],["web",{"0":{"164":1},"1":{"183":1,"572":5,"573":3,"574":2,"575":1,"576":6,"577":5,"578":2,"580":1,"581":2}}],["websitecoping",{"1":{"998":1}}],["website",{"1":{"22":1,"181":2}}],["whole",{"1":{"189":1}}],["why",{"0":{"186":1,"187":1},"1":{"187":1}}],["whether",{"1":{"488":1}}],["wherever",{"1":{"27":1}}],["where",{"1":{"25":1,"27":1,"186":1,"1005":1}}],["whenever",{"1":{"571":1}}],["when",{"1":{"22":1,"27":2,"90":2,"181":2,"187":1,"189":1,"192":1,"193":2,"194":1,"720":2}}],["which",{"1":{"24":1,"25":1,"26":1,"27":1,"29":1,"90":1,"188":2,"192":1,"193":2,"471":1,"489":1}}],["while",{"1":{"22":1,"188":1,"191":1,"195":1,"196":2}}],["whatever",{"1":{"191":1,"737":1}}],["what",{"0":{"22":1},"1":{"195":1}}],["wii",{"1":{"720":2}}],["width",{"1":{"628":1,"633":2,"634":1,"635":1,"636":1,"644":1,"859":1}}],["wimhelperhttps",{"1":{"533":1}}],["winrt",{"1":{"720":2}}],["win",{"1":{"720":2}}],["wincred",{"1":{"412":1}}],["winstore",{"1":{"411":1}}],["winner",{"1":{"196":1}}],["win32开头的项目类型",{"1":{"127":1}}],["window中勾掉unity",{"1":{"1016":1}}],["window",{"1":{"700":1}}],["windows平台",{"1":{"591":1}}],["windows环境",{"0":{"493":1}}],["windows存储的初始密码账号不对",{"1":{"420":1}}],["windows解决",{"0":{"415":1}}],["windows",{"0":{"409":1,"410":1,"549":1,"566":1},"1":{"9":1,"411":2,"412":1,"415":1,"424":2,"497":1,"498":2,"499":1,"524":2,"566":4,"567":1,"720":7}}],["windows下绝对路径启动问题",{"0":{"9":1}}],["windos部分版本的git会提示实际上是缺少微软的",{"1":{"414":1}}],["windos",{"1":{"33":1,"38":1}}],["wikipedia",{"1":{"96":1}}],["wiki",{"1":{"50":1,"87":1,"96":1,"111":1,"532":1,"747":1}}],["will",{"1":{"25":1,"27":1,"90":5,"186":2,"187":2,"188":2,"189":2,"190":1,"193":4,"484":1,"485":1,"486":1,"487":1,"585":2,"662":2}}],["without",{"1":{"193":1}}],["with",{"1":{"22":3,"24":1,"25":2,"26":2,"27":1,"28":1,"189":3,"190":1,"195":2,"196":1,"484":1,"488":2,"571":1,"601":1,"625":1,"628":1,"851":2,"980":2,"998":4}}],["waitaction",{"1":{"242":1}}],["wavefunctioncollapse",{"1":{"211":1}}],["watch",{"1":{"191":1}}],["was",{"1":{"25":1,"571":1}}],["want",{"1":{"22":1,"26":1,"187":1,"188":1,"189":1,"193":1,"196":1,"737":1}}],["wangjia184",{"1":{"10":1}}],["ways",{"1":{"196":1,"486":1}}],["way",{"1":{"22":3,"90":1,"189":1,"1005":1}}],["www",{"0":{"1027":1,"1028":1,"1029":1,"1030":1},"1":{"21":1,"50":1,"65":1,"71":1,"77":1,"81":2,"103":1,"126":1,"131":2,"185":1,"533":1,"567":1,"606":1,"719":4,"737":1,"747":1,"998":1}}],["不这么干",{"1":{"1037":1}}],["不透明物体大部分情况下是按照从前往后渲染",{"1":{"1037":1}}],["不透明物体被放在粗略分隔的从前往后排布的桶中",{"1":{"1037":1}}],["不透明物件",{"1":{"975":1,"978":1}}],["不得大于64k",{"1":{"981":1}}],["不得不从排列良好的",{"1":{"960":1}}],["不得不学着使用阴阳术来补牙",{"1":{"296":1}}],["不得不修补被烧坏的衣服",{"1":{"296":1}}],["不减少draw",{"1":{"979":1}}],["不论它的sortinglayer和sortingorder怎么设置都是不起作用的",{"1":{"976":1}}],["不论循环迭代多少次",{"1":{"824":1}}],["不過自定義編輯器來達成",{"1":{"975":1}}],["不過根據",{"1":{"564":1}}],["不想复制粘贴converttoentity",{"1":{"971":1}}],["不只是gameobject",{"1":{"964":1}}],["不幸的是",{"1":{"940":1}}],["不幸着凉感冒",{"1":{"296":1}}],["不添加数据",{"1":{"927":1}}],["不考虑在后续帧中是否重用了部分",{"1":{"878":1}}],["不考虑合理性",{"1":{"131":1}}],["不包含内部的子任务",{"1":{"878":1}}],["不完全准确",{"1":{"877":1}}],["不使用字符串名称对",{"1":{"858":1}}],["不跳帧的画面",{"1":{"854":1}}],["不可见的",{"1":{"828":1}}],["不全是因为装箱",{"1":{"823":1}}],["不直观的说",{"1":{"819":1}}],["不直接阻塞主进程",{"1":{"451":1}}],["不评价好坏",{"1":{"810":1}}],["不足",{"0":{"788":1}}],["不适用于凹多边形适用案例",{"1":{"764":1}}],["不移动背景精灵转而移动背景取景区域来实现背景移动效果",{"1":{"728":1}}],["不做过多解释",{"1":{"712":1}}],["不做处理ugui事件和射线穿透的问题eventsystem也是向场景发送射线",{"1":{"657":1}}],["不放到gac中",{"1":{"707":1}}],["不为",{"1":{"689":1}}],["不为空",{"1":{"688":1,"693":1}}],["不为空的话表示已经编译过就不需要再次编译",{"1":{"131":1}}],["不断的跟踪他们正在使用的东西",{"1":{"898":1}}],["不断向上查找",{"1":{"679":1}}],["不断以骇人的手段残害着武林正道的人士",{"1":{"297":1}}],["不支持websocket",{"1":{"584":1}}],["不支持多个文件上传",{"1":{"510":1}}],["不经过web服务器",{"1":{"581":1}}],["不妨自己证实一下",{"1":{"854":1}}],["不妨可以考虑使用",{"1":{"538":1}}],["不妨多设一些分舵来扩大招人数量",{"1":{"380":1}}],["不仅仅是对entity进行了修改",{"1":{"738":1}}],["不仅步骤重复又繁琐",{"1":{"510":1}}],["不仅要标记所有存活对象",{"1":{"119":1}}],["不希望",{"1":{"455":1}}],["不阻塞",{"1":{"451":1}}],["不保存",{"0":{"448":1},"1":{"447":1,"451":1}}],["不演示全局引入方式",{"1":{"401":1}}],["不再会被返还给操作系统",{"1":{"814":1}}],["不再存在skill的概念",{"1":{"811":1}}],["不再同步所有节点的enter",{"1":{"795":1}}],["不再演示全局使用方式",{"1":{"401":1}}],["不再单单响应服务器命令",{"1":{"43":1}}],["不建议这样做",{"1":{"401":1}}],["不怕有分舵後忘记调薪资而管理不方便",{"1":{"372":1}}],["不怕没练到武不高兴",{"1":{"372":1}}],["不掉落皮毛",{"1":{"299":1}}],["不必在意",{"1":{"296":1}}],["不小心闯入了其他街区",{"1":{"296":1}}],["不料反被狗追",{"1":{"296":1}}],["不给",{"1":{"295":1}}],["不知道大家理解没有",{"1":{"841":1}}],["不知道是不是bug",{"1":{"377":1}}],["不知道中式的遗迹啥样的",{"1":{"287":1}}],["不知道为什么这个方法取到的直接就是大端字节数组",{"1":{"39":1}}],["不",{"1":{"274":3}}],["不受命中的影响",{"1":{"385":1}}],["不受场景等级的制约",{"1":{"265":1}}],["不受cpu字节序的影响",{"1":{"39":1}}],["不存储行为",{"1":{"927":1}}],["不存储",{"1":{"259":1}}],["不存在",{"1":{"855":1}}],["不存在字节序问题",{"1":{"39":1}}],["不存在任何delay",{"1":{"15":1}}],["不存在某个玩家领先或落后其他玩家若干个turn的情况",{"1":{"11":1}}],["不然可能会疑惑",{"1":{"751":1}}],["不然一瞬间就消失了看不到",{"1":{"751":1}}],["不然黑图或者绿图",{"1":{"570":1}}],["不然部署时拉取仓库会失败",{"1":{"541":1}}],["不然即使是胖子一样备摸两下就趴",{"1":{"377":1}}],["不然没法进行初级制作",{"1":{"301":1}}],["不然移动到另一个城市",{"1":{"287":1}}],["不然击中一个两次",{"1":{"244":1}}],["不然就返回第",{"1":{"220":1}}],["不在",{"1":{"942":1}}],["不在关卡通路上的房间",{"1":{"225":1}}],["不在critical",{"1":{"224":1}}],["不隶属于任何玩家区域的单元格被称为隔离区或自然区",{"1":{"214":1}}],["不难看出",{"1":{"197":1}}],["不会进行同批处理",{"1":{"979":1,"980":1,"981":1,"982":1}}],["不会遵循linkedentitygroup的conversion",{"1":{"965":1}}],["不会做其他更多事",{"1":{"958":1,"1001":1}}],["不会递归地",{"1":{"958":1,"1001":1}}],["不会为创建关联",{"1":{"956":1}}],["不会复制数据",{"1":{"937":1}}],["不会在实体删除的时候被删除",{"1":{"931":1}}],["不会执行",{"1":{"914":1}}],["不会跟踪在主线程之外发生的分配",{"1":{"878":1}}],["不会触发重构过程",{"1":{"860":1}}],["不会",{"1":{"857":1,"936":1}}],["不会影响门派的存亡",{"1":{"380":1}}],["不会产生任何出口",{"1":{"224":1}}],["不会保留到下次",{"1":{"173":1}}],["不会像lockstep一样",{"1":{"15":1}}],["不处于存活状态",{"1":{"115":1}}],["不是一次",{"1":{"971":1}}],["不是",{"1":{"864":1,"949":1}}],["不是很明显的",{"1":{"785":1}}],["不是assetbundle包",{"1":{"704":1}}],["不是开发人员",{"1":{"616":1}}],["不是真的叫他去写秘笈",{"1":{"374":1}}],["不是加高他的练武成效",{"1":{"373":1}}],["不是gc的工作区域",{"1":{"113":1}}],["不是对整个系统就是对某个用户程序提供服务",{"1":{"3":1}}],["不管你是否认同",{"1":{"959":1,"1002":1}}],["不管转换过程中有多少魔法",{"1":{"952":1}}],["不管怎样",{"1":{"841":1}}],["不管怎样最後还是会武功迟滞",{"1":{"377":1}}],["不管用什么脚本后端",{"1":{"819":1}}],["不管是哪种方式",{"1":{"707":1}}],["不管对象结构有多复杂",{"1":{"111":1}}],["不管客户端的血量是多少",{"1":{"63":1}}],["不需要特別設定",{"1":{"978":1}}],["不需要我们进行操作",{"1":{"876":1}}],["不需要做任何特殊配置",{"1":{"578":1}}],["不需要关心激活到期时间",{"1":{"560":1}}],["不需要一定向下面这样",{"1":{"287":1}}],["不需要碰撞触发的特效",{"1":{"245":1}}],["不需要在对象中添加或删除成员的时候修改克隆方法",{"1":{"111":1}}],["不需要执行中间的过程",{"1":{"15":1}}],["不能利用好内存块",{"1":{"929":1}}],["不能包含none中任意一个组件类型一次实体查询的结果会返回所有符合查询要求的内存块",{"1":{"915":1}}],["不能混用",{"1":{"840":1}}],["不能基于system",{"1":{"714":1}}],["不能用link",{"1":{"601":1}}],["不能体验新版非常遗憾",{"1":{"553":1}}],["不能接受命令请求",{"1":{"450":1}}],["不能大地图移动",{"0":{"343":1}}],["不能售卖东西",{"0":{"343":1}}],["不能",{"1":{"270":1}}],["不能跨范围",{"1":{"173":1}}],["不能保证每次新生代都少于10",{"1":{"120":1}}],["不能影响其他系统",{"1":{"91":1}}],["不能使用sudo的解决办法",{"1":{"7":1}}],["不停止老版本",{"1":{"88":1}}],["不自然的感觉",{"1":{"84":1}}],["不预测将来的位置",{"1":{"77":1}}],["不一致",{"1":{"982":1}}],["不一致也时有发生",{"1":{"48":1}}],["不一样",{"1":{"964":1}}],["不一样对于",{"1":{"695":1}}],["不一会直接跳到p",{"1":{"74":1}}],["不要用foreach",{"1":{"864":1}}],["不要用dynamic关键字",{"1":{"602":1}}],["不要再update中重复实例化对象",{"1":{"864":1}}],["不要使用withany<t",{"1":{"910":1}}],["不要使用linq因为会分配大量的托管内存",{"1":{"864":1}}],["不要使用闭包和匿名方法",{"1":{"864":1}}],["不要使用ugui的outline和shadow",{"1":{"860":1}}],["不要使用texture2d",{"1":{"858":1,"864":1}}],["不要在运行时使用addcomponent将组件添加到gameobjects可能是一项非常昂贵的操作",{"1":{"858":1}}],["不要忘记将新的对象放到视差层中",{"1":{"737":1}}],["不要混淆reflection",{"1":{"709":1}}],["不要想着用异步加载ui",{"1":{"702":1}}],["不要告诉别人",{"1":{"591":1}}],["不要把该依赖打包到",{"1":{"537":1}}],["不要幻想名门正派就一定会光明正大",{"1":{"383":1}}],["不要急著建设武场",{"1":{"376":1}}],["不要小看拿秘笈领悟",{"1":{"373":1}}],["不要让他们失望",{"1":{"218":1}}],["不要设置duetime为0",{"1":{"161":1}}],["不要瞎改终端配置除非你完全确定你在干嘛​",{"1":{"87":1}}],["不要相信玩家",{"1":{"62":1}}],["不要将datetime当成datetimeoffset使用",{"0":{"31":1}}],["不过具体到实现来说",{"1":{"1010":1}}],["不过该行为的目的又有所不同",{"1":{"964":1}}],["不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的",{"1":{"197":1}}],["不过我不再需要converttoentity了",{"1":{"971":1}}],["不过我会大致解释一下",{"1":{"971":1}}],["不过我想要用这些类型来进行查询",{"1":{"955":1}}],["不过我们在mimpidreams中使用了这个工作流程",{"1":{"737":1}}],["不过过去常见的",{"1":{"955":1}}],["不过可以使用job将工作分配到子线程中",{"1":{"917":1}}],["不过幸运的是",{"1":{"783":1}}],["不过首先要做的是",{"1":{"765":1}}],["不过在这边文章中",{"1":{"737":1}}],["不过在这里还是想概括一下",{"1":{"737":1}}],["不过不得不用z轴偏移来放置它们以免z方向有冲突",{"1":{"737":1}}],["不过如果背景是多张不同的纹理连续出现的话",{"1":{"726":1}}],["不过对于2d",{"1":{"724":1}}],["不过addressable提供了一些便利的方法",{"1":{"699":1}}],["不过开发此插件的作者又开发出另一款工具",{"1":{"553":1}}],["不过最好还是慢慢卖",{"1":{"376":1}}],["不过金色怪物和头目会有更高的概率掉落魔法物品",{"1":{"274":1}}],["不过基本上都局限于制作符文之语的白色物品",{"1":{"273":1}}],["不过本文只会探讨受上下左右四个点约束的情况",{"1":{"207":1}}],["不过呢",{"1":{"206":1}}],["不过这一次和assetandgameobject",{"1":{"964":1}}],["不过这并不会影响system的计算逻辑",{"1":{"904":1}}],["不过这种方法也不是万能的",{"1":{"750":1}}],["不过这种方法也不是不能用",{"1":{"748":1}}],["不过这样做的缺点是攻击范围大小恒定",{"1":{"748":1}}],["不过这只是大",{"1":{"374":1}}],["不过这不是个问题",{"1":{"220":1}}],["不过这两种算法的原理都是一样的",{"1":{"197":1}}],["不过这个还是无法解决帧同步的问题",{"1":{"12":1}}],["不过同步块中专门准备了一个字段用来存hashcode",{"1":{"131":1}}],["不过",{"1":{"74":1,"274":1,"455":1,"841":1,"917":1}}],["不过取决于项目需要",{"1":{"51":1}}],["不过将这些字节流翻译成unicode比其他的传输方式复杂",{"1":{"39":1}}],["不用设置两次常量",{"1":{"981":1}}],["不用担心上图中有3个gameobject声明了同一个",{"1":{"966":1}}],["不用到处搜索解决方案了",{"1":{"682":1}}],["不用转换",{"1":{"39":1}}],["不用每次都要从服务器拉取日志查看",{"1":{"30":1}}],["不止是c",{"1":{"38":1}}],["不转换会造成错误的收发数据",{"1":{"36":1}}],["不方便处理一些特殊逻辑",{"1":{"15":1}}],["不太像是一个成型的项目",{"1":{"15":1}}],["不联网状态",{"1":{"15":1}}],["不同变体",{"1":{"982":1}}],["不同shader",{"1":{"982":1}}],["不同",{"1":{"941":1,"956":1,"1039":1}}],["不同材质的物体",{"1":{"877":1}}],["不同种族的头部模型大小是不一致的",{"1":{"848":1}}],["不同appdomain之间的对象必须通过proxy",{"1":{"707":1}}],["不同首先比较两个对象的",{"1":{"695":1}}],["不同于",{"1":{"687":1}}],["不同城市的装饰树木不同",{"1":{"287":1}}],["不同的着色器阶段可以从缓存区中直接获取到需要的常量",{"1":{"981":1}}],["不同的是前者两个类型都是系统级别的",{"1":{"931":1}}],["不同的是每次调用",{"1":{"699":1}}],["不同的组件触发事件的方法都不一样",{"1":{"681":1}}],["不同的",{"1":{"457":1}}],["不同的类库有不同的使用方式",{"1":{"397":1}}],["不同的城市该如何进行区分",{"1":{"287":1}}],["不同的整数代表一个瓦片的种类",{"1":{"208":1}}],["不同的浏览器默认语言不同",{"1":{"154":1}}],["不同频率和振幅参数下的柏林噪声结果将所有结果叠加在一起",{"1":{"204":1}}],["不同用户网络状况不同",{"1":{"46":1}}],["不同步也不一定就结算不一致",{"1":{"15":1}}],["不同步也可能是客户端bug",{"1":{"15":1}}],["不同客户端通过对比这个值",{"1":{"15":1}}],["不依赖具体每个玩家是否有操作更新",{"1":{"12":1}}],["邮件服务器sendmail和数据库服务器mysqld等",{"1":{"3":1}}],["它拥有自己的entitymanager和componentsystem",{"1":{"1054":1}}],["它仍然设置ghostpredictionsystemgroup",{"1":{"1013":1}}],["它与上文gpu",{"1":{"982":1}}],["它与wsgi相比是两样东西",{"1":{"579":1}}],["它就会优先绘制在其他更远的对象上面",{"1":{"976":1}}],["它知道如何处理这些情况",{"1":{"970":1}}],["它知道服务器已经处理了请求",{"1":{"69":1}}],["它完全支持",{"1":{"969":1}}],["它完美地使用了基本的数学向量知识",{"1":{"787":1}}],["它看起来像是",{"1":{"965":1}}],["它",{"1":{"965":1}}],["它甚至知道在",{"1":{"948":1}}],["它每帧都会从传统的",{"1":{"944":1}}],["它每一轮采样都是从多个随机采样点中",{"1":{"214":1}}],["它仅仅是被绘制了而已",{"1":{"943":1}}],["它内部存储着一定数量的元素",{"1":{"937":1}}],["它能把一个变量内存空间大小的弹性的缓冲",{"1":{"937":1}}],["它能不断的更新以保持当前的组中的entity是最新的",{"1":{"740":1}}],["它以一个goto指令的形式存在栈里",{"1":{"890":1}}],["它以当前相机为参考",{"1":{"841":1}}],["它有自己的内存管理机制",{"1":{"879":1}}],["它大致代表的是摄像机照射范围内",{"1":{"877":1}}],["它所占的屏幕范围内",{"1":{"862":1}}],["它只会降低draw",{"1":{"982":2}}],["它只会重新绘制画布内容",{"1":{"860":1}}],["它只有一个文件",{"1":{"441":1}}],["它定义了图片上每个点的位置的信息",{"1":{"846":1}}],["它定义客户端可用的字节",{"1":{"86":1}}],["它默认大小是",{"1":{"841":1}}],["它已经投入了大量的学术研究",{"1":{"833":1}}],["它已经执行完毕",{"1":{"795":1}}],["它发生在当一个值类型被当做引用类型使用时",{"1":{"820":1}}],["它采取一个优化策略",{"1":{"814":1}}],["它里面有颜色的方块表示托管堆内存空间中存储的数据值",{"1":{"813":1}}],["它依然是一个顺序节点",{"1":{"795":1}}],["它包含了技能的icon",{"1":{"811":1}}],["它包含一个抽象方法",{"1":{"683":1}}],["它包括",{"1":{"721":1}}],["它比较特殊",{"1":{"841":1}}],["它比",{"1":{"721":1}}],["它必须被加载到appdomain中",{"1":{"707":1}}],["它必须被加载到某个appdomain中",{"1":{"707":1}}],["它对应的物体应该先于",{"1":{"695":1}}],["它还拥有以下一些常用的属性或方法",{"1":{"687":1}}],["它还生成元数据",{"1":{"127":1}}],["它也解决了传统方式进行",{"1":{"661":1}}],["它也将停止自己",{"1":{"283":1}}],["它始终位于左上角",{"1":{"625":1}}],["它可能会意外地删除在导出时无法确定是否被调用而在运行时可能被调用的属性或方法",{"1":{"604":1}}],["它可以通过搜索反编译器或者il查看器的输出来定位",{"1":{"821":1}}],["它可以支持非常复杂的背景",{"1":{"732":1}}],["它可以为clr提供用于识别类型的元数据等等",{"1":{"707":1}}],["它可以运行在不同的appdomain",{"1":{"707":1}}],["它可以保证不留空白边",{"1":{"628":1}}],["它可以保证ui中的所有元素都在屏幕内部",{"1":{"628":1}}],["它可以保证同一个请求中的一致性",{"1":{"174":1}}],["它可以在任何时间点按照任何客户端眼中的样子重建世界",{"1":{"79":1}}],["它位于unity安装路径的contents",{"1":{"590":1}}],["它使用从unity导出的gradle项目",{"1":{"586":1}}],["它使用了早前我们声明的",{"1":{"201":1}}],["它自带丰富的组件",{"1":{"580":1}}],["它实现了wsgi协议",{"1":{"580":1}}],["它用于定义传输信息的类型",{"1":{"579":1}}],["它规定一个程序该如何与",{"1":{"572":1}}],["它主要是存储一些unity常用的packages",{"1":{"526":1}}],["它都会检查以下条件是否全部满足",{"1":{"456":1}}],["它都会从配置文件中获取值",{"1":{"173":1}}],["它针对的是数据库中键的当前值",{"1":{"454":1}}],["它确保程序可以将数据还原到正确的数据库上",{"1":{"452":1}}],["它首先执行",{"1":{"452":1}}],["它和调用",{"1":{"449":1}}],["它通过网络连接",{"1":{"444":1}}],["它保存了某个时间点的数据集",{"1":{"441":1}}],["它最大的打孔数就是3孔",{"1":{"269":1}}],["它最终所在的位置是c和d之间",{"1":{"106":1}}],["它会保存gsv",{"1":{"991":1}}],["它会保留所有网格和顶点",{"1":{"860":1}}],["它会添加linkedentitygroup",{"1":{"971":1}}],["它会和converttoentity的工作模式类似",{"1":{"970":1}}],["它会创建一个新的",{"1":{"969":1}}],["它会创建一个图形化的地牢",{"1":{"223":1}}],["它会基于一些标准来选择导入什么",{"1":{"951":1}}],["它会找到工程中所有的system",{"1":{"917":1}}],["它会在",{"1":{"948":1}}],["它会在提交数据到",{"1":{"943":1}}],["它会在内存中创建一个新的对象",{"1":{"898":1}}],["它会在某个地方进行渲染",{"1":{"759":1}}],["它会怎么样让程序死掉",{"1":{"891":1}}],["它会知道怎么样返回进而曳继续执行代码",{"1":{"890":1}}],["它会打包到包体中",{"1":{"873":1}}],["它会先执行",{"1":{"535":1}}],["它会先得到要创建的元素所占用的空间大小",{"1":{"220":1}}],["它会向父进程发送一个完成信号",{"1":{"455":1}}],["它会被追加到",{"1":{"445":1}}],["它会根据协议文本的内容",{"1":{"444":1}}],["它会将凭证缓存到你系统用户的钥匙串中",{"1":{"411":1}}],["它给了你一个近乎公平的方式去选择某一面墙",{"1":{"220":1}}],["它应该不会被藏在无法到达的地方",{"1":{"218":1}}],["它工作得还是比较令人满意的",{"1":{"217":1}}],["它让游戏变得很有乐趣",{"1":{"217":1}}],["它让整个游戏没法玩了",{"1":{"64":1}}],["它上方的位置只能是特定的几个id",{"1":{"209":1}}],["它支持下面的场景",{"1":{"174":1}}],["它引用了代表配置文件的对象config",{"1":{"173":1}}],["它被注册为单例",{"1":{"173":1}}],["它被注册为单例服务",{"1":{"173":1}}],["它一次编译整个程序集",{"1":{"130":1}}],["它无法在多个进程之间进行共享",{"1":{"130":1}}],["它根据需要在执行期间转换",{"1":{"129":1}}],["它们只不过是用来快速创建新数据的蓝图",{"1":{"964":1}}],["它们是为了让我们更容易地编写shader并处理实时渲染的",{"1":{"976":1}}],["它们是",{"1":{"964":1,"971":1}}],["它们有同样的",{"1":{"929":1}}],["它们由clr管理",{"1":{"883":1}}],["它们都会打包喂给",{"1":{"945":1}}],["它们都将存储在堆中",{"1":{"895":1}}],["它们都小到可以忽略不计",{"1":{"858":1}}],["它们都要暂停应用程序",{"1":{"121":1}}],["它们定义对象的形状",{"1":{"844":1}}],["它们定义了程序的执行环境",{"1":{"574":1}}],["它们之间都是可以相互转换的",{"1":{"841":1}}],["它们之间的关系",{"1":{"125":1}}],["它们通常采用下面的这些形式之一",{"1":{"821":1}}],["它们能为你提供这些信息",{"1":{"767":1}}],["它们就以不同的速度移动了",{"1":{"737":1}}],["它们就能相互搭配",{"1":{"577":1}}],["它们的不同仅仅在于顶点数据的差别",{"1":{"876":1}}],["它们的关系如下图所示",{"1":{"847":1}}],["它们的值根其所属的canvas的渲染模式有关",{"1":{"640":1}}],["它们的作用如下",{"1":{"503":1}}],["它们自己都没有解析动态语言如php的功能",{"1":{"580":1}}],["它们对服务器主进程的阻塞情况如下",{"1":{"451":1}}],["它们对应下面蓝色字体的",{"1":{"270":1}}],["它们分别是",{"1":{"447":1}}],["它们分别从各顶点指向输入点",{"1":{"197":1}}],["它们代表了输入坐标落在了哪个单元正方形里",{"1":{"199":1}}],["它们会调用windows",{"1":{"127":1}}],["它在运行应用程序之前而非运行该应用程序时",{"1":{"130":1}}],["它在标记",{"1":{"119":1}}],["它在lan中也能工作的很好",{"1":{"64":1}}],["它的版本号不会更改",{"1":{"991":1}}],["它的能力甚至比普通的",{"1":{"971":1}}],["它的convert",{"1":{"965":1,"1003":1}}],["它的核心部分",{"1":{"906":1}}],["它的参数pvalue也实质上被移除",{"1":{"891":1}}],["它的参数值将被复制到一个保留特定调用的内存区域",{"1":{"826":1}}],["它的顶点数目不能超过300",{"1":{"876":1}}],["它的原点",{"1":{"841":1}}],["它的代码全部控制在",{"1":{"841":1}}],["它的局限在于射出射线的点只有一个",{"1":{"750":1}}],["它的性能是最好的",{"1":{"731":1}}],["它的作用就是调用hierarchy中所有挂载事件的gameobject",{"1":{"680":1}}],["它的所有子元素自动成为容器成员",{"1":{"406":1}}],["它的物品等级也就高于25",{"1":{"269":1}}],["它的物品等级就是25以下",{"1":{"269":1}}],["它的值就是面板上的",{"1":{"644":1}}],["它的值会更新",{"1":{"174":1}}],["它的值是不会更新的",{"1":{"174":1}}],["它的构造函数如下",{"1":{"173":1}}],["它的第一个阶段与标记",{"1":{"119":1}}],["它的基本思想是",{"1":{"107":1}}],["它的更新频率也是可控的",{"1":{"73":1}}],["它处理用户命令",{"1":{"84":1}}],["它不会添加linkedentitygroupbuffer",{"1":{"970":1}}],["它不会接收到任何新信息",{"1":{"75":1}}],["它不是",{"1":{"965":1}}],["它不仅说明了",{"1":{"846":1}}],["它不需要运行两个集群",{"1":{"89":1}}],["它不需要用户输入就能运行而且提供某种服务",{"1":{"3":1}}],["它负责处理客户端的输入并更新游戏状态",{"1":{"73":1}}],["它并不能被操作系统识别",{"1":{"707":1}}],["它并不能保证是绝对可逆的",{"1":{"70":1}}],["它并没有把客户端发来的所有的命令都处理掉",{"1":{"69":1}}],["它将在内部维护一个池",{"1":{"1033":1}}],["它将永远被打开也不会被gc清理",{"1":{"898":1}}],["它将被放到堆上并在栈上放一个指针指向它在堆里的存储",{"1":{"887":1}}],["它将停止优先级较低的节点",{"1":{"283":2}}],["它将停止比此结点优先级较低的节点",{"1":{"283":1}}],["它将观察黑板的变化",{"1":{"283":3}}],["它将终止自身",{"1":{"283":1}}],["它将继续观察黑板的变化",{"1":{"283":1}}],["它将本机映像缓存中生成的代码作为磁盘上的文件保存",{"1":{"130":1}}],["它将仅在该操作系统上运行",{"1":{"129":1}}],["它将比它开始行驶的地方提前大约100米",{"1":{"75":1}}],["它将",{"1":{"69":1,"125":1}}],["它将这个字节作为高位字节还是低位字节处理",{"1":{"37":1}}],["它是透明跟不透明的分界点",{"1":{"976":1}}],["它是clr的运行单元",{"1":{"707":1}}],["它是相对于父矩形的尺寸",{"1":{"644":1}}],["它是作为一个静态库被连接到最终的游戏可执行文件中",{"1":{"591":1}}],["它是原表中",{"1":{"142":1}}],["它是一个x",{"1":{"639":1}}],["它是一个典型的贝姆垃圾收集器",{"1":{"591":1}}],["它是一个web服务器",{"1":{"578":1,"580":1}}],["它是一个基于某些状态支持回滚",{"1":{"13":1}}],["它是一种思想",{"1":{"122":1}}],["它是以小端发存放的",{"1":{"37":1}}],["它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件",{"1":{"3":1}}],["白莲教",{"0":{"335":1}}],["白桦",{"1":{"302":1}}],["白衣公子",{"1":{"295":1}}],["白色的方块表示分配到托管堆的内存量",{"1":{"813":1}}],["白色的竖线表示选择的当前的帧",{"1":{"700":1}}],["白色的顺序来判定成色",{"1":{"275":1}}],["白色部分",{"1":{"657":1}}],["白色色条表示发呆",{"1":{"375":1}}],["白色",{"1":{"275":1}}],["白色你会完全看到后面",{"1":{"0":1}}],["白色是一块玻璃板",{"1":{"0":1}}],["白和不同程度的灰色来控制画面显示的程度",{"1":{"0":1}}]],"serializationVersion":2}