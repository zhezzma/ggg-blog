{"_path":"/unity/2022-09-10-ecs-beiwang","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity ecs的备忘录","description":"关于parent和LinkedEntityGroupparent 涉及到localtoworld, 以及一些物理和其他的转换规则parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"关于parent和linkedentitygroup"},"children":[{"type":"text","value":"关于parent和LinkedEntityGroup"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获取世界坐标..可以使用LocalToWorld.pos"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"linkedEntityGroup 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 有关"}]}]},{"type":"element","tag":"h2","props":{"id":"关于转换"},"children":[{"type":"text","value":"关于转换"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Conversion World中，仅仅是复制生成了来自Classic World的、保留原有Hierarchy关系的GameObject Entity，这些Entity拥有的组件仍然是我们熟知的传统Unity组件，例如Transform、MeshFilter。接下来，将调用DOTS预置的或我们自定义的Convert接口，完成向IComponentData组件的转换。自然而然的，可能没有实现对某Component Object的转换接口，那么在转换过程中将被丢弃，所以该转换不一定是“一对一”，所以Unity称呼其为\"Primary Entity\"。下图呈现了转换全过程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-09-10-ecs-beiwang/v2-332760451f516eb225e95ea7683945e5_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"转换过程都是在Conversion World中完成的,DOTS在内部为转换过程创建了一个World。作为独立World，它拥有自己的EntityManager和ComponentSystem，进而拥有并管理自己的Entity和ComponentData。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用ConvertToEntity组件,添加IConvertGameObjectToEntity接口,或者在组件上添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[GenerateAuthoringComponent]"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-09-10-ecs-beiwang/1662571573000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同一,但是使用代码控制转换的时机,继承ConvertToSingleEntity,并覆盖awake,然后在手动调用."},{"type":"element","tag":"pre","props":{"code":"public class ConvertToSingleEntity : ConvertToEntity\n{\n    void Awake()\n    {\n    }\n}\n\n//实际上就是ConvertToEntity中的代码\npublic static void ConvertGameObejct(World dstWorld, GameObject gameObject)\n{\n    var system = World.DefaultGameObjectInjectionWorld.GetOrCreateSystem<ConvertToEntitySystem>();\n\n    var convert = gameObject.GetComponent<ConvertToEntity>();\n\n    if (convert == null)\n    {\n        return ;\n    }\n    system.AddToBeConverted(dstWorld, convert);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class ConvertToSingleEntity : ConvertToEntity\n{\n    void Awake()\n    {\n    }\n}\n\n//实际上就是ConvertToEntity中的代码\npublic static void ConvertGameObejct(World dstWorld, GameObject gameObject)\n{\n    var system = World.DefaultGameObjectInjectionWorld.GetOrCreateSystem<ConvertToEntitySystem>();\n\n    var convert = gameObject.GetComponent<ConvertToEntity>();\n\n    if (convert == null)\n    {\n        return ;\n    }\n    system.AddToBeConverted(dstWorld, convert);\n}\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用IDeclareReferencedPrefabs.声明实体的prefab,然后进行存储,以便进行之后的实例化"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"对于转换世界中的每个游戏对象，在任何转换系统运行之前，都会在目标世界中自动创建一个主要实体。随后可以通过 GameObjectConversionSystem.GetPrimaryEntity 访问与 GameObject 关联的实体。"},{"type":"element","tag":"pre","props":{"code":"  /*\n     *    \n     *    \n         if (m_Prefab == Entity.Null)\n               {\n                   var prefabEntity = GetSingletonEntity<GamePrefabCollectionComponent>();\n                   var prefabs = GetBuffer<GamePrefabBuffer>(prefabEntity);\n                   for (int i = 0; i < prefabs.Length; ++i)\n                   {\n                       if (HasComponent<Player.State>(prefabs[i].Value))\n                           m_Prefab = prefabs[i].Value;\n                   }\n               }\n     * \n     * \n     * 添加进来的prefab不需要添加convert to entity\n     * 可以用单例获取GamePrefabCollectionComponent,然后获取想要的entity\n     * \n     */\n    public class GameDeclareReferencedPrefabs : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n    {\n   \n        public List<GameObject> Prefabs = new List<GameObject>();\n\n        public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n        {\n            dstManager.AddComponentData(entity, default(GamePrefabCollectionComponent));\n            var prefabs = dstManager.AddBuffer<GamePrefabBuffer>(entity);\n\n            foreach (var prefab in Prefabs)\n            { \n                var prefabEnt = conversionSystem.GetPrimaryEntity(prefab);\n                if (dstManager.Exists(prefabEnt))\n                    prefabs.Add(new GamePrefabBuffer { Value = prefabEnt });\n                else\n                    Debug.LogError($\"The prefab {prefab.name} in the ghost collection was no converted to an entity, skipping it\");\n            }\n        }\n\n        public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n        {\n            foreach (var prefab in Prefabs)\n            {\n                if(prefab == null)\n                {\n                    continue;\n                }\n                referencedPrefabs.Add(prefab);\n            }\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  /*\n     *    \n     *    \n         if (m_Prefab == Entity.Null)\n               {\n                   var prefabEntity = GetSingletonEntity<GamePrefabCollectionComponent>();\n                   var prefabs = GetBuffer<GamePrefabBuffer>(prefabEntity);\n                   for (int i = 0; i < prefabs.Length; ++i)\n                   {\n                       if (HasComponent<Player.State>(prefabs[i].Value))\n                           m_Prefab = prefabs[i].Value;\n                   }\n               }\n     * \n     * \n     * 添加进来的prefab不需要添加convert to entity\n     * 可以用单例获取GamePrefabCollectionComponent,然后获取想要的entity\n     * \n     */\n    public class GameDeclareReferencedPrefabs : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n    {\n   \n        public List<GameObject> Prefabs = new List<GameObject>();\n\n        public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n        {\n            dstManager.AddComponentData(entity, default(GamePrefabCollectionComponent));\n            var prefabs = dstManager.AddBuffer<GamePrefabBuffer>(entity);\n\n            foreach (var prefab in Prefabs)\n            { \n                var prefabEnt = conversionSystem.GetPrimaryEntity(prefab);\n                if (dstManager.Exists(prefabEnt))\n                    prefabs.Add(new GamePrefabBuffer { Value = prefabEnt });\n                else\n                    Debug.LogError($\"The prefab {prefab.name} in the ghost collection was no converted to an entity, skipping it\");\n            }\n        }\n\n        public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n        {\n            foreach (var prefab in Prefabs)\n            {\n                if(prefab == null)\n                {\n                    continue;\n                }\n                referencedPrefabs.Add(prefab);\n            }\n        }\n    }\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"4.从转换系统中根据component获取实体,和上面类似..因为转换子物体的时候,转换系统中会生成实体,这个时候可以使用组件从conversionSystem中获取,"},{"type":"element","tag":"pre","props":{"code":"     public static void AddAbilityComponents(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem, AbilityAuthoring[] abilities)\n        {\n            dstManager.AddComponentData(entity, new AbilityCollection.State());\n\n            // Create ability entities\n            var abilityEntities = new List<Entity>(abilities.Length);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                var e = conversionSystem.GetEntities(abilities[i]);\n                e.MoveNext();\n                var abilityEntity = e.Current;\n\n                if (abilityEntities.Contains(abilityEntity))\n                {\n                    GameDebug.LogError(\"Ability \" + abilities[i] + \" registered multiple times in abilities list\");\n                }\n\n                abilityEntities.Add(abilityEntity);\n            }\n\n            // Add abilities to ability buffer\n            dstManager.AddBuffer<AbilityCollection.AbilityEntry>(entity);\n            var abilityBuffer = dstManager.GetBuffer<AbilityCollection.AbilityEntry>(entity);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                abilityBuffer.Add(new AbilityCollection.AbilityEntry\n                {\n                    entity = abilityEntities[i],\n                    abilityType = abilities[i].abilityTypeFlags,\n                    canRunWith = abilities[i].canRunWithFlags,\n                    canInterrupt = abilities[i].canInterruptFlags,\n                });\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"     public static void AddAbilityComponents(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem, AbilityAuthoring[] abilities)\n        {\n            dstManager.AddComponentData(entity, new AbilityCollection.State());\n\n            // Create ability entities\n            var abilityEntities = new List<Entity>(abilities.Length);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                var e = conversionSystem.GetEntities(abilities[i]);\n                e.MoveNext();\n                var abilityEntity = e.Current;\n\n                if (abilityEntities.Contains(abilityEntity))\n                {\n                    GameDebug.LogError(\"Ability \" + abilities[i] + \" registered multiple times in abilities list\");\n                }\n\n                abilityEntities.Add(abilityEntity);\n            }\n\n            // Add abilities to ability buffer\n            dstManager.AddBuffer<AbilityCollection.AbilityEntry>(entity);\n            var abilityBuffer = dstManager.GetBuffer<AbilityCollection.AbilityEntry>(entity);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                abilityBuffer.Add(new AbilityCollection.AbilityEntry\n                {\n                    entity = abilityEntities[i],\n                    abilityType = abilities[i].abilityTypeFlags,\n                    canRunWith = abilities[i].canRunWithFlags,\n                    canInterrupt = abilities[i].canInterruptFlags,\n                });\n            }\n        }\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"5.手动转换gameobject,他的代码和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntitySystem"}]},{"type":"text","value":"的代码差不多.会创建一个ConversionWorld,然后进行转换,都是使用了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionUtility.Convert"}]},{"type":"text","value":"工作"},{"type":"element","tag":"pre","props":{"code":"        public static Entity ConvertGameObjectPrefab(GameObject go,World dstWorld,out BlobAssetStore blob)\n        {\n            Entity returnEntity = Entity.Null;\n        \n            blob = new BlobAssetStore();\n\n            returnEntity =\n                GameObjectConversionUtility.ConvertGameObjectHierarchy(go,GameObjectConversionSettings.FromWorld(dstWorld, blob));\n\n            return returnEntity;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static Entity ConvertGameObjectPrefab(GameObject go,World dstWorld,out BlobAssetStore blob)\n        {\n            Entity returnEntity = Entity.Null;\n        \n            blob = new BlobAssetStore();\n\n            returnEntity =\n                GameObjectConversionUtility.ConvertGameObjectHierarchy(go,GameObjectConversionSettings.FromWorld(dstWorld, blob));\n\n            return returnEntity;\n        }\n"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"关于parent和linkedentitygroup","depth":2,"text":"关于parent和LinkedEntityGroup"},{"id":"关于转换","depth":2,"text":"关于转换"}]}},"_type":"markdown","_id":"content:unity:2022-09-10-ecs-beiwang.md","_source":"content","_file":"unity/2022-09-10-ecs-beiwang.md","_extension":"md","date":"2022-09-10"}