[{"_path":"/unity/2022-09-10-ecs-beiwang","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity ecs的备忘录","description":"关于parent和LinkedEntityGroupparent 涉及到localtoworld, 以及一些物理和其他的转换规则parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"关于parent和linkedentitygroup"},"children":[{"type":"text","value":"关于parent和LinkedEntityGroup"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent和位置有关系..所以父实体需要添加Translation和LocalToWorld.否则会删除该parent和LocalToParent组件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加了parent组件且添加了Translation,LocalToWorld,LocalToParent组件,会自动给父实体添加child组件,四个组件缺一不可"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果使用了LocalToParent,这个时候Translation代表的是相对于父对象的坐标..相当于传统的localTranslation\n这个时候如果获取世界坐标..可以使用LocalToWorld.pos"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"linkedEntityGroup 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 有关"}]}]},{"type":"element","tag":"h2","props":{"id":"关于转换"},"children":[{"type":"text","value":"关于转换"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Conversion World中，仅仅是复制生成了来自Classic World的、保留原有Hierarchy关系的GameObject Entity，这些Entity拥有的组件仍然是我们熟知的传统Unity组件，例如Transform、MeshFilter。接下来，将调用DOTS预置的或我们自定义的Convert接口，完成向IComponentData组件的转换。自然而然的，可能没有实现对某Component Object的转换接口，那么在转换过程中将被丢弃，所以该转换不一定是“一对一”，所以Unity称呼其为\"Primary Entity\"。下图呈现了转换全过程。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-09-10-ecs-beiwang/v2-332760451f516eb225e95ea7683945e5_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"转换过程都是在Conversion World中完成的,DOTS在内部为转换过程创建了一个World。作为独立World，它拥有自己的EntityManager和ComponentSystem，进而拥有并管理自己的Entity和ComponentData。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用ConvertToEntity组件,添加IConvertGameObjectToEntity接口,或者在组件上添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[GenerateAuthoringComponent]"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-09-10-ecs-beiwang/1662571573000.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同一,但是使用代码控制转换的时机,继承ConvertToSingleEntity,并覆盖awake,然后在手动调用."},{"type":"element","tag":"pre","props":{"code":"public class ConvertToSingleEntity : ConvertToEntity\n{\n    void Awake()\n    {\n    }\n}\n\n//实际上就是ConvertToEntity中的代码\npublic static void ConvertGameObejct(World dstWorld, GameObject gameObject)\n{\n    var system = World.DefaultGameObjectInjectionWorld.GetOrCreateSystem<ConvertToEntitySystem>();\n\n    var convert = gameObject.GetComponent<ConvertToEntity>();\n\n    if (convert == null)\n    {\n        return ;\n    }\n    system.AddToBeConverted(dstWorld, convert);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class ConvertToSingleEntity : ConvertToEntity\n{\n    void Awake()\n    {\n    }\n}\n\n//实际上就是ConvertToEntity中的代码\npublic static void ConvertGameObejct(World dstWorld, GameObject gameObject)\n{\n    var system = World.DefaultGameObjectInjectionWorld.GetOrCreateSystem<ConvertToEntitySystem>();\n\n    var convert = gameObject.GetComponent<ConvertToEntity>();\n\n    if (convert == null)\n    {\n        return ;\n    }\n    system.AddToBeConverted(dstWorld, convert);\n}\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用IDeclareReferencedPrefabs.声明实体的prefab,然后进行存储,以便进行之后的实例化"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"对于转换世界中的每个游戏对象，在任何转换系统运行之前，都会在目标世界中自动创建一个主要实体。随后可以通过 GameObjectConversionSystem.GetPrimaryEntity 访问与 GameObject 关联的实体。"},{"type":"element","tag":"pre","props":{"code":"  /*\n     *    \n     *    \n         if (m_Prefab == Entity.Null)\n               {\n                   var prefabEntity = GetSingletonEntity<GamePrefabCollectionComponent>();\n                   var prefabs = GetBuffer<GamePrefabBuffer>(prefabEntity);\n                   for (int i = 0; i < prefabs.Length; ++i)\n                   {\n                       if (HasComponent<Player.State>(prefabs[i].Value))\n                           m_Prefab = prefabs[i].Value;\n                   }\n               }\n     * \n     * \n     * 添加进来的prefab不需要添加convert to entity\n     * 可以用单例获取GamePrefabCollectionComponent,然后获取想要的entity\n     * \n     */\n    public class GameDeclareReferencedPrefabs : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n    {\n   \n        public List<GameObject> Prefabs = new List<GameObject>();\n\n        public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n        {\n            dstManager.AddComponentData(entity, default(GamePrefabCollectionComponent));\n            var prefabs = dstManager.AddBuffer<GamePrefabBuffer>(entity);\n\n            foreach (var prefab in Prefabs)\n            { \n                var prefabEnt = conversionSystem.GetPrimaryEntity(prefab);\n                if (dstManager.Exists(prefabEnt))\n                    prefabs.Add(new GamePrefabBuffer { Value = prefabEnt });\n                else\n                    Debug.LogError($\"The prefab {prefab.name} in the ghost collection was no converted to an entity, skipping it\");\n            }\n        }\n\n        public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n        {\n            foreach (var prefab in Prefabs)\n            {\n                if(prefab == null)\n                {\n                    continue;\n                }\n                referencedPrefabs.Add(prefab);\n            }\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  /*\n     *    \n     *    \n         if (m_Prefab == Entity.Null)\n               {\n                   var prefabEntity = GetSingletonEntity<GamePrefabCollectionComponent>();\n                   var prefabs = GetBuffer<GamePrefabBuffer>(prefabEntity);\n                   for (int i = 0; i < prefabs.Length; ++i)\n                   {\n                       if (HasComponent<Player.State>(prefabs[i].Value))\n                           m_Prefab = prefabs[i].Value;\n                   }\n               }\n     * \n     * \n     * 添加进来的prefab不需要添加convert to entity\n     * 可以用单例获取GamePrefabCollectionComponent,然后获取想要的entity\n     * \n     */\n    public class GameDeclareReferencedPrefabs : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs\n    {\n   \n        public List<GameObject> Prefabs = new List<GameObject>();\n\n        public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n        {\n            dstManager.AddComponentData(entity, default(GamePrefabCollectionComponent));\n            var prefabs = dstManager.AddBuffer<GamePrefabBuffer>(entity);\n\n            foreach (var prefab in Prefabs)\n            { \n                var prefabEnt = conversionSystem.GetPrimaryEntity(prefab);\n                if (dstManager.Exists(prefabEnt))\n                    prefabs.Add(new GamePrefabBuffer { Value = prefabEnt });\n                else\n                    Debug.LogError($\"The prefab {prefab.name} in the ghost collection was no converted to an entity, skipping it\");\n            }\n        }\n\n        public void DeclareReferencedPrefabs(List<GameObject> referencedPrefabs)\n        {\n            foreach (var prefab in Prefabs)\n            {\n                if(prefab == null)\n                {\n                    continue;\n                }\n                referencedPrefabs.Add(prefab);\n            }\n        }\n    }\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"4.从转换系统中根据component获取实体,和上面类似..因为转换子物体的时候,转换系统中会生成实体,这个时候可以使用组件从conversionSystem中获取,"},{"type":"element","tag":"pre","props":{"code":"     public static void AddAbilityComponents(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem, AbilityAuthoring[] abilities)\n        {\n            dstManager.AddComponentData(entity, new AbilityCollection.State());\n\n            // Create ability entities\n            var abilityEntities = new List<Entity>(abilities.Length);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                var e = conversionSystem.GetEntities(abilities[i]);\n                e.MoveNext();\n                var abilityEntity = e.Current;\n\n                if (abilityEntities.Contains(abilityEntity))\n                {\n                    GameDebug.LogError(\"Ability \" + abilities[i] + \" registered multiple times in abilities list\");\n                }\n\n                abilityEntities.Add(abilityEntity);\n            }\n\n            // Add abilities to ability buffer\n            dstManager.AddBuffer<AbilityCollection.AbilityEntry>(entity);\n            var abilityBuffer = dstManager.GetBuffer<AbilityCollection.AbilityEntry>(entity);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                abilityBuffer.Add(new AbilityCollection.AbilityEntry\n                {\n                    entity = abilityEntities[i],\n                    abilityType = abilities[i].abilityTypeFlags,\n                    canRunWith = abilities[i].canRunWithFlags,\n                    canInterrupt = abilities[i].canInterruptFlags,\n                });\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"     public static void AddAbilityComponents(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem, AbilityAuthoring[] abilities)\n        {\n            dstManager.AddComponentData(entity, new AbilityCollection.State());\n\n            // Create ability entities\n            var abilityEntities = new List<Entity>(abilities.Length);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                var e = conversionSystem.GetEntities(abilities[i]);\n                e.MoveNext();\n                var abilityEntity = e.Current;\n\n                if (abilityEntities.Contains(abilityEntity))\n                {\n                    GameDebug.LogError(\"Ability \" + abilities[i] + \" registered multiple times in abilities list\");\n                }\n\n                abilityEntities.Add(abilityEntity);\n            }\n\n            // Add abilities to ability buffer\n            dstManager.AddBuffer<AbilityCollection.AbilityEntry>(entity);\n            var abilityBuffer = dstManager.GetBuffer<AbilityCollection.AbilityEntry>(entity);\n            for (int i = 0; i < abilities.Length; i++)\n            {\n                abilityBuffer.Add(new AbilityCollection.AbilityEntry\n                {\n                    entity = abilityEntities[i],\n                    abilityType = abilities[i].abilityTypeFlags,\n                    canRunWith = abilities[i].canRunWithFlags,\n                    canInterrupt = abilities[i].canInterruptFlags,\n                });\n            }\n        }\n"}]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"5.手动转换gameobject,他的代码和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntitySystem"}]},{"type":"text","value":"的代码差不多.会创建一个ConversionWorld,然后进行转换,都是使用了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObjectConversionUtility.Convert"}]},{"type":"text","value":"工作"},{"type":"element","tag":"pre","props":{"code":"        public static Entity ConvertGameObjectPrefab(GameObject go,World dstWorld,out BlobAssetStore blob)\n        {\n            Entity returnEntity = Entity.Null;\n        \n            blob = new BlobAssetStore();\n\n            returnEntity =\n                GameObjectConversionUtility.ConvertGameObjectHierarchy(go,GameObjectConversionSettings.FromWorld(dstWorld, blob));\n\n            return returnEntity;\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static Entity ConvertGameObjectPrefab(GameObject go,World dstWorld,out BlobAssetStore blob)\n        {\n            Entity returnEntity = Entity.Null;\n        \n            blob = new BlobAssetStore();\n\n            returnEntity =\n                GameObjectConversionUtility.ConvertGameObjectHierarchy(go,GameObjectConversionSettings.FromWorld(dstWorld, blob));\n\n            return returnEntity;\n        }\n"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"关于parent和linkedentitygroup","depth":2,"text":"关于parent和LinkedEntityGroup"},{"id":"关于转换","depth":2,"text":"关于转换"}]}},"_type":"markdown","_id":"content:unity:2022-09-10-ecs-beiwang.md","_source":"content","_file":"unity/2022-09-10-ecs-beiwang.md","_extension":"md","date":"2022-09-10"},{"_path":"/unity/2022-04-02-circlecast-overlapple-diff","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"CircleCast和Overlapple的区别是什么","description":"从以上可以看出CircleCastAll是投射了一个⚪的运动轨迹","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-04-02-CircleCast-Overlapple-diff/1648876953000.png"},"children":[]},{"type":"text","value":"从以上可以看出CircleCastAll是投射了一个⚪的运动轨迹"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而OverlapCircleAll只是检查了一个⚪内的范围"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然如果CircleCastAll的参数"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"distance设置为0,它的功能和"}]},{"type":"text","value":"OverlapCircleAll就类似了"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2022-04-02-CircleCast-Overlapple-diff.md","_source":"content","_file":"unity/2022-04-02-CircleCast-Overlapple-diff.md","_extension":"md","date":"2022-04-02"},{"_path":"/unity/2022-01-28-unity-editor-iteration-profiler","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Editor Iteration Profiler的使用","description":"一些记录关闭netcode的代码生成Multiplayer->Code Generation Windown 关闭burst的编译,命令行添加参数--burst-disable-compilation ,查看Plugins\\TranslucentImage\\Script\\Editor\\ScenceGizmoAutoDisable.cs 删除特性UnityEditor.Callbacks.DidReloadScriptsUnity 重新生成 TypeCache。这大约需要 4000毫秒，具体取决于程序集中的类型数量。所以避免使用过多无用的插件.减少类型数量参考链接Fast Domain Relo","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"一些记录"},"children":[{"type":"text","value":"一些记录"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关闭netcode的代码生成"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Multiplayer->Code Generation Windown "}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"关闭burst的编译,命令行添加参数"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"--burst-disable-compilation"}]},{"type":"text","value":" ,"},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/Packages/com.unity.burst@1.6/manual/docs/QuickStart.html","rel":["nofollow"]},"children":[{"type":"text","value":"查看"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Plugins\\TranslucentImage\\Script\\Editor\\ScenceGizmoAutoDisable.cs"}]},{"type":"text","value":" 删除特性"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UnityEditor.Callbacks.DidReloadScripts"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unity 重新生成 "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ScriptReference/TypeCache.html","rel":["nofollow"]},"children":[{"type":"text","value":"TypeCache"}]},{"type":"text","value":"。这大约需要 4000毫秒，具体取决于程序集中的类型数量。所以避免使用过多无用的插件.减少类型数量"}]}]},{"type":"element","tag":"h2","props":{"id":"参考链接"},"children":[{"type":"text","value":"参考链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://johnaustin.io/articles/2020/domain-reloads-in-unity","rel":["nofollow"]},"children":[{"type":"text","value":"Fast Domain Reloads in Unity — John Austin"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/improving-iteration-time-on-c-script-changes.1184446/","rel":["nofollow"]},"children":[{"type":"text","value":"Unity - Improving iteration time on C# script changes - Unity Forum"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一些记录","depth":2,"text":"一些记录"},{"id":"参考链接","depth":2,"text":"参考链接"}]}},"_type":"markdown","_id":"content:unity:2022-01-28-unity-Editor-Iteration-Profiler.md","_source":"content","_file":"unity/2022-01-28-unity-Editor-Iteration-Profiler.md","_extension":"md","date":"2022-01-28"},{"_path":"/unity/2022-01-02-unity-hot-reload","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于unity的热重载的研究","description":"Roslyn C# - Runtime Compiler通过FileSystemWatcher监控目录检查改变的文件unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.Get","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"roslyn-c-runtime-compiler"},"children":[{"type":"text","value":"Roslyn C# - Runtime Compiler"}]},{"type":"element","tag":"h3","props":{"id":"通过filesystemwatcher监控目录检查改变的文件"},"children":[{"type":"text","value":"通过FileSystemWatcher监控目录检查改变的文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.GetFiles(folderPath,\"*.cs\", SearchOption.AllDirectories);\n    foreach (var item in fileEntries)\n    {\n        var key = Path.GetFileName(item);\n        if (Files.TryGetValue(key,out var f) == false)\n        {\n            Files.Add(key, item);\n        }\n        else\n        {\n            Debug.LogError($\"{f}和{item}的文件名相同\");\n        }\n    }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.GetFiles(folderPath,\"*.cs\", SearchOption.AllDirectories);\n    foreach (var item in fileEntries)\n    {\n        var key = Path.GetFileName(item);\n        if (Files.TryGetValue(key,out var f) == false)\n        {\n            Files.Add(key, item);\n        }\n        else\n        {\n            Debug.LogError($\"{f}和{item}的文件名相同\");\n        }\n    }\n"}]}]},{"type":"element","tag":"h3","props":{"id":"编译修改的文件并重新加载"},"children":[{"type":"text","value":"编译修改的文件并重新加载"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"  // Recompile the script\n    ScriptAssembly asm = domain.CompileAndLoadFile(path, securityMode);\n    \n    // Check for success\n    if(asm == null)\n    {\n        domain.LogCompilerOutputToConsole();\n        return;\n    }\n    \n    // Find the type for the changed source file\n    Type mainMonoType = GetMainMonoTypeForSourceFile(path);\n    \n    // Find type with matching full name\n    ScriptType reloadType = asm.FindType(mainMonoType);\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  // Recompile the script\n    ScriptAssembly asm = domain.CompileAndLoadFile(path, securityMode);\n    \n    // Check for success\n    if(asm == null)\n    {\n        domain.LogCompilerOutputToConsole();\n        return;\n    }\n    \n    // Find the type for the changed source file\n    Type mainMonoType = GetMainMonoTypeForSourceFile(path);\n    \n    // Find type with matching full name\n    ScriptType reloadType = asm.FindType(mainMonoType);\n"}]}]},{"type":"element","tag":"h3","props":{"id":"替换场景中的monobehavior"},"children":[{"type":"text","value":"替换场景中的monobehavior"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static bool ReplaceScriptsForScene(Scene targetScene, ScriptType scriptType, out ModScriptReplacerReport report, ScriptReplacerOptions options = ScriptReplacerOptions.Default)\n{\n    bool failed = false;\n    report = new ModScriptReplacerReport();\n\n    bool includeInactive = (options & ScriptReplacerOptions.ReplaceDisabledScripts) != 0;\n\n    foreach (GameObject gameObject in targetScene.GetRootGameObjects())\n    {\n        foreach (MonoBehaviour behaviour in gameObject.GetComponentsInChildren<MonoBehaviour>(includeInactive))\n        {\n            if (ReplaceScriptBehaviourImpl(behaviour, scriptType, ref report, options) == false)\n                failed = true;\n        }\n    }\n    return failed == false;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static bool ReplaceScriptsForScene(Scene targetScene, ScriptType scriptType, out ModScriptReplacerReport report, ScriptReplacerOptions options = ScriptReplacerOptions.Default)\n{\n    bool failed = false;\n    report = new ModScriptReplacerReport();\n\n    bool includeInactive = (options & ScriptReplacerOptions.ReplaceDisabledScripts) != 0;\n\n    foreach (GameObject gameObject in targetScene.GetRootGameObjects())\n    {\n        foreach (MonoBehaviour behaviour in gameObject.GetComponentsInChildren<MonoBehaviour>(includeInactive))\n        {\n            if (ReplaceScriptBehaviourImpl(behaviour, scriptType, ref report, options) == false)\n                failed = true;\n        }\n    }\n    return failed == false;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过以上可以看到明显的缺点只支持monobehavior"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若想支持非monobehavior可能需要自己进行处理"}]},{"type":"element","tag":"h2","props":{"id":"et的热重载"},"children":[{"type":"text","value":"ET的热重载"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离项目到不同的dll中"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过代码加载dll"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Reflection.Assembly.Load(assBytes, pdbBytes)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"首先进行编译dll"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"按R热加载后,通过反射,对现有的对象进行销毁,然后重新创建"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"\npublic class CodeLoader: IDisposable\n{\n    public static CodeLoader Instance = new CodeLoader();\n\n    public Action Update;\n    public Action LateUpdate;\n    public Action OnApplicationQuit;\n\n    private Assembly assembly;\n\n    private ILRuntime.Runtime.Enviorment.AppDomain appDomain;\n    \n    private Type[] allTypes;\n    \n    public CodeMode CodeMode { get; set; }\n\n    private CodeLoader()\n    {\n    }\n\n    public void Dispose()\n    {\n        this.appDomain?.Dispose();\n    }\n    \n    public void Start()\n    {\n        switch (this.CodeMode)\n        {\n            case CodeMode.Mono:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.allTypes = assembly.GetTypes();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n            case CodeMode.ILRuntime:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                //byte[] assBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.dll\"));\n                //byte[] pdbBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.pdb\"));\n            \n                appDomain = new ILRuntime.Runtime.Enviorment.AppDomain();\n                MemoryStream assStream = new MemoryStream(assBytes);\n                MemoryStream pdbStream = new MemoryStream(pdbBytes);\n                appDomain.LoadAssembly(assStream, pdbStream, new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());\n\n                ILHelper.InitILRuntime(appDomain);\n\n                this.allTypes = appDomain.LoadedTypes.Values.Select(x => x.ReflectionType).ToArray();\n                IStaticMethod start = new ILStaticMethod(appDomain, \"ET.Entry\", \"Start\", 0);\n                start.Run();\n                break;\n            }\n            case CodeMode.Reload:\n            {\n                byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.dll\"));\n                byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.pdb\"));\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.LoadLogic();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n        }\n    }\n\n    // 热重载调用下面三个方法\n    // CodeLoader.Instance.LoadLogic();\n    // Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n    // Game.EventSystem.Load();\n    public void LoadLogic()\n    {\n        if (this.CodeMode != CodeMode.Reload)\n        {\n            throw new Exception(\"CodeMode != Reload!\");\n        }\n        \n        // 傻屌Unity在这里搞了个傻逼优化，认为同一个路径的dll，返回的程序集就一样。所以这里每次编译都要随机名字\n        string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*.dll\");\n        if (logicFiles.Length != 1)\n        {\n            throw new Exception(\"Logic dll count != 1\");\n        }\n\n        string logicName = Path.GetFileNameWithoutExtension(logicFiles[0]);\n        byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.dll\"));\n        byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.pdb\"));\n\n        Assembly hotfixAssembly = Assembly.Load(assBytes, pdbBytes);\n        \n        List<Type> listType = new List<Type>();\n        listType.AddRange(this.assembly.GetTypes());\n        listType.AddRange(hotfixAssembly.GetTypes());\n        this.allTypes = listType.ToArray();\n    }\n\n    public Type[] GetTypes()\n    {\n        return this.allTypes;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class CodeLoader: IDisposable\n{\n    public static CodeLoader Instance = new CodeLoader();\n\n    public Action Update;\n    public Action LateUpdate;\n    public Action OnApplicationQuit;\n\n    private Assembly assembly;\n\n    private ILRuntime.Runtime.Enviorment.AppDomain appDomain;\n    \n    private Type[] allTypes;\n    \n    public CodeMode CodeMode { get; set; }\n\n    private CodeLoader()\n    {\n    }\n\n    public void Dispose()\n    {\n        this.appDomain?.Dispose();\n    }\n    \n    public void Start()\n    {\n        switch (this.CodeMode)\n        {\n            case CodeMode.Mono:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.allTypes = assembly.GetTypes();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n            case CodeMode.ILRuntime:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                //byte[] assBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.dll\"));\n                //byte[] pdbBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.pdb\"));\n            \n                appDomain = new ILRuntime.Runtime.Enviorment.AppDomain();\n                MemoryStream assStream = new MemoryStream(assBytes);\n                MemoryStream pdbStream = new MemoryStream(pdbBytes);\n                appDomain.LoadAssembly(assStream, pdbStream, new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());\n\n                ILHelper.InitILRuntime(appDomain);\n\n                this.allTypes = appDomain.LoadedTypes.Values.Select(x => x.ReflectionType).ToArray();\n                IStaticMethod start = new ILStaticMethod(appDomain, \"ET.Entry\", \"Start\", 0);\n                start.Run();\n                break;\n            }\n            case CodeMode.Reload:\n            {\n                byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.dll\"));\n                byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.pdb\"));\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.LoadLogic();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n        }\n    }\n\n    // 热重载调用下面三个方法\n    // CodeLoader.Instance.LoadLogic();\n    // Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n    // Game.EventSystem.Load();\n    public void LoadLogic()\n    {\n        if (this.CodeMode != CodeMode.Reload)\n        {\n            throw new Exception(\"CodeMode != Reload!\");\n        }\n        \n        // 傻屌Unity在这里搞了个傻逼优化，认为同一个路径的dll，返回的程序集就一样。所以这里每次编译都要随机名字\n        string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*.dll\");\n        if (logicFiles.Length != 1)\n        {\n            throw new Exception(\"Logic dll count != 1\");\n        }\n\n        string logicName = Path.GetFileNameWithoutExtension(logicFiles[0]);\n        byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.dll\"));\n        byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.pdb\"));\n\n        Assembly hotfixAssembly = Assembly.Load(assBytes, pdbBytes);\n        \n        List<Type> listType = new List<Type>();\n        listType.AddRange(this.assembly.GetTypes());\n        listType.AddRange(hotfixAssembly.GetTypes());\n        this.allTypes = listType.ToArray();\n    }\n\n    public Type[] GetTypes()\n    {\n        return this.allTypes;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按下f8编译dll"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static class BuildAssemblieEditor\n{\n        [MenuItem(\"Tools/BuildLogic _F8\")]\n        public static void BuildLogic()\n        {\n            string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*\");\n            foreach (string file in logicFiles)\n            {\n                File.Delete(file);\n            }\n            \n            int random = RandomHelper.RandomNumber(100000000, 999999999);\n            string logicFile = $\"Logic_{random}\";\n            \n            BuildAssemblieEditor.BuildMuteAssembly(logicFile, new []\n            {\n                \"Codes/Hotfix/\",\n                \"Codes/HotfixView/\",\n            }, new[]{Path.Combine(Define.BuildOutputDir, \"Data.dll\")}, CodeOptimization.Debug);\n        }\n\n\n    private static void BuildMuteAssembly(string assemblyName, string[] CodeDirectorys, string[] additionalReferences, CodeOptimization codeOptimization)\n        {\n            List<string> scripts = new List<string>();\n            for (int i = 0; i < CodeDirectorys.Length; i++)\n            {\n                DirectoryInfo dti = new DirectoryInfo(CodeDirectorys[i]);\n                FileInfo[] fileInfos = dti.GetFiles(\"*.cs\", System.IO.SearchOption.AllDirectories);\n                for (int j = 0; j < fileInfos.Length; j++)\n                {\n                    scripts.Add(fileInfos[j].FullName);\n                }\n            }\n\n            string dllPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.dll\");\n            string pdbPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.pdb\");\n            File.Delete(dllPath);\n            File.Delete(pdbPath);\n\n            Directory.CreateDirectory(Define.BuildOutputDir);\n\n            AssemblyBuilder assemblyBuilder = new AssemblyBuilder(dllPath, scripts.ToArray());\n            \n            //启用UnSafe\n            //assemblyBuilder.compilerOptions.AllowUnsafeCode = true;\n\n            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);\n\n            assemblyBuilder.compilerOptions.CodeOptimization = codeOptimization;\n            assemblyBuilder.compilerOptions.ApiCompatibilityLevel = PlayerSettings.GetApiCompatibilityLevel(buildTargetGroup);\n            // assemblyBuilder.compilerOptions.ApiCompatibilityLevel = ApiCompatibilityLevel.NET_4_6;\n\n            assemblyBuilder.additionalReferences = additionalReferences;\n            \n            assemblyBuilder.flags = AssemblyBuilderFlags.None;\n            //AssemblyBuilderFlags.None                 正常发布\n            //AssemblyBuilderFlags.DevelopmentBuild     开发模式打包\n            //AssemblyBuilderFlags.EditorAssembly       编辑器状态\n            assemblyBuilder.referencesOptions = ReferencesOptions.UseEngineModules;\n\n            assemblyBuilder.buildTarget = EditorUserBuildSettings.activeBuildTarget;\n\n            assemblyBuilder.buildTargetGroup = buildTargetGroup;\n\n            assemblyBuilder.buildStarted += delegate(string assemblyPath) { Debug.LogFormat(\"build start：\" + assemblyPath); };\n\n            assemblyBuilder.buildFinished += delegate(string assemblyPath, CompilerMessage[] compilerMessages)\n            {\n                int errorCount = compilerMessages.Count(m => m.type == CompilerMessageType.Error);\n                int warningCount = compilerMessages.Count(m => m.type == CompilerMessageType.Warning);\n\n                Debug.LogFormat(\"Warnings: {0} - Errors: {1}\", warningCount, errorCount);\n\n                if (warningCount > 0)\n                {\n                    Debug.LogFormat(\"有{0}个Warning!!!\", warningCount);\n                }\n\n                if (errorCount > 0)\n                {\n                    for (int i = 0; i < compilerMessages.Length; i++)\n                    {\n                        if (compilerMessages[i].type == CompilerMessageType.Error)\n                        {\n                            Debug.LogError(compilerMessages[i].message);\n                        }\n                    }\n                }\n            };\n            \n            //开始构建\n            if (!assemblyBuilder.Build())\n            {\n                Debug.LogErrorFormat(\"build fail：\" + assemblyBuilder.assemblyPath);\n                return;\n            }\n        }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static class BuildAssemblieEditor\n{\n        [MenuItem(\"Tools/BuildLogic _F8\")]\n        public static void BuildLogic()\n        {\n            string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*\");\n            foreach (string file in logicFiles)\n            {\n                File.Delete(file);\n            }\n            \n            int random = RandomHelper.RandomNumber(100000000, 999999999);\n            string logicFile = $\"Logic_{random}\";\n            \n            BuildAssemblieEditor.BuildMuteAssembly(logicFile, new []\n            {\n                \"Codes/Hotfix/\",\n                \"Codes/HotfixView/\",\n            }, new[]{Path.Combine(Define.BuildOutputDir, \"Data.dll\")}, CodeOptimization.Debug);\n        }\n\n\n    private static void BuildMuteAssembly(string assemblyName, string[] CodeDirectorys, string[] additionalReferences, CodeOptimization codeOptimization)\n        {\n            List<string> scripts = new List<string>();\n            for (int i = 0; i < CodeDirectorys.Length; i++)\n            {\n                DirectoryInfo dti = new DirectoryInfo(CodeDirectorys[i]);\n                FileInfo[] fileInfos = dti.GetFiles(\"*.cs\", System.IO.SearchOption.AllDirectories);\n                for (int j = 0; j < fileInfos.Length; j++)\n                {\n                    scripts.Add(fileInfos[j].FullName);\n                }\n            }\n\n            string dllPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.dll\");\n            string pdbPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.pdb\");\n            File.Delete(dllPath);\n            File.Delete(pdbPath);\n\n            Directory.CreateDirectory(Define.BuildOutputDir);\n\n            AssemblyBuilder assemblyBuilder = new AssemblyBuilder(dllPath, scripts.ToArray());\n            \n            //启用UnSafe\n            //assemblyBuilder.compilerOptions.AllowUnsafeCode = true;\n\n            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);\n\n            assemblyBuilder.compilerOptions.CodeOptimization = codeOptimization;\n            assemblyBuilder.compilerOptions.ApiCompatibilityLevel = PlayerSettings.GetApiCompatibilityLevel(buildTargetGroup);\n            // assemblyBuilder.compilerOptions.ApiCompatibilityLevel = ApiCompatibilityLevel.NET_4_6;\n\n            assemblyBuilder.additionalReferences = additionalReferences;\n            \n            assemblyBuilder.flags = AssemblyBuilderFlags.None;\n            //AssemblyBuilderFlags.None                 正常发布\n            //AssemblyBuilderFlags.DevelopmentBuild     开发模式打包\n            //AssemblyBuilderFlags.EditorAssembly       编辑器状态\n            assemblyBuilder.referencesOptions = ReferencesOptions.UseEngineModules;\n\n            assemblyBuilder.buildTarget = EditorUserBuildSettings.activeBuildTarget;\n\n            assemblyBuilder.buildTargetGroup = buildTargetGroup;\n\n            assemblyBuilder.buildStarted += delegate(string assemblyPath) { Debug.LogFormat(\"build start：\" + assemblyPath); };\n\n            assemblyBuilder.buildFinished += delegate(string assemblyPath, CompilerMessage[] compilerMessages)\n            {\n                int errorCount = compilerMessages.Count(m => m.type == CompilerMessageType.Error);\n                int warningCount = compilerMessages.Count(m => m.type == CompilerMessageType.Warning);\n\n                Debug.LogFormat(\"Warnings: {0} - Errors: {1}\", warningCount, errorCount);\n\n                if (warningCount > 0)\n                {\n                    Debug.LogFormat(\"有{0}个Warning!!!\", warningCount);\n                }\n\n                if (errorCount > 0)\n                {\n                    for (int i = 0; i < compilerMessages.Length; i++)\n                    {\n                        if (compilerMessages[i].type == CompilerMessageType.Error)\n                        {\n                            Debug.LogError(compilerMessages[i].message);\n                        }\n                    }\n                }\n            };\n            \n            //开始构建\n            if (!assemblyBuilder.Build())\n            {\n                Debug.LogErrorFormat(\"build fail：\" + assemblyBuilder.assemblyPath);\n                return;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按下R重载"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"    \npublic static class OperaComponentSystem\n{\n    public static void Update()\n    { \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            CodeLoader.Instance.LoadLogic();\n            Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n            Game.EventSystem.Load();\n            Log.Debug(\"hot reload success!\");\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \npublic static class OperaComponentSystem\n{\n    public static void Update()\n    { \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            CodeLoader.Instance.LoadLogic();\n            Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n            Game.EventSystem.Load();\n            Log.Debug(\"hot reload success!\");\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"roslyn-c-runtime-compiler","depth":2,"text":"Roslyn C# - Runtime Compiler","children":[{"id":"通过filesystemwatcher监控目录检查改变的文件","depth":3,"text":"通过FileSystemWatcher监控目录检查改变的文件"},{"id":"编译修改的文件并重新加载","depth":3,"text":"编译修改的文件并重新加载"},{"id":"替换场景中的monobehavior","depth":3,"text":"替换场景中的monobehavior"}]},{"id":"et的热重载","depth":2,"text":"ET的热重载"}]}},"_type":"markdown","_id":"content:unity:2022-01-02-unity-hot-reload.md","_source":"content","_file":"unity/2022-01-02-unity-hot-reload.md","_extension":"md","date":"2022-01-02"},{"_path":"/unity/2021-10-01-increased-script-assembly-reload-time","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Increased script assembly reload time","description":"Hi,\nWe found out that this particular issue is very hard to work on as domain reload depends on a lot of things:\n- Number and types of UI widgets alive in the editor\n- Quantity of code in the project (including from packages)\n- Callbacks run as part of the domain reload (InitializeOnLoad, EditorApplication events...) that can be handled by both editor, first party packages, 3rd party packages or user code\n- Topology of the project...","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hi,\nWe found out that this particular issue is very hard to work on as domain reload depends on a lot of things:\n- Number and types of UI widgets alive in the editor\n- Quantity of code in the project (including from packages)\n- Callbacks run as part of the domain reload (InitializeOnLoad, EditorApplication events...) that can be handled by both editor, first party packages, 3rd party packages or user code\n- Topology of the project..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So when we get numbers from users, about Domain Reload times, there are a lot of times where we can't find where the root issue come from."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The good news is that this is going to change !"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In next version, Unity will ship with a diagnostic switch enabling detailed domain reload timings, allowing any user to see what actually happen on domain reload. This will help us figure what are the most common problematic components and on which ones we should prioritize optimization effort. This will also help users find workarounds for improving performance (e.g. close a particularly consuming UI widget, remove a package that is not really needed in the project,...).\nShortly after, we will backport this diagnostic switch to LTS versions of Unity (current plan is to backport down to 2019.4), to allow for more precise performance comparison."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We are also working internally to leverage that diagnostic tools to detect problems earlier in packages that we ship, as part of our internal package validation suites. This is an ongoing effort though, so don't put your expectations too high on this, and please report your detailed domain reload logs as soon as you get the update !"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Domain reload detailed timings can now be enabled in 2021.2.0a20 an 2021.1.11f1 (and we are busy backporting this to 2019.4 and 2020.3).\n- In 2021.2.x it can be enabled using the diagnostics switches in Editor Preferences\n"},{"type":"element","tag":"img","props":{"alt":"upload_2021-6-14_12-14-44.png","src":"/images/2021-10-01-Increased-script-assembly-reload-time/upload_2021-6-14_12-14-44-png.871142"},"children":[]},{"type":"text","value":"\n- In 2021.1 (which does not have the diagnostic switches UI), you can enable it with the environment variable UNITY_DIAG_ENABLE_DOMAIN_RELOAD_TIMINGS.\n(e.g. in a Powershell console, you can run"}]},{"type":"element","tag":"pre","props":{"code":" $env:UNITY_DIAG_ENABLE_DOMAIN_RELOAD_TIMINGS=\"1\"; & 'C:\\Program Files\\Unity\\Hub\\Editor\\2021.1.11f1\\Editor\\Unity.exe'\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" $env:UNITY_DIAG_ENABLE_DOMAIN_RELOAD_TIMINGS=\"1\"; & 'C:\\Program Files\\Unity\\Hub\\Editor\\2021.1.11f1\\Editor\\Unity.exe'\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":")."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After that, in your editor logs ("}]},{"type":"element","tag":"pre","props":{"code":"%LOCALAPPDATA%\\Unity\\Editor\\Editor.log\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"%LOCALAPPDATA%\\Unity\\Editor\\Editor.log\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"), you'll see detailed timings on domain reload."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/any-update-regarding-increased-script-assembly-reload-time.1117138/?_ga=2.41177696.399908227.1633157438-1122779591.1605612681","rel":["nofollow"]},"children":[{"type":"text","value":"Any update regarding \"Increased script assembly reload time\"? - Unity Forum"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-10-01-Increased-script-assembly-reload-time.md","_source":"content","_file":"unity/2021-10-01-Increased-script-assembly-reload-time.md","_extension":"md","date":"2021-10-01"},{"_path":"/unity/2021-08-01-ai-planner","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"AI-PLANNER使用","description":"定义实体和组件SemanticObject  为gameobject添加各种componentTraits : 相当于component.可以定义各种属性定义处理系统Problem  依托 DecisionController运行计划StateTermination  为Problem  提供中止条件SemanticQuery   根据query为 DecisionController提供实体Action : 相当于一个特殊的system的基类.他定义了参数,和处理条件.以及effects和reward,但是没有实现具体的方法(executionInfo),executionInfo是需要手动","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"定义实体和组件"},"children":[{"type":"text","value":"定义实体和组件"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SemanticObject  为gameobject添加各种component"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Traits : 相当于component.可以定义各种属性"}]}]},{"type":"element","tag":"h2","props":{"id":"定义处理系统"},"children":[{"type":"text","value":"定义处理系统"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Problem  依托 DecisionController运行计划"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"StateTermination  为Problem  提供中止条件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SemanticQuery   根据query为 DecisionController提供实体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Action : 相当于一个特殊的system的基类.他定义了参数,和处理条件.以及effects和reward,但是没有实现具体的方法(executionInfo),executionInfo是需要手动定义的"},{"type":"element","tag":"pre","props":{"code":"    public abstract class PlannerActionSystem : SystemBase\n    {\n\n        List<ParameterDefinition> m_Parameters = new List<ParameterDefinition>();\n\n\n        List<Operation> m_Preconditions = new List<Operation>();\n\n\n\n        List<ParameterDefinition> m_CreatedObjects = new List<ParameterDefinition>();\n\n\n        List<string> m_RemovedObjects = new List<string>();\n\n\n        List<Operation> m_ObjectModifiers = new List<Operation>();\n\n\n        float m_Reward;\n\n        List<CustomRewardData> m_CustomRewards;\n\n\n        Unity.AI.Planner.Controller.ActionExecutionInfo executionInfo;\n\n\n        protected override void OnUpdate()\n        {\n            //检查条件\n\n            //将参数传给executionInfo\n\n            //然后执行方法\n            \n            \n            //处理effect.对object进行修改,创建,删除\n            \n            //然后处理reward\n            \n        }\n\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public abstract class PlannerActionSystem : SystemBase\n    {\n\n        List<ParameterDefinition> m_Parameters = new List<ParameterDefinition>();\n\n\n        List<Operation> m_Preconditions = new List<Operation>();\n\n\n\n        List<ParameterDefinition> m_CreatedObjects = new List<ParameterDefinition>();\n\n\n        List<string> m_RemovedObjects = new List<string>();\n\n\n        List<Operation> m_ObjectModifiers = new List<Operation>();\n\n\n        float m_Reward;\n\n        List<CustomRewardData> m_CustomRewards;\n\n\n        Unity.AI.Planner.Controller.ActionExecutionInfo executionInfo;\n\n\n        protected override void OnUpdate()\n        {\n            //检查条件\n\n            //将参数传给executionInfo\n\n            //然后执行方法\n            \n            \n            //处理effect.对object进行修改,创建,删除\n            \n            //然后处理reward\n            \n        }\n\n    }\n"}]}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"actions"},"children":[{"type":"text","value":"actions"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"motives  相当于 preconditions   ..需要一些设定才会执行这个"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Requirements   也可以使用preconditions代替   ,"}]}]},{"type":"element","tag":"h2","props":{"id":"domain"},"children":[{"type":"text","value":"domain"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"维护了一个entities列表,当entity触发了OnTriggerEnter事件会增加到这个列表中."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"aiplanner倒是不需要这个..他们是通过entity和component进行目标查找的"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"定义实体和组件","depth":2,"text":"定义实体和组件"},{"id":"定义处理系统","depth":2,"text":"定义处理系统"},{"id":"actions","depth":2,"text":"actions"},{"id":"domain","depth":2,"text":"domain"}]}},"_type":"markdown","_id":"content:unity:2021-08-01-AI-Planner.md","_source":"content","_file":"unity/2021-08-01-AI-Planner.md","_extension":"md","date":"2021-08-01"},{"_path":"/unity/2021-07-20-formerlyserializedas","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"防止变量引用丢失 FormerlySerializedAs","description":"public class shishi : MonoBehaviour\n{\n    public CameraSizeHandler CameraSize01;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset Vie","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-07-20-FormerlySerializedAs/20200110140001821.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"public class shishi : MonoBehaviour\n{\n    public CameraSizeHandler CameraSize01;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class shishi : MonoBehaviour\n{\n    public CameraSizeHandler CameraSize01;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在有一个需求，想改一改CameraSize01这个字段的名字，比如想修改为CameraSize02，并且需要将之前在监视器面板中为CameraSize01设置的各项值保留下来，如果直接修改，则会丢失属性中的值"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class shishi : MonoBehaviour\n{\n    [FormerlySerializedAs(\"CameraSize01\")]\n    public CameraSizeHandler CameraSize02;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class shishi : MonoBehaviour\n{\n    [FormerlySerializedAs(\"CameraSize01\")]\n    public CameraSizeHandler CameraSize02;\n \n    [System.Serializable]\n    public class CameraSizeHandler\n    {\n        public Color BackgroundColor = Color.gray;\n        public Rect ViewPortRect = new Rect(0.0f, 0.0f, 1.0f, 1.0f); \n        public RectOffset ViewPortOffset; \n        public Vector2 CanvasMargin = new Vector2(22.0f, 22.0f);\n        public float MaxSpeed = 1000.0f;\n        bool enabled = false;\n    }\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-07-20-FormerlySerializedAs.md","_source":"content","_file":"unity/2021-07-20-FormerlySerializedAs.md","_extension":"md","date":"2021-07-20"},{"_path":"/unity/2021-06-14-unity-render-order","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY的渲染顺序","description":"工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gist.github.com/qxsoftware/499135b6482ca57727c69e11b91a12bf","rel":["nofollow"]},"children":[{"type":"text","value":"MeshRendererInspector.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/mesh-renderer-inspector.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何添加新的 SortingLayer？请通过 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Edit/Project Settings/Tags and Layers"}]},{"type":"text","value":" 菜单选项打开："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/tags-layers.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后添加三个 Sorting Layer，如上图所示。注意，Sorting Layer 添加后是可以拖动调整顺序的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"便捷修改 Camera 的 opaqueSortMode 和 transparencySortMode："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gist.github.com/qxsoftware/1821915377e333e45f7a632ae07e64aa","rel":["nofollow"]},"children":[{"type":"text","value":"CameraInspector.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/sort-mode.jpg"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"实际测试"},"children":[{"type":"text","value":"实际测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试之前首先明确两点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"什么因素影响绘制顺序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"深度缓冲区对绘制结果的影响"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了弄清楚第一点，什么因素影响绘制顺序，我们需要把 ZWrite 关闭。同时结合 Unity Frame Debugger来观察绘制顺序。"}]},{"type":"element","tag":"h5","props":{"id":"render-queue"},"children":[{"type":"text","value":"Render Queue"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RenderQueue 是材质（Material）的关键属性，当我们在 Unity 中创建一个材质后，Unity 会给这个材质设置一个默认 Shader，然后这个材质的 RenderQueue 被改为其 Shader 中设定的 RenderQueue。如果给这个材质球换了 Shader，Unity 会更新它的 RenderQueue（但是请注意，假如当前材质的 Shader 的 RenderQueue 是 3000，然后你修改 Shader 让其 RenderQueue 变成 3100，对应材质球的 RenderQueue 并不会更新！）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unity 最终以 Material 的 RenderQueue 为准。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 内置了几个 RenderQueue 的字面值："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"RenderQueue"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"值"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Background"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"这个渲染队列最先渲染，一般用于渲染背景"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Geometry(默认值)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"这个渲染队列是大多数物体的默认队列，用于渲染不透明物体"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"AlphaTest"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2450"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"使用了 AlphaTest 的物体在这个队列渲染，当所有的不透明物体都渲染完了再渲染这个，有助于提升性能"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Transparent"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"在 Geometry 和 AlphaTest 之后、从后往前渲染，所有的半透明物体都应该在这里渲染"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Overlay"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"在之前的所有渲染队列都渲染完了之后渲染，比如镜头光晕"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到，RenderQueue 越大，渲染越靠后。"}]},{"type":"element","tag":"h5","props":{"id":"cameraopaquesortmode"},"children":[{"type":"text","value":"Camera.opaqueSortMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下，不透明物体被放在粗略分隔的从前往后排布的桶中，GPU 按照这种方式渲染能节省性能。但是也有部分 GPU 不这么干，比如 PowerVR。Camera.opaqueSortMode 这个值的默认值是 Dafault，根据不同硬件平台，这个值有可能是：OpaqueSortMode.FrontToBack 或者 OpaqueSortMode.NoDistanceSort。我们也可以主动设置这个值为某一种。比如为了减少 CPU 消耗，把这个值设置为 NoDistanceSort。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，不透明物体大部分情况下是按照从前往后渲染，也就是离相机越近，越先渲染。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果是手动选择了 FrontToBack，就是从前往后渲染；如果是 NoDistanceSort，就是从后往前渲染。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据实际测试，渲染的顺序并不是完全按照物体几何中心离相机的距离进行排序，而是一个近似的排序。"}]}]},{"type":"element","tag":"h5","props":{"id":"cameratransparencysortmode"},"children":[{"type":"text","value":"Camera.transparencySortMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照我测试用的 Unity5.3.4f1，修改这个值也会影响不透明物体的渲染顺序。所以这个东西很可能不重要，而且有 bug。"}]},{"type":"element","tag":"h5","props":{"id":"sortinglayer"},"children":[{"type":"text","value":"SortingLayer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SortingLayer 拥有最高优先级，如果 SortingLayer 不同，则首先按照 SortingLayer 排序；如果 SortingLayer 相同，再按照 RenderQueue 排序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示，有 6 个立方体，分别按顺序在摄像机前排开："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/preview.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/cubes.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中，g1 组的立方体 SortingLayer 都是 Layer3，RenderQueue 都是 3000；g2 组的立方体 SortingLayer 都是 Layer2，RenderQueue 都是3500，最终渲染顺序是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"g2m1 g2m2 g2m3 g1m1 g1m2 g1m3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直观地说，就是 SortingLayer 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。SortingLayer 默认只有一个：Default，越往后添加的 SortingLayer 越大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在把 g1 组的立方体 SortingLayer 改成 Layer2，RenderQueue 改成 3600，最终渲染顺序还是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"g2m1 g2m2 g2m3 g1m1 g1m2 g1m3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直观地说，SortingLayer 相同的前提下，RenderQueue 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"h5","props":{"id":"sortingorder"},"children":[{"type":"text","value":"SortingOrder"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果 SortingLayer 和 RenderQueue 都一样，则 SortingOrder 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果只是 SortingLayer 一样，RenderQueue 和 SortingOrder 都不一样，则物体的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"由 RenderQueue 和 SortingOrder 之和决定，相加之和越大，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上结论是通过 Frame Debugger 单步执行得出的。"}]}]},{"type":"element","tag":"h5","props":{"id":"cameradepth"},"children":[{"type":"text","value":"Camera.depth"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有一个很常用的调整渲染顺序的选项：摄像机深度。摄像机深度是优先级最高的选项，深度值越大，物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。常用的比如 NGUI 就是用一个单独的相机（深度值比渲染场景的相机大）来渲染 UI，这样就保证 UI 在所有东西上方。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考资料："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://jakobknudsen.wordpress.com/2013/07/20/transparency-and-sorting/","rel":["nofollow"]},"children":[{"type":"text","value":"Transparency and sorting in Unity"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-06-14-unity-render-order.md","_source":"content","_file":"unity/2021-06-14-unity-render-order.md","_extension":"md","date":"2021-06-14"},{"_path":"/unity/2021-06-13-how-to-make-one-way-platform","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"How to Make One Way Platform in unity","description":"Hello Readers, I'll Show you how to make simple one way platform. It is simple, useful and efficient technique to achieve this result. Here is the procedure --","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hello Readers, I'll Show you how to make simple one way platform. It is simple, useful and efficient technique to achieve this result. Here is the procedure --"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make a Simple platform using Box collider."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make a new game object children of the platform and add a box collider just below the original platform as shown in image and tick its 'is trigger' checkbox so that we can check player's collision in it."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"111","src":"/images/2021-06-13-How-to-Make-One-Way-Platform/111-1623584452229.jpg"},"children":[]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Create a new Script to the game object we create in step 2 and assign the following script --"}]}]},{"type":"element","tag":"pre","props":{"code":"//the collider of the main visible platform\nvar platform : BoxCollider2D;\n//this variable is true when the players is just below the platform so that its Box collider can be disabled that will allow the player to pass through the platform\nvar oneway : boolean;\n\n\nfunction Update () {\n    //Enabling or Disabling the platform's Box collider to allowing player to pass\n    if (oneway)\n     platform.enabled=false;\n     if (!oneway)\n     platform.enabled=true; \n}\n//Checking the collison of the gameobject we created in step 2 for checking if the player is just below the platform and nedded to ignore the collison to the platform\nfunction OnTriggerStay2D(other: Collider2D) {\n   oneway = true;\n}\n\nfunction OnTriggerExit2D(other: Collider2D) {\n//Just to make sure that the platform's Box Collider does not get permantly disabled and it should be enabeled once the player get its through\n   oneway = false;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//the collider of the main visible platform\nvar platform : BoxCollider2D;\n//this variable is true when the players is just below the platform so that its Box collider can be disabled that will allow the player to pass through the platform\nvar oneway : boolean;\n\n\nfunction Update () {\n    //Enabling or Disabling the platform's Box collider to allowing player to pass\n    if (oneway)\n     platform.enabled=false;\n     if (!oneway)\n     platform.enabled=true; \n}\n//Checking the collison of the gameobject we created in step 2 for checking if the player is just below the platform and nedded to ignore the collison to the platform\nfunction OnTriggerStay2D(other: Collider2D) {\n   oneway = true;\n}\n\nfunction OnTriggerExit2D(other: Collider2D) {\n//Just to make sure that the platform's Box Collider does not get permantly disabled and it should be enabeled once the player get its through\n   oneway = false;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I've made a simple ball game to illustrate the application of the one way platforms. You can download the example project folder below. --"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-06-13-How-to-Make-One-Way-Platform.md","_source":"content","_file":"unity/2021-06-13-How-to-Make-One-Way-Platform.md","_extension":"md","date":"2021-06-13"},{"_path":"/unity/2021-05-20-ecs-commandbuff-question","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"commandbuff的一些问题","description":"componentpublic struct State:IComponentData\n{\n    public int a;\n} \na系统\n var PostUpdateCommands = World.GetExistingSystem<AbilityUpdateCommandBufferSystem>().CreateCommandBuffer();\nEntities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        st","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"component"}]},{"type":"element","tag":"pre","props":{"code":"public struct State:IComponentData\n{\n    public int a;\n} \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public struct State:IComponentData\n{\n    public int a;\n} \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a系统"}]},{"type":"element","tag":"pre","props":{"code":"\n var PostUpdateCommands = World.GetExistingSystem<AbilityUpdateCommandBufferSystem>().CreateCommandBuffer();\nEntities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 1111;\n        PostUpdateCommands.SetComponent(entity,state);\n    })\n    .WithoutBurst()\n    .Run();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n var PostUpdateCommands = World.GetExistingSystem<AbilityUpdateCommandBufferSystem>().CreateCommandBuffer();\nEntities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 1111;\n        PostUpdateCommands.SetComponent(entity,state);\n    })\n    .WithoutBurst()\n    .Run();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"b系统"}]},{"type":"element","tag":"pre","props":{"code":"Entities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 2222;\n        EntityManager.SetComponentData(entity,state);\n    })\n     .WithStructuralChanges()\n    .Run();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Entities\n    .ForEach((Entity entity) =>\n    {\n        var state = EntityManager.GetComponent<State>(entity);\n        state.a = 2222;\n        EntityManager.SetComponentData(entity,state);\n    })\n     .WithStructuralChanges()\n    .Run();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行顺序"}]},{"type":"element","tag":"pre","props":{"code":"A-->B-->AbilityUpdateCommandBufferSystem\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"A-->B-->AbilityUpdateCommandBufferSystem\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里的结果,我们以为是2222.其实是1111."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以要么全是使用commandbuff.否则容易造成数据错误"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-05-20-ecs-commandbuff-question.md","_source":"content","_file":"unity/2021-05-20-ecs-commandbuff-question.md","_extension":"md","date":"2021-05-20"},{"_path":"/unity/2021-04-11-render-texture","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity RenderTexture的应用","description":"1. UGUI上显示模型UGUI上显示模型.png创建拍摄用的摄像机创建RenderTexture并绑定到摄像机camera.targetTexture上RenderTexture绑定到rawImage.texture上（rawImage见上图）创建显示的模型，相机可见注意Destroy销毁 创建出来的RenderTexture 和相机注意模型上的粒子特效由于Alpha透明通道，显示会有一点问题，可以通过Shader Blend混合处理，挂载在rawImage上。public void CreateCamera(Vector3 pos, Vector3 rot, int width, int ","body":{"type":"root","children":[{"type":"element","tag":"h4","props":{"id":"_1-ugui上显示模型"},"children":[{"type":"text","value":"1. UGUI上显示模型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/4276633-05b67353425f7248.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI上显示模型.png"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建拍摄用的摄像机"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建RenderTexture并绑定到摄像机camera.targetTexture上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RenderTexture绑定到rawImage.texture上（rawImage见上图）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建显示的模型，相机可见"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意Destroy销毁 创建出来的RenderTexture 和相机"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意模型上的粒子特效由于Alpha透明通道，显示会有一点问题，可以通过Shader Blend混合处理，挂载在rawImage上。"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public void CreateCamera(Vector3 pos, Vector3 rot, int width, int height, string layerName, float size)\n{\n    // 创建拍摄用的摄像机\n    GameObject go = new GameObject(\"ModelCamera\");\n    _camera = go.AddComponent<Camera>();\n    _camera.clearFlags = CameraClearFlags.SolidColor;\n    _camera.transform.position = pos;\n    _camera.transform.rotation = Quaternion.Euler(rot);\n    _camera.cullingMask = LayerMask.GetMask(layerName);\n    _camera.orthographic = true;\n    _camera.orthographicSize = size;\n    _camera.backgroundColor = new Color(0,0,0,0);\n\n    // 创建RenderTexture并绑定到摄像机上\n    _renderTexture = new RenderTexture(width, height, 8);\n    _camera.targetTexture = _renderTexture;\n\n    if (_rawImage != null)\n    {\n        _rawImage.texture = _renderTexture;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void CreateCamera(Vector3 pos, Vector3 rot, int width, int height, string layerName, float size)\n{\n    // 创建拍摄用的摄像机\n    GameObject go = new GameObject(\"ModelCamera\");\n    _camera = go.AddComponent<Camera>();\n    _camera.clearFlags = CameraClearFlags.SolidColor;\n    _camera.transform.position = pos;\n    _camera.transform.rotation = Quaternion.Euler(rot);\n    _camera.cullingMask = LayerMask.GetMask(layerName);\n    _camera.orthographic = true;\n    _camera.orthographicSize = size;\n    _camera.backgroundColor = new Color(0,0,0,0);\n\n    // 创建RenderTexture并绑定到摄像机上\n    _renderTexture = new RenderTexture(width, height, 8);\n    _camera.targetTexture = _renderTexture;\n\n    if (_rawImage != null)\n    {\n        _rawImage.texture = _renderTexture;\n    }\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"_2-camera相机拍照分享保存为jpg"},"children":[{"type":"text","value":"2. Camera相机拍照分享，保存为jpg"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"private IEnumerator CameraPhoto(Camera cam, Rect rect, string name) {\n    if (rt == null) {\n        rt = RenderTexture.GetTemporary(renderTextureDesc);\n    }\n    cam.targetTexture = rt;\n    cam.Render();\n\n    RenderTexture currentActiveRT = RenderTexture.active;\n    RenderTexture.active = rt;\n    Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false);\n    screenShot.ReadPixels(rect, 0, 0);\n    screenShot.Apply();\n    yield return new WaitForEndOfFrame();\n\n    cam.targetTexture = null;\n    RenderTexture.active = currentActiveRT;\n\n    byte[] bytes = screenShot.EncodeToJPG();\n    string file = Application.dataPath + \"/Texture/\" + name;\n    System.IO.File.WriteAllBytes(file, bytes);\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private IEnumerator CameraPhoto(Camera cam, Rect rect, string name) {\n    if (rt == null) {\n        rt = RenderTexture.GetTemporary(renderTextureDesc);\n    }\n    cam.targetTexture = rt;\n    cam.Render();\n\n    RenderTexture currentActiveRT = RenderTexture.active;\n    RenderTexture.active = rt;\n    Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false);\n    screenShot.ReadPixels(rect, 0, 0);\n    screenShot.Apply();\n    yield return new WaitForEndOfFrame();\n\n    cam.targetTexture = null;\n    RenderTexture.active = currentActiveRT;\n\n    byte[] bytes = screenShot.EncodeToJPG();\n    string file = Application.dataPath + \"/Texture/\" + name;\n    System.IO.File.WriteAllBytes(file, bytes);\n}\n"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Rendertexture的分配和销毁上有一个地方需要注意：\n如果频繁的要new一个rt出来，那么不要直接new，而是使用RenderTexture提供的GetTemporary和ReleaseTemporary，它将在内部维护一个池，反复重用一些大小格式一样的rt资源，因为让GPU为你分配一个新的texture其实是要耗时间的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"EncodeToJPG 生成的图片体积更小"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"有的时候我们想人为的控制每一次渲染，你可以将这个摄像机disable掉，然后手动的调用一次render。"}]},{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"_3-制作小地图"},"children":[{"type":"text","value":"3. 制作小地图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-153a6a121210c7f7.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里需要新建一个Layer。依次点击菜单项Edit -> Project Settings -> Tags and Layers新建Layer命名为Minimap。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-f96f6a1a4c01bae2.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后新建三个球体。一个设为蓝色代表Unity Chan。将该球体设为Unity Chan的子对象，并将其Layer设为Minimap。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-dfdc8f16823fbf32.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对两个机器人进行同样的操作，将球体改为红色。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-4b34ec3b3279e6aa.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在最关键的一步来了！选中Main Camera并确保其Culling Mask中不包括Minimap这一层。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-1eb8533ebe757f7d.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后选中Minimap Camera让其Culling Mask只包括Minimap这一层。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-e16613658b088db8.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在这个小地图看起来就比较完善了！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-04-11-render-texture/17266280-694ef4f538aae2e1.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-04-11-render-texture.md","_source":"content","_file":"unity/2021-04-11-render-texture.md","_extension":"md","date":"2021-04-11"},{"_path":"/unity/2021-01-25-tilemap","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"2021 01 25 Tilemap","description":"B站圈毛君翻译教程：The Basic：https://www.bilibili.com/video/av48965588/Rule Tile：https://www.bilibili.com/video/av49083381/Prefab Brush：https://www.bilibili.com/video/av49098444/Tilemap Collider：https://www.bilibili.com/video/av49115670/TileBaseGetTileData 确定瓦片在瓦片地图上的外观 ,相当于滚动列表中的getdata..获取数据用于显示,,RefreshTi","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"b站圈毛君翻译教程"},"children":[{"type":"text","value":"B站圈毛君翻译教程："}]},{"type":"element","tag":"h3","props":{"id":"the-basichttpswwwbilibilicomvideoav48965588"},"children":[{"type":"text","value":"The Basic："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av48965588/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av48965588/"}]}]},{"type":"element","tag":"h3","props":{"id":"rule-tilehttpswwwbilibilicomvideoav49083381"},"children":[{"type":"text","value":"Rule Tile："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av49083381/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av49083381/"}]}]},{"type":"element","tag":"h3","props":{"id":"prefab-brushhttpswwwbilibilicomvideoav49098444"},"children":[{"type":"text","value":"Prefab Brush："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av49098444/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av49098444/"}]}]},{"type":"element","tag":"h3","props":{"id":"tilemap-colliderhttpswwwbilibilicomvideoav49115670"},"children":[{"type":"text","value":"Tilemap Collider："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/av49115670/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.bilibili.com/video/av49115670/"}]}]},{"type":"element","tag":"h1","props":{"id":"tilebase"},"children":[{"type":"text","value":"TileBase"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetTileData"}]},{"type":"text","value":" 确定瓦片在瓦片地图上的外观 ,相当于滚动列表中的getdata..获取数据用于显示,,RefreshTile后会触发"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"b站圈毛君翻译教程","depth":3,"text":"B站圈毛君翻译教程："},{"id":"the-basichttpswwwbilibilicomvideoav48965588","depth":3,"text":"The Basic：https://www.bilibili.com/video/av48965588/"},{"id":"rule-tilehttpswwwbilibilicomvideoav49083381","depth":3,"text":"Rule Tile：https://www.bilibili.com/video/av49083381/"},{"id":"prefab-brushhttpswwwbilibilicomvideoav49098444","depth":3,"text":"Prefab Brush：https://www.bilibili.com/video/av49098444/"},{"id":"tilemap-colliderhttpswwwbilibilicomvideoav49115670","depth":3,"text":"Tilemap Collider：https://www.bilibili.com/video/av49115670/"}]}},"_type":"markdown","_id":"content:unity:2021-01-25-tilemap.md","_source":"content","_file":"unity/2021-01-25-tilemap.md","_extension":"md","date":"2021-01-25"},{"_path":"/unity/2021-01-24-screentoworld","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"解决Unity鼠标坐标点转成世界坐标系坐标点","description":"使用射线这是一种发射线，获取当前点击的物体（具有碰撞器）的坐标点（也就是碰撞器范围的坐标点）if (Input.GetMouseButtonDown(0))\n{\n\n    RaycastHit hitt = new RaycastHit();\n\n    Ray ray =Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    Physics.Raycast(ray, out hitt);\n\n    Debug.Log(hitt.point);\n\n    //Debug.Log(Camera.main.ScreenToWorldPoint(","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"使用射线"},"children":[{"type":"text","value":"使用射线"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一种发射线，获取当前点击的物体（具有碰撞器）的坐标点（也就是碰撞器范围的坐标点）"}]},{"type":"element","tag":"pre","props":{"code":"if (Input.GetMouseButtonDown(0))\n{\n\n    RaycastHit hitt = new RaycastHit();\n\n    Ray ray =Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    Physics.Raycast(ray, out hitt);\n\n    Debug.Log(hitt.point);\n\n    //Debug.Log(Camera.main.ScreenToWorldPoint(Input.mousePosition));\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (Input.GetMouseButtonDown(0))\n{\n\n    RaycastHit hitt = new RaycastHit();\n\n    Ray ray =Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    Physics.Raycast(ray, out hitt);\n\n    Debug.Log(hitt.point);\n\n    //Debug.Log(Camera.main.ScreenToWorldPoint(Input.mousePosition));\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"直接转换"},"children":[{"type":"text","value":"直接转换"}]},{"type":"element","tag":"pre","props":{"code":" void Update()\n {\n    if(Input.GetMouseButtonDown(0))\n   {    \n     var  z = target.transform.position.z - camera.transform.position.z;\n     Debug.Log(TempC.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, z)));\n    }\n }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" void Update()\n {\n    if(Input.GetMouseButtonDown(0))\n   {    \n     var  z = target.transform.position.z - camera.transform.position.z;\n     Debug.Log(TempC.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, z)));\n    }\n }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"摄像机对游戏世界的渲染范围是一个平截头体，渲染边界是一个矩形，用与near clippingplane或者far clippingplane平行的平面截取这个平截头体，可以获得无数个平行的矩形面，也就是我们看到的屏幕矩形。离摄像机越远，矩形越大，离摄像机越近，矩形越小。所以，同样大小的物体，随着离摄像机越来越远，相对于对应屏幕矩形就越来越小，所看起来就越来越小。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在屏幕上，某个像素点相对于屏幕矩形的位置，可以对应于游戏世界中的点相对于某个截面的位置，关键在于这个点在哪个截面上，也就是说，关键在于这个截面离摄像机有多远！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在ScreenToWorldPoint这个方法中，参数是一个三维坐标，而实际上，屏幕坐标只能是二维坐标。参数中的z坐标的作用就是：用来表示上述平面离摄像机的距离。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就是说，给定一个坐标（X，Y，Z），"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先截取一个垂直于摄像机Z轴的，距离为Z的平面P，这样不管X，Y怎么变化，返回的点都只能在这个平面上；"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，X，Y表示像素坐标，根据（X，Y）相对于屏幕的位置，得到游戏世界中的点相对于截面P的位置，我们也就将屏幕坐标转换为了世界坐标。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以如果要判断是否点中一个目标,则传入的z的值即你想选中的目标到摄像机的距离"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"使用射线","depth":2,"text":"使用射线"},{"id":"直接转换","depth":2,"text":"直接转换"}]}},"_type":"markdown","_id":"content:unity:2021-01-24-screentoworld.md","_source":"content","_file":"unity/2021-01-24-screentoworld.md","_extension":"md","date":"2021-01-24"},{"_path":"/unity/2020-12-20-collection-has-not-been-disposed","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","description":"A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.\n启用堆栈跟踪单击 Unity 菜单中的 Jobs > Leak Detection > Full Stack Traces 以选中它。还有记得重启unity然后，控制台中的错误内容将显示内存泄漏发生在数据保留位置。A Native Collection has not been disposed, resulting in a memory leak. Alloca","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"f:id:sugar_affordance:20201110091446p","src":"/images/2020-12-20-Collection-has-not-been-disposed/20201110091446.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.\n"}]}]},{"type":"element","tag":"h3","props":{"id":"启用堆栈跟踪"},"children":[{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%B9%A5%BF%A5%C3%A5%AF%A5%C8%A5%EC%A1%BC%A5%B9","rel":["nofollow"]},"children":[{"type":"text","value":"启用"}]},{"type":"text","value":"堆栈跟踪"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单击 Unity 菜单中的 Jobs > Leak Detection > Full Stack Traces 以选中它。还有记得重启unity"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"f:id:sugar_affordance:20201110091520p","src":"/images/2020-12-20-Collection-has-not-been-disposed/20201110091520.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，控制台中的错误内容将显示内存"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"泄漏"}]},{"type":"text","value":"发生在数据保留位置。"}]},{"type":"element","tag":"pre","props":{"code":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:\nUnity.Entities.BlobAssetStore:.ctor() (at Library/PackageCache/com.unity.entities@0.16.0-preview.21/Unity.Entities.Hybrid/GameObjectConversion/BlobAssetStore.cs:26)\nCreateEntitySystem:Setup(Transform) (at Assets/0_MainAssets/Scripts/ECS/System/CreateEntitySystem.cs:116)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:\nUnity.Entities.BlobAssetStore:.ctor() (at Library/PackageCache/com.unity.entities@0.16.0-preview.21/Unity.Entities.Hybrid/GameObjectConversion/BlobAssetStore.cs:26)\nCreateEntitySystem:Setup(Transform) (at Assets/0_MainAssets/Scripts/ECS/System/CreateEntitySystem.cs:116)\n"}]}]},{"type":"element","tag":"h4","props":{"id":"关于分配器"},"children":[{"type":"text","value":"关于分配器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NativeContainer（如 NativeArray）在 Dispose 中未释放内存时，会根据某些条件"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"检测"}]},{"type":"text","value":"为内存泄漏。 条件"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"因分配器"}]},{"type":"text","value":"的类型而异，分配器是 Allocator.TempJob，在确保本机 Array 时指定。"}]},{"type":"element","tag":"pre","props":{"code":"NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob);\n","language":"cs","meta":"","className":["language-cs"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个详细的解释。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ja/current/Manual/JobSystemNativeContainer.html","rel":["nofollow"]},"children":[{"type":"text","value":"NativeContainer - Unity 手册"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如果 Allocator.Temp"}]},{"type":"text","value":"在函数中没有 Dispose， 否则内存"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"泄漏"}]},{"type":"text","value":"，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"确定 Allocator.TempJob"}]},{"type":"text","value":"必须在\n4 帧内释放， 否则内存"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"泄漏确定"}]},{"type":"text","value":"__Allocator.Persistent 将永久保留，"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF","rel":["nofollow"]},"children":[{"type":"text","value":"并且不会"}]},{"type":"text","value":"检测到内存泄漏。"}]},{"type":"element","tag":"h3","props":{"id":"用-using-括起来确保内存安全"},"children":[{"type":"text","value":"用 using 括起来，确保内存安全"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"知道泄漏的位置后，我们只是将变量放在 Dispose 中，但**建议在 using"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/%A5%B9%A5%C6%A1%BC%A5%C8%A5%E1%A5%F3%A5%C8","rel":["nofollow"]},"children":[{"type":"text","value":"语句"}]},{"type":"text","value":"**中括起来。"}]},{"type":"element","tag":"pre","props":{"code":"using (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n","language":"cs","meta":"","className":["language-cs"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样，当您离开块时，将自动释放变量。\n当有多个变量时，请并排排列它们。"}]},{"type":"element","tag":"pre","props":{"code":"using (NativeArray<ArchetypeChunk> chunks = AnimationBatcherQuery.CreateArchetypeChunkArray(Allocator.TempJob))\nusing (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n","language":"cs","meta":"","className":["language-cs"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using (NativeArray<ArchetypeChunk> chunks = AnimationBatcherQuery.CreateArchetypeChunkArray(Allocator.TempJob))\nusing (NativeArray<float> leakArray = new NativeArray<float>(4, Allocator.TempJob)) {\n\n  // 処理\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/C%23","rel":["nofollow"]},"children":[{"type":"text","value":"从 C#"}]},{"type":"text","value":"8 开始，您可以在 Coco 中并排编写句点，但 Unity 现在"},{"type":"element","tag":"a","props":{"href":"http://d.hatena.ne.jp/keyword/C%23","rel":["nofollow"]},"children":[{"type":"text","value":"像 C#"}]},{"type":"text","value":"7.3 一样，将来会起作用吗？"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"启用堆栈跟踪","depth":3,"text":"启用堆栈跟踪"},{"id":"用-using-括起来确保内存安全","depth":3,"text":"用 using 括起来，确保内存安全"}]}},"_type":"markdown","_id":"content:unity:2020-12-20-Collection-has-not-been-disposed.md","_source":"content","_file":"unity/2020-12-20-Collection-has-not-been-disposed.md","_extension":"md","date":"2020-12-20"},{"_path":"/unity/2020-11-29-pitch-yaw-roll","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"pitch yaw roll是什么","description":"三维空间的右手笛卡尔坐标如图1所示。图1在航空中，pitch, yaw, roll如图2所示。pitch是围绕X轴旋转，也叫做俯仰角，如图3所示。yaw是围绕Y轴旋转，也叫偏航角，如图4所示。roll是围绕Z轴旋转，也叫翻滚角，如图5所示。图2图3-pitch是围绕X轴旋转图4-yaw是围绕Y轴旋转图5-roll是围绕Z轴旋转绕三个轴的旋转值pitch，yaw，roll来自航空界的叫法，翻译为俯仰角，偏航角，翻滚角，非常形象。\n从英文意思出发，roll:是卷；滚动，转动；辗的意思；\nyaw是（火箭、飞机、宇宙飞船等）偏航的意思；\npitch是坠落；倾斜；投掷的意思；\n所以，roll的意思是翻滚","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"三维空间的右手笛卡尔坐标如图1所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183456562"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在航空中，pitch, yaw, roll如图2所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pitch是围绕X轴旋转，也叫做俯仰角，如图3所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"yaw是围绕Y轴旋转，也叫偏航角，如图4所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"roll是围绕Z轴旋转，也叫翻滚角，如图5所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183507359"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183518578"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图3-pitch是围绕X轴旋转"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183525562"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图4-yaw是围绕Y轴旋转"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20140401183537890"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图5-roll是围绕Z轴旋转"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"绕三个轴的旋转值pitch，yaw，roll来自航空界的叫法，翻译为俯仰角，偏航角，翻滚角，非常形象。\n从英文意思出发，roll:是卷；滚动，转动；辗的意思；\nyaw是（火箭、飞机、宇宙飞船等）偏航的意思；\npitch是坠落；倾斜；投掷的意思；\n所以，roll的意思是翻滚，就是绕着机身所在的那个轴。yaw是偏航的意思，偏航就是绕着重力方向为轴。pitch倾斜、坠落的意思（头朝地坠落）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外值得注意的是，pitch值是不能超过90度，这里牵扯到了万向锁的知识，不再多说，网上很多讨论。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面这张图是以摄像机的角度来阐述欧拉角的，可以加深理解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-29-pitch-yaw-roll/20151125212621964"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-29-pitch-yaw-roll.md","_source":"content","_file":"unity/2020-11-29-pitch-yaw-roll.md","_extension":"md","date":"2020-11-29"}]