{"_path":"/tool/2019-09-02-redis-aof-rdb","_dir":"tool","_draft":false,"_partial":false,"_locale":"","title":"Redis的两种持久化RDB和AOF","description":"Redis 分别提供了 RDB 和 AOF 两种持久化机制：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 分别提供了 RDB 和 AOF 两种持久化机制："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-a7c5f2bb064f2c0307d15dca06d7d31d3adfc032.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本章首先介绍 AOF 功能的运作机制， 了解命令是如何被保存到 AOF 文件里的， 观察不同的 AOF 保存模式对数据的安全性、以及 Redis 性能的影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"之后会介绍从 AOF 文件中恢复数据库状态的方法，以及该方法背后的实现机制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后还会介绍对 AOF 进行重写以调整文件体积的方法， 并研究这种方法是如何在不改变数据库状态的前提下进行的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为本章涉及 AOF 运行的相关机制， 如果还没了解过 AOF 功能的话， 请先阅读 "},{"type":"element","tag":"a","props":{"href":"http://redis.io/topics/persistence","rel":["nofollow"]},"children":[{"type":"text","value":"Redis 持久化手册中关于 AOF 的部分"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"无论是rdb还是aof都是把存储的文件恢复到内存中"}]}]},{"type":"element","tag":"h1","props":{"id":"rdb优点与缺点"},"children":[{"type":"text","value":"RDB优点与缺点"}]},{"type":"element","tag":"h3","props":{"id":"优点"},"children":[{"type":"text","value":"优点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。"}]}]},{"type":"element","tag":"h3","props":{"id":"缺点"},"children":[{"type":"text","value":"缺点"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。\n"},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2019-09-02-redis-aof-rdb/20181004174024768.png"},"children":[]}]}]},{"type":"element","tag":"h2","props":{"id":"aof-命令同步"},"children":[{"type":"text","value":"AOF 命令同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的， 为了方便起见， 我们称呼这种记录过程为同步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子， 如果执行以下命令："}]},{"type":"element","tag":"pre","props":{"code":"redis> RPUSH list 1 2 3 4\n(integer) 4\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n\nredis> KEYS *\n1) \"list\"\n\nredis> RPOP list\n\"4\"\n\nredis> LPOP list\n\"1\"\n\nredis> LPUSH list 1\n(integer) 3\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"redis> RPUSH list 1 2 3 4\n(integer) 4\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n\nredis> KEYS *\n1) \"list\"\n\nredis> RPOP list\n\"4\"\n\nredis> LPOP list\n\"1\"\n\nredis> LPUSH list 1\n(integer) 3\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么其中四条对数据库有修改的写入命令就会被同步到 AOF 文件中："}]},{"type":"element","tag":"pre","props":{"code":"RPUSH list 1 2 3 4\n\nRPOP list\n\nLPOP list\n\nLPUSH list 1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"RPUSH list 1 2 3 4\n\nRPOP list\n\nLPOP list\n\nLPUSH list 1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了处理的方便， AOF 文件使用网络通讯协议的格式来保存这些命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 上面列举的四个命令在 AOF 文件中就实际保存如下："}]},{"type":"element","tag":"pre","props":{"code":"*2\n$6\nSELECT\n$1\n0\n*6\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n*2\n$4\nRPOP\n$4\nlist\n*2\n$4\nLPOP\n$4\nlist\n*3\n$5\nLPUSH\n$4\nlist\n$1\n1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"*2\n$6\nSELECT\n$1\n0\n*6\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n*2\n$4\nRPOP\n$4\nlist\n*2\n$4\nLPOP\n$4\nlist\n*3\n$5\nLPUSH\n$4\nlist\n$1\n1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/connection/select.html#select","rel":["nofollow"]},"children":[{"type":"text","value":"SELECT"}]},{"type":"text","value":" 命令是 AOF 程序自己加上去的之外， 其他命令都是之前我们在终端里执行的命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同步命令到 AOF 文件的整个过程可以分为三个阶段："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fsync"}]},{"type":"text","value":" 函数或者 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fdatasync"}]},{"type":"text","value":" 函数会被调用，将写入的内容真正地保存到磁盘中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下几个小节将详细地介绍这三个步骤。"}]},{"type":"element","tag":"h2","props":{"id":"命令传播"},"children":[{"type":"text","value":"命令传播"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当一个 Redis 客户端需要执行命令时， 它通过网络连接， 将协议文本发送给 Redis 服务器。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 要执行命令 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET KEY VALUE"}]},{"type":"text","value":" ， 客户端将向服务器发送文本 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n\""}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务器在接到客户端的请求之后， 它会根据协议文本的内容， 选择适当的命令函数， 并将各个参数从字符串文本转换为 Redis 字符串对象（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StringObject"}]},{"type":"text","value":"）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 针对上面的 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/string/set.html#set","rel":["nofollow"]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 命令例子， Redis 将客户端的命令指针指向实现 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/string/set.html#set","rel":["nofollow"]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 命令的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setCommand"}]},{"type":"text","value":" 函数， 并创建三个 Redis 字符串对象， 分别保存 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 、 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KEY"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VALUE"}]},{"type":"text","value":" 三个参数（命令也算作参数）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当命令函数成功执行之后， 命令参数都会被传播到 AOF 程序， 以及 REPLICATION 程序（本节不讨论这个，列在这里只是为了完整性的考虑）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个执行并传播命令的过程可以用以下伪代码表示："}]},{"type":"element","tag":"pre","props":{"code":"if (execRedisCommand(cmd, argv, argc) == EXEC_SUCCESS):\n\n    if aof_is_turn_on():\n        # 传播命令到 AOF 程序\n        propagate_aof(cmd, argv, argc)\n\n    if replication_is_turn_on():\n        # 传播命令到 REPLICATION 程序\n        propagate_replication(cmd, argv, argc)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if (execRedisCommand(cmd, argv, argc) == EXEC_SUCCESS):\n\n    if aof_is_turn_on():\n        # 传播命令到 AOF 程序\n        propagate_aof(cmd, argv, argc)\n\n    if replication_is_turn_on():\n        # 传播命令到 REPLICATION 程序\n        propagate_replication(cmd, argv, argc)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是该过程的流程图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-a5c804211267a10a5c3ffa47c5b600727191a3be.svg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"缓存追加"},"children":[{"type":"text","value":"缓存追加"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当命令被传播到 AOF 程序之后， 程序会根据命令以及命令的参数， 将命令从字符串对象转换回原来的协议文本。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如说， 如果 AOF 程序接受到的三个参数分别保存着 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET"}]},{"type":"text","value":" 、 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KEY"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VALUE"}]},{"type":"text","value":" 三个字符串， 那么它将生成协议文本 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n\""}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"协议文本生成之后， 它会被追加到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"redis.h/redisServer"}]},{"type":"text","value":" 结构的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 末尾。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"redisServer"}]},{"type":"text","value":" 结构维持着 Redis 服务器的状态， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 域则保存着所有等待写入到 AOF 文件的协议文本："}]},{"type":"element","tag":"pre","props":{"code":"struct redisServer {\n\n    // 其他域...\n\n    sds aof_buf;\n\n    // 其他域...\n};\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct redisServer {\n\n    // 其他域...\n\n    sds aof_buf;\n\n    // 其他域...\n};\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至此， 追加命令到缓存的步骤执行完毕。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综合起来，整个缓存追加过程可以分为以下三步："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"接受命令、命令的参数、以及参数的个数、所使用的数据库等信息。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将命令还原成 Redis 网络通讯协议。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将协议文本追加到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 末尾。"}]}]},{"type":"element","tag":"h2","props":{"id":"文件写入和保存"},"children":[{"type":"text","value":"文件写入和保存"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当服务器常规任务函数被执行、 或者事件处理器被执行时， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof.c/flushAppendOnlyFile"}]},{"type":"text","value":" 函数都会被调用， 这个函数执行以下两个工作："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"WRITE：根据条件，将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_buf"}]},{"type":"text","value":" 中的缓存写入到 AOF 文件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SAVE：根据条件，调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fsync"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fdatasync"}]},{"type":"text","value":" 函数，将 AOF 文件保存到磁盘中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。"}]},{"type":"element","tag":"h2","props":{"id":"aof-保存模式"},"children":[{"type":"text","value":"AOF 保存模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 目前支持三种 AOF 保存模式，它们分别是："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_NO"}]},{"type":"text","value":" ：不保存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_EVERYSEC"}]},{"type":"text","value":" ：每一秒钟保存一次。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_ALWAYS"}]},{"type":"text","value":" ：每执行一个命令保存一次。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下三个小节将分别讨论这三种保存模式。"}]},{"type":"element","tag":"h3","props":{"id":"不保存"},"children":[{"type":"text","value":"不保存"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式下， 每次调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"flushAppendOnlyFile"}]},{"type":"text","value":" 函数， WRITE 都会被执行， 但 SAVE 会被略过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式下， SAVE 只会在以下任意一种情况中被执行："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Redis 被关闭"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 功能被关闭"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。"}]},{"type":"element","tag":"h3","props":{"id":"每一秒钟保存一次"},"children":[{"type":"text","value":"每一秒钟保存一次"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fsync"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fdatasync"}]},{"type":"text","value":" 的调用并不是每秒一次， 它和调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"flushAppendOnlyFile"}]},{"type":"text","value":" 函数时 Redis 所处的状态有关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"flushAppendOnlyFile"}]},{"type":"text","value":" 函数被调用时， 可能会出现以下四种情况："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子线程正在执行 SAVE ，并且："},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。"}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子线程没有在执行 SAVE ，并且："},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以用流程图表示这四种情况："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-1b226a6d0f09ed1b61a30d899372834634b96504.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。"}]},{"type":"element","tag":"h3","props":{"id":"每执行一个命令保存一次"},"children":[{"type":"text","value":"每执行一个命令保存一次"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。"}]},{"type":"element","tag":"h2","props":{"id":"aof-保存模式对性能和安全性的影响"},"children":[{"type":"text","value":"AOF 保存模式对性能和安全性的影响"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在上一个小节， 我们简短地描述了三种 AOF 保存模式的工作方式， 现在， 是时候研究一下这三个模式在安全性和性能方面的区别了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不保存（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_NO"}]},{"type":"text","value":"）：写入和保存都由主进程执行，两个操作都会阻塞主进程。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一秒钟保存一次（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_EVERYSEC"}]},{"type":"text","value":"）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每执行一个命令保存一次（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_ALWAYS"}]},{"type":"text","value":"）：和模式 1 一样。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综合起来，三种 AOF 模式的操作特性可以总结如下："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"模式"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"WRITE 是否阻塞？"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"SAVE 是否阻塞？"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"停机时丢失的数据量"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_NO"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_EVERYSEC"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"不阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"一般情况下不超过 2 秒钟的数据。"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AOF_FSYNC_ALWAYS"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"阻塞"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"最多只丢失一个命令的数据。"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"aof-文件的读取和数据还原"},"children":[{"type":"text","value":"AOF 文件的读取和数据还原"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这也就是说， 只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Redis 读取 AOF 文件并还原数据库的详细步骤如下："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建一个不带网络连接的伪客户端（fake client）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"完成第 4 步之后， AOF 文件所保存的数据库就会被完整地还原出来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意， 因为 Redis 的命令只能在客户端的上下文中被执行， 而 AOF 还原时所使用的命令来自于 AOF 文件， 而不是网络， 所以程序使用了一个没有网络连接的伪客户端来执行命令。 伪客户端执行命令的效果， 和带网络连接的客户端执行命令的效果， 完全一样。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"整个读取和还原过程可以用以下伪代码表示："}]},{"type":"element","tag":"pre","props":{"code":"def READ_AND_LOAD_AOF():\n\n    # 打开并读取 AOF 文件\n    file = open(aof_file_name)\n    while file.is_not_reach_eof():\n\n        # 读入一条协议文本格式的 Redis 命令\n        cmd_in_text = file.read_next_command_in_protocol_format()\n\n        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象\n        cmd, argv, argc = text_to_command(cmd_in_text)\n\n        # 执行命令\n        execRedisCommand(cmd, argv, argc)\n\n    # 关闭文件\n    file.close()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def READ_AND_LOAD_AOF():\n\n    # 打开并读取 AOF 文件\n    file = open(aof_file_name)\n    while file.is_not_reach_eof():\n\n        # 读入一条协议文本格式的 Redis 命令\n        cmd_in_text = file.read_next_command_in_protocol_format()\n\n        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象\n        cmd, argv, argc = text_to_command(cmd_in_text)\n\n        # 执行命令\n        execRedisCommand(cmd, argv, argc)\n\n    # 关闭文件\n    file.close()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作为例子， 以下是一个简短的 AOF 文件的内容："}]},{"type":"element","tag":"pre","props":{"code":"*2\n$6\nSELECT\n$1\n0\n*3\n$3\nSET\n$3\nkey\n$5\nvalue\n*8\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n$1\n5\n$1\n6\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"*2\n$6\nSELECT\n$1\n0\n*3\n$3\nSET\n$3\nkey\n$5\nvalue\n*8\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n$1\n5\n$1\n6\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当程序读入这个 AOF 文件时， 它首先执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SELECT 0"}]},{"type":"text","value":" 命令 —— 这个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SELECT"}]},{"type":"text","value":" 命令是由 AOF 写入程序自动生成的， 它确保程序可以将数据还原到正确的数据库上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后执行后面的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SET key value"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RPUSH 1 2 3 4"}]},{"type":"text","value":" 命令， 还原 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"key"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 两个键的数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。"}]},{"type":"element","tag":"h2","props":{"id":"aof-重写"},"children":[{"type":"text","value":"AOF 重写"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOF 文件通过同步 Redis 服务器所执行的命令， 从而实现了数据库状态的记录， 但是， 这种同步方式会造成一个问题： 随着运行时间的流逝， AOF 文件会变得越来越大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子， 如果服务器执行了以下命令："}]},{"type":"element","tag":"pre","props":{"code":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么光是记录 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 键的状态， AOF 文件就需要保存四条命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另一方面， 有些被频繁操作的键， 对它们所调用的命令可能有成百上千、甚至上万条， 如果这样被频繁操作的键有很多的话， AOF 文件的体积就会急速膨胀， 对 Redis 、甚至整个系统的造成影响。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决以上的问题， Redis 需要对 AOF 文件进行重写（rewrite）： 创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下就来介绍 AOF 重写的实现方式。"}]},{"type":"element","tag":"h2","props":{"id":"aof-重写的实现"},"children":[{"type":"text","value":"AOF 重写的实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"考虑这样一个情况， 如果服务器对键 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 执行了以下四条命令："}]},{"type":"element","tag":"pre","props":{"code":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么当前列表键 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 在数据库中的值就为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[1, 2, 3]"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们要保存这个列表的当前状态， 并且尽量减少所使用的命令数， 那么最简单的方式不是去 AOF 文件上分析前面执行的四条命令， 而是直接读取 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"list"}]},{"type":"text","value":" 键在数据库的当前值， 然后用一条 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RPUSH 1 2 3"}]},{"type":"text","value":" 命令来代替前面的四条命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再考虑这样一个例子， 如果服务器对集合键 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"animal"}]},{"type":"text","value":" 执行了以下命令："}]},{"type":"element","tag":"pre","props":{"code":"SADD animal cat                 // {cat}\n\nSADD animal dog panda tiger     // {cat, dog, panda, tiger}\n\nSREM animal cat                 // {dog, panda, tiger}\n\nSADD animal cat lion            // {cat, lion, dog, panda, tiger}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"SADD animal cat                 // {cat}\n\nSADD animal dog panda tiger     // {cat, dog, panda, tiger}\n\nSREM animal cat                 // {dog, panda, tiger}\n\nSADD animal cat lion            // {cat, lion, dog, panda, tiger}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么使用一条 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SADD animal cat lion dog panda tiger"}]},{"type":"text","value":" 命令， 就可以还原 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"animal"}]},{"type":"text","value":" 集合的状态， 这比之前的四条命令调用要大大减少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。 整个重写过程可以用伪代码表示如下："}]},{"type":"element","tag":"pre","props":{"code":"def AOF_REWRITE(tmp_tile_name):\n\n  f = create(tmp_tile_name)\n\n  # 遍历所有数据库\n  for db in redisServer.db:\n\n    # 如果数据库为空，那么跳过这个数据库\n    if db.is_empty(): continue\n\n    # 写入 SELECT 命令，用于切换数据库\n    f.write_command(\"SELECT \" + db.number)\n\n    # 遍历所有键\n    for key in db:\n\n      # 如果键带有过期时间，并且已经过期，那么跳过这个键\n      if key.have_expire_time() and key.is_expired(): continue\n\n      if key.type == String:\n\n        # 用 SET key value 命令来保存字符串键\n\n        value = get_value_from_string(key)\n\n        f.write_command(\"SET \" + key + value)\n\n      elif key.type == List:\n\n        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键\n\n        item1, item2, ..., itemN = get_item_from_list(key)\n\n        f.write_command(\"RPUSH \" + key + item1 + item2 + ... + itemN)\n\n      elif key.type == Set:\n\n        # 用 SADD key member1 member2 ... memberN 命令来保存集合键\n\n        member1, member2, ..., memberN = get_member_from_set(key)\n\n        f.write_command(\"SADD \" + key + member1 + member2 + ... + memberN)\n\n      elif key.type == Hash:\n\n        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键\n\n        field1, value1, field2, value2, ..., fieldN, valueN =\\\n        get_field_and_value_from_hash(key)\n\n        f.write_command(\"HMSET \" + key + field1 + value1 + field2 + value2 +\\\n                        ... + fieldN + valueN)\n\n      elif key.type == SortedSet:\n\n        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN\n        # 命令来保存有序集键\n\n        score1, member1, score2, member2, ..., scoreN, memberN = \\\n        get_score_and_member_from_sorted_set(key)\n\n        f.write_command(\"ZADD \" + key + score1 + member1 + score2 + member2 +\\\n                        ... + scoreN + memberN)\n\n      else:\n\n        raise_type_error()\n\n      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间\n      if key.have_expire_time():\n        f.write_command(\"EXPIREAT \" + key + key.expire_time_in_unix_timestamp())\n\n    # 关闭文件\n    f.close()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"def AOF_REWRITE(tmp_tile_name):\n\n  f = create(tmp_tile_name)\n\n  # 遍历所有数据库\n  for db in redisServer.db:\n\n    # 如果数据库为空，那么跳过这个数据库\n    if db.is_empty(): continue\n\n    # 写入 SELECT 命令，用于切换数据库\n    f.write_command(\"SELECT \" + db.number)\n\n    # 遍历所有键\n    for key in db:\n\n      # 如果键带有过期时间，并且已经过期，那么跳过这个键\n      if key.have_expire_time() and key.is_expired(): continue\n\n      if key.type == String:\n\n        # 用 SET key value 命令来保存字符串键\n\n        value = get_value_from_string(key)\n\n        f.write_command(\"SET \" + key + value)\n\n      elif key.type == List:\n\n        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键\n\n        item1, item2, ..., itemN = get_item_from_list(key)\n\n        f.write_command(\"RPUSH \" + key + item1 + item2 + ... + itemN)\n\n      elif key.type == Set:\n\n        # 用 SADD key member1 member2 ... memberN 命令来保存集合键\n\n        member1, member2, ..., memberN = get_member_from_set(key)\n\n        f.write_command(\"SADD \" + key + member1 + member2 + ... + memberN)\n\n      elif key.type == Hash:\n\n        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键\n\n        field1, value1, field2, value2, ..., fieldN, valueN =\\\n        get_field_and_value_from_hash(key)\n\n        f.write_command(\"HMSET \" + key + field1 + value1 + field2 + value2 +\\\n                        ... + fieldN + valueN)\n\n      elif key.type == SortedSet:\n\n        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN\n        # 命令来保存有序集键\n\n        score1, member1, score2, member2, ..., scoreN, memberN = \\\n        get_score_and_member_from_sorted_set(key)\n\n        f.write_command(\"ZADD \" + key + score1 + member1 + score2 + member2 +\\\n                        ... + scoreN + memberN)\n\n      else:\n\n        raise_type_error()\n\n      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间\n      if key.have_expire_time():\n        f.write_command(\"EXPIREAT \" + key + key.expire_time_in_unix_timestamp())\n\n    # 关闭文件\n    f.close()\n"}]}]},{"type":"element","tag":"h2","props":{"id":"aof-后台重写"},"children":[{"type":"text","value":"AOF 后台重写"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上一节展示的 AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子进程进行 AOF 重写期间，主进程可以继续处理命令请求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2019-09-02-redis-aof-rdb/graphviz-982033b83f571a133367a8830ee5cca84f6a08e5.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"处理命令请求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将写命令追加到现有的 AOF 文件中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将写命令追加到 AOF 重写缓存中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样一来可以保证："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当步骤 1 执行完毕之后， 现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当步骤 2 执行完毕之后， 程序就完成了新旧两个 AOF 文件的交替。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上就是 AOF 后台重写， 也即是 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof","rel":["nofollow"]},"children":[{"type":"text","value":"BGREWRITEAOF"}]},{"type":"text","value":" 命令的工作原理。"}]},{"type":"element","tag":"h2","props":{"id":"aof-后台重写的触发条件"},"children":[{"type":"text","value":"AOF 后台重写的触发条件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AOF 重写可以由用户通过调用 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof","rel":["nofollow"]},"children":[{"type":"text","value":"BGREWRITEAOF"}]},{"type":"text","value":" 手动触发。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外， 服务器在 AOF 功能开启的情况下， 会维持以下三个变量："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"记录当前 AOF 文件大小的变量 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_current_size"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"记录最后一次 AOF 重写之后， AOF 文件大小的变量 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_rewrite_base_size"}]},{"type":"text","value":" 。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"增长百分比变量 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aof_rewrite_perc"}]},{"type":"text","value":" 。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每次当 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"serverCron"}]},{"type":"text","value":" 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"没有 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgsave.html#bgsave","rel":["nofollow"]},"children":[{"type":"text","value":"BGSAVE"}]},{"type":"text","value":" 命令在进行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"没有 "},{"type":"element","tag":"a","props":{"href":"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof","rel":["nofollow"]},"children":[{"type":"text","value":"BGREWRITEAOF"}]},{"type":"text","value":" 在进行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当前 AOF 文件大小大于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"server.aof_rewrite_min_size"}]},{"type":"text","value":" （默认值为 1 MB）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下， 增长百分比为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"100%"}]},{"type":"text","value":" ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。"}]},{"type":"element","tag":"h2","props":{"id":"小结"},"children":[{"type":"text","value":"小结"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 重写的目的是用更小的体积来保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 重写是一个有歧义的名字，实际的重写工作是针对数据库的当前值来进行的，程序既不读写、也不使用原有的 AOF 文件。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AOF 可以由用户手动触发，也可以由服务器自动触发。"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"优点","depth":3,"text":"优点"},{"id":"缺点","depth":3,"text":"缺点"},{"id":"aof-命令同步","depth":2,"text":"AOF 命令同步"},{"id":"命令传播","depth":2,"text":"命令传播"},{"id":"缓存追加","depth":2,"text":"缓存追加"},{"id":"文件写入和保存","depth":2,"text":"文件写入和保存"},{"id":"aof-保存模式","depth":2,"text":"AOF 保存模式","children":[{"id":"不保存","depth":3,"text":"不保存"},{"id":"每一秒钟保存一次","depth":3,"text":"每一秒钟保存一次"},{"id":"每执行一个命令保存一次","depth":3,"text":"每执行一个命令保存一次"}]},{"id":"aof-保存模式对性能和安全性的影响","depth":2,"text":"AOF 保存模式对性能和安全性的影响"},{"id":"aof-文件的读取和数据还原","depth":2,"text":"AOF 文件的读取和数据还原"},{"id":"aof-重写","depth":2,"text":"AOF 重写"},{"id":"aof-重写的实现","depth":2,"text":"AOF 重写的实现"},{"id":"aof-后台重写","depth":2,"text":"AOF 后台重写"},{"id":"aof-后台重写的触发条件","depth":2,"text":"AOF 后台重写的触发条件"},{"id":"小结","depth":2,"text":"小结"}]}},"_type":"markdown","_id":"content:tool:2019-09-02-redis-aof-rdb.md","_source":"content","_file":"tool/2019-09-02-redis-aof-rdb.md","_extension":"md","date":"2019-09-02"}