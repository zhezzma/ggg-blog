{"_path":"/unity/2020-11-15-ecs-parent","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"ecs中的parent","description":"ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"关于转换系统"},"children":[{"type":"text","value":"关于转换系统"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终调用的时候是使用."}]},{"type":"element","tag":"pre","props":{"code":"GameObjectConversionUtility.Convert(gameObjectWorld);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"GameObjectConversionUtility.Convert(gameObjectWorld);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后具体的转换过程会新疆一个转换world主要执行GameObjectConversionMappingSystem,然后转换完成后销毁这个world"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameObjectConversionUtility.ConvertGameObjectHierarchy(unitView.gameObject, settings)会转换所有child."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameObjectConversionMappingSystem.conversion.MappingSystem.AddGameObjectOrPrefab(root);会递归所有child"}]}]},{"type":"element","tag":"h1","props":{"id":"parent"},"children":[{"type":"text","value":"parent"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"localtoworld是一个矩阵"}]},{"type":"element","tag":"pre","props":{"code":"      EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"      EntityManager.SetComponentData(myCube, new LocalToWorld\n        {\n            Value = new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))\n        });\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-1eb72ea2222c31c50554021afecb27d1_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Translation"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Rotation"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Scale"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NonUniformScale"}]},{"type":"text","value":"组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 组件指向了父 Entity, 那么最终该 Entity 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LocalToWorld"}]},{"type":"text","value":" 值将会和父 Entity的 LocalToWorld 一样."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们新建一个场景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20201116024147417","src":"/images/2020-11-15-ecs-parent/image-20201116024147417.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查看分析器.就能看到如下关系图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20201116024105067","src":"/images/2020-11-15-ecs-parent/image-20201116024105067.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CUBE   "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"child"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"physicsCollider"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SPHER "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"parent"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"localtoparent"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"previousparent"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于物理的转化规则,子物体没有physicscollider."}]},{"type":"element","tag":"h2","props":{"id":"linkedentitygroup"},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"是一个 dynamic buffer , 通常它会影响:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":". 注意实例化并不一定和ECS中的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Prefab"}]},{"type":"text","value":" component 直接关联."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":"时也会同时销毁 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":"中的所有 entity. 类似在编辑器中删除"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"entityManager.SetEnabled"}]},{"type":"text","value":" 加上的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Disabled"}]},{"type":"text","value":"component 会告知 ECS 的查询系统忽略它们, 而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":" 中的 entity 也会受到同样的影响. 有点类似禁用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" 时同时会禁用整个层级树."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意如果buffer 中的 entity 也有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":", 系统"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"不会递归地"}]},{"type":"text","value":"执行instantiation/destroy/disabled 过程."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些过程在具体执行当中也有一些细微不同."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":"只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"必须要把自己包括在内"}]},{"type":"text","value":"才能正常工作**.** 然而"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":"则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要注意"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":"并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的."}]},{"type":"element","tag":"h2","props":{"id":"从非-prefab-conversion-中获取linkedentitygroup"},"children":[{"type":"text","value":"从非 prefab conversion 中获取LinkedEntityGroup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前, 我们使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"并不能得到 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":". 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"却可以正常得到基于"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Parent"}]},{"type":"text","value":" 的层级结构)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:"}]},{"type":"element","tag":"pre","props":{"code":" public void DeclareLinkedEntityGroup(GameObject gameObject)\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public void DeclareLinkedEntityGroup(GameObject gameObject)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果)."}]},{"type":"element","tag":"pre","props":{"code":"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-fe2983f48e754c910758292e0a0dfc91_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从 debbuger 现在可以看到已经正常添加了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]},{"type":"text","value":", 目前它已经支持"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnable"}]},{"type":"text","value":" 的正常工作了:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup."}]},{"type":"element","tag":"h2","props":{"id":"关于手动添加linkedentitygroup"},"children":[{"type":"text","value":"关于手动添加"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-de0722a0a9b1b64f962e00c0655f6641_1440w.jpg"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<LinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer<LinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class SpecialCube : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject itsChild;\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponent<LinkedEntityGroup>(entity);\n        var leg = dstManager.GetBuffer<LinkedEntityGroup>(entity);\n        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-50abef20adb51226bd0af6bddba9e8bb_1440w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-11-15-ecs-parent/v2-287469fff9e08d15954ccf00d6b63df5_1440w.jpg"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"关于parent和linkedentitygroup"},"children":[{"type":"text","value":"关于parent和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LinkedEntityGroup"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"parent 涉及到localtoworld, 以及一些物理和其他的转换规则"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"linkedEntityGroup 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Instantiate"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SetEnabled"}]},{"type":"text","value":"  "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DestroyEntity"}]},{"type":"text","value":" 有关"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"被disable的组件不会被foreach到,除非主动申请选取disable"}]},{"type":"element","tag":"h1","props":{"id":"最佳的方式去关联entity和prefab"},"children":[{"type":"text","value":"最佳的方式去关联entity和prefab"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/hybrid-ecs-best-way-to-handle-convert-and-inject-game-object-prefab.736646/","rel":["nofollow"]},"children":[{"type":"text","value":"Hybrid ECS] Best way to handle Convert and Inject Game Object Prefab? - Unity Forum"}]}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\n \npublic class Prefabs : MonoBehaviour\n{\n    private static Prefabs m_Instance;\n \n    public static GameObject PlayerModel => m_Instance.playerModel;\n \n    public GameObject playerModel;\n \n    private void Awake()\n    {\n        if (m_Instance == null)\n        {\n            m_Instance = this;\n        }\n        else\n        {\n            Debug.LogError(\"Prefab Singleton loaded twice\");\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\n \npublic class Prefabs : MonoBehaviour\n{\n    private static Prefabs m_Instance;\n \n    public static GameObject PlayerModel => m_Instance.playerModel;\n \n    public GameObject playerModel;\n \n    private void Awake()\n    {\n        if (m_Instance == null)\n        {\n            m_Instance = this;\n        }\n        else\n        {\n            Debug.LogError(\"Prefab Singleton loaded twice\");\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using Unity.Entities;\nusing Unity.NetCode;\nusing Unity.Transforms;\nusing UnityEngine;\n \n[UpdateInGroup(typeof(ClientSimulationSystemGroup))]\n \npublic class PlayerModelSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.WithNone<Transform>().ForEach((Entity playerEntity, ref PlayerComponent playerComponent) => {\n            if (Prefabs.PlayerModel != null)\n            {\n                var playerModel = Object.Instantiate(Prefabs.PlayerModel);\n                EntityManager.AddComponentObject(playerEntity, playerModel.GetComponent<Transform>());\n                EntityManager.AddComponentData(playerEntity, new CopyTransformToGameObject());\n            }\n        });\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.NetCode;\nusing Unity.Transforms;\nusing UnityEngine;\n \n[UpdateInGroup(typeof(ClientSimulationSystemGroup))]\n \npublic class PlayerModelSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.WithNone<Transform>().ForEach((Entity playerEntity, ref PlayerComponent playerComponent) => {\n            if (Prefabs.PlayerModel != null)\n            {\n                var playerModel = Object.Instantiate(Prefabs.PlayerModel);\n                EntityManager.AddComponentObject(playerEntity, playerModel.GetComponent<Transform>());\n                EntityManager.AddComponentData(playerEntity, new CopyTransformToGameObject());\n            }\n        });\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://forum.unity.com/threads/unity-tech-where-is-the-simple-bridge-between-monobehaviours-and-ecs.823485/","rel":["nofollow"]},"children":[{"type":"text","value":"Unity Tech - Where is the SIMPLE Bridge Between MonoBehaviours and ECS?? - Unity Forum"}]}]},{"type":"element","tag":"pre","props":{"code":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n \n// Attach to your Game Object to be converted, the GameObjectPrefab is a pure Game Object with no conversion that may contain MonoBehaviour components such as the particle system.\npublic class GameObjectPrefabAuthoring : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject GameObjectPrefab;\n \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentObject(entity, new GameObjectPrefab\n        {\n            Value = GameObjectPrefab\n        });\n    }\n}\n \npublic class GameObjectPrefab : IComponentData\n{\n    public GameObject Value;\n}\n \n// Instantiate and destroy the referenced prefab when the entity is created or destroyed. You can even pool the Game Object.\npublic class GameObjectPrefabSystem : JobComponentSystem\n{\n    public class GameObjectPrefabInstance : ISystemStateComponentData\n    {\n        public GameObject Value;\n    }\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities\n            .WithNone<GameObjectPrefabInstance>()\n            .ForEach((Entity entity, GameObjectPrefab gameObjectPrefab) =>\n            {\n                var gameObjectPrefabInstance = Object.Instantiate(gameObjectPrefab.Value);\n \n                EntityManager.AddComponentData(entity, new GameObjectPrefabInstance\n                {\n                    Value = gameObjectPrefabInstance\n                });\n \n                // Just an example to make the GameObject Prefab instance follow the entity.\n                EntityManager.AddComponentObject(entity, gameObjectPrefabInstance.transform);\n                EntityManager.AddComponent<CopyTransformToGameObject>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        Entities\n            .WithNone<GameObjectPrefab>()\n            .ForEach((Entity entity, GameObjectPrefabInstance gameObjectPrefabInstance) =>\n            {\n                Object.Destroy(gameObjectPrefabInstance.Value);\n \n                EntityManager.RemoveComponent<GameObjectPrefabInstance>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        return default;\n    }\n}\n \n// A dummy system for testing purposes.\npublic class DummyEntityWithGameObjectControllerSystem : JobComponentSystem\n{\n    EntityQuery m_Query;\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var deltaTime = Time.DeltaTime;\n        var speed = 3;\n        var direction = new float2(Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\"));\n        var destroy = Input.GetKeyDown(KeyCode.Delete);\n \n        if (destroy)\n        {\n            EntityManager.DestroyEntity(m_Query);\n        }\n \n        return Entities\n            .WithStoreEntityQueryInField(ref m_Query)\n            .WithAll<GameObjectPrefab>()\n            .ForEach((ref Translation translation) =>\n            {\n                translation.Value += math.normalizesafe(new float3(direction, 0).xzy) * speed * deltaTime;\n            })\n            .Schedule(inputDeps);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing UnityEngine;\n \n// Attach to your Game Object to be converted, the GameObjectPrefab is a pure Game Object with no conversion that may contain MonoBehaviour components such as the particle system.\npublic class GameObjectPrefabAuthoring : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public GameObject GameObjectPrefab;\n \n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        dstManager.AddComponentObject(entity, new GameObjectPrefab\n        {\n            Value = GameObjectPrefab\n        });\n    }\n}\n \npublic class GameObjectPrefab : IComponentData\n{\n    public GameObject Value;\n}\n \n// Instantiate and destroy the referenced prefab when the entity is created or destroyed. You can even pool the Game Object.\npublic class GameObjectPrefabSystem : JobComponentSystem\n{\n    public class GameObjectPrefabInstance : ISystemStateComponentData\n    {\n        public GameObject Value;\n    }\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        Entities\n            .WithNone<GameObjectPrefabInstance>()\n            .ForEach((Entity entity, GameObjectPrefab gameObjectPrefab) =>\n            {\n                var gameObjectPrefabInstance = Object.Instantiate(gameObjectPrefab.Value);\n \n                EntityManager.AddComponentData(entity, new GameObjectPrefabInstance\n                {\n                    Value = gameObjectPrefabInstance\n                });\n \n                // Just an example to make the GameObject Prefab instance follow the entity.\n                EntityManager.AddComponentObject(entity, gameObjectPrefabInstance.transform);\n                EntityManager.AddComponent<CopyTransformToGameObject>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        Entities\n            .WithNone<GameObjectPrefab>()\n            .ForEach((Entity entity, GameObjectPrefabInstance gameObjectPrefabInstance) =>\n            {\n                Object.Destroy(gameObjectPrefabInstance.Value);\n \n                EntityManager.RemoveComponent<GameObjectPrefabInstance>(entity);\n            })\n            .WithStructuralChanges()\n            .Run();\n \n        return default;\n    }\n}\n \n// A dummy system for testing purposes.\npublic class DummyEntityWithGameObjectControllerSystem : JobComponentSystem\n{\n    EntityQuery m_Query;\n \n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var deltaTime = Time.DeltaTime;\n        var speed = 3;\n        var direction = new float2(Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\"));\n        var destroy = Input.GetKeyDown(KeyCode.Delete);\n \n        if (destroy)\n        {\n            EntityManager.DestroyEntity(m_Query);\n        }\n \n        return Entities\n            .WithStoreEntityQueryInField(ref m_Query)\n            .WithAll<GameObjectPrefab>()\n            .ForEach((ref Translation translation) =>\n            {\n                translation.Value += math.normalizesafe(new float3(direction, 0).xzy) * speed * deltaTime;\n            })\n            .Schedule(inputDeps);\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"linkedentitygroup","depth":2,"text":"LinkedEntityGroup"},{"id":"从非-prefab-conversion-中获取linkedentitygroup","depth":2,"text":"从非 prefab conversion 中获取LinkedEntityGroup"},{"id":"关于手动添加linkedentitygroup","depth":2,"text":"关于手动添加LinkedEntityGroup"}]}},"_type":"markdown","_id":"content:unity:2020-11-15-ecs-parent.md","_source":"content","_file":"unity/2020-11-15-ecs-parent.md","_extension":"md","date":"2020-11-15"}