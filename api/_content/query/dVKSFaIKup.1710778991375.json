{"_path":"/dotnet/2020-01-06-dll-load","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"dll文件的加载","description":"程序的运行要去加载所需要的dll文件，在程序运行的时候往往会遇到dll找不到的问题，或者不能确定所加载的dll文件是否是自己所需要的dll，遇到dll出问题的时候往往会不知所措，但是一旦知道了dll的加载顺序，按这个去查找解决就会方便和得心应手了。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"程序的运行要去加载所需要的dll文件，在程序运行的时候往往会遇到dll找不到的问题，或者不能确定所加载的dll文件是否是自己所需要的dll，遇到dll出问题的时候往往会不知所措，但是一旦知道了dll的加载顺序，按这个去查找解决就会方便和得心应手了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(1)先搜索可执行文件所在路径，再搜索系统路径：%PATH%（环境变量所配置的路径）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般Path中的值为：%SystemRoot%\\system32;%SystemRoot%;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(2)然后按下列顺序搜索 DLL："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、当前进程的可执行模块所在的目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、当前目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、Windows 系统目录。GetSystemDirectory 函数检索此目录的路径。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、Windows 目录。GetWindowsDirectory 函数检索此目录的路径。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5、PATH 环境变量中列出的目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有时候确定了加载的dll文件确实是自己所想加载的dll文件，但是还会发生错误的可能原因，就是dll文件被损坏，此时需要重新替换现有的dll文件；或者dll文件和所用的头文件（.h文件）不匹配，即是头文件中的函数，在dll文件中没有实现，这样的话，找到对应的dll文件就ok了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"AssemblyLoadContext"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上AssemblyLoadContext是AppDomain的继承者，它提供相同而且更多的功能-除了安全边界（隔离）。最小的安全边界是进程，因此你将需要使用进程间通信来正确隔离数据和代码执行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"官网文档中提到Appdomain已经过时了，为了兼容旧的版本，提供了部分功能。建议在.NET Core3.0及更高的版本使用AssemblyLoadContext。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"从AppDomain迁移到AssemblyLoadContext"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也许你仍在应用程序中使用AppDomain。现在，以下代码显示如何用AssemblyLoadContext的相应方法去替换掉AppDomain方法："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取所有程序集"}]}]},{"type":"element","tag":"pre","props":{"code":"var assembliesInAppDomain = AppDomain.CurrentDomain.GetAssemblies();\nvar assembliesInAssemblyLoadContext = AssemblyLoadContext.Default.Assemblies;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var assembliesInAppDomain = AppDomain.CurrentDomain.GetAssemblies();\nvar assembliesInAssemblyLoadContext = AssemblyLoadContext.Default.Assemblies;\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加载一个程序集"}]}]},{"type":"element","tag":"pre","props":{"code":"AppDomain.CurrentDomain.Load(AssemblyName.GetAssemblyName(\"path\"));\nAssemblyLoadContext.Default.LoadFromAssemblyName(AssemblyName.GetAssemblyName(\"path\"));\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AppDomain.CurrentDomain.Load(AssemblyName.GetAssemblyName(\"path\"));\nAssemblyLoadContext.Default.LoadFromAssemblyName(AssemblyName.GetAssemblyName(\"path\"));\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加载一个程序集 路径或者字节数组:"}]}]},{"type":"element","tag":"pre","props":{"code":"AppDomain.CurrentDomain.Load(File.ReadAllBytes(\"path\"));\nAssemblyLoadContext.Default.LoadFromStream(File.OpenRead(\"path\"));// orAssemblyLoadContext.Default.LoadFromAssemblyPath(\"path\");\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AppDomain.CurrentDomain.Load(File.ReadAllBytes(\"path\"));\nAssemblyLoadContext.Default.LoadFromStream(File.OpenRead(\"path\"));// orAssemblyLoadContext.Default.LoadFromAssemblyPath(\"path\");\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"测试封装的获取程序集方法GetAssemblies"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"准备工作："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建一个控制台程序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加一个类库项目，命名为AA.Service"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在控制台应用程序，添加一个类TypeFinder代码如下："}]},{"type":"element","tag":"pre","props":{"code":"public class TypeFinder\n    {\n        /// <summary>\n        /// 获取物理路径 \n        /// </summary>\n        /// <returns>\\bin\\Debug\\netcoreapp3.0</returns>\n        public virtual string GetBinDirectory()\n        {\n            return AppContext.BaseDirectory;\n        }\n        /// <summary>\n        /// 获取程序集\n        /// </summary>\n        /// <returns></returns>\n        public IList<Assembly> GetAssemblies()\n        {\n            var binPath = GetBinDirectory();\n            var addedAssemblyNames = new List<string>();\n            var assemblies = new List<Assembly>();\n\n            //\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a=>IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n                addedAssemblyNames.Add(assembly.FullName);\n            }\n\n            foreach (var dllPath in Directory.GetFiles(binPath, \"*.dll\",\n                 SearchOption.TopDirectoryOnly))\n            {\n                try\n                {\n                    var an = AssemblyName.GetAssemblyName(dllPath);\n                    if (!addedAssemblyNames.Contains(an.FullName))\n                    {\n                        AssemblyLoadContext.Default.LoadFromAssemblyName(an);\n                    }\n                }\n                catch (BadImageFormatException ex)\n                {\n                    Trace.TraceError(ex.ToString());\n                }\n            }\n\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a => IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n\n                assemblies.Add(assembly);\n            }\n            return assemblies;\n        }\n\n        /// <summary>\n        /// 排除系统程序集\n        /// </summary>\n        /// <param name=\"assemblyName\"></param>\n        /// <returns></returns>\n        private bool IsNotSysAssembly(string assemblyName) \n        {\n            return !assemblyName.StartsWith(\"Microsoft.\")\n                      && !assemblyName.StartsWith(\"System.\")\n                      && !assemblyName.StartsWith(\"Newtonsoft.\")\n                      && assemblyName != \"netstandard\";\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class TypeFinder\n    {\n        /// <summary>\n        /// 获取物理路径 \n        /// </summary>\n        /// <returns>\\bin\\Debug\\netcoreapp3.0</returns>\n        public virtual string GetBinDirectory()\n        {\n            return AppContext.BaseDirectory;\n        }\n        /// <summary>\n        /// 获取程序集\n        /// </summary>\n        /// <returns></returns>\n        public IList<Assembly> GetAssemblies()\n        {\n            var binPath = GetBinDirectory();\n            var addedAssemblyNames = new List<string>();\n            var assemblies = new List<Assembly>();\n\n            //\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a=>IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n                addedAssemblyNames.Add(assembly.FullName);\n            }\n\n            foreach (var dllPath in Directory.GetFiles(binPath, \"*.dll\",\n                 SearchOption.TopDirectoryOnly))\n            {\n                try\n                {\n                    var an = AssemblyName.GetAssemblyName(dllPath);\n                    if (!addedAssemblyNames.Contains(an.FullName))\n                    {\n                        AssemblyLoadContext.Default.LoadFromAssemblyName(an);\n                    }\n                }\n                catch (BadImageFormatException ex)\n                {\n                    Trace.TraceError(ex.ToString());\n                }\n            }\n\n            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a => IsNotSysAssembly(a.FullName)))\n            {\n                if (addedAssemblyNames.Contains(assembly.FullName))\n                    continue;\n\n                assemblies.Add(assembly);\n            }\n            return assemblies;\n        }\n\n        /// <summary>\n        /// 排除系统程序集\n        /// </summary>\n        /// <param name=\"assemblyName\"></param>\n        /// <returns></returns>\n        private bool IsNotSysAssembly(string assemblyName) \n        {\n            return !assemblyName.StartsWith(\"Microsoft.\")\n                      && !assemblyName.StartsWith(\"System.\")\n                      && !assemblyName.StartsWith(\"Newtonsoft.\")\n                      && assemblyName != \"netstandard\";\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在控制台应用程序添加引用AA.Service类库，生成查看bin文件，出现了AA.Service.dll"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-06-dll-load/640.webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调用代码输出(排除系统dll以Microsoft、system开头的)程序集："}]},{"type":"element","tag":"pre","props":{"code":"var assemblies= new TypeFinder().GetAssemblies();        \nforeach (var a in assemblies)             \n{                \nConsole.WriteLine(a.FullName);            \n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var assemblies= new TypeFinder().GetAssemblies();        \nforeach (var a in assemblies)             \n{                \nConsole.WriteLine(a.FullName);            \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"输出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-06-dll-load/640.webp"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-01-06-dll-load.md","_source":"content","_file":"dotnet/2020-01-06-dll-load.md","_extension":"md","date":"2020-01-06"}