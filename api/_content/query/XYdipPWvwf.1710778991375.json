{"_path":"/dotnet/2022-08-15-equal-hashcode","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","description":"先看一个不负责任的写法//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n  ","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看一个不负责任的写法"}]},{"type":"element","tag":"pre","props":{"code":"//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n        }\n        public override bool Equals(object obj)\n        {\n            return true;\n        }\n \n    }\n    class Program\n    {\n            \n        static void Sum<T>() where T : MyMethod, new()\n        {\n            T t1 = new T();\n            T t2 = new T();\n             \n            t1.a = 3; t2.a = 4;//不会报错           \n             //t1.a=3;t2.a=3;报错，字典中已经存在相同键\n             Dictionary<MyMethod, int> d = new Dictionary<MyMethod, int>();\n            d.Add(t1, 1);\n            d.Add(t2, 2);\n            \n            \n        }\n        static void Main(string[] args)\n        {\n            \n            Sum<MyMethod>();\n            Console.Read();\n \n        }\n       \n    }\n \n}\n \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n        }\n        public override bool Equals(object obj)\n        {\n            return true;\n        }\n \n    }\n    class Program\n    {\n            \n        static void Sum<T>() where T : MyMethod, new()\n        {\n            T t1 = new T();\n            T t2 = new T();\n             \n            t1.a = 3; t2.a = 4;//不会报错           \n             //t1.a=3;t2.a=3;报错，字典中已经存在相同键\n             Dictionary<MyMethod, int> d = new Dictionary<MyMethod, int>();\n            d.Add(t1, 1);\n            d.Add(t2, 2);\n            \n            \n        }\n        static void Main(string[] args)\n        {\n            \n            Sum<MyMethod>();\n            Console.Read();\n \n        }\n       \n    }\n \n}\n \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说Dictionary的Add的具体实现,ILSpy反编译中C#Dictionary的Add方法源码："}]},{"type":"element","tag":"pre","props":{"code":"public void Add(TKey key, TValue value)\n{\n    this.Insert(key, value, true);\n}\n \n \nprivate void Insert(TKey key, TValue value, bool add)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n    if (this.buckets == null)\n    {\n        this.Initialize(0);\n    }\n    \n    int num = this.comparer.GetHashCode(key) & 2147483647;\n    int num2 = num % this.buckets.Length;\n    int num3 = 0;\n    for (int i = this.buckets[num2]; i >= 0; i = this.entries[i].next)\n    {\n        //如果hash值和字典中某个值的hash值相等 且 两个值的Equals返回值为True Trow 异常：已添加了具有相同键的项。\n        if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))\n        {\n            if (add)\n            {\n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            this.entries[i].value = value;\n            this.version++;\n            return;\n        }\n        num3++;\n    }\n    int num4;\n    if (this.freeCount > 0)\n    {\n        num4 = this.freeList;\n        this.freeList = this.entries[num4].next;\n        this.freeCount--;\n    }\n    else\n    {\n        if (this.count == this.entries.Length)\n        {\n            this.Resize();\n            num2 = num % this.buckets.Length;\n        }\n        num4 = this.count;\n        this.count++;\n    }\n    this.entries[num4].hashCode = num;\n    this.entries[num4].next = this.buckets[num2];\n    this.entries[num4].key = key;\n    this.entries[num4].value = value;\n    this.buckets[num2] = num4;\n    this.version++;\n    if (num3 > 100 && HashHelpers.IsWellKnownEqualityComparer(this.comparer))\n    {\n        this.comparer = (IEqualityComparer<TKey>)HashHelpers.GetRandomizedEqualityComparer(this.comparer);\n        this.Resize(this.entries.Length, true);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Add(TKey key, TValue value)\n{\n    this.Insert(key, value, true);\n}\n \n \nprivate void Insert(TKey key, TValue value, bool add)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n    if (this.buckets == null)\n    {\n        this.Initialize(0);\n    }\n    \n    int num = this.comparer.GetHashCode(key) & 2147483647;\n    int num2 = num % this.buckets.Length;\n    int num3 = 0;\n    for (int i = this.buckets[num2]; i >= 0; i = this.entries[i].next)\n    {\n        //如果hash值和字典中某个值的hash值相等 且 两个值的Equals返回值为True Trow 异常：已添加了具有相同键的项。\n        if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))\n        {\n            if (add)\n            {\n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            this.entries[i].value = value;\n            this.version++;\n            return;\n        }\n        num3++;\n    }\n    int num4;\n    if (this.freeCount > 0)\n    {\n        num4 = this.freeList;\n        this.freeList = this.entries[num4].next;\n        this.freeCount--;\n    }\n    else\n    {\n        if (this.count == this.entries.Length)\n        {\n            this.Resize();\n            num2 = num % this.buckets.Length;\n        }\n        num4 = this.count;\n        this.count++;\n    }\n    this.entries[num4].hashCode = num;\n    this.entries[num4].next = this.buckets[num2];\n    this.entries[num4].key = key;\n    this.entries[num4].value = value;\n    this.buckets[num2] = num4;\n    this.version++;\n    if (num3 > 100 && HashHelpers.IsWellKnownEqualityComparer(this.comparer))\n    {\n        this.comparer = (IEqualityComparer<TKey>)HashHelpers.GetRandomizedEqualityComparer(this.comparer);\n        this.Resize(this.entries.Length, true);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当每次调用Dictionary的Add方法时，参数都将与Dictionary中的值进行Equals，大家都知道DIctionary是用Hash值进行存储的，而hash值的计算方法是通过Object.GetHashCode实现的，如果这2个方法不一致，那么很容易就出现问题，特别是Dictionary中的Add方法这种情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"个人理解Dictionary的Add方法的实现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Add()->GetHashCode(),Equals()->判断2个hashcode是否相等 和Equals返回值是否为True->若同时成立，抛异常。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GetHashCode的目的不是为一个对象生成唯一的标识符，而是为了实现基于哈希表的数据结构，如Dictionary<K, V>或HashSet。 哈希函数需要确保如果x == ==y，那么x.GetHashCode()==  y.GetHashCode()，但反过来就不对了：两个不同的对象可以有相同的哈希代码。这种情况被称为哈希碰撞。 如果存在碰撞，哈希表结构仍然可以工作，但它们的运行速度较慢，因为你的程序必须花时间来分辨你要搜索的是哪个碰撞对象。因此，一个好的散列函数将努力使碰撞最小化。(注意，如果一个类有232个以上的可能值，要完全避免碰撞在数学上是不可能的，因为有鸽子笼原则）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，你如何为你的类写一个好的GetHashCode实现呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"做一些复杂的数学运算，将你的类的每一个字段转换为int，然后通过剖析来确定其中的系数的最佳值？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据Troelsen的说法，不需要。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要在你的 \"最独特 \"的字符串字段上调用GetHashCode()就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写System.String.GetHashCode的开发者知道他们在做什么，所以只要使用它，你就会自动利用他们的 \"坚实的哈希码算法\"。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2022-08-15-equal-hashcode.md","_source":"content","_file":"dotnet/2022-08-15-equal-hashcode.md","_extension":"md","date":"2022-08-15"}