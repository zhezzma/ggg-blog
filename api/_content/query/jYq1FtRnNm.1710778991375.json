{"_path":"/unity/2020-01-13-unity-attack-detection","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"unity攻击范围检测","description":"扇形攻击其实这个分为两部分，是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离是扇形角度范围内计算怪物是否在你的视野范围内其实可以这么看\nAvatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。这样就能判断是否在视线范围内。所以现在的问题就是这么计算这个夹角计算的方式是，获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量调用Vector3.Angle(a, b)计算夹角    public ","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"扇形攻击"},"children":[{"type":"text","value":"扇形攻击"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实这个分为两部分，"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是扇形角度范围内"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"计算怪物是否在你的视野范围内其实可以这么看\n"},{"type":"element","tag":"img","props":{"alt":"【小松教你手游开发】【unity实用技能】计算目标物体是否在自己的扇形视野范围","src":"/images/2020-01-13-unity-attack-detection/80f6c4220d181e73991a8dfdfda32a81.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Avatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样就能判断是否在视线范围内。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以现在的问题就是这么计算这个夹角"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"计算的方式是，"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"调用Vector3.Angle(a, b)计算夹角"}]}]},{"type":"element","tag":"pre","props":{"code":"    public GameObject avatar;\n    public GameObject enemy;\n    \n    //扇形距离 攻击距离  扇形的半径 \n    float minDistance = 10f;\n    //扇形的角度 也就是攻击的角度\n    float minAngle = 120f;\n\n    // Update is called once per frame\n    void Update ()\n    {\n        Vector3 avatarPos = avatar.transform.position;\n        Vector3 enemyPos = enemy.transform.position;\n        \n        //与敌人的距离\n        float distance = Vector3.Distance(avatarPos, enemyPos);\n\n        //主角相对于目标的向量\n        Vector3 srcLocalVect = enemyPos - avatarPos;\n        srcLocalVect.y = 0;\n\n        //获取主角正前方的一个点\n        Vector3 forwardLocalPos = avatar.transform.forward * 1 + avatarPos;\n\n        //获取正方向向量\n        Vector3 forwardLocalVect = forwardLocalPos - avatarPos;\n        forwardLocalVect.y = 0;\n\n        //计算角度\n        float angle = Vector3.Angle(srcLocalVect, forwardLocalVect);\n\n        if(distance < minDistance && angle < minAngle/2)\n        {\n            Debug.Log(\"In EyeSight\");\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public GameObject avatar;\n    public GameObject enemy;\n    \n    //扇形距离 攻击距离  扇形的半径 \n    float minDistance = 10f;\n    //扇形的角度 也就是攻击的角度\n    float minAngle = 120f;\n\n    // Update is called once per frame\n    void Update ()\n    {\n        Vector3 avatarPos = avatar.transform.position;\n        Vector3 enemyPos = enemy.transform.position;\n        \n        //与敌人的距离\n        float distance = Vector3.Distance(avatarPos, enemyPos);\n\n        //主角相对于目标的向量\n        Vector3 srcLocalVect = enemyPos - avatarPos;\n        srcLocalVect.y = 0;\n\n        //获取主角正前方的一个点\n        Vector3 forwardLocalPos = avatar.transform.forward * 1 + avatarPos;\n\n        //获取正方向向量\n        Vector3 forwardLocalVect = forwardLocalPos - avatarPos;\n        forwardLocalVect.y = 0;\n\n        //计算角度\n        float angle = Vector3.Angle(srcLocalVect, forwardLocalVect);\n\n        if(distance < minDistance && angle < minAngle/2)\n        {\n            Debug.Log(\"In EyeSight\");\n        }\n    }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"长方形范围攻击检测"},"children":[{"type":"text","value":"长方形范围攻击检测"}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            float rightDistance = Vector3.Dot(temVec, transform.right.normalized);\n\n            if (Mathf.Abs(rightDistance) <= 3)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            float rightDistance = Vector3.Dot(temVec, transform.right.normalized);\n\n            if (Mathf.Abs(rightDistance) <= 3)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"判断目标点是否在指定的矩形内两个随机点确定的矩形"},"children":[{"type":"text","value":"判断目标点是否在指定的矩形内（两个随机点确定的矩形）"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class Rectangle01\n{\n    /// Min为当前坐标系中矩形的最小点\n    /// Max为当前坐标系中矩形的最大点\n    public Vector2 Min;\n    public Vector2 Max;\n \n    public bool Contains( Vector2 point)\n    {\n        if (point.x < this.Min.x)\n        {\n            return false;\n        }\n        if (point.x > this.Max.x)\n        {\n            return false;\n        }\n        if (point.y < this.Min.y)\n        {\n            return false;\n        }\n        if (point.y > this.Max.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        vertex0 = this.Min;\n        vertex1 = new Vector2(this.Max.x, this.Min.y);\n        vertex2 = this.Max;\n        vertex3 = new Vector2(this.Min.x, this.Max.y);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class Rectangle01\n{\n    /// Min为当前坐标系中矩形的最小点\n    /// Max为当前坐标系中矩形的最大点\n    public Vector2 Min;\n    public Vector2 Max;\n \n    public bool Contains( Vector2 point)\n    {\n        if (point.x < this.Min.x)\n        {\n            return false;\n        }\n        if (point.x > this.Max.x)\n        {\n            return false;\n        }\n        if (point.y < this.Min.y)\n        {\n            return false;\n        }\n        if (point.y > this.Max.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        vertex0 = this.Min;\n        vertex1 = new Vector2(this.Max.x, this.Min.y);\n        vertex2 = this.Max;\n        vertex3 = new Vector2(this.Min.x, this.Max.y);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试   脚本"}]},{"type":"element","tag":"pre","props":{"code":"public class TestRt01 : MonoBehaviour {\n \n    public Transform Point;\n    public Transform RtPoint0, RtPoint1;\n    public Rectangle01 rtBox;\n \n    private const float _pointRadius = 0.1f;\n  \n    private void OnDrawGizmos()\n    {\n        if (rtBox != null)\n        {\n            DrawRt(rtBox);\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            rtBox = CreateFromTwoPoints(RtPoint0.position, RtPoint1.position);\n            bool cont = rtBox.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    public Rectangle01 CreateFromTwoPoints(Vector2 point0, Vector2 point1)\n    {\n        Rectangle01 rt = new Rectangle01();\n        if (point0.x < point1.x)\n        {\n            rt.Min.x = point0.x;\n            rt.Max.x = point1.x;\n        }\n        else\n        {\n            rt.Min.x = point1.x;\n            rt.Max.x = point0.x;\n        }\n        if (point0.y < point1.y)\n        {\n            rt.Min.y = point0.y;\n            rt.Max.y = point1.y;\n        }\n        else\n        {\n            rt.Min.y = point1.y;\n            rt.Max.y = point0.y;\n        }\n        return rt;\n    }\n \n    protected void DrawRt( Rectangle01 box)\n    {\n        Vector2 v0, v1, v2, v3;\n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class TestRt01 : MonoBehaviour {\n \n    public Transform Point;\n    public Transform RtPoint0, RtPoint1;\n    public Rectangle01 rtBox;\n \n    private const float _pointRadius = 0.1f;\n  \n    private void OnDrawGizmos()\n    {\n        if (rtBox != null)\n        {\n            DrawRt(rtBox);\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            rtBox = CreateFromTwoPoints(RtPoint0.position, RtPoint1.position);\n            bool cont = rtBox.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    public Rectangle01 CreateFromTwoPoints(Vector2 point0, Vector2 point1)\n    {\n        Rectangle01 rt = new Rectangle01();\n        if (point0.x < point1.x)\n        {\n            rt.Min.x = point0.x;\n            rt.Max.x = point1.x;\n        }\n        else\n        {\n            rt.Min.x = point1.x;\n            rt.Max.x = point0.x;\n        }\n        if (point0.y < point1.y)\n        {\n            rt.Min.y = point0.y;\n            rt.Max.y = point1.y;\n        }\n        else\n        {\n            rt.Min.y = point1.y;\n            rt.Max.y = point0.y;\n        }\n        return rt;\n    }\n \n    protected void DrawRt( Rectangle01 box)\n    {\n        Vector2 v0, v1, v2, v3;\n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"判断目标点是否在某一矩形区域以任一点为中心的矩形区域"},"children":[{"type":"text","value":"判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）"}]},{"type":"element","tag":"pre","props":{"code":"public class Box {\n \n    public Vector2 Center;\n    public Vector2 Axis0;\n    public Vector2 Axis1;\n    public Vector2 Extents;\n \n    public Box(Vector2 center, Vector2 axis0, Vector2 axis1, Vector2 extents)\n    {\n        this.Center = center;\n        this.Axis0 = axis0;\n        this.Axis1 = axis1;\n        this.Extents = extents;\n    }\n    public bool Contains(Vector2 point)\n    {\n        Vector2 vector;\n        vector.x = point.x - this.Center.x;\n        vector.y = point.y - this.Center.y;\n        float num = vector.Dot(ref this.Axis0);\n        if (num < -this.Extents.x)\n        {\n            return false;\n        }\n        if (num > this.Extents.x)\n        {\n            return false;\n        }\n        num = vector.Dot(ref this.Axis1);\n        if (num < -this.Extents.y)\n        {\n            return false;\n        }\n        if (num > this.Extents.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        Vector2 vector = (Vector2)(this.Axis0 * this.Extents.x);\n        Vector2 vector2 = (Vector2)(this.Axis1 * this.Extents.y);\n        vertex0 = (this.Center - vector) - vector2;\n        vertex1 = (this.Center + vector) - vector2;\n        vertex2 = (this.Center + vector) + vector2;\n        vertex3 = (this.Center - vector) + vector2;\n    }\n \n}\n \npublic static class Vector2ex\n{\n    public static float Dot(this Vector2 vector, ref Vector2 value)\n    {\n        return ((vector.x * value.x) + (vector.y * value.y));\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Box {\n \n    public Vector2 Center;\n    public Vector2 Axis0;\n    public Vector2 Axis1;\n    public Vector2 Extents;\n \n    public Box(Vector2 center, Vector2 axis0, Vector2 axis1, Vector2 extents)\n    {\n        this.Center = center;\n        this.Axis0 = axis0;\n        this.Axis1 = axis1;\n        this.Extents = extents;\n    }\n    public bool Contains(Vector2 point)\n    {\n        Vector2 vector;\n        vector.x = point.x - this.Center.x;\n        vector.y = point.y - this.Center.y;\n        float num = vector.Dot(ref this.Axis0);\n        if (num < -this.Extents.x)\n        {\n            return false;\n        }\n        if (num > this.Extents.x)\n        {\n            return false;\n        }\n        num = vector.Dot(ref this.Axis1);\n        if (num < -this.Extents.y)\n        {\n            return false;\n        }\n        if (num > this.Extents.y)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)\n    {\n        Vector2 vector = (Vector2)(this.Axis0 * this.Extents.x);\n        Vector2 vector2 = (Vector2)(this.Axis1 * this.Extents.y);\n        vertex0 = (this.Center - vector) - vector2;\n        vertex1 = (this.Center + vector) - vector2;\n        vertex2 = (this.Center + vector) + vector2;\n        vertex3 = (this.Center - vector) + vector2;\n    }\n \n}\n \npublic static class Vector2ex\n{\n    public static float Dot(this Vector2 vector, ref Vector2 value)\n    {\n        return ((vector.x * value.x) + (vector.y * value.y));\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试脚本"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class TestBox : MonoBehaviour {\n \n    public Transform Point;\n    public Transform rtBox;\n    Box box;\n    private const float _pointRadius = .11f;\n    private void OnDrawGizmos()\n    {\n        if (box!=null)\n        {\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n            DrawBox(ref box);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            box = new Box(rtBox.position, rtBox.right, rtBox.up, rtBox.localScale); ;\n            bool cont = box.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n \n    protected void DrawBox(ref Box box)\n    {\n        Vector2 v0, v1, v2, v3;\n \n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class TestBox : MonoBehaviour {\n \n    public Transform Point;\n    public Transform rtBox;\n    Box box;\n    private const float _pointRadius = .11f;\n    private void OnDrawGizmos()\n    {\n        if (box!=null)\n        {\n            Gizmos.DrawSphere(Point.position, _pointRadius);\n            DrawBox(ref box);\n        }\n    }\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            box = new Box(rtBox.position, rtBox.right, rtBox.up, rtBox.localScale); ;\n            bool cont = box.Contains(Point.position);\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n \n    protected void DrawBox(ref Box box)\n    {\n        Vector2 v0, v1, v2, v3;\n \n        box.CalcVertices(out v0, out v1, out v2, out v3);\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(v0, v1);\n        Gizmos.DrawLine(v1, v2);\n        Gizmos.DrawLine(v2, v3);\n        Gizmos.DrawLine(v3, v0);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"半圆形攻击范围检测"},"children":[{"type":"text","value":"半圆形攻击范围检测"}]},{"type":"element","tag":"pre","props":{"code":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            if (distance <= 5)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using UnityEngine;\nusing System.Collections;\n\n\npublic class AttackCHeck : MonoBehaviour\n{\n    //要攻击的目标\n    public Transform Target;\n    private void Update()\n    {\n        //计算玩家与敌人的距离\n        float distance = Vector3.Distance(transform.position, Target.position);\n        //玩家与敌人的方向向量\n        Vector3 temVec = Target.position - transform.position;\n        //与玩家正前方做点积\n        float forwardDistance = Vector3.Dot(temVec, transform.forward.normalized);\n        if (forwardDistance > 0 && forwardDistance <= 10)\n        {\n            if (distance <= 5)\n            {\n                Debug.Log(\"进入攻击范围\");\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"圆形攻击范围"},"children":[{"type":"text","value":"圆形攻击范围"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"圆形攻击范围有两种，以玩着荣耀的王昭君大招为例子，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一种是制定位置施法：新版本的王昭君的大招是指定位置施法的，也就是说在玩家固定施法半径以内可随意放一个圆形的技能。在半径之内的敌人受伤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二种是固定位置施法：老版本的王昭君大招是在自身一定半径以内，敌人在这个范围内受伤。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实两种判断都很简单，只需要判断敌人和SkillPosition之间的距离是否小于半径即可。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-01-13-unity-attack-detection/20180425195609483.png"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"/// <summary>\n    /// 不定点式圆形攻击\n    /// </summary>\n    /// <param name=\"attacked\">被攻击方</param>\n    /// <param name=\"skillPosition\">技能释放位置</param>\n    /// <param name=\"radius\">半径</param>\n    /// <returns></returns>\n    public bool CircleAttack(Transform attacked,Transform skillPosition, float radius)\n    {\n        float distance = Vector3.Distance(attacked.position, skillPosition.position);\n        if (distance < radius)\n        {\n            return true;\n        }\n        return false;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/// <summary>\n    /// 不定点式圆形攻击\n    /// </summary>\n    /// <param name=\"attacked\">被攻击方</param>\n    /// <param name=\"skillPosition\">技能释放位置</param>\n    /// <param name=\"radius\">半径</param>\n    /// <returns></returns>\n    public bool CircleAttack(Transform attacked,Transform skillPosition, float radius)\n    {\n        float distance = Vector3.Distance(attacked.position, skillPosition.position);\n        if (distance < radius)\n        {\n            return true;\n        }\n        return false;\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"方法2"}]},{"type":"element","tag":"pre","props":{"code":"public class Circle {\n \n    public Vector2 Center;\n    public float Radius;\n \n    public Circle(Vector2 center, float radius)\n    {\n        this.Center = center;\n        this.Radius = radius;\n    }\n \n    public bool Contains( Vector2 point)\n    {\n        Vector2 vector = point - this.Center;\n        return (vector.SqrMagnitude() <= (this.Radius * this.Radius));\n    }\n \n    public Vector2 Eval(float t)\n    {\n        return new Vector2(this.Center.x + (this.Radius * Mathf.Cos(t)), this.Center.y + (this.Radius * Mathf.Sin(t)));\n    }\n }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Circle {\n \n    public Vector2 Center;\n    public float Radius;\n \n    public Circle(Vector2 center, float radius)\n    {\n        this.Center = center;\n        this.Radius = radius;\n    }\n \n    public bool Contains( Vector2 point)\n    {\n        Vector2 vector = point - this.Center;\n        return (vector.SqrMagnitude() <= (this.Radius * this.Radius));\n    }\n \n    public Vector2 Eval(float t)\n    {\n        return new Vector2(this.Center.x + (this.Radius * Mathf.Cos(t)), this.Center.y + (this.Radius * Mathf.Sin(t)));\n    }\n }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"判断一个点是否在三角形里面"},"children":[{"type":"text","value":"判断一个点是否在三角形里面"}]},{"type":"element","tag":"pre","props":{"code":"public static  bool InTrigon(Vector3 _target,Vector3 _center,Vector3 _left,Vector3 _right){  \n        Vector3 Ctl=_left-_center;  \n        Vector3 Ctr=_right -_center;  \n        Vector3 Ctt=_target-_center;  \n        Vector3 Ltr=_right-_left;  \n        Vector3 Ltc=_right-_center;  \n        Vector3 Ltt=_left-_target;  \n        Vector3 Rtl=_left-_right;  \n        Vector3 Rtc=_center-_right;  \n        Vector3 Rtt=_target-_right;  \n        if(   \n           Vector3.Dot(Vector3.Cross(Ctl,Ctr).normalized,Vector3.Cross(Ctl,Ctt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Ltr,Ltc).normalized,Vector3.Cross(Ltr,Ltt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Rtc,Rtl).normalized,Vector3.Cross(Rtc,Rtt).normalized)==1  \n           )  \n            return true;  \n        else  \n            return false;  \n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static  bool InTrigon(Vector3 _target,Vector3 _center,Vector3 _left,Vector3 _right){  \n        Vector3 Ctl=_left-_center;  \n        Vector3 Ctr=_right -_center;  \n        Vector3 Ctt=_target-_center;  \n        Vector3 Ltr=_right-_left;  \n        Vector3 Ltc=_right-_center;  \n        Vector3 Ltt=_left-_target;  \n        Vector3 Rtl=_left-_right;  \n        Vector3 Rtc=_center-_right;  \n        Vector3 Rtt=_target-_right;  \n        if(   \n           Vector3.Dot(Vector3.Cross(Ctl,Ctr).normalized,Vector3.Cross(Ctl,Ctt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Ltr,Ltc).normalized,Vector3.Cross(Ltr,Ltt).normalized)==1&&  \n           Vector3.Dot(Vector3.Cross(Rtc,Rtl).normalized,Vector3.Cross(Rtc,Rtt).normalized)==1  \n           )  \n            return true;  \n        else  \n            return false;  \n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原理：通过向量之间的对比，利用点乘和差乘实现判断一个点是否在三角形里面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"叉乘： 叉乘结果用右手判断法则。"}]},{"type":"element","tag":"h3","props":{"id":"方法二"},"children":[{"type":"text","value":"方法二"}]},{"type":"element","tag":"pre","props":{"code":"public class Triangle \n{\n    public enum Orientations\n    {\n        CW,//三个点顺时针\n        CCW,//三个点逆时针\n        None//不清楚点的顺序\n    }\n \n    public Vector2 V0;\n    public Vector2 V1;\n    public Vector2 V2;\n    public Triangle(Vector2 v0, Vector2 v1, Vector2 v2)\n    {\n        this.V0 = v0;\n        this.V1 = v1;\n        this.V2 = v2;\n    }\n    public static Triangle CreateTriangle2(Transform v0, Transform v1, Transform v2)\n    {\n        return new Triangle(v0.position, v1.position, v2.position);\n    }\n \n    public Orientations CalcOrientation(float threshold = 1E-05f)\n    {\n        float num = this.CalcDeterminant();\n        if (num > threshold)\n        {\n            return Orientations.CCW;\n        }\n        if (num < -threshold)\n        {\n            return Orientations.CW;\n        }\n        return Orientations.None;\n    }\n \n    public float CalcDeterminant()\n    {\n        return ((((((this.V1.x * this.V2.y) + (this.V0.x * this.V1.y)) + (this.V2.x * this.V0.y)) - (this.V1.x * this.V0.y)) - (this.V2.x * this.V1.y)) - (this.V0.x * this.V2.y));\n    }\n \n    public bool Contains(Vector2 point)\n    {\n        bool flag = (((point.x - this.V1.x) * (this.V0.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V0.x - this.V1.x))) < 0f;\n        bool flag2 = (((point.x - this.V2.x) * (this.V1.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V1.x - this.V2.x))) < 0f;\n        if (flag != flag2)\n        {\n            return false;\n        }\n        bool flag3 = (((point.x - this.V0.x) * (this.V2.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V2.x - this.V0.x))) < 0f;\n        return (flag2 == flag3);\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是逆时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) > 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是顺时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) < 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public class Triangle \n{\n    public enum Orientations\n    {\n        CW,//三个点顺时针\n        CCW,//三个点逆时针\n        None//不清楚点的顺序\n    }\n \n    public Vector2 V0;\n    public Vector2 V1;\n    public Vector2 V2;\n    public Triangle(Vector2 v0, Vector2 v1, Vector2 v2)\n    {\n        this.V0 = v0;\n        this.V1 = v1;\n        this.V2 = v2;\n    }\n    public static Triangle CreateTriangle2(Transform v0, Transform v1, Transform v2)\n    {\n        return new Triangle(v0.position, v1.position, v2.position);\n    }\n \n    public Orientations CalcOrientation(float threshold = 1E-05f)\n    {\n        float num = this.CalcDeterminant();\n        if (num > threshold)\n        {\n            return Orientations.CCW;\n        }\n        if (num < -threshold)\n        {\n            return Orientations.CW;\n        }\n        return Orientations.None;\n    }\n \n    public float CalcDeterminant()\n    {\n        return ((((((this.V1.x * this.V2.y) + (this.V0.x * this.V1.y)) + (this.V2.x * this.V0.y)) - (this.V1.x * this.V0.y)) - (this.V2.x * this.V1.y)) - (this.V0.x * this.V2.y));\n    }\n \n    public bool Contains(Vector2 point)\n    {\n        bool flag = (((point.x - this.V1.x) * (this.V0.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V0.x - this.V1.x))) < 0f;\n        bool flag2 = (((point.x - this.V2.x) * (this.V1.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V1.x - this.V2.x))) < 0f;\n        if (flag != flag2)\n        {\n            return false;\n        }\n        bool flag3 = (((point.x - this.V0.x) * (this.V2.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V2.x - this.V0.x))) < 0f;\n        return (flag2 == flag3);\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是逆时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) > 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) > 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n \n    /// <summary>\n    /// 当已经知道 三个顶点的顺序是顺时针方向的时候使用\n    /// </summary>\n    /// <param name=\"point\"></param>\n    /// <returns></returns>\n    public bool ContainsCW(Vector2 point)\n    {\n        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) < 0f)\n        {\n            return false;\n        }\n        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) < 0f)\n        {\n            return false;\n        }\n        return true;\n    }\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试脚本"}]},{"type":"element","tag":"pre","props":{"code":"\npublic class TriangleTest : MonoBehaviour {\n    public Transform Point;\n    public Transform V0, V1, V2;\n    Triangle triangle;\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            triangle = Triangle.CreateTriangle2(V0, V1, V2);\n            Triangle.Orientations orientation = triangle.CalcOrientation();\n \n            bool cont = false;\n            if (orientation == Triangle.Orientations.CCW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else if (orientation == Triangle.Orientations.CW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else // Degenerate\n            {\n                Debug.LogError(\"Triangle is degenerate\");\n            }\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    private void OnDrawGizmos()\n    {\n        if (triangle!=null)\n        {\n            DrawTriangle( triangle);\n        }\n    }\n \n \n    void DrawTriangle( Triangle triangle)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(triangle.V0, triangle.V1);\n        Gizmos.DrawLine(triangle.V1, triangle.V2);\n        Gizmos.DrawLine(triangle.V2, triangle.V0);\n    }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class TriangleTest : MonoBehaviour {\n    public Transform Point;\n    public Transform V0, V1, V2;\n    Triangle triangle;\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            triangle = Triangle.CreateTriangle2(V0, V1, V2);\n            Triangle.Orientations orientation = triangle.CalcOrientation();\n \n            bool cont = false;\n            if (orientation == Triangle.Orientations.CCW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else if (orientation == Triangle.Orientations.CW)\n            {\n                 cont = triangle.Contains(Point.position);\n                 //cont1 = triangle.ContainsCW(Point.position); // 如果你知道三角形方向(顶点顺序方向)，就用这个\n            }\n            else // Degenerate\n            {\n                Debug.LogError(\"Triangle is degenerate\");\n            }\n            if (cont)\n            {\n                Debug.Log(\"目标点在矩形范围内\");\n            }\n            else\n            {\n                Debug.Log(\"目标点不在矩形范围内\");\n            }\n        }\n    }\n    private void OnDrawGizmos()\n    {\n        if (triangle!=null)\n        {\n            DrawTriangle( triangle);\n        }\n    }\n \n \n    void DrawTriangle( Triangle triangle)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawLine(triangle.V0, triangle.V1);\n        Gizmos.DrawLine(triangle.V1, triangle.V2);\n        Gizmos.DrawLine(triangle.V2, triangle.V0);\n    }\n\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"向量"},"children":[{"type":"text","value":"向量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实这些小算法基本上用的全是向量的计算,向量的计算有两种"}]},{"type":"element","tag":"h3","props":{"id":"向量的点乘"},"children":[{"type":"text","value":"向量的点乘"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"–>A . B = |A| * |B| * cos θ\n–>点乘应用"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果 让 A 等于单位向量 |A| ==1 c点积 等于 B 在 A 上的投影"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果 让 A B等于单位向量 arccos(a.b) == 夹角"}]}]},{"type":"element","tag":"h3","props":{"id":"向量的叉乘"},"children":[{"type":"text","value":"向量的叉乘"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"–>A* B = C C就是A和B的法向量\n–>叉乘应用"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"c 是有方向 。 通过 左手 定则 可以知道 C 的方向"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所以叉乘一般是用来计算方向的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A 和 B 都是单位向量 arcsin(|A*B|) 等于 夹角"}]}]},{"type":"element","tag":"h1","props":{"id":"凸多边形碰撞分离轴定理算法"},"children":[{"type":"text","value":"凸多边形碰撞(分离轴定理算法)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"*"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"正文如下：*"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"多边形碰撞","src":"/images/2020-01-13-unity-attack-detection/20170204235932265.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当我发现我需要在flash中检测多边形碰撞时，我碰巧地遇到了一个叫“分离轴定理”的方法。但唯一的问题是，为了真正地掌握它，我可费了不少功夫。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在阅读了大量有关碰撞检测的资料，并参看了一些代码示例后，这个方法总算被我领悟了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了帮助其他那些不精通数学的开发者，我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍。我还在下文引入了一个使用分离轴定理实现的demo，以及供大家下载并使用的ActionScript 3源代码。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"（译者：demo和源代码请到原文中查看和下载）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：分离轴定理需要一点数学向量的知识，所以在深究这个算法前，你最好复习一下这方面的内容。"}]},{"type":"element","tag":"h1","props":{"id":"算法简述"},"children":[{"type":"text","value":"算法简述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从根本上来讲，分离轴定理（以及其他碰撞算法）的用途就是去检测并判断两个图形之间是否有间隙。分离轴定理中用到的方法使算法本身显得十分独特。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我所听到过分离轴定理的最好类比方式是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"投影问题","src":"/images/2020-01-13-unity-attack-detection/20170205000242395.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从编程的角度来讲，从每个可能的角度上去检测会使处理变得十分密集。不过幸运的是，由于多边形的性质，你只需要检测其中几个关键的角度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你需要检测的角度数量就正是这个多边形的边数。也就是说，你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和。举个例子，两个五边形就需要检测10个角度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"角度选取","src":"/images/2020-01-13-unity-attack-detection/20170205000357272.jpg"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"如何在代码中实现"},"children":[{"type":"text","value":"如何在代码中实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个简易但比较啰嗦的方法，以下是基本的步骤："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤一：**从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤一图解","src":"/images/2020-01-13-unity-attack-detection/20170205000919294.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤二：**循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤二图解","src":"/images/2020-01-13-unity-attack-detection/20170205001546835.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤三：**对第二个多边形做同样的处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤三图解","src":"/images/2020-01-13-unity-attack-detection/20170205001940563.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**步骤四：**分别得到这两个多边形的投影，并检测这两段投影是否重叠。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"步骤四图解","src":"/images/2020-01-13-unity-attack-detection/20170205002051627.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个算法基本就是如此的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顺带提一下，如果你记录了哪个轴上的投影重叠值最小（以及重叠了多少），那么你就能用这个值来分开这两个图形。"}]},{"type":"element","tag":"h2","props":{"id":"那么如何处理圆呢"},"children":[{"type":"text","value":"那么如何处理圆呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在分离轴定理中，检测圆与检测多边形相比，会有点点奇异，但仍然是可以实现的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"圆的投影轴","src":"/images/2020-01-13-unity-attack-detection/20170205002152799.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这以后就是按套路遍历另一个多边形的每条投影轴，并检测是否有投影重叠。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"噢，对了，万一你想知道如何把圆投影到轴上，那你只用简单地把圆心投影上去，然后加上和减去半径就能得到投影长度了。"}]},{"type":"element","tag":"h1","props":{"id":"优点与不足"},"children":[{"type":"text","value":"优点与不足"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和其他的碰撞检测技术一样，分离轴定理算法有它自己的优点和不足。以下是其一些优点和不足的简要概述："}]},{"type":"element","tag":"h2","props":{"id":"优点"},"children":[{"type":"text","value":"优点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（译者：原来老外也喜欢先谈优点啊～>～）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……）"}]}]},{"type":"element","tag":"h2","props":{"id":"不足"},"children":[{"type":"text","value":"不足"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可能这个算法会有更多优点和不足之处，但是我想这应该是最主要的几个了。"}]},{"type":"element","tag":"h1","props":{"id":"总结"},"children":[{"type":"text","value":"总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我希望这篇文章能帮助你了解到分离轴定理算法。我已经尽可能地不提供过多的信息并讲解得十分简明了。（我绝不是数学方面的专家，所以如果我遗漏了什么，我深表歉意）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是一些帮助我理解分离轴定理算法的页面："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.harveycartel.org/metanet/tutorials/tutorialA.html","rel":["nofollow"]},"children":[{"type":"text","value":"harverycartel.org"}]},{"type":"text","value":"——有更多详细的表述以及很多很酷的示例。我在这个页面上学到了很多。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://gpwiki.org/index.php/VB:Tutorials:Building_A_Physics_Engine:Basic_Intersection_Detection","rel":["nofollow"]},"children":[{"type":"text","value":"GPWiki.org"}]},{"type":"text","value":"——有不错的讲解和代码示例，我用这些代码作为编写自己代码的基础。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.tonypa.pri.ee/vectors/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"Tony Pa"}]},{"type":"text","value":"——向量教程，学习向量的不错资源。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.gamedev.net/community/forums/topic.asp?topic_id=251638","rel":["nofollow"]},"children":[{"type":"text","value":"GameDev.net forum"}]},{"type":"text","value":"——一个论坛成员写的分离轴定理碰撞检测系统，带给了我一些计算方面的想法。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"本文翻译自"}]},{"type":"element","tag":"a","props":{"href":"http://www.sevenson.com.au/","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"@sevenson"}]}]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"的文章"}]},{"type":"element","tag":"a","props":{"href":"http://www.sevenson.com.au/actionscript/sat/","rel":["nofollow"]},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Separating Axis Theorem (SAT) Explanation"}]}]},{"type":"text","value":"** 。**"}]},{"type":"element","tag":"pre","props":{"code":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XRect{\n    private Vector2 _point0 = new Vector2();\n    private Vector2 _point1 = new Vector2();\n    private Vector2 _point2 = new Vector2();\n    private Vector2 _point3 = new Vector2();\n\n    public List<Vector2> _pointList = new List<Vector2>();\n\n    private float _min = 0;\n    private float _max = 0;\n\n\n    public void UpdatePoint(RectTransform RT)\n    {\n        float x = RT.localPosition.x;\n        float y = RT.localPosition.y;\n        float width = RT.sizeDelta.x;\n        float height = RT.sizeDelta.y;\n        float angle = RT.localRotation.eulerAngles.z;\n\n        Vector2 centerV = new Vector2(RT.localPosition.x, RT.localPosition.y);\n\n        _point0 = new Vector2(x - width / 2, y + height / 2);\n        _point0 = _Transform(_point0,angle,centerV);\n\n        _point1 = new Vector2(x + width / 2, y + height / 2);\n        _point1 = _Transform(_point1, angle, centerV);\n\n        _point2 = new Vector2(x + width / 2, y - height / 2);\n        _point2 = _Transform(_point2, angle, centerV);\n\n        _point3 = new Vector2(x - width / 2, y - height / 2);\n        _point3 = _Transform(_point3, angle, centerV);\n\n        _pointList.Clear();\n        _pointList.Add(_point0);\n        _pointList.Add(_point1);\n        _pointList.Add(_point2);\n        _pointList.Add(_point3);\n\n        Vector3[] temp = new Vector3[4];\n        RT.GetLocalCorners(temp);\n       \n    }\n\n    //获取投影轴\n    public Vector2 GetAxis(int index)\n    {\n        Vector2 v = _GetEdge(index);\n\n        Vector2 result = new Vector2();\n\n        result.x = v.y;\n        result.y = 0 - v.x;\n\n        return result;\n    }\n\n    public void ResetProjection(Vector2 axis)\n    {\n        if (axis.x == 0 && axis.y == 0)\n        {\n            Debug.LogError(\"投影轴数据错误！\");\n            return;\n        }\n        float projectionX;\n        Vector2 v;\n        for (int i = 0; i < _pointList.Count; ++i)\n        {\n            v = _pointList[i];\n            if (axis.x == 0)\n            {\n                projectionX = v.y;\n            }\n            else if (axis.y == 0)\n            {\n                projectionX = v.x;\n            }\n            else\n            {\n                projectionX = (v.x - axis.x / axis.y * v.y) / (1 + Mathf.Pow(axis.x / axis.y, 2));\n            }\n\n\n            if (i == 0)\n            {\n                _min = projectionX;\n                _max = projectionX;\n            }\n            else\n            {\n                if (projectionX > _max)\n                {\n                    _max = projectionX;\n                }\n                if (projectionX < _min)\n                {\n                    _min = projectionX;\n                }\n            }\n\n        } \n    }\n\n    public float GetMin()\n    {\n        return _min;\n    }\n\n    public float GetMax()\n    {\n        return _max;\n    }\n\n\n    //获取边向量\n    private Vector2 _GetEdge(int index)\n    {\n        Vector2 result = new Vector2();\n        switch (index)\n        {\n            case 0:\n                result = _point1 - _point0;\n                break;\n            case 1:\n                result = _point2 - _point1;\n                break;\n            case 2:\n                result = _point3 - _point2;\n                break;\n            case 3:\n                result = _point0 - _point3;\n                break;\n        }\n\n        return result;\n    }\n\n    private Vector2 _Transform(Vector2 v,float angle,Vector2 centerV)\n    {\n        Vector2 result = new Vector2();\n\n        float initX = v.x;\n        float initY = v.y;\n\n        //将顶点移动到原点四周\n        float centerPointX = initX - centerV.x;\n        float centerPointY = initY - centerV.y;\n\n        float r = angle * Mathf.Deg2Rad;\n\n        float a = Mathf.Cos(r);\n        float b = Mathf.Sin(r);\n\n        result.x = centerPointX * a + centerPointY * (-b) + centerV.x;\n        result.y = centerPointX * b + centerPointY * a + centerV.y;\n\n        return result;\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XRect{\n    private Vector2 _point0 = new Vector2();\n    private Vector2 _point1 = new Vector2();\n    private Vector2 _point2 = new Vector2();\n    private Vector2 _point3 = new Vector2();\n\n    public List<Vector2> _pointList = new List<Vector2>();\n\n    private float _min = 0;\n    private float _max = 0;\n\n\n    public void UpdatePoint(RectTransform RT)\n    {\n        float x = RT.localPosition.x;\n        float y = RT.localPosition.y;\n        float width = RT.sizeDelta.x;\n        float height = RT.sizeDelta.y;\n        float angle = RT.localRotation.eulerAngles.z;\n\n        Vector2 centerV = new Vector2(RT.localPosition.x, RT.localPosition.y);\n\n        _point0 = new Vector2(x - width / 2, y + height / 2);\n        _point0 = _Transform(_point0,angle,centerV);\n\n        _point1 = new Vector2(x + width / 2, y + height / 2);\n        _point1 = _Transform(_point1, angle, centerV);\n\n        _point2 = new Vector2(x + width / 2, y - height / 2);\n        _point2 = _Transform(_point2, angle, centerV);\n\n        _point3 = new Vector2(x - width / 2, y - height / 2);\n        _point3 = _Transform(_point3, angle, centerV);\n\n        _pointList.Clear();\n        _pointList.Add(_point0);\n        _pointList.Add(_point1);\n        _pointList.Add(_point2);\n        _pointList.Add(_point3);\n\n        Vector3[] temp = new Vector3[4];\n        RT.GetLocalCorners(temp);\n       \n    }\n\n    //获取投影轴\n    public Vector2 GetAxis(int index)\n    {\n        Vector2 v = _GetEdge(index);\n\n        Vector2 result = new Vector2();\n\n        result.x = v.y;\n        result.y = 0 - v.x;\n\n        return result;\n    }\n\n    public void ResetProjection(Vector2 axis)\n    {\n        if (axis.x == 0 && axis.y == 0)\n        {\n            Debug.LogError(\"投影轴数据错误！\");\n            return;\n        }\n        float projectionX;\n        Vector2 v;\n        for (int i = 0; i < _pointList.Count; ++i)\n        {\n            v = _pointList[i];\n            if (axis.x == 0)\n            {\n                projectionX = v.y;\n            }\n            else if (axis.y == 0)\n            {\n                projectionX = v.x;\n            }\n            else\n            {\n                projectionX = (v.x - axis.x / axis.y * v.y) / (1 + Mathf.Pow(axis.x / axis.y, 2));\n            }\n\n\n            if (i == 0)\n            {\n                _min = projectionX;\n                _max = projectionX;\n            }\n            else\n            {\n                if (projectionX > _max)\n                {\n                    _max = projectionX;\n                }\n                if (projectionX < _min)\n                {\n                    _min = projectionX;\n                }\n            }\n\n        } \n    }\n\n    public float GetMin()\n    {\n        return _min;\n    }\n\n    public float GetMax()\n    {\n        return _max;\n    }\n\n\n    //获取边向量\n    private Vector2 _GetEdge(int index)\n    {\n        Vector2 result = new Vector2();\n        switch (index)\n        {\n            case 0:\n                result = _point1 - _point0;\n                break;\n            case 1:\n                result = _point2 - _point1;\n                break;\n            case 2:\n                result = _point3 - _point2;\n                break;\n            case 3:\n                result = _point0 - _point3;\n                break;\n        }\n\n        return result;\n    }\n\n    private Vector2 _Transform(Vector2 v,float angle,Vector2 centerV)\n    {\n        Vector2 result = new Vector2();\n\n        float initX = v.x;\n        float initY = v.y;\n\n        //将顶点移动到原点四周\n        float centerPointX = initX - centerV.x;\n        float centerPointY = initY - centerV.y;\n\n        float r = angle * Mathf.Deg2Rad;\n\n        float a = Mathf.Cos(r);\n        float b = Mathf.Sin(r);\n\n        result.x = centerPointX * a + centerPointY * (-b) + centerV.x;\n        result.y = centerPointX * b + centerPointY * a + centerV.y;\n\n        return result;\n    }\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XCollisionHelper {\n\n    private static XCollisionHelper _instance;\n\n    public static XCollisionHelper GetInstance()\n    {\n        if (_instance  == null)\n        {\n            _instance = new XCollisionHelper();\n        }\n\n        return _instance;\n    }\n\n    public bool Check(XRect xRect1,XRect xRect2)\n    {\n        for (int i = 0; i <4;++i)\n        {\n            Vector2 axis = xRect1.GetAxis(i);\n\n            //获取两个矩形在投影轴上的范围\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        for (int i = 0; i < 4; ++i)\n        {\n            Vector2 axis = xRect2.GetAxis(i);\n\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    \n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class XCollisionHelper {\n\n    private static XCollisionHelper _instance;\n\n    public static XCollisionHelper GetInstance()\n    {\n        if (_instance  == null)\n        {\n            _instance = new XCollisionHelper();\n        }\n\n        return _instance;\n    }\n\n    public bool Check(XRect xRect1,XRect xRect2)\n    {\n        for (int i = 0; i <4;++i)\n        {\n            Vector2 axis = xRect1.GetAxis(i);\n\n            //获取两个矩形在投影轴上的范围\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        for (int i = 0; i < 4; ++i)\n        {\n            Vector2 axis = xRect2.GetAxis(i);\n\n            xRect1.ResetProjection(axis);\n            xRect2.ResetProjection(axis);\n\n            if (xRect1.GetMin() > xRect2.GetMax() || xRect1.GetMax() < xRect2.GetMin())\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    \n\n}\n"}]}]},{"type":"element","tag":"pre","props":{"code":"﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class XRectItemCtrl : MonoBehaviour, IDragHandler\n{\n\n    public Image imgRect;\n    private XRect _xRect = new XRect();\n\n    public XRect GetXRect()\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        _xRect.UpdatePoint(RT);\n\n        if (transform.gameObject.name == \"Image0\")\n        {\n        }\n\n        return _xRect;\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        RT.localPosition = new Vector2(RT.localPosition.x + eventData.delta.x, RT.localPosition.y + eventData.delta.y);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class XRectItemCtrl : MonoBehaviour, IDragHandler\n{\n\n    public Image imgRect;\n    private XRect _xRect = new XRect();\n\n    public XRect GetXRect()\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        _xRect.UpdatePoint(RT);\n\n        if (transform.gameObject.name == \"Image0\")\n        {\n        }\n\n        return _xRect;\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        RectTransform RT = transform.GetComponent<RectTransform>();\n        RT.localPosition = new Vector2(RT.localPosition.x + eventData.delta.x, RT.localPosition.y + eventData.delta.y);\n    }\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"其他的一些参考"},"children":[{"type":"text","value":"其他的一些参考"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[]},{"type":"element","tag":"li","props":{},"children":[]},{"type":"element","tag":"li","props":{},"children":[]},{"type":"element","tag":"li","props":{},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"方法二","depth":3,"text":"方法二"},{"id":"向量的点乘","depth":3,"text":"向量的点乘"},{"id":"向量的叉乘","depth":3,"text":"向量的叉乘"},{"id":"那么如何处理圆呢","depth":2,"text":"那么如何处理圆呢？"},{"id":"优点","depth":2,"text":"优点"},{"id":"不足","depth":2,"text":"不足"}]}},"_type":"markdown","_id":"content:unity:2020-01-13-unity-attack-detection.md","_source":"content","_file":"unity/2020-01-13-unity-attack-detection.md","_extension":"md","date":"2020-01-13"}