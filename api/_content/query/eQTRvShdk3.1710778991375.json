{"_path":"/unity/2022-01-02-unity-hot-reload","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"关于unity的热重载的研究","description":"Roslyn C# - Runtime Compiler通过FileSystemWatcher监控目录检查改变的文件unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.Get","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"roslyn-c-runtime-compiler"},"children":[{"type":"text","value":"Roslyn C# - Runtime Compiler"}]},{"type":"element","tag":"h3","props":{"id":"通过filesystemwatcher监控目录检查改变的文件"},"children":[{"type":"text","value":"通过FileSystemWatcher监控目录检查改变的文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"unity的FileSystemWatcher有点问题,子目录下文件返回的路径是错的.所以需要先存储下cs文件进行索引"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.GetFiles(folderPath,\"*.cs\", SearchOption.AllDirectories);\n    foreach (var item in fileEntries)\n    {\n        var key = Path.GetFileName(item);\n        if (Files.TryGetValue(key,out var f) == false)\n        {\n            Files.Add(key, item);\n        }\n        else\n        {\n            Debug.LogError($\"{f}和{item}的文件名相同\");\n        }\n    }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public RealtimeScriptWatcher(ScriptDomain domain, string folderPath)\n{\n    this.domain = domain;\n    Files = new Dictionary<string, string>();\n    string[] fileEntries = Directory.GetFiles(folderPath,\"*.cs\", SearchOption.AllDirectories);\n    foreach (var item in fileEntries)\n    {\n        var key = Path.GetFileName(item);\n        if (Files.TryGetValue(key,out var f) == false)\n        {\n            Files.Add(key, item);\n        }\n        else\n        {\n            Debug.LogError($\"{f}和{item}的文件名相同\");\n        }\n    }\n"}]}]},{"type":"element","tag":"h3","props":{"id":"编译修改的文件并重新加载"},"children":[{"type":"text","value":"编译修改的文件并重新加载"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"  // Recompile the script\n    ScriptAssembly asm = domain.CompileAndLoadFile(path, securityMode);\n    \n    // Check for success\n    if(asm == null)\n    {\n        domain.LogCompilerOutputToConsole();\n        return;\n    }\n    \n    // Find the type for the changed source file\n    Type mainMonoType = GetMainMonoTypeForSourceFile(path);\n    \n    // Find type with matching full name\n    ScriptType reloadType = asm.FindType(mainMonoType);\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  // Recompile the script\n    ScriptAssembly asm = domain.CompileAndLoadFile(path, securityMode);\n    \n    // Check for success\n    if(asm == null)\n    {\n        domain.LogCompilerOutputToConsole();\n        return;\n    }\n    \n    // Find the type for the changed source file\n    Type mainMonoType = GetMainMonoTypeForSourceFile(path);\n    \n    // Find type with matching full name\n    ScriptType reloadType = asm.FindType(mainMonoType);\n"}]}]},{"type":"element","tag":"h3","props":{"id":"替换场景中的monobehavior"},"children":[{"type":"text","value":"替换场景中的monobehavior"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static bool ReplaceScriptsForScene(Scene targetScene, ScriptType scriptType, out ModScriptReplacerReport report, ScriptReplacerOptions options = ScriptReplacerOptions.Default)\n{\n    bool failed = false;\n    report = new ModScriptReplacerReport();\n\n    bool includeInactive = (options & ScriptReplacerOptions.ReplaceDisabledScripts) != 0;\n\n    foreach (GameObject gameObject in targetScene.GetRootGameObjects())\n    {\n        foreach (MonoBehaviour behaviour in gameObject.GetComponentsInChildren<MonoBehaviour>(includeInactive))\n        {\n            if (ReplaceScriptBehaviourImpl(behaviour, scriptType, ref report, options) == false)\n                failed = true;\n        }\n    }\n    return failed == false;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static bool ReplaceScriptsForScene(Scene targetScene, ScriptType scriptType, out ModScriptReplacerReport report, ScriptReplacerOptions options = ScriptReplacerOptions.Default)\n{\n    bool failed = false;\n    report = new ModScriptReplacerReport();\n\n    bool includeInactive = (options & ScriptReplacerOptions.ReplaceDisabledScripts) != 0;\n\n    foreach (GameObject gameObject in targetScene.GetRootGameObjects())\n    {\n        foreach (MonoBehaviour behaviour in gameObject.GetComponentsInChildren<MonoBehaviour>(includeInactive))\n        {\n            if (ReplaceScriptBehaviourImpl(behaviour, scriptType, ref report, options) == false)\n                failed = true;\n        }\n    }\n    return failed == false;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过以上可以看到明显的缺点只支持monobehavior"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若想支持非monobehavior可能需要自己进行处理"}]},{"type":"element","tag":"h2","props":{"id":"et的热重载"},"children":[{"type":"text","value":"ET的热重载"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分离项目到不同的dll中"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过代码加载dll"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"System.Reflection.Assembly.Load(assBytes, pdbBytes)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"首先进行编译dll"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"按R热加载后,通过反射,对现有的对象进行销毁,然后重新创建"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关键代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"\npublic class CodeLoader: IDisposable\n{\n    public static CodeLoader Instance = new CodeLoader();\n\n    public Action Update;\n    public Action LateUpdate;\n    public Action OnApplicationQuit;\n\n    private Assembly assembly;\n\n    private ILRuntime.Runtime.Enviorment.AppDomain appDomain;\n    \n    private Type[] allTypes;\n    \n    public CodeMode CodeMode { get; set; }\n\n    private CodeLoader()\n    {\n    }\n\n    public void Dispose()\n    {\n        this.appDomain?.Dispose();\n    }\n    \n    public void Start()\n    {\n        switch (this.CodeMode)\n        {\n            case CodeMode.Mono:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.allTypes = assembly.GetTypes();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n            case CodeMode.ILRuntime:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                //byte[] assBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.dll\"));\n                //byte[] pdbBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.pdb\"));\n            \n                appDomain = new ILRuntime.Runtime.Enviorment.AppDomain();\n                MemoryStream assStream = new MemoryStream(assBytes);\n                MemoryStream pdbStream = new MemoryStream(pdbBytes);\n                appDomain.LoadAssembly(assStream, pdbStream, new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());\n\n                ILHelper.InitILRuntime(appDomain);\n\n                this.allTypes = appDomain.LoadedTypes.Values.Select(x => x.ReflectionType).ToArray();\n                IStaticMethod start = new ILStaticMethod(appDomain, \"ET.Entry\", \"Start\", 0);\n                start.Run();\n                break;\n            }\n            case CodeMode.Reload:\n            {\n                byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.dll\"));\n                byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.pdb\"));\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.LoadLogic();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n        }\n    }\n\n    // 热重载调用下面三个方法\n    // CodeLoader.Instance.LoadLogic();\n    // Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n    // Game.EventSystem.Load();\n    public void LoadLogic()\n    {\n        if (this.CodeMode != CodeMode.Reload)\n        {\n            throw new Exception(\"CodeMode != Reload!\");\n        }\n        \n        // 傻屌Unity在这里搞了个傻逼优化，认为同一个路径的dll，返回的程序集就一样。所以这里每次编译都要随机名字\n        string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*.dll\");\n        if (logicFiles.Length != 1)\n        {\n            throw new Exception(\"Logic dll count != 1\");\n        }\n\n        string logicName = Path.GetFileNameWithoutExtension(logicFiles[0]);\n        byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.dll\"));\n        byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.pdb\"));\n\n        Assembly hotfixAssembly = Assembly.Load(assBytes, pdbBytes);\n        \n        List<Type> listType = new List<Type>();\n        listType.AddRange(this.assembly.GetTypes());\n        listType.AddRange(hotfixAssembly.GetTypes());\n        this.allTypes = listType.ToArray();\n    }\n\n    public Type[] GetTypes()\n    {\n        return this.allTypes;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\npublic class CodeLoader: IDisposable\n{\n    public static CodeLoader Instance = new CodeLoader();\n\n    public Action Update;\n    public Action LateUpdate;\n    public Action OnApplicationQuit;\n\n    private Assembly assembly;\n\n    private ILRuntime.Runtime.Enviorment.AppDomain appDomain;\n    \n    private Type[] allTypes;\n    \n    public CodeMode CodeMode { get; set; }\n\n    private CodeLoader()\n    {\n    }\n\n    public void Dispose()\n    {\n        this.appDomain?.Dispose();\n    }\n    \n    public void Start()\n    {\n        switch (this.CodeMode)\n        {\n            case CodeMode.Mono:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.allTypes = assembly.GetTypes();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n            case CodeMode.ILRuntime:\n            {\n                Dictionary<string, UnityEngine.Object> dictionary = AssetsBundleHelper.LoadBundle(\"code.unity3d\");\n                byte[] assBytes = ((TextAsset)dictionary[\"Code.dll\"]).bytes;\n                byte[] pdbBytes = ((TextAsset)dictionary[\"Code.pdb\"]).bytes;\n                \n                //byte[] assBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.dll\"));\n                //byte[] pdbBytes = File.ReadAllBytes(Path.Combine(\"../Unity/\", Define.BuildOutputDir, \"Code.pdb\"));\n            \n                appDomain = new ILRuntime.Runtime.Enviorment.AppDomain();\n                MemoryStream assStream = new MemoryStream(assBytes);\n                MemoryStream pdbStream = new MemoryStream(pdbBytes);\n                appDomain.LoadAssembly(assStream, pdbStream, new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());\n\n                ILHelper.InitILRuntime(appDomain);\n\n                this.allTypes = appDomain.LoadedTypes.Values.Select(x => x.ReflectionType).ToArray();\n                IStaticMethod start = new ILStaticMethod(appDomain, \"ET.Entry\", \"Start\", 0);\n                start.Run();\n                break;\n            }\n            case CodeMode.Reload:\n            {\n                byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.dll\"));\n                byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, \"Data.pdb\"));\n                \n                assembly = Assembly.Load(assBytes, pdbBytes);\n                this.LoadLogic();\n                IStaticMethod start = new MonoStaticMethod(assembly, \"ET.Entry\", \"Start\");\n                start.Run();\n                break;\n            }\n        }\n    }\n\n    // 热重载调用下面三个方法\n    // CodeLoader.Instance.LoadLogic();\n    // Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n    // Game.EventSystem.Load();\n    public void LoadLogic()\n    {\n        if (this.CodeMode != CodeMode.Reload)\n        {\n            throw new Exception(\"CodeMode != Reload!\");\n        }\n        \n        // 傻屌Unity在这里搞了个傻逼优化，认为同一个路径的dll，返回的程序集就一样。所以这里每次编译都要随机名字\n        string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*.dll\");\n        if (logicFiles.Length != 1)\n        {\n            throw new Exception(\"Logic dll count != 1\");\n        }\n\n        string logicName = Path.GetFileNameWithoutExtension(logicFiles[0]);\n        byte[] assBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.dll\"));\n        byte[] pdbBytes = File.ReadAllBytes(Path.Combine(Define.BuildOutputDir, $\"{logicName}.pdb\"));\n\n        Assembly hotfixAssembly = Assembly.Load(assBytes, pdbBytes);\n        \n        List<Type> listType = new List<Type>();\n        listType.AddRange(this.assembly.GetTypes());\n        listType.AddRange(hotfixAssembly.GetTypes());\n        this.allTypes = listType.ToArray();\n    }\n\n    public Type[] GetTypes()\n    {\n        return this.allTypes;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按下f8编译dll"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public static class BuildAssemblieEditor\n{\n        [MenuItem(\"Tools/BuildLogic _F8\")]\n        public static void BuildLogic()\n        {\n            string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*\");\n            foreach (string file in logicFiles)\n            {\n                File.Delete(file);\n            }\n            \n            int random = RandomHelper.RandomNumber(100000000, 999999999);\n            string logicFile = $\"Logic_{random}\";\n            \n            BuildAssemblieEditor.BuildMuteAssembly(logicFile, new []\n            {\n                \"Codes/Hotfix/\",\n                \"Codes/HotfixView/\",\n            }, new[]{Path.Combine(Define.BuildOutputDir, \"Data.dll\")}, CodeOptimization.Debug);\n        }\n\n\n    private static void BuildMuteAssembly(string assemblyName, string[] CodeDirectorys, string[] additionalReferences, CodeOptimization codeOptimization)\n        {\n            List<string> scripts = new List<string>();\n            for (int i = 0; i < CodeDirectorys.Length; i++)\n            {\n                DirectoryInfo dti = new DirectoryInfo(CodeDirectorys[i]);\n                FileInfo[] fileInfos = dti.GetFiles(\"*.cs\", System.IO.SearchOption.AllDirectories);\n                for (int j = 0; j < fileInfos.Length; j++)\n                {\n                    scripts.Add(fileInfos[j].FullName);\n                }\n            }\n\n            string dllPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.dll\");\n            string pdbPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.pdb\");\n            File.Delete(dllPath);\n            File.Delete(pdbPath);\n\n            Directory.CreateDirectory(Define.BuildOutputDir);\n\n            AssemblyBuilder assemblyBuilder = new AssemblyBuilder(dllPath, scripts.ToArray());\n            \n            //启用UnSafe\n            //assemblyBuilder.compilerOptions.AllowUnsafeCode = true;\n\n            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);\n\n            assemblyBuilder.compilerOptions.CodeOptimization = codeOptimization;\n            assemblyBuilder.compilerOptions.ApiCompatibilityLevel = PlayerSettings.GetApiCompatibilityLevel(buildTargetGroup);\n            // assemblyBuilder.compilerOptions.ApiCompatibilityLevel = ApiCompatibilityLevel.NET_4_6;\n\n            assemblyBuilder.additionalReferences = additionalReferences;\n            \n            assemblyBuilder.flags = AssemblyBuilderFlags.None;\n            //AssemblyBuilderFlags.None                 正常发布\n            //AssemblyBuilderFlags.DevelopmentBuild     开发模式打包\n            //AssemblyBuilderFlags.EditorAssembly       编辑器状态\n            assemblyBuilder.referencesOptions = ReferencesOptions.UseEngineModules;\n\n            assemblyBuilder.buildTarget = EditorUserBuildSettings.activeBuildTarget;\n\n            assemblyBuilder.buildTargetGroup = buildTargetGroup;\n\n            assemblyBuilder.buildStarted += delegate(string assemblyPath) { Debug.LogFormat(\"build start：\" + assemblyPath); };\n\n            assemblyBuilder.buildFinished += delegate(string assemblyPath, CompilerMessage[] compilerMessages)\n            {\n                int errorCount = compilerMessages.Count(m => m.type == CompilerMessageType.Error);\n                int warningCount = compilerMessages.Count(m => m.type == CompilerMessageType.Warning);\n\n                Debug.LogFormat(\"Warnings: {0} - Errors: {1}\", warningCount, errorCount);\n\n                if (warningCount > 0)\n                {\n                    Debug.LogFormat(\"有{0}个Warning!!!\", warningCount);\n                }\n\n                if (errorCount > 0)\n                {\n                    for (int i = 0; i < compilerMessages.Length; i++)\n                    {\n                        if (compilerMessages[i].type == CompilerMessageType.Error)\n                        {\n                            Debug.LogError(compilerMessages[i].message);\n                        }\n                    }\n                }\n            };\n            \n            //开始构建\n            if (!assemblyBuilder.Build())\n            {\n                Debug.LogErrorFormat(\"build fail：\" + assemblyBuilder.assemblyPath);\n                return;\n            }\n        }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static class BuildAssemblieEditor\n{\n        [MenuItem(\"Tools/BuildLogic _F8\")]\n        public static void BuildLogic()\n        {\n            string[] logicFiles = Directory.GetFiles(Define.BuildOutputDir, \"Logic_*\");\n            foreach (string file in logicFiles)\n            {\n                File.Delete(file);\n            }\n            \n            int random = RandomHelper.RandomNumber(100000000, 999999999);\n            string logicFile = $\"Logic_{random}\";\n            \n            BuildAssemblieEditor.BuildMuteAssembly(logicFile, new []\n            {\n                \"Codes/Hotfix/\",\n                \"Codes/HotfixView/\",\n            }, new[]{Path.Combine(Define.BuildOutputDir, \"Data.dll\")}, CodeOptimization.Debug);\n        }\n\n\n    private static void BuildMuteAssembly(string assemblyName, string[] CodeDirectorys, string[] additionalReferences, CodeOptimization codeOptimization)\n        {\n            List<string> scripts = new List<string>();\n            for (int i = 0; i < CodeDirectorys.Length; i++)\n            {\n                DirectoryInfo dti = new DirectoryInfo(CodeDirectorys[i]);\n                FileInfo[] fileInfos = dti.GetFiles(\"*.cs\", System.IO.SearchOption.AllDirectories);\n                for (int j = 0; j < fileInfos.Length; j++)\n                {\n                    scripts.Add(fileInfos[j].FullName);\n                }\n            }\n\n            string dllPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.dll\");\n            string pdbPath = Path.Combine(Define.BuildOutputDir, $\"{assemblyName}.pdb\");\n            File.Delete(dllPath);\n            File.Delete(pdbPath);\n\n            Directory.CreateDirectory(Define.BuildOutputDir);\n\n            AssemblyBuilder assemblyBuilder = new AssemblyBuilder(dllPath, scripts.ToArray());\n            \n            //启用UnSafe\n            //assemblyBuilder.compilerOptions.AllowUnsafeCode = true;\n\n            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);\n\n            assemblyBuilder.compilerOptions.CodeOptimization = codeOptimization;\n            assemblyBuilder.compilerOptions.ApiCompatibilityLevel = PlayerSettings.GetApiCompatibilityLevel(buildTargetGroup);\n            // assemblyBuilder.compilerOptions.ApiCompatibilityLevel = ApiCompatibilityLevel.NET_4_6;\n\n            assemblyBuilder.additionalReferences = additionalReferences;\n            \n            assemblyBuilder.flags = AssemblyBuilderFlags.None;\n            //AssemblyBuilderFlags.None                 正常发布\n            //AssemblyBuilderFlags.DevelopmentBuild     开发模式打包\n            //AssemblyBuilderFlags.EditorAssembly       编辑器状态\n            assemblyBuilder.referencesOptions = ReferencesOptions.UseEngineModules;\n\n            assemblyBuilder.buildTarget = EditorUserBuildSettings.activeBuildTarget;\n\n            assemblyBuilder.buildTargetGroup = buildTargetGroup;\n\n            assemblyBuilder.buildStarted += delegate(string assemblyPath) { Debug.LogFormat(\"build start：\" + assemblyPath); };\n\n            assemblyBuilder.buildFinished += delegate(string assemblyPath, CompilerMessage[] compilerMessages)\n            {\n                int errorCount = compilerMessages.Count(m => m.type == CompilerMessageType.Error);\n                int warningCount = compilerMessages.Count(m => m.type == CompilerMessageType.Warning);\n\n                Debug.LogFormat(\"Warnings: {0} - Errors: {1}\", warningCount, errorCount);\n\n                if (warningCount > 0)\n                {\n                    Debug.LogFormat(\"有{0}个Warning!!!\", warningCount);\n                }\n\n                if (errorCount > 0)\n                {\n                    for (int i = 0; i < compilerMessages.Length; i++)\n                    {\n                        if (compilerMessages[i].type == CompilerMessageType.Error)\n                        {\n                            Debug.LogError(compilerMessages[i].message);\n                        }\n                    }\n                }\n            };\n            \n            //开始构建\n            if (!assemblyBuilder.Build())\n            {\n                Debug.LogErrorFormat(\"build fail：\" + assemblyBuilder.assemblyPath);\n                return;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按下R重载"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"    \npublic static class OperaComponentSystem\n{\n    public static void Update()\n    { \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            CodeLoader.Instance.LoadLogic();\n            Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n            Game.EventSystem.Load();\n            Log.Debug(\"hot reload success!\");\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \npublic static class OperaComponentSystem\n{\n    public static void Update()\n    { \n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            CodeLoader.Instance.LoadLogic();\n            Game.EventSystem.Add(CodeLoader.Instance.GetTypes());\n            Game.EventSystem.Load();\n            Log.Debug(\"hot reload success!\");\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"roslyn-c-runtime-compiler","depth":2,"text":"Roslyn C# - Runtime Compiler","children":[{"id":"通过filesystemwatcher监控目录检查改变的文件","depth":3,"text":"通过FileSystemWatcher监控目录检查改变的文件"},{"id":"编译修改的文件并重新加载","depth":3,"text":"编译修改的文件并重新加载"},{"id":"替换场景中的monobehavior","depth":3,"text":"替换场景中的monobehavior"}]},{"id":"et的热重载","depth":2,"text":"ET的热重载"}]}},"_type":"markdown","_id":"content:unity:2022-01-02-unity-hot-reload.md","_source":"content","_file":"unity/2022-01-02-unity-hot-reload.md","_extension":"md","date":"2022-01-02"}