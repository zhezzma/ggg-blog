{"_path":"/game/2022-08-21-behavior-tree-source-code","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"行为树源代码解析","description":"行为树的构建首先行为树会有个根节点TaskRoot ,当构建行为树的时候,会将节点添加到该root下行为树的构建如下://获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"行为树的构建"},"children":[{"type":"text","value":"行为树的构建"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先行为树会有个根节点"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskRoot"}]},{"type":"text","value":" ,当构建行为树的时候,会将节点添加到该root下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"行为树的构建如下:"}]},{"type":"element","tag":"pre","props":{"code":"//获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _tree.AddNode(PointerCurrent, node);\n    return this;\n}\n//增加节点,并将该节点设置为当前父节点\npublic BehaviorTreeBuilder AddNodeWithPointer (ITaskParent task) {\n    AddNode(task);\n    _pointers.Add(task);\n    \n    return this;\n}\n//退出当前父节点\npublic BehaviorTreeBuilder End () {\n    _pointers.RemoveAt(_pointers.Count - 1);\n    \n    return this;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _tree.AddNode(PointerCurrent, node);\n    return this;\n}\n//增加节点,并将该节点设置为当前父节点\npublic BehaviorTreeBuilder AddNodeWithPointer (ITaskParent task) {\n    AddNode(task);\n    _pointers.Add(task);\n    \n    return this;\n}\n//退出当前父节点\npublic BehaviorTreeBuilder End () {\n    _pointers.RemoveAt(_pointers.Count - 1);\n    \n    return this;\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"行为树的运行"},"children":[{"type":"text","value":"行为树的运行"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一帧都执行update(),且如果根节点返回的是成功或者失败,则清空所有任务并"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"End()"}]},{"type":"text","value":",累计tick(所有子节点都会执行Reset())"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果子节点中有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"持续"}]},{"type":"text","value":"的任务时,则该任务会被认为时激活的.添加到行为树中"}]}]},{"type":"element","tag":"pre","props":{"code":"public TaskStatus Tick () {\n    var status = Root.Update();\n    if (status != TaskStatus.Continue) {\n        Reset();\n    }\n\n    return status;\n}\n\npublic void Reset () {\n    foreach (var task in _tasks) {\n        task.End();\n    }\n\n    _tasks.Clear();\n    TickCount++;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public TaskStatus Tick () {\n    var status = Root.Update();\n    if (status != TaskStatus.Continue) {\n        Reset();\n    }\n\n    return status;\n}\n\npublic void Reset () {\n    foreach (var task in _tasks) {\n        task.End();\n    }\n\n    _tasks.Clear();\n    TickCount++;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们看看任务的子类有哪些:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskRoot"}]},{"type":"text","value":" 一般来说只有一个子节点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskParentBase"}]},{"type":"text","value":" ,会在每一次循环中同步tick,如果tick和行为树不一样,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":",如果onUpdate()返回的时成功或者失败,也会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskBase"}]},{"type":"text","value":" 会在每一次循环中同步tick,如果tick和行为树不一样,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":",如果GetUpdate()返回的时成功或者失败,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Exit"}]},{"type":"text","value":" (Exit时会Reset)且如果自己的状态曾经为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Continue"}]},{"type":"text","value":"会从行为树的激活任务中移除,否则会将自身添加到行为树的激活任务中."}]}]},{"type":"element","tag":"h3","props":{"id":"持续的任务是怎么运行的"},"children":[{"type":"text","value":"持续的任务是怎么运行的"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;\nRoot --> Sequence;\nSequence-->TaskA;\nSequence-->TaskB;\nSequence-->TaskC;\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;\nRoot --> Sequence;\nSequence-->TaskA;\nSequence-->TaskB;\nSequence-->TaskC;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sequence会记录自己循环过哪些task. 当taskb持续状态时,则会进入下一个循环,但不会进入下一tick,走到Sequence后,他不会执行已经执行过的任务,所以进入Sequence后会直接执行TaskB;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只有当有任务失败或者成功,才会执行下一个tick,下一个tick所有task都会reset"}]},{"type":"element","tag":"h2","props":{"id":"使用"},"children":[{"type":"text","value":"使用"}]},{"type":"element","tag":"h3","props":{"id":"并行"},"children":[{"type":"text","value":"并行"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用.,注意子节点,要么是持续的,要么是成功的..如果有任何失败了将会reset"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"并行需要等待子节点全部完成,再根据子节点的返回状态判断该并行节点的状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"并不是说并行,就是两个不想干的node不断的执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同时执行下面所有子节点的start(),然后等待所有子节点的反馈是成功还是失败"}]}]},{"type":"element","tag":"h3","props":{"id":"序列"},"children":[{"type":"text","value":"序列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般把Sequence-->Condition  当作if  就可以"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;Sequence --> Condition;Sequence --> AC\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;Sequence --> Condition;Sequence --> AC\n"}]}]},{"type":"element","tag":"h3","props":{"id":"选择"},"children":[{"type":"text","value":"选择"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由下图可以看出..Selector --> Sequence--> Condition  相当于if else"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-21-behavior-tree-source-code/1660118886000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把select,当成 if not来看"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;\nSelect -->Condition; Select-->action\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;\nSelect -->Condition; Select-->action\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"select-->Inverter -->Condition  可以当作if来看.."}]},{"type":"element","tag":"pre","props":{"code":"graph TD;select --> inverter-->conditions;select-->action\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;select --> inverter-->conditions;select-->action\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和Sequence的区别就是,select在执行b前返回的是true."}]},{"type":"element","tag":"h3","props":{"id":"观察者模式"},"children":[{"type":"text","value":"观察者模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"观察者装饰器...就是观察某个变量..然后决定低优先级节点,自身节点,的执行(重启等)方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分为两种状况\n1.在当前节点未激活的时候,观察某个变量 生效的方式:Stops.LOWER_PRIORITY,Stops.BOTH,Stops.LOWER_PRIORITY_IMMEDIATE_RESTART,Stops.IMMEDIATE_RESTART\n2.在当前节点激活的时候,观察某个变量Stops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART\n所以会有三种节点出现"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()永远返回true,子节点永远返回false,保证该装饰器节点是inactive状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()永远返回false,子节点永远返回true,保证该装饰器节点是active状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()根据情况返回true和false,比如如果玩家在附近,则执行该装饰器下代码.如果玩家不在附近则stop,执行低优先级代码"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stops.NONE：装饰器只会在启动时检查一次它的状态，并且永远不会停止任何正在运行的节点。\nStops.SELF：装饰器将在启动时检查一次它的条件状态，如果满足，它将继续观察黑板的变化。一旦不再满足该条件，它将终止自身，并让父组合继续处理它的下一个节点。\nStops.LOWER_PRIORITY：装饰器将在启动时检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止比此结点优先级较低的节点，允许父组合继续处理下一个节点\nStops.BOTH：装饰器将同时停止:self和优先级较低的节点。\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启此装饰器。\nStops.IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启装饰器。正如在这两种情况下，一旦不再满足条件，它也将停止自己。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说人话..就是\n在当前节点未激活的时候,观察某个变量\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART和Stops.IMMEDIATE_RESTART这个会停止低优先级(就是该节点后面的)的节点,然后会立即重新开始当前节点\nStops.LOWER_PRIORITY和Stops.BOTH 会先停止优先级较低的节点,然后再停止父节点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在当前节点激活的时候,观察某个变量\nStops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART 这三个,都会先停止子节点.然后停止自身,最后会影响到停止父节点"}]},{"type":"element","tag":"h3","props":{"id":"条件和装饰器"},"children":[{"type":"text","value":"条件和装饰器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RepeatUntilSuccess --> ConditionBase 可以构成一个新动作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConditionBase 在返回失败的时候被RepeatUntilSuccess 转换为持续"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"行为树的构建","depth":2,"text":"行为树的构建"},{"id":"行为树的运行","depth":2,"text":"行为树的运行","children":[{"id":"持续的任务是怎么运行的","depth":3,"text":"持续的任务是怎么运行的"}]},{"id":"使用","depth":2,"text":"使用","children":[{"id":"并行","depth":3,"text":"并行"},{"id":"序列","depth":3,"text":"序列"},{"id":"选择","depth":3,"text":"选择"},{"id":"观察者模式","depth":3,"text":"观察者模式"},{"id":"条件和装饰器","depth":3,"text":"条件和装饰器"}]}]}},"_type":"markdown","_id":"content:game:2022-08-21-behavior-tree-source-code.md","_source":"content","_file":"game/2022-08-21-behavior-tree-source-code.md","_extension":"md","date":"2022-08-21"}