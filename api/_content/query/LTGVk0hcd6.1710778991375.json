{"_path":"/unity/2019-09-03-xlua-inject","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"xlua注入源码解读","description":"让C#代码支持热更的流程Generate Code\n这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。Hotfix Inject\n这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码Generate Code 实现和生成结果\n在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Im","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让C#代码支持热更的流程"}]}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generate Code\n这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hotfix Inject\n这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Generate Code 实现和生成结果"}]},{"type":"text","value":"\n在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Imp这个就是到时候要重复使用到的映射到Lua中function的委托。"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public void __Gen_Delegate_Imp0()\n{\n    RealStatePtr L = luaEnv.rawL;\n    int errFunc = LuaAPI.pcall_prepare(L, errorFuncRef, luaReference);\n    PCall(L, 0, 0, errFunc);\n    LuaAPI.lua_settop(L, errFunc - 1);\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void __Gen_Delegate_Imp0()\n{\n    RealStatePtr L = luaEnv.rawL;\n    int errFunc = LuaAPI.pcall_prepare(L, errorFuncRef, luaReference);\n    PCall(L, 0, 0, errFunc);\n    LuaAPI.lua_settop(L, errFunc - 1);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生成的代码就是先设置errorFuncRef（异常回调），luaReference（Lua方法）。如果在XLua中设置了热更修复代码，那么就会在C#中生成一个DelegateBridge，而其luaReference的指向就是Lua中的方法，所以这个只能调用指定的__Gen_Delegate_Imp，调用其他会报错。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hotfix Inject"}]},{"type":"text","value":"\n这一步是在Unity为C#代码生成完对应dll之后，由XLua再来对dll注入一些判断条件式来完成是否进行Lua调用的行为。\n判断方法很简单，检查对应类静态字段是否有DelegateBridge对象。\n实现如下："}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"bool injectMethod(MethodDefinition method, HotfixFlagInTool hotfixType)\n{\n            var type = method.DeclaringType;\n            bool isFinalize = (method.Name == \"Finalize\" && method.IsSpecialName);\n            //__Gen_Delegate_Imp 方法引用\n            MethodReference invoke = null;\n            int param_count = method.Parameters.Count + (method.IsStatic ? 0 : 1);\n            //根据返回值和参数个数类型，查找对应的委托方法\n            if (!findHotfixDelegate(method, out invoke, hotfixType))\n            {\n                Error(\"can not find delegate for \" + method.DeclaringType + \".\" + method.Name + \"! try re-genertate code.\");\n                return false;\n            }\n\n            if (invoke == null)\n            {\n                throw new Exception(\"unknow exception!\");\n            }\n            \n            invoke = injectAssembly.MainModule.Import(invoke);\n            //插入的类静态字段，用来标记对应的方法是否有对应的Lua注入\n            FieldReference fieldReference = null;\n            //方法中的变量定义\n            VariableDefinition injection = null;\n            bool isIntKey = hotfixType.HasFlag(HotfixFlagInTool.IntKey) && !type.HasGenericParameters && isTheSameAssembly;\n            //isIntKey = !type.HasGenericParameters;\n\n            if (!isIntKey)\n            {\n                //新建变量，加入方法体的变量组中\n                injection = new VariableDefinition(invoke.DeclaringType);\n                method.Body.Variables.Add(injection);\n                //获取这个方法对应的委托名，因为有重载方法存在，所以之前已经注入的过的方法会在这边获取时候计数加1，\n                //比如第一个重载获取的是__Hotfix0，那么下一个重载会是__Hotfix1，判断是否注入就是是否设置对应FieldReference。\n                var luaDelegateName = getDelegateName(method);\n                if (luaDelegateName == null)\n                {\n                    Error(\"too many overload!\");\n                    return false;\n                }\n                //创建对应的静态Field名字就是上面取到的luaDelegateName \n                FieldDefinition fieldDefinition = new FieldDefinition(luaDelegateName, Mono.Cecil.FieldAttributes.Static | Mono.Cecil.FieldAttributes.Private,\n                    invoke.DeclaringType);\n                type.Fields.Add(fieldDefinition);\n                fieldReference = fieldDefinition.GetGeneric();\n            }\n\n            bool ignoreValueType = hotfixType.HasFlag(HotfixFlagInTool.ValueTypeBoxing);\n            //IL插入位置，现在定位的是方法体的第一行\n            var insertPoint = method.Body.Instructions[0];\n            //获取IL处理器\n            var processor = method.Body.GetILProcessor();\n            //构造函数的处理逻辑先跳过这边不做分析\n            if (method.IsConstructor)\n            {\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            Dictionary<Instruction, Instruction> originToNewTarget = new Dictionary<Instruction, Instruction>();\n            HashSet<Instruction> noCheck = new HashSet<Instruction>();\n            \n            while (insertPoint != null)\n            {\n                //isIntKey这边用到的是Xlua中的AutoIdMap，这边只对最基础的功能做分析，这边就分析基础的注入了。\n                Instruction firstInstruction;\n                if (isIntKey)\n                {\n                    firstInstruction = processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count);\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, hotfixFlagGetter));\n                }\n                else\n                {\n                    //创建第一条IL语句，获取类的静态Field压入方法栈中，其实就是之前luaDelegateName获取的字段\n                    firstInstruction = processor.Create(OpCodes.Ldsfld, fieldReference);\n                    //插入insertPoint之前\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    //创建并插入IL，获取栈顶的值并压入到对应的变量中，injection就是我们之前创建的新建变量\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Stloc, injection));\n                    //创建并插入IL，压入变量体中的值到栈\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n                //创建跳转语句，为false时候直接跳转insertPoint,\n                //这边OpCodes.Brfalse看起来是布尔值判断，其实也会判断是否为null\n                var jmpInstruction = processor.Create(OpCodes.Brfalse, insertPoint);\n                processor.InsertBefore(insertPoint, jmpInstruction);\n\n                if (isIntKey)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count));\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, delegateBridgeGetter));\n                }\n                else\n                {\n                    //创建并插入IL,再次压入变量的值，因为上面做完判断后，栈顶的值就会被弹出，所以这边要再次压入\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n\n                for (int i = 0; i < param_count; i++)\n                {\n                    if (i < ldargs.Length)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(ldargs[i]));\n                    }\n                    else if (i < 256)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg_S, (byte)i));\n                    }\n                    else\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg, (short)i));\n                    }\n                    if (i == 0 && !method.IsStatic && type.IsValueType)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldobj, type));\n                        \n                    }\n                    //对值类型进行Box\n                    if (ignoreValueType)\n                    {\n                        TypeReference paramType;\n                        if (method.IsStatic)\n                        {\n                            paramType = method.Parameters[i].ParameterType;\n                        }\n                        else\n                        {\n                            paramType = (i == 0) ? type : method.Parameters[i - 1].ParameterType;\n                        }\n                        if (paramType.IsValueType)\n                        {\n                            processor.InsertBefore(insertPoint, processor.Create(OpCodes.Box, paramType));\n                        }\n                    }\n                }\n                //创建并插入IL，调用invoke方法，因为之前已经压入injection的值，DelegateBridge的对象\n                processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, invoke));\n                //普通方法，加入返回操作\n                if (!method.IsConstructor && !isFinalize)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ret));\n                }\n\n                if (!method.IsConstructor)\n                {\n                    break;\n                }\n                else\n                {\n                    originToNewTarget[insertPoint] = firstInstruction;\n                    noCheck.Add(jmpInstruction);\n                }\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            if (method.IsConstructor)\n            {\n                fixBranch(processor, method.Body.Instructions, originToNewTarget, noCheck);\n            }\n\n            if (isFinalize)\n            {\n                if (method.Body.ExceptionHandlers.Count == 0)\n                {\n                    throw new InvalidProgramException(\"Finalize has not try-catch? Type :\" + method.DeclaringType);\n                }\n                method.Body.ExceptionHandlers[0].TryStart = method.Body.Instructions[0];\n            }\n            if (isIntKey)\n            {\n                bridgeIndexByKey.Add(method);\n            }\n            return true;\n}\nstatic string getDelegateName(MethodDefinition method)\n{\n            string fieldName = method.Name;\n            if (fieldName.StartsWith(\".\"))\n            {\n                fieldName = fieldName.Substring(1);\n            }\n            string ccFlag = method.IsConstructor ? \"_c\" : \"\";\n            string luaDelegateName = null;\n            var type = method.DeclaringType;\n            for (int i = 0; i < MAX_OVERLOAD; i++)\n            {\n                string tmp = ccFlag + \"__Hotfix\" + i + \"_\" + fieldName;\n                if (!type.Fields.Any(f => f.Name == tmp)) // injected\n                {\n                    luaDelegateName = tmp;\n                    break;\n                }\n            }\n            return luaDelegateName;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"bool injectMethod(MethodDefinition method, HotfixFlagInTool hotfixType)\n{\n            var type = method.DeclaringType;\n            bool isFinalize = (method.Name == \"Finalize\" && method.IsSpecialName);\n            //__Gen_Delegate_Imp 方法引用\n            MethodReference invoke = null;\n            int param_count = method.Parameters.Count + (method.IsStatic ? 0 : 1);\n            //根据返回值和参数个数类型，查找对应的委托方法\n            if (!findHotfixDelegate(method, out invoke, hotfixType))\n            {\n                Error(\"can not find delegate for \" + method.DeclaringType + \".\" + method.Name + \"! try re-genertate code.\");\n                return false;\n            }\n\n            if (invoke == null)\n            {\n                throw new Exception(\"unknow exception!\");\n            }\n            \n            invoke = injectAssembly.MainModule.Import(invoke);\n            //插入的类静态字段，用来标记对应的方法是否有对应的Lua注入\n            FieldReference fieldReference = null;\n            //方法中的变量定义\n            VariableDefinition injection = null;\n            bool isIntKey = hotfixType.HasFlag(HotfixFlagInTool.IntKey) && !type.HasGenericParameters && isTheSameAssembly;\n            //isIntKey = !type.HasGenericParameters;\n\n            if (!isIntKey)\n            {\n                //新建变量，加入方法体的变量组中\n                injection = new VariableDefinition(invoke.DeclaringType);\n                method.Body.Variables.Add(injection);\n                //获取这个方法对应的委托名，因为有重载方法存在，所以之前已经注入的过的方法会在这边获取时候计数加1，\n                //比如第一个重载获取的是__Hotfix0，那么下一个重载会是__Hotfix1，判断是否注入就是是否设置对应FieldReference。\n                var luaDelegateName = getDelegateName(method);\n                if (luaDelegateName == null)\n                {\n                    Error(\"too many overload!\");\n                    return false;\n                }\n                //创建对应的静态Field名字就是上面取到的luaDelegateName \n                FieldDefinition fieldDefinition = new FieldDefinition(luaDelegateName, Mono.Cecil.FieldAttributes.Static | Mono.Cecil.FieldAttributes.Private,\n                    invoke.DeclaringType);\n                type.Fields.Add(fieldDefinition);\n                fieldReference = fieldDefinition.GetGeneric();\n            }\n\n            bool ignoreValueType = hotfixType.HasFlag(HotfixFlagInTool.ValueTypeBoxing);\n            //IL插入位置，现在定位的是方法体的第一行\n            var insertPoint = method.Body.Instructions[0];\n            //获取IL处理器\n            var processor = method.Body.GetILProcessor();\n            //构造函数的处理逻辑先跳过这边不做分析\n            if (method.IsConstructor)\n            {\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            Dictionary<Instruction, Instruction> originToNewTarget = new Dictionary<Instruction, Instruction>();\n            HashSet<Instruction> noCheck = new HashSet<Instruction>();\n            \n            while (insertPoint != null)\n            {\n                //isIntKey这边用到的是Xlua中的AutoIdMap，这边只对最基础的功能做分析，这边就分析基础的注入了。\n                Instruction firstInstruction;\n                if (isIntKey)\n                {\n                    firstInstruction = processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count);\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, hotfixFlagGetter));\n                }\n                else\n                {\n                    //创建第一条IL语句，获取类的静态Field压入方法栈中，其实就是之前luaDelegateName获取的字段\n                    firstInstruction = processor.Create(OpCodes.Ldsfld, fieldReference);\n                    //插入insertPoint之前\n                    processor.InsertBefore(insertPoint, firstInstruction);\n                    //创建并插入IL，获取栈顶的值并压入到对应的变量中，injection就是我们之前创建的新建变量\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Stloc, injection));\n                    //创建并插入IL，压入变量体中的值到栈\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n                //创建跳转语句，为false时候直接跳转insertPoint,\n                //这边OpCodes.Brfalse看起来是布尔值判断，其实也会判断是否为null\n                var jmpInstruction = processor.Create(OpCodes.Brfalse, insertPoint);\n                processor.InsertBefore(insertPoint, jmpInstruction);\n\n                if (isIntKey)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count));\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, delegateBridgeGetter));\n                }\n                else\n                {\n                    //创建并插入IL,再次压入变量的值，因为上面做完判断后，栈顶的值就会被弹出，所以这边要再次压入\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));\n                }\n\n                for (int i = 0; i < param_count; i++)\n                {\n                    if (i < ldargs.Length)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(ldargs[i]));\n                    }\n                    else if (i < 256)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg_S, (byte)i));\n                    }\n                    else\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg, (short)i));\n                    }\n                    if (i == 0 && !method.IsStatic && type.IsValueType)\n                    {\n                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldobj, type));\n                        \n                    }\n                    //对值类型进行Box\n                    if (ignoreValueType)\n                    {\n                        TypeReference paramType;\n                        if (method.IsStatic)\n                        {\n                            paramType = method.Parameters[i].ParameterType;\n                        }\n                        else\n                        {\n                            paramType = (i == 0) ? type : method.Parameters[i - 1].ParameterType;\n                        }\n                        if (paramType.IsValueType)\n                        {\n                            processor.InsertBefore(insertPoint, processor.Create(OpCodes.Box, paramType));\n                        }\n                    }\n                }\n                //创建并插入IL，调用invoke方法，因为之前已经压入injection的值，DelegateBridge的对象\n                processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, invoke));\n                //普通方法，加入返回操作\n                if (!method.IsConstructor && !isFinalize)\n                {\n                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ret));\n                }\n\n                if (!method.IsConstructor)\n                {\n                    break;\n                }\n                else\n                {\n                    originToNewTarget[insertPoint] = firstInstruction;\n                    noCheck.Add(jmpInstruction);\n                }\n                insertPoint = findNextRet(method.Body.Instructions, insertPoint);\n            }\n\n            if (method.IsConstructor)\n            {\n                fixBranch(processor, method.Body.Instructions, originToNewTarget, noCheck);\n            }\n\n            if (isFinalize)\n            {\n                if (method.Body.ExceptionHandlers.Count == 0)\n                {\n                    throw new InvalidProgramException(\"Finalize has not try-catch? Type :\" + method.DeclaringType);\n                }\n                method.Body.ExceptionHandlers[0].TryStart = method.Body.Instructions[0];\n            }\n            if (isIntKey)\n            {\n                bridgeIndexByKey.Add(method);\n            }\n            return true;\n}\nstatic string getDelegateName(MethodDefinition method)\n{\n            string fieldName = method.Name;\n            if (fieldName.StartsWith(\".\"))\n            {\n                fieldName = fieldName.Substring(1);\n            }\n            string ccFlag = method.IsConstructor ? \"_c\" : \"\";\n            string luaDelegateName = null;\n            var type = method.DeclaringType;\n            for (int i = 0; i < MAX_OVERLOAD; i++)\n            {\n                string tmp = ccFlag + \"__Hotfix\" + i + \"_\" + fieldName;\n                if (!type.Fields.Any(f => f.Name == tmp)) // injected\n                {\n                    luaDelegateName = tmp;\n                    break;\n                }\n            }\n            return luaDelegateName;\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"xlua.hotfix"}]},{"type":"text","value":"在完成生成代码和注入后，只要在Lua中调用xlua.hotfix或util.hotfix*ex方法就可以实现C#代码热更了。*hotfix和hotfixex的区别在与是否可以调用原C#代码，其实ex的实现也是调用了hotfix，在下面将分析hotfix和hotfix_ex的实现原理。\n先分析下hotfix的Lua代码，代码在第一篇文章中的实例化lua中："}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"     init_xlua.lua\n     xlua.hotfix = function(cs, field, func)\n                //判空\n                if func == nil then func = false end\n                //检查并且统一转化为table\n                //因为在Xlua中可以一次传一个方法，或者一次传一组方法\n                local tbl = (type(field) == 'table') and field or {[field] = func}\n                //遍历需要hotfix的代码，key是方法名，v是对应的func\n                for k, v in pairs(tbl) do\n                    //构造函数的hotfix，这边不做分析了，原理一样\n                    local cflag = ''\n                    if k == '.ctor' then\n                        cflag = '_c'\n                        k = 'ctor'\n                    end\n                    //检查v的类型\n                    local f = type(v) == 'function' and v or nil\n                    //调用access函数，其在初始化注册，最终实现在C#中下文解析实现\n                    xlua.access(cs, cflag .. '__Hotfix0_'..k, f) -- at least one\n                    //尝试给重载方法也添加上function如果有重载的话\n                    pcall(function()\n                        for i = 1, 99 do\n                            xlua.access(cs, cflag .. '__Hotfix'..i..'_'..k, f)\n                        end\n                    end)\n                end\n                //设置私有访问\n                xlua.private_accessible(cs)\n              end\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"     init_xlua.lua\n     xlua.hotfix = function(cs, field, func)\n                //判空\n                if func == nil then func = false end\n                //检查并且统一转化为table\n                //因为在Xlua中可以一次传一个方法，或者一次传一组方法\n                local tbl = (type(field) == 'table') and field or {[field] = func}\n                //遍历需要hotfix的代码，key是方法名，v是对应的func\n                for k, v in pairs(tbl) do\n                    //构造函数的hotfix，这边不做分析了，原理一样\n                    local cflag = ''\n                    if k == '.ctor' then\n                        cflag = '_c'\n                        k = 'ctor'\n                    end\n                    //检查v的类型\n                    local f = type(v) == 'function' and v or nil\n                    //调用access函数，其在初始化注册，最终实现在C#中下文解析实现\n                    xlua.access(cs, cflag .. '__Hotfix0_'..k, f) -- at least one\n                    //尝试给重载方法也添加上function如果有重载的话\n                    pcall(function()\n                        for i = 1, 99 do\n                            xlua.access(cs, cflag .. '__Hotfix'..i..'_'..k, f)\n                        end\n                    end)\n                end\n                //设置私有访问\n                xlua.private_accessible(cs)\n              end\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"XLuaAccess在C#中的实现："}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"        //xlua.access(cs, cflag .. '__Hotfix0_'..k, f)\n\n        public static int XLuaAccess(RealStatePtr L)\n        {\n            try\n            {\n                \n                ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n                //获取对应的CS类Type\n                Type type = getType(L, translator, 1);\n                object obj = null;\n                if (type == null && LuaAPI.lua_type(L, 1) == LuaTypes.LUA_TUSERDATA)\n                {\n                    obj = translator.SafeGetCSObj(L, 1);\n                    if (obj == null)\n                    {\n                        return LuaAPI.luaL_error(L, \"xlua.access, #1 parameter must a type/c# object/string\");\n                    }\n                    type = obj.GetType();\n                }\n\n                if (type == null)\n                {\n                    return LuaAPI.luaL_error(L, \"xlua.access, can not find c# type\");\n                }\n                //将cflag .. '__Hotfix0_'..k 转为fieldName，这个字段就是之前Inject时候创建的类静态字段名\n                string fieldName = LuaAPI.lua_tostring(L, 2);\n\n                BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;\n                //这边访问一定是Set所以后面就不分析了，这边就是反射获取对应的FieldInfo，重点在于translator.GetObject方法。\n                if (LuaAPI.lua_gettop(L) > 2) // set\n                {\n                    var field = type.GetField(fieldName, bindingFlags);\n                    if (field != null)\n                    {\n                        field.SetValue(obj, translator.GetObject(L, 3, field.FieldType));\n                        return 0;\n                    }\n                    var prop = type.GetProperty(fieldName, bindingFlags);\n                    if (prop != null)\n                    {\n                        prop.SetValue(obj, translator.GetObject(L, 3, prop.PropertyType), null);\n                        return 0;\n                    }\n                }\n                else\n                {\n                    ...\n                }\n                return LuaAPI.luaL_error(L, \"xlua.access, no field \" + fieldName);\n            }\n            catch (Exception e)\n            {\n                return LuaAPI.luaL_error(L, \"c# exception in xlua.access: \" + e);\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object GetObject(RealStatePtr L, int index, Type type)\n        {\n            int udata = LuaAPI.xlua_tocsobj_safe(L, index);\n\n            if (udata != -1)\n            {\n                ...\n            }\n            else\n            {\n                //一些特殊值类型的返回\n                ...\n                return (objectCasters.GetCaster(type)(L, index, null));\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public ObjectCast GetCaster(Type type)\n       {\n            ...\n            ObjectCast oc;\n            //缓存行为，继续分析第一次获取的caster委托\n            if (!castersMap.TryGetValue(type, out oc))\n            {\n                oc = genCaster(type);\n                castersMap.Add(type, oc);\n            }\n            return oc;\n        }\n        //为了减少篇幅，只展示必要代码\n        private ObjectCast genCaster(Type type)\n        {\n            \n            ObjectCast fixTypeGetter = (RealStatePtr L, int idx, object target) =>\n            {\n                if (LuaAPI.lua_type(L, idx) == LuaTypes.LUA_TUSERDATA)\n                {\n                    object obj = translator.SafeGetCSObj(L, idx);\n                    return (obj != null && type.IsAssignableFrom(obj.GetType())) ? obj : null;\n                }\n                return null;\n            }; \n            if ...\n            //在Inject代码时候我们已经知道其字段类型就是DelegateBridge，所以会返回的就是这个表达式\n            else if (typeof(DelegateBridgeBase).IsAssignableFrom(type))\n            {\n                return (RealStatePtr L, int idx, object target) =>\n                {\n                    //缓存行为，分析CreateDelegateBridge\n                    object obj = fixTypeGetter(L, idx, target);\n                    if (obj != null) return obj;\n\n                    if (!LuaAPI.lua_isfunction(L, idx))\n                    {\n                        return null;\n                    }\n\n                    return translator.CreateDelegateBridge(L, null, idx);\n                };\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx)\n        {\n            //这边只是查找是否这个方法已经有缓存了，有的话直接返回，没有就要Create，我们继续分析Create的事。\n            LuaAPI.lua_pushvalue(L, idx);\n            LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);\n            //不为null就是已经生成过，就直接从缓存获取\n            if (!LuaAPI.lua_isnil(L, -1))\n            {\n                retrun ...\n            }\n            else\n            {\n                //弹出刚刚查询过的nil值\n                LuaAPI.lua_pop(L, 1);\n            }\n            //开始生成对应的DelegateBridge\n            //压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //获取function对应的引用id\n            int reference = LuaAPI.luaL_ref(L);\n            //再次压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //压入function对应的引用id\n            LuaAPI.lua_pushnumber(L, reference);\n            //将栈顶的两个值以字典形式存在全局变量表中，这个的作用就是上面的代码查询是否已经在lua中缓存。\n            LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n            DelegateBridgeBase bridge;\n            try\n            {\n                //创建DelegateBridge，注意这边的reference，这个就是对应了lua中修复的lua函数，\n                //我们在Inject时候call的方法会使用到这个参数。\n                bridge = new DelegateBridge(reference, luaEnv);\n            }\n            catch(Exception e)\n            {\n                //异常情况下的，清场操作\n                LuaAPI.lua_pushvalue(L, idx);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.xlua_rawseti(L, LuaIndexes.LUA_REGISTRYINDEX, reference);\n                throw e;\n            }\n            //因为hotfix时候，delegateType传进来是个null，后续代码不会被调用到，就不做分析了。\n            if (delegateType == null)\n            {\n                //缓存到字典中，注意这里是弱引用所以会被回收，被回收后，需要从lua中查询到对应引用值，然后再生产。\n                delegate_bridges[reference] = new WeakReference(bridge);\n                return bridge;\n            }\n            ...\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        //xlua.access(cs, cflag .. '__Hotfix0_'..k, f)\n\n        public static int XLuaAccess(RealStatePtr L)\n        {\n            try\n            {\n                \n                ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n                //获取对应的CS类Type\n                Type type = getType(L, translator, 1);\n                object obj = null;\n                if (type == null && LuaAPI.lua_type(L, 1) == LuaTypes.LUA_TUSERDATA)\n                {\n                    obj = translator.SafeGetCSObj(L, 1);\n                    if (obj == null)\n                    {\n                        return LuaAPI.luaL_error(L, \"xlua.access, #1 parameter must a type/c# object/string\");\n                    }\n                    type = obj.GetType();\n                }\n\n                if (type == null)\n                {\n                    return LuaAPI.luaL_error(L, \"xlua.access, can not find c# type\");\n                }\n                //将cflag .. '__Hotfix0_'..k 转为fieldName，这个字段就是之前Inject时候创建的类静态字段名\n                string fieldName = LuaAPI.lua_tostring(L, 2);\n\n                BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;\n                //这边访问一定是Set所以后面就不分析了，这边就是反射获取对应的FieldInfo，重点在于translator.GetObject方法。\n                if (LuaAPI.lua_gettop(L) > 2) // set\n                {\n                    var field = type.GetField(fieldName, bindingFlags);\n                    if (field != null)\n                    {\n                        field.SetValue(obj, translator.GetObject(L, 3, field.FieldType));\n                        return 0;\n                    }\n                    var prop = type.GetProperty(fieldName, bindingFlags);\n                    if (prop != null)\n                    {\n                        prop.SetValue(obj, translator.GetObject(L, 3, prop.PropertyType), null);\n                        return 0;\n                    }\n                }\n                else\n                {\n                    ...\n                }\n                return LuaAPI.luaL_error(L, \"xlua.access, no field \" + fieldName);\n            }\n            catch (Exception e)\n            {\n                return LuaAPI.luaL_error(L, \"c# exception in xlua.access: \" + e);\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object GetObject(RealStatePtr L, int index, Type type)\n        {\n            int udata = LuaAPI.xlua_tocsobj_safe(L, index);\n\n            if (udata != -1)\n            {\n                ...\n            }\n            else\n            {\n                //一些特殊值类型的返回\n                ...\n                return (objectCasters.GetCaster(type)(L, index, null));\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public ObjectCast GetCaster(Type type)\n       {\n            ...\n            ObjectCast oc;\n            //缓存行为，继续分析第一次获取的caster委托\n            if (!castersMap.TryGetValue(type, out oc))\n            {\n                oc = genCaster(type);\n                castersMap.Add(type, oc);\n            }\n            return oc;\n        }\n        //为了减少篇幅，只展示必要代码\n        private ObjectCast genCaster(Type type)\n        {\n            \n            ObjectCast fixTypeGetter = (RealStatePtr L, int idx, object target) =>\n            {\n                if (LuaAPI.lua_type(L, idx) == LuaTypes.LUA_TUSERDATA)\n                {\n                    object obj = translator.SafeGetCSObj(L, idx);\n                    return (obj != null && type.IsAssignableFrom(obj.GetType())) ? obj : null;\n                }\n                return null;\n            }; \n            if ...\n            //在Inject代码时候我们已经知道其字段类型就是DelegateBridge，所以会返回的就是这个表达式\n            else if (typeof(DelegateBridgeBase).IsAssignableFrom(type))\n            {\n                return (RealStatePtr L, int idx, object target) =>\n                {\n                    //缓存行为，分析CreateDelegateBridge\n                    object obj = fixTypeGetter(L, idx, target);\n                    if (obj != null) return obj;\n\n                    if (!LuaAPI.lua_isfunction(L, idx))\n                    {\n                        return null;\n                    }\n\n                    return translator.CreateDelegateBridge(L, null, idx);\n                };\n            }\n        }\n        //为了减少篇幅，只展示必要代码\n        public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx)\n        {\n            //这边只是查找是否这个方法已经有缓存了，有的话直接返回，没有就要Create，我们继续分析Create的事。\n            LuaAPI.lua_pushvalue(L, idx);\n            LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);\n            //不为null就是已经生成过，就直接从缓存获取\n            if (!LuaAPI.lua_isnil(L, -1))\n            {\n                retrun ...\n            }\n            else\n            {\n                //弹出刚刚查询过的nil值\n                LuaAPI.lua_pop(L, 1);\n            }\n            //开始生成对应的DelegateBridge\n            //压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //获取function对应的引用id\n            int reference = LuaAPI.luaL_ref(L);\n            //再次压入idx对应的值，idx对应的值是Lua中的function\n            LuaAPI.lua_pushvalue(L, idx);\n            //压入function对应的引用id\n            LuaAPI.lua_pushnumber(L, reference);\n            //将栈顶的两个值以字典形式存在全局变量表中，这个的作用就是上面的代码查询是否已经在lua中缓存。\n            LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n            DelegateBridgeBase bridge;\n            try\n            {\n                //创建DelegateBridge，注意这边的reference，这个就是对应了lua中修复的lua函数，\n                //我们在Inject时候call的方法会使用到这个参数。\n                bridge = new DelegateBridge(reference, luaEnv);\n            }\n            catch(Exception e)\n            {\n                //异常情况下的，清场操作\n                LuaAPI.lua_pushvalue(L, idx);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);\n                LuaAPI.lua_pushnil(L);\n                LuaAPI.xlua_rawseti(L, LuaIndexes.LUA_REGISTRYINDEX, reference);\n                throw e;\n            }\n            //因为hotfix时候，delegateType传进来是个null，后续代码不会被调用到，就不做分析了。\n            if (delegateType == null)\n            {\n                //缓存到字典中，注意这里是弱引用所以会被回收，被回收后，需要从lua中查询到对应引用值，然后再生产。\n                delegate_bridges[reference] = new WeakReference(bridge);\n                return bridge;\n            }\n            ...\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样在进行调用hotfix后，对应的要修复的类的静态字段就会被设置上对应的DelegateBridge对象，然后在C#代码执行到对应的需要热更修复的方法时候，会先执行我们注入的IL代码，检查是否有对应的DelegateBridge。那么就是调用DelegateBridge中对应的方法，方法中包含的reference就是Lua对应的function，这样就执行到了lua中去，实现了热更。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"util.hotfix_ex的实现"}]},{"type":"text","value":"\n其实现直白的来讲就是在调用util.hotfix_ex(functionB)时候，真正设置的是一个中间函数A，它被设置为对应方法的热更修复函数。\n在调用A进行热更时候，它先设置这个方法的热更方法为空，然后调用原先设置的functionB，当functionB调用完后，然后再设置回热更方法为A，那么就能实现在热更修复方法functionB中调用原先的方法。\n因为设置这些参数都是带反射的，所以在高频场景是有性能消耗的。\n代码实现如下："}]}]},{"type":"element","tag":"pre","props":{"className":["language-lua"],"code":"local function hotfix_ex(cs, field, func)\n    --断言，检查参数\n    assert(type(field) == 'string' and type(func) == 'function', 'invalid argument: #2 string needed, #3 function needed!')\n    --创建中间函数，就是上文提到的A\n    local function func_after(...)\n        --先将需要热更修复的方法设置为nil，那么再调用方法时候会执行的就是之前方法\n        xlua.hotfix(cs, field, nil)\n        --执行func，就是上文提到的functionB\n        local ret = {func(...)}\n        ---重新将需要热更修复的方法设置为中间函数A\n        xlua.hotfix(cs, field, func_after)\n        return unpack(ret)\n    end\n    --设置需要热更修复为中间函数A\n    xlua.hotfix(cs, field, func_after)\nend\n","language":"lua","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"local function hotfix_ex(cs, field, func)\n    --断言，检查参数\n    assert(type(field) == 'string' and type(func) == 'function', 'invalid argument: #2 string needed, #3 function needed!')\n    --创建中间函数，就是上文提到的A\n    local function func_after(...)\n        --先将需要热更修复的方法设置为nil，那么再调用方法时候会执行的就是之前方法\n        xlua.hotfix(cs, field, nil)\n        --执行func，就是上文提到的functionB\n        local ret = {func(...)}\n        ---重新将需要热更修复的方法设置为中间函数A\n        xlua.hotfix(cs, field, func_after)\n        return unpack(ret)\n    end\n    --设置需要热更修复为中间函数A\n    xlua.hotfix(cs, field, func_after)\nend\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"结束语"}]},{"type":"text","value":"整个Hotfix的实现也分析完了，后续的文章将继续分析，XLua中的各种优化技巧实现，比如无GC传值，模板生成技术。"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2019-09-03-xlua-inject.md","_source":"content","_file":"unity/2019-09-03-xlua-inject.md","_extension":"md","date":"2019-09-03"}