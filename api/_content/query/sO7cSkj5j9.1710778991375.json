{"_path":"/dotnet/2020-08-09-orleans-best-practices","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Orleans 最佳实践","description":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"重入"},"children":[{"type":"text","value":"重入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为访问grain一般是需要跨服务器的，所以可重入是很有必要的。。"}]},{"type":"element","tag":"h1","props":{"id":"无状态grain"},"children":[{"type":"text","value":"无状态Grain"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"grain永远是运行在服务端的,包括无状态的."}]},{"type":"element","tag":"h1","props":{"id":"time"},"children":[{"type":"text","value":"time"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"time是单线程的.."}]},{"type":"element","tag":"h2","props":{"id":"错误"},"children":[{"type":"text","value":"错误"}]},{"type":"element","tag":"pre","props":{"code":"        public override async Task OnActivateAsync()\n        {\n\n            if (this.TimerDisposable == null)\n            {\n                this.TimerDisposable = RegisterTimer(\n                            this.SaveChanges,\n                            \"timer\",\n                            TimeSpan.FromMilliseconds(0),\n                            TimeSpan.FromMilliseconds(1)\n                            );\n            }\n\n            await base.OnActivateAsync();\n        }\n\n\n\n        private Task SaveChanges(object arg)\n        {\n            this.persisitent.State.num++;\n\n            return this.persisitent.WriteStateAsync();\n        }\n\n        public async Task StartUp()\n        {\n            this.persisitent.State.num = 0;\n            await this.WriteStateAsync();\n        }\n        \n        \n           var grain = this.GrainFactory.GetGrain<ITimeTestGrain>(1000);\n\n            await grain.StartUp();\n        \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public override async Task OnActivateAsync()\n        {\n\n            if (this.TimerDisposable == null)\n            {\n                this.TimerDisposable = RegisterTimer(\n                            this.SaveChanges,\n                            \"timer\",\n                            TimeSpan.FromMilliseconds(0),\n                            TimeSpan.FromMilliseconds(1)\n                            );\n            }\n\n            await base.OnActivateAsync();\n        }\n\n\n\n        private Task SaveChanges(object arg)\n        {\n            this.persisitent.State.num++;\n\n            return this.persisitent.WriteStateAsync();\n        }\n\n        public async Task StartUp()\n        {\n            this.persisitent.State.num = 0;\n            await this.WriteStateAsync();\n        }\n        \n        \n           var grain = this.GrainFactory.GetGrain<ITimeTestGrain>(1000);\n\n            await grain.StartUp();\n        \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上代码当duetime设置为0的时候,会有类型的错误"}]},{"type":"element","tag":"pre","props":{"code":"Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原因猜测,grain未激活完成的时候,如果为0的时候,这个时候time的callback(SaveChanges)还没有加入到任务队列,就调用了state,而之后也立即同时调用了state这个时候就会报错."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决方案:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要设置duetime为0"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"或者不要在OnActivateAsync中RegisterTimer,在Activate后再RegisterTimer"}]}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"错误","depth":2,"text":"错误"}]}},"_type":"markdown","_id":"content:dotnet:2020-08-09-Orleans-Best-Practices.md","_source":"content","_file":"dotnet/2020-08-09-Orleans-Best-Practices.md","_extension":"md","date":"2020-08-09"}