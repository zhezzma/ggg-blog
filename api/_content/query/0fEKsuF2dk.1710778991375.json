{"_path":"/unity/2020-11-13-simple-save","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"简单保存工具","description":"using Newtonsoft.Json;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DotHass.Unity\n{\n    public class SaveService : ISaveService\n    {\n        // IMPORTANT: Make sure to change this key for each project you use thi","body":{"type":"root","children":[{"type":"element","tag":"pre","props":{"code":"using Newtonsoft.Json;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DotHass.Unity\n{\n    public class SaveService : ISaveService\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        public string Key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26e\";\n\n        public bool Encrypt = false;\n\n        public SaveService()\n        {\n            // Create a new encryption provider\n            SimpleEncryption.provider = new RijndaelManaged\n            {\n                // Get the bytes from the supplied string key and use it as the provider's key\n                Key = Encoding.ASCII.GetBytes(Key),\n\n                // Ensure that the same data is always encrypted the same way when used with the same key\n                Mode = CipherMode.ECB\n            };\n        }\n\n        protected Task DeleteAsync(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            this.Delete(fullPath);\n            return Task.CompletedTask;\n        }\n\n        protected Task SaveAsync(string key, object value)\n        {\n           \n\n            var fullPath = this.GetFullPath(key);\n            var content = JsonConvert.SerializeObject(value);\n\n            return WriteAsync(fullPath, content);\n        }\n\n        protected async Task<T> LoadAsync<T>(string key, T defaultValue)\n        {\n            var fullPath = this.GetFullPath(key);\n\n            if (this.Exists(fullPath) == false)\n            {\n                return defaultValue;\n            }\n            return await LoadAsync<T>(key);\n        }\n\n        private async Task<T> LoadAsync<T>(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            var content = await this.ReadAsync(fullPath);\n            return JsonConvert.DeserializeObject<T>(content);\n        }\n\n        protected string GetFullPath(string key)\n        {\n            return Path.Combine(Application.persistentDataPath, key.ToUpper());\n        }\n\n        public bool Exists(string fullPath)\n        {\n            return File.Exists(fullPath);\n        }\n\n        public void Delete(string fullPath)\n        {\n            if (File.Exists(fullPath))\n            {\n                File.Delete(fullPath);\n            }\n            else if (Directory.Exists(fullPath))\n            {\n                Directory.Delete(fullPath, true);\n            }\n        }\n\n        public async Task WriteAsync(string fullPath, string content)\n        {\n            if (this.Encrypt == true)\n            {\n                content = SimpleEncryption.EncryptString(content);\n            }\n            using (StreamWriter sw = new StreamWriter(fullPath, false, Encoding.UTF8))\n            {\n                //覆盖该文件\n                await sw.WriteAsync(content);\n            }\n        }\n\n        public async Task<string> ReadAsync(string fullPath)\n        {\n            using (StreamReader sw = new StreamReader(fullPath, Encoding.UTF8))\n            {\n                var fetchedString = await sw.ReadToEndAsync();\n\n                if (this.Encrypt == true)\n                {\n                    fetchedString = SimpleEncryption.DecryptString(fetchedString);\n                }\n                return fetchedString;\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using Newtonsoft.Json;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DotHass.Unity\n{\n    public class SaveService : ISaveService\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        public string Key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26e\";\n\n        public bool Encrypt = false;\n\n        public SaveService()\n        {\n            // Create a new encryption provider\n            SimpleEncryption.provider = new RijndaelManaged\n            {\n                // Get the bytes from the supplied string key and use it as the provider's key\n                Key = Encoding.ASCII.GetBytes(Key),\n\n                // Ensure that the same data is always encrypted the same way when used with the same key\n                Mode = CipherMode.ECB\n            };\n        }\n\n        protected Task DeleteAsync(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            this.Delete(fullPath);\n            return Task.CompletedTask;\n        }\n\n        protected Task SaveAsync(string key, object value)\n        {\n           \n\n            var fullPath = this.GetFullPath(key);\n            var content = JsonConvert.SerializeObject(value);\n\n            return WriteAsync(fullPath, content);\n        }\n\n        protected async Task<T> LoadAsync<T>(string key, T defaultValue)\n        {\n            var fullPath = this.GetFullPath(key);\n\n            if (this.Exists(fullPath) == false)\n            {\n                return defaultValue;\n            }\n            return await LoadAsync<T>(key);\n        }\n\n        private async Task<T> LoadAsync<T>(string key)\n        {\n            var fullPath = this.GetFullPath(key);\n            var content = await this.ReadAsync(fullPath);\n            return JsonConvert.DeserializeObject<T>(content);\n        }\n\n        protected string GetFullPath(string key)\n        {\n            return Path.Combine(Application.persistentDataPath, key.ToUpper());\n        }\n\n        public bool Exists(string fullPath)\n        {\n            return File.Exists(fullPath);\n        }\n\n        public void Delete(string fullPath)\n        {\n            if (File.Exists(fullPath))\n            {\n                File.Delete(fullPath);\n            }\n            else if (Directory.Exists(fullPath))\n            {\n                Directory.Delete(fullPath, true);\n            }\n        }\n\n        public async Task WriteAsync(string fullPath, string content)\n        {\n            if (this.Encrypt == true)\n            {\n                content = SimpleEncryption.EncryptString(content);\n            }\n            using (StreamWriter sw = new StreamWriter(fullPath, false, Encoding.UTF8))\n            {\n                //覆盖该文件\n                await sw.WriteAsync(content);\n            }\n        }\n\n        public async Task<string> ReadAsync(string fullPath)\n        {\n            using (StreamReader sw = new StreamReader(fullPath, Encoding.UTF8))\n            {\n                var fetchedString = await sw.ReadToEndAsync();\n\n                if (this.Encrypt == true)\n                {\n                    fetchedString = SimpleEncryption.DecryptString(fetchedString);\n                }\n                return fetchedString;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"pre","props":{"code":"using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\n/// <summary>\n/// https://github.com/sabresaurus/PlayerPrefsEditor/blob/master/Runtime/SimpleEncryption.cs\n/// </summary>\nnamespace DotHass.Unity\n{\n    public static class SimpleEncryption\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        private static readonly string key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26C\";\n\n        // Cache the encryption provider\n        public static RijndaelManaged provider = null;\n\n        private static void SetupProvider()\n        {\n            // Create a new encryption provider\n            provider = new RijndaelManaged();\n\n            // Get the bytes from the supplied string key and use it as the provider's key\n            provider.Key = Encoding.ASCII.GetBytes(key);\n\n            // Ensure that the same data is always encrypted the same way when used with the same key\n            provider.Mode = CipherMode.ECB;\n        }\n\n        /// <summary>\n        /// Encrypts the specified string using the key stored in SimpleEncryption and returns the encrypted result\n        /// </summary>\n        public static string EncryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create an encryptor to encrypt the bytes\n            ICryptoTransform encryptor = provider.CreateEncryptor();\n\n            // Convert the source string into bytes to be encrypted\n            byte[] sourceBytes = Encoding.UTF8.GetBytes(sourceString);\n\n            // Encrypt the bytes using the encryptor we just created\n            byte[] outputBytes = encryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Convert the encrypted bytes into a Base 64 string, so we can safely represent them as a string and return\n            // that string\n            return Convert.ToBase64String(outputBytes);\n        }\n\n        /// <summary>\n        /// Decrypts the specified string from its specified encrypted value into the returned decrypted value using the\n        /// key stored in SimpleEncryption\n        /// </summary>\n        public static string DecryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create a decryptor to decrypt the encrypted bytes\n            ICryptoTransform decryptor = provider.CreateDecryptor();\n\n            // Convert the base 64 string representing the encrypted bytes back into an array of encrypted bytes\n            byte[] sourceBytes = Convert.FromBase64String(sourceString);\n\n            // Use the decryptor we just created to decrypt those bytes\n            byte[] outputBytes = decryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Turn the decrypted bytes back into the decrypted string and return it\n            return Encoding.UTF8.GetString(outputBytes);\n        }\n\n        /// <summary>\n        /// Encrypts the specified float value and returns an encrypted string\n        /// </summary>\n        public static string EncryptFloat(float value)\n        {\n            // Convert the float into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Encrypts the specified int value and returns an encrypted string\n        /// </summary>\n        public static string EncryptInt(int value)\n        {\n            // Convert the int value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// Encrypts the specified bool value and returns an encrypted string\n        /// </summary>\n        public static string EncryptBool(bool value)\n        {\n            // Convert the bool value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a float into the decrypted float\n        /// </summary>\n        public static float DecryptFloat(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a float and return it\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing an int into the decrypted int\n        /// </summary>\n        public static int DecryptInt(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a int and return it\n            return BitConverter.ToInt32(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a bool into the decrypted bool\n        /// </summary>\n        public static bool DecryptBool(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a bool and return it\n            return BitConverter.ToBoolean(bytes, 0);\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\n/// <summary>\n/// https://github.com/sabresaurus/PlayerPrefsEditor/blob/master/Runtime/SimpleEncryption.cs\n/// </summary>\nnamespace DotHass.Unity\n{\n    public static class SimpleEncryption\n    {\n        // IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your\n        // encrypted values. This key must be exactly 32 characters long (256 bit).\n        private static readonly string key = \":{j%6j?E:t#}G10mM%9hp5S=%}2,Y26C\";\n\n        // Cache the encryption provider\n        public static RijndaelManaged provider = null;\n\n        private static void SetupProvider()\n        {\n            // Create a new encryption provider\n            provider = new RijndaelManaged();\n\n            // Get the bytes from the supplied string key and use it as the provider's key\n            provider.Key = Encoding.ASCII.GetBytes(key);\n\n            // Ensure that the same data is always encrypted the same way when used with the same key\n            provider.Mode = CipherMode.ECB;\n        }\n\n        /// <summary>\n        /// Encrypts the specified string using the key stored in SimpleEncryption and returns the encrypted result\n        /// </summary>\n        public static string EncryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create an encryptor to encrypt the bytes\n            ICryptoTransform encryptor = provider.CreateEncryptor();\n\n            // Convert the source string into bytes to be encrypted\n            byte[] sourceBytes = Encoding.UTF8.GetBytes(sourceString);\n\n            // Encrypt the bytes using the encryptor we just created\n            byte[] outputBytes = encryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Convert the encrypted bytes into a Base 64 string, so we can safely represent them as a string and return\n            // that string\n            return Convert.ToBase64String(outputBytes);\n        }\n\n        /// <summary>\n        /// Decrypts the specified string from its specified encrypted value into the returned decrypted value using the\n        /// key stored in SimpleEncryption\n        /// </summary>\n        public static string DecryptString(string sourceString)\n        {\n            if (provider == null)\n            {\n                // Encryption provider hasn't been set up yet, so set it up\n                SetupProvider();\n            }\n\n            // Create a decryptor to decrypt the encrypted bytes\n            ICryptoTransform decryptor = provider.CreateDecryptor();\n\n            // Convert the base 64 string representing the encrypted bytes back into an array of encrypted bytes\n            byte[] sourceBytes = Convert.FromBase64String(sourceString);\n\n            // Use the decryptor we just created to decrypt those bytes\n            byte[] outputBytes = decryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);\n\n            // Turn the decrypted bytes back into the decrypted string and return it\n            return Encoding.UTF8.GetString(outputBytes);\n        }\n\n        /// <summary>\n        /// Encrypts the specified float value and returns an encrypted string\n        /// </summary>\n        public static string EncryptFloat(float value)\n        {\n            // Convert the float into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Encrypts the specified int value and returns an encrypted string\n        /// </summary>\n        public static string EncryptInt(int value)\n        {\n            // Convert the int value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// Encrypts the specified bool value and returns an encrypted string\n        /// </summary>\n        public static string EncryptBool(bool value)\n        {\n            // Convert the bool value into its 4 bytes\n            byte[] bytes = BitConverter.GetBytes(value);\n\n            // Represent those bytes as a base 64 string\n            string base64 = Convert.ToBase64String(bytes);\n\n            // Return the encrypted version of that base 64 string\n            return SimpleEncryption.EncryptString(base64);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a float into the decrypted float\n        /// </summary>\n        public static float DecryptFloat(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a float and return it\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing an int into the decrypted int\n        /// </summary>\n        public static int DecryptInt(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a int and return it\n            return BitConverter.ToInt32(bytes, 0);\n        }\n\n        /// <summary>\n        /// Decrypts the encrypted string representing a bool into the decrypted bool\n        /// </summary>\n        public static bool DecryptBool(string sourceString)\n        {\n            // Decrypt the encrypted string\n            string decryptedString = SimpleEncryption.DecryptString(sourceString);\n\n            // Convert the decrypted Base 64 representation back into bytes\n            byte[] bytes = Convert.FromBase64String(decryptedString);\n\n            // Turn the bytes back into a bool and return it\n            return BitConverter.ToBoolean(bytes, 0);\n        }\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2020-11-13-simple-save.md","_source":"content","_file":"unity/2020-11-13-simple-save.md","_extension":"md","date":"2020-11-13"}