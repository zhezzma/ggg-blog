{"_path":"/unity/2020-08-29-notch-solution","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Notch Solution","description":"Screen.safeArea会返回移动平台安全区的Rect。例如，iPhoneX（2436x1125px）横屏时，Screen.safeArea返回的值为Rect（132，63，2172，1062）。如图：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Screen.safeArea会返回移动平台安全区的Rect。例如，iPhoneX（2436x1125px）横屏时，Screen.safeArea返回的值为Rect（132，63，2172，1062）。如图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-2381f8819f70e7cd357662188e2616b6_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"适配思路：以界面为单位，打开界面时，获取当前设备的safeArea，调整界面的锚点，进行适配。以下利用SafeArea.cs脚本，对当前window进行适配。主要考虑三种情况："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"情况1：UI中没有全屏背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-b472160ce00e02f830c3e09dd2bc5747_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决思路：直接调整当前window的锚点，进行适配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"情况2：UI中有全屏背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-baffbbebb247c6466fcf5f0b9ddd1a95_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决思路：把背景分离到window之外，只对当前window进行适配，对背景不做处理。为了方便适配，我们可以把背景单独做成window，在UI框架中对window和背景进行分开管理。上图中，蓝色为背景图片，红色为适配的window。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"情况3：适配需要靠边的UI(例如侧边的聊天弹窗等)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-bb8467626340c8dac46c81adf176b1c3_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-29-Notch-Solution/v2-615a71b2dfd94b07e4bed4d0fbcea2db_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决思路：把需要靠边的按钮拉伸到屏幕之外，达到适配效果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/jirowang0409/Garena","rel":["nofollow"]},"children":[{"type":"text","value":"jirowang0409/Garena: Projects in Garena (github.com)"}]}]},{"type":"element","tag":"h1","props":{"id":"notch-solution"},"children":[{"type":"text","value":"notch solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先分为两个component."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://exceed7.com/notch-solution/components/ui-behaviour/safe-padding.html","rel":["nofollow"]},"children":[{"type":"text","value":"SafePadding"}]},{"type":"text","value":"Works with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":" tree of the uGUI component system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://exceed7.com/notch-solution/components/adaptation/safe-adaptation.html","rel":["nofollow"]},"children":[{"type":"text","value":"SafeAdaptation"}]},{"type":"text","value":"They are based on using "},{"type":"element","tag":"a","props":{"href":"https://docs.unity3d.com/ScriptReference/Playables.Playable.html","rel":["nofollow"]},"children":[{"type":"text","value":"Playables API"}]},{"type":"text","value":" to control "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameObject"}]},{"type":"text","value":" with animation playables, therefore utilizing "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Animator"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AnimationClip"}]},{"type":"text","value":" instead of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RectTransform"}]},{"type":"text","value":"."}]}]},{"type":"element","tag":"h2","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"pre","props":{"code":"        protected Rect SafeAreaRelative\n            => NotchSolutionUtility.ShouldUseNotchSimulatorValue ? storedSimulatedSafeAreaRelative : NotchSolutionUtility.ScreenSafeAreaRelative;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected Rect SafeAreaRelative\n            => NotchSolutionUtility.ShouldUseNotchSimulatorValue ? storedSimulatedSafeAreaRelative : NotchSolutionUtility.ScreenSafeAreaRelative;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看这句,如果是使用了模拟器,则使用simulatedSafeAreaRelative"}]},{"type":"element","tag":"pre","props":{"code":"        void INotchSimulatorTarget.SimulatorUpdate(Rect simulatedSafeAreaRelative, Rect[] simulatedCutoutsRelative)\n        {\n            this.storedSimulatedSafeAreaRelative = simulatedSafeAreaRelative;\n            this.storedSimulatedCutoutsRelative = simulatedCutoutsRelative;\n            UpdateRectBase();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        void INotchSimulatorTarget.SimulatorUpdate(Rect simulatedSafeAreaRelative, Rect[] simulatedCutoutsRelative)\n        {\n            this.storedSimulatedSafeAreaRelative = simulatedSafeAreaRelative;\n            this.storedSimulatedCutoutsRelative = simulatedCutoutsRelative;\n            UpdateRectBase();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Editor代码中如果改变了模拟器的环境.则会更改该值"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而生产环境中则会使用NotchSolutionUtility.ScreenSafeAreaRelative,他也是通过Screen.safeArea进行判断的"}]},{"type":"element","tag":"pre","props":{"code":"        internal static Rect ScreenSafeAreaRelative\n        {\n            get\n            {\n                Rect absolutePaddings = Screen.safeArea;\n                cachedScreenSafeAreaRelative = ToScreenRelativeRect(absolutePaddings);\n                cachedScreenSafeArea = absolutePaddings;\n                safeAreaRelativeCached = true;\n                return cachedScreenSafeAreaRelative;\n            }\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        internal static Rect ScreenSafeAreaRelative\n        {\n            get\n            {\n                Rect absolutePaddings = Screen.safeArea;\n                cachedScreenSafeAreaRelative = ToScreenRelativeRect(absolutePaddings);\n                cachedScreenSafeArea = absolutePaddings;\n                safeAreaRelativeCached = true;\n                return cachedScreenSafeAreaRelative;\n            }\n        }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"safepadding"},"children":[{"type":"text","value":"safepadding"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"原理","depth":2,"text":"原理"},{"id":"safepadding","depth":2,"text":"safepadding"}]}},"_type":"markdown","_id":"content:unity:2020-08-29-Notch-Solution.md","_source":"content","_file":"unity/2020-08-29-Notch-Solution.md","_extension":"md","date":"2020-08-29"}