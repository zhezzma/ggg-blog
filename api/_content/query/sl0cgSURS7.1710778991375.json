{"_path":"/unity/2020-10-22-unity-render-order","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"Unity rendering order渲染顺序","description":"關於深度緩衝 (Depth buffering, or z-buffering)勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 Rasterization 怎麼透過 z-buffering ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"關於深度緩衝-depth-buffering-or-z-buffering"},"children":[{"type":"text","value":"關於深度緩衝 (Depth buffering, or z-buffering)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Rasterisation","rel":["nofollow"]},"children":[{"type":"text","value":"Rasterization"}]},{"type":"text","value":" 怎麼透過 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Z-buffering","rel":["nofollow"]},"children":[{"type":"text","value":"z-buffering"}]},{"type":"text","value":" ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小與最後成像尺寸相同。在 Unity shader 中可利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZWrite On | Off"}]},{"type":"text","value":" 來切換是否將深度資訊要寫入到 z-buffer。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果場景中其他物件 rendering 時，也在同一個 pixel 位置渲染結果時，會檢查 z-buffer 所儲存的深度資訊，是否將渲染結果覆蓋原本的 pixel，並且將新的深度資訊寫入到 z-buffer。通常條件會設定為深度資訊比原本更接近攝影機時，就能夠覆蓋原本結果。在 Unity shader 中可利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always"}]},{"type":"text","value":" 來調整判斷方式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"有 z-buffering 機制，可不管物件算繪順序 (rendering order)，使得離攝影機越近的物件，永遠都描繪在其他離攝影機越遠的物件之前"}]},{"type":"text","value":" ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZTest LEqual"}]},{"type":"text","value":")。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-xEsBEXX2jiQ/Wv_KFd2e3hI/AAAAAAAAwHY/aMJAzz3UIPkMUZOUqd9sgz_dsKZYN0PmQCHMYCw/s1600/bed-room.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"房間示意圖","src":"/images/2020-10-22-unity-render-order/bed-room.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"房間示意圖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-x6KnmDnIk6o/Wv_KF_uymYI/AAAAAAAAwHc/XyV7-wddP-0QgqxstR_8MGzLGOxMlbUuACHMYCw/s1600/depth-info-bed-room.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"房間的深度資訊，越深色表示離攝影機越近","src":"/images/2020-10-22-unity-render-order/depth-info-bed-room.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"房間的深度資訊，越深色表示離攝影機越近"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://assetstore.unity.com/packages/3d/props/furniture/pack-gesta-furniture-1-28237","rel":["nofollow"]},"children":[{"type":"text","value":"場景來源"}]}]},{"type":"element","tag":"h2","props":{"id":"renderers-rendering-order"},"children":[{"type":"text","value":"Renderer’s rendering order"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假設 shader 中關閉深度機制的判斷 ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZTest Always"}]},{"type":"text","value":")，或者在 render 場景物件的過程中都不寫入深度 ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZWrite Off"}]},{"type":"text","value":")，即"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"沒有 z-buffering 機制，rendering order 會決定成像的結果，越晚畫的物件永遠都在其他較早畫的物件之上"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而在 SpriteRenderer 直接修改 sorting layer 以及 order in layer 來改變 rendering order，就能調整該物件在算繪結果的物件前後，便是基於此緣故，更多細節可查看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Sprites/Default"}]},{"type":"text","value":" shader 程式碼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"故整理在 Unity 中，rendering order 是根據以下參數進行排序："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Camera depth > Material type > Sorting layer > Order in layer > Material render queue > Camera order algorithm"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Camera depth"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常無法搭配 Clear Flags: Don’t Clear，因為不會清除 depth buffer (z-buffer)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"camera.depth"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇場景中的 camera 編輯"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-VdjJ2P8mRSw/Wv_KGL2e9kI/AAAAAAAAwHg/bf871Tz0ZCgcM_pTnENDlLA2EVCVEOXgQCHMYCw/s1600/edit-camera-depth-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 depth 參數","src":"/images/2020-10-22-unity-render-order/edit-camera-depth-unity.png"},"children":[]}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"編輯 depth 參數"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material type"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"先畫不透明物件 (opaque)，再畫透明物件 (transparent)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根據 material render queue 來決定，數值小於等於 2500 為不透明物件，數值大於 2500 為透明物件"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sorting layer"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯（不過自定義編輯器來達成）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingLayerID"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 Tag Manager 編輯 Sorting layer"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-HQnwI_JP7dQ/Wv_KG_RuisI/AAAAAAAAwHo/8ecZFCMsknsP2XOd227LgYyr_JsP-k5fwCHMYCw/s1600/edit-sorting-layers-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Sorting layers","src":"/images/2020-10-22-unity-render-order/edit-sorting-layers-unity.png"},"children":[]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Sorting layer"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-74IY8tFv9b4/WwAf4mJ-bqI/AAAAAAAAwJQ/xHzyeHjHwP89PPKkCo3Ahp_OrsCdEJNKwCLcBGAs/s1600/edit-sorting-layer-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Sorting layer","src":"/images/2020-10-22-unity-render-order/edit-sorting-layer-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Order in layer"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingOrder"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Order in layer"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-8VZ0pu3-ZdI/WwAfrRVqL9I/AAAAAAAAwJM/89ZAUPkUfUsy9eXQn1bZUW9y_Q8HxBCxwCLcBGAs/s1600/edit-order-in-layer-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Order in layer","src":"/images/2020-10-22-unity-render-order/edit-order-in-layer-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material render queue"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數字越大越晚畫"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"預設值會從 Shader 取得，但可自行定義"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不透明物件 (Opaque)、半透明物件 (AlphaTest)、透明物件 (Transparent) 預設值分別 2000、2450、以及 3000"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通常只有透明物件會關閉 ZWrite"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"material.renderQueue"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"選擇專案中的 material 編輯"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/--4-IFurF7lk/Wv_KGSiPZ2I/AAAAAAAAwHk/95Bv8w902lke-HN_CCP1wigeekWuMQknQCHMYCw/s1600/edit-render-queue-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 render queue","src":"/images/2020-10-22-unity-render-order/edit-render-queue-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Camera render algorithm"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"無法在預設編輯器修改，使用程式調整"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"非透明物件排序演算法"},{"type":"element","tag":"pre","props":{"code":"camera.opaqueSortMode\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"camera.opaqueSortMode\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Default：在 Unity 2018.1 預設值 FrontToBack"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"FrontToBack：粗略低由近到遠排序繪製，能使得 GPU rendering 時有更好的效能"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"NoDistanceSort：關閉排序繪製，能降低 CPU 的使用量"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透明物件排序演算法"},{"type":"element","tag":"pre","props":{"code":"camera.transparencySortMode\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"camera.transparencySortMode\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Default：根據 camera projection mode 調整"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Perspective：根據 camera 位置到物件中心 (object center) 的距離排序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Orthographic：根據 view plane 到物件中心 (object center) 的距離排序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CustomAxis：制定 axis 排序，專門用於 2D 遊戲製作，可參考"},{"type":"element","tag":"a","props":{"href":"https://qiita.com/RyotaMurohoshi/items/3f0de2689af72f9b46f9","rel":["nofollow"]},"children":[{"type":"text","value":"這篇文章"}]}]}]}]}]}]}]},{"type":"element","tag":"h4","props":{"id":"补充renderqueue"},"children":[{"type":"text","value":"补充RenderQueue"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"nderQueue ，RenderQueue 其实就是shader中tags中的Queue"}]},{"type":"element","tag":"pre","props":{"code":"Tags { \"Queue\"=\"Geometry\" }\n","language":"bash","meta":"","className":["language-bash"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Tags { \"Queue\"=\"Geometry\" }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下，Unity会基于对象距离摄像机的远近来排序你的对象。因此，当一个对象离摄像机越近，它就会优先绘制在其他更远的对象上面。对于大多数情况这是有效并合适的，但是在一些特殊情况下，你可能想要自己控制对象的绘制顺序。而使用Tags{}块我们就可以得到这样的控制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity提供给我们一些默认的渲染队列，每一个对应一个唯一的值，来指导Unity绘制对象到屏幕上。这些内置的渲染队列被称为Background, Geometry, AlphaTest, GeometryLast,Transparent, Overlay。这些队列不是随便创建的，它们是为了让我们更容易地编写Shader并处理实时渲染的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同时需在SubShader中显示声明ZWrite Off，通知Unity我们会重写物体的渲染深度排序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"https:////upload-images.jianshu.io/upload_images/15536448-9a2deda21e4f661e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/744/format/webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，最后给出一个最终的总结：\n依次按条件先后顺序进行排序渲染处理。先按大项条件排序，后按小项条件排序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.Camera Depth: 越小越优先\n2.RenderQueue 2500以下"}]},{"type":"element","tag":"pre","props":{"code":"1. Sorting Layer/Order in Layer\n    1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n    2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n    2.RenderQueue 越小越优先\n    3.RenderQueue 相等，`由近到远排序优先`\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"1. Sorting Layer/Order in Layer\n    1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n    2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n    2.RenderQueue 越小越优先\n    3.RenderQueue 相等，`由近到远排序优先`\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.RenderQueue 2500以上\n1. Sorting Layer/Order in Layer\n1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先\n2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序\n2.RenderQueue 越小越优先\n3.RenderQueue 相等，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"由远到近排序优先"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说明一下：2500是关键值，它是透明跟不透明的分界点，因此我们考虑层级的时候要注意着点：renderqueue > 2500的物体绝对会在renderqueue <= 2500的物体前面，即渲染时renderqueue大的会挡住renderqueue小的，不论它的sortingLayer和sortingOrder怎么设置都是不起作用的。知道了这点，其他的就很好理解了。当两个的RenderQueue都在同一侧时，在SortingLayer高的绝对会在sortingLayer前面，无视renderqueue跟soringOrder，只有在sortingLayer相同的前提下，soringOrder高的会在sortingOrder低的前面，无视renderqueue。当sortingLayer跟sortingOrder相同时，才看renderqueue的高低，高的在前面。特别要注意一下半透明物体的渲染顺序是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"越远越先渲染"}]},{"type":"text","value":"，这与不透明物体是相反的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UGUI中的ui默认使用的是UI/Default 材质，对应的shader中的渲染队列是Transparent"}]},{"type":"element","tag":"pre","props":{"code":"Shader \"UI/Default\"\n{\n    Properties\n    {\n       ...\n    }\n\n    SubShader\n    {\n        Tags\n        {\n            \"Queue\"=\"Transparent\"\n            \"IgnoreProjector\"=\"True\"\n            \"RenderType\"=\"Transparent\"\n            \"PreviewType\"=\"Plane\"\n            \"CanUseSpriteAtlas\"=\"True\"\n        }\n        ...\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Shader \"UI/Default\"\n{\n    Properties\n    {\n       ...\n    }\n\n    SubShader\n    {\n        Tags\n        {\n            \"Queue\"=\"Transparent\"\n            \"IgnoreProjector\"=\"True\"\n            \"RenderType\"=\"Transparent\"\n            \"PreviewType\"=\"Plane\"\n            \"CanUseSpriteAtlas\"=\"True\"\n        }\n        ...\n    }\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"uguis-rendering-order"},"children":[{"type":"text","value":"UGUI’s rendering order"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Unity 5.x 推出的 UGUI 系統中，其 rendering order 卻是另外規則，這分成兩個部分探討 Canvas & CanvasRenderer，其概念可想像是 CanvasRenderer 可視為畫在畫布 Canvas 的元件，之後該畫布再畫在最終的畫面上（e.g. render target）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"關於 Canvas 的 rendering order："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Screen Space - Overlay"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"想像該 canvas 由隱藏的 camera 處理，其 depth = 101 (最後才處理)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多個相同的 canvas 使用 Sort Order 來決定描繪順序，數字越大越晚畫"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://3.bp.blogspot.com/-Jwq-GkVy5Pg/Wv_MaxvDuEI/AAAAAAAAwII/8xeKRt-08sw9AtYHAxXbPztqk3rlwMH6QCLcBGAs/s1600/edit-canvas-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Canvas's Sort Order","src":"/images/2020-10-22-unity-render-order/edit-canvas-unity.png"},"children":[]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Screen Space - Camera & World Space"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"想像為存在在世界場景的平面"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多個相同 canvas 使用 Sorting layer 以及 Order in layer 來決定 rendering order"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://4.bp.blogspot.com/-u-mDDKcRfAY/Wv_NHS9SsZI/AAAAAAAAwIU/Mt_mBRPL8DYo7Xj9Cbh-hOPTFbg6X3UMgCLcBGAs/s1600/edit-canvas-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"編輯 Canvas's Sorting layer & Order in layer","src":"/images/2020-10-22-unity-render-order/edit-canvas-unity.png"},"children":[]}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"關於同一個 canvas 下，其 CanvasRenderer 之間的 rendering order："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material render queue > Transform order"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Material render queue 同前面說明，看材質球 (material) 的 render queue 參數"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Transform order：依照 Transform 階層關係，採 Pre-order 方式排序"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://4.bp.blogspot.com/-fCMusmLKj4k/Wv_NnqL6SXI/AAAAAAAAwIo/suCM_XaddIAEwirQkIibP2wB8Mas3EjagCLcBGAs/s1600/canvas-renderer-rendering-order-unity.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"Canvas renderer's rendering order example","src":"/images/2020-10-22-unity-render-order/canvas-renderer-rendering-order-unity.png"},"children":[]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注意：當所屬的 Canvas 之 render mode 為 Screen Space - Overlay，則無視 Material render queue"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"使用實踐情境"},"children":[{"type":"text","value":"使用實踐情境"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3D"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不透明物件 & 半透明物件 (e.g. 草、鐵絲網等等) 依照場景擺放"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不需要特別設定 rendering order"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一切交給 z-buffering 機制"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透明物件或是粒子特效 (particle system) 可透過 sort layer & order in layer 機制調整 rendering order"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"透明物件 shader 通常不會寫 z-buffer (e.g. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ZWrite Off"}]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可 hack inspector 來設定 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingLayerID"}]},{"type":"text","value":" 以及 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"renderer.sortingOrder"}]}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2D"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sprite renderer 使用 sort layer & order in layer 機制來調整 rendering order，以控制 depth"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UGUI"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"利用 transform hierarchy 來建立 rendering order，因應效能優化可能還得拆成多個 canvas"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"若採用 Canvas render mode: World space，想讓 UI 與 3D 場景物件的結合，可將 canvas 視為 3D 物件去設計場景架構 (這自己就沒有經驗…)"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"關於深度緩衝-depth-buffering-or-z-buffering","depth":2,"text":"關於深度緩衝 (Depth buffering, or z-buffering)"},{"id":"renderers-rendering-order","depth":2,"text":"Renderer’s rendering order"},{"id":"uguis-rendering-order","depth":2,"text":"UGUI’s rendering order"},{"id":"使用實踐情境","depth":2,"text":"使用實踐情境"}]}},"_type":"markdown","_id":"content:unity:2020-10-22-unity-render-order.md","_source":"content","_file":"unity/2020-10-22-unity-render-order.md","_extension":"md","date":"2020-10-22"}