{"_path":"/dotnet/2020-08-15-kestrel-source-code","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Kestrel源码分析","description":"Kestrel是http://ASP.NET Core框架内置的默认Web Server 什么是Web Server? 根据维基百科的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Kestrel是"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core框架内置的默认Web Server 什么是Web Server? 根据"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Web_server","rel":["nofollow"]},"children":[{"type":"text","value":"维基百科"}]},{"type":"text","value":"的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。"}]},{"type":"element","tag":"h2","props":{"id":"定义-iserverihttpapplicationtcontext"},"children":[{"type":"text","value":"定义 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core定义了两个基本的接口"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"，及"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"接口定义了Web Server的基本功能，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"则定义了处理HTTP协议的应用程序的基本功能，我们首先来看下这两个定义:"}]},{"type":"element","tag":"h2","props":{"id":"web-服务器-iserver"},"children":[{"type":"text","value":"Web 服务器 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents a server.\n    /// </summary>\n    public interface IServer : IDisposable\n    {\n        /// <summary>\n        /// A collection of HTTP features of the server.\n        /// </summary>\n        IFeatureCollection Features { get; }\n\n        /// <summary>\n        /// Start the server with an application.\n        /// </summary>\n        /// <param name=\"application\">An instance of <see cref=\"IHttpApplication{TContext}\"/>.</param>\n        /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n        /// <param name=\"cancellationToken\">Indicates if the server startup should be aborted.</param>\n        Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken);\n\n        /// <summary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.</param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents a server.\n    /// </summary>\n    public interface IServer : IDisposable\n    {\n        /// <summary>\n        /// A collection of HTTP features of the server.\n        /// </summary>\n        IFeatureCollection Features { get; }\n\n        /// <summary>\n        /// Start the server with an application.\n        /// </summary>\n        /// <param name=\"application\">An instance of <see cref=\"IHttpApplication{TContext}\"/>.</param>\n        /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n        /// <param name=\"cancellationToken\">Indicates if the server startup should be aborted.</param>\n        Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken);\n\n        /// <summary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.</param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Features"}]},{"type":"text","value":" 是一个功能集合，其中可以包含所有应用程序需要的，用以处理HTTP协议各个阶段和组成部分的功能集，以接口的形式注入到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Features"}]},{"type":"text","value":"中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync"}]},{"type":"text","value":"方法可以启动IServer对象，用来接受用户请求。包含两个参数："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"。 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplicatoin<TContext>"}]},{"type":"text","value":"是最终处理HTTP请求的应用程序入口点，在ASP.NET Core应用程序中，默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"实现是："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HostingApplication"}]},{"type":"text","value":"，我们会在稍后的部分进行详细的介绍。 而"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"用来响应中断应用程序启动的请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StopAsync"}]},{"type":"text","value":"方法用来处理停止服务的请求，接受一个参数"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"，用来响应中断停止应用程序的请求。"}]},{"type":"element","tag":"h2","props":{"id":"http应用程序-ihttpapplicationtcontext"},"children":[{"type":"text","value":"Http应用程序 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents an application.\n    /// </summary>\n    /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n    public interface IHttpApplication<TContext>\n    {\n        /// <summary>\n        /// Create a TContext given a collection of HTTP features.\n        /// </summary>\n        /// <param name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.</param>\n        /// <returns>The created TContext.</returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// <summary>\n        /// Asynchronously processes an TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext that the operation will process.</param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// <summary>\n        /// Dispose a given TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext to be disposed.</param>\n        /// <param name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.</param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents an application.\n    /// </summary>\n    /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n    public interface IHttpApplication<TContext>\n    {\n        /// <summary>\n        /// Create a TContext given a collection of HTTP features.\n        /// </summary>\n        /// <param name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.</param>\n        /// <returns>The created TContext.</returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// <summary>\n        /// Asynchronously processes an TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext that the operation will process.</param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// <summary>\n        /// Dispose a given TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext to be disposed.</param>\n        /// <param name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.</param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"接口的定义包含了三个方法： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateContext"}]},{"type":"text","value":"方法用来创建处理请求的上下文中所需要的所有相关数据，组成"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象，由接口的实现自己定义类型， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ProcessRequestAsync"}]},{"type":"text","value":"方法使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateContext"}]},{"type":"text","value":"方法创建的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象处理本次请求。 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DisposeContext"}]},{"type":"text","value":"方法在完成请求的处理后，负责释放"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象。"}]},{"type":"element","tag":"h2","props":{"id":"实现-kestrelserver"},"children":[{"type":"text","value":"实现 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core提供了默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"，下面我们就来看看"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"具体都做了些什么。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":" 定义在dotnet/aspnetcore项目中（"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore","rel":["nofollow"]},"children":[{"type":"text","value":"GITHUB REPO"}]},{"type":"text","value":"）。 项目名称为：Microsoft.AspNetCore.Server.Kestrel.Core 名称空间.AspNetCore.Server.Kestrel.Core "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore/blob/master/src/Servers/Kestrel/Core/src/KestrelServer.cs","rel":["nofollow"]},"children":[{"type":"text","value":"源代码"}]}]}]},{"type":"element","tag":"h2","props":{"id":"服务器启动端口监听协议解析及请求处理"},"children":[{"type":"text","value":"服务器启动：端口监听，协议解析及请求处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先看一下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync()"}]},{"type":"text","value":"方法的代码实现："}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"public async Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"首先会检查服务器的"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F","rel":["nofollow"]},"children":[{"type":"text","value":"字节序"}]},{"type":"text","value":"，目前是不支持大端序的。 然后检查最大请求长度限制的设置项，以及服务器是否已经启动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddressBinder"}]},{"type":"text","value":"对预先配置的IP地址或终结点(EndPoint)名称进行监听，开始接受客户端的请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当每有一个新的HTTP请求通过TCP协议或其他协议和服务器成功简历连接后，AddressBinder使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadPool.UnsafeQueueUserWorkItem()"}]},{"type":"text","value":"方法将"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法添加到线程池中，等待线程池的调度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果此时进程有可用的线程，就会调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法，处理用户的HTTP请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法默认使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件，处理新接入的用户请求，当设置了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MaxConcurrentConnections"}]},{"type":"text","value":"值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"True"}]},{"type":"text","value":"时，则会默认使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConnectionLimitMiddleware"}]},{"type":"text","value":"中间件，限制最大可用连接数，如果当前请求数已经达到最大可接受连接数，则拒绝用户的请求并断开连接，否则调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件，继续处理用户的请求。"}]},{"type":"element","tag":"h2","props":{"id":"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection"},"children":[{"type":"text","value":"处理HTTP请求 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件负责组装连接相关的上下文数据"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionContext"}]},{"type":"text","value":"，并使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]},{"type":"text","value":"类处理用户请求。"}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"internal class HttpConnectionMiddleware<TContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication<TContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication<TContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get<IMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"internal class HttpConnectionMiddleware<TContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication<TContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication<TContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get<IMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n"}]}]},{"type":"element","tag":"h3","props":{"id":"http版本控制-httpconnection"},"children":[{"type":"text","value":"HTTP版本控制 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当用户创建"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]},{"type":"text","value":"类时，在初始化过程中，会根据用户请求声明的HTTP协议版本，分别创建对应版本的Connection类，并使用该类处理用户请求："}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"public async Task ProcessRequestsAsync<TContext>(IHttpApplication<TContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection<TContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get<IConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get<IConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task ProcessRequestsAsync<TContext>(IHttpApplication<TContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection<TContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get<IConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get<IConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HTTP1和HTTP2处理HTTP协议的方式有所不同，HTTP1协议解析完成后，会立即调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"处理请求，HTTP2协议解析完成后，会再次调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadPool.UnsafeQueueUserWorkItem()"}]},{"type":"text","value":"方法等待线程池可用线程。"}]},{"type":"element","tag":"h2","props":{"id":"结束语"},"children":[{"type":"text","value":"结束语"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"服务的代码量并不下，其中主要是辅助接受用户请求和解析HTTP协议的代码，在这里不做详细的介绍，各位读者有兴趣的，可以详细阅读源代码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"服务在接受和处理请求时，都用到了线程池，可以极大的提高服务器的吞吐量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后面，我们还会详细介绍系统默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"实现，看看ASP.NET Core是如何将HTTP转发到Controller和Action，其中又有哪些精妙的代码呢。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"定义-iserverihttpapplicationtcontext","depth":2,"text":"定义 - IServer、IHttpApplication<TContext>"},{"id":"web-服务器-iserver","depth":2,"text":"Web 服务器 - IServer"},{"id":"http应用程序-ihttpapplicationtcontext","depth":2,"text":"Http应用程序 - IHttpApplication<TContext>"},{"id":"实现-kestrelserver","depth":2,"text":"实现 - KestrelServer"},{"id":"服务器启动端口监听协议解析及请求处理","depth":2,"text":"服务器启动：端口监听，协议解析及请求处理。"},{"id":"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection","depth":2,"text":"处理HTTP请求 - HttpConnectionMiddleware<ServiceContext>、HttpConnection","children":[{"id":"http版本控制-httpconnection","depth":3,"text":"HTTP版本控制 - HttpConnection"}]},{"id":"结束语","depth":2,"text":"结束语"}]}},"_type":"markdown","_id":"content:dotnet:2020-08-15-Kestrel-source-code.md","_source":"content","_file":"dotnet/2020-08-15-Kestrel-source-code.md","_extension":"md","date":"2020-08-15"}