[{"_path":"/game/2022-08-21-behavior-tree-source-code","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"行为树源代码解析","description":"行为树的构建首先行为树会有个根节点TaskRoot ,当构建行为树的时候,会将节点添加到该root下行为树的构建如下://获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"行为树的构建"},"children":[{"type":"text","value":"行为树的构建"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先行为树会有个根节点"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskRoot"}]},{"type":"text","value":" ,当构建行为树的时候,会将节点添加到该root下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"行为树的构建如下:"}]},{"type":"element","tag":"pre","props":{"code":"//获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _tree.AddNode(PointerCurrent, node);\n    return this;\n}\n//增加节点,并将该节点设置为当前父节点\npublic BehaviorTreeBuilder AddNodeWithPointer (ITaskParent task) {\n    AddNode(task);\n    _pointers.Add(task);\n    \n    return this;\n}\n//退出当前父节点\npublic BehaviorTreeBuilder End () {\n    _pointers.RemoveAt(_pointers.Count - 1);\n    \n    return this;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//获取当前父节点..默认则为TaskRoot\nprivate ITaskParent PointerCurrent {\n    get {\n        if (_pointers.Count == 0) return null;\n        return _pointers[_pointers.Count - 1];\n    }\n}\n//增加节点到当前父节点\npublic BehaviorTreeBuilder AddNode (ITask node) {\n    _tree.AddNode(PointerCurrent, node);\n    return this;\n}\n//增加节点,并将该节点设置为当前父节点\npublic BehaviorTreeBuilder AddNodeWithPointer (ITaskParent task) {\n    AddNode(task);\n    _pointers.Add(task);\n    \n    return this;\n}\n//退出当前父节点\npublic BehaviorTreeBuilder End () {\n    _pointers.RemoveAt(_pointers.Count - 1);\n    \n    return this;\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"行为树的运行"},"children":[{"type":"text","value":"行为树的运行"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每一帧都执行update(),且如果根节点返回的是成功或者失败,则清空所有任务并"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"End()"}]},{"type":"text","value":",累计tick(所有子节点都会执行Reset())"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果子节点中有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"持续"}]},{"type":"text","value":"的任务时,则该任务会被认为时激活的.添加到行为树中"}]}]},{"type":"element","tag":"pre","props":{"code":"public TaskStatus Tick () {\n    var status = Root.Update();\n    if (status != TaskStatus.Continue) {\n        Reset();\n    }\n\n    return status;\n}\n\npublic void Reset () {\n    foreach (var task in _tasks) {\n        task.End();\n    }\n\n    _tasks.Clear();\n    TickCount++;\n}\n","language":"csharp","meta":"","className":["language-csharp"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public TaskStatus Tick () {\n    var status = Root.Update();\n    if (status != TaskStatus.Continue) {\n        Reset();\n    }\n\n    return status;\n}\n\npublic void Reset () {\n    foreach (var task in _tasks) {\n        task.End();\n    }\n\n    _tasks.Clear();\n    TickCount++;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们看看任务的子类有哪些:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskRoot"}]},{"type":"text","value":" 一般来说只有一个子节点"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskParentBase"}]},{"type":"text","value":" ,会在每一次循环中同步tick,如果tick和行为树不一样,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":",如果onUpdate()返回的时成功或者失败,也会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TaskBase"}]},{"type":"text","value":" 会在每一次循环中同步tick,如果tick和行为树不一样,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Reset"}]},{"type":"text","value":",如果GetUpdate()返回的时成功或者失败,则会"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Exit"}]},{"type":"text","value":" (Exit时会Reset)且如果自己的状态曾经为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Continue"}]},{"type":"text","value":"会从行为树的激活任务中移除,否则会将自身添加到行为树的激活任务中."}]}]},{"type":"element","tag":"h3","props":{"id":"持续的任务是怎么运行的"},"children":[{"type":"text","value":"持续的任务是怎么运行的"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;\nRoot --> Sequence;\nSequence-->TaskA;\nSequence-->TaskB;\nSequence-->TaskC;\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;\nRoot --> Sequence;\nSequence-->TaskA;\nSequence-->TaskB;\nSequence-->TaskC;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sequence会记录自己循环过哪些task. 当taskb持续状态时,则会进入下一个循环,但不会进入下一tick,走到Sequence后,他不会执行已经执行过的任务,所以进入Sequence后会直接执行TaskB;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只有当有任务失败或者成功,才会执行下一个tick,下一个tick所有task都会reset"}]},{"type":"element","tag":"h2","props":{"id":"使用"},"children":[{"type":"text","value":"使用"}]},{"type":"element","tag":"h3","props":{"id":"并行"},"children":[{"type":"text","value":"并行"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用.,注意子节点,要么是持续的,要么是成功的..如果有任何失败了将会reset"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"并行需要等待子节点全部完成,再根据子节点的返回状态判断该并行节点的状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"并不是说并行,就是两个不想干的node不断的执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同时执行下面所有子节点的start(),然后等待所有子节点的反馈是成功还是失败"}]}]},{"type":"element","tag":"h3","props":{"id":"序列"},"children":[{"type":"text","value":"序列"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般把Sequence-->Condition  当作if  就可以"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;Sequence --> Condition;Sequence --> AC\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;Sequence --> Condition;Sequence --> AC\n"}]}]},{"type":"element","tag":"h3","props":{"id":"选择"},"children":[{"type":"text","value":"选择"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由下图可以看出..Selector --> Sequence--> Condition  相当于if else"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-21-behavior-tree-source-code/1660118886000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把select,当成 if not来看"}]},{"type":"element","tag":"pre","props":{"code":"graph TD;\nSelect -->Condition; Select-->action\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;\nSelect -->Condition; Select-->action\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"select-->Inverter -->Condition  可以当作if来看.."}]},{"type":"element","tag":"pre","props":{"code":"graph TD;select --> inverter-->conditions;select-->action\n","language":"mermaid","meta":"","className":["language-mermaid"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"graph TD;select --> inverter-->conditions;select-->action\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和Sequence的区别就是,select在执行b前返回的是true."}]},{"type":"element","tag":"h3","props":{"id":"观察者模式"},"children":[{"type":"text","value":"观察者模式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"观察者装饰器...就是观察某个变量..然后决定低优先级节点,自身节点,的执行(重启等)方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分为两种状况\n1.在当前节点未激活的时候,观察某个变量 生效的方式:Stops.LOWER_PRIORITY,Stops.BOTH,Stops.LOWER_PRIORITY_IMMEDIATE_RESTART,Stops.IMMEDIATE_RESTART\n2.在当前节点激活的时候,观察某个变量Stops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART\n所以会有三种节点出现"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()永远返回true,子节点永远返回false,保证该装饰器节点是inactive状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()永远返回false,子节点永远返回true,保证该装饰器节点是active状态"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"IsConditionMet()根据情况返回true和false,比如如果玩家在附近,则执行该装饰器下代码.如果玩家不在附近则stop,执行低优先级代码"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stops.NONE：装饰器只会在启动时检查一次它的状态，并且永远不会停止任何正在运行的节点。\nStops.SELF：装饰器将在启动时检查一次它的条件状态，如果满足，它将继续观察黑板的变化。一旦不再满足该条件，它将终止自身，并让父组合继续处理它的下一个节点。\nStops.LOWER_PRIORITY：装饰器将在启动时检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止比此结点优先级较低的节点，允许父组合继续处理下一个节点\nStops.BOTH：装饰器将同时停止:self和优先级较低的节点。\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启此装饰器。\nStops.IMMEDIATE_RESTART：一旦启动，装饰器将检查它的状态，如果不满足，它将观察黑板的变化。一旦条件满足，它将停止优先级较低的节点，并命令父组合立即重启装饰器。正如在这两种情况下，一旦不再满足条件，它也将停止自己。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说人话..就是\n在当前节点未激活的时候,观察某个变量\nStops.LOWER_PRIORITY_IMMEDIATE_RESTART和Stops.IMMEDIATE_RESTART这个会停止低优先级(就是该节点后面的)的节点,然后会立即重新开始当前节点\nStops.LOWER_PRIORITY和Stops.BOTH 会先停止优先级较低的节点,然后再停止父节点"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在当前节点激活的时候,观察某个变量\nStops.SELF Stops.BOTH Stops.IMMEDIATE_RESTART 这三个,都会先停止子节点.然后停止自身,最后会影响到停止父节点"}]},{"type":"element","tag":"h3","props":{"id":"条件和装饰器"},"children":[{"type":"text","value":"条件和装饰器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RepeatUntilSuccess --> ConditionBase 可以构成一个新动作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConditionBase 在返回失败的时候被RepeatUntilSuccess 转换为持续"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"行为树的构建","depth":2,"text":"行为树的构建"},{"id":"行为树的运行","depth":2,"text":"行为树的运行","children":[{"id":"持续的任务是怎么运行的","depth":3,"text":"持续的任务是怎么运行的"}]},{"id":"使用","depth":2,"text":"使用","children":[{"id":"并行","depth":3,"text":"并行"},{"id":"序列","depth":3,"text":"序列"},{"id":"选择","depth":3,"text":"选择"},{"id":"观察者模式","depth":3,"text":"观察者模式"},{"id":"条件和装饰器","depth":3,"text":"条件和装饰器"}]}]}},"_type":"markdown","_id":"content:game:2022-08-21-behavior-tree-source-code.md","_source":"content","_file":"game/2022-08-21-behavior-tree-source-code.md","_extension":"md","date":"2022-08-21"},{"_path":"/game/2022-08-05-dia2","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"暗黑2怪物等级和掉落规则","description":"怪物等级在普通难度上，怪物的等级由怪物的种类决定，不受场景等级的制约。在噩梦和地狱的难度中，怪物的等级由场景等级决定。普通怪物的等级为场景等级，场景的蓝色精英怪物等级为场景等级加2，金色怪物等级为场景等级加3.例如:85级的场景中会出现普通怪物85级、boss怪物87级、精英金怪兽88级3种等级的怪物关底boss等级固定，与场景等级无太大关系。怪物的分类要研究暗黑2的物品掉落系统，首先要了解暗黑世界中的怪物。暗黑中怪物分为如下几个种类等级：\n1.（eBoss）：中文中我们一般称之为.【关底BOSS】，如安达里尔、督瑞尔、墨菲斯托等\n2.（Boss）：即【普通BOSS】，这些怪物有且仅有6个：\n","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"怪物等级"},"children":[{"type":"text","value":"怪物等级"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在普通难度上，怪物的等级由怪物的种类决定，不受场景等级的制约。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在噩梦和地狱的难度中，怪物的等级由场景等级决定。普通怪物的等级为场景等级，场景的蓝色精英怪物等级为场景等级加2，金色怪物等级为场景等级加3.例如:85级的场景中会出现普通怪物85级、boss怪物87级、精英金怪兽88级3种等级的怪物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"关底boss等级固定"}]},{"type":"text","value":"，与场景等级无太大关系。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765901000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765913000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765924000.png"},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659765933000.png"},"children":[]}]}]},{"type":"element","tag":"h3","props":{"id":"怪物的分类"},"children":[{"type":"text","value":"怪物的分类"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要研究暗黑2的物品掉落系统，首先要了解暗黑世界中的怪物。暗黑中怪物分为如下几个种类等级："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n1.（eBoss）：中文中我们一般称之为.【关底BOSS】，如安达里尔、督瑞尔、墨菲斯托等"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n2.（Boss）：即【普通BOSS】，这些怪物有且仅有6个："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n☆血乌 格里斯瓦得 罗达门特 召唤者 衣卒尔 尼拉塞克"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n3.（Unique）：中文中我们一般称之为【精英怪】，游戏中表现为其名字为暗金色。分为固定精英怪（Super Unique）和随机精英怪（Random Unique）。固定精英怪拥有固定的名字和固定的出现地点，拥有固定属性以及可能出现的随机属性。如“毕须博须”、“暴躁外皮”等。随机精英怪则是在游戏中随机出现，名字由词缀“XXX之XXX的”的随机构成，并随机获得一些特殊属性。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n4.（Minion）：中文中我们称之为【随从】，即精英怪身边的与其同类的喽啰怪物。在游戏中外观和普通怪一样，但隐藏有带领它的精英怪的部分特殊属性。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n5.（Champion）：中文中我们称之为【头目】。游戏中表现为其名字为蓝色。有时候它们能从其名字的前缀（如果有的话）中获得特殊属性。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n6.（Normal）：普通小怪。游戏中表现为其名字为白色。"}]},{"type":"element","tag":"h3","props":{"id":"财宝阶层"},"children":[{"type":"text","value":"财宝阶层"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TC是一个包含了众多物品清单的多层目录，一个大TC目录中可能包含有多个子TC目录。 怪物死亡后掉落的物品就是从其TC目录的物品清单中按照一定规则随机取出物品。\n但我们玩家在日常口头交流时，常常只讨论武器和防具的掉落，并将TC目录简化为一个数字等级，简称为怪物的TC。比如我们常说的墨菲斯托的TC=78，暴躁外皮的TC=87等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"☆TC由3到87，按3递增（3、6、9…81、84、87），共有29个递增的TC阶层。"}]},{"type":"element","tag":"h2","props":{"id":"掉落规则"},"children":[{"type":"text","value":"掉落规则"}]},{"type":"element","tag":"h3","props":{"id":"物品等级"},"children":[{"type":"text","value":"物品等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"物品等级常用术语为ilvl，注意这个等级不是使用装备需要的等级，而是一个内在的等级数据，一定程度上决定了装备可能的质量。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"打怪掉落  打怪刷到的装备等级=掉装备怪物的等级"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"翻箱子掉落 开箱子掉落的装备等级=场景等级"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在NPC那里买到 商店买的装备等级=人物等级+5"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在NPC那里通过赌博得到  赌博得的装备等级=人物等级+4或-5"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"**物品等级最大99。**物品等级最大的作用有两个："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"决定了该物品的最大出孔数,比如，同样是灰幕寿衣，如果是25级以下怪物掉落的，它的物品等级就是25以下，它最大的打孔数就是3孔；如果是高于25级怪物掉落的，它的物品等级也就高于25，这件衣服最大孔数就是4孔。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"物品等级决定了装备的词缀，物品等级越高，可能出现的词缀就越好。"}]}]},{"type":"element","tag":"h3","props":{"id":"词缀等级"},"children":[{"type":"text","value":"词缀等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"物品的属性来源于物品所具有的词缀。游戏中每一种词缀都代表了某一种特定的属性，一旦物品拥有了某个词缀，那么就一定具有这个词缀所代表的属性。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n所有的词缀总共分为2类：前缀和后缀。前缀和后缀又分别按照所代表属性的不同分成组。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767663000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如图中的绿框内是前缀，红框内是后缀，它们对应下面蓝色字体的“属性”，珠宝匠对应4孔，偏向对应格档速度和格档机率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"词缀种类非常多，蓝色装备最多可以从词缀中选择不同的两个，黄色最多选择6个。而不同词缀又是有不同等级的，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"高等级词缀当然只能出现在物品等级和品质等级更高的装备上。"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n前缀共分为三个系26个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第一系是进攻型前缀共计14小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号110组加准确率；编号105组增强伤害；编号111组同时加准确和伤害 或者 按等级加准确；编号123组加对恶魔的准确和伤害；编号142组加对不死的准确和伤害；编号137组加冰伤害；编号138组加火伤害；编号139组加电伤害；编号140组加毒伤害；编号113组吓跑怪物；编号121组杀死敌人加法力；编号107组所受伤害转为法力；编号114组加mf；编号112组加照亮范围"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第二系是防御型前缀共计11小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号117组加抗冰；编号118组加抗火；编号119组加抗电；编号120组加抗毒；编号116组加全抗；编号115组加法力；编号101组加防御；编号108组加耐力；编号109组按百分比加耐力；编号122组增加凹槽；编号141组增加投掷物数量；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第三系是技能前缀有1个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号125小组：加人物技能；加亚马逊单系技能；加野蛮人单系技能；加圣骑士单系技能；加死灵法师单系技能；加法师单系技能；加德鲁伊单系技能；加刺客单系技能；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n后缀共分为四个系35个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第一系是进攻型后缀共计16小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号15组加最小伤害值；编号14组加最大伤害值；编号10组加冰伤害；编号12组加火伤害；编号13组加电伤害；编号16组加毒伤害；编号27组偷取生命；编号28组偷取法力；编号24组；编号20组阻止怪物；编号4组忽略目标防御；编号7组加攻击速度；编号9组加施法速度；编号21组加额外金币；编号22组加mf；编号25组同时加照亮范围和准确；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第二系是防御型后缀共计11小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号1组物理伤害减少；编号2组魔法伤害减少；编号29组减少中毒时间；编号11组冰冻时间减半；编号35组加快速奔跑；编号18组加快速打击恢复；编号8组加格挡；编号6组反弹伤害；编号39组投掷物恢复数量；编号37组装备自动修复；编号39组永不磨损"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第三系是技能后缀有1个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号44组：加亚马逊单个技能(包括聚气)；加野蛮人单个技能(包括聚气)；加德鲁伊单个技能(包括聚气)；加死灵法师单个技能(包括聚气)；加圣骑士单个技能(包括聚气)；加法师单个技能(包括聚气)；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n第四系是属性后缀共计7个小组："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n编号31组加力量；编号17组加敏捷；编号23组加能量；编号41组按等级加法力、按等级加生命或按等级同时加法力和生命(仅限蓝色装备)；编号26组加生命；编号19组自动恢复生命；编号30组减需求；"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"当装备从怪物身上掉落时，或是当人物离开城镇导致商店里的商品更新时，或是当人物把物品从商人那里买下来时，或是当你用赫拉迪克方块合成新的物品时，物品的属性就在那一瞬间随机生成了。生成时系统将会随机挑选一些词缀安排给这个物品，于是物品就有了变化莫测的属性"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"取最高 qlvl or ilvl 为X 当｛ X < (99-Q/2) ｝时，则该物品是低等物品,词缀等级（A）按照  { A = X - Q/2 } 计算词缀等级。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767006000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子：我有一件地狱A1冰冷之原掉的装备，由于它是68场景等级（M），所以怪物是68-71级之间，掉落的装备就是68级-71级物等。比如按最低的68白怪掉的一个战帽，他的品质等级（Q）是34级，那么，带入公式 68 < [ (99-34/2) = 82 ]，满足公式一。词缀等级按照 {A= 68 - 34/2 = 51}计算，他的词缀就是51级。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当｛ X > (99-Q/2) ｝时则是高等物品 按照 {A=2*X-99} 计算词缀等级。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767121000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子：超市金怪出了一个君主盾（统盾），85+3，物等（I）88级，大于品质（Q）72级，带入公式 { A=2*88-99 } = 77级词缀等级（A）"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"以上情况之外，还有一种特殊情况，游戏内有7种自带 “魔法等级” （ML）的物品，按照 A= X + ML 计算"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659767156000.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个栗子：3c瘸子掉了一个头环，他的最低物等（I）至少是82级。他的魔法等级是3，那么公式计算，他的词缀等级应该是 A = 82 + 3，85级。那么问题来了，他会鉴定出+2职业技能么？答案是，不能。 因为+2全技能的词缀是90级的。"}]},{"type":"element","tag":"pre","props":{"code":"var x = math.max(qlvl,ilvl);\nfloat result;\n\nif(mlvl == 0)\n{\n    if( x > 99-(qlvl/2))\n    {\n        result = 2*x - 99; \n    }\n    else\n    {\n        result = x - qlvl/2\n    }\n}\nelse\n{\n    result = x +i.mlvl;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var x = math.max(qlvl,ilvl);\nfloat result;\n\nif(mlvl == 0)\n{\n    if( x > 99-(qlvl/2))\n    {\n        result = 2*x - 99; \n    }\n    else\n    {\n        result = x - qlvl/2\n    }\n}\nelse\n{\n    result = x +i.mlvl;\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"品质等级"},"children":[{"type":"text","value":"品质等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"品质等级（qlvl）："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"每个装备固有的一个品质等级"}]},{"type":"text","value":"，对于非绿色非暗金装备，qlvl和其底材一样，比如一件执政官铠甲，无论是蓝色还是黄色，其qlvl都是84。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"品质等级是玩家无法左右的，但是需要了解。因为它会与财宝等级（TC）一起决定掉落的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"品质等级决定具体是哪件装备（是镰刀还是执政官甲）；"}]}]},{"type":"element","tag":"h3","props":{"id":"财富等级"},"children":[{"type":"text","value":"财富等级"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"财宝等级决定物品的品质等级"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"怪物是否能掉落对应装备必须满足两个条件："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"怪物的“财宝等级”（TC）大于或等于装备所在的“财宝等级”（TC），"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"同时怪物自身的等级要大于或等于装备自身的“品质等级”（qlvl）。"}]}]},{"type":"element","tag":"h3","props":{"id":"底材"},"children":[{"type":"text","value":"底材"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我们要提前介绍“底材”这个概念。其实在之前的内容已经提到过很多次“底材”，不过基本上都局限于制作符文之语的白色物品。但严格地说，“底材”实际上是所有魔法装备的衍生基础。你可以简单地理解为，一件白色的“军帽”经过“上色”变成了带有1-2条额外属性的蓝色“军帽”，或者经过另一种“上色”就变成了暗金物品“谐角之冠”，但他们的底材都是“军帽”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而底材也分为了普通级、扩展级和精英级三类，三类底材拥有同样的模型，后一级比前一级的基础属性更高，“军帽”就属于“精英级”底材："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1635230129413.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同一底材的暗金/绿色物品还会有自己的专属qlvl，一般叫做“成品qlvl”，如果我们打到了一个白色“军帽”，那它的qlvl显然就是58，而暗金军帽“谐角之冠”还会有自己专属的成品qlvl：69(见上上图的左下角)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2022-08-05-dia2/1659770992000.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"掉落机制"},"children":[{"type":"text","value":"掉落机制"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"怪物会掉落特定的物品么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不,不过金色怪物和头目会有更高的概率掉落魔法物品,头目会掉落魔法物品或更多的黄金.不过,怪物的种类与掉落的物品没有关系."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"人物的等级与掉落的物品有关么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不,掉落的物品只与怪物等级与场景等级有关."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"锁住的箱子会掉更好的东西么?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不,但它会掉出更多的东西,一般来说是没上锁的两倍."}]},{"type":"element","tag":"h4","props":{"id":"掉落过程"},"children":[{"type":"text","value":"掉落过程"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"底材判定过程（TC判定过程）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n怪物的TC值代表了怪物能掉落的物品底材的最高Qlvl。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n☆也就是说，当怪物TC ≥ 物品底材Qlvl时，则怪物能掉落该物品底材。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"成色判定过程（Mlvl判定过程）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n确定了物品的底材后，系统将按照暗金 - 绿色 - 黄色 - 蓝色 - 白色的顺序来判定成色。当判定为暗金或者绿色时，系统会检查怪物等级是否满足物品的成品Qlvl。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n如果物品成色被判定为暗金，而怪物等级Mlvl不足以掉落该物品的暗金形态或者该物品暗金形态不存在，则会掉落该物品的黄色形态并拥有3倍的耐久度；如果物品成色被判定为绿色，而怪物等级Mlvl不足以掉落该物品的绿色形态或者该物品绿色形态不存在，则会掉落该物品的蓝色形态并拥有2倍的耐久度。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"☆ 也就是说，当怪物等级Qlvl≥物品成品Qlvl时，怪物才能掉落该物品的暗金/绿色形态。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n☆ MF值会分别增加暗金、绿色、黄色、蓝色判定的几率，但不影响超强、普通、劣质的判定。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们回过头来看看“谐角之冠”的掉落过程："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1、击杀怪物A，假设它的财宝等级(TC)为59，怪物等级(mlvl)为65，那么就可以掉落qlvl为58的底材“军帽”(因为此时TC>底材qlvl)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2、MF值开始介入(在这之前TC表还有一系列的pick过程，较为复杂，暂不介绍)，游戏进入“暗金 - 绿色 - 黄色 - 蓝色 - 白色”的掉落判定顺序，假设此时可以掉落该底材的暗金品质装备“谐角之冠”，但是由于怪物等级mlvl 65<“谐角之冠”的成品qlvl 69，则无法掉落，改为掉落黄色品质的“军帽”，且具有3倍耐久度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3、如果怪物B的TC为57，那么根本不会掉落底材“军帽”，后续的“上色”流程无从谈起。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4、如果怪物C的TC为67，mlvl为70，其余流程与前面一致，那么可以成功掉落“谐角之冠”。(因为TC>底材qlvl，可以进入掉落判定阶段，当判定为“谐角之冠”时，检查怪物mlvl>“谐角之冠”的成品qlvl，符合要求)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前面已经提到过，MF只和“上色”有关，无法影响装备的品质等级qlvl，所以就算是把MF堆到10000，你在普通难度下也无法获得“统治者大盾”。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"怪物等级","depth":2,"text":"怪物等级","children":[{"id":"怪物的分类","depth":3,"text":"怪物的分类"},{"id":"财宝阶层","depth":3,"text":"财宝阶层"}]},{"id":"掉落规则","depth":2,"text":"掉落规则","children":[{"id":"物品等级","depth":3,"text":"物品等级"},{"id":"词缀等级","depth":3,"text":"词缀等级"},{"id":"品质等级","depth":3,"text":"品质等级"},{"id":"财富等级","depth":3,"text":"财富等级"},{"id":"底材","depth":3,"text":"底材"},{"id":"掉落机制","depth":3,"text":"掉落机制"}]}]}},"_type":"markdown","_id":"content:game:2022-08-05-dia2.md","_source":"content","_file":"game/2022-08-05-dia2.md","_extension":"md","date":"2022-08-05"},{"_path":"/game/2022-08-03-ecs","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"ecs中实体创建方法","description":"代码中创建实体,然后绑定view在link的时候,创建相关实体SpaceWaterList.cs中,这种注意创建的实体和parent没有关系..如果是在land中,需要在销毁land的时候,同时销毁该实体.则不能使用该方法..public void Link(World world, Entity entity, params object[] list)\n{\n    for (int i = 0; i < this.Spawners.Count; i++)\n    {\n        var waterEntity = world.EntityManager.CreateEntity();\n","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"代码中创建实体然后绑定view"},"children":[{"type":"text","value":"代码中创建实体,然后绑定view"}]},{"type":"element","tag":"h2","props":{"id":"在link的时候创建相关实体"},"children":[{"type":"text","value":"在link的时候,创建相关实体"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SpaceWaterList.cs中,这种注意创建的实体和parent没有关系..如果是在land中,需要在销毁land的时候,同时销毁该实体.则不能使用该方法.."}]}]},{"type":"element","tag":"pre","props":{"code":"public void Link(World world, Entity entity, params object[] list)\n{\n    for (int i = 0; i < this.Spawners.Count; i++)\n    {\n        var waterEntity = world.EntityManager.CreateEntity();\n\n        world.EntityManager.AddComponentObject(waterEntity,this.Spawners[i]); \n\n        this.Spawners[i].gameObject.Link(world, waterEntity, entity);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Link(World world, Entity entity, params object[] list)\n{\n    for (int i = 0; i < this.Spawners.Count; i++)\n    {\n        var waterEntity = world.EntityManager.CreateEntity();\n\n        world.EntityManager.AddComponentObject(waterEntity,this.Spawners[i]); \n\n        this.Spawners[i].gameObject.Link(world, waterEntity, entity);\n    }\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SpaceNPCList.cs中,通过ConverEntitys.ConvertGameObejct对游戏对象进行转换..注意其上的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConvertToEntity"}]},{"type":"text","value":"组件转换目标设置为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"none"}]},{"type":"text","value":" ,在这里"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SpawnerAuthoring"}]},{"type":"text","value":" 可以继承"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DeclareParentBehaviour"}]},{"type":"text","value":" 就可以设置parent."}]}]},{"type":"element","tag":"pre","props":{"code":"    public List<SpawnerAuthoring> Spawners = new List<SpawnerAuthoring>();\n    \n    public void Link(World world, Entity entity, params object[] list)\n    {\n        foreach (var item in this.Spawners)\n        {\n            ConverEntitys.ConvertGameObejct(world, item.gameObject, entity);\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public List<SpawnerAuthoring> Spawners = new List<SpawnerAuthoring>();\n    \n    public void Link(World world, Entity entity, params object[] list)\n    {\n        foreach (var item in this.Spawners)\n        {\n            ConverEntitys.ConvertGameObejct(world, item.gameObject, entity);\n        }\n    }\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"代码中创建实体然后绑定view","depth":2,"text":"代码中创建实体,然后绑定view"},{"id":"在link的时候创建相关实体","depth":2,"text":"在link的时候,创建相关实体"}]}},"_type":"markdown","_id":"content:game:2022-08-03-ecs.md","_source":"content","_file":"game/2022-08-03-ecs.md","_extension":"md","date":"2022-08-03"},{"_path":"/game/2022-03-16-gyj-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"苟与剑中的单位生成方式","description":"npc生成方式默认的npc会存储必要数据,比如状态,位置等MapNPCSystem中从npcproxy加载数据,位置一般是固定的,从land中读取运行时的npc会存储MapNPCSystem中从npcproxy加载数据,根据land或者house,随机位置怪物不存储加载land后,则会转换SpawnerAuthoring进行转换生成的点,然后进行生成只运行AI的npcNPCProxy初始化的时候加载,影响局势的(君主,帮派)和与角色由关系的npc处理ai事件.如果进入地图.则实例化场景资源会存储SurvivalStorageSystem创建的时候,则会根据地图id从map_id.bin中加载数","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"npc生成方式"},"children":[{"type":"text","value":"npc生成方式"}]},{"type":"element","tag":"h3","props":{"id":"默认的npc"},"children":[{"type":"text","value":"默认的npc"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储必要数据,比如状态,位置等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MapNPCSystem"}]},{"type":"text","value":"中从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npcproxy"}]},{"type":"text","value":"加载数据,位置一般是固定的,从land中读取"}]}]},{"type":"element","tag":"h3","props":{"id":"运行时的npc"},"children":[{"type":"text","value":"运行时的npc"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MapNPCSystem"}]},{"type":"text","value":"中从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"npcproxy"}]},{"type":"text","value":"加载数据,根据land或者house,随机位置"}]}]},{"type":"element","tag":"h3","props":{"id":"怪物"},"children":[{"type":"text","value":"怪物"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加载land后,则会转换"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SpawnerAuthoring"}]},{"type":"text","value":"进行转换生成的点,然后进行生成"}]}]},{"type":"element","tag":"h3","props":{"id":"只运行ai的npc"},"children":[{"type":"text","value":"只运行AI的npc"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NPCProxy"}]},{"type":"text","value":"初始化的时候加载,影响局势的(君主,帮派)和与角色由关系的npc"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"处理ai事件.如果进入地图.则实例化"}]}]},{"type":"element","tag":"h2","props":{"id":"场景资源"},"children":[{"type":"text","value":"场景资源"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SurvivalStorageSystem"}]},{"type":"text","value":"创建的时候,则会根据地图id从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"map_id.bin"}]},{"type":"text","value":"中加载数据"}]}]},{"type":"element","tag":"h2","props":{"id":"用户物品"},"children":[{"type":"text","value":"用户物品"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会存储"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SurvivalStorageSystem"}]},{"type":"text","value":"创建的时候,则会根据地图id从CharacterSpaceProxy中加载用户数据"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"npc生成方式","depth":2,"text":"npc生成方式","children":[{"id":"默认的npc","depth":3,"text":"默认的npc"},{"id":"运行时的npc","depth":3,"text":"运行时的npc"},{"id":"怪物","depth":3,"text":"怪物"},{"id":"只运行ai的npc","depth":3,"text":"只运行AI的npc"}]},{"id":"场景资源","depth":2,"text":"场景资源"},{"id":"用户物品","depth":2,"text":"用户物品"}]}},"_type":"markdown","_id":"content:game:2022-03-16-gyj-map.md","_source":"content","_file":"game/2022-03-16-gyj-map.md","_extension":"md","date":"2022-03-16"},{"_path":"/game/2022-02-19-quest-machine","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"quest machine 使用相关","description":"autostart  自动开始信息offer 发放任务时显示的信息states   任务开始时,结束时等各种状态时显示的信息..设置状态时执行其中的actionlist ,nodes  会有各个节点,他也会有各种显示的信息,会同states中的信息一起显示到各个位置Counter  定义计数的方式和存储计数的值,  但是不定义任务的目标值,目标值在节点中定义npc任务指示的显示?进入地图后.拉取该地图所有npc的任务然后实例化任务则进行开始检查是否自动开始?如果条件满足直接触发任务,添加到玩家任务列表,或者发送邮件提示之类的是否有接取条件,如果有的话检查是否变成可接状态QuestIndicat","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"autostart  自动开始信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"offer 发放任务时显示的信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"states   任务开始时,结束时等各种状态时显示的信息..设置状态时执行其中的actionlist ,"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"nodes  会有各个节点,他也会有各种显示的信息,会同states中的信息一起显示到各个位置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Counter  定义计数的方式和存储计数的值,  但是不定义任务的目标值,目标值在节点中定义"}]}]},{"type":"element","tag":"h4","props":{"id":"npc任务指示的显示"},"children":[{"type":"text","value":"npc任务指示的显示?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"进入地图后.拉取该地图所有npc的任务"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后实例化任务"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"则进行开始检查"},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否自动开始?如果条件满足直接触发任务,添加到玩家任务列表,或者发送邮件提示之类的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否有接取条件,如果有的话检查是否变成可接状态"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"QuestIndicatorManager不是单例相当于控制器.每个npc身上都有,主要是控制npc的指示显示"}]},{"type":"element","tag":"h2","props":{"id":"任务接受流程"},"children":[{"type":"text","value":"任务接受流程"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"组件Targetable中执行Interact(),会触发QuestGiver.StartDialogueWithPlayer"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"打开对话框"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"QuestGiver.GiveQuestToQuester"}]},{"type":"element","tag":"h2","props":{"id":"任务分类"},"children":[{"type":"text","value":"任务分类"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MoveTo型任务（移动）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"触发剧情"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"新功能开放"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Farm型任务（重复）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"杀狼,动物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"搜集特殊物品,怪物掉落或者采集物品的时候偶尔采集到"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"木材采集,钓鱼,制作料理"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"地图内找寻物品,地图内传话,送礼物,酒"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"追杀人物(地图内,地图外)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"杀人(地图内,地图外)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"镖局任务,跨地图送货,送信"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Collect型任务（收集）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"收集包(星露谷)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"图书馆(星露谷)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"藏经阁"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt型任务（狩猎）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Boss"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Puzzle型任务（解谜）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Challenge型任务（挑战）"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"暗黑3 大秘境 xxx层"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"附加类：Storytelling型任务（叙事）"}]}]}]},{"type":"element","tag":"h2","props":{"id":"显示"},"children":[{"type":"text","value":"显示"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对话"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一条随机话语"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有任务,任务按钮"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有对话,显示对话按钮"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"更多"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"任务接受流程","depth":2,"text":"任务接受流程"},{"id":"任务分类","depth":2,"text":"任务分类"},{"id":"显示","depth":2,"text":"显示"}]}},"_type":"markdown","_id":"content:game:2022-02-19-quest-machine.md","_source":"content","_file":"game/2022-02-19-quest-machine.md","_extension":"md","date":"2022-02-19"},{"_path":"/game/2021-12-21-gyj-skill","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"苟与剑游戏技能分析","description":"释放前检查Tag常用tag写死,比如眩晕等自定义tag,通过判断AscHasAllTags 和AscHasNoneTags 技能是否能够执行检查释放消耗检查冷却时间检查其他自定义条件是否装备指定武器是否变身是否隐身释放后激活阶段animalAction(角色动画)waitAction(等待动作)释放阶段触发释放特效前摇执行阶段释放project其他爆炸物的释放完成阶段后摇角色动画攻击动作投射物子弹弹幕攻击特效其他动作角色动作等待时间\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技能说明动作跳跃攻击跳跃离开危险或跳入战斗之中跳跃动画,并且使用抛物线落到指定点的一个特殊动作旋风旋转的死亡之舞","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"释放前"},"children":[{"type":"text","value":"释放前"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查Tag"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"常用tag写死,比如眩晕等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"自定义tag,通过判断"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AscHasAllTags"}]},{"type":"text","value":" 和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AscHasNoneTags"}]},{"type":"text","value":" 技能是否能够执行"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查释放消耗"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查冷却时间"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查其他自定义条件"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否装备指定武器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否变身"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是否隐身"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"释放后"},"children":[{"type":"text","value":"释放后"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"激活阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"animalAction(角色动画)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"waitAction(等待动作)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"释放阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"触发释放特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"前摇"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"释放project"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其他爆炸物的释放"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"完成阶段"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"后摇角色动画"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"攻击动作"},"children":[{"type":"text","value":"攻击动作"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"投射物"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子弹"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"弹幕攻击"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"特效"}]}]},{"type":"element","tag":"h3","props":{"id":"其他动作"},"children":[{"type":"text","value":"其他动作"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色动作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"等待时间"}]}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"动作"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"跳跃攻击"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"跳跃离开危险或跳入战斗之中"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"跳跃动画,并且使用抛物线落到指定点的一个特殊动作"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"旋风"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"旋转的死亡之舞挥砍所有在旋转路径上的敌人"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"旋转动画并且移动的一个特殊动作"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"双手挥击"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"当装备两把武器时可在一次攻击中击中两个敌人或者攻击一个敌人两次"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"检查附近敌人是否多个,是多个则击中两个,不然击中一个两次.特殊动作"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"特效"},"children":[{"type":"text","value":"特效"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"释放特效(不需要碰撞触发的特效)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"全体加血"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤怪物"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"击中特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"击杀特效"}]}]},{"type":"element","tag":"h3","props":{"id":"特效动作"},"children":[{"type":"text","value":"特效动作"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"伤害"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"伤害类型 毒,冰冻,火焰"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"自己附加状态 附加属性(力量,智力),附加伤害,附加伤害百分比,附加暴击等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"敌人附加状态 扣除属性等"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤object"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"召唤物的属性"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"案例"},"children":[{"type":"text","value":"案例"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"特效1"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"特效2"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"重击"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"强力打击增加造成的伤害并震退敌人"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"伤害特效(附加伤害,附加伤害百分比)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"击退特效"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"击晕"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"成功的攻击将使敌人晕眩并提高你的命中率"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"普通伤害"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"击晕特效,有一定的时间"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"狂暴"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"威力强大但不计后果的攻击可以增加伤害和命中率但忽视防御"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"伤害特效(提高属性)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"降低自身防御为0有一定的时间"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"大叫"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"警告队友迫近的危险并提升他们的防御力"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"增加防御 有一定的时间"}]},{"type":"element","tag":"td","props":{},"children":[]}]}]}]},{"type":"element","tag":"h3","props":{"id":"技能词条skillterm"},"children":[{"type":"text","value":"技能词条(skillterm)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"技能根据等级分为入门,小成,大成,巅峰,圆满,每个等级可以解锁额外的词条"}]},{"type":"element","tag":"h2","props":{"id":"tag"},"children":[{"type":"text","value":"TAG"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个特效可以授予角色tag"}]},{"type":"element","tag":"h2","props":{"id":"武器技能"},"children":[{"type":"text","value":"武器技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了解决攻击使用什么技能,且装备的打造问题..武器可有技能\n武器决定了有哪些技能,比如火系弓箭技能..\n武器没有等级概念???"}]},{"type":"element","tag":"h2","props":{"id":"如果不同的职业技能都能升级到20级那就没有职业差异化了儒家也可用20级道家的技能这样是不对的"},"children":[{"type":"text","value":"如果不同的职业技能都能升级到20级.那就没有职业差异化了,儒家,也可用20级道家的技能.这样是不对的"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"方法一,等级提升添加境界限制.."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"方法二, 技能书分为初级,中级,上级,顶级..然后境界限制学习的条件..书的等级限制能炼到的等级  ...略麻烦"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"升级可以解锁"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一条额外属性..."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个招式"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"洗练可以修改额外属性.以及招式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将qe的提示改成左右键,并去除????"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"/images/2021-12-21-gyj-skill/2021-12-23-19-03-23%E6%89%93%E5%88%86%E6%89%93%E6%9B%B4%E4%BA%BA%E5%93%81%E7%BA%A7.jpg"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"释放前","depth":2,"text":"释放前"},{"id":"释放后","depth":2,"text":"释放后","children":[{"id":"攻击动作","depth":3,"text":"攻击动作"},{"id":"其他动作","depth":3,"text":"其他动作"}]},{"id":"特效","depth":2,"text":"特效","children":[{"id":"特效动作","depth":3,"text":"特效动作"},{"id":"案例","depth":3,"text":"案例"},{"id":"技能词条skillterm","depth":3,"text":"技能词条(skillterm)"}]},{"id":"tag","depth":2,"text":"TAG"},{"id":"武器技能","depth":2,"text":"武器技能"},{"id":"如果不同的职业技能都能升级到20级那就没有职业差异化了儒家也可用20级道家的技能这样是不对的","depth":2,"text":"如果不同的职业技能都能升级到20级.那就没有职业差异化了,儒家,也可用20级道家的技能.这样是不对的"}]}},"_type":"markdown","_id":"content:game:2021-12-21-gyj-skill.md","_source":"content","_file":"game/2021-12-21-gyj-skill.md","_extension":"md","date":"2021-12-21"},{"_path":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"unity gameplay ability源代码解析","description":"github仓库 : https://github.com/sjai013/unity-gameplay-ability-system","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"github仓库 : "},{"type":"element","tag":"a","props":{"href":"https://github.com/sjai013/unity-gameplay-ability-system","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/sjai013/unity-gameplay-ability-system"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个开源系统主要包含了以下内容"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Attribute System  属性系统."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Gameplay Tags  tag用来判断技能是否能够释放,以及检查effect是否能够添加"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Gameplay Effects  技能特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ability 技能"}]}]},{"type":"element","tag":"h2","props":{"id":"特效"},"children":[{"type":"text","value":"特效"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GameplayEffectSpec 是特效的runtime"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包含了特效的双方和target"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包含了其他数据等级,持续时间等"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建方法"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AbilitySystemCharacter.MakeOutgoingSpec"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameplayEffectSpec.CreateNew"}]}]}]},{"type":"element","tag":"h3","props":{"id":"添加特效到角色"},"children":[{"type":"text","value":"添加特效到角色"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"检查特效tag是否能够添加到角色身上"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List<GameplayTagScriptableObject>();\nfor (var i = 0; i < AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List<GameplayTagScriptableObject>();\nfor (var i = 0; i < AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n"}]}]},{"type":"element","tag":"h3","props":{"id":"特效gameplayeffectscriptableobject本身"},"children":[{"type":"text","value":"特效"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameplayEffectScriptableObject"}]},{"type":"text","value":"本身"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameplayEffectDefinitionContainer  定义了特效的使用效果与条件"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DurationPolicy和DurationModifier和DurationMultiplier构成了该特效的持续时间,以及是否立即使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DurationModifier.CalculateMagnitude(this).GetValueOrDefault() *.DurationMultiplier"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modifiers 该特效对属性的修改"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ConditionalGameplayEffects  暂时没看到使用的地方??"}]}]}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"   public struct GameplayEffectDefinitionContainer\n    {\n        /// <summary>\n        /// 持续方案,,是立即,还是持续\n        /// </summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// <summary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// </summary>\n        public float DurationMultiplier;\n\n\n        /// <summary>\n        /// 该特效对属性的修改\n        /// </summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// <summary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// </summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   public struct GameplayEffectDefinitionContainer\n    {\n        /// <summary>\n        /// 持续方案,,是立即,还是持续\n        /// </summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// <summary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// </summary>\n        public float DurationMultiplier;\n\n\n        /// <summary>\n        /// 该特效对属性的修改\n        /// </summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// <summary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// </summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameplayEffectTags   定义处理特效之间的关系"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"   public struct GameplayEffectTags\n   {\n        /// <summary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// </summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// <summary>\n        /// effect添加到人身上前,需要检查的条件\n        /// </summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   public struct GameplayEffectTags\n   {\n        /// <summary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// </summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// <summary>\n        /// effect添加到人身上前,需要检查的条件\n        /// </summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"技能"},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AbstractAbilitySpec是技能的runtime,包含了"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ability的scriptobject"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ability的其他数据例如等级,词条等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色字段"}]}]},{"type":"element","tag":"h3","props":{"id":"技能释放流程"},"children":[{"type":"text","value":"技能释放流程"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ability的cost和cooldown都使用了GameplayEffectScriptableObject,这也是这个系统比较蛋疼的地方,就是每个ability都需要建立cost和cooldown的object."}]},{"type":"element","tag":"h3","props":{"id":"检查cost"},"children":[{"type":"text","value":"检查cost"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查cost特效身上的Modifiers字段,并计算最终值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后和角色属性进行对比"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modifiers可以有多条,且有计算公式"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i < geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue < 0) return false;\n\n        }\n        return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i < geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue < 0) return false;\n\n        }\n        return true;\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"检查cooldow"},"children":[{"type":"text","value":"检查cooldow"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"冷却时间特效最终会被添加到人物的身上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"该函数,主要是比对并找到人身上同tag的特效.然后检查该特效的TotalDuration"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i < this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag < grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag < cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i < this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag < grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag < cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"检查abilitytags"},"children":[{"type":"text","value":"检查abilitytags"}]},{"type":"element","tag":"h4","props":{"id":"abilitytags"},"children":[{"type":"text","value":"abilitytags"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义了一些tag用来释放前进行检查是否能释放该技能"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"例如检查自身是否能够匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OwnerTags"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果是指定目标则检查目标身上是否能够匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TargetTags"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SourceTags?暂时没有好的理解"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"[Serializable]\npublic struct AbilityTags\n{\n    /// <summary>\n    /// This tag describes the Gameplay Ability\n    /// </summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// <summary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// <summary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// <summary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Serializable]\npublic struct AbilityTags\n{\n    /// <summary>\n    /// This tag describes the Gameplay Ability\n    /// </summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// <summary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// <summary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// <summary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"checkgameplaytags被定义在每个ability下然后对其重写"},"children":[{"type":"text","value":"CheckGameplayTags()被定义在每个ability下然后对其重写"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AscHasAllTags  用来检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RequireTags"}]},{"type":"text","value":" ,检查人身上特效的tags是否包含这些,如果没有包含则检查失败"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AscHasNoneTags 用来检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IgnoreTags"}]},{"type":"text","value":" ,检查人身上特效的tags是否包含这些,如果包含则检查失败"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"特效","depth":2,"text":"特效","children":[{"id":"添加特效到角色","depth":3,"text":"添加特效到角色"},{"id":"特效gameplayeffectscriptableobject本身","depth":3,"text":"特效GameplayEffectScriptableObject本身"}]},{"id":"技能","depth":2,"text":"技能","children":[{"id":"技能释放流程","depth":3,"text":"技能释放流程"},{"id":"检查cost","depth":3,"text":"检查cost"},{"id":"检查cooldow","depth":3,"text":"检查cooldow"},{"id":"检查abilitytags","depth":3,"text":"检查abilitytags"}]}]}},"_type":"markdown","_id":"content:game:2021-12-14-untiy-gameplay-ablility-sourcecode.md","_source":"content","_file":"game/2021-12-14-untiy-gameplay-ablility-sourcecode.md","_extension":"md","date":"2021-12-14"},{"_path":"/game/2021-08-05-game-task-design","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"游戏人物设计","description":"前言我知道没人爱看理论文章。可偶尔也得定期坐下来写点枯燥的设计理论文章，以防本旗舰彻底变成一个专业游戏评论博客。虽然我在写评论的时候从来都是本着“写评论是为了写设计要点”的方针，但是这事情干多了，还是不免会陷入就事论事的陷阱之中。也经常会有人问“FNV和F1、F2的任务系统不是一样的吗”这种问题，有时候也还是应该总结一下，写点理论文章。整理一下工作文档，再定期写一些抽象的文字对自己是有好处的。任务的概念与发展简史：从具体，到抽象，再到具体“老僧三十年前未参禅时，见山是山，见水是水。及至拿来，亲见知识，有个入处，见山不是山，见水不是水。而今得个休歇处，依前见山只是山，见水只是水。”——《五灯会元","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"前言"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我知道没人爱看理论文章。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可偶尔也得定期坐下来写点枯燥的设计理论文章，以防本旗舰彻底变成一个专业游戏评论博客。虽然我在写评论的时候从来都是本着“写评论是为了写设计要点”的方针，但是这事情干多了，还是不免会陷入就事论事的陷阱之中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也经常会有人问“FNV和F1、F2的任务系统不是一样的吗”这种问题，有时候也还是应该总结一下，写点理论文章。整理一下工作文档，再定期写一些抽象的文字对自己是有好处的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"任务的概念与发展简史：从具体，到抽象，再到具体"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"“老僧三十年前未参禅时，见山是山，见水是水。及至拿来，亲见知识，有个入处，见山不是山，见水不是水。而今得个休歇处，依前见山只是山，见水只是水。”"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"——《五灯会元》卷十七《青原惟信禅师》"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"任务是什么？"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不管你是玩家还是设计者，你可能都没有仔细考虑过这个问题。\n任务似乎是那种“慢慢浸透了整个行业”的设计要素，我们甚至找不到游戏中任务系统的第一个发明人。\n但当你看到任务的时候，你就会认出它们。\n任务就是魔兽世界里面那些头顶着问号和感叹号的家伙们。\n任务就是使命召唤里面那些不停在屏幕一侧刷新的作战目标和前进方向。\n任务就是360的成就和PS3的奖杯列表里面密密麻麻令人眼晕的文字。\n任务就是网络游戏里在左下角刷个不停的的游戏活动提示。\n总之，任务就是游戏的时候告诉你“你现在应该去干什么”的那些系统，这些任务完成以后，你通常会得到对应的报酬。把用户需要的帮助、行为和报酬打个包，就能得到一个任务；接着，设计师就可以往任务里面插进各种各样的其他要素。\n“看，我这里有胡萝卜。你干完什么什么就肯定能得到胡萝卜哦！”\n这个设计的思路实在太过简单，但当我们回过头来看，却发现这个设计已经统治了整个行业。从FPS到RPG，甚至手机游戏和网页游戏，到处都充斥着任务和类任务系统的身影。\n因为任务实在是太好用了。它就是游戏行业对所谓的“叙事五要素”的综合解答。\n我们都知道，不管是小说、电影还是电视，都有五个经典的问题：时间、地点、人物、事件、原因，也就是When、Where、Whom、What、Why。对于游戏行业来说，这五个问题却没有这么简单。\n你用文字表述？玩家根本不看。你用其他表达方式表述？这些解决方案又没有通用性。\n而在一个任务之中，这些问题同时都会被展示出来。\n你能不能做这个任务？你应该去什么地方？你为什么要做这个任务，能得到什么东西？任务要怎么完成？用户现在到底应该做什么，怎么做？\n设计师总归要把这些东西告诉用户的，而任务是个比其他展示形式更为完善的解答。\n玩家需要的东西，帮助、行动和报酬，只要打开任务列表就一目了然了。\n所以现代游戏里到处都是任务、成就和目标，而游戏用户也飞快接受了它们。\n那些从不玩游戏的人看到现代的大型游戏，经常会问类似这样的问题：“这个角色光这么跑来跑去/打打杀杀是要干什么呢？”\n自从有了任务，这种问题总算也能回答了。\n但是——\n为什么我们的现代游戏中有这么多无聊的任务呢？为什么我们都讨厌Farm呢？为什么有的游戏任务好，有的游戏任务就差呢？要怎么做才能做出更好玩的任务呢？\n这都不是简单地把帮助、行动和报酬打个包就能解决的问题。肯定还有什么比“把帮助、行动和报酬打包”更根本的东西，存在在任务之中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"思想的起源"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也许任务最早的思想源头来自现实。\n如果说是现实中的“任务”概念，历史倒是很明确的。那些管理学大师们主张把工作分拆成一个又一个独立的模块，每个模块自然由许多任务组成。把这些任务分解到人头上，就是成功的管理了。\n但这种官僚而枯燥的管理方式，显然不应该是任务设计的起源。\n你们有谁觉得拿到每周工作任务表的时候觉得特高兴特好玩么？没有吧？\n你们会因为工作任务特复杂特有挑战性觉得充满了乐趣么？不会吧？\n明明工作也有行动啊。明明工作完了也能得到报酬啊。\n为什么工作就不好玩呢？\n但是在游戏里接到一排复杂的任务的时候，我们就会觉得好玩。\n应该这么说，游戏任务设计借鉴了管理学上的模型，但是其发展自有其源流，可谓殊途同归。\n所以，我们还是要沿着游戏本身的发展脉络，回溯到“任务”是隐含条件的古早时代中去。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"见山是山：没有任务的时代"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"早期的游戏当然没有任务，这似乎是个不容置疑的事实。\n最早的游戏，不管是太空侵略者还是Pong，包括Atari上那些东西，都只是光点、线段和色块，连显示文字的能力都不太有，自然没有任务的空间。\n超级玛丽的屏幕左上角不会有个对话框，告诉你你还需要踩死3只蘑菇才能获得5个金币的报酬。\n而在勇者斗恶龙里面，国王也只会让你去打倒恶龙，不会告诉你“你打倒恶龙需要屠龙剑，我在小地图上已经把它的位置标出来了，你顺着雷达走去就好”。\n至于游戏的另外来源呢？那些桌面游戏也同样没有任务。\n战棋游戏贡献的核心是数值系统和规则表。桌面角色扮演游戏则带来了迷宫、成长和宏大华丽的叙事。\n不管你是爱玩龙与地下城还是魂斗罗，你都不会见到类似今天主流游戏这样的任务。\n那时候的快乐似乎也很纯粹——\n稍等。\n早期的游戏确实没有任务，但是，这并不代表早期游戏没有“目的”。\n即便机能受到限制，即使整个行业都还出于萌芽期，但是游戏带给人们的快乐其实是没有变化的。\n比如我们玩超级玛丽这样的横板动作游戏，最初始的动力就是“我要打通这一关”。如果换成任务制的语言，就是“你要不停地反复到达屏幕的尽头”，以便看到更多的关卡、敌人和BOSS。\n当然，打通这一关以后，我的目标立刻就会变成“我想打通整个游戏”。那我就需要知道，“杀死库巴大王可以看到一段和公主的动画小电影”，或者“在地下城关卡有隐藏的房间到达就可以跳关”。\n然后，假定我没满足于打通关，还想用尽可能少的命打通关，我就需要想办法利用游戏的系统，比如“吃100个金币奖励一条命”、“吃蘑菇可以变大”、“吃花可以喷火”。这同样可以换成任务制的语言，比如“收集57/100个金币，获得自动复活药”。\n接着呢？我的朋友打得比我还好，他的分数比我更高，我还想打高分。我就必须开始研究杀死什么样的怪物可以获得怎样的分数回报好向他炫耀。那么，“一只乌龟跳一下等于100分”的任务回报也是可行的了。\n你看，如果用现代任务设计中的语言，完全可以把整个超级玛丽的系统都翻译过来。早期游戏没有任务，却并不代表他们没有今天游戏这些任务的要素。他们只是没有使用“任务设计”这种工具而已。如果是RPG类游戏，那就更方便了：不管是魔法门还是勇者斗恶龙，都可以非常容易地把冒险日志和攻略转化成任务化的语言。\n早期游戏的设计师们同样深谙“必须让玩家知道现在他应该要干什么”这个道理。只是在他们的时代中，游戏还是一件很新锐的玩具，并不需要掌握那么多的用户，也不需要努力让所有人都来理解游戏的目的，只要他们自己觉得“展示成这样玩家就能理解了吧”就可以了。\n早期游戏有游戏目的，只是他们还没有任务制来让玩家掌握目的；他们希望玩家自己可以探索出这些目的来。\n他们见山是山，是因为山在那里，而且也只需要接待懂得如何爬山的人就好了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"见山不是山：任务导向勃发的年代"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大概是从90年代中期开始，无论是东方还是西方，无论是家用机还是PC游戏，大家都开始逐渐采用任务设计了。\n任务的出现不是一个一夜之间的事件。现在回头看那个时期的游戏，可以发现有大量的“复合设计”：普通的主线剧情或日志和以列表形式出现的任务同时出现在游戏的系统里。\n玩家可以直接点击任务名获取单个任务的详情，也可以阅读庞大的日志，或者直接冲进游戏的关卡里打打杀杀。如果说上面的说法不太具体，你回忆一下暗黑破坏神（Diablo）或者博得之门（Baldur’s Gate），就能立刻明白“混合”这种说法的含义。日系游戏则更偏爱“列表”式的任务呈现方法，玩家需要到一个统一的“任务中心”去获取和完成任务，这种思路被大规模继承到了后来的网络游戏里，很多网络游戏都把任务设计集中在一点上完成。\n然后，在不知不觉中，游戏中的任务提示越来越明确，任务获得和完成越来越清楚，回报也越来越明显了。不光是角色扮演游戏有了任务和目标，模拟游戏、即时战略游戏、FPS和TPS射击游戏、动作游戏也纷纷从善如流加入了任务和目标。不管哪个游戏，只要打开菜单，总有个地方告诉你“你现在应该去干什么”。\n任务制被大规模采用的主要原因，其实并不是任务制本身有多少优势；而是游戏已经逐渐复杂化了，谁也不敢保证玩家能通过自己的探索就理解游戏所有的设计。\n有很多业内人士指出，那是因为现代游戏发展得太复杂了。他们觉得应该回到游戏的本原去，做些独立游戏，做些大家一看就会玩的东西，才是正确的道路。评论家和华尔街追捧那些独立游戏，追捧各种各样的创意小游戏，对360和PS3上的作品嗤之以鼻。\n真的吗？难道电影业会因为一个长镜头到底无法处理庞大的信息量，就指责说这是电影导演和编剧的错误，他们试图用电影承载太多的内容，所以整个电影业都应该回到用摄影机拍摄一些五分钟短片的年代去，以便可以继续用一个长镜头处理到底？\n显然不是。\n任务是一种如此好用的特殊语言，5分钟就能教会一个从没玩过这个游戏的人这个游戏的规则，并指导着他一步一步把这个游戏打通。\n任务时代的高潮出现在进入21世纪以后，到魔兽世界的时代到达巅峰。\n在魔兽世界和怪物猎人这样的游戏中，所有的设计都被任务统一起来，你不接任务几乎无法进行游戏。不管是叙事、系统还是教学，一切都有相对的任务进行指引。GTA这样的沙盘游戏更是整个就以任务展开剧情，不完成任务连地图都不会开启。\n同样，这个时代的其他游戏也在进行着疯狂的任务化和目标化：每个FPS游戏都有目标列表，多数的关卡都可以选择，就连赛车游戏也充满了限定条件的任务挑战模式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是，并不是任务本身好玩，而是任务想要达成的那些目的好玩。一旦搞错了因果关系，任务设计很容易滑入到“为了任务而任务”的歧途上去。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"见山只是山：重新淡化任务的年代"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把所有东西都任务化没问题吗？不要紧的，没有问题！\n——但就算这么说，在看到伦敦：地狱门里面用程序代码来生成任务的时候，人们心里也会忍不住打鼓吧。\n任务的泛滥很快就产生了一些负面效果。\n在任务列表把所有游戏内容都规范化、标准化的同时，“乏味”这个魔鬼也开始进入了这个系统。当我们看到任务列表越来越长，而每个任务的格式也越来越相似的时候，忍不住就有了“这是工作”的错觉。一旦玩家有了“这是工作”的错觉，他们就会抛弃这些设计。\n尤其是在某些网络游戏和纯任务制游戏中，这种乏味的感觉到达了顶峰。\n我就不多举例子了，但是你们每个人脑海中肯定都有一大排无聊到爆的纯任务制游戏和网络游戏列表。\n在这样的游戏中，典型的任务就是“打死多少个某种怪”、“打死多少个某种怪然后从他们身上拿回掉落”、“打死某种怪的BOSS”，然后如此重复循环。如果游戏的怪物设计有点特色还好，如果所有的怪物只有数值不同，打通这种游戏简直是折磨。\n这种游戏多了当然会产生反弹。\n在发售日期距离现在更近的游戏中，我们已经不太经常看到“任务中心”或者“关卡列表”这种东西了；取而代之的是重新复活的“发现设计目标”模式。\n很多任务是通过提示出现的。如果玩家没有完成过某个特定操作，或者没有发现线索，这个任务就不会在任务列表里出现。就算是魔兽世界式的问号、感叹号这样的明显提示，设计师在后来的版本中也在努力增加着任务本身的变化性，把任务获得、推进、完成的方法变得更为多样。\n与其说是“淡化”任务，不如说是大家对任务制设计的理解已经更加精进，更加娴熟。\nFNV就是一个好例子：虽然基本的设计元素仍然是那些任务，但是任务的变化已经更为多样，入口、出口和完成方式也更加变化多端。现代FPS/TPS游戏也不再像以前那么强调关卡和目标的概念，而更喜欢用类似成就的被动处理方法来提示玩家正确的玩法。\n同样，类任务设计也大行其道。在网络游戏里面，厂商们已经忍不住把任务从策划手里拿了出来，改名叫作“活动”、“每日”和“运镖”之类五花八门的名目。XBOX360的成就和PS3的奖杯只是换了个名字，两者其实也是明显的类任务设计。就连往常应该毫无“任务”可言的对战FPS/TPS游戏，也忍不住加入了升级、连杀奖励、称号这样的类任务系统，鼓励大家带着目的去打每一盘对战。\n总之，任务还是任务，在设计师的脑海和他们的工作文档中，大概还是这么组织的；只是，他们正在努力让用户看不到那个乏味的大任务列表。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"回到概念"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正如上面的简史所说，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"任务是一个被完全“凭空创造”出来的概念"}]},{"type":"text","value":"。\n就如电影和电视中的“镜头”，或者戏剧创作中的“幕”和“场”，是创造者为了创作方便，也为了观众接受方便而创作的概念。\n也就是说，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"“任务”无论对故事、对可玩性还是对互动来说，其实都是不必要的"}]},{"type":"text","value":"。\n导演用自然的一个长镜头到底，理论上也能拍电影——他们要真这么干了还能成为大师。当然，你做一个没有任务的游戏成不了大师。\n但是，人类和动物的区别就在于我们可以使用工具。“任务”正是我们这个行业所创造出来的最犀利的工具之一，这种设计理念甚至已经不仅仅限于游戏之中了，渗透到了现代社会的许多角落中去。\n顺便说一句，要知道我们游戏行业已经创造了多少超乎常理的设计概念了？去看看刚刚出了DVDRIP的电影《Scott.Pilgrim.Vs.The.World》吧。对游戏没有了解的人不可能知道为什么群众给这片子在IMDB上投了8.0分的。\n一个好的游戏设计师，应当在心中时刻有着“任务”的概念；但是他不应当被任务的固有概念所束缚。\n当他需要剧情的时候，他应该能够把各种各样的剧情和故事熟练拆解成各种所需要的任务形式，并分配下去；当他需要游戏性的时候，他也应当能够将这种游戏性所需要的所有知识和操作，分散在不同的任务和目标之中。\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让玩家每时每刻都知道他应当去做什么，这就是整个任务设计的核心。"}]},{"type":"text","value":"\n事情的关键并不是设计任务。\n你不应该为了设计任务而设计任务。\n那些充斥在三流游戏中的草率任务，正是在这种“我们需要500个任务”的粗暴指示下产生的。\n在如今的时代，如果一个任务只是因为“我需要填满任务列表”而存在，那这个任务就应该毫不犹豫地被删除。\n作为一个游戏设计师，你应该要保证："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"你所设计的每一个任务，都有明确的设计目的。因为任务只是表象，设计目的才是真正的血肉。"}]},{"type":"text","value":"\n哪怕是最不起眼的“去杀10条狼”的Farm任务，实际上也是可以有设计目的的。我将在接下来的“任务的设计方法”一节中深入这个问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"照例，我知道你们都不爱看的枯燥无聊的理论文章……第二部分。说真的我没想到这个命题竟然能扯出这么多，写起来收不住了……所以这篇只是设计方法的（上）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"工具箱"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任务设计的方法说简单很简单，就是对各种设计手法的灵活使用。说复杂也复杂，因为任务的种类实在是多种多样。一个像魔兽世界这样庞大的游戏起码能分类出几十种不同的任务形式，如果细化到设计师们交给程序的需求列表这种程度，这个数字肯定会增加到三位数或者四位数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要把多种多样的设计目的、游戏内容和故事情节分解成任务的形式，你必须先对任务这个工具箱本身了若指掌。那些大号的电钻和锤子要放在最下面，钳子和螺丝刀在中层，螺母和螺钉装在顶层的塑料袋里。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，在正式进入主题之前，我先说一下这个工具箱的各层结构。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要解决的第一个问题是“这是个什么样的任务”，由设计目的决定的是任务的执行方式。我这个任务是要用来指引用户呢，满足用户的收集欲望呢，提供一种全新的游戏内容呢，还是方便关卡制作呢？从这个角度去思考任务的执行方式，就能把纷繁复杂的任务形式梳理清楚。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来的问题是“用户怎么获得这个任务”，由展示方法决定的是任务的逻辑结构。怎么把一个任务呈现给用户？把怎样的任务呈现给什么类型的用户？怎么给用户提供对一个任务的期待？在逻辑结构层来解决。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后的一个问题是“各种各样的任务怎么管理”，由管理方法决定的是任务的分层模型；对玩家来说，这个分层模型也同时决定了他所看到的界面组织形式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从这里再前进一步就是“任务相关的制作资源怎么管理”，这个说起来就太枯燥乏味了，我这篇文章可能不会提到。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后一步是“预先告知用户任务回报”，这是个博大精深的话题，就算谈到我也只会是泛泛而谈。如果真要深入论述，恐怕得等到这架"},{"type":"element","tag":"a","props":{"href":"https://necromanov.wordpress.com/","rel":["nofollow"]},"children":[{"type":"text","value":"战略航空军的旗舰"}]},{"type":"text","value":"上出现一篇叫“游戏数值设计”的理论性文章以后了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些设计工具出现的时间有早有晚，有些仍然在发展中，有些工具已经产生了各种各样的变体。但是无论出现早晚，每种工具都有其优势和劣势。考虑到这是个进步非常迅速变化也非常快的领域，如果读者有什么意见也请自由发表。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"执行方式：从设计目的出发"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任务的执行方式设计是现代游戏设计中最多变，也是最需要创造力的范畴。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在执行方式这节中，我不打算像那些典型的“游戏教学书籍”那样用庞大枯燥的列表淹没你们——看那些“玩法教学书籍”是绝对学不会怎么设计的。同样，我也不需要重复一遍各种流行游戏中的任务设计，鹦鹉学舌的文章没有任何意义可言。与其有空看这种无意义的文章，还不如随便装个游戏抓紧时间打一打。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我会从“任务的设计目的”入手，从设计者和玩家两方面的动机出发把任务分成六个大类以及一个灵活的附加类。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MoveTo型任务（移动）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Farm型任务（重复）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Collect型任务（收集）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt型任务（狩猎）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Puzzle型任务（解谜）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Challenge型任务（挑战）"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"附加类：Storytelling型任务（叙事）"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于我国是游戏设计后发国家，有些设计概念用中文表述可能不是太清晰，所有的类型都带个英文命名……总之你们知道Farm任务指代的是“重复作业”而不是“种田”就好了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"MoveTo型任务（移动任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"人类是这样一种生物：他们声称自己喜欢自由。但对大多数人来说，如果真的把自由的选择权给了他们，他们就会不知所措。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，1990年的每个游戏中，都有庞大的地下城和分支对话。2010年的绝大多数游戏中，你只需要跟着任务黄点的指示，从一个黄点跑到下一个黄点。这是一个有点冷酷的事实，多数人并不是真的喜欢自由，或者喜欢选择——他们只是装作喜欢而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以我们必须要给这些人设计MoveTo型任务。别给他们选择权，直接告诉他们现在应该去哪里吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MoveTo型任务是所有任务形式中最原始的一个，它的目的就是让玩家移动，或者说“跑路”。不管是魔戒的“到魔多去销毁戒指”还是西游记的“到西天去取经”，都是典型的Moveto任务。超级玛莉要从左到右突破所有关卡，雪人兄弟不往上冲就会被拖死，几乎所有FPS都要奔向一个又一个Checkpoint，这些也都是Moveto任务。从广义上来讲，甚至那些指示玩家如何按键移动人物、如何使用鼠标/手柄的教学目标都是Moveto类别的一种。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它的设计目的也非常显而易见：指引玩家行动，展示游戏内容。这个目的类型几乎和整个游戏史一样久远：既然你设计了游戏，当然要告诉玩家里面有些什么吧！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对玩家来说，完成MoveTo任务的目的是看到更多的没有看过的新内容；对设计者来说，MoveTo任务的目的除了展示玩家没有看过的新鲜设计内容之外，还要起到控制任务复杂度、关卡和脚本位置、Debug等等设计各种规范化的重要作用。在完成一个MoveTo任务之后，我们几乎可以笃定玩家必定在某个位置——这实在是太适合作为一段脚本的开头了。同样，对测试和Debug人员来说，移动任务也起到了重要的降低工作复杂度的作用——几乎是各种类沙盘游戏中唯一一个能起到该作用的设计手段。你不知道玩家什么时候去打哪里的怪，你也不知道玩家会怎么理解一个谜题，但是一个移动任务的结束地点肯定是个固定点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“这不都是废话吗！”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"肯定有好多读者要这么说了吧……且慢，且慢。从这个简单的事实陈述里面，能够导出一个很重要的问题，我把这个事实陈述换种说法看看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“如果玩家跟着这种任务移动到了新地点，却没有新的游戏内容呢？”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你看到问题所在了。设计师设计Moveto任务除了指引之外，还有一个规范任务行动区间的作用；而玩家则不能理解这种作用，他们会觉得一段看不到任何内容的纯跑路是非常无聊枯燥的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"事实也是如此。偶尔做一两个还好，如果连续几个任务都是纯跑路，路上没有任何游戏内容，哪怕报酬再好，玩家也是很烦躁的。从根本的设计目的上来说，跑路任务就不应该是用来消耗玩家时间的。成天让他在毫无内容变化的地方跑来跑去，不枯燥才怪呢！你能怪玩家想要自动跑路吗？你能怪他想要传送系统吗？显然不能。这甚至不能用回报来加以平衡；毕竟跑路的过程中，玩家什么也没干。你可以偶尔给玩家大笔的横财，但你不能老给他横财，长此以往必将吊起玩家的口味，让你想给他真正的回报的时候也没得可给。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从这个简单的陈述中，我们可以推论出现代MoveTo任务设计的指导思想：“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"如果玩家不能看到任何新内容，就不要让他去做一个MoveTo任务"}]},{"type":"text","value":"”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用设计目的这个标准来看，许多传统的任务设计方式都是有问题的。比如说，一个任务做完了以后，为什么一定要跑路回去交？如果没有任何新内容或者下阶段展开的话，有必要吗？一个关系到多个相关NPC的连续任务，需要让玩家跑来跑去吗？有没有什么代替方法？如果还不行，那么你就需要给玩家提供方便的移动方式：载具、出租车、自动跑路、瞬间移动，什么都行。这不是“现代浮躁的玩家不懂得游戏性”，而是“你根本没有给玩家提供任何游戏性”，这两者之间的区别是显而易见的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而这条规则当然也可以反过来用：“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在有重要的新游戏内容的情况下，你必须用Moveto任务来保证这些内容不被玩家错过"}]},{"type":"text","value":"”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这类情况下，MoveTo类型的任务则是绝对必要的，不能完全被方便移动方式所代替。最典型的用法，就如同介绍一个大型新场景给玩家的时候，最好能用MoveTo任务把你这个场景的各个设计要点交待清楚。一座主城需要让玩家了解各个功能区；一个副本需要让玩家了解各个关键设计所在；哪怕是一段大型的即时电影演出，玩家也需要观摩电影的指引。在这些情况下，不要用快速移动方式代替你的MoveTo任务；在可能的情况下，甚至可以限制玩家移动来保证BUG数量能够得到控制。回去交任务也并不是都是没有用的操作，有些时候交任务本身可能也是一个设计要点，这个例子就比如荒野大镖客RDR里面回家那一段的杰出演出。我们不应该对“快速移动”或者“自动跑路”这样的设计要素一棍子打死，而应该区分对待。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那如果设计师一定要插入一段内容不太丰富的MoveTo任务呢？倒也不是不能设计，只要你改换一下任务的类型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我可以提供这么几个任务设计的例子。在通常的设计方法中，这些都被归类于不同的任务类别，甚至不同的游戏性；但如果从设计目的考虑，你会发现他们本质上都是MovTo类的任务。跑到某个地方采集一组药草，安装一个炸弹，拉动一个开关什么的，本质上有区别吗？其实没有。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师有一段路必需要求玩家跑两遍->在这两遍路上产生不同的、无法跳过的敌人。用不同的敌人来制造差异性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师有一个大关卡必须要求玩家先到最里面然后再出来->在进去的时候是一个MoveTo任务，在脱出的时候是一个强制推进的MoveTo型任务，可能是有时间限制、炸弹、毒气、洪水，总之你自己去想吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师希望控制玩家特定的移动路径，或者交待重要的NPC剧情/性格->把MoveTo任务改写成一个护送任务，这是MoveTo任务的一个子类型。让NPC沿着事先设好的固定点移动，同时控制玩家不能离开NPC过远。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师不在乎玩家怎么移动，但希望玩家看到这个区域内所有的重要点->把MoveTo任务改写成一个多段的物品收集/地点到达任务。设定几个操作点，让玩家去完成特定的操作，同时完成区域的交待工作。这种任务虽然以收集、解谜甚至Farm的形式出现，但本质上还是MoveTo型任务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师有一个复杂的关卡，但他希望玩家能按顺序完成这个关卡->把一个单一目标的MoveTo任务改写成一个连续而拥有多段目标的MoveTo任务。拆开路点，让用户每时每刻都有个短路点等在前面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以从这个基础上发挥你的设计能力和创造力，继续改善你的设计。关键仍然是设计目的，只要不是拖延游戏时间，玩家就不会讨厌MoveTo任务。难道有人会讨厌看激烈的大场面？那还玩什么游戏啊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上，不管是出于叙事考虑、设计考虑还是测试考虑，几乎每个任务的第一步都会是一个MoveTo型任务，这也是我把这个类别放在第一位的原因。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Farm型任务（重复任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计师不应该用MoveTo任务来拖延游戏时间。那他们应该用什么工具呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然是Farm任务。我说的不是种田，Farm在这里也不当种田讲（虽然在目前最流行的开心农场和Farmville里，他们的“Farm任务”真的是在种田……但理论还是应该更普适一点）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那Farm任务到底是什么呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务的历史同样非常久远，可以追溯到游戏的史前期，甚至比Moveto类型还要早。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们总是说“打怪练功”、“打怪练功”。早在卷轴滚动技术出现之前，人们就开始玩各种只有一个固定画面的游戏，并且在这个固定的画面上用几个像素点对抗另外一些几个像素点组成的太空侵略者们。然后他们开始玩各种动作游戏，这些游戏的主题仍然是打怪（或者被怪打，总之还是有怪的）。然后是射击游戏，还是打怪。然后是角色扮演游戏，这次不光是打怪，还有升级……总之，光一个打怪就能覆盖80%的游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，打怪能得到什么呢？对这个问题的思考产生了Farm任务。一开始设计师们只是简单地计算分数，鼓励玩家的虚荣心；但这种行为很快就不够了，玩家们需要更明确的回报，设计师们就开始在游戏里加入什么奖命啊、奖励武器啊之类的新花样。终于，那些RPG设计师们把这些东西包装成了标准范式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随着设计师们在“打怪”和“练功”两者之间建立了明确的关系，Farm任务也由此产生。通常认为，只要在这两者之间建立联系的任务，就是Farm任务。所有那些让你去杀7只鸡15头猪20个兽人45个德国佬然后给你金币银币美刀钞票的任务，也全都是Farm任务。如果在广义上放宽到“所有需要反复熟练操作的游戏”，那Farm任务几乎能覆盖100%的类型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么这么命名呢？理由也很简单。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"种田有什么特点？主要就是两条，第一条是“田每年都要种，反反复复的种”，第二条是“种瓜得瓜，种豆得豆”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务有什么特点？同样是两条，第一条是“重复进行一样的工作”（打怪为主），第二条是“你费了多少力和时间，就有多少回报”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说，Farm任务的核心就是“重复”和“回报”。只要把握住这个核心要点，你就能轻易地识别出各种各样的Farm任务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而这些就是设计师们赖以拖延游戏时间的神兵利器。从一开始，就算没有Farm任务，游戏也很好玩，人们也要趴在电视/电脑/手机前面玩太空侵略者，超级玛丽，勇者斗恶龙，使命召唤和愤怒的小鸟。加上回报以后，群众不就会想要“多打一个任务”，“再多打一个任务”了吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多完美啊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好，那么我们现在知道了设计师侧的设计目的是“拖延时间”。那么玩家呢？对玩家来说，“重复”除了拖延时间之外还有什么用处？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个也再明显不过了——有个成语叫“熟能生巧”。人们为何要不停玩一样的游戏呢？自然是因为他们越玩越好啊。游戏技巧的提高本身，就已经是一件非常强力的武器了，足以拉着一部分人在游戏面前反复尝试。如果这种技巧的提高还伴随着各种游戏数值的提高，他们就更忍不住了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他们提高技巧，开启新内容，挑战新内容，再提高技巧，如此反复。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就是说，Farm任务的设计目的也分两个方面：设计师想用这种设计拖延用户的游戏时间，把他们拴在自己的游戏上；另一方面是用户，他们希望通过这些Farm任务熟悉游戏和熟练操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看起来真是太完美了。设计师们拖延了时间，用户自己也乐意，大家还有额外回报。加个没啥实际用途的升级槽，玩家就该高兴死了吧？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么……喜欢反复完成“干掉15头迅猛龙/干掉15头老虎/干掉15头豹子”这类任务的人请举手。有人吗？喂，举手啊？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好吧，为什么现在的Farm任务越设计越烦人了呢？明明是这么一个你情我愿的设计模式啊。它怎么就越做越无聊了呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务之所以能击中大量玩家心中的软肋，其原因和种田一样：“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"付出总有回报"}]},{"type":"text","value":"”。付出努力，收获与之相应的回报，永远是最令人兴奋的YY故事主线。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务比现实有一个最大的优点：游戏里的回报从不赖账。现实是难以预测的，谋事在人，成事在天；游戏则是个非常公平的裁判。在完成了Farm任务以后，玩家可以得到非常确实的回报，系统绝不会贪污，不会打官腔，也不会踢皮球，该升级升级，该捞钱捞钱。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种回报有一种短暂而强烈的上瘾性，几乎我们每个人都体会过那种看着回报一次次增加或者角色一次次成长的兴奋感，脑内的兴奋物质——大概是内啡肽吧，如果不是请纠正——大量分泌。如果你不太玩游戏，那么就想象看着自己投资的股票市值不停上升的景象吧，带来的快感和上瘾性有其相似之处。对于初次接触游戏的人，这种上瘾性尤其可怕——在现实中可能一辈子也获得不了的成就感和安全感，在游戏里只用几天就能满足了。所以那些第一次玩网络游戏的人纷纷沉迷，办公室里的白领们忙着偷菜，Facebook上的洋人们在Farmville面前纷纷垂首……谁也不是内啡肽的对手。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但如果你想做一个真正了不起的游戏，你就不能过于依赖这种廉价的Farm成瘾性，它更不该是你作为一个游戏设计师的唯一依赖。把猴子关在笼子里，他每次去拿同样的香蕉都会感到兴奋，用户可不会……好吧，至少有很大一部分用户会逐渐产生抗药性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"确实，有些人会一直满足于这种成瘾性，但也有很多人不会。对游戏了解不多的人往往对这种上瘾性大惊失色，从而对此口诛笔伐，指责电子海洛因；一些对游戏浅尝辄止的轻度用户体验过上瘾性后对它产生了抗体，却会觉得“游戏什么的不过如此大同小异”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说实话，连猴子都能抄来一个Farm-升级系统，还要游戏设计师干什么？那可不是你的本事，而是用户大脑中内啡肽的本事啊。集中36只猴子，里面肯定有一只能押中轮盘赌的数字；如果你只是简单地做了打怪升级的Farm任务，那就意味着你和猴子一样，完全把运气寄托在用户身上，希望他们中的绝大多数人都还没对这种兴奋物质分泌模式产生抗性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你觉得这样就够了，当然也可以。最近的一只猴子公司估值都有51亿美元了，可以得很呢……但既然这是一篇设计理论文章，就该写出点儿比猴子转轮盘赌更多的东西来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那除了“重复”和“回报”以外，玩家还想要什么？再想想之前那句话，“熟能生巧”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"没错，他们还要技能的提高。如果有技能的提高，没有回报他们都一遍遍玩游戏。让我们再看看前面那几个Farm任务。猎龙，猎虎，猎豹。玩家完成这几个任务之后，技术提高了吗？对游戏内容更熟悉了吗？除了那点银币和经验他们得到别的了吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在你该知道这几个Farm任务的问题出在哪里了吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然是重复一样枯燥乏味的操作，技术不仅得不到任何提高，就算提高了也没用的话，就别怨用户上外挂啊！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Farm任务要做好，关键问题并不是你这个Farm任务本身的文本或者程序脚本写出高潮来，而是你这个游戏打怪部分本身必须有趣，而且有深度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"深度可以分成两个方面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"玩家的技术可以提高"}]},{"type":"text","value":"。这里有好多个方面可以提高，他的角色数值可以提高；他本人的操作能力可以提高；他对游戏的知识也可以提高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"这个提高必须有用，而且总是有用"}]},{"type":"text","value":"。这一点总是被很多设计师忽略，所以我想强调一下。如果提高知识对游戏进程/游戏效率并无影响的话，那它就不是一个提高；数值和操作能力也是一样的。如果提高造成的效果近乎可以忽略——干掉这个设计要素。反正你不干掉它玩家也不会在乎，谁在意我杀一个怪是用4.8秒还是4.6秒？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要做到这两点，你设计的游戏毫无疑问会拥有一张“成长阶梯表”，这是一件比猴子画的升级槽复杂而有趣得多的东西。你的游戏有多少种怪物，这些怪物有多少相关知识，玩家要消灭这些怪物需要多少操作能力和角色数值，和他们对应的有多少Farm任务，这些Farm任务完成以后能获得多少种不同的回报……等等等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在这些Farm任务就是有明确设计目的了：它们就是引导玩家通向这张成长表的桥梁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要保证玩家能提高技能，而且这些技能对他进一步玩游戏有帮助，Farm任务就没有问题。甚至都不用Farm任务的额外奖励，玩家们自己都会去找最有效率的打怪升级方式；如果游戏设计能做到这个方式随着“成长阶梯表”不停变化的话，整个游戏就不会显得那么枯燥乏味。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"游戏设计师们务必要记住，你要在Farm任务中设计的是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一种需要不断“重复”的游戏内容，它应当是经得起不断重复的"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"照例，也有几点补充。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是不是要做出游戏深度，就一定要把Farm任务做得很难或者很复杂？**–>**不一定。单纯地提高难度往往只是增加枯燥而已，单纯地提高操作复杂度肯定只是增加乏味。你只需要保证“相应的难度有相应的回报”就可以了。让没有技能或者厌恶复杂度的玩家接受低风险的回报，让喜欢挑战和提高技能的玩家去面对高风险高回报，别盲目地做那些对深度玩家好玩但是难死庸手的东西。如果要做，给他们相应的高回报，这样也能顺利地把玩家分开档次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是不是能够通过调整随机性来改善Farm任务的重复性？我加点状态变化啦随机怪物啦随机掉落啦什么的怎样？**–>**不是。务必记住，深度只是第二级的目的，在你实现这个目的之前，要先保证第一阶段“付出总有回报”的Farm任务公式没有受到破坏。种田的特点是固定的投入和固定的产出，就算有随机的天灾也应当能够以人力进行应对。不要用你对随机性的偏爱破坏Farm部分，那是另外一个设计目的完全不同的类型任务：Hunt任务的范畴。当然，可以有意外惊喜，也可以有累计奖励，没有玩家讨厌意外惊喜或者累积奖励。但是，别做过分的随机性。Farm的用户最讨厌天灾了。如果非要有天灾，给他们设计对策，掌握对策就能战胜的天灾立刻就变成游戏深度了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一定要做无聊的Farm任务来拖延时间该怎么办？开发周期来不及了呀！**–>**无论如何，加点儿调剂。改变一下回报的种类，把不同的Farm任务明确分开。玩家其实不怕重复做一件事，他们更怕“只能做一件事”，例如最终幻想13里面的刷乌龟……一旦一个游戏只能做一件事，这不仅是玩家不满的源泉，更是对整个游戏制作资源的极大浪费，游戏设计师们应该感到耻辱。所以，在成长阶梯表上，时刻考虑多提供几个不同方向的Farm任务作为选择。甚至，不同的打法给不同的回报。只要你的“付出就有回报”这个原则是确定的，根据完成方法的不同给不同的回报并不会降低Farm本身带来的乐趣。还不行……偶尔插点纯正内啡肽吧。但如果真的要插，这次就千万别给玩家他还要Farm多久的提示了，他爱Farm多久Farm多久——永恒之塔的100遍Farm任务恐怕是游戏设计史上最愚蠢的设计之一了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这次还是两个重要大类……继续继续。常见任务种类这就差不多了，剩下的2+1种其实都是特殊用途了，还得再整理整理思路。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Collect型任务（收集任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说完了MoveTo型的任务和Farm型的任务，接下来可以说点确实没啥内涵的东西了。Collect任务就是任务里最好设计的一类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"几乎每类常见游戏设计都是冲着某一种人性的弱点去的，收集任务也不例外。有人完全不收集任何东西吗？从藏书、集邮、标本制作、奢侈品购买、艺术品收藏一直到首办、变形金刚、网络资源下载狂，一般人总归会忍不住去收集某些自己喜欢的东西。小学生就会本能地收集弹珠啦、烟标啦之类的东西，可见这确实是人类基本的爱好之一。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"收集任务收集的并不一定是装备或者道具；收集装备或者道具的任务，也并不一定是出于收集目的所设计的。比如最简单的“打某种怪随机掉落n个专属物品”这种任务，从形式上来说是收集型任务，本质上却不是。这种任务是Farm型任务的一种变种，用来填千篇一律的Farm型任务表的。类似的，“到若干固定地点取得特定任务物品”也同样不是Collect任务，而是Moveto任务。但如果这种掉落品有其特殊的规律和值得研究的多样性，它却又可以成为收集任务的一部分了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么呢？因为收集任务设计中，最重要的就是“收集欲”。**所有不能激发收集欲望的任务都不是好的收集任务。**人们并不想收集那些完全一样的东西。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说实话，收集欲望这东西本身没啥好说的，几条基本规律开天辟地以来就没改过，而且都是地球人都知道的设计原则，还做不到就是设计师的错了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就像金融衍生品的核心就是“打包与交换”这个概念一样，收集设计的核心就是“标准化与列表化”，把杂乱无章的物品合并，并组织成有逻辑的收集表。把相同的物品组织成收集内容，在内容的基础上产生逻辑，把过大的列表分成多级别的小表。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"收集任务的设计目的就是赤裸裸地利用人类本能的收集欲甚至收集强迫症，来推销设计师们想卖的东西"}]},{"type":"text","value":"，最典型也是最混蛋的设计就是臭名昭著的成就系统。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至于详细的设计要点么，我随便一列，你们也随便一看。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先，容易理解，容易入门。能够大众化的收集爱好通常都入门很容易，在游戏里也不例外。集邮的开始只是几张纪念邮票，钱币的入门也不过是几个平常找零回来的硬币，一个奢侈品狂姑娘的起步可能只是一个三流品牌的包包。好的收集品通常应该在玩家不知不觉间入手，然后给他展开一幅未来的庞大画卷。正面例子我就不多说了，反面例子么，COD7就是一个近在咫尺的例子。我估计肯定有好多用户直到通关也没发现游戏里有情报箱可以收集吧？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后，提示明确。什么东西能收集，收集了有好处，应该有明确的提示。在开放式的沙盘游戏，比如荒野大镖客、辐射这样的作品里，这点特别重要——因为你完全无法控制玩家什么时候拿到什么物品。如果实在不能像FNV一样用游戏内的任务进行提示，用一些超游戏的手段进行提示也是合理的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再次，阶段和收集目标清晰。弹珠为什么只是小孩子的收集品？因为弹珠和弹珠彼此之间的区别实在太小了。收集设计也是同样的道理，每个阶段都要有自己的特色，收集完一定数量以后要立刻给玩家回报，别去搞那些容易令人放弃的“贯穿性收集”。我刚批评过的哥特4就不说了，贯穿整个游戏的多种“漏掉一个就完了”的收集品实在是令人无语。COD7也很令人绝望，如果说有比从头到尾都没发现一个情报箱更惨的事情，那就是打了大半游戏以后才拾取到第一个情报箱……所有不能回去重新收集的收集品，起码应该给一个数量提示吧。就像臭名昭著的金融行业一样，“贪婪”和“恐惧”也是永远的设计主题。人类很难抗拒把已经有相当进程的收集项目收集完的冲动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，留下充足的想象空间。有哪个现实中的收集领域有尽头呢？在一个领域后面接着的是另一个领域，在一个类型后面接着的是另一个类型。每个能够流行开来的收集爱好都有着几乎无穷无尽的深度，游戏用不到做到这种程度，但是相当深度的收集目标也是必要的。已经收集的内容是进一步收集的垫脚石，已经收集到的奖励装备可以通过收集进一步升级，都是提供深度的简单办法。再深入就可以引入类似鉴定、随机属性或者隐藏属性这样的高级收集爱好者才会喜欢的要素，模仿现实收集行业里捡漏和鉴宝的要素。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其他……其他真没什么好写的了。能做到这些，有收集癖的人就会欢欢地去做了；至于没有收集癖的那少数人，还是在收集回报上想办法吧。至于那些连贪婪和恐惧都没有的冷静强者，估计也不会来玩游戏吧？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，我想谈另一个问题：收集设计思路的扩展用法。利用收集癖好本身不算什么了不起的设计，但怎样利用收集癖好来引导用户就是个艺术了。从开放的角度来想，只要能激发用户收集欲，收集的是什么其实无所谓。你到底要在收集任务里推销些什么呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"把眼光放远一点，不要把收集设计仅仅局限在任务上。最传统的想法是收集道具，这当然没有问题；音乐、CG、回想、图鉴这些想法比收集道具前进了一步，但本质上也区别不大。\n最简单的例子是成就。收集成就把收集的领域扩大到了“行为”方面。成就是挑战性设计，但把挑战们打包成一个成就系统，就是典型的收集设计了。这个类型改变的效果是非常明显的，现在几乎每个游戏都在努力做着类似成就的系统，瞄准的就是那些收集型玩家。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关卡同样可以做成一种收集。谁规定所有关卡都要马上开放给玩家的？一点点解锁、凭票制、时间制、积分制都是可以考虑的设计。几乎每个音乐游戏都有用颜色清晰标明的不同难度及其评价，打开这个界面本身就是一种收集性质的激励。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"收集在装备设计中同样有大量应用。最经典的收集装备设计就是魔兽世界的套装……我上面说的入手简单、阶段目标清晰、提示明确、想象空间充足全齐了，可以当作一个经典的收集设计范例。暗黑破坏神的镶嵌是另外一个把收集要素融入到装备系统的好例子。这里值得一提的收集设计是“隐性收集装备”，也就是从数值角度按照套装设计，却并不写明的套装。在收集品过多的情况下，可以考虑用这个思路来设计。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更进一步，制造业还是一种收集。用收集任务的角度来看制造业系统设计，很多问题就迎刃而解了。要怎么安排制造业生产的装备？要如何引导玩家去获得各种不同来源的道具，然后投入制造？要怎么安排制造业的阶梯性？用收集的理念来设计，会比用简单的公式合成或者复杂的真实系制造理念好玩得多。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现阶段能想到的收集设计，个人认为是剧情线索的收集。这是一项真正愿者上钩的收集。那些最好的小说，实际上也是把细节和叙事线索什么的隐藏在字里行间，直到所有线索汇集，才一气呵成讲完所有的故事，塑造出令人印象深刻的人物。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"目前这方面有几个很好的尝试，比如Bioshock系列，通过录音和关卡的完美结合来安排收集性质的线索叙事；FNV在结构上已经是线索收集-任务展开的形式了，可惜的是影响要素还并没有按照收集系统来设计，缺乏了一些形式美感，也不容易让一般玩家领会到那种草蛇灰线伏线千里的气势。在没有任何提示下，有多少人能发现凯撒的死亡竟然会影响好几个八竿子都打不着的遥远任务的展开线索？在叙事领域，目前还没有将线索收集作为核心收集要素的例子，最多也就是Bioshock这样无伤大雅的补充；但我个人觉得，类似作品的出现也不会太远了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt型任务（狩猎任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"自古以来狩猎就是人类的本能，在游戏世界里也不例外。当然，打死那些没啥抵抗能力的家畜不算狩猎，所谓Hunt任务，就是要拿出最好的武器和装备，和相对更强大的敌人进行生死的决斗，并获得惊人的报酬——俗称打BOSS。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果说Farm任务对应的是动作游戏中的杂兵，那么Hunt任务对应的就是动作游戏中的Boss战。\n如果说Farm任务对应的是代表幸福安宁满足感的内啡肽，那么Hunt任务对应的就是亢奋专注快感的多巴胺。\n如果说Farm任务的目的是设计成“普通玩家经过努力后不用脑也可以完成”，那么Hunt任务就应该保证成为“玩家反复磨练技术后得到的报偿”。\nOK，到此为止。理论上是该这么说的啦……实际上不是这么回事。把上面那些基本常识记下来，然后来考虑一下真正的设计目的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设计Hunt任务的目的和考验玩家什么的没有任何关系。你设计首领战不是为了让玩家打不过去，而是为了让他的辛苦练习和成长有用武之地。真正的设计目的是消费。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Hunt任务和BOSS战的设计，对应的是玩家的消费"}]},{"type":"text","value":"（当然还有投资，但这两者在游戏中就和现实经济中一样难以区分）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说，如果说其他类型的任务起到的是积累的作用，那么Hunt任务（当然还有PVP）就要起到消费的作用：在其他内容中取得的技能、等级和消耗品在这里被用掉，并变成玩家们最爱的回报和装备不动产。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个游戏的BOSS战可不是设计到谁都打不过去就是好的。想要做这种内容，去做怒首领蜂好了，听说直到今天在整个世界也只有一个人类可以打败二周目真绯蜂改发狂，而且大家还没有在录像上亲见。你通过传送每小时打败10次巴尔和考验玩家有任何关系么？你集结25个人和一个有钱的老板，去刷一个大副本和考验玩家有任何关系么？什么关系都没有啊。\n无他，唯手熟尔。Farm任务是连外挂也能完成的任务，而Hunt任务就应该是要求操作熟练度和专克外挂的那些内容。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说到这里，最重要的是什么简直呼之欲出。主要有两个问题，门槛和随机性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门槛部分的设计思想很简单，保证用户大多数的资产都能在某个Hunt任务中用上。所有的武器、职业和技能都有优势领域自然最好，大部分有用也很不错。让不同的Hunt任务之间所需要的门槛错开也是很重要的，有些BOSS可能是硬性的数值门槛，有些可能是队伍组成/技能熟练门槛，有些可能是特殊装备门槛、时间门槛甚至用户金钱/资产门槛。不要太轻视这个部分：除了让用户怎么捞以外，让用户捞到的东西有用也是非常重要的。如果条件允许的话，负责设计重要的门槛BOSS的游戏设计师最好同时负责数值或系统的设计，至少也要有项目内数值或系统设计的经验。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说随机性。随机性看起来很简单，但其实也有不少小窍门。核心的指导思想么……我就说的浅白且反动一点了：**距离现实中的赌博（或者彩票）设计越近，那么随机性的设计就越令人舒服。**不算金融衍生品的话，赌博是人类掌握的最有效的财富消灭器，久经考验。如果这个游戏设计的目的是让人反复玩，那么Hunt任务和BOSS设计就要当仁不让，扛起作为赌场的责任来。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最无聊的BOSS就是那种可以按照固定套路简单地对付，但是期望回报还一直非常高的BOSS。买100块随机返回80~120块奖金的彩票会有人爱买吗？一个这种高级BOSS就能毁掉整个游戏，最典型的例子就是FF13，网游里面也有大量“只有一个BOSS有人在刷”的游戏。当一个游戏所有的Hunt部分都变成Farm的时候，这个游戏的生命也就差不多到头了。性质非常类似的糟糕设计是“一切BOSS都可以用同样的招数简单的处理”，这会让玩家觉得不管是熟练操作还是角色成长都没有任何实际意义。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外一种乍看之下很好，其实却很令人烦躁的随机性设计就是所谓“平均化几率”。BOSS确实会很多招数，但他只是每次以相同的概率抽取几个差不多难度的招数。好不容易打倒了某个BOSS，这个BOSS却只会以平均的概率掉落各种相同等级的装备（在魔兽世界的某些BOSS中这种设计特别常见）。平均化随机的问题在于，事实上的回报和给玩家造成的期望不符。比如BOSS掉落三种装备，几率全是1/3。一般玩家自然会想“打三次应该就能都掉出来了吧”，实际上却不是这么回事——大多数时候起码要打4次或者5次才能都掉出来（感兴趣的人可以自己算算，我就不附公式了）。这个心理期望概率和实际概率的误差在重复次数不是太多的时候会非常明显。可以参考一下轮盘的设计：如果回报严格遵循算数平均的话，就应该给不同风险偏好的用户不同的赔率。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从这里再进一步，就是在“玩法的随机性”和“回报的随机性”之间建立逻辑关系。流行的赌博形式可以分为四种：赔率规则非常简单，但是玩法策略充满可控性和对抗性的赌博（例如二十一点和得克萨斯扑克）；赔率规则非常复杂，但是玩法策略非常简单或者完全不可操控的赌博（例如轮盘）；赔率和玩法都非常简单的赌博（例如彩票，老虎机）；赔率和玩法都非常复杂的赌博（例如麻将，赛马）。其中第三种是最有趣的。六合彩本身是一个纯粹随机的游戏，但是由于回报倍率惊人，而且形式十分迷惑人，人们忍不住发展出了众多的“彩票逻辑”。计算数字概率啦，改变投注策略啦，就仿佛六合彩那几个数字和赛马或足球一样是有规律可循的一般……人们是多么热爱虚幻的操控感啊。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么回到随机性设计的问题上来。在目前的BOSS设计中，玩家的行动或行动策略对他所能获得的回报有影响吗？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和赌博一对比，就显示出多数游戏在这方面设计的空白和乏力。暗黑破坏神显然是没有的，魔兽世界也基本是没有的，赌注状态仅有“能打过”和“打不过”两级门槛，用户并不能下更大的赌注，或者提高自己赢得赌注的几率。有些游戏倒是拉开了回报赔率的差距，同样一个BOSS可能掉落等级差距极大的回报，但这个回报赔率的区别并不取决于玩家所做出的赌注决策，只是纯粹碰运气而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"是否可以适当强化不同BOSS之间的赌博公式区别，让不同的BOSS拥有不同的回报赔率，并且这个赔率可以随着玩家的选择而改变呢？有些游戏选择了根据打法改变掉落表，有些游戏则引入了时间和评价之类的其他影响因素，不过在这方面的尝试仍然远远不够。比如，能不能制作一个类似轮盘或者赛马赌票的Hunt任务系统呢？能不能刻意限制玩家打BOSS的次数，让“无限下注赌场”变成“有限下注赌场”呢？顺着“赌场下注”的思路想下去，应该还有更多有趣的想法吧。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Puzzle型任务（解谜任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果这篇文章写作于1990年而不是2010年，肯定会写“Puzzle型任务的设计目的是智力挑战和由此带来的愉悦感”。就像神秘岛里的层层机关，就像国家宝藏里的条条线索，抽丝剥茧到最后揭开所有谜题……多有趣啊。\n就连在大众传媒和一般人的想象中，游戏设计师们干的也应该是类似这样的工作：他们（经常也有她们，通常还是些美妞……可恶，我恨现实）坐在一些塑胶玩具和毛绒玩具中间，对着一些色彩斑斓的电脑屏幕画画图，连连线，就做出来了一些类似愤怒的小鸟和植物大战僵尸的可爱游戏，然后大赚其钱。\n多美好的想象啊。大众传媒还觉得魔兽世界的测试员是世界上最好最有趣的十个工作之一呢……你们敢找个魔兽世界的Tester来么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"遗憾的是，现在是2010年，一个互联网络已经大行其道的年代，所以这一段不会这么写。人类的智力在Google面前实在不值一提，再难的谜题在搜索引擎面前也会被分秒解决。智力挑战？抱歉一般人不喜欢这个。大家能面对的智力挑战到头就是雷顿教授（而且还要查攻略），稍微差点儿就是脑白金，一本字书或者一篇长文能秒掉百分之八十的用户，你还挑战他们的智力？开什么玩笑啊。\n所以，解谜任务在网络时代分出了两条支流。简单的那条支流瞄准的是操作，把“智力”简化成了简单重复操作考验，代表作品就如同脑白金、Puzzle Quest和愤怒的小鸟；难的那条支流则担负着另外一个任务，这类Puzzle型任务的最主要设计目的不是“智力挑战”，而是“用户交流”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先说“操作性谜题”。操作性谜题……本质上不是谜题。它们是一些通过程序生成的小游戏，只是装成谜题的样子而已。\n最低档的操作性谜题就仿佛国内网游非常流行的“每日文化答题”，用户只需要背背题库就好——为了每日领赏，他们也确实对题库倒背如流（我时常想，如果专门开个雅思题库或者GRE题库服务器，没准比新东方教学效果还好呢）。俄罗斯方块衍生系和宝石迷阵衍生系也非常受欢迎，做成和游戏内系统挂钩的或者3D视角的也不算费事（Puzzle Quest就算是个最典型的例子了）。再强一点的放拼字游戏或者数独，虽然抄起来很省心，只要设计师们改头换面一番就能瞬间生成数以千计的谜题表——脑白金是最好的例子了。喜欢动作性的设计师可以像愤怒的小鸟一样照抄某些经典的动作或者解谜游戏设计，反正愤怒的小鸟自己也不过是照抄那些前辈，例如百战天虫什么的（事实上这个抛物线解谜类型久远到电脑都还没出现就已经有了，如果十七世纪会解这种谜题，你就可以在任意一家国家的炮兵中找到一份好工作）。再往上才是“自己设计操作性谜题任务”——虽然大众媒体都吹捧这种做法，但我非常非常不推荐这条道路。一百个放在Appstore或者Xboxlive上的原创小游戏里，起码有九十五个无人问津。一百个放在主流游戏里面的解谜小游戏，起码有九十个是垃圾。劳民伤财呀，何苦呢？\n那么这种谜题任务用来干吗呢？目的也很简单，这大概是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"成本最低的用来调剂节奏和拖延游戏时间的方法"}]},{"type":"text","value":"。设计操作性谜题任务几乎不需要什么游戏设计师，只需要些谜题数据库就能搞定了，而这点努力能换回玩家成千上万的游戏时间。它们也很适合做那些跨等级和横跨整个游戏的固定任务/每日任务，这样设计内容方面就不用操心了，只要简单调整调整题库的难度表和回报比例就成。除了“天才的设计师自己钩钩画画出来”的小游戏之外，剩下的操作性谜题都是久经考验，一般人也都玩得非常好，用户引导方面同样不用费心。\n就只是这样？没错，就只是这样，我想不出有什么更深刻的设计目标了。除了“低成本内容”外，没有其他意义，甭指望用户会因为你做了一个比愤怒的小鸟还好玩还漂亮的小游戏就凑过来，因为他们买的本来就是愤怒的小鸟而不是其他。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说“交流性谜题任务”。交流性谜题的设计目的就是让玩家们在游戏内或者游戏外勾勾搭搭，吵吵嚷嚷，间接"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"提高游戏的黏着度"}]},{"type":"text","value":"。\n最简单的交流性谜题自然是“多人合作”Puzzle任务了。在任务里强制让玩家们协作解除机关就能达成最简单的强制多人合作，再进一步就是让玩家们在战术/移动层上达成配合的解谜任务。玩家们在行动上的配合，或者强制限时推进同样非常好用，可以逼着用户们强化彼此之间的关系等级，构建出一些要求比野队、随机副本或者G团更高的任务内容。\n“寻求帮助”也是一种很好的交流性任务。大多数有任务的游戏，都有不止一种职业，设计师可以通过这种需要其他职业能力的任务来强化沟通。如果把这种任务放大到关卡或者副本的层面上来看，还可以发掘出更多变的用法：例如某个副本，有要求一个五人队伍中有四个战士才能完成的交流性Puzzle任务，也就无形间提供了整个副本的另外一套强制打法。\n再往上一层的目的就是想办法引导玩家去进行游戏外的讨论，这通过普通任务就很难做到了——搜索引擎和教程仍然是无敌的。通常来说，要让一个任务在玩家中造成分歧，用“隐藏”或者“推理”这种寻常手段是没用的，这种手段最多能制造一些“XXX地区还差两个任务没做成就完不成求助”这样的低水平讨论。你必须要做到两点：第一，隐藏一部份数据和逻辑。第二，构造虚假的线索。争论，只有争论才是制造分歧和掩盖谜题真相的最有力武器。构造虚假的线索，隐藏关键的数据，让玩家在他的直觉和逻辑之间产生矛盾。这事儿暴雪干得精熟，Square Enix也不遑多让。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后我还是用实例来说明，说个我所知道的“交流性谜题”（其实不是谜题任务了，但是设计目的差不多）的设计例子吧。你们都知道暗黑破坏神2那臭名昭著的“物品掉落率增加7%护符（俗称SC）”吧？由于可以增加7%的掉落率，所有人都喜欢它。在某大型网络游戏里面，有个类似的设计，某些职业和装备上有个属性叫做“物品掉落率增加”的、看起来就像SC一样非常重要的属性。官方只是草草一说“这个属性可以增加物品的掉落率啊”就结束了，然后几个设计师在非官方的场合透露过“确实是有改变率的啊”。争论由此展开。由于持有技能的职业通常在大Raid中不太重要，有这种属性的装备本身战斗力通常非常低下，那到底要怎么才能最大化利益呢？一个Raid团应该带几个这种掉落率相关群众，又应该怎么围绕它们来安排战术呢？技术党们争论不止，自然想到了测试，结果发现——这个属性的效果是根据目标BOSS和掉落物种类的不同而变化的。对于大多数低等便宜原料来说掉落率常常倍增，但是对于各种装备、高级原料、宝石什么的就很难说了……于是持各种论调的技术党们争辩不止，论坛上定期出现“最新一期掉落率实测结果！推翻传统论调”的月经贴，各国人民组团时左右为难。\n我相信设计师们一定在偷笑吧。例子到此为止——Puzzle任务应该也不用再多说了。想办法创造出新的谜题和话题点，创造更多的争辩和分歧吧。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"只有能产生分歧的问题，才是互联网和搜索引擎无法战胜的内容。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Challenge型任务（挑战任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Challenge型任务的设计目的是“玩家分层”和“虚荣心”。如果说以上前几类任务的最终设计目的都是“让所有用户都能完成”的话，那么挑战型任务设计的目的只有一个："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让绝大多数用户只能部分地完成它"}]},{"type":"text","value":"（注意不是完不成它，一个用户不感兴趣或怎么也完不成的挑战是相当失败的）。“人人都有”的东西大家不太感兴趣，只有“人无我有”才是可恶的虚荣心。\n这个类型任务的设计思路直接继承了原始时代“分数”的设计目标，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让用户分层化"}]},{"type":"text","value":"。人生的目的就是打到最高分，每天的最高分，每周的最高分，每月的最高分，每服务器的最高分，历史的最高分……强者们，高手们，人民币日元美元欧元战士们，你们炫耀的时候到了！\n“挑战么……增加难度不就行了？”\n不要把这事儿想得太容易。没错，难度变化是几乎每个游戏都有的基础。变更数量、变更敌方属性、变更敌方行动规律（玩家管这叫AI，虽然实质上这和AI关系非常小）。同样的内容，改变一下数值和容错率就能提供完全不同的难度，是大家喜闻乐见的挑战自我和挑战他人的形式。这里棘手的问题，主要是怎么把这些难度变化任务展示给一般玩家……大多数游戏的设计是完全失败的，只有少数精英玩家会去挑战高难度。我印象里最成功的设计恐怕还是暴雪的暗黑破坏神，强逼着一般用户去挑战最高难度反复刷刷刷。如果你想让玩家挑战不同难度的相同任务，首先要控制难度种类不超过四种（最多五种吧，再多一般人就直接忽略了），然后是尽量让他们认为这是一次通关顺序上不同的内容——而不是反复进行同样的内容。\n可对精英玩家来说，这是远远不够的。设计师们总在抱怨用户弱智，他们总能发现，用户中最弱的那一部分永远比人类所能想象的程度还要弱。反过来说，用户们最强的那一部分也是强到几乎无止境的。反射神经论毫秒计算的只是基础，高手们的肉眼不光可以分辨单独帧，甚至还能分辨出每个单独帧延迟的时间；你的十个指头每分钟最多输出一百个有意义的操作，有的高手每分钟能输出五百个；你觉得能弹个钢琴已经很了不起了，可用户里多的是有绝对音感加精准操作媲美职业钢琴师的高手；你能在甩狙击枪的过程中命中目标？高手还能用肉眼对抛物线做积分呢。设计师当然要尽全力设计各种各样的高难度内容，这是他们当然的职责。但光靠难度是不够的，谁能斗过无敌的玩家呢？甭管是噩梦还是神级难度都有人无伤通关，设计目标是50分钟的内容可能会被突破到两三分钟，理论上决不可能的精确操作会被打到100%命中，高手的手指和外挂无异。光从难度入手是不够的，还得另想办法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外的办法，就是设计师放弃去挑战玩家，而是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"让玩家挑战自己和其他玩家的极限"}]},{"type":"text","value":"。无论是单机还是网游，都在试图走这个方向，设计那些让强力用户和强力用户自身进行极限挑战的内容。所以，挑战任务设计的核心，其实是“你要让玩家们在什么样的项目上分出高下”。由于挑战本身就是一种快乐，是否要在这里设计对应的回报都存在很大争议——从结果来看，通常有没有回报都可以。有些人喜欢留个象征性的入门回报，有些人喜欢留个分级制但是上不封顶的回报，有些人喜欢留个只给冠军的回报——怎么操作都行的，反正挑战任务的目标是玩家的好胜心和虚荣心；既然是“虚”荣心，当上冠军这件事情本身已经足以让那些高手们手舞足蹈了。除了回报之外，改善挑战任务的组织同样有不错的小说。理论上来说，挑战任务直接散布在整个游戏中是可以的；但像荒野大镖客RDR一样，用一些等级和列表把这些挑战任务组织起来会更好一些。看到100个挑战任务像芝麻一样分布在游戏里会令不少人抓狂；但如果挑战任务的组织结构是4"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"10（容易）、3"}]},{"type":"text","value":"10（普通）、2"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"10（困难）、1"}]},{"type":"text","value":"10（噩梦），那同样数量的挑战任务能让更多的人上钩。\n撇开难度不说，还有几种被广泛使用的低成本Challenge类任务设计手法——呃，我就不提人民币/美元充值榜和道具/装备排行榜了，那些太邪恶了，要用也得想办法立个牌坊再说。PVP要素也不多提了，给一个任务制作协作模式或者对抗模式的成本太高，基本可以视作完全做了个不同的新任务了——八成还得搭做一张新地图什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"精确操作：传统上来说，分数主要就是用来奖励精确操作的——偶尔也用来奖励一下下面说的其他几类挑战任务。千万别设计那种“谁来了都能打满分”的分数统计任务，如果有这种内容，请果断砍掉，没有任何意义。精确操作通常有两种表现形式，一种是“操作得越准越好”，另一种是“操作得不出错就好”，前者考验反应，后者考验意识。这个对非网络游戏来说是非常常用的设计手段，但对网络游戏来说有个棘手的延时问题（同时也衍生出了外挂问题）。选择哪种，只取决于你所需要的游戏类型。前者更适合做分数排行榜，设计毫无失误的连击和目押；后者更适合做网络游戏和各种用来展现神一般的意识和飘忽的操作的内容。\n时间限制和时间统计：时限任务是最最最好做的挑战任务了。甭管什么内容，你都可以加个时间限制在那里，立马就可以开始计时排名。倒数计时可以强化紧张感，顺序计时可以用来做用户水准评价。再弱智的游戏都可以有时间挑战任务，怎么都能加进去的……只是有一个小小的问题，似乎有很大一部分玩家生理上本能讨厌计时。我个人的建议是，尽量少用倒计时，把倒计时任务丢在关键位置和某些可选任务里，不要做全局化的计时任务系统（也就是那种所有任务都自带一个计时器的禁忌设计）。这种东西偶尔有几个可以，走到哪儿都有就会破坏整个游戏的节奏感，还会吓跑患有隐性闹钟恐惧症的玩家。如果打算大量使用时间相关的设计，可以考虑用其他的方式变通处理，例如限定时间的BUFF或者道具，或者用“全世界/全服务器第一个达成某某目标”这样的变通手段来做。\n探索与意外发现：也就是“完成度”，同样是加起来不费什么大事儿的内容。和时间设计正好相反的挑战要素，时间相关挑战对应那些快准狠玩家，完成度相关挑战对应那些细慢精玩家。这个类型的挑战任务倒是不怕多，甚至从某种意义上来说，越多越好，做得越多就能引导玩家看到越多的设计细节——前提是你的游戏有足够的设计细节。击杀一个任务中生成的所有敌人，踹翻所有的生成宝箱，认真看完小电影抓紧时间按掉里面所有QTE，打柴堆一下向下移动三步空挥五刀就能吃到1UP……怎样变态的小知识都可以。暴雪饭们都对WOW“服务器里的树苗会随着版本更新逐渐换成大树”这事情赞不绝口，UO粉们对“因为游戏BUG产生的不同颜色的一般物品”趋之若鹜，玩家们探索设计细节的这个过程本身有时就能构成口碑营销。知道这些没用的小知识也算是炫耀要素之一，是真正爱好者们引以为豪的话题，做点儿东西满足他们的期待也是没错的。完全没有这些小知识的游戏看起来会很粗糙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Storytelling型任务（叙事任务）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"说完了六类主要的设计目的，按以上教程做出来的任务就能好玩，或者令人印象很深刻了么？\n很遗憾，恐怕还是不能。这篇理论文章的目的是把任务做得很舒服，不会有人动辄跳起来骂娘，可不代表这些任务不会无聊。\n设计和艺术是不一样的。因为设计可以很容易地复制，而艺术不能。上面这些并不是什么了不起的东西，只是一篇基础设计常识的实用菜谱。不管怎么无聊的故事线，照着上面这些任务分类去做，至少能把普通的文本转换成看起来不那么单调的任务线，也能保证一般用户都能轻松地接受这些任务。\n但叙事没有这么简单，因为叙事的要求比不无聊要高得多。叙事任务并无其固定的形式。形式并不等于公式，世上有好的食谱和差的食谱，但绝无那种神奇的食谱可以保证你的蛋糕一定美味可口。\n所以，最后一个附加的任务分类就是叙事（Storytelling），探讨一下怎么用讨厌的任务制设计方法来实现电影化或者小说化的叙事。这一部分基本上全是设想了，不像前面六个大类，你们直接去找个“魔兽世界大灾变”来玩就能看到里面很多任务设计思路的具体改进方案。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个问题其实相当为难。大多数时候，任务制就是叙事的天敌。\n任务制天生就适合做短篇小说，它甚至能把很好的长篇故事拆成很多什么都不是的短篇小说和超短篇小说。回想一下你最喜欢的那些电影和小说吧，每个拆成任务制以后似乎都很无聊，连贯的故事变得支离破碎。\n几个还算成功的游戏作品在这些方面的努力看起来也乏善可陈。魔兽世界制作了数以万计的任务和数百万字的任务文本，但能让玩家感到激动地任务怕是连十分之一都没有。侠盗列车手GTA4在单个任务上下的功夫不可谓不深，投入不可谓不多，但大多数任务还是只配被玩家快速地按掉又按掉。辐射新维加斯在任务结构和复杂程度方面的努力创下了角色扮演游戏史上的新高，但这种努力也没有遮掩住主线任务故事的散乱和最终决战的巨大落差。我们手头没什么太成功的例子，只好从那些一闪而过的成功火花里来找灵感。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于游戏来说，叙事三要素的实现顺序和其他媒体是不一样的。我们的叙事三要素按照难度从低往高排，是环境，情节，人物。\n对于一个游戏来说，最容易搞定的就是环境了。环境带来的冲击随时都能看到，而且能够感受到；要塑造一个出色的环境也用不着什么太复杂的技巧：音乐加场景设计就能基本搞定。几乎每个成功的游戏，背后都有一个杰出的世界观。这也是任务设计最容易发挥其威力的地方——所谓世界，原本就是由一个又一个的细节拼成的，任务设计恰恰擅长描述细节。只要隔三差五分配一些任务或目标在世界观塑造上，就能很成功地构造环境。\n情节就相对比较难办了。任务制和情节的抵触看起来十分彻底：谁愿意每次情节发生的时候看到“你的任务已经更新”，然后又要重新跑一大段路？别管设计师或者剧本原来打算搞什么叙事节奏，现在都已经破坏光了。一个恶劣的反面例子就是辐射新维加斯最后的胡佛水坝大战，虽然剧本和线索布置得很充足，但真打到这里的时候就会令人感觉“啊，不过如此……”，一点也没有最终决战应有的节奏。\n我个人的观点，正确的发展方向只能是“"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"关键情节连贯化"}]},{"type":"text","value":"”。当情节上需要进行关键高潮的时候，尽一切可能进行连贯化。任务不用回去交，回报直接打进道具栏，跑路部分使用强制传送，小电影部分用即时互动……把所有的精力集中在叙事进程本身上，能跳的部分毫不犹豫地跳，能省的部分毫不犹豫地省。所有的叙事应当一气呵成，就像电影的高潮部分一样。任务执行本身也应当和叙事结合起来，要把游戏时间、难度，甚至是玩家失败的可能性也考虑进整个叙事流程当中。当然，出于成本和周期考虑，不可能所有任务都这么设计；为了达到这个目的，甚至可以牺牲那些不重要的次要任务的质量，明确地在“主线关键剧情任务”和“环境塑造任务”之间拉开差距。至于网络游戏么……你看，网络游戏本来也是要送新手包诱骗用户去升级的，不是么？既然用户肯定有额外资源，索性都用在这里好了。\n人物是最大的难点。就算是小说，要塑造一个人物形象也是难比登天的事情；更别说游戏了。说实话，我实在想不到什么成功塑造了人物形象的普通游戏例子，偶尔有几个成功的例子，又不太具备普适性，比如Bioshock这样的大成功连他们自己的二代都复制不了。日本游戏曾经倒是有很多成就，但那些成就是FC和PS舞台剧时代的成就，沿用的是戏剧形式的夸张演出，并不是当代的成就，当代的日本游戏人物塑造可以说是普遍失败的（美少女游戏Galgame除外啦……以5pb为代表的角色营销干得还不错)。我们只好从叙事常识角度试着来构思如何在任务中塑造人物了。\n先不说人物曲线什么的劳什子，塑造人物的最基本要求就是“信息量”，光这一点大多数任务制的游戏就保证不了。如果一部电影剧本看到第50页的时候还不知道谁是主角，有几个，这电影剧本肯定会被打回去重写；这样的事偏偏在游戏中反复地发生。不管是魔兽世界、GTA还是荒野大镖客里，主要角色塑造很少有超过十个任务的——区区十个任务！通常来说，不算任务进行过程，这十个任务也只够将就交待一下角色的出身性格什么的，距离有血有肉还差得远呢。想用这种分量的信息量塑造一个了不起的角色，你们需要的不是编剧，是莎士比亚了。要真想通过任务塑造人物，第一件事情就是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"把人物角色相关任务的密度和数量提高"}]},{"type":"text","value":"，把所有能拉到目标角色身上的任务都拉过来，聚集成一条事件线，甚至一个巨大的事件团。\n接着就是所谓的“人物曲线”，一个人物角色的背景、动机、内在目标和性格变化。这个要求就更高了，就算在电影里通常也只是极少数主角能享受的高级待遇。对于游戏来说，这个变化更必须是能在游戏过程中让玩家潜移默化地体会出来的……难上加难。舞台剧式的角色直接转职固然省事，但以叙事手段来说未免落了下乘。用好感度之类的数值来处理人物不同阶段的反应和AI比前者略好，但以这种系统作为游戏内容却显得十分生硬，只有最早期那些“恋爱”游戏才会用这种生硬的系统——别看了，近期游戏里Dragon Age我说的就是你，这种上个世纪的Gameplay你不觉得难受么！如果参照日本galgame脚本的发展过程，比较受欢迎的处理方式其实是“同样的关键任务事件中，不同的角色有不同的反应”，但这个在游戏制作成本上的投入又实在太大了……现代游戏不能光掰对话树啊，也需要有不同的演出甚至具体的不同游戏内容。稍微退让一些的做法可能更有实际可操作性：人物的背景、动机、过去等等都是独立的小型任务或任务细节，关键的“性格变化”和“冲突”两步则和游戏内的大型情节任务挂钩处理，并设计对应的任务体验内容。由于大多数游戏都做得很差，在这方面努力一些，再在关键的体验部分想出个好点子就能令玩家留下深刻印象，典型例子如Bioshock的某角色以及最近COD7的某角色。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"总之，叙事性任务是所有任务类型中最需要灵活想法的一个部分，它是由其他所有类别任务复合而形成的。怎样巧妙地将任务系统的文本和游戏内容勾连成庞大而美妙的叙事体验，更接近艺术而不是技术，我也只能泛泛而谈了。在接下来的逻辑结构一节里，还会继续探讨不同的任务结构形式和玩家体验之间的关系。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"内容为转载，总篇幅较长。原文地址（自备梯子）："}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/11/14/quest-design-01/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(1)：概念与简史"}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/11/23/quest_design_2/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(2)：MoveTo与Farm任务"}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/12/03/quest_design_03/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(3)：Collect与Hunt任务"}]},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//necromanov.wordpress.com/2010/12/14/quest_design_04/","rel":["nofollow"]},"children":[{"type":"text","value":"游戏任务设计(4)：Puzzle、Challenge和任务叙事"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-08-05-game-task-design.md","_source":"content","_file":"game/2021-08-05-game-task-design.md","_extension":"md","date":"2021-08-05"},{"_path":"/game/2021-06-15-rpgbuilder","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"rpgbuild的一些备注","description":"skills   相当于 采矿技能,种植技能 ,制作技能level templates 只是升级属性..比如角色等级,skill等级.weapon等级weapontemplates  相当于拳法精通..斧头精通..枪法精通.棍法精通这些..而且有相关的技能和属性Races  种族,定义了可选职业,以及 weapontemplates  ,以及初始stat等classes  职业定义了stat以及技能树,和魔法书","body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"skills   相当于 采矿技能,种植技能 ,制作技能"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"level templates 只是升级属性..比如角色等级,skill等级.weapon等级"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"weapontemplates  相当于拳法精通..斧头精通..枪法精通.棍法精通这些..而且有相关的技能和属性"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Races  种族,定义了可选职业,以及 weapontemplates  ,以及初始stat等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"classes  职业定义了stat以及技能树,和魔法书"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-06-15-rpgbuilder.md","_source":"content","_file":"game/2021-06-15-rpgbuilder.md","_extension":"md","date":"2021-06-15"},{"_path":"/game/2021-06-12-edgar-code-read","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"Edgar源代码解读","description":"生成类LevelGeneratorBase  最基本的生成方法类包括Generate和GenerateCoroutineDungeonGeneratorBase 一般都会继承于该类Generate流程创建playload,即IPipelineTask的上下文创建pipelineTask,包括三个InputTask,GeneratorTask,PostProcessingTaskPipelineRunner执行管道任务,将playload赋值给各个pipelineTask然后执行pipelinetask的Process()函数pipelineTask你可以继承LevelGeneratorBase","body":{"type":"root","children":[{"type":"element","tag":"h3","props":{"id":"生成类"},"children":[{"type":"text","value":"生成类"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LevelGeneratorBase"}]},{"type":"text","value":"  最基本的生成方法类包括"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Generate"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GenerateCoroutine"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DungeonGeneratorBase"}]},{"type":"text","value":" 一般都会继承于该类"}]}]},{"type":"element","tag":"h4","props":{"id":"generate流程"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Generate"}]},{"type":"text","value":"流程"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建playload,即IPipelineTask的上下文"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"创建pipelineTask,包括三个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InputTask"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratorTask"}]},{"type":"text","value":","},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PostProcessingTask"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PipelineRunner执行管道任务,将playload赋值给各个pipelineTask然后执行pipelinetask的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Process()"}]},{"type":"text","value":"函数"}]}]},{"type":"element","tag":"h4","props":{"id":"pipelinetask"},"children":[{"type":"text","value":"pipelineTask"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以继承"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LevelGeneratorBase"}]},{"type":"text","value":"  然后分别覆盖"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetInputTask()"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetGeneratorTask()"}]},{"type":"text","value":",还有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GetPostProcessingTask()"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"InputTask"}]},{"type":"text","value":"   一般来说是FixedLevelGraphInputTask,主要是用来设置Payload.LevelDescription"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratorTask"}]},{"type":"text","value":"   主要是通过GraphBasedGeneratorGrid2D来设置Payload.GeneratedLevel 和 Payload.GeneratorStats,还有会实例化"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Generated Level/Room template instances"}]},{"type":"text","value":"以及下面的房间,参见"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratorUtils.TransformLayout"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PostProcessingTask"}]},{"type":"text","value":"  主要是根据PriorityCallbacks按照优先顺序执行回调函数,默认的回调函数,通过配置有以下"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"InitializeSharedTilemaps 即实例化"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GeneratedLevel/Tilemaps"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CopyTilesToSharedTilemaps 将rooms下的tile复制到SharedTilemaps 下"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CenterGrid 将Generated Level下的子对象设置为0,0"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DisableRoomTemplatesRenderers    禁用roomtemapltes下的显示"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DisableRoomTemplatesColliders  禁用roomtemplates下的碰撞"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"还可以通过继承DungeonGeneratorPostProcessBase写你自己的后处理函数"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"door-sockets"},"children":[{"type":"text","value":"Door sockets"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"门锁..就是走廊和房间选中同一个锁,就能匹配的上"}]},{"type":"element","tag":"h2","props":{"id":"对于连接处"},"children":[{"type":"text","value":"对于连接处"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他会按照顺序copy到sharedtilemaps.所以,位于连接处的tile,如果后面的会覆盖前面的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210630183742467","src":"/images/2021-06-12-edgar-code-read/image-20210630183742467.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210630183825008","src":"/images/2021-06-12-edgar-code-read/image-20210630183825008.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终的合成则是下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210630183914172","src":"/images/2021-06-12-edgar-code-read/image-20210630183914172.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"生成类","depth":3,"text":"生成类"},{"id":"door-sockets","depth":3,"text":"Door sockets"},{"id":"对于连接处","depth":2,"text":"对于连接处"}]}},"_type":"markdown","_id":"content:game:2021-06-12-edgar-code-read.md","_source":"content","_file":"game/2021-06-12-edgar-code-read.md","_extension":"md","date":"2021-06-12"},{"_path":"/game/2021-01-23-spelunky-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"Spelunky关卡生成","description":"关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"part1-创建solution-path-关卡通路"},"children":[{"type":"text","value":"Part1. 创建Solution path - 关卡通路"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"算法的第一部分是生成关卡的 Critical Path（通路），关卡由 16 个房间按照 4x4 的网格组成。方法是先在第一排随机找到一个起始房间，然后随机使相邻的房间成为通路的一部分，一直到最后一排，生成出口。找到通路之后，连接这些房间，然后再随机补充上非通路部分的房间，打通这些房间。如图顺序所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/spelunky-map-generation-steps.gif"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后为这些房间随机选取对应的预定义好的关卡模块。根据 Spelunky 的教学文章["},{"type":"element","tag":"a","props":{"href":"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/#reference","rel":["nofollow"]},"children":[{"type":"text","value":"3]"}]},{"type":"text","value":"，这里有 4 种不同的房间类型："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530045.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个关卡由16个房间按照4x4的网格方式组成，这里有4种不同的房间类型："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"0：不在critical path上，不会产生任何出口（可被忽略的）次要房间 (感谢洋芋君指出之前的翻译问题)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1：左右一定有出口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2：左右下一定有出口，如果有2号room在上方，也一定有上方出口"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3：左右上一定有出口"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一步在最顶部这行随机选取一格创建一个Start Room，房间类型对开始的房间来说没太大影响。一般来说，Start Room类型我们会选1或者2。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每当一个Room被创建，首先总是类型1(左右)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后要决定往哪边走。取一个均匀分布的随机数，从1到5。当1或2时，critical path向左；当3或4时，critical path向右；当5时，path向下。（当critical path碰到屏幕边缘，立即向下移动并同时切换左右方向。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这有个问题，如果我们向左或右移动，是OK的，因为我们创建的Room是一定有左右出口的。但我们要向下走，我们就得改变我们当前所在的房间了。所以生成器重写房间类型为2，覆盖当前的房间，现在我们可以向下移动了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当生成器移到下一个房间，会问我们最后创建的那个房间（也就是刚才我们头顶上那个）类型是不是2（底部有出口）。 如果是2，那么当前这个房间类型一定要是2或3（上方有出口）。因为2、3类型都有左右出口，启动算法从头再来一次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果到了底部这一行，我们要尝试向下，那肯定不行了，我们放置一个Exit Room来取代向下的房间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们已经生成了整个critical path（关卡通路，即图中那些暗红色的格子，游戏中是不显示的，这里只是为了举例）。接下来要做的最后一件事，我们要把4x4的网格中的空余部分放上类型为0的房间，这些房间并不在critical path上。这些房间在任何方向都不一定有出口，所以有时候会生成一些围墙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一列中有3或者4个Room 0，那这一列房间有几率成为一个蛇窝。如果我们要生成蛇窝的话，从上到下，放一列房间，类型为7 8 9，或者7 8 8 9，取决于我们希望这个蛇窝有多深。(这里的蛇和宝石并不像其他敌人那样随机生成，因为它们是这种地形的一部分，所以位置基本是固定出现。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530075.png_webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"蛇窝"}]}]},{"type":"element","tag":"h1","props":{"id":"part2-创建房间-关卡生成算法的第二部分生成room我们先不考虑那些障碍物陷阱敌人和宝箱什么的"},"children":[{"type":"text","value":"Part2. 创建房间 关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530105.png_webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Spelunky并不像其他大部分游戏（平台游戏，platformer）在传统的2D tile-base的平台游戏中，你用关卡编辑器做出的地图可能看起来像这样："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-23-Spelunky-map/8752-1519530119.png_webp"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种类型编辑器里，是这样的，比如，在（64,128）这个位置是草的tile。但Spelunky完全不是这样。\n上一部分我们了解了Spelunky有4种基本房间类型（types）。这每个房间类型有8-16个模板。这些模板具备一个房间的基本布局，包括一些静态和概率tile的组合。\nRoom Templates（房间模板）\n每个房间类型都有一堆不同的模板。\n"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"译注：Derek Yu使用不同的布局，做了一系列的房间设计。比如你掉出去的房间（DROP）、掉入的房间（LANDING）、可以穿过的走廊（CORRIDOR）、不在关卡通路上的房间（NON-CRITICAL）。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"房间模板，嗯……看起来就像下面这样："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1100000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"40L6000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11P0000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11L0000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"11L5000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1100000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1100000000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1111111111"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个模板由10x8 的tile网格组成。\"0\"表示空，\"1\"表示100%是砖块，\"L\"是梯子，\"P\"是爬梯子上去的平台(platform)。现在你在看这个模板， 嗯，下面一排是地面，左边是2个tile宽的墙，上面有个小缺口，有个梯子可以爬到那。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Static and Probabilistic Tiles( 静态和概率Tile )"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"static tile就像传统关卡编辑器里一样，你让这里有个砖块，那这就永远是砖块了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面模板里的\"4\" tile，就是probabilistic tile。\"4\"表示那有25%的几率会是一个能推动的障碍物，出现在梯子的顶部旁边。有经验的Spelunky玩家会一下认出这个：有时你爬到一个梯子顶部，旁边有个障碍物，你得推它，就可以进到下一个房间。有时候爬到梯子顶上旁边就没有这玩意。还有比如“这有33%的几率会出现个尖刺”，或者“这有一半的几率是空的，或者是砖块”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Obstacle Block( 障碍块）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"5\"和\"6\"就是所谓的Obstacle Block。Obstacle Block由 5x3 的tile网格组成，是个有趣的小结构，会让玩家针对这个障碍来思考自己的策略。Obstacle block本身也会由一些概率tile组成。下面是\"5\" 这个模板，表示放置在地上（\"6\"表示放置在空中）:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"00000"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"00102"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"71177"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"规则和之前的一样，0是空，1是砖块。你能看出来，这是个小台阶。\"7\"有33%的几率是个尖刺，或者为空。如果运气不好，这里就得跳到那个台阶上面避开尖刺。\"2\"表示有一半的几率味空，或者是砖块。这就有意思了，有可能有个小砖块让你落脚不用踩到尖刺，也有可能除了小台阶，旁边都是空的，玩家得跳到上面去。你可以看出，这么个小障碍块，如果设计的好的话，游戏自己就会随机生成很多很多有意思的场景。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"译于2018-Jan-20"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原文链接最好用chrome打开，对，要科学，你懂了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://tinysubversions.com/spelunkyGen/","rel":["nofollow"]},"children":[{"type":"text","value":"http://tinysubversions.com/spelunkyGen/"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://tinysubversions.com/spelunkyGen2/","rel":["nofollow"]},"children":[{"type":"text","value":"http://tinysubversions.com/spelunkyGen2/"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://indienova.com/u/root/blogread/5454","rel":["nofollow"]},"children":[{"type":"text","value":"https://indienova.com/u/root/blogread/5454"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/","rel":["nofollow"]},"children":[{"type":"text","value":"https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-01-23-Spelunky-map.md","_source":"content","_file":"game/2021-01-23-Spelunky-map.md","_extension":"md","date":"2021-01-23"},{"_path":"/game/2021-01-23-roguelike-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"roguelike地牢生成算法","description":"引言文章作者：Mike Anderson随机生成的地图是 Roguelike 类游戏最独特的一点，它让游戏变得很有乐趣，因为玩家永远要面对新的挑战。但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。在这篇文章里，我会将自己在开发一款名为 Tyrant 的 Roguelike 游戏中使用的方法记录下来。我怀疑这可能只能算是一个原型，但是我之前也没有见过什么一本正经讲述生成 Roguelike 地图算法","body":{"type":"root","children":[{"type":"element","tag":"h4","props":{"id":"引言"},"children":[{"type":"text","value":"引言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文章作者："},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Mike_Anderson","rel":["nofollow"]},"children":[{"type":"text","value":"Mike Anderson"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随机生成的地图是 "},{"type":"element","tag":"a","props":{"href":"https://indienova.com/tag/roguelike/","rel":["nofollow"]},"children":[{"type":"text","value":"Roguelike"}]},{"type":"text","value":" 类游戏最独特的一点，它让游戏变得很有乐趣，因为玩家永远要面对新的挑战。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这篇文章里，我会将自己在开发一款名为 "},{"type":"element","tag":"a","props":{"href":"http://sourceforge.net/projects/tyrant/","rel":["nofollow"]},"children":[{"type":"text","value":"Tyrant"}]},{"type":"text","value":" 的 Roguelike 游戏中使用的方法记录下来。我怀疑这可能只能算是一个原型，但是我之前也没有见过什么一本正经讲述生成 Roguelike 地图算法的文章。而且，它工作得还是比较令人满意的，所以，我愿意将它分享给大家。"}]},{"type":"element","tag":"h4","props":{"id":"这款算法的目标"},"children":[{"type":"text","value":"这款算法的目标"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在写任何代码之前，了解自己的目标总是很重要的，这对编程很有帮助，哪怕你随后会做无数的修改。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个地牢（"},{"type":"element","tag":"a","props":{"href":"https://indienova.com/tag/dungeon/","rel":["nofollow"]},"children":[{"type":"text","value":"Dungeon"}]},{"type":"text","value":"）应该包含以下要点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一组相互连通的房间、门和通道"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个入口（向上走的楼梯）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个出口（向下走的楼梯）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有的空间必须能够到达"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后一点尤其重要。要知道，你的玩家在契而不舍的努力之后，应该能够顺利通过这一层，不要让他们失望。另外，如果放了某个物品到地图上的某个空间，它应该不会被藏在无法到达的地方。"}]},{"type":"element","tag":"h4","props":{"id":"计划"},"children":[{"type":"text","value":"计划"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在我写 Tyrant 的时候，我尝试了很多种不同的算法来生成地图，这里所讲的是我能做到的最好的一个，也是目前游戏中使用的那个。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我的灵感来自于此：“如果我是地下城的一个居民，那么我该怎么去建设我的地牢呢？”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显然，我并不会将我的地下城建造成一个一个看起来不错的小房间，然后在中间用长长的通道连接起来。所以，当我需要为我的小怪物们提供更多空间的时候，我应该是拿起我的斧头，挖一个更大一些的洞。这样当他们有所需要的时候就会增加一些新房间——尽管它们看起来可能杂乱无章。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有些地下城主可能想要用吊桥呀、陷阱呀什么的来守护比较“有趣”的房间，但是这些需求都异曲同工。由一个小的地牢开始，慢慢向四周扩散，直到整个地牢形成。这就是我们的计划。"}]},{"type":"element","tag":"h4","props":{"id":"算法"},"children":[{"type":"text","value":"算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个算法里面，“元素”代表着某种地图元素，比如：大房间、小房间、通道、圆形竞技场、保险柜等等。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将整个地图填满土"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在地图中间挖一个房间出来"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"选中某一房间（如果有多个的话）的墙壁"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"确定要修建某种新元素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"查看从选中的墙延伸出去是否有足够的空间承载新的元素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有的话继续，不然就返回第 3 步"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"从选中的墙处增加新的元素"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"返回第 3 步，直到地牢建设完成"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在地图的随机点上安排上楼和下楼的楼梯"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最后，放进去怪兽和物品"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 1、2 步很简单。只要你创建好地图就可以去做到。我发现，写一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fillRect"}]},{"type":"text","value":" 指令用来填充一个区域是比较有效的做法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 3 步麻烦一些。你不能随意的寻找一个方块区域去添加你的元素，因为规则是要将元素添加到当前的地牢当中。这样会使得连接看起来比较不错，也确保了所有的区域都可以到达。Tyrant 的做法是：在地图上随机选择一个方块，直到找到横向或者纵向毗邻一个干净的方块那个。这样做的好处是：它给了你一个近乎公平的方式去选择某一面墙。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 4 步不太困难。我自己写了一个随机方法来决定建造哪一种元素。你可以自己定义它们，调整某些元素出现的权重，这会让你的地牢有自己的特点和侧重点。一个规划比较好的地牢会有很多规矩的房间，中间有长而且直的走廊连接。而洞穴则可能有一堆打洞以及曲折的小道等等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 5 步更复杂一些，而且也是整个算法的核心。针对每一种元素，你需要知道它会占用的空间大小。然后你要去判断它是否和已经有的元素相交。Tyrant 使用了相对简单的一种方法：它会先得到要创建的元素所占用的空间大小，得到这个空间的数据，然后检查是否这个空间由土填满。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 6 步决定是否创建这个元素。如果这个待确定的空间包含有除了土之外的内容，那么就回到第 3 步继续。注意，大部分元素在这步都会被打回。不过这不是个问题，因为处理时间可以忽略。Tyrant 尝试着将某个元素加入 300 次左右到地牢中去，一般只有 40 次左右会通过这步。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 7 步会将新元素添加到地图上去。在这步，你还可以增加一些有趣的元素，比如动物、居民、秘道门和财宝什么的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 8 步返回去创建更多的房间。确切的次数跟你地牢的尺寸以及其它参数有关。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 9 步要看个人喜好了。最简单的方法就是随机的去查找方块，直到找到一个空的位置去放置楼梯。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第 10 步就是随机的创建怪兽。Tyrant 在这一步才加入游戏中大多数的怪兽，由少量的特殊怪兽或者生物会在生成房间的时候添加进去。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就这样啦，这里所说的只是算法的规则，具体还要您自己去实现啦。"}]},{"type":"element","tag":"h4","props":{"id":"例子"},"children":[{"type":"text","value":"例子"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，在看了半天算法之后，我们来一个例子吧："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Key:"}]},{"type":"element","tag":"pre","props":{"code":"# = 地板\nD = 门\nW = 正在考查中的墙\nC = 宝箱\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# = 地板\nD = 门\nW = 正在考查中的墙\nC = 宝箱\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\1. 第一个房间"}]},{"type":"element","tag":"pre","props":{"code":"#####\n#####\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####\n#####\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\2. 随机选择一面墙"}]},{"type":"element","tag":"pre","props":{"code":"#####\n#####W\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####\n#####W\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\3. 为新的通道元素进行区域搜索（包括两边的空间）"}]},{"type":"element","tag":"pre","props":{"code":"#####**********\n#####W*********\n#####**********\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####**********\n#####W*********\n#####**********\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\4. 是空的，可以添加元素"}]},{"type":"element","tag":"pre","props":{"code":"#####\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\5. 选择另外一面墙"}]},{"type":"element","tag":"pre","props":{"code":"#####     W\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#####     W\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\6. 扫描寻找新的房间所占用空间："}]},{"type":"element","tag":"pre","props":{"code":"       ******\n       ******\n       ******\n       ******\n       ******\n#####  ***W**\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"       ******\n       ******\n       ******\n       ******\n       ******\n#####  ***W**\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\7. 这个地区也可以，那就添加一个新房间，再往里面扔一个宝箱 C（Chest）："}]},{"type":"element","tag":"pre","props":{"code":"        ####\n        ###C\n        ####\n        ####\n#####     D  \n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        ####\n        ###C\n        ####\n        ####\n#####     D  \n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\8. 跟前面做法一样，我们增加一个新的通道元素"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\9. 这一次，我们试着为第二个房间增加一个通道元素"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #\n        #### #\n        ###C*******\n        ####W******\n        ####*******\n#####     D  #\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #\n        #### #\n        ###C*******\n        ####W******\n        ####*******\n#####     D  #\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\10. 扫描失败了，已经被占用"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #\n        #### #\n        ###C #\n        #### #\n        #### #\n#####     D  #\n#####D########\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\11. 比较特别的元素，一个菱形的房间"}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #   ###\n        #### #  #####\n        ###C # #######\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #   ###\n        #### #  #####\n        ###C # #######\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\12. 添加一个隐藏的暗门，以及充满陷阱的通道："}]},{"type":"element","tag":"pre","props":{"code":"             #\n             #   ###\n        #### #  #####\n        ###C # #######S###T##TT#T##\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"             #\n             #   ###\n        #### #  #####\n        ###C # #######S###T##TT#T##\n        #### #D#######\n        #### # #######\n#####     D  #  #####\n#####D########   ###\n#####\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\\13. 继续……"}]},{"type":"element","tag":"h4","props":{"id":"总结"},"children":[{"type":"text","value":"总结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"好了，这就是我的算法，我希望它对你有用，或者从一个有趣的角度去看如何解决一个问题。"}]},{"type":"element","tag":"h4","props":{"id":"代码实现"},"children":[{"type":"text","value":"代码实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Java 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Java_Example_of_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"Java 代码实现"}]},{"type":"text","value":"\n你可以通过 "},{"type":"element","tag":"a","props":{"href":"http://openprocessing.org/visuals/?visualID=18822","rel":["nofollow"]},"children":[{"type":"text","value":"Open Processing"}]},{"type":"text","value":" 在浏览器里面运行它（需要做一些小修改）。它会创建一个图形化的地牢。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Python Curses 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Python_Curses_Example_of_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"Python Curses 代码实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"C++ 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=C%2B%2B_Example_of_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"C++ 代码实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"C# 代码实现"}]},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=CSharp_Example_of_a_Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"C# 代码实现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原文地址："},{"type":"element","tag":"a","props":{"href":"http://www.roguebasin.com/index.php?title=Dungeon-Building_Algorithm","rel":["nofollow"]},"children":[{"type":"text","value":"链接"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:game:2021-01-23-roguelike-map.md","_source":"content","_file":"game/2021-01-23-roguelike-map.md","_extension":"md","date":"2021-01-23"},{"_path":"/game/2021-01-22-civ-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"文明6地图生成算法","description":"作者：哈里叔叔\n链接：https://www.zhihu.com/question/52019284/answer/1476187895\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"作者：哈里叔叔\n链接："},{"type":"element","tag":"a","props":{"href":"https://www.zhihu.com/question/52019284/answer/1476187895","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.zhihu.com/question/52019284/answer/1476187895"}]},{"type":"text","value":"\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}]},{"type":"element","tag":"h3","props":{"id":"对称性对抗游戏简介"},"children":[{"type":"text","value":"对称性对抗游戏简介"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对称性对抗游戏是指参与游戏的玩家所拥有的资源、交互方式、受制规则、最终目标是相同或相近的，是一种公平、对称的零和游戏。如《英雄无敌》《文明》《卡坦岛》等游戏。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们参考文明的4X要素["},{"type":"element","tag":"a","props":{"href":"#ref_1"},"children":[{"type":"text","value":"1]"}]},{"type":"text","value":"搭建了一个多人回合制战略游戏，如下图所示：地图开始被“战争迷雾”所覆盖。玩家必须派遣探险者进入这片迷雾中，以揭露要扩张的土地，要开发的资源以及要消灭的对手。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_720w.jpg"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"地图的平衡性指标"},"children":[{"type":"text","value":"地图的平衡性指标"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们参考["},{"type":"element","tag":"a","props":{"href":"#ref_2"},"children":[{"type":"text","value":"2]"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"#ref_3"},"children":[{"type":"text","value":"3]"}]},{"type":"text","value":"两篇参考文献制定出评估对称性对抗游戏地图平衡性的两点指标。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1. 战略特征（Strategic Feature）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"战略特征是指玩家在游戏中可以利用的战略资源。 战略特征的平衡是指每一名玩家在一定时间内获得基本相同的资源（包括类型和数量）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面两张图显示了两名玩家战略特征不平衡的情况，蓝色玩家初始时可以获得更多的矿产资源，而黄色玩家的出生点附近几乎没有矿产资源，这会导致游戏初期黄色玩家的发展受限。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2. 玩家占位符（player placeholder）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"玩家初始的出生点占位的分布也会影响游戏的平衡性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面两张图显示了玩家初始占位符分布密度不同导致游戏性不平衡的情况。左图的玩家初始分布密集，这会导致这个地区的玩家在游戏前期相互碾压、发展受限；而右图中的黄色玩家在游戏前期缺少竞争，能够更好地发展自身建设。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了以上两点对游戏平衡性的影响之外，战略游戏地图的随机地图还要考虑到：地图的美观性、根据玩家的偏好定制参数、生成地图的效率等要求。"}]},{"type":"element","tag":"h3","props":{"id":"地图的生成过程"},"children":[{"type":"text","value":"地图的生成过程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1. 根据玩家的偏好定制地图参数"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在新建游戏之前，我们会让玩家根据自己的喜好定制地图参数，包括地图的尺寸、玩家的总数量、地图的类型（盘古大陆、大洲、海岛群）、水体比例、植被比例、岩石比例与资源的比例等。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2. 生成地图的轮廓：柏林噪声"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声（Perlin noise）指由Ken Perlin发明的自然噪声生成算法["},{"type":"element","tag":"a","props":{"href":"#ref_4"},"children":[{"type":"text","value":"4]"}]},{"type":"text","value":"。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"与椒盐噪声相比，柏林噪声有较好的连续性分布，可以更好的模拟自然界中的地形分布与地表装饰物分布。利用柏林噪声生成自然地图可以参考B站视频："},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1sJ411e7nt","rel":["nofollow"]},"children":[{"type":"text","value":"柏林噪声程序化生成随机地图"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"#ref_5"},"children":[{"type":"text","value":"5]"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声的生成采用伪随机数的生成方式，相同的“随机数种子”会生成相同的地貌。这也是很多随机地图生成器中会暴露“种子”让玩家根据种子生成地图的原因。如果想跟好朋友分享某个生成结果比较好的地图，只需要共享“种子”字符串，就能在随机地图生成器中还原出所生成的地形，而不需要把整个地图文件保存到本地再分享。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity官方自带生成柏林函数的函数。我们引用了柏林噪声js库来进行地形的实现。我们利用柏林噪声的采样尺度来决定地图的类型是连续的大陆型地图还是离散的大洲型地图；将随机取到的连续噪声均衡化作为地图的高度图，根据用户设置的水体占比来制定海平面高度，最终生成的地形结果如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3. 玩家出生点的选择：米切尔最佳候选算法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了保证每位玩家两两之间的初始分布不会过近，我们在生成游戏地形后，在陆地上对玩家初始占位符进行均匀采样。为了兼顾效果与效率，我们最终选用米切尔最佳候选 算法（best candidate）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"米切尔最佳候选算法是一种渐进、增量式的均匀采样方法。它每一轮采样都是从多个随机采样点中，保留与之前轮的所有采样点中最小距离最大的点作为本轮的采样结果。更加具体直观的算法解释可以参考:"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//bindog.github.io/blog/2014/08/09/visualizing-algorithms/","rel":["nofollow"]},"children":[{"type":"text","value":"算法可视化"}]},{"type":"text","value":"["},{"type":"element","tag":"a","props":{"href":"#ref_6"},"children":[{"type":"text","value":"6]"}]},{"type":"text","value":"中有关米切尔候选算法的部分"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示：黑色点是之前轮已经确定的采样点，灰色点是本轮随机采样的候选点，每个候选点都选出与之前轮采样点中距离最近的距离，再从中选出最小距离最大的红色点作为本轮采样的结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"利用这种采样方式采样出玩家的初始占位符，可以避免任意两个玩家之间的距离过近导致游戏平衡性被破坏，如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4. 战略资源的分布"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采样出玩家的分布之后，我们将地图单元格分为两种类型：每个玩家占位符附近距离N以内的单元格为玩家区域（Player Zones），不隶属于任何玩家区域的单元格被称为隔离区或自然区（Natural Zones）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了让每名玩家在游戏初始时具有公平的战略特征，我们对每位玩家的玩家区域内定额分配植被、岩石与矿产资源。根据用户设定的植被、岩石与资源占比分别计算出每位玩家区应当分配到的植被、岩石与资源数量，然后在每个玩家区域内不重不漏地采样出相等数量的植被、岩石与资源单元格。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于自然区，我们按照玩家设置的参数，采用米切尔候选算法均匀采样每一种资源。这样可以保证每位玩家在游戏初始时能够得到数量一致的战略特征。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5. 边界情况处理"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用以上方式生成的地图在某些情况下会产生不好的结果，例如当水体比例过低时生成海岛地形，会导致水体不够划分不出海岛地形；当水体比例过高时，会由于陆地单元格分布不均导致出生在不同规模大小的岛屿上的玩家能够得到的战略资源再度失衡。对于这些边界情况，我们利用种子生长与泛洪填充等启发式生成方法生成地图，优先保证地图类型能够满足用户的需求，并尽可能保证水体与各种战略特征的资源逼近用户的设定。以下是我们在水体占比过低与水体占比过高时生成的地图，可以看出在这两种情况下依然能够保证所生成地图的平衡性："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_720w.jpg"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"生成地图质量的定量评估"},"children":[{"type":"text","value":"生成地图质量的定量评估"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了判断我们的生成随机地图算法是否具有良好的平衡性指标，我们设计了一套地图自动扩张算法：每个玩家以出生点占位符为种子，轮流从目前领土所毗邻的无人单元格中抽取一个进行占领以扩张势力范围，直到地图中所有的单元格都被有且只有一个玩家占领；然后我们统计每个玩家占领到的资源数量、距离最近的敌人距离，以及每个玩家与多少数量的玩家领土相邻。如下图所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实验组是我们的算法生成的地图，对照组是根据水体与各种资源的比例随机采样地形、随机采样玩家分布得到的地图。如下方左侧是实验组生成的地图，右侧是对照组生成的地图："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实验组与对照组各生成100次地图，统计每个玩家与其他势力最小距离的均值与方差、扩张完成后各资源占有量的均值与方差以及每位玩家潜在冲突势力的均值与方差，统计的结果如下所示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_hd.jpg"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过定量的统计结果可以看出，我们的方法生成的地图，玩家之间有更大的平均极小距离，这说明每位玩家的出生点占位符设置更加平衡；各种资源的分布方差均比对照组小，说明我们的战略特征分配与朴素的随机生成的地图相比更加均衡。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"综上所述，我们的地图生成结果能够保证对称性多人对抗战略游戏的平衡性。"}]},{"type":"element","tag":"h3","props":{"id":""},"children":[]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"对称性对抗游戏简介","depth":3,"text":"对称性对抗游戏简介"},{"id":"地图的平衡性指标","depth":3,"text":"地图的平衡性指标"},{"id":"地图的生成过程","depth":3,"text":"地图的生成过程"},{"id":"生成地图质量的定量评估","depth":3,"text":"生成地图质量的定量评估"},{"id":"","depth":3,"text":""}]}},"_type":"markdown","_id":"content:game:2021-01-22-civ-map.md","_source":"content","_file":"game/2021-01-22-civ-map.md","_extension":"md","date":"2021-01-22"},{"_path":"/game/2021-01-21-wave-collapse-function","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"波函数坍塌算法生成地图","description":"什么是“波函数坍塌”？这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"什么是波函数坍塌"},"children":[{"type":"text","value":"什么是“波函数坍塌”？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才有了一个比较霸气的名字而已。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"开发这些模型或者贴图合成技术是为了能使用一块很小的由人工制作的贴图或者模型来生成大量相似的贴图或者模型。这样可以有效的减少人工作业，提升效率。当然可能有人会有这样的疑问，现在基于GAN的AI看起来能够生成又是动画又是图片的，还有这种技术存在的必要吗? 答案当然是有存在的必要，首先GAN需要海量的样本去训练，有生成这么多样本的劲，大概早就做完游戏了，其次是AI生成的不一定能满足业务需求，而且使用者并没有调教的可能性，而在做贴图或者模型合成时，实际上只需要一个样本就可以完成所有的工作了。接下来要简要介绍下基本的原理。"}]},{"type":"element","tag":"h2","props":{"id":"基本原理"},"children":[{"type":"text","value":"基本原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“波函数坍塌“主要是依赖于样本相邻各点的布局结构，以这些结构作为特征，在一个更大的空间上生成满足样本结构约束的新数据。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以贴图合成为例，假设在输入贴图中有且仅有一点坐标是 x,y，颜色为"},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/6.svg"},"children":[]},{"type":"text","value":" ，上下左右四个点的颜色分别是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/5.svg"},"children":[]},{"type":"text","value":" 。那么在输出贴图中，如果存在一点颜色为 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/6.svg"},"children":[]},{"type":"text","value":" ，那么它的上下左右四个点的颜色必须是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/5.svg"},"children":[]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实际上我们可以建立更复杂的相邻布局约束，比如说以贴图中某个点周围的不仅上下左右，还有对角线上的4个点，总共八个点建立约束条件，甚至是上下左右四个点的上下左右总共12个点。不过本文只会探讨受上下左右四个点约束的情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以我们的算法就是根据输入贴图提供的这种约束关系来生成输出贴图。这是一个搜索的过程，实际上是一个np hard问题，也就是说，只有当我们搜索了所有的可能性时，才一定能获得一个结果，当然这个结果可能是成功合成贴图，也可能是失败了，当对最终生成图片存在外界约束时，会有更大的可能性失败。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然以贴图为例来说明，但是本文的初衷是为了能够生2d游戏的地图，所以接下来将仅介绍2d下的离散模型合成技术。在2d游戏开发中，一般会用瓦片（tiles）贴图来构成地图，其中瓦片会有特定的几何形状，然后通过瓦片的放置来完成地图。本文以及提供的代码只会考虑正方形的瓦片，对于正方形瓦片来说就和上面的解释完全一致了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后不得不列一下我觉得还蛮重要的公式，该公式描述了上文中提及的一致性约束。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"设输入模型为 E，输出模型为 M ，那么当 M与 E 一致时，则对于 M中任意一点 x ，存在 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/8.svg"},"children":[]},{"type":"text","value":" ，且 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/8.svg"},"children":[]},{"type":"text","value":" 属于 E ，满足："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/7.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中， x 是 M中一点，而 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/8.svg"},"children":[]},{"type":"text","value":" 是 E中一点， "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/9.svg"},"children":[]},{"type":"text","value":" 则是几何纬度上正负向的单位向量，3维下是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/4.svg"},"children":[]},{"type":"text","value":" ，2维下则是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/3.svg"},"children":[]},{"type":"text","value":" 。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接下来当然是要介绍具体的算法了。但是首先还是需要将问题重新描述一下。"}]},{"type":"element","tag":"h2","props":{"id":"描述问题"},"children":[{"type":"text","value":"描述问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们需要通过一个样例模型，然后给予一个种子来生成一个更大的模型。在2d情况下，模型会被描述为一个二维矩阵，矩阵中的每个点都是一个非负整数，不同的整数代表一个瓦片的种类，0表示空瓦片。我们需要设定输出模型的大小比如一个10*10的矩阵，然后通过一个特定的种子来生成随机数，根据这个随机数去遍历所有的可能性并找到一个合适的解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以我们的程序至少需要做下面几件事："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"载入瓦片信息，种类编号和瓦片的图片。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"载入输入模型信息，即输入模型矩阵，矩阵的值为瓦片种类id，然后分析输入模型，得到约束条件矩阵。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据约束矩阵，以及随机数去搜索输出模型。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"输出（可视化）输出模型。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显然，第三步是最为麻烦的，也是最困难的，其次是第二步，我们需要得到一个约束矩阵，然后第一和第四步都是常规操作。"}]},{"type":"element","tag":"h2","props":{"id":"获得约束矩阵"},"children":[{"type":"text","value":"获得约束矩阵"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"约束矩阵描述了在输入模型中，相邻点的布局关系。当我们为输出模型布局时，我们可以在某一点填入一个特定的瓦片id，然后当填充这个瓦片相邻的四个瓦片时，通过查询约束矩阵，我们可以知道在当前瓦片id下，它上方的位置只能是特定的几个id。同理就可以推导出其他三个瓦片能够选择的id。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以当生成一个2d模型时，需要4个约束矩阵，分别代表x轴正向，负向，和y轴正向，负向的约束。每个约束矩阵的长度为总的瓦片id数，宽度也是总的瓦片id数，其值为bool或者是0或1，用来表示当当前点上的瓦片id是某个值时，其相邻对应位置瓦片允许的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写个简单的例子，对于输入模型矩阵 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/2.svg"},"children":[]},{"type":"text","value":" 的正的右侧，也就是x轴正方向，可以得到如下的约束规则：0-1，1-2，2-3，2-1，1-0，0-0。整理成矩阵也就是 "},{"type":"element","tag":"img","props":{"alt":"[公式]","src":"/images/2021-01-21-wave-collapse-function/1.svg"},"children":[]},{"type":"text","value":" ，这个矩阵等于它的转置矩阵，然后我们会有4个类似这样的约束矩阵对应不同方向的邻居，我们使用当前的瓦片id去查询就可以得到相邻瓦片允许填入的瓦片id了。"}]},{"type":"element","tag":"h2","props":{"id":"搜索算法"},"children":[{"type":"text","value":"搜索算法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"搜索算法部分是最为困难的部分了。我们需要保存一个记录矩阵（catalog），该矩阵与最终输出模型大小相同，比如输出模型是10"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"10的这个记录矩阵也是10"}]},{"type":"text","value":"10的。在这个记录矩阵中，每个元素会是一个集合，表示当前该点可以填入的瓦片id的集合，当该点可填入瓦片id集合为空集时，说明走了一条错误的路径，需要回退。然后我们的搜索算法会按照之前走过来的路径回退到上一个操作点，同时这个记录矩阵也需要回退相应的步数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于记录矩阵的回退，需要记录一个类似数据库的ahead log的东西，来记录所有对记录矩阵的操作，当产生回退时，只需要沿着这log向前恢复就可以。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于搜索算法的前进和回退，在我参考的论文里没有提及具体的方式，经过一段时间的尝试，我建立了一颗树来记录搜索的路径，当产生回退时，树的当前节点会被标记为不可通行，便不会向这片树枝搜索了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-21-wave-collapse-function/v2-37deccf09bca15112c03e8169fc3c525_720w.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如上图所示，灰色的节点表示还没探索到，实际上还不在树里，红色的节点表示需要回退的节点。蓝色的节点表示已探索或者待探索的节点，绿色的箭头表示已经探索的路径。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"五边形节点表示根节点，一旦在根节点发生回退说明，搜索失败，并没有找到合适的输出模型。正方形节点表示选择点操作，当游标在正方形节点上时，等于选取该节点记录的点为当前点。圆形节点则表示，为当前点选择了一个特定的瓦片，该瓦片的种类取决于记录矩阵在该点允许的选择，然后会根据约束矩阵，更新记录矩阵，当发现更新后记录矩阵存在空集便会回退。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最终会有如下的搜索过程："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"建立搜索树，找到所有的点，并将其放在根节点下边，随机选一个节点，将游标移动到该节点，设定该节点对应的点为当前节点，然后根据记录矩阵中的值，随机选择一个瓦片填入，并根据约束矩阵更新记录矩阵。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"找到剩余所有没有瓦片的点，将这些节点加入当前节点后面，然后将根据这些点与当前所选中的点的距离，计算一个权重，离得最近的会被最先搜索，如果没有新的节点可以选择，则生成成功。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据权重和生成的随机数以及选择一个节点，根据记录矩阵在该点的瓦片集合以及随机数为该节点选择一个瓦片，然后根据约束矩阵以及当前选择去更新记录矩阵中相邻点的记录："}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果更新中发现某相邻点可选瓦片为空，则需要回退到上一个圆形节点，与此同时记录矩阵也要回退上一个圆形节点之后的操作，并将该节点标为禁止通行，并返回第2步，如果发现当前节点在根节点，则生成失败。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果不为空，则根据随机数选择一个瓦片填入，并根据约束矩阵更新记录矩阵，然后返回第2步。"}]}]},{"type":"element","tag":"h2","props":{"id":"链接"},"children":[{"type":"text","value":"链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian%5C_docid=0M2y2bvM","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&yidian\\_docid=0M2y2bvM"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/65495333","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/65495333"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/mxgmn/WaveFunctionCollapse","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/mxgmn/WaveFunctionCollapse"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/BorisTheBrave/DeBroglie","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/BorisTheBrave/DeBroglie"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"什么是波函数坍塌","depth":2,"text":"什么是“波函数坍塌”？"},{"id":"基本原理","depth":2,"text":"基本原理"},{"id":"描述问题","depth":2,"text":"描述问题"},{"id":"获得约束矩阵","depth":2,"text":"获得约束矩阵"},{"id":"搜索算法","depth":2,"text":"搜索算法"},{"id":"链接","depth":2,"text":"链接"}]}},"_type":"markdown","_id":"content:game:2021-01-21-wave-collapse-function.md","_source":"content","_file":"game/2021-01-21-wave-collapse-function.md","_extension":"md","date":"2021-01-21"},{"_path":"/game/2021-01-20-perlin-map","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"使用柏林噪声算法生成地图","description":"柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得奥斯卡科技成果奖（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的改进版柏林噪声算法。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。\n如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/doc/oscar.html","rel":["nofollow"]},"children":[{"type":"text","value":"奥斯卡科技成果奖"}]},{"type":"text","value":"（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/noise/","rel":["nofollow"]},"children":[{"type":"text","value":"改进版柏林噪声算法"}]},{"type":"text","value":"。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。\n如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://images2015.cnblogs.com/blog/608996/201707/608996-20170721155322355-1352334868.png","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/608996-20170721155322355-1352334868.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正如图所示，柏林噪声算法可以用来模拟许多自然中的噪声现象。接下来让我们从数理上分析算法的实现原理。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"基本原理"},"children":[{"type":"text","value":"基本原理#"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：事先声明，本节内容大多源于"},{"type":"element","tag":"a","props":{"href":"http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html","rel":["nofollow"]},"children":[{"type":"text","value":"this wonderful article by Matt Zucker"}]},{"type":"text","value":"，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"让我们从最基本的柏林噪声函数看起：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"public double perlin(double x, double y, double z);"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"函数接收"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x,y,z"}]},{"type":"text","value":"三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x,y,z"}]},{"type":"text","value":"的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-bfbbc85ed4afee99.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-bfbbc85ed4afee99.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子来理解伪随机，比如我们从圆周率π（3.14159...）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-ad4b0120e857b5d3.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-ad4b0120e857b5d3.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图2：各顶点上的梯度向量随机选取结果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"采用这些特殊梯度向量的原因在"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/paper445.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"Ken Perlin's SIGGRAPH 2002 paper: Improving Noise"}]},{"type":"text","value":"这篇文章里有具体讲解。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意：许多介绍柏林噪声算法的文章都是根据最初版柏林噪声算法来讲解的，预定义的梯度表不是本文所说的这12个向量。如图2所示的梯度向量就是最初版算法所随机出来的梯度向量，不过这两种算法的原理都是一样的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-6dde06b2b941253d.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-6dde06b2b941253d.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图3:各个距离向量"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，对每个顶点的梯度向量和距离向量做"},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Dot_product","rel":["nofollow"]},"children":[{"type":"text","value":"点积"}]},{"type":"text","value":"运算，我们就可以得出每个顶点的影响值：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad.x * dist.x + grad.y * dist.y + grad.z * dist.z"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"dot(vec1,vec2) = cos(angle(vec1,vec2)) * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"dot(vec1,vec2) = cos(angle(vec1,vec2)) * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"换句话说，如果两向量指向同一方向，点积结果为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"1 * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"1 * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果两向量指向相反方向，则点积结果为："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"-1 * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-1 * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果两向量互相垂直，则点积结果为0。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"0 * vec1.length * vec2.length\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"0 * vec1.length * vec2.length\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。下面通过一副彩色图，直观地看下各顶点的影响值："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-0c7ca0db2126715a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-0c7ca0db2126715a.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图4：2D柏林噪声的影响值"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"// Below are 4 influence values in the arrangement:\n// [g1] | [g2]\n// -----------\n// [g3] | [g4]\nint g1, g2, g3, g4;\nint u, v;   // These coordinates are the location of the input coordinate in its unit square.  \n            // For example a value of (0.5,0.5) is in the exact center of its unit square.\n\nint x1 = lerp(g1,g2,u);\nint x2 = lerp(g3,h4,u);\n\nint average = lerp(x1,x2,v);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Below are 4 influence values in the arrangement:\n// [g1] | [g2]\n// -----------\n// [g3] | [g4]\nint g1, g2, g3, g4;\nint u, v;   // These coordinates are the location of the input coordinate in its unit square.  \n            // For example a value of (0.5,0.5) is in the exact center of its unit square.\n\nint x1 = lerp(g1,g2,u);\nint x2 = lerp(g3,h4,u);\n\nint average = lerp(x1,x2,v);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"fade函数"}]},{"type":"text","value":"，通常也被称为"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ease curve"}]},{"type":"text","value":"(也作为缓动函数在游戏中广泛使用)："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-27f5e6997742a89a.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-27f5e6997742a89a.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图5：ease curve"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"代码实现"},"children":[{"type":"text","value":"代码实现#"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在本节开始前我需要重申一遍，代码实现是C#版本。相比"},{"type":"element","tag":"a","props":{"href":"http://mrl.nyu.edu/~perlin/noise/","rel":["nofollow"]},"children":[{"type":"text","value":"Ken Perlin的Java版本实现"}]},{"type":"text","value":"做了小小的改动，主要是增加了代码的整洁性和可读性，支持噪声重复（瓦片重复）特性。代码完全开源，可免费使用（考虑到这毕竟不是我原创发明的算法 - Ken Perlin才是！）"}]},{"type":"element","tag":"h2","props":{"id":"准备工作"},"children":[{"type":"text","value":"准备工作##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一步，我们需要先声明一个排列表（permutation table），或者直接缩写为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组就行了。数组长度为256，分别随机、无重复地存放了0-255这些数值。为了避免缓存溢出，我们再重复填充一次数组的值，所以数组最终长度为512："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"private static readonly int[] permutation = { 151,160,137,91,90,15,                 // Hash lookup table as defined by Ken Perlin.  This is a randomly\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    // arranged array of all numbers from 0-255 inclusive.\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\nprivate static readonly int[] p;                                                    // Doubled permutation to avoid overflow\n\nstatic Perlin() {\n    p = new int[512];\n    for(int x=0;x<512;x++) {\n        p[x] = permutation[x%256];\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private static readonly int[] permutation = { 151,160,137,91,90,15,                 // Hash lookup table as defined by Ken Perlin.  This is a randomly\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    // arranged array of all numbers from 0-255 inclusive.\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\nprivate static readonly int[] p;                                                    // Doubled permutation to avoid overflow\n\nstatic Perlin() {\n    p = new int[512];\n    for(int x=0;x<512;x++) {\n        p[x] = permutation[x%256];\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组会在算法后续的哈希计算中使用到，用于确定一组输入最终挑选哪个梯度向量（从前面所列出的12个梯度向量中挑选）。后续代码会详细展示"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组的用法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着，我们开始编写柏林噪声函数："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double perlin(double x, double y, double z) {\n    if(repeat > 0) {                                    // If we have any repeat on, change the coordinates to their \"local\" repetitions\n        x = x%repeat;\n        y = y%repeat;\n        z = z%repeat;\n    }\n    \n    int xi = (int)x & 255;                              // Calculate the \"unit cube\" that the point asked will be located in\n    int yi = (int)y & 255;                              // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\n    int zi = (int)z & 255;                              // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\n    double xf = x-(int)x;\n    double yf = y-(int)y;\n    double zf = z-(int)z;\n    // ...\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double perlin(double x, double y, double z) {\n    if(repeat > 0) {                                    // If we have any repeat on, change the coordinates to their \"local\" repetitions\n        x = x%repeat;\n        y = y%repeat;\n        z = z%repeat;\n    }\n    \n    int xi = (int)x & 255;                              // Calculate the \"unit cube\" that the point asked will be located in\n    int yi = (int)y & 255;                              // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\n    int zi = (int)z & 255;                              // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\n    double xf = x-(int)x;\n    double yf = y-(int)y;\n    double zf = z-(int)z;\n    // ...\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的代码很直观。首先，对输入坐标使用求余运算符%，求出[0,repeat)范围内的余数。紧接着声明"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"xi, yi, zi"}]},{"type":"text","value":"三个变量。它们代表了输入坐标落在了哪个单元正方形里。我们还要限制坐标在[0,255]这个范围内，避免访问数组"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"时，出现数组越界错误。这也产生了一个副作用：柏林噪声每隔256个整数就会再次重复。但这不是太大的问题，因为算法不仅能处理整数，还能处理小数。最后，我们通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"xf, yf, zf"}]},{"type":"text","value":"三个变量（也就是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x,y,z"}]},{"type":"text","value":"的小数部分值），确定了输入坐标在单元正方形里的空间位置（就是前面所示的小蓝点）。"}]},{"type":"element","tag":"h2","props":{"id":"fade函数"},"children":[{"type":"text","value":"Fade函数##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在我们需要用代码表示前面所提到的fade函数（图5）。正如上文所提，函数的数学表示：\n"},{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码实现如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public static double fade(double t) {\n                                                        // Fade function as defined by Ken Perlin.  This eases coordinate values\n                                                        // so that they will ease towards integral values.  This ends up smoothing\n                                                        // the final output.\n    return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3\n}\n\npublic double perlin(double x, double y, double z) {\n    // ...\n\n    double u = fade(xf);\n    double v = fade(yf);\n    double w = fade(zf);\n\n    // ...\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static double fade(double t) {\n                                                        // Fade function as defined by Ken Perlin.  This eases coordinate values\n                                                        // so that they will ease towards integral values.  This ends up smoothing\n                                                        // the final output.\n    return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3\n}\n\npublic double perlin(double x, double y, double z) {\n    // ...\n\n    double u = fade(xf);\n    double v = fade(yf);\n    double w = fade(zf);\n\n    // ...\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码所计算得出的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"u / v / w"}]},{"type":"text","value":"变量将在后面的插值计算中使用到。"}]},{"type":"element","tag":"h2","props":{"id":"哈希函数"},"children":[{"type":"text","value":"哈希函数##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"柏林噪声哈希函数用于给每组输入计算返回一个唯一、确定值。哈希函数在维基百科的定义如下："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法，输入数据有任何细微的不同，都会令输出结果完全不一样"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面代码就是柏林噪声算法所使用的哈希函数。它使用了早前我们声明的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double perlin(double x, double y, double z) {\n    // ...\n\n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n\n    // ...\n}\n\npublic int inc(int num) {\n    num++;\n    if (repeat > 0) num %= repeat;\n    \n    return num;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double perlin(double x, double y, double z) {\n    // ...\n\n    int aaa, aba, aab, abb, baa, bba, bab, bbb;\n    aaa = p[p[p[    xi ]+    yi ]+    zi ];\n    aba = p[p[p[    xi ]+inc(yi)]+    zi ];\n    aab = p[p[p[    xi ]+    yi ]+inc(zi)];\n    abb = p[p[p[    xi ]+inc(yi)]+inc(zi)];\n    baa = p[p[p[inc(xi)]+    yi ]+    zi ];\n    bba = p[p[p[inc(xi)]+inc(yi)]+    zi ];\n    bab = p[p[p[inc(xi)]+    yi ]+inc(zi)];\n    bbb = p[p[p[inc(xi)]+inc(yi)]+inc(zi)];\n\n    // ...\n}\n\npublic int inc(int num) {\n    num++;\n    if (repeat > 0) num %= repeat;\n    \n    return num;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码的哈希函数，对包围着输入坐标（小蓝点）的周围8个单元正方形的索引坐标进行了哈希计算。"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"inc()"}]},{"type":"text","value":"函数用于将输入值增加1，同时保证范围在[0,repeat)内。如果不需要噪声重复，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"inc()"}]},{"type":"text","value":"函数可以简化成单纯将输入值增加1。由于哈希结果值是从"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"p[]"}]},{"type":"text","value":"数组中得到的，所以哈希函数的返回值范围限定在[0,255]内。"}]},{"type":"element","tag":"h2","props":{"id":"梯度函数"},"children":[{"type":"text","value":"梯度函数##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我时常认为Ken Perlin的最初版算法里的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad()"}]},{"type":"text","value":"函数写法过于复杂，令人费解。我们只要明白"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad()"}]},{"type":"text","value":"函数的作用在于计算随机选取的梯度向量以及顶点位置向量的点积。Ken Perlin巧妙地使用了位翻转(bit-flipping)技巧来实现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public static double grad(int hash, double x, double y, double z) {\n    int h = hash & 15;                                    // Take the hashed value and take the first 4 bits of it (15 == 0b1111)\n    double u = h < 8 /* 0b1000 */ ? x : y;                // If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.\n    \n    double v;                                             // In Ken Perlin's original implementation this was another conditional operator (?:).  I\n                                                          // expanded it for readability.\n    \n    if(h < 4 /* 0b0100 */)                                // If the first and second significant bits are 0 set v = y\n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)  // If the first and second significant bits are 1 set v = x\n        v = x;\n    else                                                  // If the first and second significant bits are not equal (0/1, 1/0) set v = z\n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static double grad(int hash, double x, double y, double z) {\n    int h = hash & 15;                                    // Take the hashed value and take the first 4 bits of it (15 == 0b1111)\n    double u = h < 8 /* 0b1000 */ ? x : y;                // If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.\n    \n    double v;                                             // In Ken Perlin's original implementation this was another conditional operator (?:).  I\n                                                          // expanded it for readability.\n    \n    if(h < 4 /* 0b0100 */)                                // If the first and second significant bits are 0 set v = y\n        v = y;\n    else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)  // If the first and second significant bits are 1 set v = x\n        v = x;\n    else                                                  // If the first and second significant bits are not equal (0/1, 1/0) set v = z\n        v = z;\n    \n    return ((h&1) == 0 ? u : -u)+((h&2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面代码则是以另一种令人容易理解的方式完成了这个任务（而且在很多语言版本的运行效率都优于前面一种）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"// Source: http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html\npublic static double grad(int hash, double x, double y, double z)\n{\n    switch(hash & 0xF)\n    {\n        case 0x0: return  x + y;\n        case 0x1: return -x + y;\n        case 0x2: return  x - y;\n        case 0x3: return -x - y;\n        case 0x4: return  x + z;\n        case 0x5: return -x + z;\n        case 0x6: return  x - z;\n        case 0x7: return -x - z;\n        case 0x8: return  y + z;\n        case 0x9: return -y + z;\n        case 0xA: return  y - z;\n        case 0xB: return -y - z;\n        case 0xC: return  y + x;\n        case 0xD: return -y + z;\n        case 0xE: return  y - x;\n        case 0xF: return -y - z;\n        default: return 0; // never happens\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Source: http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html\npublic static double grad(int hash, double x, double y, double z)\n{\n    switch(hash & 0xF)\n    {\n        case 0x0: return  x + y;\n        case 0x1: return -x + y;\n        case 0x2: return  x - y;\n        case 0x3: return -x - y;\n        case 0x4: return  x + z;\n        case 0x5: return -x + z;\n        case 0x6: return  x - z;\n        case 0x7: return -x - z;\n        case 0x8: return  y + z;\n        case 0x9: return -y + z;\n        case 0xA: return  y - z;\n        case 0xB: return -y - z;\n        case 0xC: return  y + x;\n        case 0xD: return -y + z;\n        case 0xE: return  y - x;\n        case 0xF: return -y - z;\n        default: return 0; // never happens\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上的源码可以"},{"type":"element","tag":"a","props":{"href":"http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html","rel":["nofollow"]},"children":[{"type":"text","value":"点击这里"}]},{"type":"text","value":"查看。无论如何，上面的两种实现并没有实质差别。他们都是从以下12个向量里随机挑选一个作为梯度向量：\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随机挑选结果其实取决于前一步所计算得出的哈希值（"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"grad()"}]},{"type":"text","value":"函数的第一个参数）。后面3个参数则代表由输入点指向顶点的距离向量（最终拿来与梯度向量进行点积）。"}]},{"type":"element","tag":"h2","props":{"id":"插值整合"},"children":[{"type":"text","value":"插值整合##"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"经过前面的几步计算，我们得出了8个顶点的影响值，并将它们进行平滑插值，得出了最终结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double perlin(double x, double y, double z) {\n    // ...\n\n    double x1, x2, y1, y2;\n    x1 = lerp(    grad (aaa, xf  , yf  , zf),           // The gradient function calculates the dot product between a pseudorandom\n                grad (baa, xf-1, yf  , zf),             // gradient vector and the vector from the input coordinate to the 8\n                u);                                     // surrounding points in its unit cube.\n    x2 = lerp(    grad (aba, xf  , yf-1, zf),           // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\n                grad (bba, xf-1, yf-1, zf),             // values we made earlier.\n                  u);\n    y1 = lerp(x1, x2, v);\n\n    x1 = lerp(    grad (aab, xf  , yf  , zf-1),\n                grad (bab, xf-1, yf  , zf-1),\n                u);\n    x2 = lerp(    grad (abb, xf  , yf-1, zf-1),\n                  grad (bbb, xf-1, yf-1, zf-1),\n                  u);\n    y2 = lerp (x1, x2, v);\n    \n    return (lerp (y1, y2, w)+1)/2;                      // For convenience we bind the result to 0 - 1 (theoretical min/max before is [-1, 1])\n}\n\n// Linear Interpolate\npublic static double lerp(double a, double b, double x) {\n    return a + x * (b - a);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double perlin(double x, double y, double z) {\n    // ...\n\n    double x1, x2, y1, y2;\n    x1 = lerp(    grad (aaa, xf  , yf  , zf),           // The gradient function calculates the dot product between a pseudorandom\n                grad (baa, xf-1, yf  , zf),             // gradient vector and the vector from the input coordinate to the 8\n                u);                                     // surrounding points in its unit cube.\n    x2 = lerp(    grad (aba, xf  , yf-1, zf),           // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\n                grad (bba, xf-1, yf-1, zf),             // values we made earlier.\n                  u);\n    y1 = lerp(x1, x2, v);\n\n    x1 = lerp(    grad (aab, xf  , yf  , zf-1),\n                grad (bab, xf-1, yf  , zf-1),\n                u);\n    x2 = lerp(    grad (abb, xf  , yf-1, zf-1),\n                  grad (bbb, xf-1, yf-1, zf-1),\n                  u);\n    y2 = lerp (x1, x2, v);\n    \n    return (lerp (y1, y2, w)+1)/2;                      // For convenience we bind the result to 0 - 1 (theoretical min/max before is [-1, 1])\n}\n\n// Linear Interpolate\npublic static double lerp(double a, double b, double x) {\n    return a + x * (b - a);\n}\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"利用倍频实现更自然的噪声"},"children":[{"type":"text","value":"利用倍频实现更自然的噪声#"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后让我们再思考下，除了前面所讲的计算，还有其他办法可以令噪声结果更加自然吗？虽然柏林噪声算法一定程度上模拟了自然噪声，但仍没有完全表现出自然噪声的不规律性。举个现实例子，现实地形会有大段连绵、高耸的山地，也会有丘陵和蚀坑，更小点的有大块岩石，甚至更小的鹅卵石块，这都属于地形的一部分。那如何让柏林噪声算法模拟出这样的自然噪声特性，解决方法也很简单：我们可以使用不同的频率（frequencies）和振幅（amplitudes）参数进行多几次柏林噪声计算，然后将结果叠加在一起。频率是指采样数据的间隔，振幅是指返回值的幅度范围。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-6f96e55ed8d87b04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-6f96e55ed8d87b04.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图6：不同频率和振幅参数下的柏林噪声结果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"将所有结果叠加在一起，我们就能得到以下结果："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-c69b2bf9e253defb.png?imageMogr2/auto-orient/strip","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-c69b2bf9e253defb.png"},"children":[]}]},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"图7：图6所有噪声的叠加结果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"很明显，这样的噪声结果更加令人信服。上面的6组噪声被称之为噪声的不同"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"倍频(Octave)"}]},{"type":"text","value":"。随着倍频增大，噪声对于最终叠加噪声的影响程度变小。当然，倍频组数的增加，会线性地增加代码执行时间，在游戏运行时使用噪声算法，再好不要使用超过几组倍频（比如，当你想在60fps下模拟火焰特效时，最好不要这么干）。然而，做数据预处理时，就很适合使用多组倍频叠加来模拟更自然的噪声（比如用于提前生成游戏地形等）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那我们应该分别挑选多大的频率和振幅来进行噪声计算呢？这个可以通过"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"persistence"}]},{"type":"text","value":"参数确定。"},{"type":"element","tag":"a","props":{"href":"http://freespace.virgin.net/hugo.elias/models/m_perlin.htm","rel":["nofollow"]},"children":[{"type":"text","value":"Hugo Elias"}]},{"type":"text","value":"对persistence的定义使用如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-b7093e0ea840d56c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-b7093e0ea840d56c.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://upload-images.jianshu.io/upload_images/1797904-006ffe9e12825253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-01-20-Perlin-map/1797904-006ffe9e12825253.png"},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上公式"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"i"}]},{"type":"text","value":"的值取决于倍频数量，代码实现也很简单："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"复制代码"}]},{"type":"element","tag":"pre","props":{"code":"public double OctavePerlin(double x, double y, double z, int octaves, double persistence) {\n    double total = 0;\n    double frequency = 1;\n    double amplitude = 1;\n    double maxValue = 0;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += perlin(x * frequency, y * frequency, z * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2;\n    }\n    \n    return total/maxValue;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public double OctavePerlin(double x, double y, double z, int octaves, double persistence) {\n    double total = 0;\n    double frequency = 1;\n    double amplitude = 1;\n    double maxValue = 0;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += perlin(x * frequency, y * frequency, z * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2;\n    }\n    \n    return total/maxValue;\n}\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"unity"},"children":[{"type":"text","value":"UNITY"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"准备工作","depth":2,"text":"准备工作##"},{"id":"fade函数","depth":2,"text":"Fade函数##"},{"id":"哈希函数","depth":2,"text":"哈希函数##"},{"id":"梯度函数","depth":2,"text":"梯度函数##"},{"id":"插值整合","depth":2,"text":"插值整合##"}]}},"_type":"markdown","_id":"content:game:2021-01-20-Perlin-map.md","_source":"content","_file":"game/2021-01-20-Perlin-map.md","_extension":"md","date":"2021-01-20"}]