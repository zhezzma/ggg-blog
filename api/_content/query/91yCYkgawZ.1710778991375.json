{"_path":"/game/2021-12-14-untiy-gameplay-ablility-sourcecode","_dir":"game","_draft":false,"_partial":false,"_locale":"","title":"unity gameplay ability源代码解析","description":"github仓库 : https://github.com/sjai013/unity-gameplay-ability-system","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"github仓库 : "},{"type":"element","tag":"a","props":{"href":"https://github.com/sjai013/unity-gameplay-ability-system","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/sjai013/unity-gameplay-ability-system"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个开源系统主要包含了以下内容"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Attribute System  属性系统."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Gameplay Tags  tag用来判断技能是否能够释放,以及检查effect是否能够添加"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Gameplay Effects  技能特效"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ability 技能"}]}]},{"type":"element","tag":"h2","props":{"id":"特效"},"children":[{"type":"text","value":"特效"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GameplayEffectSpec 是特效的runtime"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包含了特效的双方和target"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包含了其他数据等级,持续时间等"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"创建方法"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AbilitySystemCharacter.MakeOutgoingSpec"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameplayEffectSpec.CreateNew"}]}]}]},{"type":"element","tag":"h3","props":{"id":"添加特效到角色"},"children":[{"type":"text","value":"添加特效到角色"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public bool ApplyGameplayEffectSpecToSelf(GameplayEffectSpec geSpec)\n{\n        if (geSpec == null) return true;\n        //检查特效是否能被应用到角色身上,比如如果是无敌状态则不能添加\n        bool tagRequirementsOK = CheckTagRequirementsMet(geSpec);\n\n        if (tagRequirementsOK == false) return false;\n\n\n        switch (geSpec.GameplayEffect.gameplayEffect.DurationPolicy)\n        {\n            case EDurationPolicy.HasDuration:\n            case EDurationPolicy.Infinite:\n                    //周期性的特效\n                    ApplyDurationalGameplayEffect(geSpec);\n                    break;\n            case EDurationPolicy.Instant:\n                    //可以立即应用的特效\n                    ApplyInstantGameplayEffect(geSpec);\n                    return true;\n        }\n\n        return true;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"检查特效tag是否能够添加到角色身上"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List<GameplayTagScriptableObject>();\nfor (var i = 0; i < AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//建立当前角色的所有特效的GrantedTags\nvar appliedTags = new List<GameplayTagScriptableObject>();\nfor (var i = 0; i < AppliedGameplayEffects.Count; i++)\n{\n    appliedTags.AddRange(AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags);\n}\n\n//检查特效上的ApplicationTagRequirements的RequireTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags.Length; i++)\n{\n    if (!appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.RequireTags[i]))\n    {\n            return false;\n    }\n}\n\n//检查特效上的ApplicationTagRequirements的IgnoreTags字段\nfor (var i = 0; i < geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags.Length; i++)\n{\n    if (appliedTags.Contains(geSpec.GameplayEffect.gameplayEffectTags.ApplicationTagRequirements.IgnoreTags[i]))\n    {\n            return false;\n    }\n}\n\nreturn true;\n"}]}]},{"type":"element","tag":"h3","props":{"id":"特效gameplayeffectscriptableobject本身"},"children":[{"type":"text","value":"特效"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GameplayEffectScriptableObject"}]},{"type":"text","value":"本身"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameplayEffectDefinitionContainer  定义了特效的使用效果与条件"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DurationPolicy和DurationModifier和DurationMultiplier构成了该特效的持续时间,以及是否立即使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DurationModifier.CalculateMagnitude(this).GetValueOrDefault() *.DurationMultiplier"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modifiers 该特效对属性的修改"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ConditionalGameplayEffects  暂时没看到使用的地方??"}]}]}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"   public struct GameplayEffectDefinitionContainer\n    {\n        /// <summary>\n        /// 持续方案,,是立即,还是持续\n        /// </summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// <summary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// </summary>\n        public float DurationMultiplier;\n\n\n        /// <summary>\n        /// 该特效对属性的修改\n        /// </summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// <summary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// </summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   public struct GameplayEffectDefinitionContainer\n    {\n        /// <summary>\n        /// 持续方案,,是立即,还是持续\n        /// </summary>\n        public EDurationPolicy DurationPolicy;\n    //修改策略\n        public ModifierMagnitudeScriptableObject DurationModifier;\n\n        /// <summary>\n        /// 该特效的持续时间，如果特效有一个有限的持续时间的话\n        /// </summary>\n        public float DurationMultiplier;\n\n\n        /// <summary>\n        /// 该特效对属性的修改\n        /// </summary>\n        public GameplayEffectModifier[] Modifiers;\n\n        /// <summary>\n        /// Other GE to apply to the source ability system, based on presence of tags on source\n        /// </summary>\n        public ConditionalGameplayEffectContainer[] ConditionalGameplayEffects;\n    }\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GameplayEffectTags   定义处理特效之间的关系"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"   public struct GameplayEffectTags\n   {\n        /// <summary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// </summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// <summary>\n        /// effect添加到人身上前,需要检查的条件\n        /// </summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"   public struct GameplayEffectTags\n   {\n        /// <summary>\n        /// 授予角色拥有的特殊tag,比如:无敌,隐身,诅咒\n        /// \n        /// 比如a技能,给敌人添加了一个诅咒(tagA)\n        /// 第二个技能依据是否有这个诅咒这个前置特效,有的话才能应用技能特效,则设置ApplicationTagRequirements.RequireTags中添加taga\n        /// \n        /// \n        /// 比如配置怪物免疫火系魔法\n        /// 则添加一个免疫火系魔法的tagb\n        /// 火系技能则在ApplicationTagRequirements中的IgnoreTags添加一个tagb\n        /// \n        /// \n        /// </summary>\n       [SerializeField] public GameplayTagScriptableObject[] GrantedTags;\n\n\n        /// <summary>\n        /// effect添加到人身上前,需要检查的条件\n        /// </summary>\n       [SerializeField] public GameplayTagRequireIgnoreContainer ApplicationTagRequirements;\n\n   }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"技能"},"children":[{"type":"text","value":"技能"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"AbstractAbilitySpec是技能的runtime,包含了"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ability的scriptobject"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ability的其他数据例如等级,词条等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色字段"}]}]},{"type":"element","tag":"h3","props":{"id":"技能释放流程"},"children":[{"type":"text","value":"技能释放流程"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual IEnumerator TryActivateAbility()\n{\n   //检查该能力是否能被激活\n   //1. 检查gameplaytags\n   //2. 检查cost\n   //3. 检查cooldown\n   if (!CanActivateAbility()) yield break;\n\n   isActive = true;\n   //激活能力前处理\n   yield return PreActivate();\n   //激活这个能力\n   yield return ActivateAbility();\n   //能力结束\n   EndAbility();\n\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ability的cost和cooldown都使用了GameplayEffectScriptableObject,这也是这个系统比较蛋疼的地方,就是每个ability都需要建立cost和cooldown的object."}]},{"type":"element","tag":"h3","props":{"id":"检查cost"},"children":[{"type":"text","value":"检查cost"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查cost特效身上的Modifiers字段,并计算最终值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后和角色属性进行对比"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Modifiers可以有多条,且有计算公式"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i < geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue < 0) return false;\n\n        }\n        return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual bool CheckCost()\n{\n        if (this.Ability.Cost == null) return true;\n        var geSpec = this.Owner.MakeOutgoingSpec(this.Ability.Cost, this.Level);\n        // If this isn't an instant cost, then assume it passes cooldown check\n        if (geSpec.GameplayEffect.gameplayEffect.DurationPolicy != EDurationPolicy.Instant) return true;\n    \n    //Modifiers可以包含多条,可以是属性会根据特效本身的等级做改变\n        for (var i = 0; i < geSpec.GameplayEffect.gameplayEffect.Modifiers.Length; i++)\n        {\n            var modifier = geSpec.GameplayEffect.gameplayEffect.Modifiers[i];\n    \n            // Only worry about additive.  Anything else passes.\n            if (modifier.ModifierOperator != EAttributeModifier.Add) continue;\n            var costValue = (modifier.ModifierMagnitude.CalculateMagnitude(geSpec) * modifier.Multiplier).GetValueOrDefault();\n            \n        //获取角色身上该属性的值\n            this.Owner.AttributeSystem.GetAttributeValue(modifier.Attribute, out var attributeValue);\n            \n            // 如果属性值+消耗的值小于0则代表技能失败\n            if (attributeValue.CurrentValue + costValue < 0) return false;\n\n        }\n        return true;\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"检查cooldow"},"children":[{"type":"text","value":"检查cooldow"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"冷却时间特效最终会被添加到人物的身上"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"该函数,主要是比对并找到人身上同tag的特效.然后检查该特效的TotalDuration"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i < this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag < grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag < cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public virtual AbilityCooldownTime CheckCooldown()\n{\n        float maxDuration = 0;\n        if (this.Ability.Cooldown == null) return new AbilityCooldownTime();\n        var cooldownTags = this.Ability.Cooldown.gameplayEffectTags.GrantedTags;\n\n        float longestCooldown = 0f;\n\n        // Check if the cooldown tag is granted to the player, and if so, capture the remaining duration for that tag\n        for (var i = 0; i < this.Owner.AppliedGameplayEffects.Count; i++)\n        {\n            var grantedTags = this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iTag = 0; iTag < grantedTags.Length; iTag++)\n            {\n                    for (var iCooldownTag = 0; iCooldownTag < cooldownTags.Length; iCooldownTag++)\n                    {\n                        if (grantedTags[iTag] == cooldownTags[iCooldownTag])\n                        {\n                                // 如果有一个策略是无限的..则返回一个float.maxvalue\n                                if (this.Owner.AppliedGameplayEffects[i].spec.GameplayEffect.gameplayEffect.DurationPolicy == EDurationPolicy.Infinite) return new AbilityCooldownTime()\n                                {\n                                    TimeRemaining = float.MaxValue,\n                                    TotalDuration = 0\n                                };\n        \n                                var durationRemaining = this.Owner.AppliedGameplayEffects[i].spec.DurationRemaining;\n        \n                                if (durationRemaining > longestCooldown)\n                                {\n                                    longestCooldown = durationRemaining;\n                                    maxDuration = this.Owner.AppliedGameplayEffects[i].spec.TotalDuration;\n                                }\n                        }\n    \n                    }\n            }\n        }\n\n        return new AbilityCooldownTime()\n        {\n            TimeRemaining = longestCooldown,\n            TotalDuration = maxDuration\n        };\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"检查abilitytags"},"children":[{"type":"text","value":"检查abilitytags"}]},{"type":"element","tag":"h4","props":{"id":"abilitytags"},"children":[{"type":"text","value":"abilitytags"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义了一些tag用来释放前进行检查是否能释放该技能"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"例如检查自身是否能够匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OwnerTags"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果是指定目标则检查目标身上是否能够匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"TargetTags"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SourceTags?暂时没有好的理解"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"[Serializable]\npublic struct AbilityTags\n{\n    /// <summary>\n    /// This tag describes the Gameplay Ability\n    /// </summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// <summary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// <summary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// <summary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Serializable]\npublic struct AbilityTags\n{\n    /// <summary>\n    /// This tag describes the Gameplay Ability\n    /// </summary>\n    [SerializeField] public GameplayTagScriptableObject AssetTag;\n\n    /// <summary>\n    /// This ability can only be activated if the owner character has all of the Required tags\n    /// and none of the Ignore tags.  Usually, the owner is the source as well.\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer OwnerTags;\n\n    /// <summary>\n    /// This ability can only be activated if the source character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer SourceTags;\n\n    /// <summary>\n    /// This ability can only be activated if the target character has all of the Required tags\n    /// and none of the Ignore tags\n    /// </summary>\n    [SerializeField] public GameplayTagRequireIgnoreContainer TargetTags;\n\n}\n"}]}]},{"type":"element","tag":"h4","props":{"id":"checkgameplaytags被定义在每个ability下然后对其重写"},"children":[{"type":"text","value":"CheckGameplayTags()被定义在每个ability下然后对其重写"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AscHasAllTags  用来检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RequireTags"}]},{"type":"text","value":" ,检查人身上特效的tags是否包含这些,如果没有包含则检查失败"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AscHasNoneTags 用来检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IgnoreTags"}]},{"type":"text","value":" ,检查人身上特效的tags是否包含这些,如果包含则检查失败"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public override bool CheckGameplayTags()\n{\n        return AscHasAllTags(Owner, this.Ability.AbilityTags.OwnerTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.OwnerTags.IgnoreTags)\n                && AscHasAllTags(Owner, this.Ability.AbilityTags.SourceTags.RequireTags)\n                && AscHasNoneTags(Owner, this.Ability.AbilityTags.SourceTags.IgnoreTags)\n                && AscHasAllTags(Target, this.Ability.AbilityTags.TargetTags.RequireTags)\n                && AscHasNoneTags(Target, this.Ability.AbilityTags.TargetTags.IgnoreTags);\n}\n\nprotected virtual bool AscHasAllTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = false;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = true;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n\nprotected virtual bool AscHasNoneTags(AbilitySystemCharacter asc, GameplayTagScriptableObject[] tags)\n{\n    // If the input ASC is not valid, assume check passed\n    if (!asc) return true;\n\n    for (var iAbilityTag = 0; iAbilityTag < tags.Length; iAbilityTag++)\n    {\n        var abilityTag = tags[iAbilityTag];\n\n        bool requirementPassed = true;\n        for (var iAsc = 0; iAsc < asc.AppliedGameplayEffects.Count; iAsc++)\n        {\n            GameplayTagScriptableObject[] ascGrantedTags = asc.AppliedGameplayEffects[iAsc].spec.GameplayEffect.gameplayEffectTags.GrantedTags;\n            for (var iAscTag = 0; iAscTag < ascGrantedTags.Length; iAscTag++)\n            {\n                if (ascGrantedTags[iAscTag] == abilityTag)\n                {\n                    requirementPassed = false;\n                }\n            }\n        }\n        // If any ability tag wasn't found, requirements failed\n        if (!requirementPassed) return false;\n    }\n    return true;\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"特效","depth":2,"text":"特效","children":[{"id":"添加特效到角色","depth":3,"text":"添加特效到角色"},{"id":"特效gameplayeffectscriptableobject本身","depth":3,"text":"特效GameplayEffectScriptableObject本身"}]},{"id":"技能","depth":2,"text":"技能","children":[{"id":"技能释放流程","depth":3,"text":"技能释放流程"},{"id":"检查cost","depth":3,"text":"检查cost"},{"id":"检查cooldow","depth":3,"text":"检查cooldow"},{"id":"检查abilitytags","depth":3,"text":"检查abilitytags"}]}]}},"_type":"markdown","_id":"content:game:2021-12-14-untiy-gameplay-ablility-sourcecode.md","_source":"content","_file":"game/2021-12-14-untiy-gameplay-ablility-sourcecode.md","_extension":"md","date":"2021-12-14"}