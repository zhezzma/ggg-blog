{"_path":"/dotnet/2020-11-13-reflection-method","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":".NET Core/Framework 创建委托以大幅度提高反射调用的性能","description":"都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为反射得到的方法创建一个委托，此后调用此委托将能够提高近乎直接调用方法本身的性能。（当然 Emit 也能够帮助我们显著提升性能，不过直接得到可以调用的委托不是更加方便吗？）"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h3","props":{"id":"性能对比数据"},"children":[{"type":"text","value":"性能对比数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"性能对比数据","src":"/images/2020-11-13-Reflection-Method/20180227195855828"},"children":[]},{"type":"text","value":"\n▲ 没有什么能够比数据更有说服力（注意后面两行是有秒数的）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可能我还需要解释一下那五行数据的含义："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"直接调用（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"应该没有什么比直接调用函数本身更有性能优势的吧"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"做一个跟直接调用的方法功能一模一样的委托（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"本文重点"}]},{"type":"text","value":" 将反射出来的方法创建一个委托，然后调用这个委托（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"看看吧，性能跟直接调差别也不大嘛"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"先反射得到方法，然后一直调用这个方法（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缓存都不用，从头开始反射然后调用得到的方法（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"100 多倍的性能损失了"}]},{"type":"text","value":"）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是测试代码，可以更好地理解上图数据的含义："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace Walterlv.Demo\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // 调用的目标实例。\n            var instance = new StubClass();\n\n            // 使用反射找到的方法。\n            var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) });\n            Assert.IsNotNull(method);\n\n            // 将反射找到的方法创建一个委托。\n            var func = InstanceMethodBuilder<int, int>.CreateInstanceMethod(instance, method);\n\n            // 跟被测方法功能一样的纯委托。\n            Func<int, int> pureFunc = value => value;\n\n            // 测试次数。\n            var count = 10000000;\n\n            // 直接调用。\n            var watch = new Stopwatch();\n            watch.Start();\n            for (var i = 0; i < count; i++)\n            {\n                var result = instance.Test(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接调用\");\n\n            // 使用同样功能的 Func 调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = pureFunc(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用\");\n\n            // 使用反射创建出来的委托调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = func(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用\");\n\n            // 使用反射得到的方法缓存调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = method.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用\");\n\n            // 直接使用反射调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) })\n                    ?.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接使用反射调用\");\n        }\n\n        private class StubClass\n        {\n            public int Test(int i)\n            {\n                return i;\n            }\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace Walterlv.Demo\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // 调用的目标实例。\n            var instance = new StubClass();\n\n            // 使用反射找到的方法。\n            var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) });\n            Assert.IsNotNull(method);\n\n            // 将反射找到的方法创建一个委托。\n            var func = InstanceMethodBuilder<int, int>.CreateInstanceMethod(instance, method);\n\n            // 跟被测方法功能一样的纯委托。\n            Func<int, int> pureFunc = value => value;\n\n            // 测试次数。\n            var count = 10000000;\n\n            // 直接调用。\n            var watch = new Stopwatch();\n            watch.Start();\n            for (var i = 0; i < count; i++)\n            {\n                var result = instance.Test(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接调用\");\n\n            // 使用同样功能的 Func 调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = pureFunc(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用\");\n\n            // 使用反射创建出来的委托调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = func(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用\");\n\n            // 使用反射得到的方法缓存调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = method.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用\");\n\n            // 直接使用反射调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) })\n                    ?.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接使用反射调用\");\n        }\n\n        private class StubClass\n        {\n            public int Test(int i)\n            {\n                return i;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"如何实现"},"children":[{"type":"text","value":"如何实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现的关键就在于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MethodInfo.CreateDelegate"}]},{"type":"text","value":" 方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此方法有两个重载："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要求传入一个类型，而这个类型就是应该转成的委托的类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拿上面的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StubClass"}]},{"type":"text","value":" 来说明会更直观一些："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"private class StubClass\n{\n    public int Test(int i)\n    {\n        return i;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private class StubClass\n{\n    public int Test(int i)\n    {\n        return i;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前者得到的委托相当于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int Test(int i)"}]},{"type":"text","value":" 方法，后者得到的委托相当于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int Test(StubClass instance, int i)"}]},{"type":"text","value":" 方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单独使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateDelegate"}]},{"type":"text","value":" 方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics.Contracts;\n\nnamespace Walterlv.Demo\n{\n    public static class InstanceMethodBuilder<T, TReturnValue>\n    {\n        /// <summary>\n        /// 调用时就像 var result = func(t)。\n        /// </summary>\n        [Pure]\n        public static Func<T, TReturnValue> CreateInstanceMethod<TInstanceType>(TInstanceType instance, MethodInfo method)\n        {\n            if (instance == null) throw new ArgumentNullException(nameof(instance));\n            if (method == null) throw new ArgumentNullException(nameof(method));\n\n            return (Func<T, TReturnValue>) method.CreateDelegate(typeof(Func<T, TReturnValue>), instance);\n        }\n\n        /// <summary>\n        /// 调用时就像 var result = func(this, t)。\n        /// </summary>\n        [Pure]\n        public static Func<TInstanceType, T, TReturnValue> CreateMethod<TInstanceType>(MethodInfo method)\n        {\n            if (method == null)\n                throw new ArgumentNullException(nameof(method));\n\n            return (Func<TInstanceType, T, TReturnValue>) method.CreateDelegate(typeof(Func<TInstanceType, T, TReturnValue>));\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics.Contracts;\n\nnamespace Walterlv.Demo\n{\n    public static class InstanceMethodBuilder<T, TReturnValue>\n    {\n        /// <summary>\n        /// 调用时就像 var result = func(t)。\n        /// </summary>\n        [Pure]\n        public static Func<T, TReturnValue> CreateInstanceMethod<TInstanceType>(TInstanceType instance, MethodInfo method)\n        {\n            if (instance == null) throw new ArgumentNullException(nameof(instance));\n            if (method == null) throw new ArgumentNullException(nameof(method));\n\n            return (Func<T, TReturnValue>) method.CreateDelegate(typeof(Func<T, TReturnValue>), instance);\n        }\n\n        /// <summary>\n        /// 调用时就像 var result = func(this, t)。\n        /// </summary>\n        [Pure]\n        public static Func<TInstanceType, T, TReturnValue> CreateMethod<TInstanceType>(MethodInfo method)\n        {\n            if (method == null)\n                throw new ArgumentNullException(nameof(method));\n\n            return (Func<TInstanceType, T, TReturnValue>) method.CreateDelegate(typeof(Func<TInstanceType, T, TReturnValue>));\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"泛型的多参数版本可以使用泛型类型生成器生成，我在 "},{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/WPwalter/article/details/79216183","rel":["nofollow"]},"children":[{"type":"text","value":"生成代码，从 "}]},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"到"}]},{"type":"text","value":" —— 自动生成多个类型的泛型 - 吕毅 一文中写了一个泛型生成器，可以稍加修改以便适应这种泛型类。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"性能对比数据","depth":3,"text":"性能对比数据"},{"id":"如何实现","depth":3,"text":"如何实现"}]}},"_type":"markdown","_id":"content:dotnet:2020-11-13-Reflection-Method.md","_source":"content","_file":"dotnet/2020-11-13-Reflection-Method.md","_extension":"md","date":"2020-11-13"}