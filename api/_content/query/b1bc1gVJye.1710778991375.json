[{"_path":"/dotnet/2022-08-15-equal-hashcode","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","description":"先看一个不负责任的写法//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n  ","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看一个不负责任的写法"}]},{"type":"element","tag":"pre","props":{"code":"//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n        }\n        public override bool Equals(object obj)\n        {\n            return true;\n        }\n \n    }\n    class Program\n    {\n            \n        static void Sum<T>() where T : MyMethod, new()\n        {\n            T t1 = new T();\n            T t2 = new T();\n             \n            t1.a = 3; t2.a = 4;//不会报错           \n             //t1.a=3;t2.a=3;报错，字典中已经存在相同键\n             Dictionary<MyMethod, int> d = new Dictionary<MyMethod, int>();\n            d.Add(t1, 1);\n            d.Add(t2, 2);\n            \n            \n        }\n        static void Main(string[] args)\n        {\n            \n            Sum<MyMethod>();\n            Console.Read();\n \n        }\n       \n    }\n \n}\n \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//先看一个不负责任的写法\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\n \n \nnamespace nothing\n{\n    class MyMethod\n    {\n        //用a值代替Hash值\n        public int a { get; set; }\n         public override int GetHashCode()\n        {\n            return a;\n        }\n        public override bool Equals(object obj)\n        {\n            return true;\n        }\n \n    }\n    class Program\n    {\n            \n        static void Sum<T>() where T : MyMethod, new()\n        {\n            T t1 = new T();\n            T t2 = new T();\n             \n            t1.a = 3; t2.a = 4;//不会报错           \n             //t1.a=3;t2.a=3;报错，字典中已经存在相同键\n             Dictionary<MyMethod, int> d = new Dictionary<MyMethod, int>();\n            d.Add(t1, 1);\n            d.Add(t2, 2);\n            \n            \n        }\n        static void Main(string[] args)\n        {\n            \n            Sum<MyMethod>();\n            Console.Read();\n \n        }\n       \n    }\n \n}\n \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再说Dictionary的Add的具体实现,ILSpy反编译中C#Dictionary的Add方法源码："}]},{"type":"element","tag":"pre","props":{"code":"public void Add(TKey key, TValue value)\n{\n    this.Insert(key, value, true);\n}\n \n \nprivate void Insert(TKey key, TValue value, bool add)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n    if (this.buckets == null)\n    {\n        this.Initialize(0);\n    }\n    \n    int num = this.comparer.GetHashCode(key) & 2147483647;\n    int num2 = num % this.buckets.Length;\n    int num3 = 0;\n    for (int i = this.buckets[num2]; i >= 0; i = this.entries[i].next)\n    {\n        //如果hash值和字典中某个值的hash值相等 且 两个值的Equals返回值为True Trow 异常：已添加了具有相同键的项。\n        if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))\n        {\n            if (add)\n            {\n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            this.entries[i].value = value;\n            this.version++;\n            return;\n        }\n        num3++;\n    }\n    int num4;\n    if (this.freeCount > 0)\n    {\n        num4 = this.freeList;\n        this.freeList = this.entries[num4].next;\n        this.freeCount--;\n    }\n    else\n    {\n        if (this.count == this.entries.Length)\n        {\n            this.Resize();\n            num2 = num % this.buckets.Length;\n        }\n        num4 = this.count;\n        this.count++;\n    }\n    this.entries[num4].hashCode = num;\n    this.entries[num4].next = this.buckets[num2];\n    this.entries[num4].key = key;\n    this.entries[num4].value = value;\n    this.buckets[num2] = num4;\n    this.version++;\n    if (num3 > 100 && HashHelpers.IsWellKnownEqualityComparer(this.comparer))\n    {\n        this.comparer = (IEqualityComparer<TKey>)HashHelpers.GetRandomizedEqualityComparer(this.comparer);\n        this.Resize(this.entries.Length, true);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void Add(TKey key, TValue value)\n{\n    this.Insert(key, value, true);\n}\n \n \nprivate void Insert(TKey key, TValue value, bool add)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n    if (this.buckets == null)\n    {\n        this.Initialize(0);\n    }\n    \n    int num = this.comparer.GetHashCode(key) & 2147483647;\n    int num2 = num % this.buckets.Length;\n    int num3 = 0;\n    for (int i = this.buckets[num2]; i >= 0; i = this.entries[i].next)\n    {\n        //如果hash值和字典中某个值的hash值相等 且 两个值的Equals返回值为True Trow 异常：已添加了具有相同键的项。\n        if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))\n        {\n            if (add)\n            {\n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            this.entries[i].value = value;\n            this.version++;\n            return;\n        }\n        num3++;\n    }\n    int num4;\n    if (this.freeCount > 0)\n    {\n        num4 = this.freeList;\n        this.freeList = this.entries[num4].next;\n        this.freeCount--;\n    }\n    else\n    {\n        if (this.count == this.entries.Length)\n        {\n            this.Resize();\n            num2 = num % this.buckets.Length;\n        }\n        num4 = this.count;\n        this.count++;\n    }\n    this.entries[num4].hashCode = num;\n    this.entries[num4].next = this.buckets[num2];\n    this.entries[num4].key = key;\n    this.entries[num4].value = value;\n    this.buckets[num2] = num4;\n    this.version++;\n    if (num3 > 100 && HashHelpers.IsWellKnownEqualityComparer(this.comparer))\n    {\n        this.comparer = (IEqualityComparer<TKey>)HashHelpers.GetRandomizedEqualityComparer(this.comparer);\n        this.Resize(this.entries.Length, true);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当每次调用Dictionary的Add方法时，参数都将与Dictionary中的值进行Equals，大家都知道DIctionary是用Hash值进行存储的，而hash值的计算方法是通过Object.GetHashCode实现的，如果这2个方法不一致，那么很容易就出现问题，特别是Dictionary中的Add方法这种情况。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"个人理解Dictionary的Add方法的实现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Add()->GetHashCode(),Equals()->判断2个hashcode是否相等 和Equals返回值是否为True->若同时成立，抛异常。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GetHashCode的目的不是为一个对象生成唯一的标识符，而是为了实现基于哈希表的数据结构，如Dictionary<K, V>或HashSet。 哈希函数需要确保如果x == ==y，那么x.GetHashCode()==  y.GetHashCode()，但反过来就不对了：两个不同的对象可以有相同的哈希代码。这种情况被称为哈希碰撞。 如果存在碰撞，哈希表结构仍然可以工作，但它们的运行速度较慢，因为你的程序必须花时间来分辨你要搜索的是哪个碰撞对象。因此，一个好的散列函数将努力使碰撞最小化。(注意，如果一个类有232个以上的可能值，要完全避免碰撞在数学上是不可能的，因为有鸽子笼原则）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么，你如何为你的类写一个好的GetHashCode实现呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"做一些复杂的数学运算，将你的类的每一个字段转换为int，然后通过剖析来确定其中的系数的最佳值？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据Troelsen的说法，不需要。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只要在你的 \"最独特 \"的字符串字段上调用GetHashCode()就可以了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"写System.String.GetHashCode的开发者知道他们在做什么，所以只要使用它，你就会自动利用他们的 \"坚实的哈希码算法\"。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2022-08-15-equal-hashcode.md","_source":"content","_file":"dotnet/2022-08-15-equal-hashcode.md","_extension":"md","date":"2022-08-15"},{"_path":"/dotnet/2021-05-01-converting-between-structs-and-byte-arrays","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Converting between Structs and Byte Arrays","description":"In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more information through inheritance, attributes, and more.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more information through inheritance, attributes, and more."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"However, sometimes we need to extract the data contained in these types – for example for sending network messages, or saving to disk. In this post we will look into converting between structs and byte arrays, to make exactly this possible."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We will compare different ways of doing so, and analyse them for performance and easy of use."}]},{"type":"element","tag":"h2","props":{"id":"why-byte-arrays"},"children":[{"type":"text","value":"Why byte arrays?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The reason we will be looking into serialising our data into byte arrays is because these are essentially the most fundamental data storage format. We can easily write them to a network buffer or stream, or to a file."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are many alternatives and none of them will be right for every single use case. For example, I like to use JSON files to store settings, scripts, and text-based assets, as well as asset meta data."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In those cases performance is not the most important consideration. Instead it is more valuable to be able to edit and review files easily inside a text editor."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In situations where performance is important however – such as the mentioned networking or compact file storage – serialising only the relevant data itself and skipping the encoding and formatting inherent to clear text files can be key."}]},{"type":"element","tag":"h2","props":{"id":"why-structures"},"children":[{"type":"text","value":"Why structures?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several reasons for why we are talking about structures specifically."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"First, I want to make a clear distinction between data and behaviour, by using a type that contains exactly the data we are interested in serialising."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Secondly, structures are much more reliable and controllable when it comes to binary data layout. We will see how this is important for our last method of serialisation."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Overall, we can use structures to directly represent the data that will be written into our byte array. For our example of networking this means that we have a clear one to one correspondence between our structures and our network messages."}]},{"type":"element","tag":"h2","props":{"id":"binaryformatter"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In our first method of converting between structs and byte arrays, we will make use of .NET’s "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":" class."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The entire purpose of that class is to serialise an object into binary format (i.e. a byte array) – as well as deserialising the same back into objects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The class offers a lot of functionality – most of which we are not interested in here. Of interest to us are only two methods: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Serialize()"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Deserialize()"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"These methods allow us to read/write our data to any stream. In many cases we could use this to write to a network – or file – buffer or stream directly. For our purpose – and for ease of testing, we will use the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MemoryStream"}]},{"type":"text","value":" class which is little more than a stream wrapper around a byte array in the first place."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here are two generic methods that do exactly this:"}]},{"type":"element","tag":"pre","props":{"code":"public static byte[] Serialize<T>(T data)\n    where T : struct\n{\n    var formatter = new BinaryFormatter();\n    var stream = new MemoryStream();\n    formatter.Serialize(stream, data);\n    return stream.ToArray();\n}\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var stream = new MemoryStream(array);\n    var formatter = new BinaryFormatter();\n    return (T)formatter.Deserialize(stream);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static byte[] Serialize<T>(T data)\n    where T : struct\n{\n    var formatter = new BinaryFormatter();\n    var stream = new MemoryStream();\n    formatter.Serialize(stream, data);\n    return stream.ToArray();\n}\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var stream = new MemoryStream(array);\n    var formatter = new BinaryFormatter();\n    return (T)formatter.Deserialize(stream);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"These methods can now be easily used like this:"}]},{"type":"element","tag":"pre","props":{"code":"[Serializable] // BinaryFormatter needs this attribute\nstruct MyStruct\n{\n    // some fields here\n}\n\nvar data = new MyStruct();\nvar bytes = Serialize(data);\nvar data2 = Deserialize<MyStruct>(bytes);\n// data and data2 now contain the same values\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[Serializable] // BinaryFormatter needs this attribute\nstruct MyStruct\n{\n    // some fields here\n}\n\nvar data = new MyStruct();\nvar bytes = Serialize(data);\nvar data2 = Deserialize<MyStruct>(bytes);\n// data and data2 now contain the same values\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This looks great!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It seems that we have found a solution that is both easy to use, and requires almost no work if we want to expand it. Allowing for the conversion of new structs simple requires the addition of the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Serializable"}]},{"type":"text","value":" attribute, while we have to do nothing at all if we modify our structures to include more, less, or different data."}]},{"type":"element","tag":"h3","props":{"id":"performance"},"children":[{"type":"text","value":"Performance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"How about performance?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I wrote a little test that both serialises and deserialises hundreds of thousands of times, and repeats that process several times to make sure we get accurate results. You can find the full code of it "},{"type":"element","tag":"a","props":{"href":"https://github.com/amulware/genericgamedev-tests/tree/master/src/StructByteArrayConversion","rel":["nofollow"]},"children":[{"type":"text","value":"on my GitHub"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here are the results:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":",\n– converting a 16 byte structs to an array one million times takes 4.86 seconds;\n– converting an array to a 16 byte struct one million times takes 3.85 seconds."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This means that a single call to either of our methods takes less than 5 microseconds."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"That is pretty good!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"With this performance we can easily write and read thousands of networking messages per second before we will notice the performance impact. That is easily enough for most games and other real-time applications."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There is another kind of performance measurement that is important however – and especially so when it comes to networking: Bandwidth."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The struct I ran the tests with consisted of exactly 16 bytes. That means that in principle we should be able to write it into a byte array with length 16. The BinaryFormatter however – and this is related to the other features it has – writes a total of 218 bytes to the array."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Suffice it to say: That is a whole lot more."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The advantage of this is, that the object that is deserialised will actually be of the correct type. I merely made the method generic so that we could perform the cast and return the structure boxed in the result of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter.Deserialize()"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are cases were we care less about the amount of data, and prefer to handle our data in this way. For this post however, I want to find a method that results in an array as small as possible."}]},{"type":"element","tag":"h2","props":{"id":"binarywriterbinaryreader"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Our second case study will be two other .NET classes: "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.io.binaryreader(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":" and "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.io.binarywriter(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"BinaryReader"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"These classes are much simpler. They do little more than allowing us to write and read primitive types like integers and booleans to and from an arbitrary stream."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This means that we cannot write the entire structure to our stream with just a single line of code any more. Instead we need to write and read all fields manually:"}]},{"type":"element","tag":"pre","props":{"code":"struct MyStruct\n{\n    int anInteger;\n    float aFloat;\n    long aLong;\n\n    public byte[] ToArray()\n    {\n        var stream = new MemoryStream();\n        var writer = new BinaryWriter(stream);\n\n        writer.Write(this.anInteger);\n        writer.Write(this.aFloat);\n        writer.Write(this.aLong);\n\n        return stream.ToArray();\n    }\n\n    public static MyStruct FromArray(byte[] bytes)\n    {\n        var reader = new BinaryReader(new MemoryStream(bytes));\n\n        var s = default(MyStruct);\n\n        s.anInteger = reader.ReadInt32();\n        s.aFloat = reader.ReadSingle();\n        s.aLong = reader.ReadInt64();\n\n        return s;\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct MyStruct\n{\n    int anInteger;\n    float aFloat;\n    long aLong;\n\n    public byte[] ToArray()\n    {\n        var stream = new MemoryStream();\n        var writer = new BinaryWriter(stream);\n\n        writer.Write(this.anInteger);\n        writer.Write(this.aFloat);\n        writer.Write(this.aLong);\n\n        return stream.ToArray();\n    }\n\n    public static MyStruct FromArray(byte[] bytes)\n    {\n        var reader = new BinaryReader(new MemoryStream(bytes));\n\n        var s = default(MyStruct);\n\n        s.anInteger = reader.ReadInt32();\n        s.aFloat = reader.ReadSingle();\n        s.aLong = reader.ReadInt64();\n\n        return s;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using these methods is similarly easy to the ones above:"}]},{"type":"element","tag":"pre","props":{"code":"var data = new MyStruct();\nvar array = data.ToArray();\nvar data2 = MyStruct.FromArray(array);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var data = new MyStruct();\nvar array = data.ToArray();\nvar data2 = MyStruct.FromArray(array);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this case, the returned array is indeed exactly 16 bytes long."}]},{"type":"element","tag":"h3","props":{"id":"performance-1"},"children":[{"type":"text","value":"Performance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"But how does this manual approach measure up in performance?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Very well!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In my test, the times for serialising and deserialising went from 4.86 and 3.85 down to 0.50 and 0.20 seconds respectively (again for one million conversions each)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It turns out this approach is not only space efficient, but it is also around ten times faster than the previous one – seemingly no reason to look back!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In fact, there is an optimisation we can make to increase performance even further: We do not have to create new "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MemoryStream"}]},{"type":"text","value":"s and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":"s for each method call. Instead we can reuse them – either by having static ones (watch out for thread-safety!) or by keeping them in whatever object manages for example our network traffic."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Doing so drops my measured time down to 0.14 and 0.11 seconds respectively."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that the same optimisation can be applied to the first method. However – while positive – the performance increase is much less than in this case, relative to the overall much worse time."}]},{"type":"element","tag":"h3","props":{"id":"some-concerns"},"children":[{"type":"text","value":"Some concerns"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If we do look back to the code however, note how if we add another structure that we would like to serialise, we have to add the two methods to it, and adapt them to its fields."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Further, if we change one of our structures, we have to make sure to reflect that change in both of these methods. We are bound to forget – especially when adding a new field – which could easily result in a small debugging nightmare."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ideally we can find a solution that is fast, uses little space, and does not require us to continuously maintain our serialisation code."}]},{"type":"element","tag":"h2","props":{"id":"marshalling"},"children":[{"type":"text","value":"Marshalling"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The last approach we will take a look at is that of marshalling."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Marshalling refers to using both managed and unmanaged data and the transfer between them. By default, any object created in C# lives in managed memory, which has a lot of advantages – such as automatic garbage collection. Using unmanaged memory on the other hand is more difficult in C#, and requires us to allocate and free space manually. If we forget to do so, we may cause memory leaks that will eventually cause our application to crash."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"All of the functionality we are interested in can be found in the static "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal(v=vs.100).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"Marshal"}]},{"type":"text","value":" class."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Specifically, we will use:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.SizeOf()"}]},{"type":"text","value":"\nto determine the byte size of our structs;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.AllocHGlobal()"}]},{"type":"text","value":"\nto allocate unmanaged memory;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.StructureToPtr()"}]},{"type":"text","value":"\nto marshal (copy) our structure to the allocated unmanaged memory;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.PtrToStructure()"}]},{"type":"text","value":"\nto marshal (copy) from unmanaged memory back to our structure;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.Copy()"}]},{"type":"text","value":"\nto copy between the unmanaged memory and our byte array;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal.FreeHGlobal()"}]},{"type":"text","value":"\nto free the allocated memory;"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using these methods we can construct the following methods:"}]},{"type":"element","tag":"pre","props":{"code":"public static byte[] Serialize<T>(T s)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var array = new byte[size];\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.StructureToPtr(s, ptr, true);\n    Marshal.Copy(ptr, array, 0, size);\n    Marshal.FreeHGlobal(ptr);\n    return array;\n}\n\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.Copy(array, 0, ptr, size);\n    var s = (T)Marshal.PtrToStructure(ptr, typeof(T));\n    Marshal.FreeHGlobal(ptr);\n    return s;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static byte[] Serialize<T>(T s)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var array = new byte[size];\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.StructureToPtr(s, ptr, true);\n    Marshal.Copy(ptr, array, 0, size);\n    Marshal.FreeHGlobal(ptr);\n    return array;\n}\n\npublic static T Deserialize<T>(byte[] array)\n    where T : struct\n{\n    var size = Marshal.SizeOf(typeof(T));\n    var ptr = Marshal.AllocHGlobal(size);\n    Marshal.Copy(array, 0, ptr, size);\n    var s = (T)Marshal.PtrToStructure(ptr, typeof(T));\n    Marshal.FreeHGlobal(ptr);\n    return s;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that due to the unsafety of using unmanaged memory, we may want to use a "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/zwc8s4fz.aspx","rel":["nofollow"]},"children":[{"type":"text","value":"try – finally"}]},{"type":"text","value":" block to make sure the memory will always be freed, even if something goes wrong. For brevity, this is left out here."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When testing our code, which again is as easy to use as before – in fact the method signatures are exactly the same as our first pair – we see that it indeed works as we hope."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Without any code inside our structures and completely generic methods there is no need to write or maintain any code when adding or modifying structures."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Further the resulting array is the expected 16 bytes long."}]},{"type":"element","tag":"h3","props":{"id":"performance-2"},"children":[{"type":"text","value":"Performance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When running these methods through the tests, converting structs to byte arrays and vice versa takes a mere 0.47 and 0.60 seconds respectively (again for one million calls)."}]},{"type":"element","tag":"h2","props":{"id":"comparison"},"children":[{"type":"text","value":"Comparison"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here is a table with the results from the performance tests:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"16 byte struct"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"struct to array"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"array to struct"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary formatter (218 byte array!)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4.86s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3.85s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary writer/reader"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.50s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.20s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"binary w/r (singleton)"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.14s"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.11s"}]}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"marshalling"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.47s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.60s"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Clearly, if what we care about most is performance, writing and reading our data manually, using shared "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]},{"type":"text","value":" objects is the fastest method."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On the other hand, the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal"}]},{"type":"text","value":" methods allow for much easier reuse and make our code significantly more robust to change since there is no code to update and maintain."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To provide some more data, here are the results from the same test, but this time with a 128 byte structure:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"128 byte struct"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"struct to array"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"array to struct"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary formatter (218 byte array!)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"17.32s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"14.47s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"binary writer/reader"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1.48s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.66s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"binary w/r (singleton)"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.78s"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"0.56s"}]}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"marshalling"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.84s"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"0.75s"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We can see that the relative ordering of the different measurements is still the same. However, note how the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryWriter"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryReader"}]},{"type":"text","value":" measurements are getting significantly closer to the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Marshal"}]},{"type":"text","value":" ones."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While I would not necessarily encourage structures of this size, I would argue that marshalling is the best approach for large structures in almost every case. The slightly slower performance is easily justified by the much more maintainable code."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In fact, I would go as far and say that even for small structures the ease of using marshalling is still top advantageous despite the lower performance."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the end, binary serialization is unlikely to ever be a bottleneck, and unless it is, we should choose the option that fulfils our requirements of small array size and ease of use."}]},{"type":"element","tag":"h2","props":{"id":"conclusion"},"children":[{"type":"text","value":"Conclusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We took a look at three – and a half – different ways of converting between structs and byte arrays."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Judging by memory usage, performance, and ease of use, there is no clear winner – only a clear loser unless we specifically need the additional functionality of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BinaryFormatter"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"However, in marshalling we found a method that is reasonably fast, while acing our other requirements."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While in extremely performance critical code we may want to write our data manually, marshalling is likely the best alternative in the vast majority of cases."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Feel free to let me know if you agree with this analysis, or if you have other methods of achieving the same result that may be worth looking into."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Enjoy the pixels!"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"why-byte-arrays","depth":2,"text":"Why byte arrays?"},{"id":"why-structures","depth":2,"text":"Why structures?"},{"id":"binaryformatter","depth":2,"text":"BinaryFormatter","children":[{"id":"performance","depth":3,"text":"Performance"}]},{"id":"binarywriterbinaryreader","depth":2,"text":"BinaryWriter/BinaryReader","children":[{"id":"performance-1","depth":3,"text":"Performance"},{"id":"some-concerns","depth":3,"text":"Some concerns"}]},{"id":"marshalling","depth":2,"text":"Marshalling","children":[{"id":"performance-2","depth":3,"text":"Performance"}]},{"id":"comparison","depth":2,"text":"Comparison"},{"id":"conclusion","depth":2,"text":"Conclusion"}]}},"_type":"markdown","_id":"content:dotnet:2021-05-01-Converting-between-Structs-and-Byte-Arrays.md","_source":"content","_file":"dotnet/2021-05-01-Converting-between-Structs-and-Byte-Arrays.md","_extension":"md","date":"2021-05-01"},{"_path":"/dotnet/2020-12-11-chrome-login-fail","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"谷歌浏览器下netcore登录失败问题","description":"IntroductionWhen you use HTTP on your Identity Server 4 enabled website, users may not login because of the changes made by Chrome in the version 8x. This occurs when you use HTTP schema in your website. The issue is explained here https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#h","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"introduction"},"children":[{"type":"text","value":"Introduction"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When you use HTTP on your Identity Server 4 enabled website, users may not login because of the changes made by Chrome in the version 8x. This occurs when you use HTTP schema in your website. The issue is explained here "},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication"}]}]},{"type":"element","tag":"h2","props":{"id":"how-to-solve-it"},"children":[{"type":"text","value":"How to solve it?"}]},{"type":"element","tag":"h3","props":{"id":"step-1"},"children":[{"type":"text","value":"Step-1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Create the below extension in your *"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":".Web"}]},{"type":"text","value":" project."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    public static class SameSiteCookiesServiceCollectionExtensions\n    {\n        /// <summary>\n        /// -1 defines the unspecified value, which tells ASPNET Core to NOT\n        /// send the SameSite attribute. With ASPNET Core 3.1 the\n        /// <seealso cref=\"SameSiteMode\" /> enum will have a definition for\n        /// Unspecified.\n        /// </summary>\n        private const SameSiteMode Unspecified = (SameSiteMode)(-1);\n\n        /// <summary>\n        /// Configures a cookie policy to properly set the SameSite attribute\n        /// for Browsers that handle unknown values as Strict. Ensure that you\n        /// add the <seealso cref=\"Microsoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware\" />\n        /// into the pipeline before sending any cookies!\n        /// </summary>\n        /// <remarks>\n        /// Minimum ASPNET Core Version required for this code:\n        ///   - 2.1.14\n        ///   - 2.2.8\n        ///   - 3.0.1\n        ///   - 3.1.0-preview1\n        /// Starting with version 80 of Chrome (to be released in February 2020)\n        /// cookies with NO SameSite attribute are treated as SameSite=Lax.\n        /// In order to always get the cookies send they need to be set to\n        /// SameSite=None. But since the current standard only defines Lax and\n        /// Strict as valid values there are some browsers that treat invalid\n        /// values as SameSite=Strict. We therefore need to check the browser\n        /// and either send SameSite=None or prevent the sending of SameSite=None.\n        /// Relevant links:\n        /// - https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1\n        /// - https://tools.ietf.org/html/draft-west-cookie-incrementalism-00\n        /// - https://www.chromium.org/updates/same-site\n        /// - https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// - https://bugs.webkit.org/show_bug.cgi?id=198181\n        /// </remarks>\n        /// <param name=\"services\">The service collection to register <see cref=\"CookiePolicyOptions\" /> into.</param>\n        /// <returns>The modified <see cref=\"IServiceCollection\" />.</returns>\n        public static IServiceCollection ConfigureNonBreakingSameSiteCookies(this IServiceCollection services)\n        {\n            services.Configure<CookiePolicyOptions>(options =>\n            {\n                options.MinimumSameSitePolicy = Unspecified;\n                options.OnAppendCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n                options.OnDeleteCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n            });\n\n            return services;\n        }\n\n        private static void CheckSameSite(HttpContext httpContext, CookieOptions options)\n        {\n            if (options.SameSite == SameSiteMode.None)\n            {\n                var userAgent = httpContext.Request.Headers[\"User-Agent\"].ToString();\n\n                if (DisallowsSameSiteNone(userAgent))\n                {\n                    options.SameSite = Unspecified;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Checks if the UserAgent is known to interpret an unknown value as Strict.\n        /// For those the <see cref=\"CookieOptions.SameSite\" /> property should be\n        /// set to <see cref=\"Unspecified\" />.\n        /// </summary>\n        /// <remarks>\n        /// This code is taken from Microsoft:\n        /// https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// </remarks>\n        /// <param name=\"userAgent\">The user agent string to check.</param>\n        /// <returns>Whether the specified user agent (browser) accepts SameSite=None or not.</returns>\n        private static bool DisallowsSameSiteNone(string userAgent)\n        {\n            // Cover all iOS based browsers here. This includes:\n            //   - Safari on iOS 12 for iPhone, iPod Touch, iPad\n            //   - WkWebview on iOS 12 for iPhone, iPod Touch, iPad\n            //   - Chrome on iOS 12 for iPhone, iPod Touch, iPad\n            // All of which are broken by SameSite=None, because they use the\n            // iOS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite iOS versions lower\n            // than 12 are not supporting SameSite at all. Starting with version 13\n            // unknown values are NOT treated as strict anymore. Therefore we only\n            // need to check version 12.\n            if (userAgent.Contains(\"CPU iPhone OS 12\")\n               || userAgent.Contains(\"iPad; CPU OS 12\"))\n            {\n                return true;\n            }\n\n            // Cover Mac OS X based browsers that use the Mac OS networking stack.\n            // This includes:\n            //   - Safari on Mac OS X.\n            // This does not include:\n            //   - Chrome on Mac OS X\n            // because they do not use the Mac OS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite MacOS X versions lower\n            // than 10.14 are not supporting SameSite at all. Starting with version\n            // 10.15 unknown values are NOT treated as strict anymore. Therefore we\n            // only need to check version 10.14.\n            if (userAgent.Contains(\"Safari\")\n               && userAgent.Contains(\"Macintosh; Intel Mac OS X 10_14\")\n               && userAgent.Contains(\"Version/\"))\n            {\n                return true;\n            }\n\n            // Cover Chrome 50-69, because some versions are broken by SameSite=None\n            // and none in this range require it.\n            // Note: this covers some pre-Chromium Edge versions,\n            // but pre-Chromium Edge does not require SameSite=None.\n            // Notes from Thinktecture:\n            // We can not validate this assumption, but we trust Microsofts\n            // evaluation. And overall not sending a SameSite value equals to the same\n            // behavior as SameSite=None for these old versions anyways.\n            if (userAgent.Contains(\"Chrome/5\") || userAgent.Contains(\"Chrome/6\"))\n            {\n                return true;\n            }\n\n            if (GetChromeVersion(userAgent) >= 80)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private static int GetChromeVersion(string userAgent)\n        {\n            try\n            {\n                return Convert.ToInt32(userAgent.Split(\"Chrome/\")[1].Split('.')[0]);\n            }\n            catch (Exception)\n            {\n                return 0;\n            }\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    public static class SameSiteCookiesServiceCollectionExtensions\n    {\n        /// <summary>\n        /// -1 defines the unspecified value, which tells ASPNET Core to NOT\n        /// send the SameSite attribute. With ASPNET Core 3.1 the\n        /// <seealso cref=\"SameSiteMode\" /> enum will have a definition for\n        /// Unspecified.\n        /// </summary>\n        private const SameSiteMode Unspecified = (SameSiteMode)(-1);\n\n        /// <summary>\n        /// Configures a cookie policy to properly set the SameSite attribute\n        /// for Browsers that handle unknown values as Strict. Ensure that you\n        /// add the <seealso cref=\"Microsoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware\" />\n        /// into the pipeline before sending any cookies!\n        /// </summary>\n        /// <remarks>\n        /// Minimum ASPNET Core Version required for this code:\n        ///   - 2.1.14\n        ///   - 2.2.8\n        ///   - 3.0.1\n        ///   - 3.1.0-preview1\n        /// Starting with version 80 of Chrome (to be released in February 2020)\n        /// cookies with NO SameSite attribute are treated as SameSite=Lax.\n        /// In order to always get the cookies send they need to be set to\n        /// SameSite=None. But since the current standard only defines Lax and\n        /// Strict as valid values there are some browsers that treat invalid\n        /// values as SameSite=Strict. We therefore need to check the browser\n        /// and either send SameSite=None or prevent the sending of SameSite=None.\n        /// Relevant links:\n        /// - https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1\n        /// - https://tools.ietf.org/html/draft-west-cookie-incrementalism-00\n        /// - https://www.chromium.org/updates/same-site\n        /// - https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// - https://bugs.webkit.org/show_bug.cgi?id=198181\n        /// </remarks>\n        /// <param name=\"services\">The service collection to register <see cref=\"CookiePolicyOptions\" /> into.</param>\n        /// <returns>The modified <see cref=\"IServiceCollection\" />.</returns>\n        public static IServiceCollection ConfigureNonBreakingSameSiteCookies(this IServiceCollection services)\n        {\n            services.Configure<CookiePolicyOptions>(options =>\n            {\n                options.MinimumSameSitePolicy = Unspecified;\n                options.OnAppendCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n                options.OnDeleteCookie = cookieContext =>\n                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);\n            });\n\n            return services;\n        }\n\n        private static void CheckSameSite(HttpContext httpContext, CookieOptions options)\n        {\n            if (options.SameSite == SameSiteMode.None)\n            {\n                var userAgent = httpContext.Request.Headers[\"User-Agent\"].ToString();\n\n                if (DisallowsSameSiteNone(userAgent))\n                {\n                    options.SameSite = Unspecified;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Checks if the UserAgent is known to interpret an unknown value as Strict.\n        /// For those the <see cref=\"CookieOptions.SameSite\" /> property should be\n        /// set to <see cref=\"Unspecified\" />.\n        /// </summary>\n        /// <remarks>\n        /// This code is taken from Microsoft:\n        /// https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/\n        /// </remarks>\n        /// <param name=\"userAgent\">The user agent string to check.</param>\n        /// <returns>Whether the specified user agent (browser) accepts SameSite=None or not.</returns>\n        private static bool DisallowsSameSiteNone(string userAgent)\n        {\n            // Cover all iOS based browsers here. This includes:\n            //   - Safari on iOS 12 for iPhone, iPod Touch, iPad\n            //   - WkWebview on iOS 12 for iPhone, iPod Touch, iPad\n            //   - Chrome on iOS 12 for iPhone, iPod Touch, iPad\n            // All of which are broken by SameSite=None, because they use the\n            // iOS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite iOS versions lower\n            // than 12 are not supporting SameSite at all. Starting with version 13\n            // unknown values are NOT treated as strict anymore. Therefore we only\n            // need to check version 12.\n            if (userAgent.Contains(\"CPU iPhone OS 12\")\n               || userAgent.Contains(\"iPad; CPU OS 12\"))\n            {\n                return true;\n            }\n\n            // Cover Mac OS X based browsers that use the Mac OS networking stack.\n            // This includes:\n            //   - Safari on Mac OS X.\n            // This does not include:\n            //   - Chrome on Mac OS X\n            // because they do not use the Mac OS networking stack.\n            // Notes from Thinktecture:\n            // Regarding https://caniuse.com/#search=samesite MacOS X versions lower\n            // than 10.14 are not supporting SameSite at all. Starting with version\n            // 10.15 unknown values are NOT treated as strict anymore. Therefore we\n            // only need to check version 10.14.\n            if (userAgent.Contains(\"Safari\")\n               && userAgent.Contains(\"Macintosh; Intel Mac OS X 10_14\")\n               && userAgent.Contains(\"Version/\"))\n            {\n                return true;\n            }\n\n            // Cover Chrome 50-69, because some versions are broken by SameSite=None\n            // and none in this range require it.\n            // Note: this covers some pre-Chromium Edge versions,\n            // but pre-Chromium Edge does not require SameSite=None.\n            // Notes from Thinktecture:\n            // We can not validate this assumption, but we trust Microsofts\n            // evaluation. And overall not sending a SameSite value equals to the same\n            // behavior as SameSite=None for these old versions anyways.\n            if (userAgent.Contains(\"Chrome/5\") || userAgent.Contains(\"Chrome/6\"))\n            {\n                return true;\n            }\n\n            if (GetChromeVersion(userAgent) >= 80)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private static int GetChromeVersion(string userAgent)\n        {\n            try\n            {\n                return Convert.ToInt32(userAgent.Split(\"Chrome/\")[1].Split('.')[0]);\n            }\n            catch (Exception)\n            {\n                return 0;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"step-2"},"children":[{"type":"text","value":"Step-2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Assume that your project name is "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Acme.BookStore"}]},{"type":"text","value":". Then open "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AcmeBookStoreWebModule.cs"}]},{"type":"text","value":" class."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Add the following line to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConfigureServices()"}]},{"type":"text","value":" method."}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"context.Services.ConfigureNonBreakingSameSiteCookies();\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"context.Services.ConfigureNonBreakingSameSiteCookies();\n"}]}]},{"type":"element","tag":"h3","props":{"id":"step-3"},"children":[{"type":"text","value":"Step-3"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Go to"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnApplicationInitialization()"}]},{"type":"text","value":" method in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AcmeBookStoreWebModule.cs"}]},{"type":"text","value":" add "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"app.UseCookiePolicy();"}]}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"public override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n        var app = context.GetApplicationBuilder();\n        var env = context.GetEnvironment();\n\n        if (env.IsDevelopment())\n        {\n                app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n                app.UseErrorPage();\n                app.UseHsts();\n        }\n         // Before UseAuthentication or anything else that writes cookies.\n        app.UseCookiePolicy(); //<--- added this --->\n\n    //....\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n        var app = context.GetApplicationBuilder();\n        var env = context.GetEnvironment();\n\n        if (env.IsDevelopment())\n        {\n                app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n                app.UseErrorPage();\n                app.UseHsts();\n        }\n         // Before UseAuthentication or anything else that writes cookies.\n        app.UseCookiePolicy(); //<--- added this --->\n\n    //....\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It's all! You are ready to go!"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Referenced from "},{"type":"element","tag":"a","props":{"href":"https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"introduction","depth":2,"text":"Introduction"},{"id":"how-to-solve-it","depth":2,"text":"How to solve it?","children":[{"id":"step-1","depth":3,"text":"Step-1"},{"id":"step-2","depth":3,"text":"Step-2"},{"id":"step-3","depth":3,"text":"Step-3"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-12-11-chrome-login-fail.md","_source":"content","_file":"dotnet/2020-12-11-chrome-login-fail.md","_extension":"md","date":"2020-12-11"},{"_path":"/dotnet/2020-11-24-flags","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"C＃枚举中使用Flags特性","description":"假如有类型 Show 的定义如下十進位表示法\n[Flags]\nenum Days\n{\n    None      = 0,  // 0000 0000\n    Sunday    = 1,  // 0000 0001\n    Monday    = 2,  // 0000 0010\n    Tuesday   = 4,  // 0000 0100\n    Wednesday = 8,  // 0000 1000\n    Thursday  = 16, // 0001 0000\n    Friday    = 32, // 0010 0000\n    Saturday  = 64  // 010","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如有类型 Show 的定义如下"}]},{"type":"element","tag":"pre","props":{"code":"十進位表示法\n[Flags]\nenum Days\n{\n    None      = 0,  // 0000 0000\n    Sunday    = 1,  // 0000 0001\n    Monday    = 2,  // 0000 0010\n    Tuesday   = 4,  // 0000 0100\n    Wednesday = 8,  // 0000 1000\n    Thursday  = 16, // 0001 0000\n    Friday    = 32, // 0010 0000\n    Saturday  = 64  // 0100 0000\n}\n位元移位表示法\n[Flags]\nenum Days\n{\n    None      = 0,      // 0000 0000\n    Sunday    = 1 << 0, // 0000 0001\n    Monday    = 1 << 1, // 0000 0010\n    Tuesday   = 1 << 2, // 0000 0100\n    Wednesday = 1 << 3, // 0000 1000\n    Thursday  = 1 << 4, // 0001 0000\n    Friday    = 1 << 5, // 0010 0000\n    Saturday  = 1 << 6  // 0100 0000\n}\n二進位表示法 (C# 7.2新增)\n[Flags]\nenum Days\n{\n    None      = 0b_0000_0000, // 0000 0000\n    Sunday    = 0b_0000_0001, // 0000 0001\n    Monday    = 0b_0000_0010, // 0000 0010\n    Tuesday   = 0b_0000_0100, // 0000 0100\n    Wednesday = 0b_0000_1000, // 0000 1000\n    Thursday  = 0b_0001_0000, // 0001 0000\n    Friday    = 0b_0010_0000, // 0010 0000\n    Saturday  = 0b_0100_0000  // 0100 0000\n}\n \n十六進位表示法\n[Flags]\nenum RenderType\n{\n   None = 0x0,\n   DataUri = 0x1,\n   GZip = 0x2,\n   ContentPage = 0x4,\n   ViewPage = 0x8,\n   HomePage = 0x10 // Next two values could be 0x20, 0x40\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"十進位表示法\n[Flags]\nenum Days\n{\n    None      = 0,  // 0000 0000\n    Sunday    = 1,  // 0000 0001\n    Monday    = 2,  // 0000 0010\n    Tuesday   = 4,  // 0000 0100\n    Wednesday = 8,  // 0000 1000\n    Thursday  = 16, // 0001 0000\n    Friday    = 32, // 0010 0000\n    Saturday  = 64  // 0100 0000\n}\n位元移位表示法\n[Flags]\nenum Days\n{\n    None      = 0,      // 0000 0000\n    Sunday    = 1 << 0, // 0000 0001\n    Monday    = 1 << 1, // 0000 0010\n    Tuesday   = 1 << 2, // 0000 0100\n    Wednesday = 1 << 3, // 0000 1000\n    Thursday  = 1 << 4, // 0001 0000\n    Friday    = 1 << 5, // 0010 0000\n    Saturday  = 1 << 6  // 0100 0000\n}\n二進位表示法 (C# 7.2新增)\n[Flags]\nenum Days\n{\n    None      = 0b_0000_0000, // 0000 0000\n    Sunday    = 0b_0000_0001, // 0000 0001\n    Monday    = 0b_0000_0010, // 0000 0010\n    Tuesday   = 0b_0000_0100, // 0000 0100\n    Wednesday = 0b_0000_1000, // 0000 1000\n    Thursday  = 0b_0001_0000, // 0001 0000\n    Friday    = 0b_0010_0000, // 0010 0000\n    Saturday  = 0b_0100_0000  // 0100 0000\n}\n \n十六進位表示法\n[Flags]\nenum RenderType\n{\n   None = 0x0,\n   DataUri = 0x1,\n   GZip = 0x2,\n   ContentPage = 0x4,\n   ViewPage = 0x8,\n   HomePage = 0x10 // Next two values could be 0x20, 0x40\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"& 按位与"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"| 按位或"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"^ 按位异或"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"~取反"}]}]},{"type":"element","tag":"h2","props":{"id":"并集-添加"},"children":[{"type":"text","value":"并集 (添加)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a|b: 并集(所有的和,相同部分只算一次);"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A | B\n{'英语', '物理', '语文', '政治', '化学', '数学', '生物', '地理', '历史'}\n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A | B\n{'英语', '物理', '语文', '政治', '化学', '数学', '生物', '地理', '历史'}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182659146","src":"/images/2020-11-24-flags/image-20210404182659146.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"差集-去除"},"children":[{"type":"text","value":"差集 (去除)"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & (~B)\n{'物理', '生物', '化学'}\n>>> B & (~A)\n{'政治', '历史', '地理'}\n  \n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & (~B)\n{'物理', '生物', '化学'}\n>>> B & (~A)\n{'政治', '历史', '地理'}\n  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182718872","src":"/images/2020-11-24-flags/image-20210404182718872.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"补集对称差集"},"children":[{"type":"text","value":"补集(对称差集)"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A ^ B\n{'物理', '生物', '化学', '政治', '历史', '地理'}\n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A ^ B\n{'物理', '生物', '化学', '政治', '历史', '地理'}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182742701","src":"/images/2020-11-24-flags/image-20210404182742701.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182802570","src":"/images/2020-11-24-flags/image-20210404182802570.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"交集-检查"},"children":[{"type":"text","value":"交集  (检查)"}]},{"type":"element","tag":"pre","props":{"code":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & B\n{'英语', '语文', '数学'}\n","language":"swift","meta":"","className":["language-swift"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":">>> A = {'数学','语文','英语','物理','化学','生物'}\n>>> B = {'数学','语文','英语','政治','地理','历史'}\n>>> A & B\n{'英语', '语文', '数学'}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者"}]},{"type":"element","tag":"pre","props":{"code":"  Show show = Show.A | Show.B;\n  show.HasFlag(Show.A);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  Show show = Show.A | Show.B;\n  show.HasFlag(Show.A);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从性能上看通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&"}]},{"type":"text","value":" 的性能会比 HasFlag 高，但是从可读性上 HasFlag 更友好，如果你的代码没有性能问题推荐使用 HasFlag 方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20210404182612251","src":"/images/2020-11-24-flags/image-20210404182612251.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"并集-添加","depth":2,"text":"并集 (添加)"},{"id":"差集-去除","depth":2,"text":"差集 (去除)"},{"id":"补集对称差集","depth":2,"text":"补集(对称差集)"},{"id":"交集-检查","depth":2,"text":"交集  (检查)"}]}},"_type":"markdown","_id":"content:dotnet:2020-11-24-flags.md","_source":"content","_file":"dotnet/2020-11-24-flags.md","_extension":"md","date":"2020-11-24"},{"_path":"/dotnet/2020-11-13-reflection-method","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":".NET Core/Framework 创建委托以大幅度提高反射调用的性能","description":"都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为反射得到的方法创建一个委托，此后调用此委托将能够提高近乎直接调用方法本身的性能。（当然 Emit 也能够帮助我们显著提升性能，不过直接得到可以调用的委托不是更加方便吗？）"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h3","props":{"id":"性能对比数据"},"children":[{"type":"text","value":"性能对比数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"性能对比数据","src":"/images/2020-11-13-Reflection-Method/20180227195855828"},"children":[]},{"type":"text","value":"\n▲ 没有什么能够比数据更有说服力（注意后面两行是有秒数的）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可能我还需要解释一下那五行数据的含义："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"直接调用（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"应该没有什么比直接调用函数本身更有性能优势的吧"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"做一个跟直接调用的方法功能一模一样的委托（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"本文重点"}]},{"type":"text","value":" 将反射出来的方法创建一个委托，然后调用这个委托（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"看看吧，性能跟直接调差别也不大嘛"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"先反射得到方法，然后一直调用这个方法（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊"}]},{"type":"text","value":"）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"缓存都不用，从头开始反射然后调用得到的方法（��"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"100 多倍的性能损失了"}]},{"type":"text","value":"）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下是测试代码，可以更好地理解上图数据的含义："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace Walterlv.Demo\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // 调用的目标实例。\n            var instance = new StubClass();\n\n            // 使用反射找到的方法。\n            var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) });\n            Assert.IsNotNull(method);\n\n            // 将反射找到的方法创建一个委托。\n            var func = InstanceMethodBuilder<int, int>.CreateInstanceMethod(instance, method);\n\n            // 跟被测方法功能一样的纯委托。\n            Func<int, int> pureFunc = value => value;\n\n            // 测试次数。\n            var count = 10000000;\n\n            // 直接调用。\n            var watch = new Stopwatch();\n            watch.Start();\n            for (var i = 0; i < count; i++)\n            {\n                var result = instance.Test(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接调用\");\n\n            // 使用同样功能的 Func 调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = pureFunc(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用\");\n\n            // 使用反射创建出来的委托调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = func(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用\");\n\n            // 使用反射得到的方法缓存调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = method.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用\");\n\n            // 直接使用反射调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) })\n                    ?.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接使用反射调用\");\n        }\n\n        private class StubClass\n        {\n            public int Test(int i)\n            {\n                return i;\n            }\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Diagnostics;\nusing System.Reflection;\n\nnamespace Walterlv.Demo\n{\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            // 调用的目标实例。\n            var instance = new StubClass();\n\n            // 使用反射找到的方法。\n            var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) });\n            Assert.IsNotNull(method);\n\n            // 将反射找到的方法创建一个委托。\n            var func = InstanceMethodBuilder<int, int>.CreateInstanceMethod(instance, method);\n\n            // 跟被测方法功能一样的纯委托。\n            Func<int, int> pureFunc = value => value;\n\n            // 测试次数。\n            var count = 10000000;\n\n            // 直接调用。\n            var watch = new Stopwatch();\n            watch.Start();\n            for (var i = 0; i < count; i++)\n            {\n                var result = instance.Test(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接调用\");\n\n            // 使用同样功能的 Func 调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = pureFunc(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用\");\n\n            // 使用反射创建出来的委托调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = func(5);\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用\");\n\n            // 使用反射得到的方法缓存调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = method.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用\");\n\n            // 直接使用反射调用。\n            watch.Restart();\n            for (var i = 0; i < count; i++)\n            {\n                var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) })\n                    ?.Invoke(instance, new object[] { 5 });\n            }\n\n            watch.Stop();\n            Console.WriteLine($\"{watch.Elapsed} - {count} 次 - 直接使用反射调用\");\n        }\n\n        private class StubClass\n        {\n            public int Test(int i)\n            {\n                return i;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"如何实现"},"children":[{"type":"text","value":"如何实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现的关键就在于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MethodInfo.CreateDelegate"}]},{"type":"text","value":" 方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此方法有两个重载："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要求传入一个类型，而这个类型就是应该转成的委托的类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拿上面的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StubClass"}]},{"type":"text","value":" 来说明会更直观一些："}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"private class StubClass\n{\n    public int Test(int i)\n    {\n        return i;\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private class StubClass\n{\n    public int Test(int i)\n    {\n        return i;\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前者得到的委托相当于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int Test(int i)"}]},{"type":"text","value":" 方法，后者得到的委托相当于 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"int Test(StubClass instance, int i)"}]},{"type":"text","value":" 方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单独使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateDelegate"}]},{"type":"text","value":" 方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。"}]},{"type":"element","tag":"pre","props":{"className":["language-csharp"],"code":"using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics.Contracts;\n\nnamespace Walterlv.Demo\n{\n    public static class InstanceMethodBuilder<T, TReturnValue>\n    {\n        /// <summary>\n        /// 调用时就像 var result = func(t)。\n        /// </summary>\n        [Pure]\n        public static Func<T, TReturnValue> CreateInstanceMethod<TInstanceType>(TInstanceType instance, MethodInfo method)\n        {\n            if (instance == null) throw new ArgumentNullException(nameof(instance));\n            if (method == null) throw new ArgumentNullException(nameof(method));\n\n            return (Func<T, TReturnValue>) method.CreateDelegate(typeof(Func<T, TReturnValue>), instance);\n        }\n\n        /// <summary>\n        /// 调用时就像 var result = func(this, t)。\n        /// </summary>\n        [Pure]\n        public static Func<TInstanceType, T, TReturnValue> CreateMethod<TInstanceType>(MethodInfo method)\n        {\n            if (method == null)\n                throw new ArgumentNullException(nameof(method));\n\n            return (Func<TInstanceType, T, TReturnValue>) method.CreateDelegate(typeof(Func<TInstanceType, T, TReturnValue>));\n        }\n    }\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics.Contracts;\n\nnamespace Walterlv.Demo\n{\n    public static class InstanceMethodBuilder<T, TReturnValue>\n    {\n        /// <summary>\n        /// 调用时就像 var result = func(t)。\n        /// </summary>\n        [Pure]\n        public static Func<T, TReturnValue> CreateInstanceMethod<TInstanceType>(TInstanceType instance, MethodInfo method)\n        {\n            if (instance == null) throw new ArgumentNullException(nameof(instance));\n            if (method == null) throw new ArgumentNullException(nameof(method));\n\n            return (Func<T, TReturnValue>) method.CreateDelegate(typeof(Func<T, TReturnValue>), instance);\n        }\n\n        /// <summary>\n        /// 调用时就像 var result = func(this, t)。\n        /// </summary>\n        [Pure]\n        public static Func<TInstanceType, T, TReturnValue> CreateMethod<TInstanceType>(MethodInfo method)\n        {\n            if (method == null)\n                throw new ArgumentNullException(nameof(method));\n\n            return (Func<TInstanceType, T, TReturnValue>) method.CreateDelegate(typeof(Func<TInstanceType, T, TReturnValue>));\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"泛型的多参数版本可以使用泛型类型生成器生成，我在 "},{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/WPwalter/article/details/79216183","rel":["nofollow"]},"children":[{"type":"text","value":"生成代码，从 "}]},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"到"}]},{"type":"text","value":" —— 自动生成多个类型的泛型 - 吕毅 一文中写了一个泛型生成器，可以稍加修改以便适应这种泛型类。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"性能对比数据","depth":3,"text":"性能对比数据"},{"id":"如何实现","depth":3,"text":"如何实现"}]}},"_type":"markdown","_id":"content:dotnet:2020-11-13-Reflection-Method.md","_source":"content","_file":"dotnet/2020-11-13-Reflection-Method.md","_extension":"md","date":"2020-11-13"},{"_path":"/dotnet/2020-08-17-netcore-options","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"IOptions、IOptionsMonitor以及IOptionsSnapshot","description":"ASP.NET Core引入了Options模式，使用类来表示相关的设置组。简单的来说，就是用强类型的类来表达配置项，这带来了很多好处。\n初学者会发现这个框架有3个主要的面向消费者的接口：IOptions、IOptionsMonitor以及IOptionsSnapshot。\n这三个接口初看起来很类似，所以很容易引起困惑，什么场景下该用哪个接口呢？","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"背景"},"children":[{"type":"text","value":"背景"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ASP.NET Core引入了Options模式，使用类来表示相关的设置组。简单的来说，就是用强类型的类来表达配置项，这带来了很多好处。\n初学者会发现这个框架有3个主要的面向消费者的接口：IOptions、IOptionsMonitor以及IOptionsSnapshot。\n这三个接口初看起来很类似，所以很容易引起困惑，什么场景下该用哪个接口呢？"}]},{"type":"element","tag":"h1","props":{"id":"示例"},"children":[{"type":"text","value":"示例"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先从一小段代码着手（TestOptions类只有一个字符串属性Name，代码略）："}]},{"type":"element","tag":"pre","props":{"code":"class Program\n{\n    static void Main(string[] args)\n    {\n        var builder = new ConfigurationBuilder();\n        builder.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true); //注意最后一个参数值，true表示配置文件更改时会重新加载。\n        var configuration = builder.Build();\n        var services = new ServiceCollection();\n        services.AddOptions();\n        services.Configure<TestOptions>(configuration); //这里通过配置文件绑定TestOptions\n        var provider = services.BuildServiceProvider();\n        Console.WriteLine(\"修改前：\");\n        Print(provider);\n\n        Change(provider); //使用代码修改Options值。\n        Console.WriteLine(\"使用代码修改后：\");\n        Print(provider);\n\n        Console.WriteLine(\"请修改配置文件。\");\n        Console.ReadLine(); //等待手动修改appsettings.json配置文件。\n        Console.WriteLine(\"修改appsettings.json文件后：\");\n        Print(provider);\n    }\n\n    static void Print(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            var options1 = sp.GetRequiredService<IOptions<TestOptions>>();\n            var options2 = sp.GetRequiredService<IOptionsMonitor<TestOptions>>();\n            var options3 = sp.GetRequiredService<IOptionsSnapshot<TestOptions>>();\n            Console.WriteLine(\"IOptions值: {0}\", options1.Value.Name);\n            Console.WriteLine(\"IOptionsMonitor值: {0}\", options2.CurrentValue.Name);\n            Console.WriteLine(\"IOptionsSnapshot值: {0}\", options3.Value.Name);\n            Console.WriteLine();\n        }\n    }\n\n    static void Change(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            sp.GetRequiredService<IOptions<TestOptions>>().Value.Name = \"IOptions Test 1\";\n            sp.GetRequiredService<IOptionsMonitor<TestOptions>>().CurrentValue.Name = \"IOptionsMonitor Test 1\";\n            sp.GetRequiredService<IOptionsSnapshot<TestOptions>>().Value.Name = \"IOptionsSnapshot Test 1\";\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Program\n{\n    static void Main(string[] args)\n    {\n        var builder = new ConfigurationBuilder();\n        builder.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true); //注意最后一个参数值，true表示配置文件更改时会重新加载。\n        var configuration = builder.Build();\n        var services = new ServiceCollection();\n        services.AddOptions();\n        services.Configure<TestOptions>(configuration); //这里通过配置文件绑定TestOptions\n        var provider = services.BuildServiceProvider();\n        Console.WriteLine(\"修改前：\");\n        Print(provider);\n\n        Change(provider); //使用代码修改Options值。\n        Console.WriteLine(\"使用代码修改后：\");\n        Print(provider);\n\n        Console.WriteLine(\"请修改配置文件。\");\n        Console.ReadLine(); //等待手动修改appsettings.json配置文件。\n        Console.WriteLine(\"修改appsettings.json文件后：\");\n        Print(provider);\n    }\n\n    static void Print(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            var options1 = sp.GetRequiredService<IOptions<TestOptions>>();\n            var options2 = sp.GetRequiredService<IOptionsMonitor<TestOptions>>();\n            var options3 = sp.GetRequiredService<IOptionsSnapshot<TestOptions>>();\n            Console.WriteLine(\"IOptions值: {0}\", options1.Value.Name);\n            Console.WriteLine(\"IOptionsMonitor值: {0}\", options2.CurrentValue.Name);\n            Console.WriteLine(\"IOptionsSnapshot值: {0}\", options3.Value.Name);\n            Console.WriteLine();\n        }\n    }\n\n    static void Change(IServiceProvider provider)\n    {\n        using(var scope = provider.CreateScope())\n        {\n            var sp = scope.ServiceProvider;\n            sp.GetRequiredService<IOptions<TestOptions>>().Value.Name = \"IOptions Test 1\";\n            sp.GetRequiredService<IOptionsMonitor<TestOptions>>().CurrentValue.Name = \"IOptionsMonitor Test 1\";\n            sp.GetRequiredService<IOptionsSnapshot<TestOptions>>().Value.Name = \"IOptionsSnapshot Test 1\";\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"appsettings.json文件："}]},{"type":"element","tag":"pre","props":{"code":"{\n    \"Name\": \"Test 0\"\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n    \"Name\": \"Test 0\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的代码，首先从appsettings.json文件读取配置，然后向容器注册依赖配置文件的TestOptions，接着分别打印IOptions<>,IOptionsMonitor<>和IOptionsSnapshot<>的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接着通过代码来修改TestOptions的值，打印。\n然后通过修改appsettings.json文件来修改TestOptions的值，打印。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"我们仅注册了一次TestOptions，却可以分别通过IOptions<>,IOptionsMonitor<>和IOptionsSnapshot<>接口来获取TestOptions的值。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果我们把appsettings.json文件中Name的值修改为Test 2，那么上面这段代码的输出是这样的："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-08-17-netcore-options/94928-20200323160553644-291512622.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"分析"},"children":[{"type":"text","value":"分析"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以看到第一次通过代码修改IOptions<>和IOptionsMonitor<>的值后，再次打印都被更新了，但是IOptionsSnapshot<>没有，为什么呢？\n让我们从Options框架的源代码着手，理解为什么会这样。\n当我们需要使用Options模式时，我们都会调用定义在OptionsServiceCollectionExtensions类上的扩展方法AddOptions(this IServiceCollection services)。"}]},{"type":"element","tag":"pre","props":{"code":"var services = new ServiceCollection();\nservices.AddOptions();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var services = new ServiceCollection();\nservices.AddOptions();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们观察AddOptions方法的实现："}]},{"type":"element","tag":"pre","props":{"code":"public static IServiceCollection AddOptions(this IServiceCollection services)\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptions<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Scoped(typeof(IOptionsSnapshot<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitor<>), typeof(OptionsMonitor<>)));\n    services.TryAdd(ServiceDescriptor.Transient(typeof(IOptionsFactory<>), typeof(OptionsFactory<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitorCache<>), typeof(OptionsCache<>)));\n    return services;\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static IServiceCollection AddOptions(this IServiceCollection services)\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptions<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Scoped(typeof(IOptionsSnapshot<>), typeof(OptionsManager<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitor<>), typeof(OptionsMonitor<>)));\n    services.TryAdd(ServiceDescriptor.Transient(typeof(IOptionsFactory<>), typeof(OptionsFactory<>)));\n    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitorCache<>), typeof(OptionsCache<>)));\n    return services;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"从上面的代码我们可以得知，IOptions<>和IOptionsMonitor<>被注册为单例服务，而IOptionsSnapshot<>被注册为范围服务。\n由于IOptions<>和IOptionsMonitor<>都被注册为单例服务，因此每次获取的都是同一个实例，所以更改了以后的值是保留的。\n而IOptionsSnapshot<>被注册为范围服务，所以每次创建新范围时获取的都是一个新的值，外部的更改只对当次有效，不会保留到下次（不能跨范围，对于ASP.NET Core来说不能跨请求）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们继续看第二次修改，第二次修改配置文件后IOptionsMonitor<>和IOptionsSnapshot<>的值更新了，而IOptions<>的值没有更新。\nIOptions<>好理解，它被注册为单例服务，第一次访问的时候生成实例并加载配置文件中的值，此后再也不会读取配置文件，所以它的值不会更新。\nIOptionsSnapshot<>被注册为范围服务，每次重新生成一个新的范围时，它都会从配置文件中获取值，因此它的值会更新。\n但是，IOptionsMonitor<>呢，它被注册为单例，为什么也会更新呢？\n让我们回到AddOptions的源代码，我们留意到IOptionsMonitor<>的实现是OptionsManager<>。\n当我们打开OptionsManager的源代码时，一切都很清楚了。\n它的构造函数如下："}]},{"type":"element","tag":"pre","props":{"code":"public OptionsMonitor(IOptionsFactory<TOptions> factory, IEnumerable<IOptionsChangeTokenSource<TOptions>> sources, IOptionsMonitorCache<TOptions> cache)\n{\n    _factory = factory;\n    _sources = sources;\n    _cache = cache;\n\n    foreach (var source in _sources)\n    {\n        var registration = ChangeToken.OnChange(\n                () => source.GetChangeToken(),\n                (name) => InvokeChanged(name),\n                source.Name);\n\n        _registrations.Add(registration);\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public OptionsMonitor(IOptionsFactory<TOptions> factory, IEnumerable<IOptionsChangeTokenSource<TOptions>> sources, IOptionsMonitorCache<TOptions> cache)\n{\n    _factory = factory;\n    _sources = sources;\n    _cache = cache;\n\n    foreach (var source in _sources)\n    {\n        var registration = ChangeToken.OnChange(\n                () => source.GetChangeToken(),\n                (name) => InvokeChanged(name),\n                source.Name);\n\n        _registrations.Add(registration);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原来OptionsMonitor的更新能力是从IOptionsChangeTokenSource而来，但是这个接口的实例又是谁呢？\n我们回到最开始的代码的第10行："}]},{"type":"element","tag":"pre","props":{"code":"services.Configure<TestOptions>(configuration);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"services.Configure<TestOptions>(configuration);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个定义在Microsoft.Extensions.Options.ConfigurationExtensions.dll的扩展方法，最后实际调用的是它的一个重载方法，代码如下："}]},{"type":"element","tag":"pre","props":{"code":"public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config, Action<BinderOptions> configureBinder)\n    where TOptions : class\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    if (config == null)\n    {\n        throw new ArgumentNullException(nameof(config));\n    }\n\n    services.AddOptions();\n    services.AddSingleton<IOptionsChangeTokenSource<TOptions>>(new ConfigurationChangeTokenSource<TOptions>(name, config));\n    return services.AddSingleton<IConfigureOptions<TOptions>>(new NamedConfigureFromConfigurationOptions<TOptions>(name, config, configureBinder));\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config, Action<BinderOptions> configureBinder)\n    where TOptions : class\n{\n    if (services == null)\n    {\n        throw new ArgumentNullException(nameof(services));\n    }\n\n    if (config == null)\n    {\n        throw new ArgumentNullException(nameof(config));\n    }\n\n    services.AddOptions();\n    services.AddSingleton<IOptionsChangeTokenSource<TOptions>>(new ConfigurationChangeTokenSource<TOptions>(name, config));\n    return services.AddSingleton<IConfigureOptions<TOptions>>(new NamedConfigureFromConfigurationOptions<TOptions>(name, config, configureBinder));\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"秘密就在上面的第15行，ConfigurationChangeTokenSource，它引用了代表配置文件的对象config，所以配置文件更新，IOptionsMonitor就会跟着更新。"}]},{"type":"element","tag":"h1","props":{"id":"结论"},"children":[{"type":"text","value":"结论"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOptions<>是单例，因此一旦生成了，除非通过代码的方式更改，它的值是不会更新的。\nIOptionsMonitor<>也是单例，但是它通过IOptionsChangeTokenSource<> 能够和配置文件一起更新，也能通过代码的方式更改值。\nIOptionsSnapshot<>是范围，所以在配置文件更新的下一次访问，它的值会更新，但是它不能跨范围通过代码的方式更改值，只能在当前范围（请求）内有效。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"官方文档是这样介绍的：\nIOptionsMonitor用于检索选项和管理TOptions实例的选项通知，它支持下面的场景："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"实例更新通知。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"命名实例。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重新加载配置。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"选择性的让实例失效。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOptionsSnapshot在需要对每个请求重新计算选项的场景中非常有用。\nIOptions可以用来支持Options模式，但是它不支持前面两者所支持的场景，如果你不需要支持上面的场景，你可以继续使用IOptions。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以你应该根据你的实际使用场景来选择到底是用这三者中的哪一个。\n"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"一般来说，如果你依赖配置文件，那么首先考虑IOptionsMonitor<>，如果不合适接着考虑IOptionsSnapshot<>，最后考虑IOptions<>。*"}]},{"type":"text","value":"\n***有一点需要注意，在ASP.NET Core应用中IOptionsMonitor可能会导致同一个请求中选项的值不一致——当你正在修改配置文件的时候——这可能会引发一些奇怪的bug。\n如果这个对你很重要，请使用IOptionsSnapshot，它可以保证同一个请求中的一致性，但是它可能会带来轻微的性能上的损失。\n如果你是在app启动的时候自己构造Options（比如在Startup类中）："}]},{"type":"element","tag":"pre","props":{"code":"services.Configure<TestOptions>(opt => opt.Name = \"Test 0\");\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"services.Configure<TestOptions>(opt => opt.Name = \"Test 0\");\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"IOptions<>最简单，也许是一个不错的选择，Configure扩展方法还有其他重载可以满足你的更多需求。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-17-netcore-options.md","_source":"content","_file":"dotnet/2020-08-17-netcore-options.md","_extension":"md","date":"2020-08-17"},{"_path":"/dotnet/2020-08-16-concurrentdictionary","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"ConcurrentDictionary并发字典","description":"ConcurrentDictionary主要用于要从多个线程（或异步任务）修改字典的情景中。如果来自单个线程，则可以根据需要使用尽可能多的代码使用标准Dictionary；）","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConcurrentDictionary主要用于要从多个线程（或异步任务）修改字典的情景中。如果来自单个线程，则可以根据需要使用尽可能多的代码使用标准Dictionary；）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果您查看ConcurrentDictionary上的方法，则会发现一些有趣的方法，例如TryAdd，TryGetValue，TryUpdate和TryRemove。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，若使用普通的Dictionary类时可能会看到下面的代码"}]},{"type":"element","tag":"pre","props":{"code":"// There are better ways to do this... but we need an example ;)\nif (!dictionary.ContainsKey(id))\n    dictionary.Add(id, value);\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// There are better ways to do this... but we need an example ;)\nif (!dictionary.ContainsKey(id))\n    dictionary.Add(id, value);\n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"多线程中同时调用该段代码,并且使用相同的id来调用Add,它将引发异常。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ConcurrentDictionary方法TryAdd为您处理该问题，并将返回true/false，告诉您是否已添加它（或该键是否已在字典中）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，除非您在代码的多线程部分中进行工作，否则您可能仅可以使用标准的Dictionary类。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-16-ConcurrentDictionary.md","_source":"content","_file":"dotnet/2020-08-16-ConcurrentDictionary.md","_extension":"md","date":"2020-08-16"},{"_path":"/dotnet/2020-08-15-kestrel-source-code","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Kestrel源码分析","description":"Kestrel是http://ASP.NET Core框架内置的默认Web Server 什么是Web Server? 根据维基百科的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Kestrel是"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core框架内置的默认Web Server 什么是Web Server? 根据"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Web_server","rel":["nofollow"]},"children":[{"type":"text","value":"维基百科"}]},{"type":"text","value":"的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。"}]},{"type":"element","tag":"h2","props":{"id":"定义-iserverihttpapplicationtcontext"},"children":[{"type":"text","value":"定义 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core定义了两个基本的接口"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"，及"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"接口定义了Web Server的基本功能，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"则定义了处理HTTP协议的应用程序的基本功能，我们首先来看下这两个定义:"}]},{"type":"element","tag":"h2","props":{"id":"web-服务器-iserver"},"children":[{"type":"text","value":"Web 服务器 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents a server.\n    /// </summary>\n    public interface IServer : IDisposable\n    {\n        /// <summary>\n        /// A collection of HTTP features of the server.\n        /// </summary>\n        IFeatureCollection Features { get; }\n\n        /// <summary>\n        /// Start the server with an application.\n        /// </summary>\n        /// <param name=\"application\">An instance of <see cref=\"IHttpApplication{TContext}\"/>.</param>\n        /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n        /// <param name=\"cancellationToken\">Indicates if the server startup should be aborted.</param>\n        Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken);\n\n        /// <summary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.</param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents a server.\n    /// </summary>\n    public interface IServer : IDisposable\n    {\n        /// <summary>\n        /// A collection of HTTP features of the server.\n        /// </summary>\n        IFeatureCollection Features { get; }\n\n        /// <summary>\n        /// Start the server with an application.\n        /// </summary>\n        /// <param name=\"application\">An instance of <see cref=\"IHttpApplication{TContext}\"/>.</param>\n        /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n        /// <param name=\"cancellationToken\">Indicates if the server startup should be aborted.</param>\n        Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken);\n\n        /// <summary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.</param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Features"}]},{"type":"text","value":" 是一个功能集合，其中可以包含所有应用程序需要的，用以处理HTTP协议各个阶段和组成部分的功能集，以接口的形式注入到"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Features"}]},{"type":"text","value":"中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync"}]},{"type":"text","value":"方法可以启动IServer对象，用来接受用户请求。包含两个参数："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"。 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplicatoin<TContext>"}]},{"type":"text","value":"是最终处理HTTP请求的应用程序入口点，在ASP.NET Core应用程序中，默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"实现是："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HostingApplication"}]},{"type":"text","value":"，我们会在稍后的部分进行详细的介绍。 而"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"用来响应中断应用程序启动的请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StopAsync"}]},{"type":"text","value":"方法用来处理停止服务的请求，接受一个参数"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CancellationToken"}]},{"type":"text","value":"，用来响应中断停止应用程序的请求。"}]},{"type":"element","tag":"h2","props":{"id":"http应用程序-ihttpapplicationtcontext"},"children":[{"type":"text","value":"Http应用程序 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents an application.\n    /// </summary>\n    /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n    public interface IHttpApplication<TContext>\n    {\n        /// <summary>\n        /// Create a TContext given a collection of HTTP features.\n        /// </summary>\n        /// <param name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.</param>\n        /// <returns>The created TContext.</returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// <summary>\n        /// Asynchronously processes an TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext that the operation will process.</param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// <summary>\n        /// Dispose a given TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext to be disposed.</param>\n        /// <param name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.</param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// <summary>\n    /// Represents an application.\n    /// </summary>\n    /// <typeparam name=\"TContext\">The context associated with the application.</typeparam>\n    public interface IHttpApplication<TContext>\n    {\n        /// <summary>\n        /// Create a TContext given a collection of HTTP features.\n        /// </summary>\n        /// <param name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.</param>\n        /// <returns>The created TContext.</returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// <summary>\n        /// Asynchronously processes an TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext that the operation will process.</param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// <summary>\n        /// Dispose a given TContext.\n        /// </summary>\n        /// <param name=\"context\">The TContext to be disposed.</param>\n        /// <param name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.</param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"接口的定义包含了三个方法： "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateContext"}]},{"type":"text","value":"方法用来创建处理请求的上下文中所需要的所有相关数据，组成"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象，由接口的实现自己定义类型， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ProcessRequestAsync"}]},{"type":"text","value":"方法使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CreateContext"}]},{"type":"text","value":"方法创建的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象处理本次请求。 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DisposeContext"}]},{"type":"text","value":"方法在完成请求的处理后，负责释放"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Context"}]},{"type":"text","value":"对象。"}]},{"type":"element","tag":"h2","props":{"id":"实现-kestrelserver"},"children":[{"type":"text","value":"实现 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=http%3A//ASP.NET","rel":["nofollow"]},"children":[{"type":"text","value":"http://ASP.NET"}]},{"type":"text","value":" Core提供了默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IServer"}]},{"type":"text","value":"："},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"，下面我们就来看看"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"具体都做了些什么。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":" 定义在dotnet/aspnetcore项目中（"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore","rel":["nofollow"]},"children":[{"type":"text","value":"GITHUB REPO"}]},{"type":"text","value":"）。 项目名称为：Microsoft.AspNetCore.Server.Kestrel.Core 名称空间.AspNetCore.Server.Kestrel.Core "},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore/blob/master/src/Servers/Kestrel/Core/src/KestrelServer.cs","rel":["nofollow"]},"children":[{"type":"text","value":"源代码"}]}]}]},{"type":"element","tag":"h2","props":{"id":"服务器启动端口监听协议解析及请求处理"},"children":[{"type":"text","value":"服务器启动：端口监听，协议解析及请求处理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们先看一下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"KestrelServer"}]},{"type":"text","value":"."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"StartAsync()"}]},{"type":"text","value":"方法的代码实现："}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"public async Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"首先会检查服务器的"},{"type":"element","tag":"a","props":{"href":"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F","rel":["nofollow"]},"children":[{"type":"text","value":"字节序"}]},{"type":"text","value":"，目前是不支持大端序的。 然后检查最大请求长度限制的设置项，以及服务器是否已经启动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后，通过"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AddressBinder"}]},{"type":"text","value":"对预先配置的IP地址或终结点(EndPoint)名称进行监听，开始接受客户端的请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当每有一个新的HTTP请求通过TCP协议或其他协议和服务器成功简历连接后，AddressBinder使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadPool.UnsafeQueueUserWorkItem()"}]},{"type":"text","value":"方法将"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法添加到线程池中，等待线程池的调度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果此时进程有可用的线程，就会调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法，处理用户的HTTP请求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"OnBind()"}]},{"type":"text","value":"方法默认使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件，处理新接入的用户请求，当设置了"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MaxConcurrentConnections"}]},{"type":"text","value":"值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"True"}]},{"type":"text","value":"时，则会默认使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ConnectionLimitMiddleware"}]},{"type":"text","value":"中间件，限制最大可用连接数，如果当前请求数已经达到最大可接受连接数，则拒绝用户的请求并断开连接，否则调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件，继续处理用户的请求。"}]},{"type":"element","tag":"h2","props":{"id":"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection"},"children":[{"type":"text","value":"处理HTTP请求 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionMiddleware<ServiceContext>"}]},{"type":"text","value":"中间件负责组装连接相关的上下文数据"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnectionContext"}]},{"type":"text","value":"，并使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]},{"type":"text","value":"类处理用户请求。"}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"internal class HttpConnectionMiddleware<TContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication<TContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication<TContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get<IMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"internal class HttpConnectionMiddleware<TContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication<TContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication<TContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get<IMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n"}]}]},{"type":"element","tag":"h3","props":{"id":"http版本控制-httpconnection"},"children":[{"type":"text","value":"HTTP版本控制 - "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当用户创建"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpConnection"}]},{"type":"text","value":"类时，在初始化过程中，会根据用户请求声明的HTTP协议版本，分别创建对应版本的Connection类，并使用该类处理用户请求："}]},{"type":"element","tag":"pre","props":{"className":["language-text"],"code":"public async Task ProcessRequestsAsync<TContext>(IHttpApplication<TContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection<TContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get<IConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get<IConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n","language":"text","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public async Task ProcessRequestsAsync<TContext>(IHttpApplication<TContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection<TContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get<IConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get<IConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HTTP1和HTTP2处理HTTP协议的方式有所不同，HTTP1协议解析完成后，会立即调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"处理请求，HTTP2协议解析完成后，会再次调用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadPool.UnsafeQueueUserWorkItem()"}]},{"type":"text","value":"方法等待线程池可用线程。"}]},{"type":"element","tag":"h2","props":{"id":"结束语"},"children":[{"type":"text","value":"结束语"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"服务的代码量并不下，其中主要是辅助接受用户请求和解析HTTP协议的代码，在这里不做详细的介绍，各位读者有兴趣的，可以详细阅读源代码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Kestrel"}]},{"type":"text","value":"服务在接受和处理请求时，都用到了线程池，可以极大的提高服务器的吞吐量。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"后面，我们还会详细介绍系统默认的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IHttpApplication<TContext>"}]},{"type":"text","value":"实现，看看ASP.NET Core是如何将HTTP转发到Controller和Action，其中又有哪些精妙的代码呢。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"定义-iserverihttpapplicationtcontext","depth":2,"text":"定义 - IServer、IHttpApplication<TContext>"},{"id":"web-服务器-iserver","depth":2,"text":"Web 服务器 - IServer"},{"id":"http应用程序-ihttpapplicationtcontext","depth":2,"text":"Http应用程序 - IHttpApplication<TContext>"},{"id":"实现-kestrelserver","depth":2,"text":"实现 - KestrelServer"},{"id":"服务器启动端口监听协议解析及请求处理","depth":2,"text":"服务器启动：端口监听，协议解析及请求处理。"},{"id":"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection","depth":2,"text":"处理HTTP请求 - HttpConnectionMiddleware<ServiceContext>、HttpConnection","children":[{"id":"http版本控制-httpconnection","depth":3,"text":"HTTP版本控制 - HttpConnection"}]},{"id":"结束语","depth":2,"text":"结束语"}]}},"_type":"markdown","_id":"content:dotnet:2020-08-15-Kestrel-source-code.md","_source":"content","_file":"dotnet/2020-08-15-Kestrel-source-code.md","_extension":"md","date":"2020-08-15"},{"_path":"/dotnet/2020-08-11-httpcontextaccessor-asynclocal","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","description":"在 DotNetCore 当中不再像 MVC5 那样可以通过 HttpContext.Current 来获取到当前请求的上下文。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 DotNetCore 当中不再像 MVC5 那样可以通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpContext.Current"}]},{"type":"text","value":" 来获取到当前请求的上下文。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过微软提供了一个 IHttpContextAccessor 来让我们访问当前请求的 Http 上下文，其定义\n如下："}]},{"type":"element","tag":"pre","props":{"code":"namespace Microsoft.AspNetCore.Http\n{\n    public interface IHttpContextAccessor\n    {\n        HttpContext HttpContext { get; set; }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Http\n{\n    public interface IHttpContextAccessor\n    {\n        HttpContext HttpContext { get; set; }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要使用的话需要将其添加到 Ioc 容器当中，在 Startup 类的 ConfigureService 我们可以将其默认实现注册到 Ioc 之中。"}]},{"type":"element","tag":"pre","props":{"code":"public void ConfigureService(IServiceCollection services) {\n    services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void ConfigureService(IServiceCollection services) {\n    services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么我们可以来看看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpContextAccessor"}]},{"type":"text","value":" 的具体实现:"}]},{"type":"element","tag":"pre","props":{"code":"using System.Threading;\n\nnamespace Microsoft.AspNetCore.Http\n{\n    public class HttpContextAccessor : IHttpContextAccessor\n    {\n        private static AsyncLocal<HttpContext> _httpContextCurrent = new AsyncLocal<HttpContext>();\n\n        public HttpContext HttpContext\n        {\n            get\n            {\n                return _httpContextCurrent.Value;\n            }\n            set\n            {\n                _httpContextCurrent.Value = value;\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Threading;\n\nnamespace Microsoft.AspNetCore.Http\n{\n    public class HttpContextAccessor : IHttpContextAccessor\n    {\n        private static AsyncLocal<HttpContext> _httpContextCurrent = new AsyncLocal<HttpContext>();\n\n        public HttpContext HttpContext\n        {\n            get\n            {\n                return _httpContextCurrent.Value;\n            }\n            set\n            {\n                _httpContextCurrent.Value = value;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在其内部主要是用了一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<HttpContext>"}]},{"type":"text","value":" 来保存一个 HttpContext 实例，那么 Accessor 是什么时候被赋值的呢？答案就是在每次 HTTP 请求的时候会将其赋值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 是什么东西？\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 是在 .Net 4.6 之后推出的一个对象，该对象接受一个泛型参数，其主要作用是保存异步等待上下文中共享某个变量的值。\n而异步方法是基于 Task 的自动线程调度，在异步上下文切换的时候可能导致数据丢失。例如在 await 调用之前对某个变量进行了赋值，而这个变量是多个线程间共享的，当 await 调用返回之前的调用点的时候，可能调用点之后的代码还处在之前的线程上，也有可能被调度到其他线程上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子："}]},{"type":"element","tag":"pre","props":{"code":"static async Task TestMethod() {\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static async Task TestMethod() {\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 await 等待任务执行完成之后，后面的代码输出的 ID 与调用之前的 ID 不一样，说明发生了线程切换："}]},{"type":"element","tag":"pre","props":{"code":"\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Img","src":"/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c93755a0.png"},"children":[]},{"type":"text","value":"\n从代码上看他们似乎在同一个线程，但是在执行的时候就已经发生了线程切换的操作了。\n而我们在这里如果使用一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadLocal<T>"}]},{"type":"text","value":"变量来存储的话，会发生什么事情呢？"}]},{"type":"element","tag":"pre","props":{"code":"static ThreadLocal<int> _threadLocal = new ThreadLocal<int>();\nstatic AsyncLocal<int> _asyncLocal = new AsyncLocal<int>();\n\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n\nstatic async Task TestMethod() {\n    _threadLocal.Value = 1000;\n    _asyncLocal.Value = 2000;\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static ThreadLocal<int> _threadLocal = new ThreadLocal<int>();\nstatic AsyncLocal<int> _asyncLocal = new AsyncLocal<int>();\n\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n\nstatic async Task TestMethod() {\n    _threadLocal.Value = 1000;\n    _asyncLocal.Value = 2000;\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Img","src":"/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c938eec4.png"},"children":[]},{"type":"text","value":"\nSO，在这里解释一下， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadLocal"}]},{"type":"text","value":" 是用于为不同的线程保存不同的变量值的，即同一个变量在不同线程当中存储的值可以不一样。在这里使用是为了保证在 TestMethod 方法中变量的唯一性，这个在同步方法用是没问题的，但这里使用了 await 关键字导致等待异步调用结束后代码已经被调度到其他的线程了，所以这里没用。而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 正是为了这种情况而准备的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这就解释了为什么是单例却在每个线程是不同的值."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-11-httpcontextaccessor-asynclocal.md","_source":"content","_file":"dotnet/2020-08-11-httpcontextaccessor-asynclocal.md","_extension":"md","date":"2020-08-11"},{"_path":"/dotnet/2020-08-10-param-attribute","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"c#特性参数","description":"可以通过反射获取这些特性然后做处理class Program\n{\n    static void Main(string[] args)\n    {\n        var message = new MessageData {\n\n            Header=\"header...\",\n            Body=\"body....\",\n            Footer=\"footer...\",\n        };\n\n        Type objT = typeof(Program);\n        Type fromBodyT = typeof(FromBodyAt","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以通过反射获取这些特性然后做处理"}]},{"type":"element","tag":"pre","props":{"code":"class Program\n{\n    static void Main(string[] args)\n    {\n        var message = new MessageData {\n\n            Header=\"header...\",\n            Body=\"body....\",\n            Footer=\"footer...\",\n        };\n\n        Type objT = typeof(Program);\n        Type fromBodyT = typeof(FromBodyAttribute);\n        MethodInfo method = objT.GetMethod(\"Test\");\n\n        ParameterInfo[] paramsInfo = method.GetParameters();\n        var parameters= new List<object>(paramsInfo.Length);\n        foreach (ParameterInfo parameterInfo in paramsInfo)\n        {\n            var parameter = new object();\n            if (parameterInfo.CustomAttributes.Any(i => i.AttributeType == fromBodyT))\n                parameter = message.Body;\n            parameters.Add(parameter);\n        }\n\n\n        object result = method.Invoke(null, parameters.ToArray());\n        Console.WriteLine(result);\n\n\n    }\n    public class FromBodyAttribute : Attribute\n    {\n    }\n    public static string Test([FromBody] string body)\n    {\n        return body;\n    }\n    class MessageData\n    {\n\n        public string Body { get; set; }\n        public string Header { get; set; }\n        public string Footer { get; set; }\n\n    }\n\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Program\n{\n    static void Main(string[] args)\n    {\n        var message = new MessageData {\n\n            Header=\"header...\",\n            Body=\"body....\",\n            Footer=\"footer...\",\n        };\n\n        Type objT = typeof(Program);\n        Type fromBodyT = typeof(FromBodyAttribute);\n        MethodInfo method = objT.GetMethod(\"Test\");\n\n        ParameterInfo[] paramsInfo = method.GetParameters();\n        var parameters= new List<object>(paramsInfo.Length);\n        foreach (ParameterInfo parameterInfo in paramsInfo)\n        {\n            var parameter = new object();\n            if (parameterInfo.CustomAttributes.Any(i => i.AttributeType == fromBodyT))\n                parameter = message.Body;\n            parameters.Add(parameter);\n        }\n\n\n        object result = method.Invoke(null, parameters.ToArray());\n        Console.WriteLine(result);\n\n\n    }\n    public class FromBodyAttribute : Attribute\n    {\n    }\n    public static string Test([FromBody] string body)\n    {\n        return body;\n    }\n    class MessageData\n    {\n\n        public string Body { get; set; }\n        public string Header { get; set; }\n        public string Footer { get; set; }\n\n    }\n\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-10-param-attribute.md","_source":"content","_file":"dotnet/2020-08-10-param-attribute.md","_extension":"md","date":"2020-08-10"},{"_path":"/dotnet/2020-08-09-orleans-best-practices","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"Orleans 最佳实践","description":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"重入"},"children":[{"type":"text","value":"重入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。\n可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。\n可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为访问grain一般是需要跨服务器的，所以可重入是很有必要的。。"}]},{"type":"element","tag":"h1","props":{"id":"无状态grain"},"children":[{"type":"text","value":"无状态Grain"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"grain永远是运行在服务端的,包括无状态的."}]},{"type":"element","tag":"h1","props":{"id":"time"},"children":[{"type":"text","value":"time"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"time是单线程的.."}]},{"type":"element","tag":"h2","props":{"id":"错误"},"children":[{"type":"text","value":"错误"}]},{"type":"element","tag":"pre","props":{"code":"        public override async Task OnActivateAsync()\n        {\n\n            if (this.TimerDisposable == null)\n            {\n                this.TimerDisposable = RegisterTimer(\n                            this.SaveChanges,\n                            \"timer\",\n                            TimeSpan.FromMilliseconds(0),\n                            TimeSpan.FromMilliseconds(1)\n                            );\n            }\n\n            await base.OnActivateAsync();\n        }\n\n\n\n        private Task SaveChanges(object arg)\n        {\n            this.persisitent.State.num++;\n\n            return this.persisitent.WriteStateAsync();\n        }\n\n        public async Task StartUp()\n        {\n            this.persisitent.State.num = 0;\n            await this.WriteStateAsync();\n        }\n        \n        \n           var grain = this.GrainFactory.GetGrain<ITimeTestGrain>(1000);\n\n            await grain.StartUp();\n        \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public override async Task OnActivateAsync()\n        {\n\n            if (this.TimerDisposable == null)\n            {\n                this.TimerDisposable = RegisterTimer(\n                            this.SaveChanges,\n                            \"timer\",\n                            TimeSpan.FromMilliseconds(0),\n                            TimeSpan.FromMilliseconds(1)\n                            );\n            }\n\n            await base.OnActivateAsync();\n        }\n\n\n\n        private Task SaveChanges(object arg)\n        {\n            this.persisitent.State.num++;\n\n            return this.persisitent.WriteStateAsync();\n        }\n\n        public async Task StartUp()\n        {\n            this.persisitent.State.num = 0;\n            await this.WriteStateAsync();\n        }\n        \n        \n           var grain = this.GrainFactory.GetGrain<ITimeTestGrain>(1000);\n\n            await grain.StartUp();\n        \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上代码当duetime设置为0的时候,会有类型的错误"}]},{"type":"element","tag":"pre","props":{"code":"Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原因猜测,grain未激活完成的时候,如果为0的时候,这个时候time的callback(SaveChanges)还没有加入到任务队列,就调用了state,而之后也立即同时调用了state这个时候就会报错."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决方案:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不要设置duetime为0"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"或者不要在OnActivateAsync中RegisterTimer,在Activate后再RegisterTimer"}]}]},{"type":"element","tag":"h1","props":{"id":"相关链接"},"children":[{"type":"text","value":"相关链接"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"错误","depth":2,"text":"错误"}]}},"_type":"markdown","_id":"content:dotnet:2020-08-09-Orleans-Best-Practices.md","_source":"content","_file":"dotnet/2020-08-09-Orleans-Best-Practices.md","_extension":"md","date":"2020-08-09"},{"_path":"/dotnet/2020-07-15-abp-default-language","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"abp默认语言规则","description":"abp是依托与aspnetcore的.我们先来看看aspnetcore是怎么实现的","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"abp默认语言规则"},"children":[{"type":"text","value":"abp默认语言规则"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp是依托与aspnetcore的.我们先来看看aspnetcore是怎么实现的"}]},{"type":"element","tag":"pre","props":{"code":"\n    services.Configure<RequestLocalizationOptions>(options =>\n        {\n            var supportedCultures = new List<CultureInfo>\n            {\n                new CultureInfo(\"en-US\"),\n                new CultureInfo(\"en\"),\n                new CultureInfo(\"fr-FR\"),\n                new CultureInfo(\"fr\")\n            };\n\n            options.DefaultRequestCulture = new RequestCulture(\"en-US\");\n            options.SupportedCultures = supportedCultures;\n            options.SupportedUICultures = supportedCultures;\n        });\n        \n        \n        //中间件\n        app.UseRequestLocalization();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n    services.Configure<RequestLocalizationOptions>(options =>\n        {\n            var supportedCultures = new List<CultureInfo>\n            {\n                new CultureInfo(\"en-US\"),\n                new CultureInfo(\"en\"),\n                new CultureInfo(\"fr-FR\"),\n                new CultureInfo(\"fr\")\n            };\n\n            options.DefaultRequestCulture = new RequestCulture(\"en-US\");\n            options.SupportedCultures = supportedCultures;\n            options.SupportedUICultures = supportedCultures;\n        });\n        \n        \n        //中间件\n        app.UseRequestLocalization();\n"}]}]},{"type":"element","tag":"h2","props":{"id":"中间件request的语言判断"},"children":[{"type":"text","value":"中间件request的语言判断"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在每次请求里 "},{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNet/Localization/RequestLocalizationOptions/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"RequestLocalizationOptions"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/RequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"RequestCultureProvider"}]},{"type":"text","value":" 列表会被遍历，第一个provider 会被使用来判断请求使用的文化。默认的 provider 来自"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"RequestLocalizationOptions"}]},{"type":"text","value":" 类,如果没有非空的 provider，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DefaultRequestCulture"}]},{"type":"text","value":" 被使用。所以如果发现语言不是按照逻辑顺序显示,先检查请求网址,再检查"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cookie"}]},{"type":"text","value":"(很难注意到),最后检查acceptlanguage"}]},{"type":"element","tag":"h3","props":{"id":"querystringrequestcultureprovider"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/QueryStringRequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"QueryStringRequestCultureProvider"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的例子指定了具体的区域性（语言和区域）设置为西班牙语/墨西哥："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/?culture=es-MX&ui-culture=es-MX","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/?culture=es-MX&ui-culture=es-MX"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你仅仅使用（culture 或者 ui-culture）中的一个参数进行传递，查询字符串 provider 将使用你传递一个值来设置这两个参数。例如，仅设置culture，将会同样设置 Culture 和 UICulture："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/?culture=es-MX","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/?culture=es-MX"}]}]},{"type":"element","tag":"h3","props":{"id":"cookierequestcultureprovider"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/CookieRequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"CookieRequestCultureProvider"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CookieRequestCultureProvider 的 DefaultCookieName 返回用于跟踪用户的首选区域性信息默认的 Cookie 名称。默认的 Cookie 名称是 “.AspNetCore.Culture”。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"cookie 的格式是 c=%LANGCODE%|uic=%LANGCODE%, c 为区域信息 和 uic 为 UI 区域信息，例如："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c=’en-UK’|uic=’en-US’"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果仅指定 culture 或 UI culture中的一个，指定的区域性信息将同时用于 culture和 UI culture。"}]},{"type":"element","tag":"h3","props":{"id":"acceptlanguageheaderrequestcultureprovider"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/AcceptLanguageHeaderRequestCultureProvider/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"AcceptLanguageHeaderRequestCultureProvider"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个一般是根据浏览器的设置进行访问的\n"},{"type":"element","tag":"img","props":{"alt":"image-20200719113919074","src":"/images/2020-07-15-abp-default-language/image-20200719113919074.png"},"children":[]},{"type":"text","value":"\n不同的浏览器默认语言不同,chrome浏览器可以再语言里设置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2020-07-15-abp-default-language/c83d70cf3bc79f3d3ec73c6db4a1cd11728b294d.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"cultures"},"children":[{"type":"text","value":"Cultures"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SupportedCultures"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"CultureInfo"}]},{"type":"text","value":" 对象决定了和文化相关的函数，如日期，时间，数字和货币格式的结果。同时决定了文字如何排序，大小写转换以及字符串比较。参考"},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.currentculture(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"CultureInfo.CurrentCulture"}]},{"type":"text","value":" 获取更多关于服务器如何获取文化的信息。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"SupportedUICultures"}]},{"type":"text","value":" 决定如何通过 "},{"type":"element","tag":"a","props":{"href":"https://msdn.microsoft.com/en-us/library/system.resources.resourcemanager(v=vs.110).aspx","rel":["nofollow"]},"children":[{"type":"text","value":"ResourceManager"}]},{"type":"text","value":" 查找翻译字符串（从 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":".resx"}]},{"type":"text","value":" 文件）。 "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"ResourceManager"}]},{"type":"text","value":" 只是通过 CurrentUICulture 简单的查找指定文化的字符串。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".NET 的每个线程都会拥有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CurrentCulture"}]},{"type":"text","value":" 和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"CurrentUICulture"}]},{"type":"text","value":" 对象。当 ASP.NET Core 在渲染与文化相关的函数的时候会检视这些对象值。例如，如果当前线程的区域性设置为 “en-US” （英语、美国）， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DateTime.Now.ToLongDateString() \"Thursday, February 18, 2016\""}]},{"type":"text","value":" ，但如果 CurrentCulture 设置为 “es-ES”（西班牙语、西班牙），输出将会是 “jueves, 18 de febrero de 2016”。"}]},{"type":"element","tag":"h2","props":{"id":"abp的实现"},"children":[{"type":"text","value":"abp的实现"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Volo.Abp.AspNetCore项目中DefaultAbpRequestLocalizationOptionsProvider.cs"}]},{"type":"element","tag":"pre","props":{"code":"#GetLocalizationOptionsAsync()\n#根据设置获取默认语言,如果默认语言为en\nvar languages = await languageProvider.GetLanguagesAsync();\nvar defaultLanguage = await settingProvider.GetOrNullAsync(LocalizationSettingNames.DefaultLanguage);\n\nvar options = !languages.Any()\n? new RequestLocalizationOptions()\n: new RequestLocalizationOptions\n{\nDefaultRequestCulture = DefaultGetRequestCulture(defaultLanguage, languages),\n\nSupportedCultures = languages\n.Select(l => l.CultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray(),\n\nSupportedUICultures = languages\n.Select(l => l.UiCultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray()\n};\n\n#如果设置中的默认语言不存在,则选取第一个语言作为默认语言\nprivate static RequestCulture DefaultGetRequestCulture(string defaultLanguage, IReadOnlyList<LanguageInfo> languages)\n{\n    if (defaultLanguage == null)\n    {\n    var firstLanguage = languages.First();\n    return new RequestCulture(firstLanguage.CultureName, firstLanguage.UiCultureName);\n    }\n\n    var (cultureName, uiCultureName) = LocalizationSettingHelper.ParseLanguageSetting(defaultLanguage);\n    return new RequestCulture(cultureName, uiCultureName);\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#GetLocalizationOptionsAsync()\n#根据设置获取默认语言,如果默认语言为en\nvar languages = await languageProvider.GetLanguagesAsync();\nvar defaultLanguage = await settingProvider.GetOrNullAsync(LocalizationSettingNames.DefaultLanguage);\n\nvar options = !languages.Any()\n? new RequestLocalizationOptions()\n: new RequestLocalizationOptions\n{\nDefaultRequestCulture = DefaultGetRequestCulture(defaultLanguage, languages),\n\nSupportedCultures = languages\n.Select(l => l.CultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray(),\n\nSupportedUICultures = languages\n.Select(l => l.UiCultureName)\n.Distinct()\n.Select(c => new CultureInfo(c))\n.ToArray()\n};\n\n#如果设置中的默认语言不存在,则选取第一个语言作为默认语言\nprivate static RequestCulture DefaultGetRequestCulture(string defaultLanguage, IReadOnlyList<LanguageInfo> languages)\n{\n    if (defaultLanguage == null)\n    {\n    var firstLanguage = languages.First();\n    return new RequestCulture(firstLanguage.CultureName, firstLanguage.UiCultureName);\n    }\n\n    var (cultureName, uiCultureName) = LocalizationSettingHelper.ParseLanguageSetting(defaultLanguage);\n    return new RequestCulture(cultureName, uiCultureName);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后中间件是"}]},{"type":"element","tag":"pre","props":{"code":"app.UseAbpRequestLocalization();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"app.UseAbpRequestLocalization();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"中间件使用的是AbpRequestLocalizationMiddleware,其实它只是对aspnetcore的RequestLocalizationMiddleware进行了一层包装"}]},{"type":"element","tag":"h3","props":{"id":"如何修改默认语言"},"children":[{"type":"text","value":"如何修改默认语言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先注意浏览器发送的中文的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"accept-language"}]},{"type":"text","value":"的值与ABP值是不一样的:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"浏览器(如Chrome)的值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"zh-CN"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"而ABP的简体中文的值为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"zh-Hans"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先修改配置文件appsettings.json"}]},{"type":"element","tag":"pre","props":{"code":"\"Settings\": {\n    \"Abp.Localization.DefaultLanguage\": \"zh-Hans\"\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\"Settings\": {\n    \"Abp.Localization.DefaultLanguage\": \"zh-Hans\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后在中间件中删除AcceptLanguageHeaderRequestCultureProvider"}]},{"type":"element","tag":"pre","props":{"code":"app.UseAbpRequestLocalization(options =>\n    {\n        options.RequestCultureProviders.RemoveAll(provider => provider is AcceptLanguageHeaderRequestCultureProvider);\n    }\n);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"app.UseAbpRequestLocalization(options =>\n    {\n        options.RequestCultureProviders.RemoveAll(provider => provider is AcceptLanguageHeaderRequestCultureProvider);\n    }\n);\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"中间件request的语言判断","depth":2,"text":"中间件request的语言判断","children":[{"id":"querystringrequestcultureprovider","depth":3,"text":"QueryStringRequestCultureProvider"},{"id":"cookierequestcultureprovider","depth":3,"text":"CookieRequestCultureProvider"},{"id":"acceptlanguageheaderrequestcultureprovider","depth":3,"text":"AcceptLanguageHeaderRequestCultureProvider"}]},{"id":"cultures","depth":2,"text":"Cultures"},{"id":"abp的实现","depth":2,"text":"abp的实现","children":[{"id":"如何修改默认语言","depth":3,"text":"如何修改默认语言"}]}]}},"_type":"markdown","_id":"content:dotnet:2020-07-15-abp-default-language.md","_source":"content","_file":"dotnet/2020-07-15-abp-default-language.md","_extension":"md","date":"2020-07-15"},{"_path":"/dotnet/2020-07-10-abp-doc","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"abp的dOC模块使用","description":"配置原理abp 使用拉的方式从github直接请求,然后存储到数据库作为缓存注意开发环境下,他会从github直接拉取而不会经过数据库缓存,所以会很慢关于版本当你写完书的时候.打个tag,然后把tag的版本号填入上方的..最新版本的分支名称即可关于多语言注意多语言abp使用了缓存..所以如果你更改了docs-langs.json,需要重启服务器,或者清空缓存{\n    \"Languages\":[\n      {\n        \"DisplayName\" : \"English\",\n        \"Code\" : \"en\",\n        \"IsDefault\": false\n      }","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"配置"},"children":[{"type":"text","value":"配置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200716181126415","src":"/images/2020-07-10-abp-doc/image-20200716181126415.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"原理"},"children":[{"type":"text","value":"原理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp 使用拉的方式从github直接请求,然后存储到数据库作为缓存"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意开发环境下,他会从github直接拉取而不会经过数据库缓存,所以会很慢"}]},{"type":"element","tag":"h1","props":{"id":"关于版本"},"children":[{"type":"text","value":"关于版本"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当你写完书的时候.打个tag,然后把tag的版本号填入上方的..最新版本的分支名称即可"}]},{"type":"element","tag":"h1","props":{"id":"关于多语言"},"children":[{"type":"text","value":"关于多语言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意多语言abp使用了缓存..所以如果你更改了docs-langs.json,需要重启服务器,或者清空缓存"}]},{"type":"element","tag":"pre","props":{"code":"{\n    \"Languages\":[\n      {\n        \"DisplayName\" : \"English\",\n        \"Code\" : \"en\",\n        \"IsDefault\": false\n      },\n      {\n        \"DisplayName\" : \"简体中文\",\n        \"Code\" : \"zh\",\n        \"IsDefault\": true\n      }\n    ]\n  }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n    \"Languages\":[\n      {\n        \"DisplayName\" : \"English\",\n        \"Code\" : \"en\",\n        \"IsDefault\": false\n      },\n      {\n        \"DisplayName\" : \"简体中文\",\n        \"Code\" : \"zh\",\n        \"IsDefault\": true\n      }\n    ]\n  }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"关于参数doc-params"},"children":[{"type":"text","value":"关于参数[doc-params]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp使用了scriban文本模板语言引擎."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/lunet-io/scriban","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/lunet-io/scriban"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体的示例参见:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&DB=EF&Tiered=No","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&DB=EF&Tiered=No"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.md","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.md"}]}]}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"parameters\": [\n    {\n      \"name\": \"UI\",\n      \"displayName\": \"UI\",\n      \"values\": {\n        \"MVC\": \"MVC / Razor Pages\",\n        \"NG\": \"Angular\"\n      }\n    },\n    {\n      \"name\": \"DB\",\n      \"displayName\": \"Database\",\n      \"values\": {\n        \"EF\": \"Entity Framework Core\",\n        \"Mongo\": \"MongoDB\"\n      }\n    },\n    {\n      \"name\": \"Tiered\",\n      \"displayName\": \"Tiered\",\n      \"values\": {\n        \"No\": \"Not Tiered\",\n        \"Yes\": \"Tiered\"\n      }\n    }\n  ]\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"parameters\": [\n    {\n      \"name\": \"UI\",\n      \"displayName\": \"UI\",\n      \"values\": {\n        \"MVC\": \"MVC / Razor Pages\",\n        \"NG\": \"Angular\"\n      }\n    },\n    {\n      \"name\": \"DB\",\n      \"displayName\": \"Database\",\n      \"values\": {\n        \"EF\": \"Entity Framework Core\",\n        \"Mongo\": \"MongoDB\"\n      }\n    },\n    {\n      \"name\": \"Tiered\",\n      \"displayName\": \"Tiered\",\n      \"values\": {\n        \"No\": \"Not Tiered\",\n        \"Yes\": \"Tiered\"\n      }\n    }\n  ]\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"markdow中使用"}]},{"type":"element","tag":"pre","props":{"code":"//[doc-params]\n{\n    \"UI\": [\"MVC\",\"NG\"],\n    \"DB\": [\"EF\", \"Mongo\"],\n    \"Tiered\": [\"Yes\", \"No\"]\n}\n本教程介绍了如何创建一个新的{{if UI == \"MVC\"}} ASP.NET Core MVC web {{else if UI == \"NG\"}} Angular {{end}}. 配置并运行它.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//[doc-params]\n{\n    \"UI\": [\"MVC\",\"NG\"],\n    \"DB\": [\"EF\", \"Mongo\"],\n    \"Tiered\": [\"Yes\", \"No\"]\n}\n本教程介绍了如何创建一个新的{{if UI == \"MVC\"}} ASP.NET Core MVC web {{else if UI == \"NG\"}} Angular {{end}}. 配置并运行它.\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生成的html"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200718164036943","src":"/images/2020-07-10-abp-doc/image-20200718164036943.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当切换ui的值后的显示,我们看到字符发生了改变"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200718164137023","src":"/images/2020-07-10-abp-doc/image-20200718164137023.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"关于doc-template"},"children":[{"type":"text","value":"关于[doc-template]"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还没看到如何用"}]},{"type":"element","tag":"h1","props":{"id":"_404"},"children":[{"type":"text","value":"404"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为访问github如果超时就会出现404."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以建议控制台设置代理然后运行"}]},{"type":"element","tag":"pre","props":{"code":"$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ndotnet run .\\IG.Www.Web.csproj\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"$env:http_proxy=\"http://127.0.0.1:1080\"\n$env:https_proxy=\"http://127.0.0.1:1080\"\ndotnet run .\\IG.Www.Web.csproj\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-07-10-abp-doc.md","_source":"content","_file":"dotnet/2020-07-10-abp-doc.md","_extension":"md","date":"2020-07-10"},{"_path":"/dotnet/2020-07-05-abp-database-user","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"关于abp的用户的一些问题","description":"abp的dbcontext是分成两种的,一个是程序运行的dbcontext,一个是数据迁移的dbcontext","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"数据迁移上下文"},"children":[{"type":"text","value":"数据迁移上下文"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"abp的dbcontext是分成两种的,一个是程序运行的dbcontext,一个是数据迁移的dbcontext"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundMigrationsDbContext.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Include modules to your migration db context */\n\n            builder.ConfigurePermissionManagement();\n            builder.ConfigureSettingManagement();\n            builder.ConfigureBackgroundJobs();\n            builder.ConfigureAuditLogging();\n            builder.ConfigureIdentity();\n            builder.ConfigureIdentityServer();\n            builder.ConfigureFeatureManagement();\n            builder.ConfigureTenantManagement();\n\n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n            builder.ConfigureBlogging();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Include modules to your migration db context */\n\n            builder.ConfigurePermissionManagement();\n            builder.ConfigureSettingManagement();\n            builder.ConfigureBackgroundJobs();\n            builder.ConfigureAuditLogging();\n            builder.ConfigureIdentity();\n            builder.ConfigureIdentityServer();\n            builder.ConfigureFeatureManagement();\n            builder.ConfigureTenantManagement();\n\n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n            builder.ConfigureBlogging();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundDbContext.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Configure the shared tables (with included modules) here */\n\n            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n            });\n \n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            /* Configure the shared tables (with included modules) here */\n\n            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n            });\n \n            /* Configure your own tables/entities inside the ConfigurePlayGround method */\n\n            builder.ConfigurePlayGround();\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们看到他们共同执行了 builder.ConfigurePlayGround();"}]},{"type":"element","tag":"h2","props":{"id":"为什么这样设计"},"children":[{"type":"text","value":"为什么这样设计?"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为了模块间不产生依赖,例如用户表,迁移dbcontext中使用了IdentityUser,而运行的dbcontext使用了appuser进行了对其的映射,"},{"type":"element","tag":"a","props":{"href":"https://github.com/abpframework/abp/issues/1998","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/abpframework/abp/issues/1998"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如何为user添加属性."},{"type":"element","tag":"a","props":{"href":"https://github.com/abpframework/abp/issues/2453","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/abpframework/abp/issues/2453"}]}]}]},{"type":"element","tag":"h1","props":{"id":"如何共用user"},"children":[{"type":"text","value":"如何共用user"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们来看下定义的Iuser接口"}]},{"type":"element","tag":"pre","props":{"code":"    public interface IUser : IAggregateRoot<Guid>, IMultiTenant\n    {\n        string UserName { get; }\n\n        [CanBeNull]\n        string Email { get; }\n\n        [CanBeNull]\n        string Name  { get; }\n\n        [CanBeNull]\n        string Surname { get; }\n\n        bool EmailConfirmed { get; }\n\n        [CanBeNull]\n        string PhoneNumber { get; }\n\n        bool PhoneNumberConfirmed { get; }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public interface IUser : IAggregateRoot<Guid>, IMultiTenant\n    {\n        string UserName { get; }\n\n        [CanBeNull]\n        string Email { get; }\n\n        [CanBeNull]\n        string Name  { get; }\n\n        [CanBeNull]\n        string Surname { get; }\n\n        bool EmailConfirmed { get; }\n\n        [CanBeNull]\n        string PhoneNumber { get; }\n\n        bool PhoneNumberConfirmed { get; }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"dbcontext中的配置字段"}]},{"type":"element","tag":"pre","props":{"code":"        public static void ConfigureAbpUser<TUser>(this EntityTypeBuilder<TUser> b)\n            where TUser : class, IUser\n        {\n            b.Property(u => u.TenantId).HasColumnName(nameof(IUser.TenantId));\n            b.Property(u => u.UserName).IsRequired().HasMaxLength(AbpUserConsts.MaxUserNameLength).HasColumnName(nameof(IUser.UserName));\n            b.Property(u => u.Email).IsRequired().HasMaxLength(AbpUserConsts.MaxEmailLength).HasColumnName(nameof(IUser.Email));\n            b.Property(u => u.Name).HasMaxLength(AbpUserConsts.MaxNameLength).HasColumnName(nameof(IUser.Name));\n            b.Property(u => u.Surname).HasMaxLength(AbpUserConsts.MaxSurnameLength).HasColumnName(nameof(IUser.Surname));\n            b.Property(u => u.EmailConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.EmailConfirmed));\n            b.Property(u => u.PhoneNumber).HasMaxLength(AbpUserConsts.MaxPhoneNumberLength).HasColumnName(nameof(IUser.PhoneNumber));\n            b.Property(u => u.PhoneNumberConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.PhoneNumberConfirmed));\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static void ConfigureAbpUser<TUser>(this EntityTypeBuilder<TUser> b)\n            where TUser : class, IUser\n        {\n            b.Property(u => u.TenantId).HasColumnName(nameof(IUser.TenantId));\n            b.Property(u => u.UserName).IsRequired().HasMaxLength(AbpUserConsts.MaxUserNameLength).HasColumnName(nameof(IUser.UserName));\n            b.Property(u => u.Email).IsRequired().HasMaxLength(AbpUserConsts.MaxEmailLength).HasColumnName(nameof(IUser.Email));\n            b.Property(u => u.Name).HasMaxLength(AbpUserConsts.MaxNameLength).HasColumnName(nameof(IUser.Name));\n            b.Property(u => u.Surname).HasMaxLength(AbpUserConsts.MaxSurnameLength).HasColumnName(nameof(IUser.Surname));\n            b.Property(u => u.EmailConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.EmailConfirmed));\n            b.Property(u => u.PhoneNumber).HasMaxLength(AbpUserConsts.MaxPhoneNumberLength).HasColumnName(nameof(IUser.PhoneNumber));\n            b.Property(u => u.PhoneNumberConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.PhoneNumberConfirmed));\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"dbcontext中的user表是如何创建,更新和使用的.."},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"UserLookupService.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看下查找,其中"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IdentityUserRepositoryExternalUserLookupServiceProvider : IExternalUserLookupServiceProvider,"}]}]},{"type":"element","tag":"pre","props":{"code":" public async Task<TUser> FindByIdAsync(Guid id, CancellationToken cancellationToken = default)\n        {\n            var localUser = await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n\n            if (ExternalUserLookupServiceProvider == null)\n            {\n                return localUser;\n            }\n\n            if (SkipExternalLookupIfLocalUserExists && localUser != null)\n            {\n                return localUser;\n            }\n\n            IUserData externalUser;\n\n            try\n            {\n                externalUser = await ExternalUserLookupServiceProvider.FindByIdAsync(id, cancellationToken);\n                if (externalUser == null)\n                {\n                    if (localUser != null)\n                    {\n                        //TODO: Instead of deleting, should be make it inactive or something like that?\n                        await WithNewUowAsync(() => _userRepository.DeleteAsync(localUser, cancellationToken: cancellationToken));\n                    }\n\n                    return null;\n                }\n            }\n            catch (Exception ex)\n            {\n                Logger.LogException(ex);\n                return localUser;\n            }\n\n            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n\n            return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" public async Task<TUser> FindByIdAsync(Guid id, CancellationToken cancellationToken = default)\n        {\n            var localUser = await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n\n            if (ExternalUserLookupServiceProvider == null)\n            {\n                return localUser;\n            }\n\n            if (SkipExternalLookupIfLocalUserExists && localUser != null)\n            {\n                return localUser;\n            }\n\n            IUserData externalUser;\n\n            try\n            {\n                externalUser = await ExternalUserLookupServiceProvider.FindByIdAsync(id, cancellationToken);\n                if (externalUser == null)\n                {\n                    if (localUser != null)\n                    {\n                        //TODO: Instead of deleting, should be make it inactive or something like that?\n                        await WithNewUowAsync(() => _userRepository.DeleteAsync(localUser, cancellationToken: cancellationToken));\n                    }\n\n                    return null;\n                }\n            }\n            catch (Exception ex)\n            {\n                Logger.LogException(ex);\n                return localUser;\n            }\n\n            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n\n            return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据上面代码可见,如果找不到该用户..会自动创建一个,如何继承了IUpdateUserData则会更新"}]},{"type":"element","tag":"pre","props":{"code":"            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"            if (localUser == null)\n            {\n                await WithNewUowAsync(() => _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));\n                return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);\n            }\n\n            if (localUser is IUpdateUserData && ((IUpdateUserData)localUser).Update(externalUser))\n            {\n                await WithNewUowAsync(() => _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));\n            }\n            else\n            {\n                return localUser;\n            }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更新还可以通过eventbus"}]},{"type":"element","tag":"pre","props":{"code":"    public class BlogUserSynchronizer :\n        IDistributedEventHandler<EntityUpdatedEto<UserEto>>,\n        ITransientDependency\n    {\n        protected IBlogUserRepository UserRepository { get; }\n        protected IBlogUserLookupService UserLookupService { get; }\n\n        public BlogUserSynchronizer(\n            IBlogUserRepository userRepository, \n            IBlogUserLookupService userLookupService)\n        {\n            UserRepository = userRepository;\n            UserLookupService = userLookupService;\n        }\n\n        public async Task HandleEventAsync(EntityUpdatedEto<UserEto> eventData)\n        {\n            var user = await UserRepository.FindAsync(eventData.Entity.Id);\n            if (user == null)\n            {\n                user = await UserLookupService.FindByIdAsync(eventData.Entity.Id);\n                if (user == null)\n                {\n                    return;\n                }\n            }\n\n            if (user.Update(eventData.Entity))\n            {\n                await UserRepository.UpdateAsync(user);\n            }\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public class BlogUserSynchronizer :\n        IDistributedEventHandler<EntityUpdatedEto<UserEto>>,\n        ITransientDependency\n    {\n        protected IBlogUserRepository UserRepository { get; }\n        protected IBlogUserLookupService UserLookupService { get; }\n\n        public BlogUserSynchronizer(\n            IBlogUserRepository userRepository, \n            IBlogUserLookupService userLookupService)\n        {\n            UserRepository = userRepository;\n            UserLookupService = userLookupService;\n        }\n\n        public async Task HandleEventAsync(EntityUpdatedEto<UserEto> eventData)\n        {\n            var user = await UserRepository.FindAsync(eventData.Entity.Id);\n            if (user == null)\n            {\n                user = await UserLookupService.FindByIdAsync(eventData.Entity.Id);\n                if (user == null)\n                {\n                    return;\n                }\n            }\n\n            if (user.Update(eventData.Entity))\n            {\n                await UserRepository.UpdateAsync(user);\n            }\n        }\n    }\n"}]}]},{"type":"element","tag":"h1","props":{"id":"如何给identityuser添加额外的属性"},"children":[{"type":"text","value":"如何给IdentityUser添加额外的属性"}]},{"type":"element","tag":"h2","props":{"id":"extra-properties"},"children":[{"type":"text","value":"Extra Properties"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先IdentityUser已经被定义,虽然我们可以通过dbcontext配置修改数据表的字段,,但是不能被映射,所以有了Extra Properties"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities"}]}]},{"type":"element","tag":"h2","props":{"id":"映射"},"children":[{"type":"text","value":"映射"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会在数据库中创建字段"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AppUser.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        public virtual string Sex { get; private set; }\n\n        private AppUser()\n        {\n\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public virtual string Sex { get; private set; }\n\n        private AppUser()\n        {\n\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundDbContext.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n\n                b.Property(x => x.Sex).HasMaxLength(128);\n            });\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"            builder.Entity<AppUser>(b =>\n            {\n                b.ToTable(AbpIdentityDbProperties.DbTablePrefix + \"Users\"); //Sharing the same table \"AbpUsers\" with the IdentityUser\n\n                b.ConfigureByConvention();\n                b.ConfigureAbpUser();\n\n                /* Configure mappings for your additional properties\n                 * Also see the PlayGroundEfCoreEntityExtensionMappings class\n                 */\n\n                b.Property(x => x.Sex).HasMaxLength(128);\n            });\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"PlayGroundEfCoreEntityExtensionMappings.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"       public static void Configure()\n        {\n            PlayGroundModulePropertyConfigurator.Configure();\n\n            OneTimeRunner.Run(() =>\n            {\n                /* You can configure entity extension properties for the\n                 * entities defined in the used modules.\n                 *\n                 * The properties defined here becomes table fields.\n                 * If you want to use the ExtraProperties dictionary of the entity\n                 * instead of creating a new field, then define the property in the\n                 * PlayGroundDomainObjectExtensions class.\n                 *\n                 * Example:\n                 *\n                 * ObjectExtensionManager.Instance\n                 *    .MapEfCoreProperty<IdentityUser, string>(\n                 *        \"MyProperty\",\n                 *        b => b.HasMaxLength(128)\n                 *    );\n                 *\n                 * See the documentation for more:\n                 * https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Extending-Entities\n                 */\n\n                ObjectExtensionManager.Instance\n                      .MapEfCoreProperty<IdentityUser, string>(\n                  nameof(AppUser.Sex),\n                  b => b.HasMaxLength(128)\n                      );\n            });\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"       public static void Configure()\n        {\n            PlayGroundModulePropertyConfigurator.Configure();\n\n            OneTimeRunner.Run(() =>\n            {\n                /* You can configure entity extension properties for the\n                 * entities defined in the used modules.\n                 *\n                 * The properties defined here becomes table fields.\n                 * If you want to use the ExtraProperties dictionary of the entity\n                 * instead of creating a new field, then define the property in the\n                 * PlayGroundDomainObjectExtensions class.\n                 *\n                 * Example:\n                 *\n                 * ObjectExtensionManager.Instance\n                 *    .MapEfCoreProperty<IdentityUser, string>(\n                 *        \"MyProperty\",\n                 *        b => b.HasMaxLength(128)\n                 *    );\n                 *\n                 * See the documentation for more:\n                 * https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Extending-Entities\n                 */\n\n                ObjectExtensionManager.Instance\n                      .MapEfCoreProperty<IdentityUser, string>(\n                  nameof(AppUser.Sex),\n                  b => b.HasMaxLength(128)\n                      );\n            });\n        }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们来看看生成的迁移表"}]},{"type":"element","tag":"pre","props":{"code":"    public partial class Added_Sex_T_User : Migration\n    {\n        protected override void Up(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.AddColumn<string>(\n                name: \"Sex\",\n                table: \"AbpUsers\",\n                maxLength: 128,\n                nullable: true);\n        }\n\n        protected override void Down(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.DropColumn(\n                name: \"Sex\",\n                table: \"AbpUsers\");\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    public partial class Added_Sex_T_User : Migration\n    {\n        protected override void Up(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.AddColumn<string>(\n                name: \"Sex\",\n                table: \"AbpUsers\",\n                maxLength: 128,\n                nullable: true);\n        }\n\n        protected override void Down(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.DropColumn(\n                name: \"Sex\",\n                table: \"AbpUsers\");\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200714123314743","src":"/images/2020-07-05-abp-database-migration/image-20200714123314743.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它时如何被添加到迁移dbcontext中的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AbpEntityTypeBuilderExtensions.cs"}]}]},{"type":"element","tag":"pre","props":{"code":"        public static void ConfigureByConvention(this EntityTypeBuilder b)\n        {\n            b.TryConfigureConcurrencyStamp();\n            b.TryConfigureExtraProperties();  //配置扩展属性,就是ExtraProperties字段\n            b.TryConfigureObjectExtensions();//就是这里对象扩展,ObjectExtensionManager.Instance添加属性,然后从这里再根据类型读取出来\n            b.TryConfigureMayHaveCreator();\n            b.TryConfigureMustHaveCreator();\n            b.TryConfigureSoftDelete();\n            b.TryConfigureDeletionTime();\n            b.TryConfigureDeletionAudited();\n            b.TryConfigureCreationTime();\n            b.TryConfigureLastModificationTime();\n            b.TryConfigureModificationAudited();\n            b.TryConfigureMultiTenant();\n        }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        public static void ConfigureByConvention(this EntityTypeBuilder b)\n        {\n            b.TryConfigureConcurrencyStamp();\n            b.TryConfigureExtraProperties();  //配置扩展属性,就是ExtraProperties字段\n            b.TryConfigureObjectExtensions();//就是这里对象扩展,ObjectExtensionManager.Instance添加属性,然后从这里再根据类型读取出来\n            b.TryConfigureMayHaveCreator();\n            b.TryConfigureMustHaveCreator();\n            b.TryConfigureSoftDelete();\n            b.TryConfigureDeletionTime();\n            b.TryConfigureDeletionAudited();\n            b.TryConfigureCreationTime();\n            b.TryConfigureLastModificationTime();\n            b.TryConfigureModificationAudited();\n            b.TryConfigureMultiTenant();\n        }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"同步"},"children":[{"type":"text","value":"同步"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以创建"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"自己的表"}]},{"type":"text","value":"来存储属性,而不是创建新实体并映射到同一表. 你通常复制原始实体的一些值. 例如可以将 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Name"}]},{"type":"text","value":" 字段添加到你自己的表中,它是原表中 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Name"}]},{"type":"text","value":" 字段的副本."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这种情况下你不需要处理迁移问题,但是需要处理数据复制问题. 当重复的值发生变化时,你应该在表中同步相同的变化. 你可以使用本地或分布式"},{"type":"element","tag":"a","props":{"href":"https://docs.abp.io/zh-Hans/abp/latest/Event-Bus","rel":["nofollow"]},"children":[{"type":"text","value":"事件总线"}]},{"type":"text","value":"订阅原始实体的更改事件. 这是根据来自另一个微服务的数据推荐的方法,特别是如果它们有单独的物理数据库(你可以在网络中搜索关于微服务设计的数据共享,这是一个广泛的主题)."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"为什么这样设计","depth":2,"text":"为什么这样设计?"},{"id":"extra-properties","depth":2,"text":"Extra Properties"},{"id":"映射","depth":2,"text":"映射"},{"id":"同步","depth":2,"text":"同步"}]}},"_type":"markdown","_id":"content:dotnet:2020-07-05-abp-database-user.md","_source":"content","_file":"dotnet/2020-07-05-abp-database-user.md","_extension":"md","date":"2020-07-05"},{"_path":"/dotnet/2020-06-11-identityserver-use","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":"2020 06 11 IdentityServer Use","description":"DotHass.Lobby.Domain\\IdentityServer\\IdentityServerDataSeedContributor.cs 中 CreateClientsAsync()","stitle":"IdentityServer使用指南","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"DotHass.Lobby.Domain\\IdentityServer\\IdentityServerDataSeedContributor.cs 中 CreateClientsAsync()"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"会在dataseed的时候生成默认数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When I try to send a HTTPS POST request from a desktop (Servers are in production environment) the following message is displayed inside the console :"}]},{"type":"element","tag":"pre","props":{"code":"Error: unable to verify the first certificate\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Error: unable to verify the first certificate\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Postman -> Preferences -> General -> SSL certificate validation -> OFF"}]},{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"it works"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://localhost:5000/.well-known/openid-configuration","rel":["nofollow"]},"children":[{"type":"text","value":"https://localhost:5000/.well-known/openid-configuration"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/connect/token","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/connect/token"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"img","props":{"alt":"image-20200613165200371","src":"/images/2020-06-11-IdentityServer-use/image-20200613165200371.png"},"children":[]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://localhost:5000/connect/userinfo","rel":["nofollow"]},"children":[{"type":"text","value":"http://localhost:5000/connect/userinfo"}]},{"type":"text","value":" 将type设置成bearer token,token填入上面获得的access_token"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image-20200613165246959","src":"/images/2020-06-11-IdentityServer-use/image-20200613165246959.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.注意发布release后.配置表中的  ..如果配置错误将会认证失败"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"appsettings.json"}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"App\": {\n    \"SelfUrl\": \"http://localhost:5000\"\n  },\n  \"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;User Id=root;Password=123456;Database=dothass.blog\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"http://localhost:5000\"\n  },\n  \"IdentityServer\": {\n    \"Clients\": {\n      \"Blog_App\": {\n        \"ClientId\": \"Blog_App\"\n      }\n    }\n  }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"App\": {\n    \"SelfUrl\": \"http://localhost:5000\"\n  },\n  \"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;User Id=root;Password=123456;Database=dothass.blog\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"http://localhost:5000\"\n  },\n  \"IdentityServer\": {\n    \"Clients\": {\n      \"Blog_App\": {\n        \"ClientId\": \"Blog_App\"\n      }\n    }\n  }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"appsettings.Development.json"}]},{"type":"element","tag":"pre","props":{"code":"{\n  \"App\": {\n    \"SelfUrl\": \"https://localhost:44377\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"https://localhost:44377\"\n  }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n  \"App\": {\n    \"SelfUrl\": \"https://localhost:44377\"\n  },\n  \"AuthServer\": {\n    \"Authority\": \"https://localhost:44377\"\n  }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还要注意请求的域名是否一样,127.0.0.1或者localhost...可能返回结果即使一样.但是不能授权."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"},{"type":"element","tag":"a","props":{"href":"http://jwt.calebb.net/%E8%A7%A3%E6%9E%90%E7%9C%8B%E4%B8%8Baccess_token","rel":["nofollow"]},"children":[{"type":"text","value":"http://jwt.calebb.net/解析看下access_token"}]}]},{"type":"element","tag":"pre","props":{"code":"{\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592054993,\n exp: 1623590993,\n iss: \"http://127.0.0.1:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592054993,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592054993,\n exp: 1623590993,\n iss: \"http://127.0.0.1:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592054993,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"}]}]},{"type":"element","tag":"pre","props":{"code":"    {\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592055396,\n exp: 1623591396,\n iss: \"http://localhost:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592055396,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    {\n alg: \"RS256\",\n kid: \"1oauLjO2TtmvAH-4A7CCLg\",\n typ: \"at+jwt\"\n}.\n{\n nbf: 1592055396,\n exp: 1623591396,\n iss: \"http://localhost:5000\",\n aud: \"Blog\",\n client_id: \"Blog_App\",\n sub: \"fa9626f7-0f6f-6158-2afd-39f5a7f6d03f\",\n auth_time: 1592055396,\n idp: \"local\",\n role: \"admin\",\n name: \"admin\",\n email: \"admin@abp.io\",\n email_verified: false,\n scope: [\n  \"address\",\n  \"email\",\n  \"openid\",\n  \"phone\",\n  \"profile\",\n  \"role\",\n  \"Blog\",\n  \"offline_access\"\n ],\n amr: [\n  \"pwd\"\n ]\n}.\n"}]}]},{"type":"element","tag":"h1","props":{"id":"错误"},"children":[{"type":"text","value":"错误"}]},{"type":"element","tag":"pre","props":{"code":"System.InvalidOperationException: IDX20803: Unable to obtain configuration from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.IO.IOException: IDX20804: Unable to retrieve document from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.\n ---> System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure.\n   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"System.InvalidOperationException: IDX20803: Unable to obtain configuration from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.IO.IOException: IDX20804: Unable to retrieve document from: '[PII is hidden. For more details, see https://aka.ms/IdentityModel/PII.]'.\n ---> System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.\n ---> System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure.\n   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)\n   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)\n   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看出来这些问题是和SSL证书有关，经过排查，发现IdentityServer4配置中：使用了"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"IP"}]},{"type":"text","value":"的形式配置的授权地址，但是SSL证书是以域名形式申请的，这就造成了SSL证书不能验证通过。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解决方法："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"将授权地址配置为域名:端口的形式"}]},{"type":"text","value":"，完美解决上述问题。注意域名为SSL证书申请时用到的域名。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"localhost使用的是开发证书,也是类似域名,127.0.0.1也是有问题的"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-06-11-IdentityServer-use.md","_source":"content","_file":"dotnet/2020-06-11-IdentityServer-use.md","_extension":"md","date":"2020-06-11"}]