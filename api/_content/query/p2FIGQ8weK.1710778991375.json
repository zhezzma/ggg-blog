{"_path":"/dotnet/2020-08-11-httpcontextaccessor-asynclocal","_dir":"dotnet","_draft":false,"_partial":false,"_locale":"","title":".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","description":"在 DotNetCore 当中不再像 MVC5 那样可以通过 HttpContext.Current 来获取到当前请求的上下文。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 DotNetCore 当中不再像 MVC5 那样可以通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpContext.Current"}]},{"type":"text","value":" 来获取到当前请求的上下文。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不过微软提供了一个 IHttpContextAccessor 来让我们访问当前请求的 Http 上下文，其定义\n如下："}]},{"type":"element","tag":"pre","props":{"code":"namespace Microsoft.AspNetCore.Http\n{\n    public interface IHttpContextAccessor\n    {\n        HttpContext HttpContext { get; set; }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"namespace Microsoft.AspNetCore.Http\n{\n    public interface IHttpContextAccessor\n    {\n        HttpContext HttpContext { get; set; }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要使用的话需要将其添加到 Ioc 容器当中，在 Startup 类的 ConfigureService 我们可以将其默认实现注册到 Ioc 之中。"}]},{"type":"element","tag":"pre","props":{"code":"public void ConfigureService(IServiceCollection services) {\n    services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public void ConfigureService(IServiceCollection services) {\n    services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那么我们可以来看看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpContextAccessor"}]},{"type":"text","value":" 的具体实现:"}]},{"type":"element","tag":"pre","props":{"code":"using System.Threading;\n\nnamespace Microsoft.AspNetCore.Http\n{\n    public class HttpContextAccessor : IHttpContextAccessor\n    {\n        private static AsyncLocal<HttpContext> _httpContextCurrent = new AsyncLocal<HttpContext>();\n\n        public HttpContext HttpContext\n        {\n            get\n            {\n                return _httpContextCurrent.Value;\n            }\n            set\n            {\n                _httpContextCurrent.Value = value;\n            }\n        }\n    }\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"using System.Threading;\n\nnamespace Microsoft.AspNetCore.Http\n{\n    public class HttpContextAccessor : IHttpContextAccessor\n    {\n        private static AsyncLocal<HttpContext> _httpContextCurrent = new AsyncLocal<HttpContext>();\n\n        public HttpContext HttpContext\n        {\n            get\n            {\n                return _httpContextCurrent.Value;\n            }\n            set\n            {\n                _httpContextCurrent.Value = value;\n            }\n        }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在其内部主要是用了一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<HttpContext>"}]},{"type":"text","value":" 来保存一个 HttpContext 实例，那么 Accessor 是什么时候被赋值的呢？答案就是在每次 HTTP 请求的时候会将其赋值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 是什么东西？\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 是在 .Net 4.6 之后推出的一个对象，该对象接受一个泛型参数，其主要作用是保存异步等待上下文中共享某个变量的值。\n而异步方法是基于 Task 的自动线程调度，在异步上下文切换的时候可能导致数据丢失。例如在 await 调用之前对某个变量进行了赋值，而这个变量是多个线程间共享的，当 await 调用返回之前的调用点的时候，可能调用点之后的代码还处在之前的线程上，也有可能被调度到其他线程上。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子："}]},{"type":"element","tag":"pre","props":{"code":"static async Task TestMethod() {\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static async Task TestMethod() {\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 await 等待任务执行完成之后，后面的代码输出的 ID 与调用之前的 ID 不一样，说明发生了线程切换："}]},{"type":"element","tag":"pre","props":{"code":"\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Img","src":"/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c93755a0.png"},"children":[]},{"type":"text","value":"\n从代码上看他们似乎在同一个线程，但是在执行的时候就已经发生了线程切换的操作了。\n而我们在这里如果使用一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadLocal<T>"}]},{"type":"text","value":"变量来存储的话，会发生什么事情呢？"}]},{"type":"element","tag":"pre","props":{"code":"static ThreadLocal<int> _threadLocal = new ThreadLocal<int>();\nstatic AsyncLocal<int> _asyncLocal = new AsyncLocal<int>();\n\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n\nstatic async Task TestMethod() {\n    _threadLocal.Value = 1000;\n    _asyncLocal.Value = 2000;\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"static ThreadLocal<int> _threadLocal = new ThreadLocal<int>();\nstatic AsyncLocal<int> _asyncLocal = new AsyncLocal<int>();\n\nstatic void Main(string[] args) {\n    Action @delegate = async () => await TestMethod();\n\n    @delegate();\n    Console.ReadKey();\n}\n\nstatic async Task TestMethod() {\n    _threadLocal.Value = 1000;\n    _asyncLocal.Value = 2000;\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n    await Task.Delay(100);\n    Console.WriteLine($\"当前线程ID{Thread.CurrentThread.ManagedThreadId}\");\n    Console.WriteLine($\"{nameof(_threadLocal)}，值:{_threadLocal.Value}\");\n    Console.WriteLine($\"{nameof(_asyncLocal)}，值:{_asyncLocal.Value}\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Img","src":"/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c938eec4.png"},"children":[]},{"type":"text","value":"\nSO，在这里解释一下， "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ThreadLocal"}]},{"type":"text","value":" 是用于为不同的线程保存不同的变量值的，即同一个变量在不同线程当中存储的值可以不一样。在这里使用是为了保证在 TestMethod 方法中变量的唯一性，这个在同步方法用是没问题的，但这里使用了 await 关键字导致等待异步调用结束后代码已经被调度到其他的线程了，所以这里没用。而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AsyncLocal<T>"}]},{"type":"text","value":" 正是为了这种情况而准备的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这就解释了为什么是单例却在每个线程是不同的值."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:dotnet:2020-08-11-httpcontextaccessor-asynclocal.md","_source":"content","_file":"dotnet/2020-08-11-httpcontextaccessor-asynclocal.md","_extension":"md","date":"2020-08-11"}