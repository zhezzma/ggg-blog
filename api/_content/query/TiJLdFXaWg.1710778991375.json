{"_path":"/unity/2021-06-14-unity-render-order","_dir":"unity","_draft":false,"_partial":false,"_locale":"","title":"UNITY的渲染顺序","description":"工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求：","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gist.github.com/qxsoftware/499135b6482ca57727c69e11b91a12bf","rel":["nofollow"]},"children":[{"type":"text","value":"MeshRendererInspector.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/mesh-renderer-inspector.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何添加新的 SortingLayer？请通过 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Edit/Project Settings/Tags and Layers"}]},{"type":"text","value":" 菜单选项打开："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/tags-layers.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后添加三个 Sorting Layer，如上图所示。注意，Sorting Layer 添加后是可以拖动调整顺序的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"便捷修改 Camera 的 opaqueSortMode 和 transparencySortMode："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gist.github.com/qxsoftware/1821915377e333e45f7a632ae07e64aa","rel":["nofollow"]},"children":[{"type":"text","value":"CameraInspector.cs"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"效果如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/sort-mode.jpg"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"实际测试"},"children":[{"type":"text","value":"实际测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试之前首先明确两点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"什么因素影响绘制顺序"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"深度缓冲区对绘制结果的影响"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为了弄清楚第一点，什么因素影响绘制顺序，我们需要把 ZWrite 关闭。同时结合 Unity Frame Debugger来观察绘制顺序。"}]},{"type":"element","tag":"h5","props":{"id":"render-queue"},"children":[{"type":"text","value":"Render Queue"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"RenderQueue 是材质（Material）的关键属性，当我们在 Unity 中创建一个材质后，Unity 会给这个材质设置一个默认 Shader，然后这个材质的 RenderQueue 被改为其 Shader 中设定的 RenderQueue。如果给这个材质球换了 Shader，Unity 会更新它的 RenderQueue（但是请注意，假如当前材质的 Shader 的 RenderQueue 是 3000，然后你修改 Shader 让其 RenderQueue 变成 3100，对应材质球的 RenderQueue 并不会更新！）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unity 最终以 Material 的 RenderQueue 为准。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unity 内置了几个 RenderQueue 的字面值："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"RenderQueue"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"值"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Background"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"这个渲染队列最先渲染，一般用于渲染背景"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Geometry(默认值)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"这个渲染队列是大多数物体的默认队列，用于渲染不透明物体"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"AlphaTest"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2450"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"使用了 AlphaTest 的物体在这个队列渲染，当所有的不透明物体都渲染完了再渲染这个，有助于提升性能"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Transparent"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"在 Geometry 和 AlphaTest 之后、从后往前渲染，所有的半透明物体都应该在这里渲染"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Overlay"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4000"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"在之前的所有渲染队列都渲染完了之后渲染，比如镜头光晕"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看到，RenderQueue 越大，渲染越靠后。"}]},{"type":"element","tag":"h5","props":{"id":"cameraopaquesortmode"},"children":[{"type":"text","value":"Camera.opaqueSortMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认情况下，不透明物体被放在粗略分隔的从前往后排布的桶中，GPU 按照这种方式渲染能节省性能。但是也有部分 GPU 不这么干，比如 PowerVR。Camera.opaqueSortMode 这个值的默认值是 Dafault，根据不同硬件平台，这个值有可能是：OpaqueSortMode.FrontToBack 或者 OpaqueSortMode.NoDistanceSort。我们也可以主动设置这个值为某一种。比如为了减少 CPU 消耗，把这个值设置为 NoDistanceSort。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以，不透明物体大部分情况下是按照从前往后渲染，也就是离相机越近，越先渲染。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果是手动选择了 FrontToBack，就是从前往后渲染；如果是 NoDistanceSort，就是从后往前渲染。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据实际测试，渲染的顺序并不是完全按照物体几何中心离相机的距离进行排序，而是一个近似的排序。"}]}]},{"type":"element","tag":"h5","props":{"id":"cameratransparencysortmode"},"children":[{"type":"text","value":"Camera.transparencySortMode"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照我测试用的 Unity5.3.4f1，修改这个值也会影响不透明物体的渲染顺序。所以这个东西很可能不重要，而且有 bug。"}]},{"type":"element","tag":"h5","props":{"id":"sortinglayer"},"children":[{"type":"text","value":"SortingLayer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SortingLayer 拥有最高优先级，如果 SortingLayer 不同，则首先按照 SortingLayer 排序；如果 SortingLayer 相同，再按照 RenderQueue 排序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如下图所示，有 6 个立方体，分别按顺序在摄像机前排开："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/preview.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"img","src":"/images/2021-06-14-unity-render-order/cubes.jpg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中，g1 组的立方体 SortingLayer 都是 Layer3，RenderQueue 都是 3000；g2 组的立方体 SortingLayer 都是 Layer2，RenderQueue 都是3500，最终渲染顺序是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"g2m1 g2m2 g2m3 g1m1 g1m2 g1m3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直观地说，就是 SortingLayer 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。SortingLayer 默认只有一个：Default，越往后添加的 SortingLayer 越大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在把 g1 组的立方体 SortingLayer 改成 Layer2，RenderQueue 改成 3600，最终渲染顺序还是："},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"g2m1 g2m2 g2m3 g1m1 g1m2 g1m3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"直观地说，SortingLayer 相同的前提下，RenderQueue 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"h5","props":{"id":"sortingorder"},"children":[{"type":"text","value":"SortingOrder"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果 SortingLayer 和 RenderQueue 都一样，则 SortingOrder 越大，则物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果只是 SortingLayer 一样，RenderQueue 和 SortingOrder 都不一样，则物体的"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"由 RenderQueue 和 SortingOrder 之和决定，相加之和越大，"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上结论是通过 Frame Debugger 单步执行得出的。"}]}]},{"type":"element","tag":"h5","props":{"id":"cameradepth"},"children":[{"type":"text","value":"Camera.depth"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有一个很常用的调整渲染顺序的选项：摄像机深度。摄像机深度是优先级最高的选项，深度值越大，物体"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"层级"}]},{"type":"text","value":"越高。常用的比如 NGUI 就是用一个单独的相机（深度值比渲染场景的相机大）来渲染 UI，这样就保证 UI 在所有东西上方。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考资料："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://jakobknudsen.wordpress.com/2013/07/20/transparency-and-sorting/","rel":["nofollow"]},"children":[{"type":"text","value":"Transparency and sorting in Unity"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:unity:2021-06-14-unity-render-order.md","_source":"content","_file":"unity/2021-06-14-unity-render-order.md","_extension":"md","date":"2021-06-14"}