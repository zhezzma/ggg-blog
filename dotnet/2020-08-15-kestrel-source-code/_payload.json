[{"data":1,"prerenderedAt":1275},["Reactive",2],{"content-query-3ZfoAFkXwH":3,"content-navigation-8C37fagqQL":693},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":687,"_id":688,"_source":689,"_file":690,"_extension":691,"date":692},"/dotnet/2020-08-15-kestrel-source-code","dotnet",false,"","Kestrel源码分析","Kestrel是http://ASP.NET Core框架内置的默认Web Server 什么是Web Server? 根据维基百科的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。",{"type":11,"children":12,"toc":668},"root",[13,41,63,67,105,116,127,145,201,219,230,239,302,314,345,375,381,401,410,430,443,464,476,525,543,568,577,589,601,610,629,634,644,656],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18,21,30,32,39],{"type":19,"value":20},"text","Kestrel是",{"type":14,"tag":22,"props":23,"children":27},"a",{"href":24,"rel":25},"https://link.zhihu.com/?target=http%3A//ASP.NET",[26],"nofollow",[28],{"type":19,"value":29},"http://ASP.NET",{"type":19,"value":31}," Core框架内置的默认Web Server 什么是Web Server? 根据",{"type":14,"tag":22,"props":33,"children":36},{"href":34,"rel":35},"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Web_server",[26],[37],{"type":19,"value":38},"维基百科",{"type":19,"value":40},"的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。",{"type":14,"tag":42,"props":43,"children":45},"h2",{"id":44},"定义-iserverihttpapplicationtcontext",[46,48,55,57],{"type":19,"value":47},"定义 - ",{"type":14,"tag":49,"props":50,"children":52},"code",{"className":51},[],[53],{"type":19,"value":54},"IServer",{"type":19,"value":56},"、",{"type":14,"tag":49,"props":58,"children":60},{"className":59},[],[61],{"type":19,"value":62},"IHttpApplication\u003CTContext>",{"type":14,"tag":64,"props":65,"children":66},"hr",{},[],{"type":14,"tag":15,"props":68,"children":69},{},[70,75,77,82,84,89,91,96,98,103],{"type":14,"tag":22,"props":71,"children":73},{"href":24,"rel":72},[26],[74],{"type":19,"value":29},{"type":19,"value":76}," Core定义了两个基本的接口",{"type":14,"tag":49,"props":78,"children":80},{"className":79},[],[81],{"type":19,"value":54},{"type":19,"value":83},"，及",{"type":14,"tag":49,"props":85,"children":87},{"className":86},[],[88],{"type":19,"value":62},{"type":19,"value":90},"，",{"type":14,"tag":49,"props":92,"children":94},{"className":93},[],[95],{"type":19,"value":54},{"type":19,"value":97},"接口定义了Web Server的基本功能，",{"type":14,"tag":49,"props":99,"children":101},{"className":100},[],[102],{"type":19,"value":62},{"type":19,"value":104},"则定义了处理HTTP协议的应用程序的基本功能，我们首先来看下这两个定义:",{"type":14,"tag":42,"props":106,"children":108},{"id":107},"web-服务器-iserver",[109,111],{"type":19,"value":110},"Web 服务器 - ",{"type":14,"tag":49,"props":112,"children":114},{"className":113},[],[115],{"type":19,"value":54},{"type":14,"tag":117,"props":118,"children":122},"pre",{"className":119,"code":121,"language":19,"meta":7},[120],"language-text","namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// \u003Csummary>\n    /// Represents a server.\n    /// \u003C/summary>\n    public interface IServer : IDisposable\n    {\n        /// \u003Csummary>\n        /// A collection of HTTP features of the server.\n        /// \u003C/summary>\n        IFeatureCollection Features { get; }\n\n        /// \u003Csummary>\n        /// Start the server with an application.\n        /// \u003C/summary>\n        /// \u003Cparam name=\"application\">An instance of \u003Csee cref=\"IHttpApplication{TContext}\"/>.\u003C/param>\n        /// \u003Ctypeparam name=\"TContext\">The context associated with the application.\u003C/typeparam>\n        /// \u003Cparam name=\"cancellationToken\">Indicates if the server startup should be aborted.\u003C/param>\n        Task StartAsync\u003CTContext>(IHttpApplication\u003CTContext> application, CancellationToken cancellationToken);\n\n        /// \u003Csummary>\n        /// Stop processing requests and shut down the server, gracefully if possible.\n        /// \u003C/summary>\n        /// \u003Cparam name=\"cancellationToken\">Indicates if the graceful shutdown should be aborted.\u003C/param>\n        Task StopAsync(CancellationToken cancellationToken);\n    }\n}\n",[123],{"type":14,"tag":49,"props":124,"children":125},{"__ignoreMap":7},[126],{"type":19,"value":121},{"type":14,"tag":15,"props":128,"children":129},{},[130,136,138,143],{"type":14,"tag":49,"props":131,"children":133},{"className":132},[],[134],{"type":19,"value":135},"Features",{"type":19,"value":137}," 是一个功能集合，其中可以包含所有应用程序需要的，用以处理HTTP协议各个阶段和组成部分的功能集，以接口的形式注入到",{"type":14,"tag":49,"props":139,"children":141},{"className":140},[],[142],{"type":19,"value":135},{"type":19,"value":144},"中。",{"type":14,"tag":15,"props":146,"children":147},{},[148,154,156,161,163,169,171,177,179,184,186,192,194,199],{"type":14,"tag":49,"props":149,"children":151},{"className":150},[],[152],{"type":19,"value":153},"StartAsync",{"type":19,"value":155},"方法可以启动IServer对象，用来接受用户请求。包含两个参数：",{"type":14,"tag":49,"props":157,"children":159},{"className":158},[],[160],{"type":19,"value":62},{"type":19,"value":162},"和",{"type":14,"tag":49,"props":164,"children":166},{"className":165},[],[167],{"type":19,"value":168},"CancellationToken",{"type":19,"value":170},"。 ",{"type":14,"tag":49,"props":172,"children":174},{"className":173},[],[175],{"type":19,"value":176},"IHttpApplicatoin\u003CTContext>",{"type":19,"value":178},"是最终处理HTTP请求的应用程序入口点，在ASP.NET Core应用程序中，默认的",{"type":14,"tag":49,"props":180,"children":182},{"className":181},[],[183],{"type":19,"value":62},{"type":19,"value":185},"实现是：",{"type":14,"tag":49,"props":187,"children":189},{"className":188},[],[190],{"type":19,"value":191},"HostingApplication",{"type":19,"value":193},"，我们会在稍后的部分进行详细的介绍。 而",{"type":14,"tag":49,"props":195,"children":197},{"className":196},[],[198],{"type":19,"value":168},{"type":19,"value":200},"用来响应中断应用程序启动的请求。",{"type":14,"tag":15,"props":202,"children":203},{},[204,210,212,217],{"type":14,"tag":49,"props":205,"children":207},{"className":206},[],[208],{"type":19,"value":209},"StopAsync",{"type":19,"value":211},"方法用来处理停止服务的请求，接受一个参数",{"type":14,"tag":49,"props":213,"children":215},{"className":214},[],[216],{"type":19,"value":168},{"type":19,"value":218},"，用来响应中断停止应用程序的请求。",{"type":14,"tag":42,"props":220,"children":222},{"id":221},"http应用程序-ihttpapplicationtcontext",[223,225],{"type":19,"value":224},"Http应用程序 - ",{"type":14,"tag":49,"props":226,"children":228},{"className":227},[],[229],{"type":19,"value":62},{"type":14,"tag":117,"props":231,"children":234},{"className":232,"code":233,"language":19,"meta":7},[120],"namespace Microsoft.AspNetCore.Hosting.Server\n{\n    /// \u003Csummary>\n    /// Represents an application.\n    /// \u003C/summary>\n    /// \u003Ctypeparam name=\"TContext\">The context associated with the application.\u003C/typeparam>\n    public interface IHttpApplication\u003CTContext>\n    {\n        /// \u003Csummary>\n        /// Create a TContext given a collection of HTTP features.\n        /// \u003C/summary>\n        /// \u003Cparam name=\"contextFeatures\">A collection of HTTP features to be used for creating the TContext.\u003C/param>\n        /// \u003Creturns>The created TContext.\u003C/returns>\n        TContext CreateContext(IFeatureCollection contextFeatures);\n\n        /// \u003Csummary>\n        /// Asynchronously processes an TContext.\n        /// \u003C/summary>\n        /// \u003Cparam name=\"context\">The TContext that the operation will process.\u003C/param>\n        Task ProcessRequestAsync(TContext context);\n\n        /// \u003Csummary>\n        /// Dispose a given TContext.\n        /// \u003C/summary>\n        /// \u003Cparam name=\"context\">The TContext to be disposed.\u003C/param>\n        /// \u003Cparam name=\"exception\">The Exception thrown when processing did not complete successfully, otherwise null.\u003C/param>\n        void DisposeContext(TContext context, Exception exception);\n    }\n}\n",[235],{"type":14,"tag":49,"props":236,"children":237},{"__ignoreMap":7},[238],{"type":19,"value":233},{"type":14,"tag":15,"props":240,"children":241},{},[242,247,249,255,257,263,265,271,273,278,280,285,287,293,295,300],{"type":14,"tag":49,"props":243,"children":245},{"className":244},[],[246],{"type":19,"value":62},{"type":19,"value":248},"接口的定义包含了三个方法： ",{"type":14,"tag":49,"props":250,"children":252},{"className":251},[],[253],{"type":19,"value":254},"CreateContext",{"type":19,"value":256},"方法用来创建处理请求的上下文中所需要的所有相关数据，组成",{"type":14,"tag":49,"props":258,"children":260},{"className":259},[],[261],{"type":19,"value":262},"Context",{"type":19,"value":264},"对象，由接口的实现自己定义类型， ",{"type":14,"tag":49,"props":266,"children":268},{"className":267},[],[269],{"type":19,"value":270},"ProcessRequestAsync",{"type":19,"value":272},"方法使用",{"type":14,"tag":49,"props":274,"children":276},{"className":275},[],[277],{"type":19,"value":254},{"type":19,"value":279},"方法创建的",{"type":14,"tag":49,"props":281,"children":283},{"className":282},[],[284],{"type":19,"value":262},{"type":19,"value":286},"对象处理本次请求。 ",{"type":14,"tag":49,"props":288,"children":290},{"className":289},[],[291],{"type":19,"value":292},"DisposeContext",{"type":19,"value":294},"方法在完成请求的处理后，负责释放",{"type":14,"tag":49,"props":296,"children":298},{"className":297},[],[299],{"type":19,"value":262},{"type":19,"value":301},"对象。",{"type":14,"tag":42,"props":303,"children":305},{"id":304},"实现-kestrelserver",[306,308],{"type":19,"value":307},"实现 - ",{"type":14,"tag":49,"props":309,"children":311},{"className":310},[],[312],{"type":19,"value":313},"KestrelServer",{"type":14,"tag":15,"props":315,"children":316},{},[317,322,324,329,331,336,338,343],{"type":14,"tag":22,"props":318,"children":320},{"href":24,"rel":319},[26],[321],{"type":19,"value":29},{"type":19,"value":323}," Core提供了默认的",{"type":14,"tag":49,"props":325,"children":327},{"className":326},[],[328],{"type":19,"value":54},{"type":19,"value":330},"：",{"type":14,"tag":49,"props":332,"children":334},{"className":333},[],[335],{"type":19,"value":313},{"type":19,"value":337},"，下面我们就来看看",{"type":14,"tag":49,"props":339,"children":341},{"className":340},[],[342],{"type":19,"value":313},{"type":19,"value":344},"具体都做了些什么。",{"type":14,"tag":346,"props":347,"children":348},"blockquote",{},[349],{"type":14,"tag":15,"props":350,"children":351},{},[352,357,359,366,368],{"type":14,"tag":49,"props":353,"children":355},{"className":354},[],[356],{"type":19,"value":313},{"type":19,"value":358}," 定义在dotnet/aspnetcore项目中（",{"type":14,"tag":22,"props":360,"children":363},{"href":361,"rel":362},"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore",[26],[364],{"type":19,"value":365},"GITHUB REPO",{"type":19,"value":367},"）。 项目名称为：Microsoft.AspNetCore.Server.Kestrel.Core 名称空间.AspNetCore.Server.Kestrel.Core ",{"type":14,"tag":22,"props":369,"children":372},{"href":370,"rel":371},"https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore/blob/master/src/Servers/Kestrel/Core/src/KestrelServer.cs",[26],[373],{"type":19,"value":374},"源代码",{"type":14,"tag":42,"props":376,"children":378},{"id":377},"服务器启动端口监听协议解析及请求处理",[379],{"type":19,"value":380},"服务器启动：端口监听，协议解析及请求处理。",{"type":14,"tag":15,"props":382,"children":383},{},[384,386,391,393,399],{"type":19,"value":385},"我们先看一下",{"type":14,"tag":49,"props":387,"children":389},{"className":388},[],[390],{"type":19,"value":313},{"type":19,"value":392},".",{"type":14,"tag":49,"props":394,"children":396},{"className":395},[],[397],{"type":19,"value":398},"StartAsync()",{"type":19,"value":400},"方法的代码实现：",{"type":14,"tag":117,"props":402,"children":405},{"className":403,"code":404,"language":19,"meta":7},[120],"public async Task StartAsync\u003CTContext>(IHttpApplication\u003CTContext> application, CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (!BitConverter.IsLittleEndian)\n                {\n                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);\n                }\n\n                ValidateOptions();\n\n                if (_hasStarted)\n                {\n                    // The server has already started and/or has not been cleaned up yet\n                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);\n                }\n                _hasStarted = true;\n\n                ServiceContext.Heartbeat?.Start();\n\n                async Task OnBind(ListenOptions options)\n                {\n                    // Add the HTTP middleware as the terminal connection middleware\n                    options.UseHttpServer(ServiceContext, application, options.Protocols);\n\n                    var connectionDelegate = options.Build();\n\n                    // Add the connection limit middleware\n                    if (Options.Limits.MaxConcurrentConnections.HasValue)\n                    {\n                        connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;\n                    }\n\n                    var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);\n                    var transport = await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);\n\n                    // Update the endpoint\n                    options.EndPoint = transport.EndPoint;\n                    var acceptLoopTask = connectionDispatcher.StartAcceptingConnections(transport);\n\n                    _transports.Add((transport, acceptLoopTask));\n                }\n\n                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);\n            }\n            catch (Exception ex)\n            {\n                Trace.LogCritical(0, ex, \"Unable to start Kestrel.\");\n                Dispose();\n                throw;\n            }\n        }\n",[406],{"type":14,"tag":49,"props":407,"children":408},{"__ignoreMap":7},[409],{"type":19,"value":404},{"type":14,"tag":15,"props":411,"children":412},{},[413,419,421,428],{"type":14,"tag":49,"props":414,"children":416},{"className":415},[],[417],{"type":19,"value":418},"Kestrel",{"type":19,"value":420},"首先会检查服务器的",{"type":14,"tag":22,"props":422,"children":425},{"href":423,"rel":424},"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F",[26],[426],{"type":19,"value":427},"字节序",{"type":19,"value":429},"，目前是不支持大端序的。 然后检查最大请求长度限制的设置项，以及服务器是否已经启动。",{"type":14,"tag":15,"props":431,"children":432},{},[433,435,441],{"type":19,"value":434},"最后，通过",{"type":14,"tag":49,"props":436,"children":438},{"className":437},[],[439],{"type":19,"value":440},"AddressBinder",{"type":19,"value":442},"对预先配置的IP地址或终结点(EndPoint)名称进行监听，开始接受客户端的请求。",{"type":14,"tag":15,"props":444,"children":445},{},[446,448,454,456,462],{"type":19,"value":447},"当每有一个新的HTTP请求通过TCP协议或其他协议和服务器成功简历连接后，AddressBinder使用",{"type":14,"tag":49,"props":449,"children":451},{"className":450},[],[452],{"type":19,"value":453},"ThreadPool.UnsafeQueueUserWorkItem()",{"type":19,"value":455},"方法将",{"type":14,"tag":49,"props":457,"children":459},{"className":458},[],[460],{"type":19,"value":461},"OnBind()",{"type":19,"value":463},"方法添加到线程池中，等待线程池的调度。",{"type":14,"tag":15,"props":465,"children":466},{},[467,469,474],{"type":19,"value":468},"如果此时进程有可用的线程，就会调用",{"type":14,"tag":49,"props":470,"children":472},{"className":471},[],[473],{"type":19,"value":461},{"type":19,"value":475},"方法，处理用户的HTTP请求。",{"type":14,"tag":15,"props":477,"children":478},{},[479,484,486,492,494,500,502,508,510,516,518,523],{"type":14,"tag":49,"props":480,"children":482},{"className":481},[],[483],{"type":19,"value":461},{"type":19,"value":485},"方法默认使用",{"type":14,"tag":49,"props":487,"children":489},{"className":488},[],[490],{"type":19,"value":491},"HttpConnectionMiddleware\u003CServiceContext>",{"type":19,"value":493},"中间件，处理新接入的用户请求，当设置了",{"type":14,"tag":49,"props":495,"children":497},{"className":496},[],[498],{"type":19,"value":499},"MaxConcurrentConnections",{"type":19,"value":501},"值为",{"type":14,"tag":49,"props":503,"children":505},{"className":504},[],[506],{"type":19,"value":507},"True",{"type":19,"value":509},"时，则会默认使用",{"type":14,"tag":49,"props":511,"children":513},{"className":512},[],[514],{"type":19,"value":515},"ConnectionLimitMiddleware",{"type":19,"value":517},"中间件，限制最大可用连接数，如果当前请求数已经达到最大可接受连接数，则拒绝用户的请求并断开连接，否则调用",{"type":14,"tag":49,"props":519,"children":521},{"className":520},[],[522],{"type":19,"value":491},{"type":19,"value":524},"中间件，继续处理用户的请求。",{"type":14,"tag":42,"props":526,"children":528},{"id":527},"处理http请求-httpconnectionmiddlewareservicecontexthttpconnection",[529,531,536,537],{"type":19,"value":530},"处理HTTP请求 - ",{"type":14,"tag":49,"props":532,"children":534},{"className":533},[],[535],{"type":19,"value":491},{"type":19,"value":56},{"type":14,"tag":49,"props":538,"children":540},{"className":539},[],[541],{"type":19,"value":542},"HttpConnection",{"type":14,"tag":15,"props":544,"children":545},{},[546,551,553,559,561,566],{"type":14,"tag":49,"props":547,"children":549},{"className":548},[],[550],{"type":19,"value":491},{"type":19,"value":552},"中间件负责组装连接相关的上下文数据",{"type":14,"tag":49,"props":554,"children":556},{"className":555},[],[557],{"type":19,"value":558},"HttpConnectionContext",{"type":19,"value":560},"，并使用",{"type":14,"tag":49,"props":562,"children":564},{"className":563},[],[565],{"type":19,"value":542},{"type":19,"value":567},"类处理用户请求。",{"type":14,"tag":117,"props":569,"children":572},{"className":570,"code":571,"language":19,"meta":7},[120],"internal class HttpConnectionMiddleware\u003CTContext>\n    {\n        private readonly ServiceContext _serviceContext;\n        private readonly IHttpApplication\u003CTContext> _application;\n        private readonly HttpProtocols _protocols;\n\n        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication\u003CTContext> application, HttpProtocols protocols)\n        {\n            _serviceContext = serviceContext;\n            _application = application;\n            _protocols = protocols;\n        }\n\n        public Task OnConnectionAsync(ConnectionContext connectionContext)\n        {\n            var memoryPoolFeature = connectionContext.Features.Get\u003CIMemoryPoolFeature>();\n\n            var httpConnectionContext = new HttpConnectionContext\n            {\n                ConnectionId = connectionContext.ConnectionId,\n                ConnectionContext = connectionContext,\n                Protocols = _protocols,\n                ServiceContext = _serviceContext,\n                ConnectionFeatures = connectionContext.Features,\n                MemoryPool = memoryPoolFeature.MemoryPool,\n                Transport = connectionContext.Transport,\n                LocalEndPoint = connectionContext.LocalEndPoint as IPEndPoint,\n                RemoteEndPoint = connectionContext.RemoteEndPoint as IPEndPoint\n            };\n\n            var connection = new HttpConnection(httpConnectionContext);\n\n            return connection.ProcessRequestsAsync(_application);\n        }\n    }\n",[573],{"type":14,"tag":49,"props":574,"children":575},{"__ignoreMap":7},[576],{"type":19,"value":571},{"type":14,"tag":578,"props":579,"children":581},"h3",{"id":580},"http版本控制-httpconnection",[582,584],{"type":19,"value":583},"HTTP版本控制 - ",{"type":14,"tag":49,"props":585,"children":587},{"className":586},[],[588],{"type":19,"value":542},{"type":14,"tag":15,"props":590,"children":591},{},[592,594,599],{"type":19,"value":593},"当用户创建",{"type":14,"tag":49,"props":595,"children":597},{"className":596},[],[598],{"type":19,"value":542},{"type":19,"value":600},"类时，在初始化过程中，会根据用户请求声明的HTTP协议版本，分别创建对应版本的Connection类，并使用该类处理用户请求：",{"type":14,"tag":117,"props":602,"children":605},{"className":603,"code":604,"language":19,"meta":7},[120],"public async Task ProcessRequestsAsync\u003CTContext>(IHttpApplication\u003CTContext> httpApplication)\n        {\n            try\n            {\n                // Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.\n                _timeoutControl.Initialize(_systemClock.UtcNowTicks);\n\n                IRequestProcessor requestProcessor = null;\n\n                switch (SelectProtocol())\n                {\n                    case HttpProtocols.Http1:\n                        // _http1Connection must be initialized before adding the connection to the connection manager\n                        requestProcessor = _http1Connection = new Http1Connection\u003CTContext>(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.Http2:\n                        // _http2Connection must be initialized before yielding control to the transport thread,\n                        // to prevent a race condition where _http2Connection.Abort() is called just as\n                        // _http2Connection is about to be initialized.\n                        requestProcessor = new Http2Connection(_context);\n                        _protocolSelectionState = ProtocolSelectionState.Selected;\n                        break;\n                    case HttpProtocols.None:\n                        // An error was already logged in SelectProtocol(), but we should close the connection.\n                        break;\n                    default:\n                        // SelectProtocol() only returns Http1, Http2 or None.\n                        throw new NotSupportedException($\"{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.\");\n                }\n\n                _requestProcessor = requestProcessor;\n\n                if (requestProcessor != null)\n                {\n                    var connectionHeartbeatFeature = _context.ConnectionFeatures.Get\u003CIConnectionHeartbeatFeature>();\n                    var connectionLifetimeNotificationFeature = _context.ConnectionFeatures.Get\u003CIConnectionLifetimeNotificationFeature>();\n\n                    // These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,\n                    // we'll need to handle these missing.\n                    Debug.Assert(connectionHeartbeatFeature != null, nameof(IConnectionHeartbeatFeature) + \" is missing!\");\n                    Debug.Assert(connectionLifetimeNotificationFeature != null, nameof(IConnectionLifetimeNotificationFeature) + \" is missing!\");\n\n                    // Register the various callbacks once we're going to start processing requests\n\n                    // The heart beat for various timeouts\n                    connectionHeartbeatFeature?.OnHeartbeat(state => ((HttpConnection)state).Tick(), this);\n\n                    // Register for graceful shutdown of the server\n                    using var shutdownRegistration = connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state => ((HttpConnection)state).StopProcessingNextRequest(), this);\n\n                    // Register for connection close\n                    using var closedRegistration = _context.ConnectionContext.ConnectionClosed.Register(state => ((HttpConnection)state).OnConnectionClosed(), this);\n\n                    await requestProcessor.ProcessRequestsAsync(httpApplication);\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.LogCritical(0, ex, $\"Unexpected exception in {nameof(HttpConnection)}.{nameof(ProcessRequestsAsync)}.\");\n            }\n            finally\n            {\n                if (_http1Connection?.IsUpgraded == true)\n                {\n                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();\n                }\n            }\n        }\n",[606],{"type":14,"tag":49,"props":607,"children":608},{"__ignoreMap":7},[609],{"type":19,"value":604},{"type":14,"tag":15,"props":611,"children":612},{},[613,615,620,622,627],{"type":19,"value":614},"HTTP1和HTTP2处理HTTP协议的方式有所不同，HTTP1协议解析完成后，会立即调用",{"type":14,"tag":49,"props":616,"children":618},{"className":617},[],[619],{"type":19,"value":62},{"type":19,"value":621},"处理请求，HTTP2协议解析完成后，会再次调用",{"type":14,"tag":49,"props":623,"children":625},{"className":624},[],[626],{"type":19,"value":453},{"type":19,"value":628},"方法等待线程池可用线程。",{"type":14,"tag":42,"props":630,"children":632},{"id":631},"结束语",[633],{"type":19,"value":631},{"type":14,"tag":15,"props":635,"children":636},{},[637,642],{"type":14,"tag":49,"props":638,"children":640},{"className":639},[],[641],{"type":19,"value":418},{"type":19,"value":643},"服务的代码量并不下，其中主要是辅助接受用户请求和解析HTTP协议的代码，在这里不做详细的介绍，各位读者有兴趣的，可以详细阅读源代码。",{"type":14,"tag":15,"props":645,"children":646},{},[647,649,654],{"type":19,"value":648},"我们看到，",{"type":14,"tag":49,"props":650,"children":652},{"className":651},[],[653],{"type":19,"value":418},{"type":19,"value":655},"服务在接受和处理请求时，都用到了线程池，可以极大的提高服务器的吞吐量。",{"type":14,"tag":15,"props":657,"children":658},{},[659,661,666],{"type":19,"value":660},"后面，我们还会详细介绍系统默认的",{"type":14,"tag":49,"props":662,"children":664},{"className":663},[],[665],{"type":19,"value":62},{"type":19,"value":667},"实现，看看ASP.NET Core是如何将HTTP转发到Controller和Action，其中又有哪些精妙的代码呢。",{"title":7,"searchDepth":669,"depth":669,"links":670},2,[671,673,675,677,679,680,686],{"id":44,"depth":669,"text":672},"定义 - IServer、IHttpApplication\u003CTContext>",{"id":107,"depth":669,"text":674},"Web 服务器 - IServer",{"id":221,"depth":669,"text":676},"Http应用程序 - IHttpApplication\u003CTContext>",{"id":304,"depth":669,"text":678},"实现 - KestrelServer",{"id":377,"depth":669,"text":380},{"id":527,"depth":669,"text":681,"children":682},"处理HTTP请求 - HttpConnectionMiddleware\u003CServiceContext>、HttpConnection",[683],{"id":580,"depth":684,"text":685},3,"HTTP版本控制 - HttpConnection",{"id":631,"depth":669,"text":631},"markdown","content:dotnet:2020-08-15-Kestrel-source-code.md","content","dotnet/2020-08-15-Kestrel-source-code.md","md","2020-08-15",[694,704,829,878,930,943,1055],{"title":695,"_path":696,"children":697},"Art","/art",[698,701],{"title":699,"_path":700},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":702,"_path":703},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":705,"_path":706,"children":707},"Dotnet","/dotnet",[708,711,714,717,720,723,726,729,732,735,738,741,744,747,750,753,756,759,762,765,768,771,774,777,780,783,786,789,792,795,798,801,804,807,808,811,814,817,820,823,826],{"title":709,"_path":710},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":712,"_path":713},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":715,"_path":716},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":718,"_path":719},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":721,"_path":722},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":724,"_path":725},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":727,"_path":728},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":730,"_path":731},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":733,"_path":734},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":736,"_path":737},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":739,"_path":740},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":742,"_path":743},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":745,"_path":746},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":748,"_path":749},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":751,"_path":752},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":754,"_path":755},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":757,"_path":758},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":760,"_path":761},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":763,"_path":764},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":766,"_path":767},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":769,"_path":770},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":772,"_path":773},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":775,"_path":776},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":778,"_path":779},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":781,"_path":782},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":784,"_path":785},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":787,"_path":788},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":790,"_path":791},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":793,"_path":794},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":796,"_path":797},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":799,"_path":800},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":802,"_path":803},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":805,"_path":806},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":8,"_path":4},{"title":809,"_path":810},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":812,"_path":813},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":815,"_path":816},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":818,"_path":819},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":821,"_path":822},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":824,"_path":825},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":827,"_path":828},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":830,"_path":831,"children":832},"Game","/game",[833,836,839,842,845,848,851,854,857,860,863,866,869,872,875],{"title":834,"_path":835},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":837,"_path":838},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":840,"_path":841},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":843,"_path":844},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":846,"_path":847},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":849,"_path":850},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":852,"_path":853},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":855,"_path":856},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":858,"_path":859},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":861,"_path":862},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":864,"_path":865},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":867,"_path":868},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":870,"_path":871},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":873,"_path":874},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":876,"_path":877},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":879,"_path":880,"children":881},"Gyj","/gyj",[882,885,888,891,894,897,900,903,906,909,912,915,918,921,924,927],{"title":883,"_path":884},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":886,"_path":887},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":889,"_path":890},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":892,"_path":893},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":895,"_path":896},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":898,"_path":899},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":901,"_path":902},"玩法","/gyj/2022-08-22-wanfa",{"title":904,"_path":905},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":907,"_path":908},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":910,"_path":911},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":913,"_path":914},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":916,"_path":917},"门派内容相关","/gyj/2022-11-17-sect",{"title":919,"_path":920},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":922,"_path":923},"种植","/gyj/2022-12-01-zhongzhi",{"title":925,"_path":926},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":928,"_path":929},"跑商","/gyj/2023-11-01-paoshang",{"title":931,"_path":932,"children":933},"Js","/js",[934,937,940],{"title":935,"_path":936},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":938,"_path":939},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":941,"_path":942},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":944,"_path":945,"children":946},"Tool","/tool",[947,950,953,956,959,962,965,968,971,974,977,980,983,986,989,992,995,998,1001,1004,1007,1010,1013,1016,1019,1022,1025,1028,1031,1034,1037,1040,1043,1046,1049,1052],{"title":948,"_path":949},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":951,"_path":952},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":954,"_path":955},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":957,"_path":958},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":960,"_path":961},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":963,"_path":964},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":966,"_path":967},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":969,"_path":970},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":972,"_path":973},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":975,"_path":976},"mac下brew 使用","/tool/2020-01-13-brew",{"title":978,"_path":979},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":981,"_path":982},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":984,"_path":985},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":987,"_path":988},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":990,"_path":991},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":993,"_path":994},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":996,"_path":997},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":999,"_path":1000},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1002,"_path":1003},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1005,"_path":1006},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1008,"_path":1009},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1011,"_path":1012},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1014,"_path":1015},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1017,"_path":1018},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1020,"_path":1021},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1023,"_path":1024},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1026,"_path":1027},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1029,"_path":1030},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1032,"_path":1033},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1035,"_path":1036},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1038,"_path":1039},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1041,"_path":1042},"rider的使用","/tool/2022-08-02-rider-use",{"title":1044,"_path":1045},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1047,"_path":1048},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1050,"_path":1051},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1053,"_path":1054},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1056,"_path":1057,"children":1058},"Unity","/unity",[1059,1062,1065,1068,1071,1074,1077,1080,1083,1086,1089,1092,1095,1098,1101,1104,1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140,1143,1146,1149,1152,1155,1158,1161,1164,1167,1170,1173,1176,1179,1182,1185,1188,1191,1194,1197,1200,1203,1206,1209,1212,1215,1218,1221,1224,1227,1230,1233,1236,1239,1242,1245,1248,1251,1254,1257,1260,1263,1266,1269,1272],{"title":1060,"_path":1061},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1063,"_path":1064},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1066,"_path":1067},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1069,"_path":1070},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1072,"_path":1073},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1075,"_path":1076},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1078,"_path":1079},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1081,"_path":1082},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1084,"_path":1085},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1087,"_path":1088},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1090,"_path":1091},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1093,"_path":1094},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1096,"_path":1097},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1099,"_path":1100},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1102,"_path":1103},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1105,"_path":1106},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1108,"_path":1109},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1111,"_path":1112},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1114,"_path":1115},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1117,"_path":1118},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1120,"_path":1121},"技能系统","/unity/2020-02-15-skill-system",{"title":1123,"_path":1124},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1126,"_path":1127},"角色状态设计","/unity/2020-02-17-character-states",{"title":1129,"_path":1130},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1132,"_path":1133},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1135,"_path":1136},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1138,"_path":1139},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1141,"_path":1142},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1144,"_path":1145},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1147,"_path":1148},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1150,"_path":1151},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1153,"_path":1154},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1156,"_path":1157},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1159,"_path":1160},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1162,"_path":1163},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1165,"_path":1166},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1168,"_path":1169},"unity的addressables","/unity/2020-09-12-addressables",{"title":1171,"_path":1172},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1174,"_path":1175},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1177,"_path":1178},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1180,"_path":1181},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1183,"_path":1184},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1186,"_path":1187},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1189,"_path":1190},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1192,"_path":1193},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1195,"_path":1196},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1198,"_path":1199},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1201,"_path":1202},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1204,"_path":1205},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1207,"_path":1208},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1210,"_path":1211},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1213,"_path":1214},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1216,"_path":1217},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1219,"_path":1220},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1222,"_path":1223},"ability","/unity/2020-11-16-dotssample",{"title":1225,"_path":1226},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1228,"_path":1229},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1231,"_path":1232},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1234,"_path":1235},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1237,"_path":1238},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1240,"_path":1241},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1243,"_path":1244},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1246,"_path":1247},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1249,"_path":1250},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1252,"_path":1253},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1255,"_path":1256},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1258,"_path":1259},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1261,"_path":1262},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1264,"_path":1265},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1267,"_path":1268},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1270,"_path":1271},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1273,"_path":1274},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779038216]