[{"data":1,"prerenderedAt":1413},["Reactive",2],{"content-query-xbwPdrwPeT":3,"content-navigation-8C37fagqQL":831},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":825,"_id":826,"_source":827,"_file":828,"_extension":829,"date":830},"/dotnet/2020-02-07-aoi","dotnet",false,"","地图的aoi","为什么要进行视野管理？1.如果不进行视野管理，流量上来看，假设平均每秒5个移动包（80字节），1个技能包（160字节），单人每秒多少？500kb。2.客户端表现来看，客户端受屏幕大小影响，离得远的玩家看不见，没有必要发给客户端。客户端性能所限，玩家多，放各种 技能，当然会看。3.从性能上考虑，服务端不用遍历全场景对象…也会大大减少性能消耗。格子LandIncServer将每个场景看做是由n个land（块）组成，每个land就是一个大小固定的正方形，默认512 * 512。比如一个scene的尺寸为1200 * 700：则需要6个land来表示:PatchLand进一步被划分为若干个Patch（",{"type":11,"children":12,"toc":812},"root",[13,22,28,33,38,44,50,55,63,68,75,81,86,93,98,111,116,123,128,138,145,150,157,182,193,198,218,229,234,239,249,257,315,320,325,330,335,340,345,352,365,388,393,398,403,408,413,418,423,428,433,463,468,507,512,517,522,527,532,537,542,547,559,568,573,581,590,595,604,609,617,634,656,664,669,677,682,687,692,697,702,707,712,717,727,735,743,752,760,769,774],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"为什么要进行视野管理",[19],{"type":20,"value":21},"text","为什么要进行视野管理？",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":27},"1.如果不进行视野管理，流量上来看，假设平均每秒5个移动包（80字节），1个技能包（160字节），单人每秒多少？500kb。",{"type":14,"tag":23,"props":29,"children":30},{},[31],{"type":20,"value":32},"2.客户端表现来看，客户端受屏幕大小影响，离得远的玩家看不见，没有必要发给客户端。客户端性能所限，玩家多，放各种 技能，当然会看。",{"type":14,"tag":23,"props":34,"children":35},{},[36],{"type":20,"value":37},"3.从性能上考虑，服务端不用遍历全场景对象…也会大大减少性能消耗。",{"type":14,"tag":39,"props":40,"children":42},"h1",{"id":41},"格子",[43],{"type":20,"value":41},{"type":14,"tag":15,"props":45,"children":47},{"id":46},"land",[48],{"type":20,"value":49},"Land",{"type":14,"tag":23,"props":51,"children":52},{},[53],{"type":20,"value":54},"IncServer将每个场景看做是由n个land（块）组成，每个land就是一个大小固定的正方形，默认512 * 512。比如一个scene的尺寸为1200 * 700：",{"type":14,"tag":23,"props":56,"children":57},{},[58],{"type":14,"tag":59,"props":60,"children":62},"img",{"alt":59,"src":61},"/images/2020-02-07-aoi/IncServer-Scene-RealScene.png",[],{"type":14,"tag":23,"props":64,"children":65},{},[66],{"type":20,"value":67},"则需要6个land来表示:",{"type":14,"tag":23,"props":69,"children":70},{},[71],{"type":14,"tag":59,"props":72,"children":74},{"alt":59,"src":73},"/images/2020-02-07-aoi/IncServer-Scene.png",[],{"type":14,"tag":15,"props":76,"children":78},{"id":77},"patch",[79],{"type":20,"value":80},"Patch",{"type":14,"tag":23,"props":82,"children":83},{},[84],{"type":20,"value":85},"Land进一步被划分为若干个Patch（格子）。以patch为单位，land的边长是2的整数次幂。",{"type":14,"tag":23,"props":87,"children":88},{},[89],{"type":14,"tag":59,"props":90,"children":92},{"alt":59,"src":91},"/images/2020-02-07-aoi/IncServer-Scene-Patch.png",[],{"type":14,"tag":15,"props":94,"children":96},{"id":95},"分块管理",[97],{"type":20,"value":95},{"type":14,"tag":23,"props":99,"children":100},{},[101,103,109],{"type":20,"value":102},"World对游戏对象的管理以patch为单位，",{"type":14,"tag":104,"props":105,"children":106},"strong",{},[107],{"type":20,"value":108},"每个patch都对应有一个对象链表",{"type":20,"value":110},"。",{"type":14,"tag":23,"props":112,"children":113},{},[114],{"type":20,"value":115},"整个world中所有的对象链表的链表头可依次存储于一个一维数组中，这样根据对象的世界坐标，即可方便的计算出其所属的patch以及对应的对象链表。",{"type":14,"tag":23,"props":117,"children":118},{},[119],{"type":14,"tag":59,"props":120,"children":122},{"alt":59,"src":121},"/images/2020-02-07-aoi/IncServer-Scene-ObjectLink.png",[],{"type":14,"tag":23,"props":124,"children":125},{},[126],{"type":20,"value":127},"假设对象的坐标为(x, z)，patch的边长为patch_size，land的边长为land_size，整个场景在x方向上有land_x个land，则对象所属的对象链表的索引计算方式为：",{"type":14,"tag":129,"props":130,"children":132},"pre",{"code":131},"index = (z / patch_size) * (land_x * (land_size / patch_size)) + (x / patch_size);\n",[133],{"type":14,"tag":134,"props":135,"children":136},"code",{"__ignoreMap":7},[137],{"type":20,"value":131},{"type":14,"tag":139,"props":140,"children":142},"h3",{"id":141},"incserver的aoi",[143],{"type":20,"value":144},"IncServer的AOI",{"type":14,"tag":23,"props":146,"children":147},{},[148],{"type":20,"value":149},"与常见的九宫格不同，IncServer支持NEAR、MIDDLE、FAR、FULL四种视野范围：",{"type":14,"tag":23,"props":151,"children":152},{},[153],{"type":14,"tag":59,"props":154,"children":156},{"alt":59,"src":155},"/images/2020-02-07-aoi/IncServer-Scene-ViewRange.png",[],{"type":14,"tag":158,"props":159,"children":160},"ul",{},[161,167,172,177],{"type":14,"tag":162,"props":163,"children":164},"li",{},[165],{"type":20,"value":166},"NEAR：当前对象所位于的patch",{"type":14,"tag":162,"props":168,"children":169},{},[170],{"type":20,"value":171},"MIDDLE：与NEAR相邻的patch",{"type":14,"tag":162,"props":173,"children":174},{},[175],{"type":20,"value":176},"FAR：与MID相邻的patch（NEAR除外）",{"type":14,"tag":162,"props":178,"children":179},{},[180],{"type":20,"value":181},"FULL：NEAR + MIDDILE + FAR",{"type":14,"tag":23,"props":183,"children":184},{},[185,187,192],{"type":20,"value":186},"不过在实际开发中，所有对象的视野都是FULL，即每个对象都能看到以自己所在patch为中心前后左右各两个patch（总计25个patch）内的其他对象。之后的讨论均假设",{"type":14,"tag":104,"props":188,"children":189},{},[190],{"type":20,"value":191},"所有游戏对象的视野范围均为FULL",{"type":20,"value":110},{"type":14,"tag":23,"props":194,"children":195},{},[196],{"type":20,"value":197},"如果对象B进入对象A的视野范围，则根据A对象类型，可能会触发不同的逻辑，比如：",{"type":14,"tag":158,"props":199,"children":200},{},[201,213],{"type":14,"tag":162,"props":202,"children":203},{},[204,206,211],{"type":20,"value":205},"对象A是玩家：将B对象",{"type":14,"tag":104,"props":207,"children":208},{},[209],{"type":20,"value":210},"序列化",{"type":20,"value":212},"到对象A的客户端。",{"type":14,"tag":162,"props":214,"children":215},{},[216],{"type":20,"value":217},"对象B是怪物：执行对象进入怪物视野的逻辑，比如激活AI等。",{"type":14,"tag":23,"props":219,"children":220},{},[221,223,228],{"type":20,"value":222},"后文将以上情况称之为在对象A的视野中加载对象B，简称为",{"type":14,"tag":104,"props":224,"children":225},{},[226],{"type":20,"value":227},"视野加载",{"type":20,"value":110},{"type":14,"tag":139,"props":230,"children":232},{"id":231},"九宫格",[233],{"type":20,"value":231},{"type":14,"tag":23,"props":235,"children":236},{},[237],{"type":20,"value":238},"让我们首先绘制一个2D的地图",{"type":14,"tag":23,"props":240,"children":241},{},[242,247],{"type":14,"tag":59,"props":243,"children":246},{"alt":244,"src":245}," 3.1 网络法实现AOI算法  - 图1","/images/2020-02-07-aoi/3276b001c9ca66df2fd93650fc75bc3d.jpeg",[],{"type":20,"value":248},"我们给这个地图定义一些数值：",{"type":14,"tag":23,"props":250,"children":251},{},[252],{"type":14,"tag":104,"props":253,"children":254},{},[255],{"type":20,"value":256},"场景相关数值计算",{"type":14,"tag":158,"props":258,"children":259},{},[260,265,270,275,280,285,290,295,300,305,310],{"type":14,"tag":162,"props":261,"children":262},{},[263],{"type":20,"value":264},"场景大小： 250*250 ， w(x轴宽度) = 250，l(y轴长度) = 250",{"type":14,"tag":162,"props":266,"children":267},{},[268],{"type":20,"value":269},"x轴格子数量：nx = 5",{"type":14,"tag":162,"props":271,"children":272},{},[273],{"type":20,"value":274},"y轴格子数量：ny = 5",{"type":14,"tag":162,"props":276,"children":277},{},[278],{"type":20,"value":279},"格子宽度: dx = w / nx = 250 / 5 = 50",{"type":14,"tag":162,"props":281,"children":282},{},[283],{"type":20,"value":284},"格子长度: dy = l / ny = 250 / 5 = 50",{"type":14,"tag":162,"props":286,"children":287},{},[288],{"type":20,"value":289},"格子的x轴坐标：idx",{"type":14,"tag":162,"props":291,"children":292},{},[293],{"type":20,"value":294},"格子的y轴坐标：idy",{"type":14,"tag":162,"props":296,"children":297},{},[298],{"type":20,"value":299},"格子编号：id = idy *nx + idx (利用格子坐标得到格子编号)",{"type":14,"tag":162,"props":301,"children":302},{},[303],{"type":20,"value":304},"格子坐标：idx = id % nx , idy = id / nx (利用格子id得到格子坐标)",{"type":14,"tag":162,"props":306,"children":307},{},[308],{"type":20,"value":309},"格子的x轴坐标: idx = id % nx (利用格子id得到x轴坐标编号)",{"type":14,"tag":162,"props":311,"children":312},{},[313],{"type":20,"value":314},"格子的y轴坐标: idy = id / nx (利用格子id得到y轴坐标编号)",{"type":14,"tag":23,"props":316,"children":317},{},[318],{"type":20,"value":319},"以上几个数值，请参考图，简单过一下，就可以理解的，初中的几何计算而已。",{"type":14,"tag":23,"props":321,"children":322},{},[323],{"type":20,"value":324},"九宫格也是打格子的方式之一，把地图划分为很多小格子，每个格子记录格子内的玩家，每个玩家的aoi范围是以自己为中心范围内的九个格子，九个格子的大小略大于屏幕大小，同样的有三个主要的操作：enter,move,leave",{"type":14,"tag":23,"props":326,"children":327},{},[328],{"type":20,"value":329},"enter:根据玩家坐标，加入到所属的格子中，通过计算以这个格子的为中心的九个格子，这九个格子内的玩家就要被通知有新玩家初始化，同时这个新玩家初始化九个格子内的所有玩家。",{"type":14,"tag":23,"props":331,"children":332},{},[333],{"type":20,"value":334},"move:根据移动前位置的格子，计算出移动前的oldaoi集合，根据当前位置的格子，计算出当前的curaoi集合，如果oldaoi, curaoi为同一个格子，则通知格子内的所有玩家该玩家在移动。如果oldaoi,curaoi不是同一个格子，即发生了跨格子的操作，那么要将该玩家从旧格子移除，同时加入新格子。同时分别遍历oldaoi,curaoi,计算出需要通知玩家消失的格子集合，通知玩家出生的格子集合，以及通知玩家移动的格子集合。",{"type":14,"tag":23,"props":336,"children":337},{},[338],{"type":20,"value":339},"leave:玩家离开地图，将玩家从对应的格子里面删除，同时通知aoi集合有玩家离开。",{"type":14,"tag":23,"props":341,"children":342},{},[343],{"type":20,"value":344},"服务器大格子的大小，以3*3的格子要总比客户端显示范围要大一点为原则。比客户端大一点，是为了预留资源加载的时间。\n　　如下图所示，绿色表示手机客户端的显示区域，当角色A在格子6中时，他可以看到1,2,3,5,6,7,9,10,11这9个格子里的内容，那么当他的状态发生变化时，就需要同步给在这9个格子里的所有玩家；同样，当这9个格子里的有玩家或者怪物的状态改变时，也需要都同步给角色A。",{"type":14,"tag":23,"props":346,"children":347},{},[348],{"type":14,"tag":59,"props":349,"children":351},{"alt":59,"src":350},"/images/2020-02-07-aoi/1430365886_455802.jpg",[],{"type":14,"tag":23,"props":353,"children":354},{},[355,357,363],{"type":20,"value":356},"当角色A移动到角色B所在的格子(7)，则他将不再看到1,5,9这三个格子里的内容，同时他将新看到4,8,12这三个格子里的地图内容（玩家和怪物）。所以这个过程中，服务器要下发消息，删除角色A所在的客户端里的1,5,9这三个格子里的地图内容，同时下发消息新增4,8,12这三个格子里的地图内容（类型一）。\n　　推荐大格子具体的大小，按客户端iPhone4S的960",{"type":14,"tag":358,"props":359,"children":360},"em",{},[361],{"type":20,"value":362},"640分辨来制定，取屏幕长宽的1/2大一些，可以定为640",{"type":20,"value":364},"360。",{"type":14,"tag":158,"props":366,"children":367},{},[368,379],{"type":14,"tag":162,"props":369,"children":370},{},[371],{"type":14,"tag":372,"props":373,"children":377},"a",{"href":374,"rel":375},"https://github.com/artasccope/GameFW.AOI",[376],"nofollow",[378],{"type":20,"value":374},{"type":14,"tag":162,"props":380,"children":381},{},[382],{"type":14,"tag":372,"props":383,"children":386},{"href":384,"rel":385},"https://www.bookstack.cn/read/zinx/78aa012966213643.md",[376],[387],{"type":20,"value":384},{"type":14,"tag":139,"props":389,"children":391},{"id":390},"灯塔法",[392],{"type":20,"value":390},{"type":14,"tag":23,"props":394,"children":395},{},[396],{"type":20,"value":397},"所谓灯塔法，即将大地图划分成有限的小格子，在每个小格子中间放一个灯塔，这个灯塔管理两个队列：一个是本格子内所有的对象集合，另一个是对本灯塔感兴趣的对象集合（简称观察者）。",{"type":14,"tag":23,"props":399,"children":400},{},[401],{"type":20,"value":402},"而地图上的每个对象，维护一个视野队列：该队列为其视野范围内的所有对象，即自身感兴趣的所有对象。",{"type":14,"tag":23,"props":404,"children":405},{},[406],{"type":20,"value":407},"一个对象在地图上面运动：分为三个操作：enter，move，leave.",{"type":14,"tag":23,"props":409,"children":410},{},[411],{"type":20,"value":412},"enter:当对象进入地图的时候，根据对象的当前位置和对象的感知距离，可以获取到该对象能观察到的所有灯塔，遍历这些灯塔，将该对象添加为其观察者。同时将这些对象添加到自己的视野队列中。",{"type":14,"tag":23,"props":414,"children":415},{},[416],{"type":20,"value":417},"move:当对象开始移动的时候，对象从一个点到另一个店，那么视野范围必然发生变化。此刻需要将对象从老的灯塔的观察者列表移除，同时将对象添加进新的灯塔的观察者列表。此外，还需要跟新玩家的视野队列，因为视野范围变化，视野内的对象也相应变化。",{"type":14,"tag":23,"props":419,"children":420},{},[421],{"type":20,"value":422},"leave:当对象离开的时候，将自身从附近灯塔的观察者队列中移除。",{"type":14,"tag":23,"props":424,"children":425},{},[426],{"type":20,"value":427},"通过灯塔法，每当物体发生变化，我们能马上根据其当前位置，定位到他的所在的灯塔，同时找到它视野范围内相关联的物体。这样避免了遍历地图上所有玩家进行处理的方式。",{"type":14,"tag":23,"props":429,"children":430},{},[431],{"type":20,"value":432},"当然灯塔的格子大小划分要因地制宜，格子越小，消耗内存越大，同时计算量变大。",{"type":14,"tag":158,"props":434,"children":435},{},[436,445,454],{"type":14,"tag":162,"props":437,"children":438},{},[439],{"type":14,"tag":372,"props":440,"children":443},{"href":441,"rel":442},"https://github.com/Bestpoker/AOI",[376],[444],{"type":20,"value":441},{"type":14,"tag":162,"props":446,"children":447},{},[448],{"type":14,"tag":372,"props":449,"children":452},{"href":450,"rel":451},"https://github.com/NetEase/pomelo-aoi",[376],[453],{"type":20,"value":450},{"type":14,"tag":162,"props":455,"children":456},{},[457],{"type":14,"tag":372,"props":458,"children":461},{"href":459,"rel":460},"https://github.com/ahuangege/tower-aoi",[376],[462],{"type":20,"value":459},{"type":14,"tag":23,"props":464,"children":465},{},[466],{"type":20,"value":467},"前几天把pomelo中的tower aoi的js实现看了一遍，总结如下：",{"type":14,"tag":469,"props":470,"children":471},"ol",{},[472,477,482,487,492,497,502],{"type":14,"tag":162,"props":473,"children":474},{},[475],{"type":20,"value":476},"js代码写得不是很好，发现了几个小问题；",{"type":14,"tag":162,"props":478,"children":479},{},[480],{"type":20,"value":481},"“对象(包括观察者)出现”“对象(包括观察者)消失”“对象(包括观察者)位置变化”“观察者位置变化”的回调通知(前三者通知对应灯塔区域的观察者，第四个通知观察者本身)没有可测试的样例，采用的话需要自己实现和测试；",{"type":14,"tag":162,"props":483,"children":484},{},[485],{"type":20,"value":486},"只考虑了起点和终点，移动路径上的玩家被忽视了，路径短的话也可能不是问题(长路径切分成多个短路径做位置更新)；",{"type":14,"tag":162,"props":488,"children":489},{},[490],{"type":20,"value":491},"观察者可能收到超出自己视野范围的消息；",{"type":14,"tag":162,"props":493,"children":494},{},[495],{"type":20,"value":496},"优点是可处理视野不同的观察者，相对于普通扫格子的实现在代码层面耦合度降低、效率提升不明显(把扫格子实现的地格看做一个灯塔区域，在地格上记录观察者就可以模拟这种灯塔模型，削去了遍历周边地格所有对象的逻辑)",{"type":14,"tag":162,"props":498,"children":499},{},[500],{"type":20,"value":501},"这里做的是四边形灯塔区域，云风提的那种六边形灯塔区域减少查询灯塔个数是特指视野半径\u003C=六边形边长的一半这种情况",{"type":14,"tag":162,"props":503,"children":504},{},[505],{"type":20,"value":506},"tower aoi其实就是处理地图视野的一个设计，类似于订阅-发布，我订阅某一块区域表示对这一块区域感兴趣，那么有对象在这一块区域出现消失移动你就通知我",{"type":14,"tag":39,"props":508,"children":510},{"id":509},"十字链表法",[511],{"type":20,"value":509},{"type":14,"tag":23,"props":513,"children":514},{},[515],{"type":20,"value":516},"这里以2d游戏为例，3d游戏顺势扩展即可。",{"type":14,"tag":23,"props":518,"children":519},{},[520],{"type":20,"value":521},"所谓十字链表法，即维护两天链表，一条根据地图上所有物体的x坐标从小到大依次插入链表，一条根据地图上所有物体的y坐标从小到大依次插入链表，可以想象成一个十字架。这样便把地图上的所有对象按序分配到了x,y链表上。",{"type":14,"tag":23,"props":523,"children":524},{},[525],{"type":20,"value":526},"这里的链表为双向链表，双向链表的好处是，获取到链表中的一个节点，便可以向前和向后遍历。这样，当我们拿到一个对象时，要获取该对象的视野范围就变得非常简单。避免了从头到尾遍历所有对象。",{"type":14,"tag":23,"props":528,"children":529},{},[530],{"type":20,"value":531},"首先根据x坐标，在x链表上找到该节点，然后从该节点向前和向后遍历，根据x方向的视野范围找出需要识别的对象。",{"type":14,"tag":23,"props":533,"children":534},{},[535],{"type":20,"value":536},"然后根据y坐标，在y链表上找到该节点，然后从该节点向前和向后遍历，根据y方向的视野范围找出需要识别的对象。",{"type":14,"tag":23,"props":538,"children":539},{},[540],{"type":20,"value":541},"拿到x,y链表上需要关注的对象，然后取他们的交集，这便是玩家视野范围内的对象。",{"type":14,"tag":23,"props":543,"children":544},{},[545],{"type":20,"value":546},"对于对象在地图上的enter,move,leave 。根据前面的思路就变得非常简单",{"type":14,"tag":158,"props":548,"children":549},{},[550],{"type":14,"tag":162,"props":551,"children":552},{},[553],{"type":14,"tag":372,"props":554,"children":557},{"href":555,"rel":556},"https://github.com/zhepama/AOI",[376],[558],{"type":20,"value":555},{"type":14,"tag":560,"props":561,"children":563},"h4",{"id":562},"十字链表基本原理",[564],{"type":14,"tag":104,"props":565,"children":566},{},[567],{"type":20,"value":562},{"type":14,"tag":23,"props":569,"children":570},{},[571],{"type":20,"value":572},"根据二维地图，将其分成x轴和y轴两个链表。如果是三维地图，则还需要维护多一个z轴的链表。将对象的坐标值按照从小到大相应的排列在相应的坐标轴上面。",{"type":14,"tag":158,"props":574,"children":575},{},[576],{"type":14,"tag":162,"props":577,"children":578},{},[579],{"type":20,"value":580},"添加到AOI（ADD）: 根据新增对象的X,Y坐标,依次遍历X,Y轴坐标链表,这里有两个目的,一个是获得这个新增对象的坐标在X,Y轴坐标的位置,另一方面获得该通知哪些结点.通知的范围,每个对象可以自己定制自己的通知范围。必须X,Y坐标同时都在通知范围内才可以进入通知集合，我们要按照从小到大进行插入。例如X轴坐标为:",{"type":14,"tag":23,"props":582,"children":583},{},[584],{"type":14,"tag":134,"props":585,"children":587},{"className":586},[],[588],{"type":20,"value":589},"a->b->c->d->e->f->g->h",{"type":14,"tag":23,"props":591,"children":592},{},[593],{"type":20,"value":594},"假设新增一个对象z,它最终所在的位置是c和d之间,需要重新在链表的头部开始遍历寻找z的位置，比如z的X轴位置是5：",{"type":14,"tag":23,"props":596,"children":597},{},[598],{"type":14,"tag":134,"props":599,"children":601},{"className":600},[],[602],{"type":20,"value":603},"a(0)->b(1)->c(2)->d(3)->e(4)-z(5)->f(6)->g(7)->h(8)",{"type":14,"tag":23,"props":605,"children":606},{},[607],{"type":20,"value":608},"但是这样会发现一个问题，如果需要管理的坐标少还可以。但如果有很多个坐标比如1W个坐标，那这个链表会很长，如果每次都需要从头部开始查找效率就很低。针对这样的插入方法目前大家常用的有快速排序、分治、按区域划分格子等方式。",{"type":14,"tag":560,"props":610,"children":612},{"id":611},"目前常用的排序算法",[613],{"type":14,"tag":104,"props":614,"children":615},{},[616],{"type":20,"value":611},{"type":14,"tag":158,"props":618,"children":619},{},[620],{"type":14,"tag":162,"props":621,"children":622},{},[623,625,632],{"type":20,"value":624},"快速排序（Quicksort）是对",{"type":14,"tag":372,"props":626,"children":629},{"href":627,"rel":628},"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306",[376],[630],{"type":20,"value":631},"冒泡排序",{"type":20,"value":633},"的一种改进。",{"type":14,"tag":23,"props":635,"children":636},{},[637,639,646,648,655],{"type":20,"value":638},"快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以",{"type":14,"tag":372,"props":640,"children":643},{"href":641,"rel":642},"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695",[376],[644],{"type":20,"value":645},"递归",{"type":20,"value":647},"进行，以此达到整个数据变成有序",{"type":14,"tag":372,"props":649,"children":652},{"href":650,"rel":651},"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%BA%8F%E5%88%97/1302588",[376],[653],{"type":20,"value":654},"序列",{"type":20,"value":110},{"type":14,"tag":158,"props":657,"children":658},{},[659],{"type":14,"tag":162,"props":660,"children":661},{},[662],{"type":20,"value":663},"分治算法",{"type":14,"tag":23,"props":665,"children":666},{},[667],{"type":20,"value":668},"分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。",{"type":14,"tag":158,"props":670,"children":671},{},[672],{"type":14,"tag":162,"props":673,"children":674},{},[675],{"type":20,"value":676},"按区域划分格子",{"type":14,"tag":23,"props":678,"children":679},{},[680],{"type":20,"value":681},"该方法是把区域划分成多个格子，比如X坐标1到X坐标4为一个格子我们（暂时称之为A格子），坐标5到X坐标9为一个格子（暂时称之为B格子）。这样做的好处是，当你插入的坐标是2的时候，我们只需要遍历A格子里面的数据找到自己位置就可以了。",{"type":14,"tag":23,"props":683,"children":684},{},[685],{"type":20,"value":686},"综合以上三种方法，大家一眼就看出来了。是的，按区域划分格子的方式是目前最佳的方式。从时间复杂度等等所有方便都是这个最佳，但是这个方法也有一个很大的问题，用这样的方式插入是很快了，但查找范围内的坐标就变的很困难了。大家可以仔细考虑一下或者自己写一个DEMO。你马上会发现，当我知道我的位置的情况下，我该如何查找周围玩家呢，是的。这样的话十字链就没有什么用了。",{"type":14,"tag":23,"props":688,"children":689},{},[690],{"type":20,"value":691},"当然会有人说我在每个格子之间用链表进行连接就可以了，那么问题又来了。该如何连接，肯定有很复杂的代码才可以完成这样逻辑。就算是你能完成这个链表的连接，但这些逻辑会提升了时间复杂度。",{"type":14,"tag":560,"props":693,"children":695},{"id":694},"快慢针",[696],{"type":20,"value":694},{"type":14,"tag":23,"props":698,"children":699},{},[700],{"type":20,"value":701},"所谓快慢针就是，总有一个指针快于一个指针。",{"type":14,"tag":23,"props":703,"children":704},{},[705],{"type":20,"value":706},"实现方式是，插入的时候把链表分成多份、比如链表长度为10，快的指针每次移动4个，然后对比当前节点如果位置小于的话，把慢指针指向快指针的位置，快指针继续向后面4个格子移动，直到找到大于的节点为止，这时候慢指针开始向前移动一个一个的对比位置就可以了。如果一直没有找到大于的节点，那就表示要插入的位置是当前链表最后的位置。",{"type":14,"tag":23,"props":708,"children":709},{},[710],{"type":20,"value":711},"相信大家已经看明白了，是的。这样的情况下效率就很高了，唯一的问题就是这个时间复杂度不稳定。使用这个方式，查找周围玩家直接前后查找移动就可以了。效率也非常高。",{"type":14,"tag":23,"props":713,"children":714},{},[715],{"type":20,"value":716},"快慢针实现：",{"type":14,"tag":129,"props":718,"children":722},{"code":719,"language":20,"meta":7,"className":720},"if (First == null)\n{\n      node.Link.YNode = AddFirst(AoiPool.Instance.Fetch\u003CLinkedListNode\u003CAoiNode>>(node).Value);\n}\nelse\n{\n       var slowCursor = First;\n\n       var skip = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(Count) /\n                     Convert.ToDouble(_skipCount)));\n\n       if (Last.Value.Position.Y > node.Position.Y)\n       {\n            for (var i = 0; i \u003C _skipCount; i++)\n            {\n                 // 移动快指针\n\n                 var fastCursor = FastCursor(i * skip, skip);\n\n                 // 如果快指针的值小于插入的值，把快指针赋给慢指针，当做当前指针。\n\n                 if (fastCursor.Value.Position.Y \u003C= node.Position.Y)\n                 {\n                       slowCursor = fastCursor;\n\n                            continue;\n                 }\n\n                 // 慢指针移动到快指针位置\n\n                 while (slowCursor != fastCursor)\n                 {\n                      if (slowCursor == null) break;\n\n                      if (slowCursor.Value.Position.Y >= node.Position.Y)\n                      {\n                           node.Link.YNode = AddBefore(slowCursor,\n                                    AoiPool.Instance.Fetch\u003CLinkedListNode\u003CAoiNode>>(node).Value);\n\n                           return;\n                        }\n\n                       slowCursor = slowCursor.Next;\n\n                        }\n                    }\n                }\n\nif (node.Link.YNode == null)\n{\n       node.Link.YNode = AddLast(AoiPool.Instance.Fetch\u003CLinkedListNode\u003CAoiNode>>(node).Value);\n}\n",[721],"language-text",[723],{"type":14,"tag":134,"props":724,"children":725},{"__ignoreMap":7},[726],{"type":20,"value":719},{"type":14,"tag":560,"props":728,"children":730},{"id":729},"实现方式",[731],{"type":14,"tag":104,"props":732,"children":733},{},[734],{"type":20,"value":729},{"type":14,"tag":158,"props":736,"children":737},{},[738],{"type":14,"tag":162,"props":739,"children":740},{},[741],{"type":20,"value":742},"Move（当角色移动后通知AOI）：",{"type":14,"tag":129,"props":744,"children":747},{"code":745,"language":20,"meta":7,"className":746},"#region 移动X轴\n\n            if (Math.Abs(node.Position.X - x) > 0)\n            {\n                if (x > node.Position.X)\n                {\n                    var cur = node.Link.XNode.Next;\n\n                    while (cur != null)\n                    {\n                        if (x \u003C cur.Value.Position.X)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n\n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Next == null)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Next;\n                    }\n                }\n                else\n                {\n                    var cur = node.Link.XNode.Previous;\n\n                    while (cur != null)\n                    {\n                        if (x > cur.Value.Position.X)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Previous == null)\n                        {\n                            _xLinks.Remove(node.Link.XNode);\n                            \n                            node.Position.X = x;\n                            \n                            node.Link.XNode = _xLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Previous;\n                    }\n                }\n            }\n\n            #endregion\n\n            #region 移动Y轴\n\n            if (Math.Abs(node.Position.Y - y) > 0)\n            {\n                if (y > node.Position.Y)\n                {\n                    var cur = node.Link.YNode.Next;\n\n                    while (cur != null)\n                    {\n                        if (y \u003C cur.Value.Position.Y)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Next == null)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Next;\n                    }\n                }\n                else\n                {\n                    var cur = node.Link.YNode.Previous;\n\n                    while (cur != null)\n                    {\n                        if (y > cur.Value.Position.Y)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddBefore(cur, node);\n\n                            break;\n                        }\n                        else if (cur.Previous == null)\n                        {\n                            _yLinks.Remove(node.Link.YNode);\n                            \n                            node.Position.Y = y;\n                            \n                            node.Link.YNode = _yLinks.AddAfter(cur, node);\n\n                            break;\n                        }\n\n                        cur = cur.Previous;\n                    }\n                }\n            }\n\n            \n            #end-region\n",[721],[748],{"type":14,"tag":134,"props":749,"children":750},{"__ignoreMap":7},[751],{"type":20,"value":745},{"type":14,"tag":158,"props":753,"children":754},{},[755],{"type":14,"tag":162,"props":756,"children":757},{},[758],{"type":20,"value":759},"查找周围（按照指定的范围查找自己周围玩家）：",{"type":14,"tag":129,"props":761,"children":764},{"code":762,"language":20,"meta":7,"className":763},"for (var i = 0; i \u003C 2; i++)\n            {\n                var cur = i == 0 ? node.Link.XNode.Next : node.Link.XNode.Previous;\n\n                while (cur != null)\n                {\n                    if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) > area.X)\n                    {\n                        break;\n                    }\n                    else if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) \u003C= area.Y)\n                    {\n                        if (Distance(node.Position, cur.Value.Position) \u003C= area.X)\n                        {\n                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);\n                        }\n                    }\n\n                    cur = i == 0 ? cur.Next : cur.Previous;\n                }\n            }\n\n            for (var i = 0; i \u003C 2; i++)\n            {\n               var cur = i == 0 ? node.Link.YNode.Next : node.Link.YNode.Previous;\n\n                while (cur != null)\n                {\n                    if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) > area.Y)\n                    {\n                        break;\n                    }\n                    else if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) \u003C= area.X)\n                    {\n                        if (Distance(node.Position, cur.Value.Position) \u003C= area.Y)\n                        {\n                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);\n                        }\n                    }\n\n                    cur = i == 0 ? cur.Next :cur.Previous;\n                }\n            }\n",[721],[765],{"type":14,"tag":134,"props":766,"children":767},{"__ignoreMap":7},[768],{"type":20,"value":762},{"type":14,"tag":15,"props":770,"children":772},{"id":771},"优缺点",[773],{"type":20,"value":771},{"type":14,"tag":158,"props":775,"children":776},{},[777,794],{"type":14,"tag":162,"props":778,"children":779},{},[780,781],{"type":20,"value":231},{"type":14,"tag":158,"props":782,"children":783},{},[784,789],{"type":14,"tag":162,"props":785,"children":786},{},[787],{"type":20,"value":788},"优点: cpu消耗小",{"type":14,"tag":162,"props":790,"children":791},{},[792],{"type":20,"value":793},"缺点: 内存开销大,内存消耗不仅和实体数有关,还和场景大小成正比",{"type":14,"tag":162,"props":795,"children":796},{},[797,799],{"type":20,"value":798},"十字链表",{"type":14,"tag":158,"props":800,"children":801},{},[802,807],{"type":14,"tag":162,"props":803,"children":804},{},[805],{"type":20,"value":806},"优点: 内存开销小,内存消耗仅和实体数有关,和场景大小无关",{"type":14,"tag":162,"props":808,"children":809},{},[810],{"type":20,"value":811},"缺点: cpu消耗高,每次移动都需要计算视野差,当实体在小区域堆积严重时效率更差",{"title":7,"searchDepth":813,"depth":813,"links":814},2,[815,816,817,818,824],{"id":17,"depth":813,"text":21},{"id":46,"depth":813,"text":49},{"id":77,"depth":813,"text":80},{"id":95,"depth":813,"text":95,"children":819},[820,822,823],{"id":141,"depth":821,"text":144},3,{"id":231,"depth":821,"text":231},{"id":390,"depth":821,"text":390},{"id":771,"depth":813,"text":771},"markdown","content:dotnet:2020-02-07-aoi.md","content","dotnet/2020-02-07-aoi.md","md","2020-02-07",[832,842,967,1016,1068,1081,1193],{"title":833,"_path":834,"children":835},"Art","/art",[836,839],{"title":837,"_path":838},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":840,"_path":841},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":843,"_path":844,"children":845},"Dotnet","/dotnet",[846,849,852,855,858,861,864,867,870,873,876,879,882,885,888,891,894,897,900,903,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964],{"title":847,"_path":848},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":850,"_path":851},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":853,"_path":854},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":856,"_path":857},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":859,"_path":860},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":862,"_path":863},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":865,"_path":866},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":868,"_path":869},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":871,"_path":872},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":874,"_path":875},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":877,"_path":878},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":880,"_path":881},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":883,"_path":884},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":886,"_path":887},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":889,"_path":890},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":892,"_path":893},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":895,"_path":896},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":898,"_path":899},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":901,"_path":902},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":8,"_path":4},{"title":905,"_path":906},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":908,"_path":909},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":911,"_path":912},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":914,"_path":915},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":917,"_path":918},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":920,"_path":921},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":923,"_path":924},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":926,"_path":927},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":929,"_path":930},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":932,"_path":933},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":935,"_path":936},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":938,"_path":939},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":941,"_path":942},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":944,"_path":945},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":947,"_path":948},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":950,"_path":951},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":953,"_path":954},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":956,"_path":957},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":959,"_path":960},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":962,"_path":963},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":965,"_path":966},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":968,"_path":969,"children":970},"Game","/game",[971,974,977,980,983,986,989,992,995,998,1001,1004,1007,1010,1013],{"title":972,"_path":973},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":975,"_path":976},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":978,"_path":979},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":981,"_path":982},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":984,"_path":985},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":987,"_path":988},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":990,"_path":991},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":993,"_path":994},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":996,"_path":997},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":999,"_path":1000},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1002,"_path":1003},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1005,"_path":1006},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1008,"_path":1009},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1011,"_path":1012},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1014,"_path":1015},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1017,"_path":1018,"children":1019},"Gyj","/gyj",[1020,1023,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053,1056,1059,1062,1065],{"title":1021,"_path":1022},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1024,"_path":1025},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1027,"_path":1028},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1030,"_path":1031},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1033,"_path":1034},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1036,"_path":1037},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1039,"_path":1040},"玩法","/gyj/2022-08-22-wanfa",{"title":1042,"_path":1043},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1045,"_path":1046},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1048,"_path":1049},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1051,"_path":1052},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1054,"_path":1055},"门派内容相关","/gyj/2022-11-17-sect",{"title":1057,"_path":1058},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1060,"_path":1061},"种植","/gyj/2022-12-01-zhongzhi",{"title":1063,"_path":1064},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1066,"_path":1067},"跑商","/gyj/2023-11-01-paoshang",{"title":1069,"_path":1070,"children":1071},"Js","/js",[1072,1075,1078],{"title":1073,"_path":1074},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1076,"_path":1077},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1079,"_path":1080},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1082,"_path":1083,"children":1084},"Tool","/tool",[1085,1088,1091,1094,1097,1100,1103,1106,1109,1112,1115,1118,1121,1124,1127,1130,1133,1136,1139,1142,1145,1148,1151,1154,1157,1160,1163,1166,1169,1172,1175,1178,1181,1184,1187,1190],{"title":1086,"_path":1087},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1089,"_path":1090},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1092,"_path":1093},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1095,"_path":1096},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1098,"_path":1099},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1101,"_path":1102},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1104,"_path":1105},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1107,"_path":1108},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1110,"_path":1111},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1113,"_path":1114},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1116,"_path":1117},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1119,"_path":1120},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1122,"_path":1123},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1125,"_path":1126},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1128,"_path":1129},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1131,"_path":1132},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1134,"_path":1135},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1137,"_path":1138},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1140,"_path":1141},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1143,"_path":1144},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1146,"_path":1147},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1149,"_path":1150},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1152,"_path":1153},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1155,"_path":1156},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1158,"_path":1159},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1161,"_path":1162},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1164,"_path":1165},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1167,"_path":1168},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1170,"_path":1171},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1173,"_path":1174},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1176,"_path":1177},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1179,"_path":1180},"rider的使用","/tool/2022-08-02-rider-use",{"title":1182,"_path":1183},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1185,"_path":1186},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1188,"_path":1189},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1191,"_path":1192},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1194,"_path":1195,"children":1196},"Unity","/unity",[1197,1200,1203,1206,1209,1212,1215,1218,1221,1224,1227,1230,1233,1236,1239,1242,1245,1248,1251,1254,1257,1260,1263,1266,1269,1272,1275,1278,1281,1284,1287,1290,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392,1395,1398,1401,1404,1407,1410],{"title":1198,"_path":1199},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1201,"_path":1202},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1204,"_path":1205},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1207,"_path":1208},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1210,"_path":1211},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1213,"_path":1214},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1216,"_path":1217},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1219,"_path":1220},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1222,"_path":1223},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1225,"_path":1226},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1228,"_path":1229},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1231,"_path":1232},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1234,"_path":1235},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1237,"_path":1238},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1240,"_path":1241},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1243,"_path":1244},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1246,"_path":1247},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1249,"_path":1250},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1252,"_path":1253},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1255,"_path":1256},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1258,"_path":1259},"技能系统","/unity/2020-02-15-skill-system",{"title":1261,"_path":1262},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1264,"_path":1265},"角色状态设计","/unity/2020-02-17-character-states",{"title":1267,"_path":1268},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1270,"_path":1271},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1273,"_path":1274},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1276,"_path":1277},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1279,"_path":1280},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1282,"_path":1283},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1285,"_path":1286},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1288,"_path":1289},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1291,"_path":1292},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1294,"_path":1295},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1297,"_path":1298},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1300,"_path":1301},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1303,"_path":1304},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1306,"_path":1307},"unity的addressables","/unity/2020-09-12-addressables",{"title":1309,"_path":1310},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1312,"_path":1313},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1315,"_path":1316},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1318,"_path":1319},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1321,"_path":1322},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1324,"_path":1325},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1327,"_path":1328},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1330,"_path":1331},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1333,"_path":1334},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1336,"_path":1337},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1339,"_path":1340},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1342,"_path":1343},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1345,"_path":1346},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1348,"_path":1349},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1351,"_path":1352},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1354,"_path":1355},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1357,"_path":1358},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1360,"_path":1361},"ability","/unity/2020-11-16-dotssample",{"title":1363,"_path":1364},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1366,"_path":1367},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1369,"_path":1370},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1372,"_path":1373},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1375,"_path":1376},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1378,"_path":1379},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1381,"_path":1382},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1384,"_path":1385},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1387,"_path":1388},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1390,"_path":1391},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1393,"_path":1394},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1396,"_path":1397},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1399,"_path":1400},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1402,"_path":1403},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1405,"_path":1406},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1408,"_path":1409},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1411,"_path":1412},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779040675]