[{"data":1,"prerenderedAt":1188},["Reactive",2],{"content-query-hlAcFaWzbB":3,"content-navigation-8C37fagqQL":606},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":600,"_id":601,"_source":602,"_file":603,"_extension":604,"date":605},"/dotnet/2019-11-01-lock-step","dotnet",false,"","帧同步的相关问题","Lock-Step我们把游戏的前进分为一帧帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都",{"type":11,"children":12,"toc":592},"root",[13,22,47,53,61,66,72,77,82,87,94,99,104,111,116,121,126,131,136,146,151,160,165,171,176,181,186,191,196,201,206,211,216,221,226,231,243,248,253,258,263,268,281,286,291,296,301,306,311,316,332,337,342,347,358,389,404,418,423,428,433,440,447,454,459,468,477,482,494,503,508,517,531,536,541,546,551],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"lock-step",[19],{"type":20,"value":21},"text","Lock-Step",{"type":14,"tag":23,"props":24,"children":25},"ol",{},[26,32,37,42],{"type":14,"tag":27,"props":28,"children":29},"li",{},[30],{"type":20,"value":31},"我们把游戏的前进分为一帧帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。",{"type":14,"tag":27,"props":33,"children":34},{},[35],{"type":20,"value":36},"每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。",{"type":14,"tag":27,"props":38,"children":39},{},[40],{"type":20,"value":41},"Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都等于延迟最高的那个人。",{"type":14,"tag":27,"props":43,"children":44},{},[45],{"type":20,"value":46},"由于大家的turn一致，以及输入固定，所以每一步所有客户端的计算结果都一致的。",{"type":14,"tag":48,"props":49,"children":50},"p",{},[51],{"type":20,"value":52},"我们来看看具体的执行流程:",{"type":14,"tag":48,"props":54,"children":55},{},[56],{"type":14,"tag":57,"props":58,"children":60},"img",{"alt":57,"src":59},"/images/2019-11-01-lock-step/113252_S4Vd_1859679.png",[],{"type":14,"tag":48,"props":62,"children":63},{},[64],{"type":20,"value":65},"上图中我们可以明显看到，这种囚徒模式的帧同步，在第二帧的时候，因为玩家1有延迟，而导致第二帧的同步时间发生延迟，从而导致所有玩家都在等待，出现卡顿现象",{"type":14,"tag":15,"props":67,"children":69},{"id":68},"bucket-synchronization乐观锁",[70],{"type":20,"value":71},"Bucket Synchronization(乐观锁)",{"type":14,"tag":48,"props":73,"children":74},{},[75],{"type":20,"value":76},"囚徒模式的帧同步，有一个致命的缺陷就是，若联网的玩家有一个网速慢了，势必会影响其他玩家的体验，因为服务器要等待所有输入达到之后再同步到所有的c端。另外如果中途有人掉线了，游戏就会无法继续或者掉线玩家无法重连，因为在严格的帧同步的情况下，中途加入游戏是从技术上来讲是非常困难的。因为你重新进来之后，你的初始状态和大家不一致，而且你的状态信息都是丢失状态的，比如，你的等级，随机种子，角色的属性信息等。 比如玩过早期的冰封王座都知道，一旦掉线基本这局就废了，需要重开，至于为何没有卡顿的现象，因为那时都是解决方案都是采用局域网的方式，所以基本是没有延迟问题的。",{"type":14,"tag":48,"props":78,"children":79},{},[80],{"type":20,"value":81},"后期为了解决这个问题，如今包括王者荣耀，服务器会保存玩家当场游戏的游戏指令以及状态信息，在玩家断线重连的时候，能够恢复到断线前的状态。不过这个还是无法解决帧同步的问题，因为严格的帧同步，是要等到所有玩家都输入之后，再去通知广播client更新，如果A服务器一直没有输入同步过来，大家是要等着的，那么如何解决这个问题？",{"type":14,"tag":48,"props":83,"children":84},{},[85],{"type":20,"value":86},"采用“定时不等待”的乐观方式在每次Interval时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新。如此帧率的时钟在由服务器控制，当客户端有操作的时候及时的发送服务器，然后服务端每秒钟20-50次向所有客户端发送更新消息。如下图:",{"type":14,"tag":48,"props":88,"children":89},{},[90],{"type":14,"tag":57,"props":91,"children":93},{"alt":57,"src":92},"/images/2019-11-01-lock-step/113303_rNd5_1859679.png",[],{"type":14,"tag":48,"props":95,"children":96},{},[97],{"type":20,"value":98},"上图中，我们看到服务器不会再等到搜集完所有用户输入再进行下一帧，而是按照固定频率来同步玩家的输入信息到每一个c端，如果有玩家网络延迟，服务器的帧步进是不会等待的，比如上图中，在第二帧的时候，玩家A的网速慢，那么他这个时候，会被网速快的玩家给秒了（其他游戏也差不多）。但是网速慢的玩家不会卡到快的玩家，只会感觉自己操作延迟而已。",{"type":14,"tag":48,"props":100,"children":101},{},[102],{"type":20,"value":103},"Bucket Synchronization 是 Lock-Step 的改良算法. 算法流程可以参考下图:",{"type":14,"tag":48,"props":105,"children":106},{},[107],{"type":14,"tag":57,"props":108,"children":110},{"alt":57,"src":109},"/images/2019-11-01-lock-step/bucket.png",[],{"type":14,"tag":48,"props":112,"children":113},{},[114],{"type":20,"value":115},"Bucket Synchronization 算法应用于网状网络, 网络中有一个 master 节点(也是 client).",{"type":14,"tag":48,"props":117,"children":118},{},[119],{"type":20,"value":120},"master 在启动之初, 会对所有 client 做网络对时, 计算网络包的超时时间.",{"type":14,"tag":48,"props":122,"children":123},{},[124],{"type":20,"value":125},"master 会设置一个 bucket 时间, 在每个 bucket 时间节点, master 执行收集到的所有 step 指令, 并将更新推送到所有的 client 上. (上图的例子是一个简化流程, 只有俩 client, 没有 master 推送)",{"type":14,"tag":48,"props":127,"children":128},{},[129],{"type":20,"value":130},"master 对收集到的 step 包做超时校验机制, 如果收到的 step 指令包的时间戳, 延迟超过了预设的阈值, 就当作超时包丢弃.",{"type":14,"tag":48,"props":132,"children":133},{},[134],{"type":20,"value":135},"与 Lock-Step 相比, Bucket Synchronization 改进的是: 设置了 bucket 的概念, 执行每一帧的时间是固定的 bucket 时间节点, 而不必等到收到所有的 client step 指令, 从而网络不再受最差的 client 限制.",{"type":14,"tag":15,"props":137,"children":139},{"id":138},"timewrap-synchronization",[140],{"type":14,"tag":141,"props":142,"children":143},"strong",{},[144],{"type":20,"value":145},"TimeWrap Synchronization",{"type":14,"tag":48,"props":147,"children":148},{},[149],{"type":20,"value":150},"它是一个基于某些状态支持回滚(rollback)的同步算法。有点类似HL的做法。\n简言之，就是对每个操作指令的执行后保存一个状态快照(snapshot)，\n各个peer按照自己的预测先行显示，但在发生一致性冲突的情况下，\n回滚到上一个状态，并重新将指令序列在基于回滚后的快照的基础上再\n执行一次，以获得正确的当前状态。",{"type":14,"tag":15,"props":152,"children":154},{"id":153},"trailing-state-synchronization",[155],{"type":14,"tag":141,"props":156,"children":157},{},[158],{"type":20,"value":159},"Trailing State Synchronization",{"type":14,"tag":48,"props":161,"children":162},{},[163],{"type":20,"value":164},"对TimeWrap Synchronization的一种改进。TimeWrap方案中建立snapshot是\n以指令数量(1或少量几个指令)间隔为单位；而TSS方案则以某种延迟值(100ms)\n间隔为单位对游戏做snapshot(比如100ms前做一个，200ms前做一个...)。\n当发生一致性冲突时，寻找最远需要开始计算的snapshot，并将该snapshot到\n现在为止的时间内的指令重新执行，得到正确的最新状态。",{"type":14,"tag":15,"props":166,"children":168},{"id":167},"state-hash",[169],{"type":20,"value":170},"State Hash",{"type":14,"tag":48,"props":172,"children":173},{},[174],{"type":20,"value":175},"在实现中客户端需要计算一些关键信息的hash值，提供给服务器以便发现游戏中的同步问题，例如玩家的位置信息，各个客户端计算结果是否一致等等。",{"type":14,"tag":48,"props":177,"children":178},{},[179],{"type":20,"value":180},"客户端执行完每个逻辑帧后，会根据游戏的状态计算出一个Hash值，用其标定一个具体的游戏状态。不同客户端通过对比这个值，即可判断客户端之间是否保持同步，平常也可用于不同步Debug。",{"type":14,"tag":48,"props":182,"children":183},{},[184],{"type":20,"value":185},"游戏外挂的种类有很多，这里所谈的外挂仅指会更改游戏逻辑执行或数值的外挂，应该也是题主最关心的类型。对于帧同步防外挂，因为游戏逻辑执行在本地，假如某个客户端使用了外挂的话，那么必然会导致其计算出的State Hash与其他客户端不一致。",{"type":14,"tag":48,"props":187,"children":188},{},[189],{"type":20,"value":190},"1、 客户端自验证（PVP 3人及以上）",{"type":14,"tag":48,"props":192,"children":193},{},[194],{"type":20,"value":195},"PVP3人及以上的战斗中，客户端上报服务器各自计算的State Hash，服务器可以通过对比State Hash判断具体哪一个客户端发生了不同步。当然，不同步也可能是客户端BUG，不同步也不一定就结算不一致。根绝不同的需求，你也可以在发现不同步后马上中断游戏。这个方法的缺点主要在于3人以下或者单机模式的话就没法使用了。",{"type":14,"tag":48,"props":197,"children":198},{},[199],{"type":20,"value":200},"2、客户端分布式验证",{"type":14,"tag":48,"props":202,"children":203},{},[204],{"type":20,"value":205},"假如客户端的核心逻辑写得足够干净和独立的话，服务器可以将某一场战斗的数据下发给一个空闲客户端，令其新起一个线程慢慢地计算验证，再将结果上报至服务器。能做到这一点的话，任何战斗模式都可以进行验证了。",{"type":14,"tag":48,"props":207,"children":208},{},[209],{"type":20,"value":210},"3、服务器验证",{"type":14,"tag":48,"props":212,"children":213},{},[214],{"type":20,"value":215},"与客户端分布式验证相同，客户端逻辑如果足够干净和独立，那么服务器也可以自己验算战斗结果。",{"type":14,"tag":48,"props":217,"children":218},{},[219],{"type":20,"value":220},"4、服务器统计与运营策略",{"type":14,"tag":48,"props":222,"children":223},{},[224],{"type":20,"value":225},"非单机模式下，服务器都根据客户端的State Hash对战斗的同步情况进行记录。将经常发生不同步的客户端标记出来，然后进一步处理。运营可以为玩家每日不同步可结算的次数设定一个阈值，超过则当日之后的战斗结算均无效。",{"type":14,"tag":48,"props":227,"children":228},{},[229],{"type":20,"value":230},"1和4是任何帧同步游戏都可以做的，2与3对游戏的框架要求比较高。我们的游戏因为是从单机版改造过来的，所以也只做了1和4。",{"type":14,"tag":232,"props":233,"children":234},"ul",{},[235],{"type":14,"tag":27,"props":236,"children":237},{},[238],{"type":14,"tag":141,"props":239,"children":240},{},[241],{"type":20,"value":242},"游戏逻辑的回滚",{"type":14,"tag":48,"props":244,"children":245},{},[246],{"type":20,"value":247},"回滚逻辑，就是我们解决问题的方案。可以这样理解，客户端的时间，领先服务器，客户端不需要服务器确认帧返回才执行指令，而是玩家输入，立刻执行（其他玩家的输入，按照其最近一个输入做预测，或者其他更优化的预测方案），然后将指令发送给服务器，服务器收到后给客户端确认，客户端收到确认后，如果服务确认的操作，和之前执行的一样（自己和其他玩家预测的操作），将不做任何改变，如果不一样（预测错误），就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧，然后再追上当前客户端的帧。",{"type":14,"tag":48,"props":249,"children":250},{},[251],{"type":20,"value":252},"此处逻辑较为复杂，我尝试举个例子说明下。",{"type":14,"tag":48,"props":254,"children":255},{},[256],{"type":20,"value":257},"当前客户端（A，B）执行到100帧，服务器执行到97帧。在100帧的时候，A执行了移动，B执行了攻击，A和B都通知服务器：我已经执行到100帧，我的操作是移动（A），攻击（B）。服务器在自己的98帧或99帧收到了A，B的消息，存在对应帧的操作数据中，等服务器执行到100帧的时候（或提前），将这个数据广播给AB。",{"type":14,"tag":48,"props":259,"children":260},{},[261],{"type":20,"value":262},"然后A和B立刻开始执行100帧，A执行移动，预测B不执行操作。而B执行攻击，预测A执行攻击（可能A的99帧也是攻击），A和B各自预测对方的操作。",{"type":14,"tag":48,"props":264,"children":265},{},[266],{"type":20,"value":267},"在A和B执行完100帧后，他们会各自保存100帧的状态快照，以及100帧各自的操作（包括预测的操作），以备万一预测错误，做逻辑回滚。",{"type":14,"tag":48,"props":269,"children":270},{},[271,273,279],{"type":20,"value":272},"执行几帧后，A，B来到了103帧，服务器到了100帧，他开始广播数据给AB，在一定延迟后，AB收到了服务器确认的100帧的数据，这时候，AB可能已经执行到104了。A和B各自去核对服务器的数据和自己预测的数据是否相同。例如A核对后，100帧的操作，和自己预测的一样，A不做任何处理，继续往前。而B核对后，发现在100帧，B对A的预测，和服务器确认的A的操作，是不一样的（B预测的是攻击，而实际A的操作是移动），B就回滚到上一个确认一样的帧，即99帧，然后根据确认的100帧操作去执行100帧，然后快速执行101",{"type":14,"tag":274,"props":275,"children":276},"del",{},[277],{"type":20,"value":278},"103的帧逻辑，之后继续执行104帧，其中（101",{"type":20,"value":280},"104）还是预测的逻辑帧。",{"type":14,"tag":48,"props":282,"children":283},{},[284],{"type":20,"value":285},"因为客户端对当前操作的立刻执行，这个操作手感，是完全和pve（不联网状态）是一样的，不存在任何delay。所以，能做到绝佳的操作手感。当预测不一样的时候，做逻辑回滚，快速追回当前操作。",{"type":14,"tag":48,"props":287,"children":288},{},[289],{"type":20,"value":290},"这样，对于网络好的玩家，和网络不好的玩家，都不会互相影响，不会像lockstep一样，网络好的玩家，会被网络不好的玩家lock住。也不会被网络延迟lock住，客户端可以一直往前预测。",{"type":14,"tag":48,"props":292,"children":293},{},[294],{"type":20,"value":295},"对于网络好的玩家（A），可以动态调整（根据动态的latency），让客户端领先服务器少一些，尽量减少预测量，就会尽量减少回滚，例如网络好的，可能客户端只领先2~3帧。",{"type":14,"tag":48,"props":297,"children":298},{},[299],{"type":20,"value":300},"对于网络不好的玩家（B），动态调整，领先服务器多一些，根据latency调整，例如领先5帧。",{"type":14,"tag":48,"props":302,"children":303},{},[304],{"type":20,"value":305},"那么，A可能预测错的情况，只有2~3帧，而网络不好的B，可能预测错误的帧有5帧。通过优化的预测技术，和消息通知的优化，可以进一步减少A和B的预测错误率。对于A而言，战斗是顺畅的，手感很好，少数情况的回滚，优化好了，并不会带来卡顿和延迟感。",{"type":14,"tag":48,"props":307,"children":308},{},[309],{"type":20,"value":310},"重点优化的是B，即网络不好的玩家，他的操作体验。因为客户端不等待服务器确认，就执行操作，所以B的操作手感，和A是一致的，区别只在于，B因为延迟，预测了比较多的帧，可能导致预测错，回滚会多一些。比如按照B的预测，应该在100帧击中A，但是因为预测错误A的操作，回滚重新执行后，B可能在100帧不会击中A。这对于B来说，通过插值和一些平滑方式，B的感受是不会有太大区别的，因为B看自己，操作自己都是及时反馈的，他感觉自己是平滑的。",{"type":14,"tag":48,"props":312,"children":313},{},[314],{"type":20,"value":315},"这种方式，保证了网络不好的B的操作手感，和A一致。回滚导致的一些轻微的抖动，都是B看A的抖动，通过优化（插值，平滑等），进一步减少这些后，B的感受是很好的。我们测试在200~300毫秒随机延迟的情况下，B的操作手感良好。",{"type":14,"tag":48,"props":317,"children":318},{},[319,321,330],{"type":20,"value":320},"这里，客户端提前服务器的方式，并且在延迟增大的情况下，客户端将加速，和",{"type":14,"tag":322,"props":323,"children":327},"a",{"href":324,"rel":325},"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/cOGn8-rHWLIxdDz-R3pXDg",[326],"nofollow",[328],{"type":20,"value":329},"守望先锋的处理方式",{"type":20,"value":331},"是一样的。当然，他们肯定比我做得好很多。",{"type":14,"tag":48,"props":333,"children":334},{},[335],{"type":20,"value":336},"希望我已经大致讲清楚了这个逻辑，大家参看几篇链接的文章，能体会更深。",{"type":14,"tag":48,"props":338,"children":339},{},[340],{"type":20,"value":341},"这里，我要强调的一点是，我们这里的预测执行，是真实逻辑的预测，和很多介绍帧同步文章提到的预测是不同的。有些文章介绍的预测执行，只是view层面的预测，例如前摇动作和位移，但是逻辑是不会提前执行的，还是要等服务器的返回。这两种预测执行（View的预测执行，和真实逻辑的预测执行）是完全不是一个概念的，这里需要仔细地区分。",{"type":14,"tag":48,"props":343,"children":344},{},[345],{"type":20,"value":346},"这里有很多的可以优化的点，我就不一一介绍了，以后可能零散地再谈。",{"type":14,"tag":232,"props":348,"children":349},{},[350],{"type":14,"tag":27,"props":351,"children":352},{},[353],{"type":14,"tag":141,"props":354,"children":355},{},[356],{"type":20,"value":357},"游戏逻辑的快照（snapshot）",{"type":14,"tag":48,"props":359,"children":360},{},[361,363,370,372,378,380,387],{"type":20,"value":362},"我们的逻辑之所以能回滚，都是基于对每一帧状态可以处理快照，存储下每一帧的状态，并可以回滚到任何一帧的状态。在",{"type":14,"tag":322,"props":364,"children":367},{"href":365,"rel":366},"https://link.zhihu.com/?target=http%3A//mauve.mizuumi.net/2012/07/05/understanding-fighting-game-networking/",[326],[368],{"type":20,"value":369},"Understanding Fighting Game Networking",{"type":20,"value":371}," 文章和",{"type":14,"tag":322,"props":373,"children":375},{"href":324,"rel":374},[326],[376],{"type":20,"value":377},"守望先锋网络",{"type":20,"value":379}," 文章中，都一笔带过了快照的说明。他们说的快照，可能略有不同，但是思路，都是能保存下每一帧的状态。如果去处理快照（Understanding那篇文章做的是模拟器游戏，可以方便地以内存快照的方式来做），是一个难点，这也是我",{"type":14,"tag":322,"props":381,"children":384},{"href":382,"rel":383},"https://zhuanlan.zhihu.com/p/38280972",[326],[385],{"type":20,"value":386},"前面文章",{"type":20,"value":388},"提到ECS在这个方式下的应用，云风的解释：",{"type":14,"tag":48,"props":390,"children":391},{},[392,396,398],{"type":14,"tag":57,"props":393,"children":395},{"alt":57,"src":394},"/images/2019-11-01-lock-step/v2-253646290632dd9ed3ca6453c4b754b5_1440w.jpg",[],{"type":20,"value":397},"云风博客截图，地址",{"type":14,"tag":322,"props":399,"children":402},{"href":400,"rel":401},"https://blog.codingnow.com/2017/06/overwatch_ecs.html",[326],[403],{"type":20,"value":400},{"type":14,"tag":48,"props":405,"children":406},{},[407,409,416],{"type":20,"value":408},"ECS是一个好的处理方式，并且我找到",{"type":14,"tag":322,"props":410,"children":413},{"href":411,"rel":412},"https://link.zhihu.com/?target=https%3A//www.kisence.com/2017/11/12/guan-yu-zheng-tong-bu-de-xie-xin-de/",[326],[414],{"type":20,"value":415},"一篇文章",{"type":20,"value":417},"，也这样做了（我看过他开源的demo，做得还不够好，应该还是demo阶段，不太像是一个成型的项目）。这篇文章的思路是很清晰的，并且也点到了一些实实在在的痛点，解决思路也基本是正确的，可以参看。",{"type":14,"tag":48,"props":419,"children":420},{},[421],{"type":20,"value":422},"这块，我做得比较早了，当时守望先锋的文章还没出，我的战斗也没有基于ECS，所以，在处理快照上，只有自己理顺逻辑来做了。",{"type":14,"tag":48,"props":424,"children":425},{},[426],{"type":20,"value":427},"我的思路是，通过一个回滚接口，需要数据回滚的部分，实现接口，各自处理自己的保存快照和回滚。就像我们序列化一个复杂的配置，每个配置各自序列化自己的部分，最终合并成一个序列化好的文件。",{"type":14,"tag":48,"props":429,"children":430},{},[431],{"type":20,"value":432},"首先，定义接口，和快照数据的reader和writer",{"type":14,"tag":48,"props":434,"children":435},{},[436],{"type":14,"tag":57,"props":437,"children":439},{"alt":57,"src":438},"/images/2019-11-01-lock-step/v2-5052de9e1c12b7e87d2f452b29fdef61_1440w.jpg",[],{"type":14,"tag":48,"props":441,"children":442},{},[443],{"type":14,"tag":57,"props":444,"children":446},{"alt":57,"src":445},"/images/2019-11-01-lock-step/v2-b666f214abd2a804e885237c5bcc119b_1440w.jpg",[],{"type":14,"tag":48,"props":448,"children":449},{},[450],{"type":14,"tag":57,"props":451,"children":453},{"alt":57,"src":452},"/images/2019-11-01-lock-step/v2-2f49a68d6fd54381d8e7bdf3ffdfb283_1440w.jpg",[],{"type":14,"tag":48,"props":455,"children":456},{},[457],{"type":20,"value":458},"然后，就是每个模块，自己去处理自己的takeSnapshot和rollback，例如：",{"type":14,"tag":48,"props":460,"children":461},{},[462,466],{"type":14,"tag":57,"props":463,"children":465},{"alt":57,"src":464},"/images/2019-11-01-lock-step/v2-96bb5917e8a766ef79323613179f404d_1440w.jpg",[],{"type":20,"value":467},"简单的数值回滚",{"type":14,"tag":48,"props":469,"children":470},{},[471,475],{"type":14,"tag":57,"props":472,"children":474},{"alt":57,"src":473},"/images/2019-11-01-lock-step/v2-1573d2a9eeec5b5d8e7e663a8e06f487_1440w.jpg",[],{"type":20,"value":476},"复制的列表回滚和调用子模块回滚",{"type":14,"tag":48,"props":478,"children":479},{},[480],{"type":20,"value":481},"思路理顺以后，就可以很方便地处理了，注意write和read的顺序，注意处理好list，就解决了大部分问题。当然，在实现逻辑的过程中，时刻要注意，一个模块如何回滚（例如获取随机数也需要回滚）。",{"type":14,"tag":48,"props":483,"children":484},{},[485,487,492],{"type":20,"value":486},"有一个更简单的方式，就是给属性打Attribute，然后写通用的方法。例如，我早",{"type":14,"tag":141,"props":488,"children":489},{},[490],{"type":20,"value":491},"期的实现方案",{"type":20,"value":493},"：",{"type":14,"tag":48,"props":495,"children":496},{},[497,501],{"type":14,"tag":57,"props":498,"children":500},{"alt":57,"src":499},"/images/2019-11-01-lock-step/v2-05fee97a51c743b54d8dca8074fe042f_1440w.jpg",[],{"type":20,"value":502},"给属性打标签",{"type":14,"tag":48,"props":504,"children":505},{},[506],{"type":20,"value":507},"根据标签，通用的读写方法，通过反射来读写，就不需要每个模块自己去实现自己的方法了：",{"type":14,"tag":48,"props":509,"children":510},{},[511,515],{"type":14,"tag":57,"props":512,"children":514},{"alt":57,"src":513},"/images/2019-11-01-lock-step/v2-c27132db564887adc282fe621f2357e3_1440w.jpg",[],{"type":20,"value":516},"部分代码",{"type":14,"tag":48,"props":518,"children":519},{},[520,522,529],{"type":20,"value":521},"这种方法，能很好地解决大部分问题，甚至前面提到的",{"type":14,"tag":322,"props":523,"children":526},{"href":524,"rel":525},"https://link.zhihu.com/?target=https%3A//github.com/suzuke/TrueSync/tree/master/Assets/TrueSync/Engine/Math",[326],[527],{"type":20,"value":528},"Truesync",{"type":20,"value":530},"，也是用的这种方式来做。",{"type":14,"tag":48,"props":532,"children":533},{},[534],{"type":20,"value":535},"但是这种方法有个难以回避的问题，就是GC，因为基于反射，当我们调用field的GetValue和SetValue的时候，GC难以避免。并且，因为全自动，不方便处理一些特殊逻辑，调试优化也不方便，最后改成了现有的方式，虽然看起来笨重一些，但是可控性更强，我后续做的很多优化，都方便很多。",{"type":14,"tag":48,"props":537,"children":538},{},[539],{"type":20,"value":540},"关于快照，也有很多可以优化的点，无论是GC内存上的，还是运行效率上的，都需要优化好，否则，可能带来性能问题。这块优化，有空另辟文章再细谈吧。",{"type":14,"tag":48,"props":542,"children":543},{},[544],{"type":20,"value":545},"当我们有了快照，就可以支持回滚，甚至跳转。例如我们要看战斗录像，如果没有快照，我们要跳到1000帧，就需要从第一帧，根据保存的操作指令，一直快速执行到1000帧，而有了快照，可以直接跳到1000帧，不需要执行中间的过程，如果需要在不同的帧之间切换，只需要跳转即可，这将带来巨大的帮助。",{"type":14,"tag":48,"props":547,"children":548},{},[549],{"type":20,"value":550},"参考文章：",{"type":14,"tag":232,"props":552,"children":553},{},[554,559,564,569,574,583],{"type":14,"tag":27,"props":555,"children":556},{},[557],{"type":20,"value":558},"Minimization of Latency in Cheat-Proof Real-Time Gaming by Trusting Time-Stamp Servers",{"type":14,"tag":27,"props":560,"children":561},{},[562],{"type":20,"value":563},"End-to-end transmission control mechanisms for multiparty interactive applicatins on the Internet",{"type":14,"tag":27,"props":565,"children":566},{},[567],{"type":20,"value":568},"Dead Reckoning: Latency Hiding for Networked Games",{"type":14,"tag":27,"props":570,"children":571},{},[572],{"type":20,"value":573},"An Efficient Synchronization Mechanism for Mirrored Game Architectures",{"type":14,"tag":27,"props":575,"children":576},{},[577],{"type":14,"tag":322,"props":578,"children":581},{"href":579,"rel":580},"https://gameinstitute.qq.com/community/detail/117819",[326],[582],{"type":20,"value":579},{"type":14,"tag":27,"props":584,"children":585},{},[586],{"type":14,"tag":322,"props":587,"children":590},{"href":588,"rel":589},"https://zhuanlan.zhihu.com/p/38468615",[326],[591],{"type":20,"value":588},{"title":7,"searchDepth":593,"depth":593,"links":594},2,[595,596,597,598,599],{"id":17,"depth":593,"text":21},{"id":68,"depth":593,"text":71},{"id":138,"depth":593,"text":145},{"id":153,"depth":593,"text":159},{"id":167,"depth":593,"text":170},"markdown","content:dotnet:2019-11-01-lock-step.md","content","dotnet/2019-11-01-lock-step.md","md","2019-11-01",[607,617,742,791,843,856,968],{"title":608,"_path":609,"children":610},"Art","/art",[611,614],{"title":612,"_path":613},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":615,"_path":616},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":618,"_path":619,"children":620},"Dotnet","/dotnet",[621,624,627,628,631,634,637,640,643,646,649,652,655,658,661,664,667,670,673,676,679,682,685,688,691,694,697,700,703,706,709,712,715,718,721,724,727,730,733,736,739],{"title":622,"_path":623},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":625,"_path":626},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":8,"_path":4},{"title":629,"_path":630},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":632,"_path":633},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":635,"_path":636},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":638,"_path":639},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":641,"_path":642},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":644,"_path":645},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":647,"_path":648},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":650,"_path":651},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":653,"_path":654},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":656,"_path":657},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":659,"_path":660},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":662,"_path":663},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":665,"_path":666},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":668,"_path":669},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":671,"_path":672},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":674,"_path":675},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":677,"_path":678},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":680,"_path":681},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":683,"_path":684},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":686,"_path":687},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":689,"_path":690},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":692,"_path":693},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":695,"_path":696},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":698,"_path":699},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":701,"_path":702},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":704,"_path":705},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":707,"_path":708},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":710,"_path":711},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":713,"_path":714},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":716,"_path":717},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":719,"_path":720},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":722,"_path":723},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":725,"_path":726},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":728,"_path":729},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":731,"_path":732},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":734,"_path":735},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":737,"_path":738},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":740,"_path":741},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":743,"_path":744,"children":745},"Game","/game",[746,749,752,755,758,761,764,767,770,773,776,779,782,785,788],{"title":747,"_path":748},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":750,"_path":751},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":753,"_path":754},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":756,"_path":757},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":759,"_path":760},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":762,"_path":763},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":765,"_path":766},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":768,"_path":769},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":771,"_path":772},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":774,"_path":775},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":777,"_path":778},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":780,"_path":781},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":783,"_path":784},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":786,"_path":787},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":789,"_path":790},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":792,"_path":793,"children":794},"Gyj","/gyj",[795,798,801,804,807,810,813,816,819,822,825,828,831,834,837,840],{"title":796,"_path":797},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":799,"_path":800},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":802,"_path":803},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":805,"_path":806},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":808,"_path":809},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":811,"_path":812},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":814,"_path":815},"玩法","/gyj/2022-08-22-wanfa",{"title":817,"_path":818},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":820,"_path":821},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":823,"_path":824},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":826,"_path":827},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":829,"_path":830},"门派内容相关","/gyj/2022-11-17-sect",{"title":832,"_path":833},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":835,"_path":836},"种植","/gyj/2022-12-01-zhongzhi",{"title":838,"_path":839},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":841,"_path":842},"跑商","/gyj/2023-11-01-paoshang",{"title":844,"_path":845,"children":846},"Js","/js",[847,850,853],{"title":848,"_path":849},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":851,"_path":852},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":854,"_path":855},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":857,"_path":858,"children":859},"Tool","/tool",[860,863,866,869,872,875,878,881,884,887,890,893,896,899,902,905,908,911,914,917,920,923,926,929,932,935,938,941,944,947,950,953,956,959,962,965],{"title":861,"_path":862},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":864,"_path":865},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":867,"_path":868},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":870,"_path":871},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":873,"_path":874},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":876,"_path":877},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":879,"_path":880},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":882,"_path":883},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":885,"_path":886},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":888,"_path":889},"mac下brew 使用","/tool/2020-01-13-brew",{"title":891,"_path":892},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":894,"_path":895},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":897,"_path":898},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":900,"_path":901},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":903,"_path":904},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":906,"_path":907},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":909,"_path":910},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":912,"_path":913},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":915,"_path":916},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":918,"_path":919},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":921,"_path":922},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":924,"_path":925},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":927,"_path":928},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":930,"_path":931},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":933,"_path":934},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":936,"_path":937},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":939,"_path":940},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":942,"_path":943},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":945,"_path":946},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":948,"_path":949},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":951,"_path":952},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":954,"_path":955},"rider的使用","/tool/2022-08-02-rider-use",{"title":957,"_path":958},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":960,"_path":961},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":963,"_path":964},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":966,"_path":967},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":969,"_path":970,"children":971},"Unity","/unity",[972,975,978,981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017,1020,1023,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053,1056,1059,1062,1065,1068,1071,1074,1077,1080,1083,1086,1089,1092,1095,1098,1101,1104,1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137,1140,1143,1146,1149,1152,1155,1158,1161,1164,1167,1170,1173,1176,1179,1182,1185],{"title":973,"_path":974},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":976,"_path":977},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":979,"_path":980},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":982,"_path":983},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":985,"_path":986},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":988,"_path":989},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":991,"_path":992},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":994,"_path":995},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":997,"_path":998},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1000,"_path":1001},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1003,"_path":1004},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1006,"_path":1007},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1009,"_path":1010},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1012,"_path":1013},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1015,"_path":1016},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1018,"_path":1019},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1021,"_path":1022},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1024,"_path":1025},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1027,"_path":1028},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1030,"_path":1031},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1033,"_path":1034},"技能系统","/unity/2020-02-15-skill-system",{"title":1036,"_path":1037},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1039,"_path":1040},"角色状态设计","/unity/2020-02-17-character-states",{"title":1042,"_path":1043},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1045,"_path":1046},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1048,"_path":1049},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1051,"_path":1052},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1054,"_path":1055},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1057,"_path":1058},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1060,"_path":1061},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1063,"_path":1064},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1066,"_path":1067},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1069,"_path":1070},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1072,"_path":1073},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1075,"_path":1076},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1078,"_path":1079},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1081,"_path":1082},"unity的addressables","/unity/2020-09-12-addressables",{"title":1084,"_path":1085},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1087,"_path":1088},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1090,"_path":1091},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1093,"_path":1094},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1096,"_path":1097},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1099,"_path":1100},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1102,"_path":1103},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1105,"_path":1106},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1108,"_path":1109},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1111,"_path":1112},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1114,"_path":1115},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1117,"_path":1118},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1120,"_path":1121},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1123,"_path":1124},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1126,"_path":1127},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1129,"_path":1130},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1132,"_path":1133},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1135,"_path":1136},"ability","/unity/2020-11-16-dotssample",{"title":1138,"_path":1139},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1141,"_path":1142},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1144,"_path":1145},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1147,"_path":1148},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1150,"_path":1151},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1153,"_path":1154},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1156,"_path":1157},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1159,"_path":1160},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1162,"_path":1163},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1165,"_path":1166},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1168,"_path":1169},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1171,"_path":1172},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1174,"_path":1175},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1177,"_path":1178},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1180,"_path":1181},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1183,"_path":1184},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1186,"_path":1187},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041524]