[{"data":1,"prerenderedAt":927},["Reactive",2],{"content-query-CPEGcJDD5w":3,"content-navigation-8C37fagqQL":345},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":339,"_id":340,"_source":341,"_file":342,"_extension":343,"date":344},"/dotnet/2020-02-02-net-sync-lag-compensation","dotnet",false,"","快节奏多人游戏同步(4)-延时补偿","PART 1 概述之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些：服务器从客户端收到带有时间戳的输入信息；服务器处理输入并且更新世界状态；服务器向所有客户端发送游戏世界的快照客户端发送输入并且模拟游戏的结果；客户端获取世界更新将自身预测的状态和服务器发送来的状态进行同步；将其他客户端控制的实体插值到过去的状态从玩家的角度来看，以上行为会导致两个重要的结果：玩家看到 自己 处于 现在玩家看到 其他玩家 处于 过去这其实并没有什么大不了的问题，但是对于时间和空间非常敏感的事件就会造成很大的问题；比如在射击游戏中爆掉敌人的头！PART 2 延时补偿假设你正",{"type":11,"children":12,"toc":330},"root",[13,22,28,71,76,112,117,123,128,133,138,143,148,153,176,181,186,191,196,201,206,211,217,222,227,233,238,243,254,263,273,285,294,303,312,321],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"part-1-概述",[19],{"type":20,"value":21},"text","PART 1 概述",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":27},"之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些：",{"type":14,"tag":29,"props":30,"children":31},"ul",{},[32,38,43,48,53],{"type":14,"tag":33,"props":34,"children":35},"li",{},[36],{"type":20,"value":37},"服务器从客户端收到带有时间戳的输入信息；",{"type":14,"tag":33,"props":39,"children":40},{},[41],{"type":20,"value":42},"服务器处理输入并且更新世界状态；",{"type":14,"tag":33,"props":44,"children":45},{},[46],{"type":20,"value":47},"服务器向所有客户端发送游戏世界的快照",{"type":14,"tag":33,"props":49,"children":50},{},[51],{"type":20,"value":52},"客户端发送输入并且模拟游戏的结果；",{"type":14,"tag":33,"props":54,"children":55},{},[56,58],{"type":20,"value":57},"客户端获取世界更新",{"type":14,"tag":29,"props":59,"children":60},{},[61,66],{"type":14,"tag":33,"props":62,"children":63},{},[64],{"type":20,"value":65},"将自身预测的状态和服务器发送来的状态进行同步；",{"type":14,"tag":33,"props":67,"children":68},{},[69],{"type":20,"value":70},"将其他客户端控制的实体插值到过去的状态",{"type":14,"tag":23,"props":72,"children":73},{},[74],{"type":20,"value":75},"从玩家的角度来看，以上行为会导致两个重要的结果：",{"type":14,"tag":29,"props":77,"children":78},{},[79,97],{"type":14,"tag":33,"props":80,"children":81},{},[82,84,90,92],{"type":20,"value":83},"玩家看到 ",{"type":14,"tag":85,"props":86,"children":87},"strong",{},[88],{"type":20,"value":89},"自己",{"type":20,"value":91}," 处于 ",{"type":14,"tag":85,"props":93,"children":94},{},[95],{"type":20,"value":96},"现在",{"type":14,"tag":33,"props":98,"children":99},{},[100,101,106,107],{"type":20,"value":83},{"type":14,"tag":85,"props":102,"children":103},{},[104],{"type":20,"value":105},"其他玩家",{"type":20,"value":91},{"type":14,"tag":85,"props":108,"children":109},{},[110],{"type":20,"value":111},"过去",{"type":14,"tag":23,"props":113,"children":114},{},[115],{"type":20,"value":116},"这其实并没有什么大不了的问题，但是对于时间和空间非常敏感的事件就会造成很大的问题；比如在射击游戏中爆掉敌人的头！",{"type":14,"tag":15,"props":118,"children":120},{"id":119},"part-2-延时补偿",[121],{"type":20,"value":122},"PART 2 延时补偿",{"type":14,"tag":23,"props":124,"children":125},{},[126],{"type":20,"value":127},"假设你正用狙击枪完美的瞄准目标的头部，此时射击绝对万无一失。",{"type":14,"tag":23,"props":129,"children":130},{},[131],{"type":20,"value":132},"然而却没打到。。。",{"type":14,"tag":23,"props":134,"children":135},{},[136],{"type":20,"value":137},"为什么会发生这种事情。。",{"type":14,"tag":23,"props":139,"children":140},{},[141],{"type":20,"value":142},"因为我们之前解释过的 client-server 架构，你瞄准的是 100ms 之前的玩家的头，而不是开枪的时候的玩家的头。。。",{"type":14,"tag":23,"props":144,"children":145},{},[146],{"type":20,"value":147},"在某种程度上相当于你在一个光速非常非常慢的宇宙中进行游戏，你瞄准的是敌人过去的位置，当你扣下扳机的时候他早就走远了。。",{"type":14,"tag":23,"props":149,"children":150},{},[151],{"type":20,"value":152},"比较幸运的是有一个相对简单的解决方案，对几乎所有的玩家都是友好的，下面来解释一下它的工作流程：",{"type":14,"tag":29,"props":154,"children":155},{},[156,161,166,171],{"type":14,"tag":33,"props":157,"children":158},{},[159],{"type":20,"value":160},"开火的时候，客户端发送开火指令到服务器，同时包含开火的一瞬间确切的时间和方向。",{"type":14,"tag":33,"props":162,"children":163},{},[164],{"type":20,"value":165},"这是关键的一步。由于服务器获取所有带有时间戳的输入，因此它可以在过去的任何时刻重构世界。特别是，它可以在任何时间点按照任何客户端眼中的样子重建世界。",{"type":14,"tag":33,"props":167,"children":168},{},[169],{"type":20,"value":170},"这意味着服务器可以准确地知道你开枪的那一刻你的武器瞄准了什么。这是你的敌人过去的头部位置，但服务器知道这是他的头部在你当前客户端所在的位置。",{"type":14,"tag":33,"props":172,"children":173},{},[174],{"type":20,"value":175},"服务器在该时间点处理快照，并更新客户端。",{"type":14,"tag":23,"props":177,"children":178},{},[179],{"type":20,"value":180},"于是皆大欢喜～",{"type":14,"tag":23,"props":182,"children":183},{},[184],{"type":20,"value":185},"服务器很开心是因为他是服务器，他永远都很开心。。。哦好冷啊",{"type":14,"tag":23,"props":187,"children":188},{},[189],{"type":20,"value":190},"你很开心是因为你瞄准目标头部并射击，完成了一记漂亮的爆头",{"type":14,"tag":23,"props":192,"children":193},{},[194],{"type":20,"value":195},"你的敌人可能是唯一不完全开心的哪个，如果他站在原地被你爆头那就是他的问题，但是如果他在移动的话，只能说明你是特别厉害的狙击手。",{"type":14,"tag":23,"props":197,"children":198},{},[199],{"type":20,"value":200},"但是如果他在掩体附近，然后移动到掩体内部的安全位置后才被命中了呢？",{"type":14,"tag":23,"props":202,"children":203},{},[204],{"type":20,"value":205},"好吧这的确有可能发生，但这就是你要为此付出的代价，因为你可以射击「过去的他」，他可能在进入掩体后几毫秒被射击。",{"type":14,"tag":23,"props":207,"children":208},{},[209],{"type":20,"value":210},"从某种程度上来说这是不公平的，但这是大家接受程度最高的解决方案了，明明瞄准开枪最后却 miss 问题更大～",{"type":14,"tag":15,"props":212,"children":214},{"id":213},"part-3-总结",[215],{"type":20,"value":216},"PART 3 总结",{"type":14,"tag":23,"props":218,"children":219},{},[220],{"type":20,"value":221},"这篇文章是快节奏多人游戏同步这个系列的最后一篇了，虽然这类问题很难得到完美解答，但是对相关概念有了清晰理解以后再看也并不是那么困难。",{"type":14,"tag":23,"props":223,"children":224},{},[225],{"type":20,"value":226},"虽然本文的读者都是游戏开发者，但依然有着另一部分读者对此很感兴趣，那就是玩家们。对玩家来说去理解诸如此类问题依然是一件很有趣的事情。",{"type":14,"tag":228,"props":229,"children":231},"h3",{"id":230},"扩展阅读",[232],{"type":20,"value":230},{"type":14,"tag":23,"props":234,"children":235},{},[236],{"type":20,"value":237},"以下是一些参考资料包括文章和源码之类的，可以帮助大家更方便的理解相关概念。",{"type":14,"tag":23,"props":239,"children":240},{},[241],{"type":20,"value":242},"与本文相关性最高的文章如下",{"type":14,"tag":23,"props":244,"children":245},{},[246],{"type":14,"tag":247,"props":248,"children":252},"a",{"href":249,"rel":250},"http://www.gabrielgambetta.com/lag-compensation.html",[251],"nofollow",[253],{"type":20,"value":249},{"type":14,"tag":23,"props":255,"children":256},{},[257],{"type":14,"tag":247,"props":258,"children":261},{"href":259,"rel":260},"http://www.gabrielgambetta.com/client-side-prediction-live-demo.html",[251],[262],{"type":20,"value":259},{"type":14,"tag":23,"props":264,"children":265},{},[266],{"type":14,"tag":247,"props":267,"children":270},{"href":268,"rel":269},"http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/",[251],[271],{"type":20,"value":272},"What Every Programmer Needs to Know About Game Networking",{"type":14,"tag":23,"props":274,"children":275},{},[276,283],{"type":14,"tag":247,"props":277,"children":280},{"href":278,"rel":279},"https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization",[251],[281],{"type":20,"value":282},"Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization",{"type":20,"value":284},".",{"type":14,"tag":23,"props":286,"children":287},{},[288],{"type":14,"tag":247,"props":289,"children":292},{"href":290,"rel":291},"https://link.springer.com/article/10.1007/s00530-012-0271-3#Sec17",[251],[293],{"type":20,"value":290},{"type":14,"tag":23,"props":295,"children":296},{},[297],{"type":14,"tag":247,"props":298,"children":301},{"href":299,"rel":300},"https://github.com/search?l=C%23&q=lag+compensation&type=Repositories",[251],[302],{"type":20,"value":299},{"type":14,"tag":23,"props":304,"children":305},{},[306],{"type":14,"tag":247,"props":307,"children":310},{"href":308,"rel":309},"https://github.com/search?l=C%23&p=1&q=Fast-Paced+Multiplayer&type=Repositories",[251],[311],{"type":20,"value":308},{"type":14,"tag":23,"props":313,"children":314},{},[315],{"type":14,"tag":247,"props":316,"children":319},{"href":317,"rel":318},"https://github.com/JoaoBorks/unity-fastpacedmultiplayer",[251],[320],{"type":20,"value":317},{"type":14,"tag":23,"props":322,"children":323},{},[324],{"type":14,"tag":247,"props":325,"children":328},{"href":326,"rel":327},"https://github.com/gamestdio/timeline",[251],[329],{"type":20,"value":326},{"title":7,"searchDepth":331,"depth":331,"links":332},2,[333,334,335],{"id":17,"depth":331,"text":21},{"id":119,"depth":331,"text":122},{"id":213,"depth":331,"text":216,"children":336},[337],{"id":230,"depth":338,"text":230},3,"markdown","content:dotnet:2020-02-02-net-sync-lag-compensation.md","content","dotnet/2020-02-02-net-sync-lag-compensation.md","md","2020-02-02",[346,356,481,530,582,595,707],{"title":347,"_path":348,"children":349},"Art","/art",[350,353],{"title":351,"_path":352},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":354,"_path":355},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":357,"_path":358,"children":359},"Dotnet","/dotnet",[360,363,366,369,372,375,378,381,384,387,390,393,396,399,402,403,406,409,412,415,418,421,424,427,430,433,436,439,442,445,448,451,454,457,460,463,466,469,472,475,478],{"title":361,"_path":362},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":364,"_path":365},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":367,"_path":368},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":370,"_path":371},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":373,"_path":374},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":376,"_path":377},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":379,"_path":380},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":382,"_path":383},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":385,"_path":386},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":388,"_path":389},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":391,"_path":392},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":394,"_path":395},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":397,"_path":398},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":400,"_path":401},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":8,"_path":4},{"title":404,"_path":405},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":407,"_path":408},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":410,"_path":411},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":413,"_path":414},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":416,"_path":417},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":419,"_path":420},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":422,"_path":423},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":425,"_path":426},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":428,"_path":429},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":431,"_path":432},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":434,"_path":435},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":437,"_path":438},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":440,"_path":441},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":443,"_path":444},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":446,"_path":447},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":449,"_path":450},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":452,"_path":453},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":455,"_path":456},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":458,"_path":459},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":461,"_path":462},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":464,"_path":465},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":467,"_path":468},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":470,"_path":471},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":473,"_path":474},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":476,"_path":477},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":479,"_path":480},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":482,"_path":483,"children":484},"Game","/game",[485,488,491,494,497,500,503,506,509,512,515,518,521,524,527],{"title":486,"_path":487},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":489,"_path":490},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":492,"_path":493},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":495,"_path":496},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":498,"_path":499},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":501,"_path":502},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":504,"_path":505},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":507,"_path":508},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":510,"_path":511},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":513,"_path":514},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":516,"_path":517},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":519,"_path":520},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":522,"_path":523},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":525,"_path":526},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":528,"_path":529},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":531,"_path":532,"children":533},"Gyj","/gyj",[534,537,540,543,546,549,552,555,558,561,564,567,570,573,576,579],{"title":535,"_path":536},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":538,"_path":539},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":541,"_path":542},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":544,"_path":545},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":547,"_path":548},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":550,"_path":551},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":553,"_path":554},"玩法","/gyj/2022-08-22-wanfa",{"title":556,"_path":557},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":559,"_path":560},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":562,"_path":563},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":565,"_path":566},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":568,"_path":569},"门派内容相关","/gyj/2022-11-17-sect",{"title":571,"_path":572},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":574,"_path":575},"种植","/gyj/2022-12-01-zhongzhi",{"title":577,"_path":578},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":580,"_path":581},"跑商","/gyj/2023-11-01-paoshang",{"title":583,"_path":584,"children":585},"Js","/js",[586,589,592],{"title":587,"_path":588},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":590,"_path":591},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":593,"_path":594},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":596,"_path":597,"children":598},"Tool","/tool",[599,602,605,608,611,614,617,620,623,626,629,632,635,638,641,644,647,650,653,656,659,662,665,668,671,674,677,680,683,686,689,692,695,698,701,704],{"title":600,"_path":601},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":603,"_path":604},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":606,"_path":607},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":609,"_path":610},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":612,"_path":613},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":615,"_path":616},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":618,"_path":619},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":621,"_path":622},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":624,"_path":625},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":627,"_path":628},"mac下brew 使用","/tool/2020-01-13-brew",{"title":630,"_path":631},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":633,"_path":634},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":636,"_path":637},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":639,"_path":640},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":642,"_path":643},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":645,"_path":646},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":648,"_path":649},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":651,"_path":652},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":654,"_path":655},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":657,"_path":658},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":660,"_path":661},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":663,"_path":664},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":666,"_path":667},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":669,"_path":670},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":672,"_path":673},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":675,"_path":676},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":678,"_path":679},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":681,"_path":682},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":684,"_path":685},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":687,"_path":688},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":690,"_path":691},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":693,"_path":694},"rider的使用","/tool/2022-08-02-rider-use",{"title":696,"_path":697},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":699,"_path":700},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":702,"_path":703},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":705,"_path":706},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":708,"_path":709,"children":710},"Unity","/unity",[711,714,717,720,723,726,729,732,735,738,741,744,747,750,753,756,759,762,765,768,771,774,777,780,783,786,789,792,795,798,801,804,807,810,813,816,819,822,825,828,831,834,837,840,843,846,849,852,855,858,861,864,867,870,873,876,879,882,885,888,891,894,897,900,903,906,909,912,915,918,921,924],{"title":712,"_path":713},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":715,"_path":716},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":718,"_path":719},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":721,"_path":722},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":724,"_path":725},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":727,"_path":728},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":730,"_path":731},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":733,"_path":734},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":736,"_path":737},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":739,"_path":740},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":742,"_path":743},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":745,"_path":746},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":748,"_path":749},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":751,"_path":752},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":754,"_path":755},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":757,"_path":758},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":760,"_path":761},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":763,"_path":764},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":766,"_path":767},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":769,"_path":770},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":772,"_path":773},"技能系统","/unity/2020-02-15-skill-system",{"title":775,"_path":776},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":778,"_path":779},"角色状态设计","/unity/2020-02-17-character-states",{"title":781,"_path":782},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":784,"_path":785},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":787,"_path":788},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":790,"_path":791},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":793,"_path":794},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":796,"_path":797},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":799,"_path":800},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":802,"_path":803},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":805,"_path":806},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":808,"_path":809},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":811,"_path":812},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":814,"_path":815},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":817,"_path":818},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":820,"_path":821},"unity的addressables","/unity/2020-09-12-addressables",{"title":823,"_path":824},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":826,"_path":827},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":829,"_path":830},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":832,"_path":833},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":835,"_path":836},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":838,"_path":839},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":841,"_path":842},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":844,"_path":845},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":847,"_path":848},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":850,"_path":851},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":853,"_path":854},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":856,"_path":857},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":859,"_path":860},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":862,"_path":863},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":865,"_path":866},"简单保存工具","/unity/2020-11-13-simple-save",{"title":868,"_path":869},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":871,"_path":872},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":874,"_path":875},"ability","/unity/2020-11-16-dotssample",{"title":877,"_path":878},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":880,"_path":881},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":883,"_path":884},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":886,"_path":887},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":889,"_path":890},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":892,"_path":893},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":895,"_path":896},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":898,"_path":899},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":901,"_path":902},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":904,"_path":905},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":907,"_path":908},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":910,"_path":911},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":913,"_path":914},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":916,"_path":917},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":919,"_path":920},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":922,"_path":923},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":925,"_path":926},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041042]