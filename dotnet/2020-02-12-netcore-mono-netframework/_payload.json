[{"data":1,"prerenderedAt":973},["Reactive",2],{"content-query-u3unC0t7Lt":3,"content-navigation-8C37fagqQL":391},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":385,"_id":386,"_source":387,"_file":388,"_extension":389,"date":390},"/dotnet/2020-02-12-netcore-mono-netframework","dotnet",false,"","扒一扒.net、.net framework、mono和Unity","1.什么是CLR？CLR（Common Language Runtime）即公共语言运行时，是一个由多种编程语言使用的“运行时”，我的理解是就是运行环境，类似于jvm虚拟机的东西，只不过CLR并不关心你用的语言是什么，无论你用的是C#，或者C++等，当通过编译器编译后，都会转换为CLR可以识别的中间语言IL2.CLR的工作方式CLR是不和模块工作的，它和程序集工作，如下当加载了公共语言运行时时，电脑必须安装了.NET Framework,同时CLR会检测目标平台，如32位Windows，或64位windows，然后决定创建对应的进程；如图1-2，托管程序集同时包含元数据和IL，当编译器把源代码",{"type":11,"children":12,"toc":382},"root",[13,21,26,31,36,44,49,54,61,66,71,76,81,86,91,96,101,112,117,122,127,140,151,158,163,168,175,180,185,194,199,206,211,218,223,228,233,238,243,248,253,258,263,268,275,280,289,294,303,308,317,322,335,340,345,354,359],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":20},"text","1.什么是CLR？",{"type":14,"tag":15,"props":22,"children":23},{},[24],{"type":19,"value":25},"CLR（Common Language Runtime）即公共语言运行时，是一个由多种编程语言使用的“运行时”，我的理解是就是运行环境，类似于jvm虚拟机的东西，只不过CLR并不关心你用的语言是什么，无论你用的是C#，或者C++等，当通过编译器编译后，都会转换为CLR可以识别的中间语言IL",{"type":14,"tag":15,"props":27,"children":28},{},[29],{"type":19,"value":30},"2.CLR的工作方式",{"type":14,"tag":15,"props":32,"children":33},{},[34],{"type":19,"value":35},"CLR是不和模块工作的，它和程序集工作，如下",{"type":14,"tag":15,"props":37,"children":38},{},[39],{"type":14,"tag":40,"props":41,"children":43},"img",{"alt":40,"src":42},"/images/2020-02-12-netcore-mono-netframework/v2-5efca0f8c5f31440e6d17c766a6cc6b6_1440w.jpg",[],{"type":14,"tag":15,"props":45,"children":46},{},[47],{"type":19,"value":48},"当加载了公共语言运行时时，电脑必须安装了.NET Framework,同时CLR会检测目标平台，如32位Windows，或64位windows，然后决定创建对应的进程；",{"type":14,"tag":15,"props":50,"children":51},{},[52],{"type":19,"value":53},"如图1-2，托管程序集同时包含元数据和IL，当编译器把源代码转换为中间语言IL后，为了执行方法，CLR会把方法的IL转换为本机（native）CPU指令，即JIT（just in time“即时”）编译",{"type":14,"tag":15,"props":55,"children":56},{},[57],{"type":14,"tag":40,"props":58,"children":60},{"alt":40,"src":59},"/images/2020-02-12-netcore-mono-netframework/v2-e12d13ed3e967c0b7463fb2764034d87_1440w.jpg",[],{"type":14,"tag":15,"props":62,"children":63},{},[64],{"type":19,"value":65},"在方法执行前，CLR会检测代码引用的所有类型，然后分配一个内部数据结构来管理引用访问，在这个数据结构中每个方法会有一个对应的记录项，每个记录项都包含地址，根据地址找到函数的实现，CLR将每个记录项都设置成（指向）一个内部的未编档函数，即JITCompiler当方法首次调用WriteLine时，JITCompiler会被调用，将方法的IL代码编译为本机的CPU指令。当方法第一次被调用时，JIT编译器会验证IL代码，当第二次时，由于第一次已经完成了验证和编译，所以第二次会直接执行。",{"type":14,"tag":15,"props":67,"children":68},{},[69],{"type":19,"value":70},"1.Mono",{"type":14,"tag":15,"props":72,"children":73},{},[74],{"type":19,"value":75},"mono即基于.NET Framework 的开源实现，基于C#的ECMA标准，包含C#编译器和CLR。mono使C#拥有了跨平台的能力。",{"type":14,"tag":15,"props":77,"children":78},{},[79],{"type":19,"value":80},"2.为什么Mono能跨平台？",{"type":14,"tag":15,"props":82,"children":83},{},[84],{"type":19,"value":85},"因为它使用了CIL（Common Intermediate Language）的通用中间语言，也叫MSIL的指令集，CIL可以在任何支持CLI（Common Language Infrastructure）“通用语言基础结构”的环境下运行，由于CIL能运行在所有支持CLI的环境中，比如.net运行时或者mono运行时，也就是说和具体的平台或者CPU无关。",{"type":14,"tag":15,"props":87,"children":88},{},[89],{"type":19,"value":90},".net从一个抽象上来说其实是一个理念，即使得多种语言编写的程序能够通过一个通用的runtime运行在不同的操作系统以及硬件平台上。但光有理念不行，还需要实现，我们这里把对于.net里面的某个实现叫做.net platform（比如.net framework就是一个在windows上实现的.net platform，mono则是一个跨平台的.net platform）。一个.net platform想要达成.net的目标，就需要一些组件，比如上图中CLR通用语言运行时，比如FCL基础类库，比如各种语言的编译器，编译器编译出来的东西想要能在CLR中运行，那也需要遵循一定的标准，这就是CLI和CIL，CIL规定了编译输出的规则，而CLI规定了编译器输入语言的规则，只有符合这种标准的语言才能编译成CIL语言运行在CLR中。",{"type":14,"tag":15,"props":92,"children":93},{},[94],{"type":19,"value":95},"好了现在有了CIL和CLR，程序员可以用符合CLI的语言比如C#编写程序了，然后将其编译成CIL，最后在CLR中运行。但是问题来了，程序员开发程序的时候需要用到一些功能以及数据结构，不可能所有的功能细节都自己实现，不然开发成本也太高了，所以就需要提供一些基础类库，方便程序员进行开发，那么需要提供哪些基础类库呢？这也需要一个标准，而.Net Standard就是用于这个目的，它规定了某个.net platform需要提供哪些API给开发者。这样的话加入一个开发者在.net platform A（比如.net framework）上开发了一个项目，然后想迁移到.net platform B（比如Mono）上，那么只要两个platform实现了同一个.net standard那么源代码就无需修改可以直接编译运行。",{"type":14,"tag":15,"props":97,"children":98},{},[99],{"type":19,"value":100},"不过还有一个问题，假如我有一台机器，装了.net platform A（比如.net framework）和.net platform B（比如Mono），那么我在A上编译出来的一个.net程序放到B上可以运行么？理论上应该没问题，毕竟CIL是统一的，虽然一个是A的CLR一个是B的CLR，但是它们都是用来处理CIL程序，就像java代码编译出来既可以运行在JVM上也可以运行在delvik上一样。然而实际上不一定，因为CIL本身也不是一成不变的，它也有自己的版本，看下面这个文档：",{"type":14,"tag":15,"props":102,"children":103},{},[104],{"type":14,"tag":105,"props":106,"children":110},"a",{"href":107,"rel":108},"https://msdn.microsoft.com/en-us/library/bb822049.aspx",[109],"nofollow",[111],{"type":19,"value":107},{"type":14,"tag":15,"props":113,"children":114},{},[115],{"type":19,"value":116},"里面的表格详细说明了.net framework和CLR版本之间的关系，从.net framework 2.0到3.5使用的是CLR 2.0，.net framework 4.0以后使用的是CLR 4.0，中间没有CLR 3.0版本。这也就意味着CIL语言本身也在发生变化，面向CLR 4.0编译出来的程序自然是不能运行在CLR 2.0上的。",{"type":14,"tag":15,"props":118,"children":119},{},[120],{"type":19,"value":121},"说那到底什么是.net framework呢？个人理解从抽象角度说.net framework是对.net标准（这个标准具体包括CLI，CIL，.net standard等）在windows平台上的一套实现，具体上说.net framework包含一整套解决方案，包含许多字组件，比如编译器、CLR、FCL等等，其中每个组件都有自己的版本，比如编译器有自己的版本用于适应不同版本的语言，比如.net framework 3.5的编译器只支持到C# 3.0，最新已经到C# 7.0了；每个版本的.net framework提供的FCL也在不断丰富，比如System.LINQ到.net framework 3.5才有；CLR的版本也会不同，之前已经说过了。因此.net framework的版本其实就是其组件版本的一个集合，高版本的.net framework中的每个子组件都进行了一定的版本更新。",{"type":14,"tag":15,"props":123,"children":124},{},[125],{"type":19,"value":126},"其实正常来说.net framework只是对.net标准的一套实现而已，其他的对于.net标准的实现完全可以将各种不同版本的组件组合起来用，比如我一套.net platform提供了.net framework 4.0的FCL和面向C# 6.0的编译器，但用的是CLR 2.0的运行时，这并没有什么问题，只要编译器和运行时匹配就行了（mono就是这么干的）。但是由于.net是微软提出来的而且.net framework是微软开发的，那别的.net platform实现自然就已.net framework为标杆，每个版本的.net framework都提供了一些新的features，支持.net framework x.x就是说这个.net platform实现了x.x版本.net framework的特性，比如下面是mono主页上的文档：",{"type":14,"tag":15,"props":128,"children":129},{},[130,134,136],{"type":14,"tag":40,"props":131,"children":133},{"alt":40,"src":132},"/images/2020-02-12-netcore-mono-netframework/20170423144055880.png",[],{"type":19,"value":135}," ",{"type":14,"tag":40,"props":137,"children":139},{"alt":40,"src":138},"/images/2020-02-12-netcore-mono-netframework/20170423144129490.png",[],{"type":14,"tag":15,"props":141,"children":142},{},[143,145],{"type":19,"value":144},"可以看到上面说的是.net 4.6 4.5，这里表示的其实是.net framework，这个图片的意思就是最新版本的mono已经实现了.net framework 4.6中支持C# 6的特性，以及此外还可以发现只有.net 3.5和2.0是mono完全实现了其所有特性。准确的说其实是mono实现了.net framework的大部分feature，并且还提供了一些mono自己的class library。Mono和.net framework大致有一个对应关系，如这篇文章所说：",{"type":14,"tag":105,"props":146,"children":149},{"href":147,"rel":148},"http://www.cnblogs.com/zhaoqingqing/archive/2016/08/12/5762867.html",[109],[150],{"type":19,"value":147},{"type":14,"tag":15,"props":152,"children":153},{},[154],{"type":14,"tag":40,"props":155,"children":157},{"alt":40,"src":156},"/images/2020-02-12-netcore-mono-netframework/20170423144146834.png",[],{"type":14,"tag":15,"props":159,"children":160},{},[161],{"type":19,"value":162},"这个表似乎不完全正确，mono 2.0实现了System.LinQ组件，这个组件在.net 3.5中提供，所以mono 2.0对应的应该是.net 2.0/3.5，即两者之和。不过还是可以当做一个参考。所以说加入一个程序集是用.net framework 3.5构建的，引用了一些dll如system.core以及system.linq，那么要想把其导入mono项目中，就必须保证mono的版本高于2.0，不然会找不到相应的引用。",{"type":14,"tag":15,"props":164,"children":165},{},[166],{"type":19,"value":167},"还有一点需要注意，网上很多讲.net版本的时候讲.net framework version和CLR version混为一谈，有些时候说的.net 2.0指的其实是CLR 2.0。另外有些人把System.Environment.Version误以为是.ne framework版本，其实不是，msdn上说的很明确，这个值指的是CLR的版本：",{"type":14,"tag":15,"props":169,"children":170},{},[171],{"type":14,"tag":40,"props":172,"children":174},{"alt":40,"src":173},"/images/2020-02-12-netcore-mono-netframework/20170423144202709.png",[],{"type":14,"tag":15,"props":176,"children":177},{},[178],{"type":19,"value":179},"另外还有一点值得注意，在vs中构建一个.net framework 3.5的项目时是，引用的System.dll是在系统的.net v2.0目录下的，也就是说.net framework不是独立的，而是依赖于.net framework 2.0.不过.net 4.0以后的版本好像就不是这样了，每次新版本都是独立的。",{"type":14,"tag":15,"props":181,"children":182},{},[183],{"type":19,"value":184},"最后谈一下Unity，Unity为了跨平台使用了Mono，其使用的Mono版本可以通过代码或者命令行方式获得，unity forum上已经有牛人说明了：",{"type":14,"tag":15,"props":186,"children":187},{},[188],{"type":14,"tag":105,"props":189,"children":192},{"href":190,"rel":191},"http://answers.unity3d.com/questions/259448/how-to-determine-mono-version-of-unity-.html",[109],[193],{"type":19,"value":190},{"type":14,"tag":15,"props":195,"children":196},{},[197],{"type":19,"value":198},"我自己的测试结果是mono 2.0",{"type":14,"tag":15,"props":200,"children":201},{},[202],{"type":14,"tag":40,"props":203,"children":205},{"alt":40,"src":204},"/images/2020-02-12-netcore-mono-netframework/20170423144215834.png",[],{"type":14,"tag":15,"props":207,"children":208},{},[209],{"type":19,"value":210},"查了一下mono官网，mono 2.0是08年的老古董（Unity居然还在用，貌似是版权问题，没有深究），而用vs打开一下Unity中的脚本，查看一下项目构建文件.csproj：",{"type":14,"tag":15,"props":212,"children":213},{},[214],{"type":14,"tag":40,"props":215,"children":217},{"alt":40,"src":216},"/images/2020-02-12-netcore-mono-netframework/20170423144232772.png",[],{"type":14,"tag":15,"props":219,"children":220},{},[221],{"type":19,"value":222},"可以看到Unity用的是.net 3.5，所以难道Unity的脚本是用.net framework 3.5构建的？显然不是。",{"type":14,"tag":15,"props":224,"children":225},{},[226],{"type":19,"value":227},"我们知道vs有一个东西叫VSTU，它最大的作用就是可以用vs的断点调试功能调试Unity Editor。Unity中的脚本在vs中打开的时候会构建一个VSTU项目。VSTU项目虽然跟普通VS项目看上去很像，但其实VSTU项目本质上并不是真正的vs项目，如果你右键项目->属性是没有反应的（VSTU 2.1以前有反应，之后就禁用了），而且右键项目中的引用也不会有添加引用选项，其实VSTU是把vs当做了一个功能强大的编辑器。",{"type":14,"tag":15,"props":229,"children":230},{},[231],{"type":19,"value":232},"但VSTU不只是利用了VS进行语法检查这么简单，它的另一个作用就是断点调试。在没有断点调试的情况下，Unity使用自己的编译器进行编译，生成Assembly-CSharp.dll（在/Library/目录中），点击Play按钮的时候用的是这个dll，而用VS进行断点调试的时候则会用VS的编译器编译出Assembly-CSharp.dll以及pdb文件，在\\Temp\\UnityVS_obj\\Debug\\目录中，此时点击Play用的就是这个dll。当然build出exe的时候用的还是自己的编译器。",{"type":14,"tag":15,"props":234,"children":235},{},[236],{"type":19,"value":237},"VSTU对项目进行了限制，不能直接在VS中添加新的dll，但可以拷贝到Unity项目的Asset目录下，这样Unity会重新构建VSTU项目，把拷进去的dll显示在引用列表里面。",{"type":14,"tag":15,"props":239,"children":240},{},[241],{"type":19,"value":242},"VSTU构建的项目是基于.net framework 3.5的。因为Unity用的是mono 2.0啊，mono 2.0实现的feature包括.net framework 2.0和3.5，而UnityEngine.dll引用了System.Core.dll，而这个dll在.net framework 3.5才有，如果是是基于.net framework 2.0构建，那么第一有些mono 2.0支持的feature在vs里面就会找不到，另外也无法断点调试，因为编译通不过。",{"type":14,"tag":15,"props":244,"children":245},{},[246],{"type":19,"value":247},"其实也可以在Unity的安装目录中寻找一些端倪，在windows下为：",{"type":14,"tag":15,"props":249,"children":250},{},[251],{"type":19,"value":252},"C:\\Program Files\\Unity\\Editor\\Data\\Mono\\lib\\mono\\2.0",{"type":14,"tag":15,"props":254,"children":255},{},[256],{"type":19,"value":257},"这个目录2.0目测就是mono的版本，目录中有很多dll，比如System.*.dll，这说明unity自带了mono项目，提供了mono 2.0中实现的基础类库。虽然Unity的脚本可以在像VS以及MonoDeveloper中打开，但是在build的时候用的还是Unity自带的Mono中的编译器，而Mono 2.0仅支持到C# 3.0，所以有些最新的语法在Unity里面是无法编译通过的（Unity 5.3.5 p8提供了一个新的编译器mono 4.4用于测试，但是似乎没有下文了）。",{"type":14,"tag":15,"props":259,"children":260},{},[261],{"type":19,"value":262},"总结一下就是，Unity使用的是mono 2.0，支持C# 3.0，提供与.net framework 3.5/2.0 API兼容的类库（mono 2.0实现了.net framework 2.0 + 3.5的feature，但是没有实现.net framework 3.0的WPF的feature，所以官网的说法是**.Net 2.0/3.5 framework profile**），使用了与CLR 2.0兼容的mono runtime，因此用vs构建Unity的dll需要.net framework 3.5以下，不然runtime不兼容；如果要用到UnityEngine等Unity的功能必须用.net framework 3.5这个版本，不然vs项目找不到System.Core.dll，无法通过编译，如果只是一些工具类，不需要引用UnityEngine.dll，那么用.net framework 2.0构建是可以的。vs只是一个第三方构建工具，想要构建出Unity能用的dll就不能使用Unity（Mono 2.0）不支持的feature。",{"type":14,"tag":15,"props":264,"children":265},{},[266],{"type":19,"value":267},"最后有一点之前一直在困扰我，但今天稍微有点想通了，就是Unity的Player Setting里面有个API compability Level：",{"type":14,"tag":15,"props":269,"children":270},{},[271],{"type":14,"tag":40,"props":272,"children":274},{"alt":40,"src":273},"/images/2020-02-12-netcore-mono-netframework/20170423144252210.png",[],{"type":14,"tag":15,"props":276,"children":277},{},[278],{"type":19,"value":279},"这个只有两个选项：.Net 2.0和.Net 2.0 Subnet，这个说实话让人很不解，从字面上讲是指API兼容，那兼容到.net 2.0难道是指兼容.net framework 2.0的FCL API？但Unity可以用到.net framework 3.5的一些库啊。网上找了一通以后发现了如下网址：",{"type":14,"tag":15,"props":281,"children":282},{},[283],{"type":14,"tag":105,"props":284,"children":287},{"href":285,"rel":286},"https://docs.unity3d.com/412/Documentation/ScriptReference/MonoCompatibility.html",[109],[288],{"type":19,"value":285},{"type":14,"tag":15,"props":290,"children":291},{},[292],{"type":19,"value":293},"以及这个Question：",{"type":14,"tag":15,"props":295,"children":296},{},[297],{"type":14,"tag":105,"props":298,"children":301},{"href":299,"rel":300},"https://forum.unity3d.com/threads/unity-supports-c-3-5-or-2-0.111440/",[109],[302],{"type":19,"value":299},{"type":14,"tag":15,"props":304,"children":305},{},[306],{"type":19,"value":307},"其中有一句话很关键：",{"type":14,"tag":15,"props":309,"children":310},{},[311],{"type":14,"tag":312,"props":313,"children":314},"strong",{},[315],{"type":19,"value":316},"The 2.0 there is likely a good reflection of what you have at least",{"type":14,"tag":15,"props":318,"children":319},{},[320],{"type":19,"value":321},"所以梳理一下就是.Net 2.0和.Net 2.0 Subnet是指编写的C#代码能够引用的函数集合的不同，如果选择了subset那么dll就不会被导入到项目中来。比如同一个项目用.Net 2.0和.Net 2.0 Subnet构建出来的目录如下，可以很明显看到两者的差别。",{"type":14,"tag":15,"props":323,"children":324},{},[325,329,331],{"type":14,"tag":40,"props":326,"children":328},{"alt":40,"src":327},"/images/2020-02-12-netcore-mono-netframework/20170423144306179.png",[],{"type":19,"value":330},"  ",{"type":14,"tag":40,"props":332,"children":334},{"alt":40,"src":333},"/images/2020-02-12-netcore-mono-netframework/20170423144321069.png",[],{"type":14,"tag":15,"props":336,"children":337},{},[338],{"type":19,"value":339},"当新建一个Unity项目时，只会有一些核心的dll会被导入到项目中，其他的dll需要从外部拷贝到项目的Asset文件夹下，VSTU项目中是不能直接添加引用的，个人感觉VSTU对项目的限制有点多，像是把开发者当成傻子，因为你在用Unity那么这些功能就给你禁用掉，不过目测可以通过修改.sln或者.csproj文件来实现一些特殊需要。那.net framework 3.5呢？其实Unity支持的是.net framework 2.0 + 3.5，跳过了3.0，因为3.0是WPF的，Unity不需要，.net 2.0指的是你至少可以用哪些feature。",{"type":14,"tag":15,"props":341,"children":342},{},[343],{"type":19,"value":344},"Unity最近因为加入了.Net基金会，出了几个用最新mono的测试版：",{"type":14,"tag":15,"props":346,"children":347},{},[348],{"type":14,"tag":105,"props":349,"children":352},{"href":350,"rel":351},"https://forum.unity3d.com/threads/upgraded-mono-net-in-editor-on-5-5-0b4.433541/",[109],[353],{"type":19,"value":350},{"type":14,"tag":15,"props":355,"children":356},{},[357],{"type":19,"value":358},"Unity 5.5.0 b4里面API compability Level增加了一个4.6选项，其实是把原来的mono 2.0换成mono 4.6进行测试，mono 4.6支持C# 6.0，并且开发者可以使用.net 4.6的API写程序，然而也不知道什么时候能有稳定版。而且mono都快要被淘汰了，以后目测都是IL2CPP了。",{"type":14,"tag":360,"props":361,"children":362},"ul",{},[363,373],{"type":14,"tag":364,"props":365,"children":366},"li",{},[367],{"type":14,"tag":105,"props":368,"children":371},{"href":369,"rel":370},"https://www.cnblogs.com/w-wfy/p/7450167.html",[109],[372],{"type":19,"value":369},{"type":14,"tag":364,"props":374,"children":375},{},[376],{"type":14,"tag":105,"props":377,"children":380},{"href":378,"rel":379},"https://blog.csdn.net/wzjssssssssss/article/details/80196314",[109],[381],{"type":19,"value":378},{"title":7,"searchDepth":383,"depth":383,"links":384},2,[],"markdown","content:dotnet:2020-02-12-netcore-mono-netframework.md","content","dotnet/2020-02-12-netcore-mono-netframework.md","md","2020-02-12",[392,402,527,576,628,641,753],{"title":393,"_path":394,"children":395},"Art","/art",[396,399],{"title":397,"_path":398},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":400,"_path":401},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":403,"_path":404,"children":405},"Dotnet","/dotnet",[406,409,412,415,418,421,424,427,430,433,436,439,442,445,448,451,454,457,460,463,466,469,472,475,476,479,482,485,488,491,494,497,500,503,506,509,512,515,518,521,524],{"title":407,"_path":408},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":410,"_path":411},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":413,"_path":414},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":416,"_path":417},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":419,"_path":420},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":422,"_path":423},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":425,"_path":426},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":428,"_path":429},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":431,"_path":432},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":434,"_path":435},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":437,"_path":438},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":440,"_path":441},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":443,"_path":444},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":446,"_path":447},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":449,"_path":450},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":452,"_path":453},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":455,"_path":456},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":458,"_path":459},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":461,"_path":462},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":464,"_path":465},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":467,"_path":468},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":470,"_path":471},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":473,"_path":474},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":8,"_path":4},{"title":477,"_path":478},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":480,"_path":481},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":483,"_path":484},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":486,"_path":487},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":489,"_path":490},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":492,"_path":493},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":495,"_path":496},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":498,"_path":499},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":501,"_path":502},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":504,"_path":505},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":507,"_path":508},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":510,"_path":511},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":513,"_path":514},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":516,"_path":517},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":519,"_path":520},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":522,"_path":523},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":525,"_path":526},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":528,"_path":529,"children":530},"Game","/game",[531,534,537,540,543,546,549,552,555,558,561,564,567,570,573],{"title":532,"_path":533},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":535,"_path":536},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":538,"_path":539},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":541,"_path":542},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":544,"_path":545},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":547,"_path":548},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":550,"_path":551},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":553,"_path":554},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":556,"_path":557},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":559,"_path":560},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":562,"_path":563},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":565,"_path":566},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":568,"_path":569},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":571,"_path":572},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":574,"_path":575},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":577,"_path":578,"children":579},"Gyj","/gyj",[580,583,586,589,592,595,598,601,604,607,610,613,616,619,622,625],{"title":581,"_path":582},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":584,"_path":585},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":587,"_path":588},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":590,"_path":591},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":593,"_path":594},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":596,"_path":597},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":599,"_path":600},"玩法","/gyj/2022-08-22-wanfa",{"title":602,"_path":603},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":605,"_path":606},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":608,"_path":609},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":611,"_path":612},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":614,"_path":615},"门派内容相关","/gyj/2022-11-17-sect",{"title":617,"_path":618},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":620,"_path":621},"种植","/gyj/2022-12-01-zhongzhi",{"title":623,"_path":624},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":626,"_path":627},"跑商","/gyj/2023-11-01-paoshang",{"title":629,"_path":630,"children":631},"Js","/js",[632,635,638],{"title":633,"_path":634},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":636,"_path":637},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":639,"_path":640},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":642,"_path":643,"children":644},"Tool","/tool",[645,648,651,654,657,660,663,666,669,672,675,678,681,684,687,690,693,696,699,702,705,708,711,714,717,720,723,726,729,732,735,738,741,744,747,750],{"title":646,"_path":647},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":649,"_path":650},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":652,"_path":653},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":655,"_path":656},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":658,"_path":659},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":661,"_path":662},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":664,"_path":665},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":667,"_path":668},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":670,"_path":671},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":673,"_path":674},"mac下brew 使用","/tool/2020-01-13-brew",{"title":676,"_path":677},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":679,"_path":680},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":682,"_path":683},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":685,"_path":686},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":688,"_path":689},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":691,"_path":692},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":694,"_path":695},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":697,"_path":698},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":700,"_path":701},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":703,"_path":704},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":706,"_path":707},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":709,"_path":710},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":712,"_path":713},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":715,"_path":716},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":718,"_path":719},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":721,"_path":722},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":724,"_path":725},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":727,"_path":728},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":730,"_path":731},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":733,"_path":734},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":736,"_path":737},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":739,"_path":740},"rider的使用","/tool/2022-08-02-rider-use",{"title":742,"_path":743},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":745,"_path":746},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":748,"_path":749},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":751,"_path":752},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":754,"_path":755,"children":756},"Unity","/unity",[757,760,763,766,769,772,775,778,781,784,787,790,793,796,799,802,805,808,811,814,817,820,823,826,829,832,835,838,841,844,847,850,853,856,859,862,865,868,871,874,877,880,883,886,889,892,895,898,901,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964,967,970],{"title":758,"_path":759},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":761,"_path":762},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":764,"_path":765},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":767,"_path":768},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":770,"_path":771},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":773,"_path":774},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":776,"_path":777},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":779,"_path":780},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":782,"_path":783},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":785,"_path":786},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":788,"_path":789},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":791,"_path":792},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":794,"_path":795},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":797,"_path":798},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":800,"_path":801},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":803,"_path":804},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":806,"_path":807},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":809,"_path":810},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":812,"_path":813},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":815,"_path":816},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":818,"_path":819},"技能系统","/unity/2020-02-15-skill-system",{"title":821,"_path":822},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":824,"_path":825},"角色状态设计","/unity/2020-02-17-character-states",{"title":827,"_path":828},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":830,"_path":831},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":833,"_path":834},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":836,"_path":837},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":839,"_path":840},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":842,"_path":843},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":845,"_path":846},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":848,"_path":849},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":851,"_path":852},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":854,"_path":855},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":857,"_path":858},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":860,"_path":861},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":863,"_path":864},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":866,"_path":867},"unity的addressables","/unity/2020-09-12-addressables",{"title":869,"_path":870},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":872,"_path":873},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":875,"_path":876},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":878,"_path":879},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":881,"_path":882},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":884,"_path":885},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":887,"_path":888},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":890,"_path":891},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":893,"_path":894},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":896,"_path":897},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":899,"_path":900},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":902,"_path":903},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":905,"_path":906},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":908,"_path":909},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":911,"_path":912},"简单保存工具","/unity/2020-11-13-simple-save",{"title":914,"_path":915},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":917,"_path":918},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":920,"_path":921},"ability","/unity/2020-11-16-dotssample",{"title":923,"_path":924},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":926,"_path":927},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":929,"_path":930},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":932,"_path":933},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":935,"_path":936},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":938,"_path":939},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":941,"_path":942},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":944,"_path":945},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":947,"_path":948},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":950,"_path":951},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":953,"_path":954},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":956,"_path":957},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":959,"_path":960},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":962,"_path":963},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":965,"_path":966},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":968,"_path":969},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":971,"_path":972},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779040539]