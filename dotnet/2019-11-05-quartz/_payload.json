[{"data":1,"prerenderedAt":1841},["Reactive",2],{"content-query-y12r8XMtl7":3,"content-navigation-8C37fagqQL":1259},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1253,"_id":1254,"_source":1255,"_file":1256,"_extension":1257,"date":1258},"/dotnet/2019-11-05-quartz","dotnet",false,"","Creating a Quartz.NET hosted service with ASP.NET Core","In this post I describe how to run Quartz.NET jobs using an ASP.NET Core hosted service. I show how to create a simple IJob, a custom IJobFactory, and a QuartzHostedService that runs jobs while your application is running. I'll also touch on some of the issues to aware of, namely of using scoped services inside singleton classes.",{"type":11,"children":12,"toc":1239},"root",[13,57,74,88,97,102,107,136,150,167,190,195,210,231,243,257,285,296,318,332,375,384,447,475,497,511,531,540,584,596,605,610,676,687,701,742,751,806,833,842,884,893,922,931,951,960,965,973,987,1016,1044,1053,1065,1079,1091,1131,1138,1143,1151,1165,1178,1183,1234],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18,21,30,32,39,41,47,49,55],{"type":19,"value":20},"text","In this post I describe how to run Quartz.NET jobs using an ",{"type":14,"tag":22,"props":23,"children":27},"a",{"href":24,"rel":25},"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2",[26],"nofollow",[28],{"type":19,"value":29},"ASP.NET Core hosted service",{"type":19,"value":31},". I show how to create a simple ",{"type":14,"tag":33,"props":34,"children":36},"code",{"className":35},[],[37],{"type":19,"value":38},"IJob",{"type":19,"value":40},", a custom ",{"type":14,"tag":33,"props":42,"children":44},{"className":43},[],[45],{"type":19,"value":46},"IJobFactory",{"type":19,"value":48},", and a ",{"type":14,"tag":33,"props":50,"children":52},{"className":51},[],[53],{"type":19,"value":54},"QuartzHostedService",{"type":19,"value":56}," that runs jobs while your application is running. I'll also touch on some of the issues to aware of, namely of using scoped services inside singleton classes.",{"type":14,"tag":58,"props":59,"children":61},"h2",{"id":60},"introduction-what-is-quartznet",[62,64],{"type":19,"value":63},"Introduction - what is Quartz.NET?",{"type":14,"tag":22,"props":65,"children":68},{"href":66,"rel":67},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#introduction-what-is-quartz-net-",[26],[69],{"type":14,"tag":70,"props":71,"children":73},"img",{"alt":70,"src":72},"/images/2019-11-05-quartz/icons-link.svg",[],{"type":14,"tag":15,"props":75,"children":76},{},[77,79,86],{"type":19,"value":78},"As per ",{"type":14,"tag":22,"props":80,"children":83},{"href":81,"rel":82},"https://www.quartz-scheduler.net/",[26],[84],{"type":19,"value":85},"their website",{"type":19,"value":87},":",{"type":14,"tag":89,"props":90,"children":91},"blockquote",{},[92],{"type":14,"tag":15,"props":93,"children":94},{},[95],{"type":19,"value":96},"Quartz.NET is a full-featured, open source job scheduling system that can be used from smallest apps to large scale enterprise systems.",{"type":14,"tag":15,"props":98,"children":99},{},[100],{"type":19,"value":101},"It's an old staple of many ASP.NET developers, used as a way of running background tasks on a timer, in a reliable, clustered, way. Using Quartz.NET with ASP.NET Core is pretty similar - Quartz.NET supports .NET Standard 2.0, so you can easily use it in your applications.",{"type":14,"tag":15,"props":103,"children":104},{},[105],{"type":19,"value":106},"Quartz.NET has two main concepts:",{"type":14,"tag":108,"props":109,"children":110},"ul",{},[111,125],{"type":14,"tag":112,"props":113,"children":114},"li",{},[115,117,123],{"type":19,"value":116},"A ",{"type":14,"tag":118,"props":119,"children":120},"strong",{},[121],{"type":19,"value":122},"job",{"type":19,"value":124},". This is the background tasks that you want to run on some sort of schedule.",{"type":14,"tag":112,"props":126,"children":127},{},[128,129,134],{"type":19,"value":116},{"type":14,"tag":118,"props":130,"children":131},{},[132],{"type":19,"value":133},"scheduler",{"type":19,"value":135},". This is responsible for running jobs based on triggers, on a time-based schedule.",{"type":14,"tag":15,"props":137,"children":138},{},[139,141,148],{"type":19,"value":140},"ASP.NET Core has good support for running \"background tasks\" via way of ",{"type":14,"tag":22,"props":142,"children":145},{"href":143,"rel":144},"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services",[26],[146],{"type":19,"value":147},"hosted services",{"type":19,"value":149},". Hosted services are started when your ASP.NET Core app starts, and run in the background for the lifetime of the application. By creating a Quartz.NET hosted service, you can use a standard ASP.NET Core application for running your tasks in the background.",{"type":14,"tag":89,"props":151,"children":152},{},[153],{"type":14,"tag":15,"props":154,"children":155},{},[156,158,165],{"type":19,"value":157},"This sort of non-HTTP scenario is also possible with the \"generic host\", ",{"type":14,"tag":22,"props":159,"children":162},{"href":160,"rel":161},"https://andrewlock.net/the-asp-net-core-generic-host-namespace-clashes-and-extension-methods/",[26],[163],{"type":19,"value":164},"but for various reasons",{"type":19,"value":166}," I generally don't use those at the moment. This should hopefully improve in ASP.NET Core 3.0 with the extra investment going into these non-HTTP scenarios.",{"type":14,"tag":15,"props":168,"children":169},{},[170,172,179,181,188],{"type":19,"value":171},"While it's possible to create ",{"type":14,"tag":22,"props":173,"children":176},{"href":174,"rel":175},"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2#timed-background-tasks",[26],[177],{"type":19,"value":178},"a \"timed\" background service",{"type":19,"value":180},", (that runs a tasks every 10 minutes, for example), Quartz.NET provides a far more robust solution. You can ensure tasks only run at specific times of the day (e.g. 2:30am), or only on specific days, or any combination by using a ",{"type":14,"tag":22,"props":182,"children":185},{"href":183,"rel":184},"https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html",[26],[186],{"type":19,"value":187},"Cron trigger",{"type":19,"value":189},". It also allows you to run multiple instances of your application in a clustered fashion, so that only a single instance can run a given task at any one time.",{"type":14,"tag":15,"props":191,"children":192},{},[193],{"type":19,"value":194},"In this post I'll show the basics of creating a Quartz.NET job and scheduling it to run on a timer in a hosted service.",{"type":14,"tag":58,"props":196,"children":198},{"id":197},"installing-quartznet",[199,201],{"type":19,"value":200},"Installing Quartz.NET",{"type":14,"tag":22,"props":202,"children":205},{"href":203,"rel":204},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#installing-quartz-net",[26],[206],{"type":14,"tag":70,"props":207,"children":209},{"alt":70,"src":208},"https://andrewlock.net/assets/img/icons-link.svg",[],{"type":14,"tag":15,"props":211,"children":212},{},[213,215,221,223,229],{"type":19,"value":214},"Quartz.NET is a .NET Standard 2.0 NuGet package, so it should be easy to install in your application. For this test I created an ASP.NET Core project and chose the Empty template. You can install the Quartz.NET package using ",{"type":14,"tag":33,"props":216,"children":218},{"className":217},[],[219],{"type":19,"value":220},"dotnet add package Quartz",{"type":19,"value":222},". If you view the ",{"type":14,"tag":224,"props":225,"children":226},"em",{},[227],{"type":19,"value":228},".csproj",{"type":19,"value":230}," for the project, it should look something like this:",{"type":14,"tag":232,"props":233,"children":238},"pre",{"className":234,"code":236,"language":237,"meta":7},[235],"language-xml","\u003CProject Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  \u003CPropertyGroup>\n    \u003CTargetFramework>netcoreapp2.2\u003C/TargetFramework>\n    \u003CAspNetCoreHostingModel>InProcess\u003C/AspNetCoreHostingModel>\n  \u003C/PropertyGroup>\n\n  \u003CItemGroup>\n    \u003CPackageReference Include=\"Microsoft.AspNetCore.App\" />\n    \u003CPackageReference Include=\"Quartz\" Version=\"3.0.7\" />\n  \u003C/ItemGroup>\n\n\u003C/Project>\n","xml",[239],{"type":14,"tag":33,"props":240,"children":241},{"__ignoreMap":7},[242],{"type":19,"value":236},{"type":14,"tag":58,"props":244,"children":246},{"id":245},"creating-an-ijob",[247,249],{"type":19,"value":248},"Creating an IJob",{"type":14,"tag":22,"props":250,"children":253},{"href":251,"rel":252},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-an-ijob",[26],[254],{"type":14,"tag":70,"props":255,"children":256},{"alt":70,"src":208},[],{"type":14,"tag":15,"props":258,"children":259},{},[260,262,268,270,275,277,283],{"type":19,"value":261},"For the actual background work we are scheduling, we're just going to use a \"hello world\" implementation that writes to an ",{"type":14,"tag":33,"props":263,"children":265},{"className":264},[],[266],{"type":19,"value":267},"ILogger\u003C>",{"type":19,"value":269}," (and hence to the console). You should implement the Quartz interface ",{"type":14,"tag":33,"props":271,"children":273},{"className":272},[],[274],{"type":19,"value":38},{"type":19,"value":276}," which contains a single asynchronous ",{"type":14,"tag":33,"props":278,"children":280},{"className":279},[],[281],{"type":19,"value":282},"Execute()",{"type":19,"value":284}," method. Note that we're using dependency injection here to inject the logger into the constructor.",{"type":14,"tag":232,"props":286,"children":291},{"className":287,"code":289,"language":290,"meta":7},[288],"language-csharp","using Microsoft.Extensions.Logging;\nusing Quartz;\nusing System.Threading.Tasks;\n\n[DisallowConcurrentExecution]\npublic class HelloWorldJob : IJob\n{\n    private readonly ILogger\u003CHelloWorldJob> _logger;\n    public HelloWorldJob(ILogger\u003CHelloWorldJob> logger)\n    {\n        _logger = logger;\n    }\n\n    public Task Execute(IJobExecutionContext context)\n    {\n        _logger.LogInformation(\"Hello world!\");\n        return Task.CompletedTask;\n    }\n}\n","csharp",[292],{"type":14,"tag":33,"props":293,"children":294},{"__ignoreMap":7},[295],{"type":19,"value":289},{"type":14,"tag":15,"props":297,"children":298},{},[299,301,307,309,316],{"type":19,"value":300},"I also decorated the job with the ",{"type":14,"tag":33,"props":302,"children":304},{"className":303},[],[305],{"type":19,"value":306},"[DisallowConcurrentExecution]",{"type":19,"value":308}," attribute. This attribute ",{"type":14,"tag":22,"props":310,"children":313},{"href":311,"rel":312},"https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/more-about-jobs.html#job-state-and-concurrency",[26],[314],{"type":19,"value":315},"prevents Quartz.NET from trying to run the same job concurrently",{"type":19,"value":317},".",{"type":14,"tag":58,"props":319,"children":321},{"id":320},"creating-an-ijobfactory",[322,324],{"type":19,"value":323},"Creating an IJobFactory",{"type":14,"tag":22,"props":325,"children":328},{"href":326,"rel":327},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-an-ijobfactory",[26],[329],{"type":14,"tag":70,"props":330,"children":331},{"alt":70,"src":208},[],{"type":14,"tag":15,"props":333,"children":334},{},[335,337,342,344,350,352,358,360,365,367,373],{"type":19,"value":336},"Next, we need to tell Quartz how it should create instances of ",{"type":14,"tag":33,"props":338,"children":340},{"className":339},[],[341],{"type":19,"value":38},{"type":19,"value":343},". By default, Quartz will try and \"new-up\" instances of the job using ",{"type":14,"tag":33,"props":345,"children":347},{"className":346},[],[348],{"type":19,"value":349},"Activator.CreateInstance",{"type":19,"value":351},", effectively calling ",{"type":14,"tag":33,"props":353,"children":355},{"className":354},[],[356],{"type":19,"value":357},"new HelloWorldJob()",{"type":19,"value":359},". Unfortunately, as we're using constructor injection, that won't work. Instead, we can provide a custom ",{"type":14,"tag":33,"props":361,"children":363},{"className":362},[],[364],{"type":19,"value":46},{"type":19,"value":366}," that hooks into the ASP.NET Core dependency injection container (",{"type":14,"tag":33,"props":368,"children":370},{"className":369},[],[371],{"type":19,"value":372},"IServiceProvider",{"type":19,"value":374},"):",{"type":14,"tag":232,"props":376,"children":379},{"className":377,"code":378,"language":290,"meta":7},[288],"using Microsoft.Extensions.DependencyInjection;\nusing Quartz;\nusing Quartz.Spi;\nusing System;\n\npublic class SingletonJobFactory : IJobFactory\n{\n    private readonly IServiceProvider _serviceProvider;\n    public SingletonJobFactory(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n\n    public IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler)\n    {\n        return _serviceProvider.GetRequiredService(bundle.JobDetail.JobType) as IJob;\n    }\n\n    public void ReturnJob(IJob job) { }\n}\n",[380],{"type":14,"tag":33,"props":381,"children":382},{"__ignoreMap":7},[383],{"type":19,"value":378},{"type":14,"tag":15,"props":385,"children":386},{},[387,389,394,396,401,403,409,411,416,418,423,425,430,432,438,440,446],{"type":19,"value":388},"This factory takes an ",{"type":14,"tag":33,"props":390,"children":392},{"className":391},[],[393],{"type":19,"value":372},{"type":19,"value":395}," in the constructor, and implements the ",{"type":14,"tag":33,"props":397,"children":399},{"className":398},[],[400],{"type":19,"value":46},{"type":19,"value":402}," interface. The important method is the ",{"type":14,"tag":33,"props":404,"children":406},{"className":405},[],[407],{"type":19,"value":408},"NewJob()",{"type":19,"value":410}," method, in which the factory has to return the ",{"type":14,"tag":33,"props":412,"children":414},{"className":413},[],[415],{"type":19,"value":38},{"type":19,"value":417}," requested by the Quartz scheduler. In this implementation we delegate directly to the ",{"type":14,"tag":33,"props":419,"children":421},{"className":420},[],[422],{"type":19,"value":372},{"type":19,"value":424},", and let the DI container find the required instance. The cast to ",{"type":14,"tag":33,"props":426,"children":428},{"className":427},[],[429],{"type":19,"value":38},{"type":19,"value":431}," at the end is required because the non-generic version of ",{"type":14,"tag":33,"props":433,"children":435},{"className":434},[],[436],{"type":19,"value":437},"GetRequiredService",{"type":19,"value":439}," returns an ",{"type":14,"tag":33,"props":441,"children":443},{"className":442},[],[444],{"type":19,"value":445},"object",{"type":19,"value":317},{"type":14,"tag":15,"props":448,"children":449},{},[450,452,458,460,465,467,473],{"type":19,"value":451},"The ",{"type":14,"tag":33,"props":453,"children":455},{"className":454},[],[456],{"type":19,"value":457},"ReturnJob",{"type":19,"value":459}," method is where the scheduler tries to return (i.e. destroy) a job that was created by the factory. Unfortunately, there's no mechanism for doing so with the built-in ",{"type":14,"tag":33,"props":461,"children":463},{"className":462},[],[464],{"type":19,"value":372},{"type":19,"value":466},". We can't create a new ",{"type":14,"tag":33,"props":468,"children":470},{"className":469},[],[471],{"type":19,"value":472},"IScopeService",{"type":19,"value":474}," that fits into the required Quartz API, so we're stuck only being able to create singleton jobs.",{"type":14,"tag":89,"props":476,"children":477},{},[478],{"type":14,"tag":15,"props":479,"children":480},{},[481,483,488,490,495],{"type":19,"value":482},"This is important. With the above implementation, it is only safe to create ",{"type":14,"tag":33,"props":484,"children":486},{"className":485},[],[487],{"type":19,"value":38},{"type":19,"value":489}," implementations that are ",{"type":14,"tag":118,"props":491,"children":492},{},[493],{"type":19,"value":494},"Singletons",{"type":19,"value":496}," (or transient).",{"type":14,"tag":58,"props":498,"children":500},{"id":499},"configuring-the-job",[501,503],{"type":19,"value":502},"Configuring the Job",{"type":14,"tag":22,"props":504,"children":507},{"href":505,"rel":506},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#configuring-the-job",[26],[508],{"type":14,"tag":70,"props":509,"children":510},{"alt":70,"src":208},[],{"type":14,"tag":15,"props":512,"children":513},{},[514,516,521,523,529],{"type":19,"value":515},"I'm only showing a single ",{"type":14,"tag":33,"props":517,"children":519},{"className":518},[],[520],{"type":19,"value":38},{"type":19,"value":522}," implementation here, but we want the Quartz hosted service to be a generic implementation that works for any number of jobs. To help with that, we create a simple DTO called ",{"type":14,"tag":33,"props":524,"children":526},{"className":525},[],[527],{"type":19,"value":528},"JobSchedule",{"type":19,"value":530}," that we'll use to define the timer schedule for a given job type:",{"type":14,"tag":232,"props":532,"children":535},{"className":533,"code":534,"language":290,"meta":7},[288],"using System;\n\npublic class JobSchedule\n{\n    public JobSchedule(Type jobType, string cronExpression)\n    {\n        JobType = jobType;\n        CronExpression = cronExpression;\n    }\n\n    public Type JobType { get; }\n    public string CronExpression { get; }\n}\n",[536],{"type":14,"tag":33,"props":537,"children":538},{"__ignoreMap":7},[539],{"type":19,"value":534},{"type":14,"tag":15,"props":541,"children":542},{},[543,544,550,552,558,560,566,568,574,576,582],{"type":19,"value":451},{"type":14,"tag":33,"props":545,"children":547},{"className":546},[],[548],{"type":19,"value":549},"JobType",{"type":19,"value":551}," is the .NET type of the job (",{"type":14,"tag":33,"props":553,"children":555},{"className":554},[],[556],{"type":19,"value":557},"HelloWorldJob",{"type":19,"value":559}," for our example), and ",{"type":14,"tag":33,"props":561,"children":563},{"className":562},[],[564],{"type":19,"value":565},"CronExpression",{"type":19,"value":567}," is a ",{"type":14,"tag":22,"props":569,"children":571},{"href":183,"rel":570},[26],[572],{"type":19,"value":573},"Quartz.NET Cron expression",{"type":19,"value":575},". Cron expressions allow complex timer scheduling so you can set rules like \"fire every half hour between the hours of 8 am and 10 am, on the 5th and 20th of every month\". Just be sure to ",{"type":14,"tag":22,"props":577,"children":579},{"href":183,"rel":578},[26],[580],{"type":19,"value":581},"check the documentation",{"type":19,"value":583}," for examples as not all Cron expressions used by different systems are interchangeable.",{"type":14,"tag":15,"props":585,"children":586},{},[587,589,595],{"type":19,"value":588},"We'll add the job to DI and configure its schedule in ",{"type":14,"tag":33,"props":590,"children":592},{"className":591},[],[593],{"type":19,"value":594},"Startup.ConfigureServices()",{"type":19,"value":87},{"type":14,"tag":232,"props":597,"children":600},{"className":598,"code":599,"language":290,"meta":7},[288],"using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing Quartz;\nusing Quartz.Impl;\nusing Quartz.Spi;\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Add Quartz services\n    services.AddSingleton\u003CIJobFactory, SingletonJobFactory>();\n    services.AddSingleton\u003CISchedulerFactory, StdSchedulerFactory>();\n\n    // Add our job\n    services.AddSingleton\u003CHelloWorldJob>();\n    services.AddSingleton(new JobSchedule(\n        jobType: typeof(HelloWorldJob),\n        cronExpression: \"0/5 * * * * ?\")); // run every 5 seconds\n}\n",[601],{"type":14,"tag":33,"props":602,"children":603},{"__ignoreMap":7},[604],{"type":19,"value":599},{"type":14,"tag":15,"props":606,"children":607},{},[608],{"type":19,"value":609},"This code adds four things as singletons to the DI container:",{"type":14,"tag":108,"props":611,"children":612},{},[613,625,646,657],{"type":14,"tag":112,"props":614,"children":615},{},[616,617,623],{"type":19,"value":451},{"type":14,"tag":33,"props":618,"children":620},{"className":619},[],[621],{"type":19,"value":622},"SingletonJobFactory",{"type":19,"value":624}," shown earlier, used for creating the job instances.",{"type":14,"tag":112,"props":626,"children":627},{},[628,630,636,638,644],{"type":19,"value":629},"An implementation of ",{"type":14,"tag":33,"props":631,"children":633},{"className":632},[],[634],{"type":19,"value":635},"ISchedulerFactory",{"type":19,"value":637},", the built-in ",{"type":14,"tag":33,"props":639,"children":641},{"className":640},[],[642],{"type":19,"value":643},"StdSchedulerFactory",{"type":19,"value":645},", which handles scheduling and managing jobs",{"type":14,"tag":112,"props":647,"children":648},{},[649,650,655],{"type":19,"value":451},{"type":14,"tag":33,"props":651,"children":653},{"className":652},[],[654],{"type":19,"value":557},{"type":19,"value":656}," job itself",{"type":14,"tag":112,"props":658,"children":659},{},[660,662,667,669,674],{"type":19,"value":661},"An instance of ",{"type":14,"tag":33,"props":663,"children":665},{"className":664},[],[666],{"type":19,"value":528},{"type":19,"value":668}," for the ",{"type":14,"tag":33,"props":670,"children":672},{"className":671},[],[673],{"type":19,"value":557},{"type":19,"value":675}," with a Cron expression to run every 5 seconds.",{"type":14,"tag":15,"props":677,"children":678},{},[679,681,686],{"type":19,"value":680},"There's only one piece missing now that brings them all together, the ",{"type":14,"tag":33,"props":682,"children":684},{"className":683},[],[685],{"type":19,"value":54},{"type":19,"value":317},{"type":14,"tag":58,"props":688,"children":690},{"id":689},"creating-the-quartzhostedservice",[691,693],{"type":19,"value":692},"Creating the QuartzHostedService",{"type":14,"tag":22,"props":694,"children":697},{"href":695,"rel":696},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-the-quartzhostedservice",[26],[698],{"type":14,"tag":70,"props":699,"children":700},{"alt":70,"src":208},[],{"type":14,"tag":15,"props":702,"children":703},{},[704,705,710,712,718,720,725,727,734,740],{"type":19,"value":451},{"type":14,"tag":33,"props":706,"children":708},{"className":707},[],[709],{"type":19,"value":54},{"type":19,"value":711}," is an implementation of ",{"type":14,"tag":33,"props":713,"children":715},{"className":714},[],[716],{"type":19,"value":717},"IHostedService",{"type":19,"value":719}," that sets up the Quartz scheduler, and starts it running in the background. Due to the design of Quartz, we can implement ",{"type":14,"tag":33,"props":721,"children":723},{"className":722},[],[724],{"type":19,"value":717},{"type":19,"value":726}," directly, instead of the ",{"type":14,"tag":22,"props":728,"children":731},{"href":729,"rel":730},"https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/background-tasks-with-ihostedservice",[26],[732],{"type":19,"value":733},"more common approach of deriving from the base ",{"type":14,"tag":33,"props":735,"children":737},{"className":736},[],[738],{"type":19,"value":739},"BackgroundService",{"type":19,"value":741}," class. The full code for the service is listed below, and I'll discuss it afterwards.",{"type":14,"tag":232,"props":743,"children":746},{"className":744,"code":745,"language":290,"meta":7},[288],"using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Hosting;\nusing Quartz;\nusing Quartz.Spi;\n\npublic class QuartzHostedService : IHostedService\n{\n    private readonly ISchedulerFactory _schedulerFactory;\n    private readonly IJobFactory _jobFactory;\n    private readonly IEnumerable\u003CJobSchedule> _jobSchedules;\n\n    public QuartzHostedService(\n        ISchedulerFactory schedulerFactory,\n        IJobFactory jobFactory,\n        IEnumerable\u003CJobSchedule> jobSchedules)\n    {\n        _schedulerFactory = schedulerFactory;\n        _jobSchedules = jobSchedules;\n        _jobFactory = jobFactory;\n    }\n    public IScheduler Scheduler { get; set; }\n\n    public async Task StartAsync(CancellationToken cancellationToken)\n    {\n        Scheduler = await _schedulerFactory.GetScheduler(cancellationToken);\n        Scheduler.JobFactory = _jobFactory;\n\n        foreach (var jobSchedule in _jobSchedules)\n        {\n            var job = CreateJob(jobSchedule);\n            var trigger = CreateTrigger(jobSchedule);\n\n            await Scheduler.ScheduleJob(job, trigger, cancellationToken);\n        }\n\n        await Scheduler.Start(cancellationToken);\n    }\n\n    public async Task StopAsync(CancellationToken cancellationToken)\n    {\n        await Scheduler?.Shutdown(cancellationToken);\n    }\n\n    private static IJobDetail CreateJob(JobSchedule schedule)\n    {\n        var jobType = schedule.JobType;\n        return JobBuilder\n            .Create(jobType)\n            .WithIdentity(jobType.FullName)\n            .WithDescription(jobType.Name)\n            .Build();\n    }\n\n    private static ITrigger CreateTrigger(JobSchedule schedule)\n    {\n        return TriggerBuilder\n            .Create()\n            .WithIdentity($\"{schedule.JobType.FullName}.trigger\")\n            .WithCronSchedule(schedule.CronExpression)\n            .WithDescription(schedule.CronExpression)\n            .Build();\n    }\n}\n",[747],{"type":14,"tag":33,"props":748,"children":749},{"__ignoreMap":7},[750],{"type":19,"value":745},{"type":14,"tag":15,"props":752,"children":753},{},[754,755,760,762,767,769,774,776,782,784,790,792,797,799,804],{"type":19,"value":451},{"type":14,"tag":33,"props":756,"children":758},{"className":757},[],[759],{"type":19,"value":54},{"type":19,"value":761}," has three dependencies: the ",{"type":14,"tag":33,"props":763,"children":765},{"className":764},[],[766],{"type":19,"value":635},{"type":19,"value":768}," and ",{"type":14,"tag":33,"props":770,"children":772},{"className":771},[],[773],{"type":19,"value":46},{"type":19,"value":775}," we configured in ",{"type":14,"tag":33,"props":777,"children":779},{"className":778},[],[780],{"type":19,"value":781},"Startup",{"type":19,"value":783},", and an ",{"type":14,"tag":33,"props":785,"children":787},{"className":786},[],[788],{"type":19,"value":789},"IEnumerable",{"type":19,"value":791},". We only added a single ",{"type":14,"tag":33,"props":793,"children":795},{"className":794},[],[796],{"type":19,"value":528},{"type":19,"value":798}," to the DI container (for the ",{"type":14,"tag":33,"props":800,"children":802},{"className":801},[],[803],{"type":19,"value":557},{"type":19,"value":805},"), but if you register more job schedules with the DI container they'll all be injected here.",{"type":14,"tag":15,"props":807,"children":808},{},[809,815,817,823,825,831],{"type":14,"tag":33,"props":810,"children":812},{"className":811},[],[813],{"type":19,"value":814},"StartAsync",{"type":19,"value":816}," is called when the application starts up and is where we configure Quartz. We start by creating an instance of ",{"type":14,"tag":33,"props":818,"children":820},{"className":819},[],[821],{"type":19,"value":822},"IScheduler",{"type":19,"value":824},", assigning it to a property for use later, and setting the ",{"type":14,"tag":33,"props":826,"children":828},{"className":827},[],[829],{"type":19,"value":830},"JobFactory",{"type":19,"value":832}," for the scheduler to the injected instance:",{"type":14,"tag":232,"props":834,"children":837},{"className":835,"code":836,"language":290,"meta":7},[288],"public async Task StartAsync(CancellationToken cancellationToken)\n{\n    Scheduler = await _schedulerFactory.GetScheduler(cancellationToken);\n    Scheduler.JobFactory = _jobFactory;\n\n    // ...\n}\n",[838],{"type":14,"tag":33,"props":839,"children":840},{"__ignoreMap":7},[841],{"type":19,"value":836},{"type":14,"tag":15,"props":843,"children":844},{},[845,847,853,854,860,862,868,869,875,877,882],{"type":19,"value":846},"Next, we loop through the injected job schedules, and create a Quartz ",{"type":14,"tag":33,"props":848,"children":850},{"className":849},[],[851],{"type":19,"value":852},"IJobDetail",{"type":19,"value":768},{"type":14,"tag":33,"props":855,"children":857},{"className":856},[],[858],{"type":19,"value":859},"ITrigger",{"type":19,"value":861}," for each one using the ",{"type":14,"tag":33,"props":863,"children":865},{"className":864},[],[866],{"type":19,"value":867},"CreateJob",{"type":19,"value":768},{"type":14,"tag":33,"props":870,"children":872},{"className":871},[],[873],{"type":19,"value":874},"CreateTrigger",{"type":19,"value":876}," helper methods at the end of the class. If you don't like how this part works, or need more control over the configuration, you can easily customise it by extending the ",{"type":14,"tag":33,"props":878,"children":880},{"className":879},[],[881],{"type":19,"value":528},{"type":19,"value":883}," DTO as you see fit.",{"type":14,"tag":232,"props":885,"children":888},{"className":886,"code":887,"language":290,"meta":7},[288],"public async Task StartAsync(CancellationToken cancellationToken)\n{\n    // ...\n    foreach (var jobSchedule in _jobSchedules)\n    {\n        var job = CreateJob(jobSchedule);\n        var trigger = CreateTrigger(jobSchedule);\n\n        await Scheduler.ScheduleJob(job, trigger, cancellationToken);\n    }\n    // ...\n}\n\nprivate static IJobDetail CreateJob(JobSchedule schedule)\n{\n    var jobType = schedule.JobType;\n    return JobBuilder\n        .Create(jobType)\n        .WithIdentity(jobType.FullName)\n        .WithDescription(jobType.Name)\n        .Build();\n}\n\nprivate static ITrigger CreateTrigger(JobSchedule schedule)\n{\n    return TriggerBuilder\n        .Create()\n        .WithIdentity($\"{schedule.JobType.FullName}.trigger\")\n        .WithCronSchedule(schedule.CronExpression)\n        .WithDescription(schedule.CronExpression)\n        .Build();\n}\n",[889],{"type":14,"tag":33,"props":890,"children":891},{"__ignoreMap":7},[892],{"type":19,"value":887},{"type":14,"tag":15,"props":894,"children":895},{},[896,898,904,906,912,914,920],{"type":19,"value":897},"Finally, once all the jobs are scheduled, you call ",{"type":14,"tag":33,"props":899,"children":901},{"className":900},[],[902],{"type":19,"value":903},"Scheduler.Start()",{"type":19,"value":905}," to actually start the Quartz.NET scheduler processing in the background. When the app shuts down, the framework will call ",{"type":14,"tag":33,"props":907,"children":909},{"className":908},[],[910],{"type":19,"value":911},"StopAsync()",{"type":19,"value":913},", at which point you can call ",{"type":14,"tag":33,"props":915,"children":917},{"className":916},[],[918],{"type":19,"value":919},"Scheduler.Stop()",{"type":19,"value":921}," to safely shut down the scheduler process.",{"type":14,"tag":232,"props":923,"children":926},{"className":924,"code":925,"language":290,"meta":7},[288],"public async Task StopAsync(CancellationToken cancellationToken)\n{\n    await Scheduler?.Shutdown(cancellationToken);\n}\n",[927],{"type":14,"tag":33,"props":928,"children":929},{"__ignoreMap":7},[930],{"type":19,"value":925},{"type":14,"tag":15,"props":932,"children":933},{},[934,936,942,944,950],{"type":19,"value":935},"You can register the hosted service using the ",{"type":14,"tag":33,"props":937,"children":939},{"className":938},[],[940],{"type":19,"value":941},"AddHostedService()",{"type":19,"value":943}," extension method in ",{"type":14,"tag":33,"props":945,"children":947},{"className":946},[],[948],{"type":19,"value":949},"Startup.ConfigureServices",{"type":19,"value":87},{"type":14,"tag":232,"props":952,"children":955},{"className":953,"code":954,"language":290,"meta":7},[288],"public void ConfigureServices(IServiceCollection services)\n{\n    // ...\n    services.AddHostedService\u003CQuartzHostedService>();\n}\n",[956],{"type":14,"tag":33,"props":957,"children":958},{"__ignoreMap":7},[959],{"type":19,"value":954},{"type":14,"tag":15,"props":961,"children":962},{},[963],{"type":19,"value":964},"If you run the application, you should see the background task running every 5 seconds and writing to the Console (or wherever you have logging configured)",{"type":14,"tag":15,"props":966,"children":967},{},[968],{"type":14,"tag":70,"props":969,"children":972},{"alt":970,"src":971},"Background service writing Hello World to console repeatedly","/images/2019-11-05-quartz/quartz_service.png",[],{"type":14,"tag":58,"props":974,"children":976},{"id":975},"using-scoped-services-in-jobs",[977,979],{"type":19,"value":978},"Using scoped services in jobs",{"type":14,"tag":22,"props":980,"children":983},{"href":981,"rel":982},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#using-scoped-services-in-jobs",[26],[984],{"type":14,"tag":70,"props":985,"children":986},{"alt":70,"src":208},[],{"type":14,"tag":15,"props":988,"children":989},{},[990,992,998,1000,1005,1007,1014],{"type":19,"value":991},"There's one big problem with the implementation as described in this post: you can only create Singleton or Transient jobs. That means you can't use any dependencies that are registered as Scoped services. For example, you can't inject an EF Core ",{"type":14,"tag":33,"props":993,"children":995},{"className":994},[],[996],{"type":19,"value":997},"DatabaseContext",{"type":19,"value":999}," into your ",{"type":14,"tag":33,"props":1001,"children":1003},{"className":1002},[],[1004],{"type":19,"value":38},{"type":19,"value":1006}," implementation, as you'll have a ",{"type":14,"tag":22,"props":1008,"children":1011},{"href":1009,"rel":1010},"http://blog.ploeh.dk/2014/06/02/captive-dependency/",[26],[1012],{"type":19,"value":1013},"captive dependency",{"type":19,"value":1015}," problem.",{"type":14,"tag":15,"props":1017,"children":1018},{},[1019,1021,1026,1028,1035,1037,1042],{"type":19,"value":1020},"Working around this isn't a big issue: you can inject an ",{"type":14,"tag":33,"props":1022,"children":1024},{"className":1023},[],[1025],{"type":19,"value":372},{"type":19,"value":1027}," and create your own scope, ",{"type":14,"tag":22,"props":1029,"children":1032},{"href":1030,"rel":1031},"https://andrewlock.net/the-dangers-and-gotchas-of-using-scoped-services-when-configuring-options-in-asp-net-core/#3-creating-a-new-scope-in-iconfigureoptions",[26],[1033],{"type":19,"value":1034},"similar to the solution for a similar problem in a previous post",{"type":19,"value":1036},". For example, if you need to use a scoped service in your ",{"type":14,"tag":33,"props":1038,"children":1040},{"className":1039},[],[1041],{"type":19,"value":557},{"type":19,"value":1043},", you could use something like the following:",{"type":14,"tag":232,"props":1045,"children":1048},{"className":1046,"code":1047,"language":290,"meta":7},[288],"public class HelloWorldJob : IJob\n{\n    // Inject the DI provider\n    private readonly IServiceProvider _provider;\n    public HelloWorldJob( IServiceProvider provider)\n    {\n        _provider = provider;\n    }\n\n    public Task Execute(IJobExecutionContext context)\n    {\n        // Create a new scope\n        using(var scope = _provider.CreateScope())\n        {\n            // Resolve the Scoped service\n            var service = scope.ServiceProvider.GetService\u003CIScopedService>();\n            _logger.LogInformation(\"Hello world!\");\n        }\n\n        return Task.CompletedTask;\n    }\n}\n",[1049],{"type":14,"tag":33,"props":1050,"children":1051},{"__ignoreMap":7},[1052],{"type":19,"value":1047},{"type":14,"tag":15,"props":1054,"children":1055},{},[1056,1058,1063],{"type":19,"value":1057},"This ensures a new scope is created every time the job runs, so you can retrieve (and dispose) scoped services inside the ",{"type":14,"tag":33,"props":1059,"children":1061},{"className":1060},[],[1062],{"type":19,"value":38},{"type":19,"value":1064},". Unfortunately things do get a little messy. In the next post I'll show a variation on this approach that is a little cleaner.",{"type":14,"tag":58,"props":1066,"children":1068},{"id":1067},"summary",[1069,1071],{"type":19,"value":1070},"Summary",{"type":14,"tag":22,"props":1072,"children":1075},{"href":1073,"rel":1074},"https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#summary",[26],[1076],{"type":14,"tag":70,"props":1077,"children":1078},{"alt":70,"src":208},[],{"type":14,"tag":15,"props":1080,"children":1081},{},[1082,1084,1089],{"type":19,"value":1083},"In this post I introduced Quartz.NET and showed how you could use it to schedule background jobs to run in ASP.NET Core using ",{"type":14,"tag":33,"props":1085,"children":1087},{"className":1086},[],[1088],{"type":19,"value":717},{"type":19,"value":1090},". The example shown in this post is best for singleton or transient jobs, which isn't ideal, as consuming scoped services is clumsy. In the next post, I'll show a variation on this approach that makes using scoped services easier.",{"type":14,"tag":108,"props":1092,"children":1093},{},[1094,1104,1113,1122],{"type":14,"tag":112,"props":1095,"children":1096},{},[1097],{"type":14,"tag":22,"props":1098,"children":1101},{"href":1099,"rel":1100},"https://github.com/andrewlock/blog-examples/tree/master/QuartzHostedService",[26],[1102],{"type":19,"value":1103},"Example source code for this post",{"type":14,"tag":112,"props":1105,"children":1106},{},[1107],{"type":14,"tag":22,"props":1108,"children":1111},{"href":1109,"rel":1110},"https://github.com/HangfireIO/Cronos",[26],[1112],{"type":19,"value":1109},{"type":14,"tag":112,"props":1114,"children":1115},{},[1116],{"type":14,"tag":22,"props":1117,"children":1120},{"href":1118,"rel":1119},"https://github.com/HangfireIO/Hangfire",[26],[1121],{"type":19,"value":1118},{"type":14,"tag":112,"props":1123,"children":1124},{},[1125],{"type":14,"tag":22,"props":1126,"children":1129},{"href":1127,"rel":1128},"https://github.com/quartznet/quartznet",[26],[1130],{"type":19,"value":1127},{"type":14,"tag":1132,"props":1133,"children":1135},"h3",{"id":1134},"hangfire-与quartznet对比",[1136],{"type":19,"value":1137},"Hangfire 与quartz.net对比",{"type":14,"tag":15,"props":1139,"children":1140},{},[1141],{"type":19,"value":1142},"在项目没有引入Hangfire之前，一直使用的是Quartz.net。个人认为Quartz.net在定时任务处理方面优势如下：",{"type":14,"tag":108,"props":1144,"children":1145},{},[1146],{"type":14,"tag":112,"props":1147,"children":1148},{},[1149],{"type":19,"value":1150},"支持秒级单位的定时任务处理，但是Hangfire只能支持分钟及以上的定时任务处理",{"type":14,"tag":15,"props":1152,"children":1153},{},[1154,1156,1163],{"type":19,"value":1155},"原因在于Hangfire用的是开源的",{"type":14,"tag":22,"props":1157,"children":1160},{"href":1158,"rel":1159},"https://github.com/atifaziz/NCrontab",[26],[1161],{"type":19,"value":1162},"NCrontab",{"type":19,"value":1164},"组件，跟linux上的crontab指令相似。",{"type":14,"tag":108,"props":1166,"children":1167},{},[1168,1173],{"type":14,"tag":112,"props":1169,"children":1170},{},[1171],{"type":19,"value":1172},"更加复杂的触发器，日历以及任务调度处理",{"type":14,"tag":112,"props":1174,"children":1175},{},[1176],{"type":19,"value":1177},"可配置的定时任务",{"type":14,"tag":15,"props":1179,"children":1180},{},[1181],{"type":19,"value":1182},"但是为什么要换Hangfire? 很大的原因在于项目需要一个后台可监控的应用，不用每次都要从服务器拉取日志查看，在没有ELK的时候相当不方便。Hangfire控制面板不仅提供监控，也可以手动的触发执行定时任务。如果在定时任务处理方面没有很高的要求，比如一定要5s定时执行，Hangfire值得拥有。抛开这些，Hangfire优势太明显了：",{"type":14,"tag":108,"props":1184,"children":1185},{},[1186,1191,1196,1201,1206,1219,1224,1229],{"type":14,"tag":112,"props":1187,"children":1188},{},[1189],{"type":19,"value":1190},"持久化保存任务、队列、统计信息",{"type":14,"tag":112,"props":1192,"children":1193},{},[1194],{"type":19,"value":1195},"重试机制",{"type":14,"tag":112,"props":1197,"children":1198},{},[1199],{"type":19,"value":1200},"多语言支持",{"type":14,"tag":112,"props":1202,"children":1203},{},[1204],{"type":19,"value":1205},"支持任务取消",{"type":14,"tag":112,"props":1207,"children":1208},{},[1209,1211,1217],{"type":19,"value":1210},"支持按指定",{"type":14,"tag":33,"props":1212,"children":1214},{"className":1213},[],[1215],{"type":19,"value":1216},"Job Queue",{"type":19,"value":1218},"处理任务",{"type":14,"tag":112,"props":1220,"children":1221},{},[1222],{"type":19,"value":1223},"服务器端工作线程可控，即job执行并发数控制",{"type":14,"tag":112,"props":1225,"children":1226},{},[1227],{"type":19,"value":1228},"分布式部署，支持高可用",{"type":14,"tag":112,"props":1230,"children":1231},{},[1232],{"type":19,"value":1233},"良好的扩展性，如支持IOC、Hangfire Dashboard授权控制、Asp.net Core、持久化存储等",{"type":14,"tag":15,"props":1235,"children":1236},{},[1237],{"type":19,"value":1238},"说了这么多的优点，我们可以有个案例，例如秒杀场景：用户下单->订单生成->扣减库存，Hangfire对于这种分布式的应用处理也是适用的，最后会给出实现。",{"title":7,"searchDepth":1240,"depth":1240,"links":1241},2,[1242,1243,1244,1245,1246,1247,1248,1249],{"id":60,"depth":1240,"text":63},{"id":197,"depth":1240,"text":200},{"id":245,"depth":1240,"text":248},{"id":320,"depth":1240,"text":323},{"id":499,"depth":1240,"text":502},{"id":689,"depth":1240,"text":692},{"id":975,"depth":1240,"text":978},{"id":1067,"depth":1240,"text":1070,"children":1250},[1251],{"id":1134,"depth":1252,"text":1137},3,"markdown","content:dotnet:2019-11-05-quartz.md","content","dotnet/2019-11-05-quartz.md","md","2019-11-05",[1260,1270,1395,1444,1496,1509,1621],{"title":1261,"_path":1262,"children":1263},"Art","/art",[1264,1267],{"title":1265,"_path":1266},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1268,"_path":1269},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1271,"_path":1272,"children":1273},"Dotnet","/dotnet",[1274,1277,1280,1283,1286,1289,1290,1293,1296,1299,1302,1305,1308,1311,1314,1317,1320,1323,1326,1329,1332,1335,1338,1341,1344,1347,1350,1353,1356,1359,1362,1365,1368,1371,1374,1377,1380,1383,1386,1389,1392],{"title":1275,"_path":1276},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1278,"_path":1279},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1281,"_path":1282},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1284,"_path":1285},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1287,"_path":1288},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":8,"_path":4},{"title":1291,"_path":1292},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1294,"_path":1295},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1297,"_path":1298},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1300,"_path":1301},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1303,"_path":1304},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1306,"_path":1307},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1309,"_path":1310},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1312,"_path":1313},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1315,"_path":1316},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1318,"_path":1319},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1321,"_path":1322},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1324,"_path":1325},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1327,"_path":1328},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1330,"_path":1331},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1333,"_path":1334},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1336,"_path":1337},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1339,"_path":1340},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1342,"_path":1343},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1345,"_path":1346},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1348,"_path":1349},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1351,"_path":1352},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1354,"_path":1355},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1357,"_path":1358},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1360,"_path":1361},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1363,"_path":1364},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1366,"_path":1367},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1369,"_path":1370},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1372,"_path":1373},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1375,"_path":1376},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1378,"_path":1379},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1381,"_path":1382},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1384,"_path":1385},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1387,"_path":1388},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1390,"_path":1391},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1393,"_path":1394},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1396,"_path":1397,"children":1398},"Game","/game",[1399,1402,1405,1408,1411,1414,1417,1420,1423,1426,1429,1432,1435,1438,1441],{"title":1400,"_path":1401},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1403,"_path":1404},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1406,"_path":1407},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1409,"_path":1410},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1412,"_path":1413},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1415,"_path":1416},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1418,"_path":1419},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1421,"_path":1422},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1424,"_path":1425},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1427,"_path":1428},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1430,"_path":1431},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1433,"_path":1434},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1436,"_path":1437},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1439,"_path":1440},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1442,"_path":1443},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1445,"_path":1446,"children":1447},"Gyj","/gyj",[1448,1451,1454,1457,1460,1463,1466,1469,1472,1475,1478,1481,1484,1487,1490,1493],{"title":1449,"_path":1450},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1452,"_path":1453},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1455,"_path":1456},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1458,"_path":1459},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1461,"_path":1462},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1464,"_path":1465},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1467,"_path":1468},"玩法","/gyj/2022-08-22-wanfa",{"title":1470,"_path":1471},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1473,"_path":1474},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1476,"_path":1477},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1479,"_path":1480},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1482,"_path":1483},"门派内容相关","/gyj/2022-11-17-sect",{"title":1485,"_path":1486},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1488,"_path":1489},"种植","/gyj/2022-12-01-zhongzhi",{"title":1491,"_path":1492},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1494,"_path":1495},"跑商","/gyj/2023-11-01-paoshang",{"title":1497,"_path":1498,"children":1499},"Js","/js",[1500,1503,1506],{"title":1501,"_path":1502},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1504,"_path":1505},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1507,"_path":1508},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1510,"_path":1511,"children":1512},"Tool","/tool",[1513,1516,1519,1522,1525,1528,1531,1534,1537,1540,1543,1546,1549,1552,1555,1558,1561,1564,1567,1570,1573,1576,1579,1582,1585,1588,1591,1594,1597,1600,1603,1606,1609,1612,1615,1618],{"title":1514,"_path":1515},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1517,"_path":1518},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1520,"_path":1521},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1523,"_path":1524},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1526,"_path":1527},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1529,"_path":1530},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":1532,"_path":1533},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":1535,"_path":1536},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1538,"_path":1539},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1541,"_path":1542},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1544,"_path":1545},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1547,"_path":1548},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1550,"_path":1551},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1553,"_path":1554},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1556,"_path":1557},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1559,"_path":1560},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1562,"_path":1563},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1565,"_path":1566},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1568,"_path":1569},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1571,"_path":1572},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1574,"_path":1575},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1577,"_path":1578},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1580,"_path":1581},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1583,"_path":1584},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1586,"_path":1587},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1589,"_path":1590},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1592,"_path":1593},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1595,"_path":1596},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1598,"_path":1599},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1601,"_path":1602},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1604,"_path":1605},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1607,"_path":1608},"rider的使用","/tool/2022-08-02-rider-use",{"title":1610,"_path":1611},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1613,"_path":1614},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1616,"_path":1617},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1619,"_path":1620},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1622,"_path":1623,"children":1624},"Unity","/unity",[1625,1628,1631,1634,1637,1640,1643,1646,1649,1652,1655,1658,1661,1664,1667,1670,1673,1676,1679,1682,1685,1688,1691,1694,1697,1700,1703,1706,1709,1712,1715,1718,1721,1724,1727,1730,1733,1736,1739,1742,1745,1748,1751,1754,1757,1760,1763,1766,1769,1772,1775,1778,1781,1784,1787,1790,1793,1796,1799,1802,1805,1808,1811,1814,1817,1820,1823,1826,1829,1832,1835,1838],{"title":1626,"_path":1627},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":1629,"_path":1630},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":1632,"_path":1633},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":1635,"_path":1636},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":1638,"_path":1639},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":1641,"_path":1642},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":1644,"_path":1645},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":1647,"_path":1648},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":1650,"_path":1651},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":1653,"_path":1654},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":1656,"_path":1657},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":1659,"_path":1660},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":1662,"_path":1663},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":1665,"_path":1666},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":1668,"_path":1669},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":1671,"_path":1672},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":1674,"_path":1675},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":1677,"_path":1678},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":1680,"_path":1681},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":1683,"_path":1684},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":1686,"_path":1687},"技能系统","/unity/2020-02-15-skill-system",{"title":1689,"_path":1690},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":1692,"_path":1693},"角色状态设计","/unity/2020-02-17-character-states",{"title":1695,"_path":1696},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":1698,"_path":1699},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1701,"_path":1702},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1704,"_path":1705},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1707,"_path":1708},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1710,"_path":1711},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1713,"_path":1714},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1716,"_path":1717},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1719,"_path":1720},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1722,"_path":1723},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1725,"_path":1726},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1728,"_path":1729},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1731,"_path":1732},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1734,"_path":1735},"unity的addressables","/unity/2020-09-12-addressables",{"title":1737,"_path":1738},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1740,"_path":1741},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1743,"_path":1744},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1746,"_path":1747},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1749,"_path":1750},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1752,"_path":1753},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1755,"_path":1756},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1758,"_path":1759},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1761,"_path":1762},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1764,"_path":1765},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1767,"_path":1768},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1770,"_path":1771},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1773,"_path":1774},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1776,"_path":1777},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1779,"_path":1780},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1782,"_path":1783},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1785,"_path":1786},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1788,"_path":1789},"ability","/unity/2020-11-16-dotssample",{"title":1791,"_path":1792},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1794,"_path":1795},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1797,"_path":1798},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1800,"_path":1801},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1803,"_path":1804},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1806,"_path":1807},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1809,"_path":1810},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1812,"_path":1813},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1815,"_path":1816},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1818,"_path":1819},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1821,"_path":1822},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1824,"_path":1825},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1827,"_path":1828},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1830,"_path":1831},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1833,"_path":1834},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1836,"_path":1837},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1839,"_path":1840},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041478]