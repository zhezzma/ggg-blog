[{"data":1,"prerenderedAt":1090},["Reactive",2],{"content-query-naXQFxfZR0":3,"content-navigation-8C37fagqQL":508},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":502,"_id":503,"_source":504,"_file":505,"_extension":506,"date":507},"/dotnet/2020-01-05-big-little-endian","dotnet",false,"","大小端字节序(Big Endian和Little Endian)","Big Endian是指低地址存放最高有效字节（MSB），而Little Endian则是低地址存放最低有效字节（LSB）。",{"type":11,"children":12,"toc":494},"root",[13,22,27,36,41,46,56,69,80,88,93,97,104,117,127,139,148,155,160,194,202,276,282,287,291,297,302,307,316,321,327,338,346,354,362,370,378,386,391,402,413,418,426,432,437,442,447,452,457,462,473,484,489],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"那么何为字节序endia呢",[19],{"type":20,"value":21},"text","那么何为字节序（Endia）呢？",{"type":14,"tag":23,"props":24,"children":25},"p",{},[26],{"type":20,"value":9},{"type":14,"tag":23,"props":28,"children":29},{},[30],{"type":14,"tag":31,"props":32,"children":33},"strong",{},[34],{"type":20,"value":35},"大端模式",{"type":14,"tag":23,"props":37,"children":38},{},[39],{"type":20,"value":40},"所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；",{"type":14,"tag":23,"props":42,"children":43},{},[44],{"type":20,"value":45},"例子：",{"type":14,"tag":47,"props":48,"children":50},"pre",{"code":49},"0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\n\n0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\n",[51],{"type":14,"tag":52,"props":53,"children":54},"code",{"__ignoreMap":7},[55],{"type":20,"value":49},{"type":14,"tag":23,"props":57,"children":58},{},[59,61,67],{"type":20,"value":60},"在大端模式下，前32位应该这样读:",{"type":14,"tag":52,"props":62,"children":64},{"className":63},[],[65],{"type":20,"value":66}," e6 84 6c 4e",{"type":20,"value":68}," ( 假设int占4个字节)",{"type":14,"tag":23,"props":70,"children":71},{},[72,74],{"type":20,"value":73},"记忆方法: ",{"type":14,"tag":52,"props":75,"children":77},{"className":76},[],[78],{"type":20,"value":79},"地址的增长顺序与值的增长顺序相反",{"type":14,"tag":23,"props":81,"children":82},{},[83],{"type":14,"tag":31,"props":84,"children":85},{},[86],{"type":20,"value":87},"小端模式",{"type":14,"tag":23,"props":89,"children":90},{},[91],{"type":20,"value":92},"所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。",{"type":14,"tag":23,"props":94,"children":95},{},[96],{"type":20,"value":45},{"type":14,"tag":47,"props":98,"children":99},{"code":49},[100],{"type":14,"tag":52,"props":101,"children":102},{"__ignoreMap":7},[103],{"type":20,"value":49},{"type":14,"tag":23,"props":105,"children":106},{},[107,109,115],{"type":20,"value":108},"在小端模式下，前32位应该这样读: ",{"type":14,"tag":52,"props":110,"children":112},{"className":111},[],[113],{"type":20,"value":114},"4e 6c 84 e6",{"type":20,"value":116},"( 假设int占4个字节)",{"type":14,"tag":23,"props":118,"children":119},{},[120,121],{"type":20,"value":73},{"type":14,"tag":52,"props":122,"children":124},{"className":123},[],[125],{"type":20,"value":126},"地址的增长顺序与值的增长顺序相同",{"type":14,"tag":23,"props":128,"children":129},{},[130,132,137],{"type":20,"value":131},"有图有真相，举个例子，数字 ",{"type":14,"tag":31,"props":133,"children":134},{},[135],{"type":20,"value":136},"0x12345678",{"type":20,"value":138}," 在两种不同字节序CPU中的存储顺序如下图",{"type":14,"tag":23,"props":140,"children":141},{},[142],{"type":14,"tag":143,"props":144,"children":147},"img",{"alt":145,"src":146},"pic1","/images/2020-01-05-big-little-endian/20160414225024808",[],{"type":14,"tag":149,"props":150,"children":152},"h2",{"id":151},"为什么会有这样的情况呢",[153],{"type":20,"value":154},"为什么会有这样的情况呢？",{"type":14,"tag":23,"props":156,"children":157},{},[158],{"type":20,"value":159},"这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。",{"type":14,"tag":161,"props":162,"children":163},"ul",{},[164,177,189],{"type":14,"tag":165,"props":166,"children":167},"li",{},[168,170,175],{"type":20,"value":169},"Motorola的",{"type":14,"tag":31,"props":171,"children":172},{},[173],{"type":20,"value":174},"PowerPC",{"type":20,"value":176},"系列CPU采用Big Endian方式存储数据。",{"type":14,"tag":165,"props":178,"children":179},{},[180,182,187],{"type":20,"value":181},"Intel的",{"type":14,"tag":31,"props":183,"children":184},{},[185],{"type":20,"value":186},"x86",{"type":20,"value":188},"系列CPU采用Little Endian方式存储数据。",{"type":14,"tag":165,"props":190,"children":191},{},[192],{"type":20,"value":193},"ARM既可以工作在大端模式，也可以工作在小端模式。",{"type":14,"tag":23,"props":195,"children":196},{},[197],{"type":14,"tag":31,"props":198,"children":199},{},[200],{"type":20,"value":201},"再来说说，一些我所收集到的情况吧。",{"type":14,"tag":161,"props":203,"children":204},{},[205,217,228,240,252],{"type":14,"tag":165,"props":206,"children":207},{},[208,210,215],{"type":20,"value":209},"Windos(x86,x64)和Linux(x86,x64)都是",{"type":14,"tag":31,"props":211,"children":212},{},[213],{"type":20,"value":214},"Little Endian",{"type":20,"value":216},"操作系统",{"type":14,"tag":165,"props":218,"children":219},{},[220,222,226],{"type":20,"value":221},"在ARM上，我见到的都是用",{"type":14,"tag":31,"props":223,"children":224},{},[225],{"type":20,"value":214},{"type":20,"value":227},"方式存储数据。",{"type":14,"tag":165,"props":229,"children":230},{},[231,233,238],{"type":20,"value":232},"C/C++语言编写的程序里数据存储顺序是跟编译平台",{"type":14,"tag":31,"props":234,"children":235},{},[236],{"type":20,"value":237},"所在的CPU相关",{"type":20,"value":239},"的。",{"type":14,"tag":165,"props":241,"children":242},{},[243,245,250],{"type":20,"value":244},"JAVA编写的程序则唯一采用",{"type":14,"tag":31,"props":246,"children":247},{},[248],{"type":20,"value":249},"Big Endian",{"type":20,"value":251},"方式来存储数据。",{"type":14,"tag":165,"props":253,"children":254},{},[255,257,261,263,267,269,274],{"type":20,"value":256},"所有网络协议也都是采用",{"type":14,"tag":31,"props":258,"children":259},{},[260],{"type":20,"value":249},{"type":20,"value":262},"的方式来传输数据的。所以有时我们也会把",{"type":14,"tag":31,"props":264,"children":265},{},[266],{"type":20,"value":249},{"type":20,"value":268},"方式称之为",{"type":14,"tag":31,"props":270,"children":271},{},[272],{"type":20,"value":273},"网络字节序",{"type":20,"value":275},"。",{"type":14,"tag":149,"props":277,"children":279},{"id":278},"为什么要注意字节序的问题呢",[280],{"type":20,"value":281},"为什么要注意字节序的问题呢？",{"type":14,"tag":23,"props":283,"children":284},{},[285],{"type":20,"value":286},"你可能这么问。当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？尤其是当你把你在微机上运算的结果运用到计算机群上去的话。在这里我想说说两种语言。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的 0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。什么？竟然变成另外一个数字了？是的，就是这种后果。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。",{"type":14,"tag":15,"props":288,"children":289},{"id":273},[290],{"type":20,"value":273},{"type":14,"tag":149,"props":292,"children":294},{"id":293},"一在进行网络通信时是否需要进行字节序转换",[295],{"type":20,"value":296},"一、在进行网络通信时是否需要进行字节序转换？",{"type":14,"tag":23,"props":298,"children":299},{},[300],{"type":20,"value":301},"相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。",{"type":14,"tag":23,"props":303,"children":304},{},[305],{"type":20,"value":306},"原因如下：网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。",{"type":14,"tag":149,"props":308,"children":310},{"id":309},"二网络字节序",[311],{"type":14,"tag":31,"props":312,"children":313},{},[314],{"type":20,"value":315},"二、网络字节序",{"type":14,"tag":23,"props":317,"children":318},{},[319],{"type":20,"value":320},"​    网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;",{"type":14,"tag":15,"props":322,"children":324},{"id":323},"c-大端转换",[325],{"type":20,"value":326},"c# 大端转换",{"type":14,"tag":23,"props":328,"children":329},{},[330,332,336],{"type":20,"value":331},"c#在windows平台上是小端字节序(Windos(x86,x64)和Linux(x86,x64)都是",{"type":14,"tag":31,"props":333,"children":334},{},[335],{"type":20,"value":214},{"type":20,"value":337},"操作系统,不止是c#)。网络发送字节流是按大端序发送，也就是从左到右发送，和c#的小端序相反，造成网关不能正常识别协议。所以需要转换",{"type":14,"tag":23,"props":339,"children":340},{},[341],{"type":14,"tag":31,"props":342,"children":343},{},[344],{"type":20,"value":345},"大小端转换",{"type":14,"tag":47,"props":347,"children":349},{"code":348},"int x = 439041118;  // 十六进制为 1A2B3C5E\n\nstring s = null;\n\nbyte[] b = BitConverter.GetBytes( x );\n\ns = BitConverter.ToString( b ); // 小端模式\nConsole.WriteLine( s ); // 小端输出 为 5E-3C-2B-1A\n\nArray.Reverse( b ); // 反转\n\ns = BitConverter.ToString( b ); // 大端模式\nConsole.WriteLine( \"{0:x}\", s ); // 大端输出 为 1A-2B-3C-5E\n\nConsole.ReadKey();\n",[350],{"type":14,"tag":52,"props":351,"children":352},{"__ignoreMap":7},[353],{"type":20,"value":348},{"type":14,"tag":23,"props":355,"children":356},{},[357],{"type":14,"tag":31,"props":358,"children":359},{},[360],{"type":20,"value":361},"C# 判断数据在此计算机结构中存储时的字节顺序（“Endian”性质），即大端还是小端",{"type":14,"tag":47,"props":363,"children":365},{"code":364},"int data = 439041118; // 十六进制为 1A2B3C5E\nbyte[] bData = BitConverter.GetBytes( data );\n            \nif (BitConverter.IsLittleEndian) // 若为 小端模式\n{\n   Array.Reverse( bData ); // 转换为 大端模式               \n}\nstring s = BitConverter.ToString( bData );\n\nConsole.WriteLine(s);\n\nConsole.ReadKey();\n",[366],{"type":14,"tag":52,"props":367,"children":368},{"__ignoreMap":7},[369],{"type":20,"value":364},{"type":14,"tag":23,"props":371,"children":372},{},[373],{"type":14,"tag":31,"props":374,"children":375},{},[376],{"type":20,"value":377},"一些封装",{"type":14,"tag":47,"props":379,"children":381},{"code":380},"\n//翻转byte数组\npublic static void ReverseBytes(byte[] bytes)\n{\n    byte tmp;\n    int len = bytes.Length;\n\n    for (int i = 0; i \u003C len / 2; i++ )\n    {\n        tmp = bytes[len - 1 - i];\n        bytes[len - 1 - i] = bytes[i];\n        bytes[i] = tmp;\n    }\n}\n\n//规定转换起始位置和长度\n public static void ReverseBytes(byte[] bytes, int start, int len)\n {\n     int end = start + len - 1;\n     byte tmp;\n     int i = 0;\n     for (int index = start; index \u003C start + len/2; index++,i++)\n     {\n         tmp = bytes[end - i];\n         bytes[end - i] = bytes[index];\n         bytes[index] = tmp;\n     }\n }\n\n// 翻转字节顺序 (16-bit)\npublic static UInt16 ReverseBytes(UInt16 value)\n{\n  return (UInt16)((value & 0xFFU) \u003C\u003C 8 | (value & 0xFF00U) >> 8);\n}\n\n\n// 翻转字节顺序 (32-bit)\npublic static UInt32 ReverseBytes(UInt32 value)\n{\n  return (value & 0x000000FFU) \u003C\u003C 24 | (value & 0x0000FF00U) \u003C\u003C 8 |\n         (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;\n}\n\n\n// 翻转字节顺序 (64-bit)\npublic static UInt64 ReverseBytes(UInt64 value)\n{\n  return (value & 0x00000000000000FFUL) \u003C\u003C 56 | (value & 0x000000000000FF00UL) \u003C\u003C 40 |\n         (value & 0x0000000000FF0000UL) \u003C\u003C 24 | (value & 0x00000000FF000000UL) \u003C\u003C 8 |\n         (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |\n         (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;\n}\n",[382],{"type":14,"tag":52,"props":383,"children":384},{"__ignoreMap":7},[385],{"type":20,"value":380},{"type":14,"tag":23,"props":387,"children":388},{},[389],{"type":20,"value":390},"另外c#直接提供了网络字节序转换方法。",{"type":14,"tag":23,"props":392,"children":393},{},[394,400],{"type":14,"tag":52,"props":395,"children":397},{"className":396},[],[398],{"type":20,"value":399},"System.Net.IPAddress.HostToNetworkOrder",{"type":20,"value":401},"（本机到网络转换）",{"type":14,"tag":23,"props":403,"children":404},{},[405,411],{"type":14,"tag":52,"props":406,"children":408},{"className":407},[],[409],{"type":20,"value":410},"System.Net.IPAddress.NetworkToHostOrder",{"type":20,"value":412},"(网络字节转成本机)",{"type":14,"tag":23,"props":414,"children":415},{},[416],{"type":20,"value":417},"推荐使用这种方法，简单有效。",{"type":14,"tag":47,"props":419,"children":421},{"code":420},"short x = 6;\nshort b = System.Net.IPAddress.HostToNetworkOrder(x); //把x转成相应的大端字节数\nbyte[] bb = System.BitConverter.GetBytes(b);//这样直接取到的就是大端字节序字节数组。\n",[422],{"type":14,"tag":52,"props":423,"children":424},{"__ignoreMap":7},[425],{"type":20,"value":420},{"type":14,"tag":149,"props":427,"children":429},{"id":428},"对于字符串型",[430],{"type":20,"value":431},"对于字符串型：",{"type":14,"tag":23,"props":433,"children":434},{},[435],{"type":20,"value":436},"使用 System.Text.Encoding.Default.GetBytes();直接取字串对应字节数组。",{"type":14,"tag":23,"props":438,"children":439},{},[440],{"type":20,"value":441},"不知道为什么这个方法取到的直接就是大端字节数组。不用转换。",{"type":14,"tag":23,"props":443,"children":444},{},[445],{"type":20,"value":446},"后来查了一下，关于字串的字节序问题，因为gbk和utf-8都是以单个字节表示数字的，所以不存在字节序问题，在多个不同系统架构都用。对于utf-16，则是以双字节表示一个整数，所以为会有字节序问题，分大小端unicode。",{"type":14,"tag":23,"props":448,"children":449},{},[450],{"type":20,"value":451},"System.Text.Encoding.Default.GetBytes();在我的简体中文系统上是以gb2312的编码，也就是单个字来进行编码的，所以也不会有字节序问题。",{"type":14,"tag":23,"props":453,"children":454},{},[455],{"type":20,"value":456},"补充：“**对于任何字符编码，编码单元的顺序是由编码方案指定的，与endian无关。**例如GBK的编码单元是字节，用两个字节表示一个汉字。这两个字节的顺序是固定的，不受CPU字节序的影响。UTF-16的编码单元是word（双字节），word之间的顺序是编码方案指定的，word内部的字节排列才会受到endian的影响。”，",{"type":14,"tag":23,"props":458,"children":459},{},[460],{"type":20,"value":461},"所以utf-8也没有字节序的问题。字节序问题之存在于需要使用两个字节以上来表示整数。而UTF-8只是一串字节流，不存在字节序问题，不过将这些字节流翻译成Unicode比其他的传输方式复杂。以字节为单位编码的，无论一个汉字是多少个字节，都无字节序问题。",{"type":14,"tag":23,"props":463,"children":464},{},[465,467],{"type":20,"value":466},"你注意，字节序问题不是指多个字节传输的先后，这个是固定的无异议的。而是指一个多字节编码在机器中的表示方式问题。\n",{"type":14,"tag":52,"props":468,"children":470},{"className":469},[],[471],{"type":20,"value":472},"char str[] = \"abaksdkakskasklasflk\"；",{"type":14,"tag":23,"props":474,"children":475},{},[476,478],{"type":20,"value":477},"这个无字节序问题。但\n",{"type":14,"tag":52,"props":479,"children":481},{"className":480},[],[482],{"type":20,"value":483},"int  str[] = {0x11223344, 2, 3 }",{"type":14,"tag":23,"props":485,"children":486},{},[487],{"type":20,"value":488},"就有字节序问题了。因为str[0]同样数值不同机器中表示不同。",{"type":14,"tag":23,"props":490,"children":491},{},[492],{"type":20,"value":493},"而剩下的， 就是字符编码内部的字节序了。比如UTF-16是用两个字节表示一个字符，但是这两个字节内部如何排序，系统并不知道，所以必须指定字节序。但是UTF-8由于几个字节表示并不相同，一定要从那个表示长度的字节开始读，相当于一开始就知道该从哪里是队头队尾，所以不存在字节序问题。",{"title":7,"searchDepth":495,"depth":495,"links":496},2,[497,498,499,500,501],{"id":151,"depth":495,"text":154},{"id":278,"depth":495,"text":281},{"id":293,"depth":495,"text":296},{"id":309,"depth":495,"text":315},{"id":428,"depth":495,"text":431},"markdown","content:dotnet:2020-01-05-big-little-endian.md","content","dotnet/2020-01-05-big-little-endian.md","md","2020-01-05",[509,519,644,693,745,758,870],{"title":510,"_path":511,"children":512},"Art","/art",[513,516],{"title":514,"_path":515},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":517,"_path":518},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":520,"_path":521,"children":522},"Dotnet","/dotnet",[523,526,529,532,535,538,541,544,545,548,551,554,557,560,563,566,569,572,575,578,581,584,587,590,593,596,599,602,605,608,611,614,617,620,623,626,629,632,635,638,641],{"title":524,"_path":525},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":527,"_path":528},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":530,"_path":531},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":533,"_path":534},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":536,"_path":537},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":539,"_path":540},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":542,"_path":543},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":8,"_path":4},{"title":546,"_path":547},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":549,"_path":550},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":552,"_path":553},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":555,"_path":556},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":558,"_path":559},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":561,"_path":562},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":564,"_path":565},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":567,"_path":568},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":570,"_path":571},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":573,"_path":574},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":576,"_path":577},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":579,"_path":580},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":582,"_path":583},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":585,"_path":586},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":588,"_path":589},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":591,"_path":592},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":594,"_path":595},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":597,"_path":598},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":600,"_path":601},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":603,"_path":604},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":606,"_path":607},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":609,"_path":610},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":612,"_path":613},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":615,"_path":616},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":618,"_path":619},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":621,"_path":622},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":624,"_path":625},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":627,"_path":628},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":630,"_path":631},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":633,"_path":634},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":636,"_path":637},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":639,"_path":640},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":642,"_path":643},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":645,"_path":646,"children":647},"Game","/game",[648,651,654,657,660,663,666,669,672,675,678,681,684,687,690],{"title":649,"_path":650},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":652,"_path":653},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":655,"_path":656},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":658,"_path":659},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":661,"_path":662},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":664,"_path":665},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":667,"_path":668},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":670,"_path":671},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":673,"_path":674},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":676,"_path":677},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":679,"_path":680},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":682,"_path":683},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":685,"_path":686},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":688,"_path":689},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":691,"_path":692},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":694,"_path":695,"children":696},"Gyj","/gyj",[697,700,703,706,709,712,715,718,721,724,727,730,733,736,739,742],{"title":698,"_path":699},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":701,"_path":702},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":704,"_path":705},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":707,"_path":708},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":710,"_path":711},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":713,"_path":714},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":716,"_path":717},"玩法","/gyj/2022-08-22-wanfa",{"title":719,"_path":720},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":722,"_path":723},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":725,"_path":726},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":728,"_path":729},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":731,"_path":732},"门派内容相关","/gyj/2022-11-17-sect",{"title":734,"_path":735},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":737,"_path":738},"种植","/gyj/2022-12-01-zhongzhi",{"title":740,"_path":741},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":743,"_path":744},"跑商","/gyj/2023-11-01-paoshang",{"title":746,"_path":747,"children":748},"Js","/js",[749,752,755],{"title":750,"_path":751},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":753,"_path":754},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":756,"_path":757},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":759,"_path":760,"children":761},"Tool","/tool",[762,765,768,771,774,777,780,783,786,789,792,795,798,801,804,807,810,813,816,819,822,825,828,831,834,837,840,843,846,849,852,855,858,861,864,867],{"title":763,"_path":764},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":766,"_path":767},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":769,"_path":770},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":772,"_path":773},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":775,"_path":776},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":778,"_path":779},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":781,"_path":782},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":784,"_path":785},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":787,"_path":788},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":790,"_path":791},"mac下brew 使用","/tool/2020-01-13-brew",{"title":793,"_path":794},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":796,"_path":797},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":799,"_path":800},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":802,"_path":803},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":805,"_path":806},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":808,"_path":809},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":811,"_path":812},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":814,"_path":815},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":817,"_path":818},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":820,"_path":821},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":823,"_path":824},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":826,"_path":827},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":829,"_path":830},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":832,"_path":833},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":835,"_path":836},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":838,"_path":839},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":841,"_path":842},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":844,"_path":845},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":847,"_path":848},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":850,"_path":851},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":853,"_path":854},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":856,"_path":857},"rider的使用","/tool/2022-08-02-rider-use",{"title":859,"_path":860},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":862,"_path":863},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":865,"_path":866},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":868,"_path":869},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":871,"_path":872,"children":873},"Unity","/unity",[874,877,880,883,886,889,892,895,898,901,904,907,910,913,916,919,922,925,928,931,934,937,940,943,946,949,952,955,958,961,964,967,970,973,976,979,982,985,988,991,994,997,1000,1003,1006,1009,1012,1015,1018,1021,1024,1027,1030,1033,1036,1039,1042,1045,1048,1051,1054,1057,1060,1063,1066,1069,1072,1075,1078,1081,1084,1087],{"title":875,"_path":876},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":878,"_path":879},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":881,"_path":882},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":884,"_path":885},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":887,"_path":888},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":890,"_path":891},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":893,"_path":894},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":896,"_path":897},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":899,"_path":900},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":902,"_path":903},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":905,"_path":906},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":908,"_path":909},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":911,"_path":912},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":914,"_path":915},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":917,"_path":918},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":920,"_path":921},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":923,"_path":924},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":926,"_path":927},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":929,"_path":930},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":932,"_path":933},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":935,"_path":936},"技能系统","/unity/2020-02-15-skill-system",{"title":938,"_path":939},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":941,"_path":942},"角色状态设计","/unity/2020-02-17-character-states",{"title":944,"_path":945},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":947,"_path":948},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":950,"_path":951},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":953,"_path":954},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":956,"_path":957},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":959,"_path":960},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":962,"_path":963},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":965,"_path":966},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":968,"_path":969},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":971,"_path":972},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":974,"_path":975},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":977,"_path":978},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":980,"_path":981},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":983,"_path":984},"unity的addressables","/unity/2020-09-12-addressables",{"title":986,"_path":987},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":989,"_path":990},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":992,"_path":993},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":995,"_path":996},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":998,"_path":999},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1001,"_path":1002},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1004,"_path":1005},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1007,"_path":1008},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1010,"_path":1011},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1013,"_path":1014},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1016,"_path":1017},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1019,"_path":1020},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1022,"_path":1023},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1025,"_path":1026},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1028,"_path":1029},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1031,"_path":1032},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1034,"_path":1035},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1037,"_path":1038},"ability","/unity/2020-11-16-dotssample",{"title":1040,"_path":1041},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1043,"_path":1044},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1046,"_path":1047},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1049,"_path":1050},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1052,"_path":1053},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1055,"_path":1056},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1058,"_path":1059},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1061,"_path":1062},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1064,"_path":1065},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1067,"_path":1068},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1070,"_path":1071},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1073,"_path":1074},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1076,"_path":1077},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1079,"_path":1080},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1082,"_path":1083},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1085,"_path":1086},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1088,"_path":1089},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041377]