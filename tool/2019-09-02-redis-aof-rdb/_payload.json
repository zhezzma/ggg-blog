[{"data":1,"prerenderedAt":2215},["Reactive",2],{"content-query-AFWYRmA84a":3,"content-navigation-8C37fagqQL":1633},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":1627,"_id":1628,"_source":1629,"_file":1630,"_extension":1631,"date":1632},"/tool/2019-09-02-redis-aof-rdb","tool",false,"","Redis的两种持久化RDB和AOF","Redis 分别提供了 RDB 和 AOF 两种持久化机制：",{"type":11,"children":12,"toc":1605},"root",[13,20,35,43,48,53,58,74,83,90,96,114,119,136,143,148,153,163,168,176,181,186,194,208,213,248,253,258,263,283,296,348,353,358,366,371,378,383,388,418,439,457,465,470,475,499,504,517,529,548,553,559,564,600,605,610,623,628,646,651,656,661,686,698,744,749,756,761,766,771,776,781,786,792,797,802,841,846,851,856,861,866,868,980,986,991,996,1001,1024,1029,1034,1039,1047,1052,1060,1080,1115,1120,1126,1131,1136,1144,1156,1161,1166,1171,1177,1182,1194,1201,1220,1240,1253,1261,1281,1286,1291,1299,1305,1310,1315,1328,1333,1338,1345,1350,1368,1373,1386,1391,1404,1409,1414,1419,1433,1439,1451,1456,1495,1508,1554,1567,1572],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":21,"props":22,"children":23},"ul",{},[24,30],{"type":14,"tag":25,"props":26,"children":27},"li",{},[28],{"type":19,"value":29},"RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。",{"type":14,"tag":25,"props":31,"children":32},{},[33],{"type":19,"value":34},"AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。",{"type":14,"tag":15,"props":36,"children":37},{},[38],{"type":14,"tag":39,"props":40,"children":42},"img",{"alt":7,"src":41},"/images/2019-09-02-redis-aof-rdb/graphviz-a7c5f2bb064f2c0307d15dca06d7d31d3adfc032.svg",[],{"type":14,"tag":15,"props":44,"children":45},{},[46],{"type":19,"value":47},"本章首先介绍 AOF 功能的运作机制， 了解命令是如何被保存到 AOF 文件里的， 观察不同的 AOF 保存模式对数据的安全性、以及 Redis 性能的影响。",{"type":14,"tag":15,"props":49,"children":50},{},[51],{"type":19,"value":52},"之后会介绍从 AOF 文件中恢复数据库状态的方法，以及该方法背后的实现机制。",{"type":14,"tag":15,"props":54,"children":55},{},[56],{"type":19,"value":57},"最后还会介绍对 AOF 进行重写以调整文件体积的方法， 并研究这种方法是如何在不改变数据库状态的前提下进行的。",{"type":14,"tag":15,"props":59,"children":60},{},[61,63,72],{"type":19,"value":62},"因为本章涉及 AOF 运行的相关机制， 如果还没了解过 AOF 功能的话， 请先阅读 ",{"type":14,"tag":64,"props":65,"children":69},"a",{"href":66,"rel":67},"http://redis.io/topics/persistence",[68],"nofollow",[70],{"type":19,"value":71},"Redis 持久化手册中关于 AOF 的部分",{"type":19,"value":73}," 。",{"type":14,"tag":15,"props":75,"children":76},{},[77],{"type":14,"tag":78,"props":79,"children":80},"strong",{},[81],{"type":19,"value":82},"无论是rdb还是aof都是把存储的文件恢复到内存中",{"type":14,"tag":84,"props":85,"children":87},"h1",{"id":86},"rdb优点与缺点",[88],{"type":19,"value":89},"RDB优点与缺点",{"type":14,"tag":91,"props":92,"children":94},"h3",{"id":93},"优点",[95],{"type":19,"value":93},{"type":14,"tag":21,"props":97,"children":98},{},[99,104,109],{"type":14,"tag":25,"props":100,"children":101},{},[102],{"type":19,"value":103},"如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。",{"type":14,"tag":25,"props":105,"children":106},{},[107],{"type":19,"value":108},"RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。",{"type":14,"tag":25,"props":110,"children":111},{},[112],{"type":19,"value":113},"RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。",{"type":14,"tag":91,"props":115,"children":117},{"id":116},"缺点",[118],{"type":19,"value":116},{"type":14,"tag":21,"props":120,"children":121},{},[122,127],{"type":14,"tag":25,"props":123,"children":124},{},[125],{"type":19,"value":126},"RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。",{"type":14,"tag":25,"props":128,"children":129},{},[130,132],{"type":19,"value":131},"每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。\n",{"type":14,"tag":39,"props":133,"children":135},{"alt":39,"src":134},"/images/2019-09-02-redis-aof-rdb/20181004174024768.png",[],{"type":14,"tag":137,"props":138,"children":140},"h2",{"id":139},"aof-命令同步",[141],{"type":19,"value":142},"AOF 命令同步",{"type":14,"tag":15,"props":144,"children":145},{},[146],{"type":19,"value":147},"Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的， 为了方便起见， 我们称呼这种记录过程为同步。",{"type":14,"tag":15,"props":149,"children":150},{},[151],{"type":19,"value":152},"举个例子， 如果执行以下命令：",{"type":14,"tag":154,"props":155,"children":157},"pre",{"code":156},"redis> RPUSH list 1 2 3 4\n(integer) 4\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n\nredis> KEYS *\n1) \"list\"\n\nredis> RPOP list\n\"4\"\n\nredis> LPOP list\n\"1\"\n\nredis> LPUSH list 1\n(integer) 3\n\nredis> LRANGE list 0 -1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n",[158],{"type":14,"tag":159,"props":160,"children":161},"code",{"__ignoreMap":7},[162],{"type":19,"value":156},{"type":14,"tag":15,"props":164,"children":165},{},[166],{"type":19,"value":167},"那么其中四条对数据库有修改的写入命令就会被同步到 AOF 文件中：",{"type":14,"tag":154,"props":169,"children":171},{"code":170},"RPUSH list 1 2 3 4\n\nRPOP list\n\nLPOP list\n\nLPUSH list 1\n",[172],{"type":14,"tag":159,"props":173,"children":174},{"__ignoreMap":7},[175],{"type":19,"value":170},{"type":14,"tag":15,"props":177,"children":178},{},[179],{"type":19,"value":180},"为了处理的方便， AOF 文件使用网络通讯协议的格式来保存这些命令。",{"type":14,"tag":15,"props":182,"children":183},{},[184],{"type":19,"value":185},"比如说， 上面列举的四个命令在 AOF 文件中就实际保存如下：",{"type":14,"tag":154,"props":187,"children":189},{"code":188},"*2\n$6\nSELECT\n$1\n0\n*6\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n*2\n$4\nRPOP\n$4\nlist\n*2\n$4\nLPOP\n$4\nlist\n*3\n$5\nLPUSH\n$4\nlist\n$1\n1\n",[190],{"type":14,"tag":159,"props":191,"children":192},{"__ignoreMap":7},[193],{"type":19,"value":188},{"type":14,"tag":15,"props":195,"children":196},{},[197,199,206],{"type":19,"value":198},"除了 ",{"type":14,"tag":64,"props":200,"children":203},{"href":201,"rel":202},"http://redis.readthedocs.org/en/latest/connection/select.html#select",[68],[204],{"type":19,"value":205},"SELECT",{"type":19,"value":207}," 命令是 AOF 程序自己加上去的之外， 其他命令都是之前我们在终端里执行的命令。",{"type":14,"tag":15,"props":209,"children":210},{},[211],{"type":19,"value":212},"同步命令到 AOF 文件的整个过程可以分为三个阶段：",{"type":14,"tag":214,"props":215,"children":216},"ol",{},[217,222,227],{"type":14,"tag":25,"props":218,"children":219},{},[220],{"type":19,"value":221},"命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。",{"type":14,"tag":25,"props":223,"children":224},{},[225],{"type":19,"value":226},"缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。",{"type":14,"tag":25,"props":228,"children":229},{},[230,232,238,240,246],{"type":19,"value":231},"文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， ",{"type":14,"tag":159,"props":233,"children":235},{"className":234},[],[236],{"type":19,"value":237},"fsync",{"type":19,"value":239}," 函数或者 ",{"type":14,"tag":159,"props":241,"children":243},{"className":242},[],[244],{"type":19,"value":245},"fdatasync",{"type":19,"value":247}," 函数会被调用，将写入的内容真正地保存到磁盘中。",{"type":14,"tag":15,"props":249,"children":250},{},[251],{"type":19,"value":252},"以下几个小节将详细地介绍这三个步骤。",{"type":14,"tag":137,"props":254,"children":256},{"id":255},"命令传播",[257],{"type":19,"value":255},{"type":14,"tag":15,"props":259,"children":260},{},[261],{"type":19,"value":262},"当一个 Redis 客户端需要执行命令时， 它通过网络连接， 将协议文本发送给 Redis 服务器。",{"type":14,"tag":15,"props":264,"children":265},{},[266,268,274,276,282],{"type":19,"value":267},"比如说， 要执行命令 ",{"type":14,"tag":159,"props":269,"children":271},{"className":270},[],[272],{"type":19,"value":273},"SET KEY VALUE",{"type":19,"value":275}," ， 客户端将向服务器发送文本 ",{"type":14,"tag":159,"props":277,"children":279},{"className":278},[],[280],{"type":19,"value":281},"\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n\"",{"type":19,"value":73},{"type":14,"tag":15,"props":284,"children":285},{},[286,288,294],{"type":19,"value":287},"服务器在接到客户端的请求之后， 它会根据协议文本的内容， 选择适当的命令函数， 并将各个参数从字符串文本转换为 Redis 字符串对象（",{"type":14,"tag":159,"props":289,"children":291},{"className":290},[],[292],{"type":19,"value":293},"StringObject",{"type":19,"value":295},"）。",{"type":14,"tag":15,"props":297,"children":298},{},[299,301,308,310,315,317,323,325,330,332,338,340,346],{"type":19,"value":300},"比如说， 针对上面的 ",{"type":14,"tag":64,"props":302,"children":305},{"href":303,"rel":304},"http://redis.readthedocs.org/en/latest/string/set.html#set",[68],[306],{"type":19,"value":307},"SET",{"type":19,"value":309}," 命令例子， Redis 将客户端的命令指针指向实现 ",{"type":14,"tag":64,"props":311,"children":313},{"href":303,"rel":312},[68],[314],{"type":19,"value":307},{"type":19,"value":316}," 命令的 ",{"type":14,"tag":159,"props":318,"children":320},{"className":319},[],[321],{"type":19,"value":322},"setCommand",{"type":19,"value":324}," 函数， 并创建三个 Redis 字符串对象， 分别保存 ",{"type":14,"tag":159,"props":326,"children":328},{"className":327},[],[329],{"type":19,"value":307},{"type":19,"value":331}," 、 ",{"type":14,"tag":159,"props":333,"children":335},{"className":334},[],[336],{"type":19,"value":337},"KEY",{"type":19,"value":339}," 和 ",{"type":14,"tag":159,"props":341,"children":343},{"className":342},[],[344],{"type":19,"value":345},"VALUE",{"type":19,"value":347}," 三个参数（命令也算作参数）。",{"type":14,"tag":15,"props":349,"children":350},{},[351],{"type":19,"value":352},"每当命令函数成功执行之后， 命令参数都会被传播到 AOF 程序， 以及 REPLICATION 程序（本节不讨论这个，列在这里只是为了完整性的考虑）。",{"type":14,"tag":15,"props":354,"children":355},{},[356],{"type":19,"value":357},"这个执行并传播命令的过程可以用以下伪代码表示：",{"type":14,"tag":154,"props":359,"children":361},{"code":360},"if (execRedisCommand(cmd, argv, argc) == EXEC_SUCCESS):\n\n    if aof_is_turn_on():\n        # 传播命令到 AOF 程序\n        propagate_aof(cmd, argv, argc)\n\n    if replication_is_turn_on():\n        # 传播命令到 REPLICATION 程序\n        propagate_replication(cmd, argv, argc)\n",[362],{"type":14,"tag":159,"props":363,"children":364},{"__ignoreMap":7},[365],{"type":19,"value":360},{"type":14,"tag":15,"props":367,"children":368},{},[369],{"type":19,"value":370},"以下是该过程的流程图：",{"type":14,"tag":15,"props":372,"children":373},{},[374],{"type":14,"tag":39,"props":375,"children":377},{"alt":7,"src":376},"/images/2019-09-02-redis-aof-rdb/graphviz-a5c804211267a10a5c3ffa47c5b600727191a3be.svg",[],{"type":14,"tag":137,"props":379,"children":381},{"id":380},"缓存追加",[382],{"type":19,"value":380},{"type":14,"tag":15,"props":384,"children":385},{},[386],{"type":19,"value":387},"当命令被传播到 AOF 程序之后， 程序会根据命令以及命令的参数， 将命令从字符串对象转换回原来的协议文本。",{"type":14,"tag":15,"props":389,"children":390},{},[391,393,398,399,404,405,410,412,417],{"type":19,"value":392},"比如说， 如果 AOF 程序接受到的三个参数分别保存着 ",{"type":14,"tag":159,"props":394,"children":396},{"className":395},[],[397],{"type":19,"value":307},{"type":19,"value":331},{"type":14,"tag":159,"props":400,"children":402},{"className":401},[],[403],{"type":19,"value":337},{"type":19,"value":339},{"type":14,"tag":159,"props":406,"children":408},{"className":407},[],[409],{"type":19,"value":345},{"type":19,"value":411}," 三个字符串， 那么它将生成协议文本 ",{"type":14,"tag":159,"props":413,"children":415},{"className":414},[],[416],{"type":19,"value":281},{"type":19,"value":73},{"type":14,"tag":15,"props":419,"children":420},{},[421,423,429,431,437],{"type":19,"value":422},"协议文本生成之后， 它会被追加到 ",{"type":14,"tag":159,"props":424,"children":426},{"className":425},[],[427],{"type":19,"value":428},"redis.h/redisServer",{"type":19,"value":430}," 结构的 ",{"type":14,"tag":159,"props":432,"children":434},{"className":433},[],[435],{"type":19,"value":436},"aof_buf",{"type":19,"value":438}," 末尾。",{"type":14,"tag":15,"props":440,"children":441},{},[442,448,450,455],{"type":14,"tag":159,"props":443,"children":445},{"className":444},[],[446],{"type":19,"value":447},"redisServer",{"type":19,"value":449}," 结构维持着 Redis 服务器的状态， ",{"type":14,"tag":159,"props":451,"children":453},{"className":452},[],[454],{"type":19,"value":436},{"type":19,"value":456}," 域则保存着所有等待写入到 AOF 文件的协议文本：",{"type":14,"tag":154,"props":458,"children":460},{"code":459},"struct redisServer {\n\n    // 其他域...\n\n    sds aof_buf;\n\n    // 其他域...\n};\n",[461],{"type":14,"tag":159,"props":462,"children":463},{"__ignoreMap":7},[464],{"type":19,"value":459},{"type":14,"tag":15,"props":466,"children":467},{},[468],{"type":19,"value":469},"至此， 追加命令到缓存的步骤执行完毕。",{"type":14,"tag":15,"props":471,"children":472},{},[473],{"type":19,"value":474},"综合起来，整个缓存追加过程可以分为以下三步：",{"type":14,"tag":214,"props":476,"children":477},{},[478,483,488],{"type":14,"tag":25,"props":479,"children":480},{},[481],{"type":19,"value":482},"接受命令、命令的参数、以及参数的个数、所使用的数据库等信息。",{"type":14,"tag":25,"props":484,"children":485},{},[486],{"type":19,"value":487},"将命令还原成 Redis 网络通讯协议。",{"type":14,"tag":25,"props":489,"children":490},{},[491,493,498],{"type":19,"value":492},"将协议文本追加到 ",{"type":14,"tag":159,"props":494,"children":496},{"className":495},[],[497],{"type":19,"value":436},{"type":19,"value":438},{"type":14,"tag":137,"props":500,"children":502},{"id":501},"文件写入和保存",[503],{"type":19,"value":501},{"type":14,"tag":15,"props":505,"children":506},{},[507,509,515],{"type":19,"value":508},"每当服务器常规任务函数被执行、 或者事件处理器被执行时， ",{"type":14,"tag":159,"props":510,"children":512},{"className":511},[],[513],{"type":19,"value":514},"aof.c/flushAppendOnlyFile",{"type":19,"value":516}," 函数都会被调用， 这个函数执行以下两个工作：",{"type":14,"tag":15,"props":518,"children":519},{},[520,522,527],{"type":19,"value":521},"WRITE：根据条件，将 ",{"type":14,"tag":159,"props":523,"children":525},{"className":524},[],[526],{"type":19,"value":436},{"type":19,"value":528}," 中的缓存写入到 AOF 文件。",{"type":14,"tag":15,"props":530,"children":531},{},[532,534,539,541,546],{"type":19,"value":533},"SAVE：根据条件，调用 ",{"type":14,"tag":159,"props":535,"children":537},{"className":536},[],[538],{"type":19,"value":237},{"type":19,"value":540}," 或 ",{"type":14,"tag":159,"props":542,"children":544},{"className":543},[],[545],{"type":19,"value":245},{"type":19,"value":547}," 函数，将 AOF 文件保存到磁盘中。",{"type":14,"tag":15,"props":549,"children":550},{},[551],{"type":19,"value":552},"两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。",{"type":14,"tag":137,"props":554,"children":556},{"id":555},"aof-保存模式",[557],{"type":19,"value":558},"AOF 保存模式",{"type":14,"tag":15,"props":560,"children":561},{},[562],{"type":19,"value":563},"Redis 目前支持三种 AOF 保存模式，它们分别是：",{"type":14,"tag":214,"props":565,"children":566},{},[567,578,589],{"type":14,"tag":25,"props":568,"children":569},{},[570,576],{"type":14,"tag":159,"props":571,"children":573},{"className":572},[],[574],{"type":19,"value":575},"AOF_FSYNC_NO",{"type":19,"value":577}," ：不保存。",{"type":14,"tag":25,"props":579,"children":580},{},[581,587],{"type":14,"tag":159,"props":582,"children":584},{"className":583},[],[585],{"type":19,"value":586},"AOF_FSYNC_EVERYSEC",{"type":19,"value":588}," ：每一秒钟保存一次。",{"type":14,"tag":25,"props":590,"children":591},{},[592,598],{"type":14,"tag":159,"props":593,"children":595},{"className":594},[],[596],{"type":19,"value":597},"AOF_FSYNC_ALWAYS",{"type":19,"value":599}," ：每执行一个命令保存一次。",{"type":14,"tag":15,"props":601,"children":602},{},[603],{"type":19,"value":604},"以下三个小节将分别讨论这三种保存模式。",{"type":14,"tag":91,"props":606,"children":608},{"id":607},"不保存",[609],{"type":19,"value":607},{"type":14,"tag":15,"props":611,"children":612},{},[613,615,621],{"type":19,"value":614},"在这种模式下， 每次调用 ",{"type":14,"tag":159,"props":616,"children":618},{"className":617},[],[619],{"type":19,"value":620},"flushAppendOnlyFile",{"type":19,"value":622}," 函数， WRITE 都会被执行， 但 SAVE 会被略过。",{"type":14,"tag":15,"props":624,"children":625},{},[626],{"type":19,"value":627},"在这种模式下， SAVE 只会在以下任意一种情况中被执行：",{"type":14,"tag":21,"props":629,"children":630},{},[631,636,641],{"type":14,"tag":25,"props":632,"children":633},{},[634],{"type":19,"value":635},"Redis 被关闭",{"type":14,"tag":25,"props":637,"children":638},{},[639],{"type":19,"value":640},"AOF 功能被关闭",{"type":14,"tag":25,"props":642,"children":643},{},[644],{"type":19,"value":645},"系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）",{"type":14,"tag":15,"props":647,"children":648},{},[649],{"type":19,"value":650},"这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。",{"type":14,"tag":91,"props":652,"children":654},{"id":653},"每一秒钟保存一次",[655],{"type":19,"value":653},{"type":14,"tag":15,"props":657,"children":658},{},[659],{"type":19,"value":660},"在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。",{"type":14,"tag":15,"props":662,"children":663},{},[664,666,671,672,677,679,684],{"type":19,"value":665},"注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 ",{"type":14,"tag":159,"props":667,"children":669},{"className":668},[],[670],{"type":19,"value":237},{"type":19,"value":540},{"type":14,"tag":159,"props":673,"children":675},{"className":674},[],[676],{"type":19,"value":245},{"type":19,"value":678}," 的调用并不是每秒一次， 它和调用 ",{"type":14,"tag":159,"props":680,"children":682},{"className":681},[],[683],{"type":19,"value":620},{"type":19,"value":685}," 函数时 Redis 所处的状态有关。",{"type":14,"tag":15,"props":687,"children":688},{},[689,691,696],{"type":19,"value":690},"每当 ",{"type":14,"tag":159,"props":692,"children":694},{"className":693},[],[695],{"type":19,"value":620},{"type":19,"value":697}," 函数被调用时， 可能会出现以下四种情况：",{"type":14,"tag":21,"props":699,"children":700},{},[701,723],{"type":14,"tag":25,"props":702,"children":703},{},[704,706],{"type":19,"value":705},"子线程正在执行 SAVE ，并且：",{"type":14,"tag":707,"props":708,"children":709},"blockquote",{},[710],{"type":14,"tag":214,"props":711,"children":712},{},[713,718],{"type":14,"tag":25,"props":714,"children":715},{},[716],{"type":19,"value":717},"这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。",{"type":14,"tag":25,"props":719,"children":720},{},[721],{"type":19,"value":722},"这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。",{"type":14,"tag":25,"props":724,"children":725},{},[726,728],{"type":19,"value":727},"子线程没有在执行 SAVE ，并且：",{"type":14,"tag":707,"props":729,"children":730},{},[731],{"type":14,"tag":214,"props":732,"children":733},{},[734,739],{"type":14,"tag":25,"props":735,"children":736},{},[737],{"type":19,"value":738},"上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。",{"type":14,"tag":25,"props":740,"children":741},{},[742],{"type":19,"value":743},"上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。",{"type":14,"tag":15,"props":745,"children":746},{},[747],{"type":19,"value":748},"可以用流程图表示这四种情况：",{"type":14,"tag":15,"props":750,"children":751},{},[752],{"type":14,"tag":39,"props":753,"children":755},{"alt":7,"src":754},"/images/2019-09-02-redis-aof-rdb/graphviz-1b226a6d0f09ed1b61a30d899372834634b96504.svg",[],{"type":14,"tag":15,"props":757,"children":758},{},[759],{"type":19,"value":760},"根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。",{"type":14,"tag":15,"props":762,"children":763},{},[764],{"type":19,"value":765},"如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。",{"type":14,"tag":15,"props":767,"children":768},{},[769],{"type":19,"value":770},"Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。",{"type":14,"tag":91,"props":772,"children":774},{"id":773},"每执行一个命令保存一次",[775],{"type":19,"value":773},{"type":14,"tag":15,"props":777,"children":778},{},[779],{"type":19,"value":780},"在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。",{"type":14,"tag":15,"props":782,"children":783},{},[784],{"type":19,"value":785},"另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。",{"type":14,"tag":137,"props":787,"children":789},{"id":788},"aof-保存模式对性能和安全性的影响",[790],{"type":19,"value":791},"AOF 保存模式对性能和安全性的影响",{"type":14,"tag":15,"props":793,"children":794},{},[795],{"type":19,"value":796},"在上一个小节， 我们简短地描述了三种 AOF 保存模式的工作方式， 现在， 是时候研究一下这三个模式在安全性和性能方面的区别了。",{"type":14,"tag":15,"props":798,"children":799},{},[800],{"type":19,"value":801},"对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下：",{"type":14,"tag":214,"props":803,"children":804},{},[805,817,829],{"type":14,"tag":25,"props":806,"children":807},{},[808,810,815],{"type":19,"value":809},"不保存（",{"type":14,"tag":159,"props":811,"children":813},{"className":812},[],[814],{"type":19,"value":575},{"type":19,"value":816},"）：写入和保存都由主进程执行，两个操作都会阻塞主进程。",{"type":14,"tag":25,"props":818,"children":819},{},[820,822,827],{"type":19,"value":821},"每一秒钟保存一次（",{"type":14,"tag":159,"props":823,"children":825},{"className":824},[],[826],{"type":19,"value":586},{"type":19,"value":828},"）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。",{"type":14,"tag":25,"props":830,"children":831},{},[832,834,839],{"type":19,"value":833},"每执行一个命令保存一次（",{"type":14,"tag":159,"props":835,"children":837},{"className":836},[],[838],{"type":19,"value":597},{"type":19,"value":840},"）：和模式 1 一样。",{"type":14,"tag":15,"props":842,"children":843},{},[844],{"type":19,"value":845},"因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。",{"type":14,"tag":15,"props":847,"children":848},{},[849],{"type":19,"value":850},"模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。",{"type":14,"tag":15,"props":852,"children":853},{},[854],{"type":19,"value":855},"模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。",{"type":14,"tag":15,"props":857,"children":858},{},[859],{"type":19,"value":860},"模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。",{"type":14,"tag":15,"props":862,"children":863},{},[864],{"type":19,"value":865},"综合起来，三种 AOF 模式的操作特性可以总结如下：",{"type":19,"value":867},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":14,"tag":869,"props":870,"children":871},"table",{},[872,901],{"type":14,"tag":873,"props":874,"children":875},"thead",{},[876],{"type":14,"tag":877,"props":878,"children":879},"tr",{},[880,886,891,896],{"type":14,"tag":881,"props":882,"children":883},"th",{},[884],{"type":19,"value":885},"模式",{"type":14,"tag":881,"props":887,"children":888},{},[889],{"type":19,"value":890},"WRITE 是否阻塞？",{"type":14,"tag":881,"props":892,"children":893},{},[894],{"type":19,"value":895},"SAVE 是否阻塞？",{"type":14,"tag":881,"props":897,"children":898},{},[899],{"type":19,"value":900},"停机时丢失的数据量",{"type":14,"tag":902,"props":903,"children":904},"tbody",{},[905,931,956],{"type":14,"tag":877,"props":906,"children":907},{},[908,917,922,926],{"type":14,"tag":909,"props":910,"children":911},"td",{},[912],{"type":14,"tag":159,"props":913,"children":915},{"className":914},[],[916],{"type":19,"value":575},{"type":14,"tag":909,"props":918,"children":919},{},[920],{"type":19,"value":921},"阻塞",{"type":14,"tag":909,"props":923,"children":924},{},[925],{"type":19,"value":921},{"type":14,"tag":909,"props":927,"children":928},{},[929],{"type":19,"value":930},"操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。",{"type":14,"tag":877,"props":932,"children":933},{},[934,942,946,951],{"type":14,"tag":909,"props":935,"children":936},{},[937],{"type":14,"tag":159,"props":938,"children":940},{"className":939},[],[941],{"type":19,"value":586},{"type":14,"tag":909,"props":943,"children":944},{},[945],{"type":19,"value":921},{"type":14,"tag":909,"props":947,"children":948},{},[949],{"type":19,"value":950},"不阻塞",{"type":14,"tag":909,"props":952,"children":953},{},[954],{"type":19,"value":955},"一般情况下不超过 2 秒钟的数据。",{"type":14,"tag":877,"props":957,"children":958},{},[959,967,971,975],{"type":14,"tag":909,"props":960,"children":961},{},[962],{"type":14,"tag":159,"props":963,"children":965},{"className":964},[],[966],{"type":19,"value":597},{"type":14,"tag":909,"props":968,"children":969},{},[970],{"type":19,"value":921},{"type":14,"tag":909,"props":972,"children":973},{},[974],{"type":19,"value":921},{"type":14,"tag":909,"props":976,"children":977},{},[978],{"type":19,"value":979},"最多只丢失一个命令的数据。",{"type":14,"tag":137,"props":981,"children":983},{"id":982},"aof-文件的读取和数据还原",[984],{"type":19,"value":985},"AOF 文件的读取和数据还原",{"type":14,"tag":15,"props":987,"children":988},{},[989],{"type":19,"value":990},"AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本。",{"type":14,"tag":15,"props":992,"children":993},{},[994],{"type":19,"value":995},"这也就是说， 只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。",{"type":14,"tag":15,"props":997,"children":998},{},[999],{"type":19,"value":1000},"Redis 读取 AOF 文件并还原数据库的详细步骤如下：",{"type":14,"tag":214,"props":1002,"children":1003},{},[1004,1009,1014,1019],{"type":14,"tag":25,"props":1005,"children":1006},{},[1007],{"type":19,"value":1008},"创建一个不带网络连接的伪客户端（fake client）。",{"type":14,"tag":25,"props":1010,"children":1011},{},[1012],{"type":19,"value":1013},"读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。",{"type":14,"tag":25,"props":1015,"children":1016},{},[1017],{"type":19,"value":1018},"根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。",{"type":14,"tag":25,"props":1020,"children":1021},{},[1022],{"type":19,"value":1023},"执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。",{"type":14,"tag":15,"props":1025,"children":1026},{},[1027],{"type":19,"value":1028},"完成第 4 步之后， AOF 文件所保存的数据库就会被完整地还原出来。",{"type":14,"tag":15,"props":1030,"children":1031},{},[1032],{"type":19,"value":1033},"注意， 因为 Redis 的命令只能在客户端的上下文中被执行， 而 AOF 还原时所使用的命令来自于 AOF 文件， 而不是网络， 所以程序使用了一个没有网络连接的伪客户端来执行命令。 伪客户端执行命令的效果， 和带网络连接的客户端执行命令的效果， 完全一样。",{"type":14,"tag":15,"props":1035,"children":1036},{},[1037],{"type":19,"value":1038},"整个读取和还原过程可以用以下伪代码表示：",{"type":14,"tag":154,"props":1040,"children":1042},{"code":1041},"def READ_AND_LOAD_AOF():\n\n    # 打开并读取 AOF 文件\n    file = open(aof_file_name)\n    while file.is_not_reach_eof():\n\n        # 读入一条协议文本格式的 Redis 命令\n        cmd_in_text = file.read_next_command_in_protocol_format()\n\n        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象\n        cmd, argv, argc = text_to_command(cmd_in_text)\n\n        # 执行命令\n        execRedisCommand(cmd, argv, argc)\n\n    # 关闭文件\n    file.close()\n",[1043],{"type":14,"tag":159,"props":1044,"children":1045},{"__ignoreMap":7},[1046],{"type":19,"value":1041},{"type":14,"tag":15,"props":1048,"children":1049},{},[1050],{"type":19,"value":1051},"作为例子， 以下是一个简短的 AOF 文件的内容：",{"type":14,"tag":154,"props":1053,"children":1055},{"code":1054},"*2\n$6\nSELECT\n$1\n0\n*3\n$3\nSET\n$3\nkey\n$5\nvalue\n*8\n$5\nRPUSH\n$4\nlist\n$1\n1\n$1\n2\n$1\n3\n$1\n4\n$1\n5\n$1\n6\n",[1056],{"type":14,"tag":159,"props":1057,"children":1058},{"__ignoreMap":7},[1059],{"type":19,"value":1054},{"type":14,"tag":15,"props":1061,"children":1062},{},[1063,1065,1071,1073,1078],{"type":19,"value":1064},"当程序读入这个 AOF 文件时， 它首先执行 ",{"type":14,"tag":159,"props":1066,"children":1068},{"className":1067},[],[1069],{"type":19,"value":1070},"SELECT 0",{"type":19,"value":1072}," 命令 —— 这个 ",{"type":14,"tag":159,"props":1074,"children":1076},{"className":1075},[],[1077],{"type":19,"value":205},{"type":19,"value":1079}," 命令是由 AOF 写入程序自动生成的， 它确保程序可以将数据还原到正确的数据库上。",{"type":14,"tag":15,"props":1081,"children":1082},{},[1083,1085,1091,1092,1098,1100,1106,1107,1113],{"type":19,"value":1084},"然后执行后面的 ",{"type":14,"tag":159,"props":1086,"children":1088},{"className":1087},[],[1089],{"type":19,"value":1090},"SET key value",{"type":19,"value":339},{"type":14,"tag":159,"props":1093,"children":1095},{"className":1094},[],[1096],{"type":19,"value":1097},"RPUSH 1 2 3 4",{"type":19,"value":1099}," 命令， 还原 ",{"type":14,"tag":159,"props":1101,"children":1103},{"className":1102},[],[1104],{"type":19,"value":1105},"key",{"type":19,"value":339},{"type":14,"tag":159,"props":1108,"children":1110},{"className":1109},[],[1111],{"type":19,"value":1112},"list",{"type":19,"value":1114}," 两个键的数据。",{"type":14,"tag":15,"props":1116,"children":1117},{},[1118],{"type":19,"value":1119},"为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。",{"type":14,"tag":137,"props":1121,"children":1123},{"id":1122},"aof-重写",[1124],{"type":19,"value":1125},"AOF 重写",{"type":14,"tag":15,"props":1127,"children":1128},{},[1129],{"type":19,"value":1130},"AOF 文件通过同步 Redis 服务器所执行的命令， 从而实现了数据库状态的记录， 但是， 这种同步方式会造成一个问题： 随着运行时间的流逝， AOF 文件会变得越来越大。",{"type":14,"tag":15,"props":1132,"children":1133},{},[1134],{"type":19,"value":1135},"举个例子， 如果服务器执行了以下命令：",{"type":14,"tag":154,"props":1137,"children":1139},{"code":1138},"RPUSH list 1 2 3 4      // [1, 2, 3, 4]\n\nRPOP list               // [1, 2, 3]\n\nLPOP list               // [2, 3]\n\nLPUSH list 1            // [1, 2, 3]\n",[1140],{"type":14,"tag":159,"props":1141,"children":1142},{"__ignoreMap":7},[1143],{"type":19,"value":1138},{"type":14,"tag":15,"props":1145,"children":1146},{},[1147,1149,1154],{"type":19,"value":1148},"那么光是记录 ",{"type":14,"tag":159,"props":1150,"children":1152},{"className":1151},[],[1153],{"type":19,"value":1112},{"type":19,"value":1155}," 键的状态， AOF 文件就需要保存四条命令。",{"type":14,"tag":15,"props":1157,"children":1158},{},[1159],{"type":19,"value":1160},"另一方面， 有些被频繁操作的键， 对它们所调用的命令可能有成百上千、甚至上万条， 如果这样被频繁操作的键有很多的话， AOF 文件的体积就会急速膨胀， 对 Redis 、甚至整个系统的造成影响。",{"type":14,"tag":15,"props":1162,"children":1163},{},[1164],{"type":19,"value":1165},"为了解决以上的问题， Redis 需要对 AOF 文件进行重写（rewrite）： 创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积。",{"type":14,"tag":15,"props":1167,"children":1168},{},[1169],{"type":19,"value":1170},"以下就来介绍 AOF 重写的实现方式。",{"type":14,"tag":137,"props":1172,"children":1174},{"id":1173},"aof-重写的实现",[1175],{"type":19,"value":1176},"AOF 重写的实现",{"type":14,"tag":15,"props":1178,"children":1179},{},[1180],{"type":19,"value":1181},"所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。",{"type":14,"tag":15,"props":1183,"children":1184},{},[1185,1187,1192],{"type":19,"value":1186},"考虑这样一个情况， 如果服务器对键 ",{"type":14,"tag":159,"props":1188,"children":1190},{"className":1189},[],[1191],{"type":19,"value":1112},{"type":19,"value":1193}," 执行了以下四条命令：",{"type":14,"tag":154,"props":1195,"children":1196},{"code":1138},[1197],{"type":14,"tag":159,"props":1198,"children":1199},{"__ignoreMap":7},[1200],{"type":19,"value":1138},{"type":14,"tag":15,"props":1202,"children":1203},{},[1204,1206,1211,1213,1219],{"type":19,"value":1205},"那么当前列表键 ",{"type":14,"tag":159,"props":1207,"children":1209},{"className":1208},[],[1210],{"type":19,"value":1112},{"type":19,"value":1212}," 在数据库中的值就为 ",{"type":14,"tag":159,"props":1214,"children":1216},{"className":1215},[],[1217],{"type":19,"value":1218},"[1, 2, 3]",{"type":19,"value":73},{"type":14,"tag":15,"props":1221,"children":1222},{},[1223,1225,1230,1232,1238],{"type":19,"value":1224},"如果我们要保存这个列表的当前状态， 并且尽量减少所使用的命令数， 那么最简单的方式不是去 AOF 文件上分析前面执行的四条命令， 而是直接读取 ",{"type":14,"tag":159,"props":1226,"children":1228},{"className":1227},[],[1229],{"type":19,"value":1112},{"type":19,"value":1231}," 键在数据库的当前值， 然后用一条 ",{"type":14,"tag":159,"props":1233,"children":1235},{"className":1234},[],[1236],{"type":19,"value":1237},"RPUSH 1 2 3",{"type":19,"value":1239}," 命令来代替前面的四条命令。",{"type":14,"tag":15,"props":1241,"children":1242},{},[1243,1245,1251],{"type":19,"value":1244},"再考虑这样一个例子， 如果服务器对集合键 ",{"type":14,"tag":159,"props":1246,"children":1248},{"className":1247},[],[1249],{"type":19,"value":1250},"animal",{"type":19,"value":1252}," 执行了以下命令：",{"type":14,"tag":154,"props":1254,"children":1256},{"code":1255},"SADD animal cat                 // {cat}\n\nSADD animal dog panda tiger     // {cat, dog, panda, tiger}\n\nSREM animal cat                 // {dog, panda, tiger}\n\nSADD animal cat lion            // {cat, lion, dog, panda, tiger}\n",[1257],{"type":14,"tag":159,"props":1258,"children":1259},{"__ignoreMap":7},[1260],{"type":19,"value":1255},{"type":14,"tag":15,"props":1262,"children":1263},{},[1264,1266,1272,1274,1279],{"type":19,"value":1265},"那么使用一条 ",{"type":14,"tag":159,"props":1267,"children":1269},{"className":1268},[],[1270],{"type":19,"value":1271},"SADD animal cat lion dog panda tiger",{"type":19,"value":1273}," 命令， 就可以还原 ",{"type":14,"tag":159,"props":1275,"children":1277},{"className":1276},[],[1278],{"type":19,"value":1250},{"type":19,"value":1280}," 集合的状态， 这比之前的四条命令调用要大大减少。",{"type":14,"tag":15,"props":1282,"children":1283},{},[1284],{"type":19,"value":1285},"除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。",{"type":14,"tag":15,"props":1287,"children":1288},{},[1289],{"type":19,"value":1290},"根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。 整个重写过程可以用伪代码表示如下：",{"type":14,"tag":154,"props":1292,"children":1294},{"code":1293},"def AOF_REWRITE(tmp_tile_name):\n\n  f = create(tmp_tile_name)\n\n  # 遍历所有数据库\n  for db in redisServer.db:\n\n    # 如果数据库为空，那么跳过这个数据库\n    if db.is_empty(): continue\n\n    # 写入 SELECT 命令，用于切换数据库\n    f.write_command(\"SELECT \" + db.number)\n\n    # 遍历所有键\n    for key in db:\n\n      # 如果键带有过期时间，并且已经过期，那么跳过这个键\n      if key.have_expire_time() and key.is_expired(): continue\n\n      if key.type == String:\n\n        # 用 SET key value 命令来保存字符串键\n\n        value = get_value_from_string(key)\n\n        f.write_command(\"SET \" + key + value)\n\n      elif key.type == List:\n\n        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键\n\n        item1, item2, ..., itemN = get_item_from_list(key)\n\n        f.write_command(\"RPUSH \" + key + item1 + item2 + ... + itemN)\n\n      elif key.type == Set:\n\n        # 用 SADD key member1 member2 ... memberN 命令来保存集合键\n\n        member1, member2, ..., memberN = get_member_from_set(key)\n\n        f.write_command(\"SADD \" + key + member1 + member2 + ... + memberN)\n\n      elif key.type == Hash:\n\n        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键\n\n        field1, value1, field2, value2, ..., fieldN, valueN =\\\n        get_field_and_value_from_hash(key)\n\n        f.write_command(\"HMSET \" + key + field1 + value1 + field2 + value2 +\\\n                        ... + fieldN + valueN)\n\n      elif key.type == SortedSet:\n\n        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN\n        # 命令来保存有序集键\n\n        score1, member1, score2, member2, ..., scoreN, memberN = \\\n        get_score_and_member_from_sorted_set(key)\n\n        f.write_command(\"ZADD \" + key + score1 + member1 + score2 + member2 +\\\n                        ... + scoreN + memberN)\n\n      else:\n\n        raise_type_error()\n\n      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间\n      if key.have_expire_time():\n        f.write_command(\"EXPIREAT \" + key + key.expire_time_in_unix_timestamp())\n\n    # 关闭文件\n    f.close()\n",[1295],{"type":14,"tag":159,"props":1296,"children":1297},{"__ignoreMap":7},[1298],{"type":19,"value":1293},{"type":14,"tag":137,"props":1300,"children":1302},{"id":1301},"aof-后台重写",[1303],{"type":19,"value":1304},"AOF 后台重写",{"type":14,"tag":15,"props":1306,"children":1307},{},[1308],{"type":19,"value":1309},"上一节展示的 AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。",{"type":14,"tag":15,"props":1311,"children":1312},{},[1313],{"type":19,"value":1314},"很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：",{"type":14,"tag":214,"props":1316,"children":1317},{},[1318,1323],{"type":14,"tag":25,"props":1319,"children":1320},{},[1321],{"type":19,"value":1322},"子进程进行 AOF 重写期间，主进程可以继续处理命令请求。",{"type":14,"tag":25,"props":1324,"children":1325},{},[1326],{"type":19,"value":1327},"子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。",{"type":14,"tag":15,"props":1329,"children":1330},{},[1331],{"type":19,"value":1332},"不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。",{"type":14,"tag":15,"props":1334,"children":1335},{},[1336],{"type":19,"value":1337},"为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中：",{"type":14,"tag":15,"props":1339,"children":1340},{},[1341],{"type":14,"tag":39,"props":1342,"children":1344},{"alt":7,"src":1343},"/images/2019-09-02-redis-aof-rdb/graphviz-982033b83f571a133367a8830ee5cca84f6a08e5.svg",[],{"type":14,"tag":15,"props":1346,"children":1347},{},[1348],{"type":19,"value":1349},"换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作：",{"type":14,"tag":214,"props":1351,"children":1352},{},[1353,1358,1363],{"type":14,"tag":25,"props":1354,"children":1355},{},[1356],{"type":19,"value":1357},"处理命令请求。",{"type":14,"tag":25,"props":1359,"children":1360},{},[1361],{"type":19,"value":1362},"将写命令追加到现有的 AOF 文件中。",{"type":14,"tag":25,"props":1364,"children":1365},{},[1366],{"type":19,"value":1367},"将写命令追加到 AOF 重写缓存中。",{"type":14,"tag":15,"props":1369,"children":1370},{},[1371],{"type":19,"value":1372},"这样一来可以保证：",{"type":14,"tag":214,"props":1374,"children":1375},{},[1376,1381],{"type":14,"tag":25,"props":1377,"children":1378},{},[1379],{"type":19,"value":1380},"现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。",{"type":14,"tag":25,"props":1382,"children":1383},{},[1384],{"type":19,"value":1385},"所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。",{"type":14,"tag":15,"props":1387,"children":1388},{},[1389],{"type":19,"value":1390},"当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：",{"type":14,"tag":214,"props":1392,"children":1393},{},[1394,1399],{"type":14,"tag":25,"props":1395,"children":1396},{},[1397],{"type":19,"value":1398},"将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。",{"type":14,"tag":25,"props":1400,"children":1401},{},[1402],{"type":19,"value":1403},"对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。",{"type":14,"tag":15,"props":1405,"children":1406},{},[1407],{"type":19,"value":1408},"当步骤 1 执行完毕之后， 现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。",{"type":14,"tag":15,"props":1410,"children":1411},{},[1412],{"type":19,"value":1413},"当步骤 2 执行完毕之后， 程序就完成了新旧两个 AOF 文件的交替。",{"type":14,"tag":15,"props":1415,"children":1416},{},[1417],{"type":19,"value":1418},"这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。",{"type":14,"tag":15,"props":1420,"children":1421},{},[1422,1424,1431],{"type":19,"value":1423},"以上就是 AOF 后台重写， 也即是 ",{"type":14,"tag":64,"props":1425,"children":1428},{"href":1426,"rel":1427},"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof",[68],[1429],{"type":19,"value":1430},"BGREWRITEAOF",{"type":19,"value":1432}," 命令的工作原理。",{"type":14,"tag":137,"props":1434,"children":1436},{"id":1435},"aof-后台重写的触发条件",[1437],{"type":19,"value":1438},"AOF 后台重写的触发条件",{"type":14,"tag":15,"props":1440,"children":1441},{},[1442,1444,1449],{"type":19,"value":1443},"AOF 重写可以由用户通过调用 ",{"type":14,"tag":64,"props":1445,"children":1447},{"href":1426,"rel":1446},[68],[1448],{"type":19,"value":1430},{"type":19,"value":1450}," 手动触发。",{"type":14,"tag":15,"props":1452,"children":1453},{},[1454],{"type":19,"value":1455},"另外， 服务器在 AOF 功能开启的情况下， 会维持以下三个变量：",{"type":14,"tag":21,"props":1457,"children":1458},{},[1459,1471,1483],{"type":14,"tag":25,"props":1460,"children":1461},{},[1462,1464,1470],{"type":19,"value":1463},"记录当前 AOF 文件大小的变量 ",{"type":14,"tag":159,"props":1465,"children":1467},{"className":1466},[],[1468],{"type":19,"value":1469},"aof_current_size",{"type":19,"value":73},{"type":14,"tag":25,"props":1472,"children":1473},{},[1474,1476,1482],{"type":19,"value":1475},"记录最后一次 AOF 重写之后， AOF 文件大小的变量 ",{"type":14,"tag":159,"props":1477,"children":1479},{"className":1478},[],[1480],{"type":19,"value":1481},"aof_rewrite_base_size",{"type":19,"value":73},{"type":14,"tag":25,"props":1484,"children":1485},{},[1486,1488,1494],{"type":19,"value":1487},"增长百分比变量 ",{"type":14,"tag":159,"props":1489,"children":1491},{"className":1490},[],[1492],{"type":19,"value":1493},"aof_rewrite_perc",{"type":19,"value":73},{"type":14,"tag":15,"props":1496,"children":1497},{},[1498,1500,1506],{"type":19,"value":1499},"每次当 ",{"type":14,"tag":159,"props":1501,"children":1503},{"className":1502},[],[1504],{"type":19,"value":1505},"serverCron",{"type":19,"value":1507}," 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：",{"type":14,"tag":214,"props":1509,"children":1510},{},[1511,1525,1536,1549],{"type":14,"tag":25,"props":1512,"children":1513},{},[1514,1516,1523],{"type":19,"value":1515},"没有 ",{"type":14,"tag":64,"props":1517,"children":1520},{"href":1518,"rel":1519},"http://redis.readthedocs.org/en/latest/server/bgsave.html#bgsave",[68],[1521],{"type":19,"value":1522},"BGSAVE",{"type":19,"value":1524}," 命令在进行。",{"type":14,"tag":25,"props":1526,"children":1527},{},[1528,1529,1534],{"type":19,"value":1515},{"type":14,"tag":64,"props":1530,"children":1532},{"href":1426,"rel":1531},[68],[1533],{"type":19,"value":1430},{"type":19,"value":1535}," 在进行。",{"type":14,"tag":25,"props":1537,"children":1538},{},[1539,1541,1547],{"type":19,"value":1540},"当前 AOF 文件大小大于 ",{"type":14,"tag":159,"props":1542,"children":1544},{"className":1543},[],[1545],{"type":19,"value":1546},"server.aof_rewrite_min_size",{"type":19,"value":1548}," （默认值为 1 MB）。",{"type":14,"tag":25,"props":1550,"children":1551},{},[1552],{"type":19,"value":1553},"当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。",{"type":14,"tag":15,"props":1555,"children":1556},{},[1557,1559,1565],{"type":19,"value":1558},"默认情况下， 增长百分比为 ",{"type":14,"tag":159,"props":1560,"children":1562},{"className":1561},[],[1563],{"type":19,"value":1564},"100%",{"type":19,"value":1566}," ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。",{"type":14,"tag":137,"props":1568,"children":1570},{"id":1569},"小结",[1571],{"type":19,"value":1569},{"type":14,"tag":21,"props":1573,"children":1574},{},[1575,1580,1585,1590,1595,1600],{"type":14,"tag":25,"props":1576,"children":1577},{},[1578],{"type":19,"value":1579},"AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。",{"type":14,"tag":25,"props":1581,"children":1582},{},[1583],{"type":19,"value":1584},"AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。",{"type":14,"tag":25,"props":1586,"children":1587},{},[1588],{"type":19,"value":1589},"不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。",{"type":14,"tag":25,"props":1591,"children":1592},{},[1593],{"type":19,"value":1594},"AOF 重写的目的是用更小的体积来保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求。",{"type":14,"tag":25,"props":1596,"children":1597},{},[1598],{"type":19,"value":1599},"AOF 重写是一个有歧义的名字，实际的重写工作是针对数据库的当前值来进行的，程序既不读写、也不使用原有的 AOF 文件。",{"type":14,"tag":25,"props":1601,"children":1602},{},[1603],{"type":19,"value":1604},"AOF 可以由用户手动触发，也可以由服务器自动触发。",{"title":7,"searchDepth":1606,"depth":1606,"links":1607},2,[1608,1610,1611,1612,1613,1614,1615,1620,1621,1622,1623,1624,1625,1626],{"id":93,"depth":1609,"text":93},3,{"id":116,"depth":1609,"text":116},{"id":139,"depth":1606,"text":142},{"id":255,"depth":1606,"text":255},{"id":380,"depth":1606,"text":380},{"id":501,"depth":1606,"text":501},{"id":555,"depth":1606,"text":558,"children":1616},[1617,1618,1619],{"id":607,"depth":1609,"text":607},{"id":653,"depth":1609,"text":653},{"id":773,"depth":1609,"text":773},{"id":788,"depth":1606,"text":791},{"id":982,"depth":1606,"text":985},{"id":1122,"depth":1606,"text":1125},{"id":1173,"depth":1606,"text":1176},{"id":1301,"depth":1606,"text":1304},{"id":1435,"depth":1606,"text":1438},{"id":1569,"depth":1606,"text":1569},"markdown","content:tool:2019-09-02-redis-aof-rdb.md","content","tool/2019-09-02-redis-aof-rdb.md","md","2019-09-02",[1634,1644,1771,1820,1872,1885,1995],{"title":1635,"_path":1636,"children":1637},"Art","/art",[1638,1641],{"title":1639,"_path":1640},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":1642,"_path":1643},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":1645,"_path":1646,"children":1647},"Dotnet","/dotnet",[1648,1651,1654,1657,1660,1663,1666,1669,1672,1675,1678,1681,1684,1687,1690,1693,1696,1699,1702,1705,1708,1711,1714,1717,1720,1723,1726,1729,1732,1735,1738,1741,1744,1747,1750,1753,1756,1759,1762,1765,1768],{"title":1649,"_path":1650},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":1652,"_path":1653},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":1655,"_path":1656},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":1658,"_path":1659},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":1661,"_path":1662},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":1664,"_path":1665},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":1667,"_path":1668},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":1670,"_path":1671},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":1673,"_path":1674},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":1676,"_path":1677},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":1679,"_path":1680},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":1682,"_path":1683},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":1685,"_path":1686},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":1688,"_path":1689},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":1691,"_path":1692},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":1694,"_path":1695},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":1697,"_path":1698},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":1700,"_path":1701},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":1703,"_path":1704},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":1706,"_path":1707},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":1709,"_path":1710},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":1712,"_path":1713},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":1715,"_path":1716},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":1718,"_path":1719},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":1721,"_path":1722},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":1724,"_path":1725},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":1727,"_path":1728},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":1730,"_path":1731},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":1733,"_path":1734},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":1736,"_path":1737},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":1739,"_path":1740},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":1742,"_path":1743},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":1745,"_path":1746},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":1748,"_path":1749},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":1751,"_path":1752},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":1754,"_path":1755},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":1757,"_path":1758},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":1760,"_path":1761},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":1763,"_path":1764},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":1766,"_path":1767},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":1769,"_path":1770},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":1772,"_path":1773,"children":1774},"Game","/game",[1775,1778,1781,1784,1787,1790,1793,1796,1799,1802,1805,1808,1811,1814,1817],{"title":1776,"_path":1777},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":1779,"_path":1780},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":1782,"_path":1783},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":1785,"_path":1786},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":1788,"_path":1789},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":1791,"_path":1792},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":1794,"_path":1795},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":1797,"_path":1798},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":1800,"_path":1801},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":1803,"_path":1804},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":1806,"_path":1807},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":1809,"_path":1810},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":1812,"_path":1813},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":1815,"_path":1816},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":1818,"_path":1819},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":1821,"_path":1822,"children":1823},"Gyj","/gyj",[1824,1827,1830,1833,1836,1839,1842,1845,1848,1851,1854,1857,1860,1863,1866,1869],{"title":1825,"_path":1826},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":1828,"_path":1829},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":1831,"_path":1832},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":1834,"_path":1835},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":1837,"_path":1838},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":1840,"_path":1841},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":1843,"_path":1844},"玩法","/gyj/2022-08-22-wanfa",{"title":1846,"_path":1847},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":1849,"_path":1850},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":1852,"_path":1853},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":1855,"_path":1856},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":1858,"_path":1859},"门派内容相关","/gyj/2022-11-17-sect",{"title":1861,"_path":1862},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":1864,"_path":1865},"种植","/gyj/2022-12-01-zhongzhi",{"title":1867,"_path":1868},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":1870,"_path":1871},"跑商","/gyj/2023-11-01-paoshang",{"title":1873,"_path":1874,"children":1875},"Js","/js",[1876,1879,1882],{"title":1877,"_path":1878},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":1880,"_path":1881},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":1883,"_path":1884},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":1886,"_path":1887,"children":1888},"Tool","/tool",[1889,1892,1895,1898,1901,1904,1907,1908,1911,1914,1917,1920,1923,1926,1929,1932,1935,1938,1941,1944,1947,1950,1953,1956,1959,1962,1965,1968,1971,1974,1977,1980,1983,1986,1989,1992],{"title":1890,"_path":1891},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":1893,"_path":1894},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":1896,"_path":1897},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":1899,"_path":1900},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":1902,"_path":1903},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":1905,"_path":1906},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":8,"_path":4},{"title":1909,"_path":1910},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":1912,"_path":1913},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":1915,"_path":1916},"mac下brew 使用","/tool/2020-01-13-brew",{"title":1918,"_path":1919},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":1921,"_path":1922},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":1924,"_path":1925},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":1927,"_path":1928},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":1930,"_path":1931},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":1933,"_path":1934},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":1936,"_path":1937},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":1939,"_path":1940},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":1942,"_path":1943},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":1945,"_path":1946},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":1948,"_path":1949},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":1951,"_path":1952},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":1954,"_path":1955},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":1957,"_path":1958},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":1960,"_path":1961},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":1963,"_path":1964},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":1966,"_path":1967},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":1969,"_path":1970},"我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","/tool/2021-12-02-vscode-plugins-big",{"title":1972,"_path":1973},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":1975,"_path":1976},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":1978,"_path":1979},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":1981,"_path":1982},"rider的使用","/tool/2022-08-02-rider-use",{"title":1984,"_path":1985},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":1987,"_path":1988},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":1990,"_path":1991},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":1993,"_path":1994},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":1996,"_path":1997,"children":1998},"Unity","/unity",[1999,2002,2005,2008,2011,2014,2017,2020,2023,2026,2029,2032,2035,2038,2041,2044,2047,2050,2053,2056,2059,2062,2065,2068,2071,2074,2077,2080,2083,2086,2089,2092,2095,2098,2101,2104,2107,2110,2113,2116,2119,2122,2125,2128,2131,2134,2137,2140,2143,2146,2149,2152,2155,2158,2161,2164,2167,2170,2173,2176,2179,2182,2185,2188,2191,2194,2197,2200,2203,2206,2209,2212],{"title":2000,"_path":2001},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":2003,"_path":2004},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":2006,"_path":2007},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":2009,"_path":2010},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":2012,"_path":2013},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":2015,"_path":2016},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":2018,"_path":2019},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":2021,"_path":2022},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":2024,"_path":2025},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":2027,"_path":2028},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":2030,"_path":2031},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":2033,"_path":2034},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":2036,"_path":2037},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":2039,"_path":2040},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":2042,"_path":2043},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":2045,"_path":2046},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":2048,"_path":2049},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":2051,"_path":2052},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":2054,"_path":2055},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":2057,"_path":2058},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":2060,"_path":2061},"技能系统","/unity/2020-02-15-skill-system",{"title":2063,"_path":2064},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":2066,"_path":2067},"角色状态设计","/unity/2020-02-17-character-states",{"title":2069,"_path":2070},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":2072,"_path":2073},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":2075,"_path":2076},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":2078,"_path":2079},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":2081,"_path":2082},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":2084,"_path":2085},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":2087,"_path":2088},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":2090,"_path":2091},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":2093,"_path":2094},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":2096,"_path":2097},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":2099,"_path":2100},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":2102,"_path":2103},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":2105,"_path":2106},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":2108,"_path":2109},"unity的addressables","/unity/2020-09-12-addressables",{"title":2111,"_path":2112},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":2114,"_path":2115},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":2117,"_path":2118},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":2120,"_path":2121},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":2123,"_path":2124},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":2126,"_path":2127},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":2129,"_path":2130},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":2132,"_path":2133},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":2135,"_path":2136},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":2138,"_path":2139},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":2141,"_path":2142},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":2144,"_path":2145},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":2147,"_path":2148},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":2150,"_path":2151},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":2153,"_path":2154},"简单保存工具","/unity/2020-11-13-simple-save",{"title":2156,"_path":2157},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":2159,"_path":2160},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":2162,"_path":2163},"ability","/unity/2020-11-16-dotssample",{"title":2165,"_path":2166},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":2168,"_path":2169},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":2171,"_path":2172},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":2174,"_path":2175},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":2177,"_path":2178},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":2180,"_path":2181},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":2183,"_path":2184},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":2186,"_path":2187},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":2189,"_path":2190},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":2192,"_path":2193},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":2195,"_path":2196},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":2198,"_path":2199},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":2201,"_path":2202},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":2204,"_path":2205},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":2207,"_path":2208},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":2210,"_path":2211},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":2213,"_path":2214},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779041811]