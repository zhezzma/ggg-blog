[{"data":1,"prerenderedAt":1140},["Reactive",2],{"content-query-pcJ2sCU0LA":3,"content-navigation-8C37fagqQL":558},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":552,"_id":553,"_source":554,"_file":555,"_extension":556,"date":557},"/tool/2021-12-02-vscode-plugins-big","tool",false,"","我是如何把 VS Code 插件启动速度从 8 秒减少到 1 秒 ","前言最近在打包 VS Code 插件时，发现打包后的插件体积非常大，而且插件在 VS Code 中的启动速度非常慢，对用户的体验不太友好了。对此做了一些研究，并更改了打包策略，终于把插件的体积从 35M 减少到 3M，并提高了插件的启动速度。本文将带你分析插件体积过大和启动速度过慢的原因，并讲解如何通过使用 webpack 进行打包来减少插件体积。最后将讲解如何配置 externals 剥离一些依赖模块，减少 bundle 的体积，避免出现打包失败的问题。原始打包首先，我们会以 iceworks-page-builder VS Code 插件为例子进行分析，具体的代码可以点击此链接查看。其中，",{"type":11,"children":12,"toc":544},"root",[13,21,27,32,37,53,58,68,96,104,109,117,138,172,180,185,193,198,204,209,282,290,303,311,339,347,375,383,396,410,416,421,428,442,455,462,475,480,488,500,508,527,534,539],{"type":14,"tag":15,"props":16,"children":18},"element","h2",{"id":17},"前言",[19],{"type":20,"value":17},"text",{"type":14,"tag":22,"props":23,"children":24},"p",{},[25],{"type":20,"value":26},"最近在打包 VS Code 插件时，发现打包后的插件体积非常大，而且插件在 VS Code 中的启动速度非常慢，对用户的体验不太友好了。对此做了一些研究，并更改了打包策略，终于把插件的体积从 35M 减少到 3M，并提高了插件的启动速度。",{"type":14,"tag":22,"props":28,"children":29},{},[30],{"type":20,"value":31},"本文将带你分析插件体积过大和启动速度过慢的原因，并讲解如何通过使用 webpack 进行打包来减少插件体积。最后将讲解如何配置 externals 剥离一些依赖模块，减少 bundle 的体积，避免出现打包失败的问题。",{"type":14,"tag":15,"props":33,"children":35},{"id":34},"原始打包",[36],{"type":20,"value":34},{"type":14,"tag":22,"props":38,"children":39},{},[40,42,51],{"type":20,"value":41},"首先，我们会以 iceworks-page-builder VS Code 插件为例子进行分析，具体的代码可以点击",{"type":14,"tag":43,"props":44,"children":48},"a",{"href":45,"rel":46},"https://link.zhihu.com/?target=https%3A//github.com/ice-lab/iceworks/tree/v0.1.6/extensions/iceworks-page-builder",[47],"nofollow",[49],{"type":20,"value":50},"此链接",{"type":20,"value":52},"查看。",{"type":14,"tag":22,"props":54,"children":55},{},[56],{"type":20,"value":57},"其中，部分目录结构说明如下：",{"type":14,"tag":59,"props":60,"children":62},"pre",{"code":61},"\u003Ccode class=\"language-text\">├── .vscodeignore            # 插件打包时需要忽略的文件\n├── build                     # 构建产物目录\n├── node_modules\n├── package.json\n├── src                       # 插件相关的源代码\n|  ├── extension.ts\n|  ├── services\n|  └── types.d.ts\n├── tsconfig.json\n└── web                       # webview 相关代码 本质是一个 React 项目\u003C/code>\n",[63],{"type":14,"tag":64,"props":65,"children":66},"code",{"__ignoreMap":7},[67],{"type":20,"value":61},{"type":14,"tag":22,"props":69,"children":70},{},[71,73,80,82,87,89,94],{"type":20,"value":72},"打包插件需要使用 ",{"type":14,"tag":43,"props":74,"children":77},{"href":75,"rel":76},"https://link.zhihu.com/?target=https%3A//github.com/microsoft/vscode-vsce",[47],[78],{"type":20,"value":79},"vsce",{"type":20,"value":81}," 这个工具。 首先确认已安装 ",{"type":14,"tag":64,"props":83,"children":85},{"className":84},[],[86],{"type":20,"value":79},{"type":20,"value":88}," ；若未安装，则执行以下的命令安装 ",{"type":14,"tag":64,"props":90,"children":92},{"className":91},[],[93],{"type":20,"value":79},{"type":20,"value":95}," ：",{"type":14,"tag":59,"props":97,"children":99},{"code":98},"\u003Ccode class=\"language-text\">npm i vsce -g\u003C/code>\n",[100],{"type":14,"tag":64,"props":101,"children":102},{"__ignoreMap":7},[103],{"type":20,"value":98},{"type":14,"tag":22,"props":105,"children":106},{},[107],{"type":20,"value":108},"在项目的根目录下执行以下命令，即开始对插件进行打包：",{"type":14,"tag":59,"props":110,"children":112},{"code":111},"\u003Ccode class=\"language-text\">vsce package\u003C/code>\n",[113],{"type":14,"tag":64,"props":114,"children":115},{"__ignoreMap":7},[116],{"type":20,"value":111},{"type":14,"tag":22,"props":118,"children":119},{},[120,122,128,130,136],{"type":20,"value":121},"它会先执行 scripts 中的 ",{"type":14,"tag":64,"props":123,"children":125},{"className":124},[],[126],{"type":20,"value":127},"vscode:prepublish",{"type":20,"value":129}," 命令。从上面可以看出，会先对 Webview 相关的代码进行构建（本质是 CLI 提供的构建能力），得到 js 、html 、css 代码，然后使用 ",{"type":14,"tag":64,"props":131,"children":133},{"className":132},[],[134],{"type":20,"value":135},"tsc",{"type":20,"value":137}," 对插件源代码（./src/**）进行编译。",{"type":14,"tag":22,"props":139,"children":140},{},[141,143,148,150,155,157,163,165,170],{"type":20,"value":142},"等待 ",{"type":14,"tag":64,"props":144,"children":146},{"className":145},[],[147],{"type":20,"value":127},{"type":20,"value":149}," 执行完成后， ",{"type":14,"tag":64,"props":151,"children":153},{"className":152},[],[154],{"type":20,"value":79},{"type":20,"value":156}," 将执行剩下的插件打包操作，最后会在项目根目录下出现一个 .vsix 文件，也就是我们成功打包出来的插件。现在，整个插件的体积是 ",{"type":14,"tag":158,"props":159,"children":160},"strong",{},[161],{"type":20,"value":162},"35M",{"type":20,"value":164},"，在 VS Code 中启动速度大概为 ",{"type":14,"tag":158,"props":166,"children":167},{},[168],{"type":20,"value":169},"8s",{"type":20,"value":171},"。插件启动效果图如下：",{"type":14,"tag":22,"props":173,"children":174},{},[175],{"type":14,"tag":176,"props":177,"children":179},"img",{"alt":7,"src":178},"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-fbf1b8f5b23a29b359d922f428152455_b.webp",[],{"type":14,"tag":22,"props":181,"children":182},{},[183],{"type":20,"value":184},"那我们有办法知道究竟是哪些文件导致这个 .vsix 文件这么大的吗？答案是有的。我们只需要把 .vsix 的后缀改成 .zip，然后把这个 zip 文件进行解压，即可看到整个插件是由哪些文件构成了。",{"type":14,"tag":59,"props":186,"children":188},{"code":187},"\u003Ccode class=\"language-text\">workspace/ice/iceworks/extensions/iceworks-page-builder/iceworks-page-builder-0.1.7\n└── extension\n   ├── CHANGELOG.md\n   ├── README.en.md\n   ├── README.md\n   ├── assets\n   ├── build                     # 1.86M\n        ├── assets\n      ├── css\n        |   └── index.css\n      ├── extension.js\n      ├── favicon.png\n      ├── index.html\n      ├── js\n      |  └── index.js\n      └── services\n         └── index.js\n   ├── node_modules              # 69.6M\n   ├── package.json\n   ├── package.nls.json\n   └── package.nls.zh-cn.json\u003C/code>\n",[189],{"type":14,"tag":64,"props":190,"children":191},{"__ignoreMap":7},[192],{"type":20,"value":187},{"type":14,"tag":22,"props":194,"children":195},{},[196],{"type":20,"value":197},"可以看出其中的 node_modules 目录的体积是最大的，这是导致插件体积过大的问题。另外，build 目录和node_modules 目录下有很多模块，正是如此，VS Code 在加载我们的插件的过程中，会加载很多小模块，这就是加载过慢的原因。",{"type":14,"tag":15,"props":199,"children":201},{"id":200},"使用-webpack-进行打包",[202],{"type":20,"value":203},"使用 webpack 进行打包",{"type":14,"tag":22,"props":205,"children":206},{},[207],{"type":20,"value":208},"相信大部分的前端开发者都知道，现在的模块化的前端开发范式非常流行，与此同时出现了很多模块构建工具，比如 Rollup、webpack 等。这些模块构建工具的出发点之一是，把多个模块打包成一个模块，解决加载多个模块速度过慢的问题。那我们能不能用这些构建工具，把多个小的源文件打包成单个入口文件，从而解决上述的问题呢？答案是肯定的。",{"type":14,"tag":22,"props":210,"children":211},{},[212,214,220,222,228,230,235,237,242,244,249,251,256,258,264,266,272,274,280],{"type":20,"value":213},"首先我们需要安装一下 ",{"type":14,"tag":64,"props":215,"children":217},{"className":216},[],[218],{"type":20,"value":219},"webpack",{"type":20,"value":221}," 和 ",{"type":14,"tag":64,"props":223,"children":225},{"className":224},[],[226],{"type":20,"value":227},"webpack-cli",{"type":20,"value":229}," ，其中， ",{"type":14,"tag":64,"props":231,"children":233},{"className":232},[],[234],{"type":20,"value":219},{"type":20,"value":236}," 是 Webpack 的核心模块， ",{"type":14,"tag":64,"props":238,"children":240},{"className":239},[],[241],{"type":20,"value":227},{"type":20,"value":243}," 是 ",{"type":14,"tag":64,"props":245,"children":247},{"className":246},[],[248],{"type":20,"value":219},{"type":20,"value":250}," 的 CLI 程序，用来在命令行中调用 ",{"type":14,"tag":64,"props":252,"children":254},{"className":253},[],[255],{"type":20,"value":219},{"type":20,"value":257}," 。另外还需要安装 ",{"type":14,"tag":64,"props":259,"children":261},{"className":260},[],[262],{"type":20,"value":263},"ts-loader",{"type":20,"value":265}," ，用于加载 ",{"type":14,"tag":64,"props":267,"children":269},{"className":268},[],[270],{"type":20,"value":271},"ts",{"type":20,"value":273}," 代码并编译成 ",{"type":14,"tag":64,"props":275,"children":277},{"className":276},[],[278],{"type":20,"value":279},"js",{"type":20,"value":281}," 代码。",{"type":14,"tag":59,"props":283,"children":285},{"code":284},"\u003Ccode class=\"language-text\">npm i --save-dev webpack webpack-cli ts-loader\u003C/code>\n",[286],{"type":14,"tag":64,"props":287,"children":288},{"__ignoreMap":7},[289],{"type":20,"value":284},{"type":14,"tag":22,"props":291,"children":292},{},[293,295,301],{"type":20,"value":294},"安装完成以后，我们需要在根目录下新建一个 ",{"type":14,"tag":64,"props":296,"children":298},{"className":297},[],[299],{"type":20,"value":300},"webpack.config.js",{"type":20,"value":302}," ，并增加以下的内容：",{"type":14,"tag":59,"props":304,"children":306},{"code":305},"\u003Ccode class=\"language-js\">const path = require('path');\n\nconst tsConfigPath = path.join(__dirname, 'tsconfig.json');\n\nconst config = {\n  target: 'node',\n  entry: './src/extension.ts',\n  output: {\n    path: path.resolve(__dirname, 'build'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2',\n    devtoolModuleFilenameTemplate: '../[resource-path]',\n  },\n  externals: {\n    vscode: 'commonjs vscode'\n  },\n  resolve: {\n    extensions: ['.ts', '.js'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              configFile: tsConfigPath,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n\nmodule.exports = (env, argv) => {\n  if (argv.mode === 'development') {\n    config.devtool = 'source-map';\n  }\n\n  return config;\n};\u003C/code>\n",[307],{"type":14,"tag":64,"props":308,"children":309},{"__ignoreMap":7},[310],{"type":20,"value":305},{"type":14,"tag":22,"props":312,"children":313},{},[314,316,322,324,330,332,337],{"type":20,"value":315},"修改 ",{"type":14,"tag":64,"props":317,"children":319},{"className":318},[],[320],{"type":20,"value":321},"package.json",{"type":20,"value":323}," 中 ",{"type":14,"tag":64,"props":325,"children":327},{"className":326},[],[328],{"type":20,"value":329},"scripts",{"type":20,"value":331}," 的内容，以使用 ",{"type":14,"tag":64,"props":333,"children":335},{"className":334},[],[336],{"type":20,"value":219},{"type":20,"value":338}," 进行打包：",{"type":14,"tag":59,"props":340,"children":342},{"code":341},"\u003Ccode class=\"language-json\">{\n    \"scripts\": {\n    \"vscode:prepublish\": \"rm -rf build && npm run build:web && webpack --mode production\",\n    \"build:web\": \"cd web && npm run build\",\n    \"watch:web\": \"cd web && npm run start\",\n    \"webpack\": \"webpack --mode development\",\n    \"webpack-dev\": \"webpack --mode development --watch\"\n  },\n}\u003C/code>\n",[343],{"type":14,"tag":64,"props":344,"children":345},{"__ignoreMap":7},[346],{"type":20,"value":341},{"type":14,"tag":22,"props":348,"children":349},{},[350,352,357,359,365,367,373],{"type":20,"value":351},"由于经过 ",{"type":14,"tag":64,"props":353,"children":355},{"className":354},[],[356],{"type":20,"value":219},{"type":20,"value":358}," 打包后， bundle 中都已经包括了需要的模块。我们可以修改 ",{"type":14,"tag":64,"props":360,"children":362},{"className":361},[],[363],{"type":20,"value":364},".vscodeignore",{"type":20,"value":366}," 的内容，把插件打包中不需要的文件忽略掉，当然我们的 ",{"type":14,"tag":64,"props":368,"children":370},{"className":369},[],[371],{"type":20,"value":372},"node_modules",{"type":20,"value":374}," 也可以忽略掉：",{"type":14,"tag":59,"props":376,"children":378},{"code":377},"\u003Ccode class=\"language-text\">.vscode\nnode_modules\nsrc/\nweb/\ntsconfig.json\nwebpack.config.js\u003C/code>\n",[379],{"type":14,"tag":64,"props":380,"children":381},{"__ignoreMap":7},[382],{"type":20,"value":377},{"type":14,"tag":22,"props":384,"children":385},{},[386,388,394],{"type":20,"value":387},"以上的相关配置可以点击",{"type":14,"tag":43,"props":389,"children":392},{"href":390,"rel":391},"https://link.zhihu.com/?target=https%3A//github.com/ice-lab/iceworks/tree/v0.3.0/extensions/iceworks-page-builder",[47],[393],{"type":20,"value":50},{"type":20,"value":395},"进行查看。",{"type":14,"tag":22,"props":397,"children":398},{},[399,401,408],{"type":20,"value":400},"在官方文档中，有一个章节专门讲解了如何使用 webpack 对插件进行打包。更详细的步骤可以参考",{"type":14,"tag":43,"props":402,"children":405},{"href":403,"rel":404},"https://link.zhihu.com/?target=https%3A//code.visualstudio.com/api/working-with-extensions/bundling-extension",[47],[406],{"type":20,"value":407},"文档",{"type":20,"value":409},"。**",{"type":14,"tag":15,"props":411,"children":413},{"id":412},"使用-externals-减少-bundle-体积",[414],{"type":20,"value":415},"使用 externals 减少 bundle 体积",{"type":14,"tag":22,"props":417,"children":418},{},[419],{"type":20,"value":420},"当配制好 webpack 相关配置，使用 webpack 打包构建插件时，出现以下的错误：",{"type":14,"tag":22,"props":422,"children":423},{},[424],{"type":14,"tag":176,"props":425,"children":427},{"alt":7,"src":426},"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-0281fdef1bde4672c98eb45a0367ad36_1440w.jpg",[],{"type":14,"tag":22,"props":429,"children":430},{},[431,433,440],{"type":20,"value":432},"大概的问题是，使用 webpack 在生产环境下进行打包时，会使用 ",{"type":14,"tag":43,"props":434,"children":437},{"href":435,"rel":436},"https://link.zhihu.com/?target=https%3A//github.com/terser/terser",[47],[438],{"type":20,"value":439},"terser",{"type":20,"value":441}," 对源码进行压缩。但是我们的 bundle 太大了（预计 bundle 的大小超过10M的时候），导致在压缩的过程中出现内存溢出的问题。",{"type":14,"tag":22,"props":443,"children":444},{},[445,447,453],{"type":20,"value":446},"我们使用 ",{"type":14,"tag":64,"props":448,"children":450},{"className":449},[],[451],{"type":20,"value":452},"webpack-bundle-analyzer",{"type":20,"value":454}," 来分析 bundle 的组成。 bundle 的依赖模块组成具体如下图：",{"type":14,"tag":22,"props":456,"children":457},{},[458],{"type":14,"tag":176,"props":459,"children":461},{"alt":7,"src":460},"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-1214a43d4854d3899346cd1f6a91b168_1440w.jpg",[],{"type":14,"tag":22,"props":463,"children":464},{},[465,467,473],{"type":20,"value":466},"可以看出我们项目依赖的 ",{"type":14,"tag":64,"props":468,"children":470},{"className":469},[],[471],{"type":20,"value":472},"prettier",{"type":20,"value":474}," 占用了 bundle 中非常大的体积。那我们现在需要借助 webpack 中的 externals，不要把该依赖打包到 bundle 中，而是作为一个外部扩展，在运行时再去从外部获取依赖。",{"type":14,"tag":22,"props":476,"children":477},{},[478],{"type":20,"value":479},"我们可以先在 webpack.config.js 中配置 externals :",{"type":14,"tag":59,"props":481,"children":483},{"code":482},"\u003Ccode class=\"language-js\">module.exports = {\n  externals: {\n    vscode: 'commonjs vscode',\n  + prettier: 'commonjs prettier'\n  },\n}\u003C/code>\n",[484],{"type":14,"tag":64,"props":485,"children":486},{"__ignoreMap":7},[487],{"type":20,"value":482},{"type":14,"tag":22,"props":489,"children":490},{},[491,493,498],{"type":20,"value":492},"确保插件在打包的时候，相关依赖也存在于插件中，需要在 ",{"type":14,"tag":64,"props":494,"children":496},{"className":495},[],[497],{"type":20,"value":364},{"type":20,"value":499}," 文件中加入以下内容（这里真的踩了坑了）：",{"type":14,"tag":59,"props":501,"children":503},{"code":502},"\u003Ccode class=\"language-text\">!node_modules/prettier\u003C/code>\n",[504],{"type":14,"tag":64,"props":505,"children":506},{"__ignoreMap":7},[507],{"type":20,"value":502},{"type":14,"tag":22,"props":509,"children":510},{},[511,513,518,520,525],{"type":20,"value":512},"配置完成后，再进行打包，最后打包的插件体积为 ",{"type":14,"tag":158,"props":514,"children":515},{},[516],{"type":20,"value":517},"3.6M",{"type":20,"value":519},"，在 VS Code 中启动速度降到了 ",{"type":14,"tag":158,"props":521,"children":522},{},[523],{"type":20,"value":524},"1s",{"type":20,"value":526}," ，效果图如下：",{"type":14,"tag":22,"props":528,"children":529},{},[530],{"type":14,"tag":176,"props":531,"children":533},{"alt":7,"src":532},"/images/2021-12-02-vscode-plugins-big/2021-11-30-07-00-08v2-7fa4f670dae3d7e42f8b8e62e041289d_b.jpg",[],{"type":14,"tag":15,"props":535,"children":537},{"id":536},"总结",[538],{"type":20,"value":536},{"type":14,"tag":22,"props":540,"children":541},{},[542],{"type":20,"value":543},"如果大家在打包 VS Code 插件时，如果打包出来的插件的体积过大，不妨可以考虑使用 webpack 对你的 VS Code 插件进行打包，会让你的插件有更小的体积，更快的启动速度，更好的用户体验。",{"title":7,"searchDepth":545,"depth":545,"links":546},2,[547,548,549,550,551],{"id":17,"depth":545,"text":17},{"id":34,"depth":545,"text":34},{"id":200,"depth":545,"text":203},{"id":412,"depth":545,"text":415},{"id":536,"depth":545,"text":536},"markdown","content:tool:2021-12-02-vscode-plugins-big.md","content","tool/2021-12-02-vscode-plugins-big.md","md","2021-12-02",[559,569,696,745,797,810,920],{"title":560,"_path":561,"children":562},"Art","/art",[563,566],{"title":564,"_path":565},"如何用蒙版将两个图过渡融合","/art/2020-09-03-ps-ronghe-pics",{"title":567,"_path":568},"像素画入门","/art/2022-02-02-xiangsuhuarumen",{"title":570,"_path":571,"children":572},"Dotnet","/dotnet",[573,576,579,582,585,588,591,594,597,600,603,606,609,612,615,618,621,624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675,678,681,684,687,690,693],{"title":574,"_path":575},"Linux部署dotnetcore记录","/dotnet/2019-06-05-linux-dotnet-daemon",{"title":577,"_path":578},"时间轮的引入","/dotnet/2019-10-29-time-wheel",{"title":580,"_path":581},"帧同步的相关问题","/dotnet/2019-11-01-lock-step",{"title":583,"_path":584},"状态同步的相关问题","/dotnet/2019-11-01-state-sync-npc",{"title":586,"_path":587},"状态同步--技能系统的同步机制分析","/dotnet/2019-11-02-state-sync-skill",{"title":589,"_path":590},"Creating a Quartz.NET hosted service with ASP.NET Core","/dotnet/2019-11-05-quartz",{"title":592,"_path":593},"DatetimeOffset和Datetime的区别","/dotnet/2019-12-01-datetimeoffset",{"title":595,"_path":596},"大小端字节序(Big Endian和Little Endian)","/dotnet/2020-01-05-big-little-endian",{"title":598,"_path":599},"dll文件的加载","/dotnet/2020-01-06-dll-load",{"title":601,"_path":602},"延迟补偿在C/S架构游戏协议设计和优化中的应用","/dotnet/2020-02-02-latency_compensating_methods_in_clientserver_in-game_protocol_design_and_optimization",{"title":604,"_path":605},"延迟补偿和对时的相关总结","/dotnet/2020-02-02-latency_compensating-rtt",{"title":607,"_path":608},"快节奏多人游戏同步(1)-ClientServer架构","/dotnet/2020-02-02-net-sync-client-server-game-architecture",{"title":610,"_path":611},"快节奏多人游戏同步(2)-客户端预测与服务器校对","/dotnet/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation",{"title":613,"_path":614},"快节奏多人游戏同步(3)-Entity插值","/dotnet/2020-02-02-net-sync-entity-interpolation",{"title":616,"_path":617},"快节奏多人游戏同步(4)-延时补偿","/dotnet/2020-02-02-net-sync-lag-compensation",{"title":619,"_path":620},"守望先锋等FPS游戏的网络同步","/dotnet/2020-02-02-overwatch-a-guide-to-understanding-netcode",{"title":622,"_path":623},"起源引擎网络同步模型","/dotnet/2020-02-02-source_multiplayer_networking",{"title":625,"_path":626},"orleans的部署模式","/dotnet/2020-02-03-orleans-deployment",{"title":628,"_path":629},"一致性hash算法","/dotnet/2020-02-06-consistent_hash",{"title":631,"_path":632},"地图的aoi","/dotnet/2020-02-07-aoi",{"title":634,"_path":635},"游戏的匹配机制ELO","/dotnet/2020-02-09-room-elo",{"title":637,"_path":638},"C# 深浅复制","/dotnet/2020-02-10-icloneable",{"title":640,"_path":641},"C#引用类型对象在循环引用时会不会内存泄漏","/dotnet/2020-02-11-gc",{"title":643,"_path":644},"扒一扒.net、.net framework、mono和Unity","/dotnet/2020-02-12-netcore-mono-netframework",{"title":646,"_path":647},"c#编译和运行启动原理","/dotnet/2020-02-13-csharp-run",{"title":649,"_path":650},"abp新建项目指南","/dotnet/2020-05-29-abp-start",{"title":652,"_path":653},"2020 06 11 IdentityServer Use","/dotnet/2020-06-11-identityserver-use",{"title":655,"_path":656},"关于abp的用户的一些问题","/dotnet/2020-07-05-abp-database-user",{"title":658,"_path":659},"abp的dOC模块使用","/dotnet/2020-07-10-abp-doc",{"title":661,"_path":662},"abp默认语言规则","/dotnet/2020-07-15-abp-default-language",{"title":664,"_path":665},"Orleans 最佳实践","/dotnet/2020-08-09-orleans-best-practices",{"title":667,"_path":668},"c#特性参数","/dotnet/2020-08-10-param-attribute",{"title":670,"_path":671},".NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal","/dotnet/2020-08-11-httpcontextaccessor-asynclocal",{"title":673,"_path":674},"Kestrel源码分析","/dotnet/2020-08-15-kestrel-source-code",{"title":676,"_path":677},"ConcurrentDictionary并发字典","/dotnet/2020-08-16-concurrentdictionary",{"title":679,"_path":680},"IOptions、IOptionsMonitor以及IOptionsSnapshot","/dotnet/2020-08-17-netcore-options",{"title":682,"_path":683},".NET Core/Framework 创建委托以大幅度提高反射调用的性能","/dotnet/2020-11-13-reflection-method",{"title":685,"_path":686},"C＃枚举中使用Flags特性","/dotnet/2020-11-24-flags",{"title":688,"_path":689},"谷歌浏览器下netcore登录失败问题","/dotnet/2020-12-11-chrome-login-fail",{"title":691,"_path":692},"Converting between Structs and Byte Arrays","/dotnet/2021-05-01-converting-between-structs-and-byte-arrays",{"title":694,"_path":695},"c#在重写object中的Equal方法时需要对GetHashCode进行重写（Dictionary引用）","/dotnet/2022-08-15-equal-hashcode",{"title":697,"_path":698,"children":699},"Game","/game",[700,703,706,709,712,715,718,721,724,727,730,733,736,739,742],{"title":701,"_path":702},"使用柏林噪声算法生成地图","/game/2021-01-20-perlin-map",{"title":704,"_path":705},"波函数坍塌算法生成地图","/game/2021-01-21-wave-collapse-function",{"title":707,"_path":708},"文明6地图生成算法","/game/2021-01-22-civ-map",{"title":710,"_path":711},"roguelike地牢生成算法","/game/2021-01-23-roguelike-map",{"title":713,"_path":714},"Spelunky关卡生成","/game/2021-01-23-spelunky-map",{"title":716,"_path":717},"Edgar源代码解读","/game/2021-06-12-edgar-code-read",{"title":719,"_path":720},"rpgbuild的一些备注","/game/2021-06-15-rpgbuilder",{"title":722,"_path":723},"游戏人物设计","/game/2021-08-05-game-task-design",{"title":725,"_path":726},"unity gameplay ability源代码解析","/game/2021-12-14-untiy-gameplay-ablility-sourcecode",{"title":728,"_path":729},"苟与剑游戏技能分析","/game/2021-12-21-gyj-skill",{"title":731,"_path":732},"quest machine 使用相关","/game/2022-02-19-quest-machine",{"title":734,"_path":735},"苟与剑中的单位生成方式","/game/2022-03-16-gyj-map",{"title":737,"_path":738},"ecs中实体创建方法","/game/2022-08-03-ecs",{"title":740,"_path":741},"暗黑2怪物等级和掉落规则","/game/2022-08-05-dia2",{"title":743,"_path":744},"行为树源代码解析","/game/2022-08-21-behavior-tree-source-code",{"title":746,"_path":747,"children":748},"Gyj","/gyj",[749,752,755,758,761,764,767,770,773,776,779,782,785,788,791,794],{"title":750,"_path":751},"美术要求","/gyj/2022-06-11-meishuyaoqiu",{"title":753,"_path":754},"游戏基础知识","/gyj/2022-06-12-jichuzhishi",{"title":756,"_path":757},"2022 08 22 地图房间的种类","/gyj/2022-08-22-detufangjiandezhonglei",{"title":759,"_path":760},"2022 08 22 奇遇事件","/gyj/2022-08-22-qiyushijian",{"title":762,"_path":763},"游戏流程","/gyj/2022-08-22-youxiliucheng",{"title":765,"_path":766},"物品产出表","/gyj/2022-08-22-wupinchanchubiao",{"title":768,"_path":769},"玩法","/gyj/2022-08-22-wanfa",{"title":771,"_path":772},"初入江湖","/gyj/2022-08-22-diyizhang",{"title":774,"_path":775},"2022 08 22 职业与工作","/gyj/2022-08-22-zhiyeyugongzuo",{"title":777,"_path":778},"天下霸图研究","/gyj/2022-11-01-tianxiabatu",{"title":780,"_path":781},"流放之路关于伤害公式和技能的分析","/gyj/2022-11-17-liufangzhilu",{"title":783,"_path":784},"门派内容相关","/gyj/2022-11-17-sect",{"title":786,"_path":787},"2022 12 01 养殖","/gyj/2022-12-01-yangzhi",{"title":789,"_path":790},"种植","/gyj/2022-12-01-zhongzhi",{"title":792,"_path":793},"人物属性设计","/gyj/2022-12-15-renwushuxing",{"title":795,"_path":796},"跑商","/gyj/2023-11-01-paoshang",{"title":798,"_path":799,"children":800},"Js","/js",[801,804,807],{"title":802,"_path":803},"如何在TypeScript中使用JS类库","/js/2022-02-12-typescript-use-js",{"title":805,"_path":806},"nuxt3项目初始化失败","/js/2023-05-16-nuxt3-init-fail",{"title":808,"_path":809},"Flex 布局使用","/js/2024-03-17-flex-use",{"title":811,"_path":812,"children":813},"Tool","/tool",[814,817,820,823,826,829,832,835,838,841,844,847,850,853,856,859,862,865,868,871,874,877,880,883,886,889,892,895,896,899,902,905,908,911,914,917],{"title":815,"_path":816},"windows发送到手机Ftp","/tool/2019-06-20-windows-send-to-ftp",{"title":818,"_path":819},"windows特殊目录修复","/tool/2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows",{"title":821,"_path":822},"scourcetree  总是需要输入密码","/tool/2019-08-07-sourcetree-git-password",{"title":824,"_path":825},"powershell 常用命令","/tool/2019-08-10-powershell-command",{"title":827,"_path":828},"scoop的使用","/tool/2019-08-20-scoop-use",{"title":830,"_path":831},"使用配置文件来管理NuGet包版本F","/tool/2019-09-02-nuget-manager",{"title":833,"_path":834},"Redis的两种持久化RDB和AOF","/tool/2019-09-02-redis-aof-rdb",{"title":836,"_path":837},"使用 SSH 登陆谷歌云 root 或者 普通账户的方法","/tool/2020-01-02-google-clound-local-login",{"title":839,"_path":840},"CentOS 下安装Shadowsocks 搭建ss","/tool/2020-01-12-centosn-ss-install",{"title":842,"_path":843},"mac下brew 使用","/tool/2020-01-13-brew",{"title":845,"_path":846},"术语中英文对照","/tool/2020-02-05-game_en_zh",{"title":848,"_path":849},"Excel中以文本形式存储的数字","/tool/2020-02-06-excel-text-number",{"title":851,"_path":852},"protobuf序列化的一些问题","/tool/2020-03-25-protobuf-empty-collections",{"title":854,"_path":855},"为博客将 RSS 转为邮件订阅","/tool/2020-06-26-blog-mail-sub",{"title":857,"_path":858},"github下载代码的速度太慢","/tool/2020-06-27-linux-github-slow",{"title":860,"_path":861},"win10开始菜单添加软件以及备份和恢复","/tool/2020-07-02-win10-start-menu",{"title":863,"_path":864},"gitbook的使用","/tool/2020-07-06-gitbook-use",{"title":866,"_path":867},"github actions 简单使用","/tool/2020-07-11-github-actions",{"title":869,"_path":870},"使用hexo建立博客并部署到github","/tool/2020-07-12-hexo-github",{"title":872,"_path":873},"终端下设置代理","/tool/2020-07-13-terminal-proxy",{"title":875,"_path":876},"发现nuget包太占用C盘，怎么办？","/tool/2020-08-30-nuget-is-big",{"title":878,"_path":879},"unity商店下载资源迁移","/tool/2020-11-15-unity-is-big",{"title":881,"_path":882},"关于coding的pages介绍","/tool/2020-11-16-coding-pages",{"title":884,"_path":885},"一些常用的dns服务器","/tool/2021-05-06-dns",{"title":887,"_path":888},"UE4素材破解","/tool/2021-11-06-ue4-view",{"title":890,"_path":891},"安装cockpit通过nginx代理访问","/tool/2021-11-07-cockpit-linux",{"title":893,"_path":894},"Windows LTSC、LTSB、Server 安装 Windows Store 应用商店 ","/tool/2021-11-15-install-windowsstore",{"title":8,"_path":4},{"title":897,"_path":898},"云效部署hexo到自己的主机 ","/tool/2021-12-11-yunxiao-liushuixian-hexo",{"title":900,"_path":901},"github 怎么合并原始分支？ ","/tool/2021-12-12-github-sync",{"title":903,"_path":904},"code server安装制作online ide","/tool/2022-01-30-code-server",{"title":906,"_path":907},"rider的使用","/tool/2022-08-02-rider-use",{"title":909,"_path":910},"2022 08 09 Amd Over","/tool/2022-08-09-amd-over",{"title":912,"_path":913},"rider破解","/tool/2022-11-19-rider-po-jie",{"title":915,"_path":916},"stable diffusion install","/tool/2023-01-20-stable-diffusion-install",{"title":918,"_path":919},"CGI, FastCGI, WSGI, uWSGI, uwsgi一文搞懂","/tool/2023-02-15-cgi-fastcgi-wsgi-uswgi",{"title":921,"_path":922,"children":923},"Unity","/unity",[924,927,930,933,936,939,942,945,948,951,954,957,960,963,966,969,972,975,978,981,984,987,990,993,996,999,1002,1005,1008,1011,1014,1017,1020,1023,1026,1029,1032,1035,1038,1041,1044,1047,1050,1053,1056,1059,1062,1065,1068,1071,1074,1077,1080,1083,1086,1089,1092,1095,1098,1101,1104,1107,1110,1113,1116,1119,1122,1125,1128,1131,1134,1137],{"title":925,"_path":926},"Unity 导出 Android 64-bit 版本","/unity/2019-06-20-unity-android-x64",{"title":928,"_path":929},"Unity的il2cpp","/unity/2019-06-20-unity-il2cpp-debugger",{"title":931,"_path":932},"googlePlay 发布问题","/unity/2019-06-23-googlplay-pulish",{"title":934,"_path":935},"关于unity的适配问题","/unity/2019-08-09-unity2d-shipei",{"title":937,"_path":938},"一次精通 RectTransform","/unity/2019-08-10-ugui-recttransform",{"title":940,"_path":941},"一次精通 eventmanager","/unity/2019-08-11-ugui-eventmanager",{"title":943,"_path":944},"ugui的eventsystem源码解读","/unity/2019-08-12-ugui-eventsystem-sourcecode",{"title":946,"_path":947},"Unity Raycasters 剖析","/unity/2019-08-12-ugui-raycasters",{"title":949,"_path":950},"关于addressable那些事","/unity/2019-09-01-addressable",{"title":952,"_path":953},"关于spriteAtlas打包那些事","/unity/2019-09-01-spriteatlas",{"title":955,"_path":956},"ilruntime的研究","/unity/2019-09-02-ilruntime",{"title":958,"_path":959},"unity的宏以及添加net框架中未引用的dll","/unity/2019-09-02-unity-reference-dll",{"title":961,"_path":962},"xlua注入源码解读","/unity/2019-09-03-xlua-inject",{"title":964,"_path":965},"如何快速的注入汇编","/unity/2019-09-04-mono.cecil-inject",{"title":967,"_path":968},"2D游戏视差背景的实现","/unity/2019-09-13-parallax-2d",{"title":970,"_path":971},"unity使用代理","/unity/2019-11-15-unity-proxy",{"title":973,"_path":974},"一篇文章搞定Entitas","/unity/2020-01-01-unity-entitas",{"title":976,"_path":977},"unity攻击范围检测的方式区别","/unity/2020-01-11-unity-attack-range-detection-type",{"title":979,"_path":980},"常见的2D碰撞检测","/unity/2020-01-12-collision-detection",{"title":982,"_path":983},"unity攻击范围检测","/unity/2020-01-13-unity-attack-detection",{"title":985,"_path":986},"技能系统","/unity/2020-02-15-skill-system",{"title":988,"_path":989},"游戏buff系统设计","/unity/2020-02-16-buff-system",{"title":991,"_path":992},"角色状态设计","/unity/2020-02-17-character-states",{"title":994,"_path":995},"理解托管堆","/unity/2020-02-18-bestpracticeunderstandingperformanceinunity",{"title":997,"_path":998},"理解自动内存管理","/unity/2020-02-19-understandingautomaticmemorymanagement",{"title":1000,"_path":1001},"unity 移动平台打包丢失shader的问题","/unity/2020-02-20-shader-lost",{"title":1003,"_path":1004},"Unity的调试相关","/unity/2020-03-01-unity-debug",{"title":1006,"_path":1007},"unity启动运行脚本流程","/unity/2020-03-04-unity-startup",{"title":1009,"_path":1010},"unity的坐标体系","/unity/2020-07-01-unity-coordinate",{"title":1012,"_path":1013},"2020 07 03 Unity Mesh","/unity/2020-07-03-unity-mesh",{"title":1015,"_path":1016},"unity Render Pipeline","/unity/2020-07-04-unity-render-pipeline",{"title":1018,"_path":1019},"Notch Solution","/unity/2020-08-29-notch-solution",{"title":1021,"_path":1022},"unity 项目dll检查","/unity/2020-08-30-unity-dll-check",{"title":1024,"_path":1025},"UNITY的垂直同步和帧率","/unity/2020-09-05-unity-vsynccount",{"title":1027,"_path":1028},"UNITY性能优化流程","/unity/2020-09-10-optimizing-for-performance",{"title":1030,"_path":1031},"堆栈内存Stack和堆内存Heap","/unity/2020-09-11-stack-heap",{"title":1033,"_path":1034},"unity的addressables","/unity/2020-09-12-addressables",{"title":1036,"_path":1037},"游戏中的向量使用","/unity/2020-09-13-vector",{"title":1039,"_path":1040},"UNITY ECS 详解","/unity/2020-10-15-unity-ecs",{"title":1042,"_path":1043},"UNITY JOB SYSTEM详解","/unity/2020-10-16-unity-job",{"title":1045,"_path":1046},"运行时打包图集","/unity/2020-10-17-runtime-spriteatlas",{"title":1048,"_path":1049},"unity ecs component","/unity/2020-10-18-unity-ecs-component",{"title":1051,"_path":1052},"基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流","/unity/2020-10-19-game-object-conversion-and-subscene",{"title":1054,"_path":1055},"源代码分析world的创建","/unity/2020-10-20-ecs-world",{"title":1057,"_path":1058},"unity使用platforms构建","/unity/2020-10-21-platform",{"title":1060,"_path":1061},"Unity rendering order渲染顺序","/unity/2020-10-22-unity-render-order",{"title":1063,"_path":1064},"关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析","/unity/2020-10-23-unity-optimizing-gpu",{"title":1066,"_path":1067},"unity的ScreenToWorldPoint","/unity/2020-10-24-screentoworldpoint",{"title":1069,"_path":1070},"URP性能测试","/unity/2020-10-24-unity-urp-performance",{"title":1072,"_path":1073},"如何使用Unity ECS打造Reactive System？","/unity/2020-11-11-how-to-build-reactive-systems-with-unity-ecs",{"title":1075,"_path":1076},"Unity中Sprite和UI Image的区别","/unity/2020-11-12-sprite-image-diff",{"title":1078,"_path":1079},"简单保存工具","/unity/2020-11-13-simple-save",{"title":1081,"_path":1082},"2020 11 14 Netcode","/unity/2020-11-14-netcode",{"title":1084,"_path":1085},"ecs中的parent","/unity/2020-11-15-ecs-parent",{"title":1087,"_path":1088},"ability","/unity/2020-11-16-dotssample",{"title":1090,"_path":1091},"unity world time system","/unity/2020-11-17-unity-ecs-worldtime",{"title":1093,"_path":1094},"netcode源代码解读","/unity/2020-11-18-netcode-sourcecode",{"title":1096,"_path":1097},"pitch yaw roll是什么","/unity/2020-11-29-pitch-yaw-roll",{"title":1099,"_path":1100},"A Native Collection has not been disposed, resulting in a memory leak. Allocated from:","/unity/2020-12-20-collection-has-not-been-disposed",{"title":1102,"_path":1103},"解决Unity鼠标坐标点转成世界坐标系坐标点","/unity/2021-01-24-screentoworld",{"title":1105,"_path":1106},"2021 01 25 Tilemap","/unity/2021-01-25-tilemap",{"title":1108,"_path":1109},"Unity RenderTexture的应用","/unity/2021-04-11-render-texture",{"title":1111,"_path":1112},"commandbuff的一些问题","/unity/2021-05-20-ecs-commandbuff-question",{"title":1114,"_path":1115},"How to Make One Way Platform in unity","/unity/2021-06-13-how-to-make-one-way-platform",{"title":1117,"_path":1118},"UNITY的渲染顺序","/unity/2021-06-14-unity-render-order",{"title":1120,"_path":1121},"防止变量引用丢失 FormerlySerializedAs","/unity/2021-07-20-formerlyserializedas",{"title":1123,"_path":1124},"AI-PLANNER使用","/unity/2021-08-01-ai-planner",{"title":1126,"_path":1127},"Increased script assembly reload time","/unity/2021-10-01-increased-script-assembly-reload-time",{"title":1129,"_path":1130},"关于unity的热重载的研究","/unity/2022-01-02-unity-hot-reload",{"title":1132,"_path":1133},"Editor Iteration Profiler的使用","/unity/2022-01-28-unity-editor-iteration-profiler",{"title":1135,"_path":1136},"CircleCast和Overlapple的区别是什么","/unity/2022-04-02-circlecast-overlapple-diff",{"title":1138,"_path":1139},"unity ecs的备忘录","/unity/2022-09-10-ecs-beiwang",1710779037483]